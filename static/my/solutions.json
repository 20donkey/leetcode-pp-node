{"372354984":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"553269487":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992070031","body":"Lee 251 double pointer\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        int prev = - s.length(); // to assure the i - prev in first scan is bigger than any possible result;\r\n        \r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;   \r\n        }\r\n        \r\n        for(int i = prev; i >= 0; i--){ // prev not pos\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(prev - i, ans[i]);   \r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000929677","body":"Time O(N) Space O(lN) \n``` java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null && q != null) return false;\n        if(p != null && q == null) return false;\n        if(p.val != q.val) return false;\n        if(!isSameTree(p.left, q.left) || !isSameTree(p.right, q.right)) return false;\n        return true;\n    }\n    \n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"577961141":[null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000821946","body":"## 题目思路\n递归法：\n\n我自己理解的解释：\n\n递归统计左子树深度和右子树深度，然后再取左子树深度和右子树深度的最大值+1(如果遇到某个子树为空的情况就返回0)\n\n官方解释总结（人菜，只能照搬，当然我有理解了才这么做）：\n\n基本上和数搜索有关的都可以用递归来做，为什么？\n\n因为树是一种递归的数据结构。而穷举搜索一棵树必然需要遍历其所有节点，而搜索的逻辑对所有子树都是一样的。因此这就很适合用递归来解决\n\n解决递归的小方法 产品经理法\n\n所谓产品经理。只需要知道做什么事情就行，而怎么实现就不用管，那是码农的事\n\n- 定义函数的功能，不管其具体的实现\n\n需要的功能是给定一个二叉树节点，返回以这个节点为根节点的子树的最大深度。假设这个函数为f。那么问题转化为了f(root)\n\n- 确定大问题和小问题的关系\n\n要解决f(root)这个问题。可以先解决f(root.right)和f(root.left)。不难看出```f(root) = max(root.left+root.right) + 1```。\n\n到这里我们仍然不知道f怎么实现，但是我们已经完成了产品经理的需求\n\n- 补充递归的终止条件\n\n如果递归到子叶节点的时候，返回0即可。\n\n## 题目的题解code\n```PHP\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxDepth($root)\n    {\n        if ($root == null) {\n            return 0;\n        }\n\n        return max($this->maxDepth($root->left), $this->maxDepth($root->right));\n    }\n}\n\n```\n## 时间和空间复杂度\n\n令n为链表总的节点数\n- 时间复杂度：O(n)，n总共有多少个节点\n- 空间复杂度：O(h)，h是树的节点，最坏的情况是h等于n，其中n为节点数，此时树退化到链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001015487","body":"## 题目思路\n解法一: 递归法\n\n先比较两颗树的节点上的值是否相等，然后递归比较前一颗树的左子树与后一颗树的左子树是否相同，再然后递归比较前一颗树的右子树与后一颗树的右子树是否相同；\n\n递归的终止条件：\n\n当获取某个树(或者两个树)的节点都为空的时候，就返回结果\n\n解法二：层序遍历\n\n层序遍历会遍历每一层的数据，在遍历每一层的时候就直接比较就行。\n\n我采用四个队列的形式，两个正式队列，两个临时队列，两个正式队列分别存储两个树的节点，两个临时队列存储分别存储每次遍寻的两个子树的每一层\n\n\n## 题目的题解code\n解法一：\n```PHP\n\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q)\n    {\n        if (!$p || !$q) {\n            return !$p && !$q;\n        }\n\n        return $p->val === $q->val &&\n            $this->isSameTree($p->left, $q->left) &&\n            $this->isSameTree($p->right, $q->right);\n    }\n}\n```\n\n解法二：\n```php\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q)\n    {\n        $currentQueueA = [$p];\n        $currentQueueB = [$q];\n\n        while ($currentQueueA && $currentQueueB) {\n            $nextQueueA = [];\n            $nextQueueB = [];\n            $isOk = $this->isSameCurrentNode($currentQueueA, $currentQueueB, $nextQueueA, $nextQueueB);\n            if (!$isOk) {\n                return false;\n            }\n            $currentQueueA = $nextQueueA;\n            $currentQueueB = $nextQueueB;\n        }\n\n        return true;\n    }\n\n    /**\n     * 判断当前节点是否相等\n     *\n     * @param $currentQueueA\n     * @param $currentQueueB\n     * @param $nextQueueA\n     * @param $nextQueueB\n     * @return bool|false\n     * @author 陈维锐\n     * @date 2021/12/25\n     */\n    private function isSameCurrentNode($currentQueueA, $currentQueueB, &$nextQueueA, &$nextQueueB)\n    {\n        if (count($currentQueueA) !== count($currentQueueB)) {\n            return false;\n        }\n\n        for($i = 0; $i < count($currentQueueA); $i++) {\n            if (!$this->isSameNodeVal($currentQueueA[$i], $currentQueueB[$i])) {\n                return false;\n            }\n            // 这里不能用 $currentQueueA[$i]->left 来加入数组。\n            // 因为，如果$currentQueueA[$i]->left 有值 ，$currentQueueA[$i]->right 无值\n            // currentQueueB[$i]->left 无值 ，$currentQueueB[$i]->right 有值\n            // 这样会导致 $currentQueueA[$i]->left 和 $currentQueueB[$i]->right 在比较值\n            $currentQueueA[$i]  && array_push($nextQueueA, $currentQueueA[$i]->left);\n            $currentQueueB[$i]  && array_push($nextQueueB, $currentQueueB[$i]->left);\n            $currentQueueA[$i]  && array_push($nextQueueA, $currentQueueA[$i]->right);\n            $currentQueueB[$i] && array_push($nextQueueB, $currentQueueB[$i]->right);\n        }\n        return true;\n    }\n\n    /**\n     * 判断当前节点的值是否相等\n     *\n     * @param $nodeAVal\n     * @param $nodeBVal\n     * @return bool\n     * @author 陈维锐\n     * @date 2021/12/25\n     */\n    private function isSameNodeVal($nodeA, $nodeB)\n    {\n        // 这里杜绝了A节点与B节点有一个节点为null的问题（两个都为null就直接返回true）\n        if (!$nodeA || !$nodeB) {\n            return $nodeA === $nodeB;\n        }\n        return $nodeA->val === $nodeB->val;\n    }\n}\n```\n## 时间和空间复杂度\n\n令n为链表总的节点数\n- 时间复杂度：O(n)，n总共有多少个节点\n- 空间复杂度：O(h)，h是树的高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"732837590":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997380228","body":"\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        return connect(head);\n    }\n\n    public ListNode connect(ListNode node){\n        if(node == null){\n            return null;\n        }\n        //[a - b]-[c - d]-\n        ListNode left = node;\n        ListNode mid = node.next;\n        if(mid == null){\n            return left;\n        }\n        ListNode right = mid.next;\n        \n        //互逆操作\n        mid.next = left;\n        left.next = connect(right);\n        return mid;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997869941","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        if( head.next == null){\n            return new TreeNode(head.val);\n        }\n\n        //设置快慢两个指针，slow前面的节点的一个指针\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode pre = null;\n\n        while( fast != null && fast.next != null){\n            fast = fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        //循环结束后slow指针停在链表的中间\n\n        //链表断开\n        pre.next = null;\n\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n\n        slow.next = null;\n\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998416181","body":"双指针遍历\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        ListNode A = headA , B = headB;\n\n        while(A != B){\n            A = A == null ? headB : A.next;\n            B = B == null ? headA : B.next;\n        }\n\n        return A;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999246447","body":"使用双指针\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null)\n        return null;\n\n        ListNode slow = head , fast = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast)\n            break;\n        }\n\n        if(fast == null || fast.next == null)\n        return null;\n\n        ListNode p1 = head;\n        ListNode p2 = slow;//fast\n        while(p1 != p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000241762","body":"class LRUCache {\n\n    private int capacity;\n    private HashMap<Integer,Node> map;\n    private Node head,tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>(capacity);\n\n        this.head = new Node(0,0);\n        this.tail = new Node(0,0);\n\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    \n    public int get(int key) {\n        if( !this.map.containsKey(key)){\n            return -1;\n        }\n\n        Node node = this.map.get(key);\n        this.moveNode2First(node);\n        return node.value;\n\n    }\n    \n    public void put(int key, int value) {\n        if(this.map.containsKey(key)){\n            Node node = this.map.get(key);\n            node.value = value;\n            this.moveNode2First(node);\n            return;\n        }\n\n        if(this.map.size() == this.capacity){\n            Node last =this.tail.prev;\n            this.map.remove(last.key);\n            this.removeLast(last);\n        }\n\n        Node node = new Node(key,value);\n        this.map.put(key,node);\n        this.addNode2First(node);\n\n    }\n\n    private void removeLast(Node last){\n        last.prev.next = tail;\n        tail.prev = last.prev;\n\n        last.prev = null;\n        last.next = null;\n    }\n\n    public void addNode2First(Node node){\n        Node currFirst = head.next;\n\n        node.next = currFirst;\n        currFirst.prev = node;\n\n        head.next = node;\n        node.prev = head;\n    }\n\n    public void moveNode2First(Node node){\n        Node next = node.next;\n        Node prev = node.prev;\n\n        prev.next = next;\n        next.prev = prev;\n\n        this.addNode2First(node);\n    }\n\n    private class Node{\n        public Node prev,next;\n        public int key,value;\n\n        public Node(int k,int v){\n            this.key = k;\n            this.value = v;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000666909","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        return root == null ? 0 : Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001014813","body":"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001104202","body":"class Solution {\n    public int sumNumbers(TreeNode root) {\n        if(root == null) return 0;\n\n        return dfs(root,0);\n    }\n\n    private int dfs(TreeNode root,int sum){\n        if(root == null) return 0;\n\n        if(root.left == null && root.right == null){\n            return sum * 10 + root.val;\n        }else if(root.left != null && root.right == null){\n            return dfs(root.left,sum * 10 + root.val);\n        }else if(root.left == null && root.right != null){\n            return dfs(root.right,sum * 10 + root.val);\n        }else{\n            return dfs(root.left,sum * 10 + root.val) + dfs(root.right,sum * 10 + root.val);\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"965682575":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1052561252":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991881171","body":"```\n/**\n * 解题思路：先把题做出来，再考虑优化\n * <p>\n * 1.直观的看，应该属于大整数相加的问题\n * 2.对num从后向前遍历，每次遍历中对k%10获得对应位数的值t，再对k/10\n * 3.使得num[i]+t；考虑两种情况，<=9和>=10；如何是第一种情况，直接相加就行；如何是第二种情况，要考虑进位\n * <p>\n * 时间复杂度：O(n)\n *\n * @author My\n * @date 2021/12/12\n */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> temp = new ArrayList<>();\n\n        //用于进位\n        int carry = 0;\n        for (int i = num.length - 1; i >= 0; i--) {\n            int t = k % 10 + num[i] + carry;\n            if (t > 9) {\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            temp.add(t % 10);\n            k /= 10;\n        }\n\n        while (k != 0) {\n            int t = k % 10 + carry;\n            if (t > 9) {\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            temp.add(t % 10);\n            k /= 10;\n        }\n\n        if (carry != 0)\n            temp.add(carry);\n\n        List<Integer> res = new ArrayList<>();\n        for (int i = temp.size() - 1; i >= 0; i--) {\n            res.add(temp.get(i));\n        }\n\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992012722","body":"### 思路\n暂时只能想到时间复杂度为O(n*m)的解法，想不到有哪些性能更优的解法，先解出来再说吧\n1.通过字符串s生成字符串数组chars，遍历chars，获得c在chars中的位置，通过list存储\n2.再次遍历chars，如果chars[i]!=c，将i与list中保存的值进行判断，找出最小的差值并保存到answer[i]中\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int[] answer = new int[chars.length];\n\n        List<Integer> tags = new ArrayList<>();\n        //遍历chars，标记c在chars中的各个位置\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                tags.add(i);\n            }\n        }\n\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != c) {\n                int min = 200;\n                for (Integer tag : tags) {\n                    min = Math.min(min, Math.abs(i - tag));\n                }\n                answer[i] = min;\n            }\n        }\n\n        return answer;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n*m)\nn:s的长度\nm:list的长度\n\n空间复杂度：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993057214","body":"### 解题思路\n解题思路：\n1.直观上的解题方式是用数组来实现，用int变量curSize记录当前stack中元素的数量，因此curSize的初始化值为0\n2.每次调用push()时，先检查curSize是否等于maxSize。如果不是，使得stack[curSize]=x，然后curSize++\n3.每次调用pop()时，先检查curSize是否等于0。如果是，直接返回-1；如果不是，先让curSize--，然后num=stack[curSize]。最后返回num\n4.每次调用increment()时，取得curSize和k中的较小值为k，遍历stack[0]-stack[k-1]，使得stack[i]+=val\n### 代码\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int maxSize;\n    private int curSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n\n    public void push(int x) {\n        if (curSize < maxSize) {\n            stack[curSize] = x;\n            curSize++;\n        }\n    }\n\n    public int pop() {\n        if (curSize == 0) {\n            return -1;\n        }\n\n        int num = stack[curSize];\n        curSize--;\n        return num;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, curSize);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度分析\n 时间复杂度：\n- push()：O(1)\n- pop()：O(1)\n- increment()：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994813013","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995345301","body":"#### 思路\n1.stack的特性是先进后出，queue的特性是先进先出\n\n2.使用2个stack来模拟queue，stack2主要用于存储val，每次新的val都回push进stack2的栈顶\n\n3.每次要执行pop()或peek()时，先将stack2中的val暂存至stack1。因此stack2栈底的val是最先进入的，也就是要返回的数值。这些数值在放入stack1后，会到stack1的栈顶，所以才可以返回\n#### 代码\n```java\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        this.stack1 = new Stack<>();\n        this.stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack2.push(x);\n    }\n\n    public int pop() {\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        Integer pop = stack1.pop();\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        return pop;\n    }\n\n\n    public int peek() {\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        Integer peek = stack1.peek();\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        return peek;\n    }\n\n    public boolean empty() {\n        return stack2.isEmpty();\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：\n- push():O(1)\n- pop():O(n)\n- peek():O(n)\n- empty:O(1)\n\n空间复杂度：\n- O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997398789","body":"#### 解题思路\n1.只有接下来仍存在两个结点时，才需要交换这两个结点的位置，否则没有必要执行这些操作。因此可以用while循环，并且这就是循环的条件\n\n2.用正常操作交换结点的next指向就可以了，重点在于不要丢失其余结点的引用\n\n#### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //创建哨兵头节点newHead，并让newHead.next=head，使得对链表中任何结点的操作一致\n        ListNode newHead = new ListNode(-1);\n        newHead.next = head;\n\n        ListNode q = newHead;\n        //只有存在两个连续的结点时，才执行下列操作，否则不需要\n        while (q.next != null && q.next.next != null) {\n            //保存接下来的链表，防止丢失\n            ListNode p = q.next.next.next;\n            //交换两个结点\n            ListNode q1 = q.next;\n            ListNode q2 = q.next.next;\n            q.next = q2;\n            q2.next = q1;\n            q1.next = p;\n            q = q1;\n        }\n        return newHead.next;\n    }\n}\n```\n#### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997974222","body":"#### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head != null) {\n            ListNode fast = head, slow = head, preSlow = null;\n\n            // 快慢指针移动\n            while(fast != null) {\n                fast = fast.next;\n                if(fast != null){\n                    fast = fast.next;\n                    preSlow = slow;\n                    slow = slow.next;\n                }\n            }\n\n            TreeNode treeNode = new TreeNode(slow.val);\n            treeNode.right = sortedListToBST(slow.next);\n            if(preSlow != null) {\n                preSlow.next = null;\n                treeNode.left = sortedListToBST(head);\n            }\n            return treeNode;\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998820225","body":"#### 思路\n使用map，以listnode作为key，以listnode.val作为value\n#### 代码\n```java\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode q1 = headA;\n        ListNode q2 = headB;\n        while (q1 != q2) {\n            q1 = q1.next;\n            q2 = q2.next;\n            if (q1 == null && q2 == null) {\n                return null;\n            }\n            if (q1 == null) {\n                q1 = headB;\n            }\n\n            if (q2 == null) {\n                q2 = headA;\n            }\n        }\n\n        return q1;\n    }\n}\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999432618","body":"#### 解题思路\n1.最暴力的解题方法，就是使用map。以ListNode为key，以pos为value。\n2.遍历链表，并设置计数器cnt=0。先从map中取以以ListNode为key的value，如果value为null，说明目前没有形成环，将ListNode和pos放入map。\n如果value非空，说明这个结点处形成了环，直接返回这个结点。\n#### 代码\n```java\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n        Map<ListNode, Integer> map = new HashMap<>();\n        int cnt = -1;\n        while (head != null) {\n            Integer pos = map.get(head);\n            if (pos == null) {\n                map.put(head, cnt++);\n                head = head.next;\n            } else {\n                return head;\n            }\n        }\n        return null;\n    }\n}\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1149004121":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991841813","body":"### 989. 数组形式的整数加法\n### 思路\n①将数组A转成整数，再将整数A和K进行运算，再将运算结果化为数组  \n\n- 优点：不用考虑数组运算的进位问题  \n- 存在问题： 时间复杂度必然增大，因为过程包含整成整数和拆成数组2部分；最大问题是数组A长度最大为1万，超出js的16位整数长度，会导致不精确问题  \n\n②利用数组进行运算  \n通过取余和整除的方法，把k的最低位取出与数组的最低位进行和运算；在进行加和的时候因为有可能超出9，要考虑进位，可考虑把进的那一位直接加在k上；由于k和数组的相对长度不知道，所以在第一次循坏完数组之后，要再循环一次k的剩余位数。\n\n### 代码\n\n\n```java  \n\n  var addToArrayForm = function (num, k) {\n    const numLen = num.length;\n    let res = [];\n    for (let i = numLen - 1; i >= 0; i--) {\n      let sum = num[i] + k % 10;\n      k = Math.floor(k / 10);\n      if (sum > 9) {\n        k++;\n        sum -= 10;\n      }\n      res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n      let sum = k % 10;\n      res.push(sum);\n    }\n    res.reverse();\n    return res;\n  };\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(MAX(m,n))，其中m为数组长度，n为k的位数。\n- 空间复杂度：O(MAX(m,n))，其中m为数组长度，n为k的位数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992170956","body":"### 821. 字符的最短距离\n### 思路\n字符串中某个字母到最近的c字符的距离，取MIN(i-l, r-i)。由于字符串的首位不一定都是c，因此可以设最左侧的l为-infinity，最右侧的r为infinity。通过从前往后，和从后往前遍历，取最小值即为结果。\n\n### 代码\n\n\n```js   \n\nvar shortestToChar = function(s, c) {\n    let len = s.length;\n    let res = [];\n    let prev = -Infinity;\n    for(let i = 0; i < len; i++){\n        if(s[i] === c) prev = i;\n        res[i] = i - prev;\n    }\n    prev = Infinity;\n    for(let i = len - 1; i >= 0; i--){\n        if(s[i] === c) prev = i;\n        res[i] = Math.min(res[i], prev - i);\n    }\n    \n    return res;\n};\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)，2次循环遍历，线性时间复杂度。\n- 空间复杂度：O(1)，额外所用空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993147102","body":"### 1381. 设计一个支持增量操作的栈\n### 思路\n①   \n在js中没有栈，可以用数组实现，用变量存储maxSize，当数组中的个数小于maxSize时可以进行入栈操作，既push；如果栈不为空就进行pop操作；inc操作通过遍历下标从0到min(k - 1, len - 1)来操作。  \n\n②  \n在方法①中inc的时间复杂度为O(k)，若想继续降低时间复杂度，则要以空间换时间，用另一数组保存增加的信息，到pop时在讲其加回，避免反复累加。\n\n### 代码\n①  \n```js  \n\n\t /**\n\t * @param {number} maxSize\n\t */\n\tvar CustomStack = function(maxSize) {\n\t    this.maxSize = maxSize;\n\t    this.stack = [];\n\t};\n\t\n\t/** \n\t * @param {number} x\n\t * @return {void}\n\t */\n\tCustomStack.prototype.push = function(x) {\n\t    if(this.stack.length < this.maxSize){\n\t        this.stack.push(x);\n\t    }\n\t};\n\t\n\t/**\n\t * @return {number}\n\t */\n\tCustomStack.prototype.pop = function() {\n\t    if(this.stack.length === 0){\n\t        return -1\n\t    }else {\n\t        return this.stack.pop();\n\t    }\n\t};\n\t\n\t/** \n\t * @param {number} k \n\t * @param {number} val\n\t * @return {void}\n\t */\n\tCustomStack.prototype.increment = function(k, val) {\n\t    let index = Math.min(k - 1, this.stack.length - 1);\n\t    for(let i = 0; i <= index; i++){\n\t        this.stack[i] += val;\n\t    }\n\t};\n\t\n\t/**\n\t * Your CustomStack object will be instantiated and called as such:\n\t * var obj = new CustomStack(maxSize)\n\t * obj.push(x)\n\t * var param_2 = obj.pop()\n\t * obj.increment(k,val)\n\t */   \n\n```\n②  \n\n```js   \n\n\t/**\n\t * @param {number} maxSize\n\t */\n\tvar CustomStack = function(maxSize) {\n\t    this.maxSize = maxSize;\n\t    this.stack = new Array(this.maxSize).fill(0);\n\t    this.add = new Array(this.maxSize).fill(0);\n\t    this.top = -1;\n\t};\n\t\n\t/** \n\t * @param {number} x\n\t * @return {void}\n\t */\n\tCustomStack.prototype.push = function(x) {\n\t    if(this.top < this.maxSize - 1){\n\t        this.top++;\n\t        this.stack[this.top] = x;\n\t    }\n\t};\n\t\n\t/**\n\t * @return {number}\n\t */\n\tCustomStack.prototype.pop = function() {\n\t    if(this.top === -1){\n\t        return -1;\n\t    }\n\t    let val = this.add[this.top] + this.stack[this.top];\n\t    if(this.top !== 0){\n\t        this.add[this.top - 1] += this.add[this.top];\n\t    }\n\t    this.add[this.top] = 0;\n\t    this.top--;\n\t    return val;\n\t};\n\t\n\t/** \n\t * @param {number} k \n\t * @param {number} val\n\t * @return {void}\n\t */\n\tCustomStack.prototype.increment = function(k, val) {\n\t    let index = Math.min(k - 1, this.top);\n\t    if(index >= 0) this.add[index] += val;\n\t};\n\t\n\t/**\n\t * Your CustomStack object will be instantiated and called as such:\n\t * var obj = new CustomStack(maxSize)\n\t * obj.push(x)\n\t * var param_2 = obj.pop()\n\t * obj.increment(k,val)\n\t */\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：①：push、pop为O(1)，inc为O(k)；②：push、pop、inc皆为O(1)。\n- 空间复杂度：①：O(maxSize)用于保存数组；②：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994920768","body":"### 394. 字符串解码\n### 思路\n最里面最后面的[]中的内容最先计算，先进后出，考虑用栈的形式储存。当遇到数字时，先用multi保存；遇到字母的时候用res保存；当遇到“[”时，压入栈；当遇到“]”时，弹出进行计算。\n\n### 代码\n\n\n```js   \n\n\tvar decodeString = function(s) {\n\t    let stack = [];\n\t    let res = \"\";\n\t    let multi = 0;\n\t    for(let char of s){\n\t        if(char >= 0 && char <= 9){\n\t            multi = multi * 10 + parseInt(char);\n\t        } else if(char === \"[\"){\n\t            stack.push([multi, res]);\n\t            multi = 0;\n\t            res = \"\";\n\t        } else if(char === \"]\"){\n\t            let lastMulti = 0, lastRes = \"\";\n\t            [lastMulti, lastRes] = stack.pop();\n\t            for(let i = 0; i < lastMulti; i++){\n\t                lastRes += res;\n\t            }\n\t            res = lastRes;\n\t        }else{\n\t            res += char;\n\t        }\n\t    };\n\t    return res;\n\t};\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)，N是字符串长度。\n- 空间复杂度：O(N)，N是字符串长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995479064","body":"### 232. 用栈实现队列\n### 思路\n要用栈来模拟队列，队列是先进先出，栈是先进后出，所以当实现出队动作时，无法直接从栈底拿到元素，需要将栈内元素一个个弹出到另一个栈，再从栈顶拿，而这时若对第二个栈实现出队就只需要从栈顶弹元素了，入队操作可以在第一个栈进行；若要出队，且第二个栈空了，再将第一个栈的元素都弹到栈2，重复操作。\n\n### 代码\n\n\n```ts  \n  \n\n\tclass MyQueue {\n\t    stack1:number[];\n\t    stack2:number[];\n\t    constructor() {\n\t        this.stack1 = [];\n\t        this.stack2 = [];\n\t    }\n\t\n\t    push(x: number): void {\n\t        this.stack1.push(x);\n\t    }\n\t\n\t    pop(): number {\n\t        if(this.stack2.length > 0){\n\t            return this.stack2.pop();\n\t        }else{\n\t            while(this.stack1.length > 0){\n\t                this.stack2.push(this.stack1.pop());\n\t            }\n\t            return this.stack2.pop();\n\t        }\n\t    }\n\t\n\t    peek(): number {\n\t        if(this.stack2.length > 0){\n\t            return this.stack2[this.stack2.length - 1];\n\t        }else{\n\t            while(this.stack1.length > 0){\n\t                this.stack2.push(this.stack1.pop());\n\t            }\n\t            return this.stack2[this.stack2.length - 1];\n\t        }\n\t    }\n\t\n\t    empty(): boolean {\n\t        return this.stack2.length === 0 && this.stack1.length === 0;\n\t    }\n\t}\n```\n\n**复杂度分析**  \n\n- 时间复杂度：push为O(1)；pop均摊为O(1),每个元素最多经历一次弹出到栈2；peek均摊为O(1)；empty为O(1)。\n- 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996495704","body":"### 768. 最多能完成排序的块 II\n### 思路\n设此块中最大的为head，如果后面的数都大于等于head，那么就是排序快；如果后面的数小于head，应该将其并入块。这种单调不减的性质，考虑用单调栈来实现。  \n遍历数组arr，如果当前的数大于等于栈顶的数，则入栈；如果小于栈顶的数，则应将其并入块，同时将栈顶元素弹出记为head，如果后续的栈顶元素依旧大于当前数，说明这些栈顶元素应该并入块，一直弹出，再将head压入。head用于表示排序快的最大数。\n\n### 代码\n\n\n```js  \n  \n\tvar maxChunksToSorted = function(arr) {\n\t    let stack = [];\n\t    let head = 0;\n\t    for(let num of arr){\n\t        if(stack.length > 0 && num < stack[stack.length - 1]){\n\t            head = stack.pop();\n\t            while(stack.length > 0 && num < stack[stack.length - 1]){\n\t                stack.pop();\n\t            }\n\t            stack.push(head);\n\t        } else{\n\t            stack.push(num);\n\t        }\n\t    }\n\t    return stack.length;\n\t};\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)。\n- 空间复杂度：O(N),N为arr长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997208063","body":"### 61. 旋转链表\n### 思路\n把倒数第一个的next指向head，把倒数第k+1个的next指向null，返回倒数第k个即为答案。利用快慢指针可以快速找到倒数第k个元素。值得注意的是边界问题，倒数第k+1指向null，返回倒数第k个，至少有2个元素，如果元素少于两个就直接返回head；如果k%len===0，倒数第0个是null，会出错，所以也直接返回head。\n\n### 代码\n\n\n```js  \n  \n\tvar rotateRight = function(head, k){\n\t    if(head === null || head.next === null) return head;\n\t    let len = 0;\n\t    let cur = head;\n\t    while(cur){\n\t        len++;\n\t        cur = cur.next;\n\t    };\n\t    k = k % len;\n\t    if(k === 0) return head;\n\t    let slow = head, fast = head;\n\t    while(fast.next){\n\t        fast = fast.next;\n\t        if(k <= 0){\n\t            slow = slow.next;\n\t        }\n\t        k--;\n\t    }\n\t    let res = slow.next;\n\t    fast.next = head;\n\t    slow.next = null;\n\t    return res;\n\t}\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997352266","body":"### 24. 两两交换链表中的节点\n### 思路\n两两交换的前提是至少有两个元素，如果少于两个元素就直接返回，如果链表总长是奇数，则最后一个元素也不用交换。两两交换元素，node3 = node2.next，node2.next = node1，node1.next = node3，然后再将多个两两交换元素之间串起来。\n\n### 代码\n\n\n```js  \n  \n\tvar swapPairs = function(head) {\n\t    if(!head || !head.next) return head;\n\t    let dummy = new ListNode(0);\n\t    dummy.next = head;\n\t    let temp = dummy;\n\t    while(temp.next && temp.next.next){\n\t      let node1 = temp.next;\n\t      let node2 = node1.next;\n\t      let node3 = node2.next;\n\t      temp.next = node2;\n\t      node2.next = node1;\n\t      node1.next = node3;\n\t      temp = node1;\n\t    }\n\t    return dummy.next;\n\t};\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997560963","body":"### 109. 有序链表转换二叉搜索树\n### 思路\n对于链表，要找到中间的结点，可以利用快慢指针，时间复杂度为O(N)，而利用数组，通过将结点存入数组中，可以通过下标实现随机存储。\n\n### 代码\n\n\n```js  \n  \n\tvar sortedListToBST = function(head) {\n\t    let arr = [];\n\t    let cur = head;\n\t    while(cur){\n\t        arr.push(cur);\n\t        cur = cur.next;\n\t    }\n\t    return dfs(arr, 0, arr.length - 1);\n\t};\n\t\n\tfunction dfs(arr, left, right){\n\t    if(left > right) return null;\n\t    let mid = (left + right) >>> 1;\n\t    let root = arr[mid];\n\t    root.left = dfs(arr, left, mid - 1);\n\t    root.right = dfs(arr, mid + 1, right);\n\t    return root;\n\t}\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)，N为链表长度。\n- 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998404495","body":"### 160. 相交链表\n### 思路\n如果存在交点，指针A遍历完链表A再遍历链表B，指针B遍历完链表B再遍历链表A，两指针应该在交点处相遇；如果不存在交点，则两指针最后都指向null。\n\n### 代码\n\n\n```js  \n  \n\tvar getIntersectionNode = function(headA, headB) {\n\t    let pa = headA, pb = headB;\n\t    while(pa !== pb){\n\t        pa = pa ? pa.next : headB;\n\t        pb = pb ? pb.next : headA;\n\t    };\n\t    return pa;\n\t};\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N + M)，N为链表A长度，M为链表B长度。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999212807","body":"### 142. 环形链表 II\n### 思路\n要判断是否有环，可以使用快慢指针，快指针走两步，满指针走一步，当有重合时，说明有环。由于是快慢指针，慢指针走的是快指针的1/2，假设环外部分长度为a，从相交节点到相遇结点的长度为b，从相遇结点再走到相交结点的长度为c。则有2*（a+b）=a+（n+1）*b +n*c，a=c+(n−1)(b+c)。则从head开始慢走，从相交点开始慢走，会在相交结点相遇。 \n![142_fig1.png](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\n\n### 代码\n\n\n```ts \n  \n\tfunction detectCycle(head: ListNode | null): ListNode | null {\n\t    let slow = head, fast = head;\n\t    while(fast && fast.next){\n\t        slow = slow.next;\n\t        fast = fast.next.next;\n\t        if(fast === slow){\n\t            fast = head;\n\t            while(fast !== slow){\n\t                fast = fast.next;\n\t                slow = slow.next;\n\t            }\n\t            return slow;\n\t        }\n\t    }\n\t    return null;\n\t};\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)，链表长度。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000023871","body":"### 142. 环形链表 II\n### 思路\n要在O(1)的时间实现删除和实现查找，需要用到链表和哈希表，哈希表保存key和结点的映射。当get或者put时，要更新结点在链表中的位置，因此需要用到双向链表。\n### 代码\n\n\n```ts \n  \n\tclass LRUCache {\n\t    dummy: DListNode;\n\t    tail: DListNode;\n\t    map: Map<number, DListNode>;\n\t    cap: number;\n\t    size: number;\n\t    constructor(capacity: number) {\n\t        this.dummy = new DListNode(-1, -1);\n\t        this.tail = new DListNode(-1, -1);\n\t        this.dummy.next = this.tail;\n\t        this.tail.prev = this.dummy;\n\t        this.cap = capacity;\n\t        this.size = 0;\n\t        this.map = new Map();\n\t    }\n\t\n\t    get(key: number): number {\n\t        if(this.map.has(key)){\n\t            let node = this.map.get(key);\n\t            let value = node.val;\n\t            this.delete(node);\n\t            this.appendHead(node);\n\t            return value;\n\t        }else{\n\t            return -1;\n\t        }\n\t    }\n\t\n\t    put(key: number, value: number): void {\n\t        let newNode = new DListNode(key, value);\n\t        if(this.map.has(key)){\n\t            let oldNode = this.map.get(key);\n\t            this.delete(oldNode);\n\t            this.appendHead(newNode);\n\t            this.map.set(key, newNode);\n\t        }else{\n\t            this.appendHead(newNode);\n\t            this.map.set(key, newNode);\n\t            this.size++;  \n\t            if(this.size > this.cap){\n\t                let key = this.deleteTail(); \n\t                this.map.delete(key);          \n\t                this.size--;\n\t            }\n\t        }\n\t    }\n\t\n\t    delete(node: DListNode): void{\n\t        let prev = node.prev;\n\t        let next = node.next;\n\t        prev.next = next;\n\t        next.prev = prev;\n\t    }\n\t    appendHead(node: DListNode): void{\n\t        let next = this.dummy.next;\n\t        this.dummy.next = node;\n\t        node.prev = this.dummy;\n\t        node.next = next;\n\t        next.prev = node;\n\t    }\n\t\n\t    deleteTail(): number{\n\t        let delNode = this.tail.prev;\n\t        this.delete(delNode);\n\t        return delNode.key;\n\t    }\n\t}\n\t\n\tclass DListNode {\n\t    key: number\n\t    val: number;\n\t    next: DListNode;\n\t    prev: DListNode;\n\t    constructor(key: number, val: number){\n\t        this.key = key;\n\t        this.val = val; \n\t    }\n\t}\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(1)。\n- 空间复杂度：O(capacity)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000840973","body":"### 104. 二叉树的最大深度\n### 思路\n①广度优先  \n用一个数组queue保存同一层的结点，用temp保存下一层的结点。  \n②深度优先  \n递归左子树的深度，递归右子树的深度，则总深度为MAX(L，R) + 1。\n### 代码\n\n\n```js \n  \n\tvar maxDepth = function(root) {\n\t    if(!root) return 0;\n\t    let queue = [];\n\t    let temp = [];\n\t    queue.push(root)\n\t    let count = 1;\n\t    while(queue.length){\n\t        while(queue.length){\n\t            let node = queue.pop();\n\t            if(node.right) temp.push(node.right);\n\t            if(node.left) temp.push(node.left);\n\t        }\n\t        if(temp.length) count++;\n\t        queue = temp;\n\t        temp = [];  \n\t    }\n\t    return count;\n\t};\n```\n\n```js \n  \n\tvar maxDepth = function(root){\n\t    return dfs(root, 0);\n\t\n\t};\n\tfunction dfs(head, depth){\n\t    if(!head) return depth;\n\t    let leftDepth = dfs(head.left, depth);\n\t    let rightDepth = dfs(head.right, depth);\n\t    return Math.max(leftDepth, rightDepth) + 1;\n\t}\n```\n\n\n**复杂度分析**  \n\n- 时间复杂度：O(N),N为节点个数。\n- 空间复杂度：广度优先O(N),深度优先O(logN)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001037363","body":"### 100. 相同的树\n### 思路\n判断两树是否相同，考虑递归来实现。对于左子树和右子树分别进行递归，相同成立的前提条件是左子树、右子树、结点的值都相同，递归的出口是叶子结点的判断。\n### 代码\n\n\n```js \n  \n\tvar isSameTree = function(p, q) {\n\t    if(!p || !q) return !p && !q;\n\t    let hasSameRight = isSameTree(p.right, q.right);\n\t    let hasSameLeft = isSameTree(p.left, q.left);\n\t    return hasSameLeft && hasSameRight && (p.val === q.val);\n\t};\n```\n\n\n\n**复杂度分析**  \n\n- 时间复杂度：O(N),N为节点个数。\n- 空间复杂度：O(logN)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1916603886":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991911495","body":"\n### 思路：\n将其中一个变为数组，之前两个都变数组，纠结怎么获取索引，现在另一个每次自处自动补零。\n### 代码：\n\nvar addToArrayForm = function(num, k) {\n       let s = [];\n        let flag = false;\n        let nl = num.length;\n        while(nl != 0 || k != 0) {\n            let a = 0, b = k % 10 ;\n            if(nl !== 0) a = num[--nl];\n            k = parseInt(k/10);\n            \n            let ans = a + b;\n            \n            if(flag) {\n                ans += 1;\n                flag = false;\n            }\n            if( ans >= 10) flag = true;\n            s.push(ans % 10);\n        }\n        if(flag) s.push(1);\n        return s.reverse();\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992195419","body":"var shortestToChar = function(s, c) {\nlet arr = [];\n    let ans = [];\n    for (let i = 0; i < s.length; i++) {\n      if (s[i] === c) {\n        arr.push(i);\n      }\n    }\n    for (let i = 0; i < s.length; i++) {\n      let max = 1000;\n      for (let j = 0; j < arr.length; j++) {\n        if (Math.abs(i - arr[j]) < max) {\n          max = Math.abs(i - arr[j]);\n        }\n      }\n      ans.push(max);\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993447999","body":"var CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    // 注意：当有增量时，取栈中的每个元素加上增量的值再次存入栈中\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995946295","body":"var MyQueue = function() {\n  this.inStack = []\n  this.outStack = []  \n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.inToOut()\n    return this.outStack.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    this.inToOut()\n    const len = this.outStack.length;\n    return this.outStack[len - 1];\n};\n\nMyQueue.prototype.inToOut = function() {\n    if(!this.outStack.length){\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n};\n\n作者：thanosru-zi-san-tai-gong\n链接：https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/js-by-thanosru-zi-san-tai-gong-9wcv/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996806372","body":"var maxChunksToSorted = function(arr) {\n let stack = [];\n\n    for (let val of arr) {\n        // 大于栈顶元素，直接入栈，算一个块\n        if (!stack.length || stack[stack.length - 1] <= val) {\n            stack.push(val);\n        } else {\n            let curMax = stack.pop();\n            // val和这些弹出的元素算一个块\n            while (stack.length && stack[stack.length - 1] > val) {\n                stack.pop();\n            }\n            // 保存块中的最大值\n            stack.push(curMax);\n        }\n    }\n    return stack.length;\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997212171","body":"var rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997402272","body":"var swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n   \n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997925370","body":"var sortedListToBST = function(head) {\n let buildTree = (l,r) => {\n        if(l>r) return null;\n        //计算中位数;\n        let mid = Math.floor((l + r + 1) / 2); \n        let left = buildTree(l,mid - 1); //构建左子树，这里为啥要先构造左子树呢？因为中序遍历，顺序为 左子树->父节点->右子树;\n        let root = new TreeNode(ptr.val); //构建父节点;\n        ptr = ptr.next; //链表取下一个值;\n        root.left = left;//父节点连接左子树;\n        root.right = buildTree(mid + 1,r);//构建右子树;\n        return root;\n    };\n        if(!head) return null //链表判空;\n        let ret = 0;\n        let ptr = head;// 链表赋值;\n        while(head){ // 计算链表长度，别看题目给出是数组，就直接head.length，答案为undefined，所以链表计算长度只能这样;\n            ret++;\n            head = head.next;\n        }\n    return buildTree(0,ret-1);\n\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999360175","body":"笨比方法\n\nvar detectCycle = function(head) {\n    let a = head;\n    let set = new Set();\n    while(a !== null) {\n        if(set.has(a)) {\n            return a;\n        } else {\n            set.add(a);\n        }\n        a = a.next;\n    }\n    return null;\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000370921","body":"class LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.map = new Map();\n    }\n    get(key) {\n        if (this.map.has(key)) {\n            // get表示访问该值\n            // 所以在访问的同时，要将其调整位置，放置在最后\n            const temp = this.map.get(key);\n            // 先删除，再添加\n            this.map.delete(key);\n            this.map.set(key, temp);\n            // 返回访问的值\n            return temp;\n        } else {\n            // 不存在，返回-1\n            return -1;\n        }\n    }\n    put(key, value) {\n        // 要将其放在最后，所以若存在key，先删除\n        if (this.map.has(key)) this.map.delete(key);\n        // 设置key、value\n        this.map.set(key, value);\n        if (this.map.size > this.capacity) {\n            // 若超出范围，将map中头部的删除\n            // map.keys()返回一个迭代器\n            // 迭代器调用next()方法，返回包含迭代器返回的下一个值，在value中\n            this.map.delete(this.map.keys().next().value);\n        }\n    }\n}\n\n作者：lzxjack\n链接：https://leetcode-cn.com/problems/lru-cache/solution/li-yong-mapdie-dai-qi-javascript-by-lzxj-9l3q/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000860685","body":"var maxDepth = function(root) {\n  if(!root) {\n        return 0;\n    } else {\n        const left = maxDepth(root.left);\n        const right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001013316","body":"递归\nvar isSameTree = function(p, q) {\n    if(p === null && q === null) return true;\n    else if(p === null || q === null) return false;\n    else {\n        let cur = p.val === q.val ? true : false;\n        let left = isSameTree(p.left,q.left);\n        let right = isSameTree(p.right,q.right);\n        return cur && left && right;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruohai0925":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991766191","body":"\n\n```java\n\nclass Solution {\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    int len = num.length;\n    int count = 0;\n    int flag = 0;\n    List<Integer> ans = new ArrayList<>();\n    while (k > 0) {\n        int tmpNum = len - count - 1 < 0 ? 0: num[len - count - 1];\n        int sum = k % 10 + tmpNum + flag;\n        flag = sum / 10;\n        k /= 10;\n        count++;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    for(int i = len - count - 1; i > -1; i--) {\n        int sum = num[i] + flag;\n        flag = sum / 10;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    if (flag == 1) {\n        ans.add(1);\n    }\n    Collections.reverse(ans);\n    return ans;\n}\n}\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991945520","body":"\n- 语言支持：Java\n\nJava Code:\n\n```java\n\npublic class Solution {\n    /**\n     * @param S: \n     * @param C: \n     * @return: nothing\n     */\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length();\n        int[] res = new int[n];\n        int pos = -n;\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], Math.abs(i - pos));\n        }\n        return res;\n    }\n}\n\n\n```\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992979075","body":"-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n\n    int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993810144","body":"Java Code:\n\n```java\n\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        // write your code here\n        if (s.length() == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        int repeat = 0;\n\n        while (index < s.length()) {\n            char c = s.charAt(index);\n            if (c == '[') {\n                index++;\n                String sub = decodeString(s);\n                for (int i = 0; i < repeat; i++) {\n                    sb.append(sub);\n                }\n                repeat = 0;\n                index++;\n            } else if (c == ']') {\n                return sb.toString();\n            } else if (Character.isDigit(c)) {\n                repeat = repeat * 10 + c - '0';\n                index++;\n            } else {\n                sb.append(c);\n                index++;\n            }\n        }\n\n        return sb.toString();\n    }\n}\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995330805","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n\n    //定义栈\n    private Stack<Integer> stackA;\n    private Stack<Integer> stackB;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stackA = new Stack<Integer>();\n        stackB = new Stack<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    //栈A入栈\n    public void push(int x) {\n        stackA.push(x);\n\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    //栈A出栈到栈B，栈B出栈\n    public int pop() {\n        if(stackB.isEmpty()) {\n            while(!stackA.isEmpty()){\n                stackB.push(stackA.pop());\n            }\n        }\n        return stackB.pop();\n    }\n    \n    //栈A出栈到栈B，栈B出栈\n    /** Get the front element. */\n    public int peek() {\n        if(stackB.isEmpty()) {\n            while(!stackA.isEmpty()){\n                stackB.push(stackA.pop());\n            }\n        }\n        return stackB.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    //栈A和栈B都为空\n    public boolean empty() {\n        if(stackA.isEmpty() && stackB.isEmpty()){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996174854","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] forward = new int[n];\n        int[] backward = new int[n];\n\n        forward[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            forward[i] = Math.max(forward[i-1], arr[i]);\n        }\n\n        backward[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            backward[i] = Math.min(backward[i + 1], arr[i]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (forward[i] <= backward[i + 1]) res++;\n        }\n\n        return res + 1;\n    }\n}\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997041423","body":"\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return null;\n        }\n        ListNode slow = head;\n        int count = 1;\n        while (slow.next != null){\n            count ++;\n            slow = slow.next;\n        }\n        // 尾结点\n        ListNode tail = slow;\n        k = k % count;\n        if(k == 0){\n            return head;\n        }\n        slow = head;\n        ListNode fast = head;\n        for(int i=0;i<k;i++){\n            fast = fast.next;\n        }\n        while (fast.next != null){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        ListNode newHead = slow.next;\n        tail.next = head;\n        slow.next = null;\n        return newHead;\n    }\n}\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997269323","body":"  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) \n    {\n        if(head==null||head.next==null)\n            return head;\n        ListNode myHead=new ListNode();\n        myHead.next=head;\n        ListNode p=myHead;\n        while(p!=null&&p.next!=null&&p.next.next!=null)\n        {\n            var x=p.next;\n            var y=p.next.next;\n            x.next=y.next;\n            y.next=x;\n            p.next=y;\n            p=x;\n        }\n        return myHead.next;\n    }\n}\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997677958","body":"\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode p = pre.next;\n        ListNode q = p.next;\n        //找到链表的中点p\n        while(q!=null && q.next!=null){\n            pre = pre.next;\n            p = pre.next;\n            q = q.next.next;\n        }\n        //将中点左边的链表分开\n        pre.next = null;\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n    }\n}\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998391924","body":"```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA;\n        ListNode pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n        // Note: In the case lists do not intersect, the pointers for A and B\n        // will still line up in the 2nd iteration, just that here won't be\n        // a common node down the list and both will reach their respective ends\n        // at the same time. So pA will be NULL in that case.\n}\n}\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998957665","body":"\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head.next;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            if (fast == slow) {\n                break;\n            }\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        if (fast == null || fast.next == null) {\n            return null;\n        }\n        while (head != slow.next) {\n            head = head.next;\n            slow = slow.next;\n        }\n        return head;\n    }\n}\n\n```\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000044018","body":"\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\npublic class LRUCache {\n    private class Node{\n        Node prev;\n        Node next;\n        int key;\n        int value;\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n\n    private int capacity;\n    private HashMap<Integer, Node> hs = new HashMap<Integer, Node>();\n    private Node head = new Node(-1, -1);\n    private Node tail = new Node(-1, -1);\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        tail.prev = head;\n        head.next = tail;\n    }\n\n    public int get(int key) {\n        if( !hs.containsKey(key)) {\t\t\t//key找不到\n            return -1;\n        }\n\n        // remove current\n        Node current = hs.get(key);\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n\n        // move current to tail\n        move_to_tail(current);\t\t\t//每次get，使用次数+1，最近使用，放于尾部\n\n        return hs.get(key).value;\n    }\n\n    public void put(int key, int value) {\t\t\t//数据放入缓存\n        // get 这个方法会把key挪到最末端，因此，不需要再调用 move_to_tail\n        if (get(key) != -1) {\n            hs.get(key).value = value;\n            return;\n        }\n\n        if (hs.size() == capacity) {\t\t//超出缓存上限\n            hs.remove(head.next.key);\t\t//删除头部数据\n            head.next = head.next.next;\n            head.next.prev = head;\n        }\n\n        Node insert = new Node(key, value);\t\t//新建节点\n        hs.put(key, insert);\n        move_to_tail(insert);\t\t\t\t\t//放于尾部\n    }\n\n    private void move_to_tail(Node current) {    //移动数据至尾部\n        current.prev = tail.prev;\n        tail.prev = current;\n        current.prev.next = current;\n        current.next = tail;\n    }\n}\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000511317","body":"Java Code:\n\n```java\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(null == root){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\n    }\n}\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000895895","body":"-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.val == q.val \n        && isSameTree(p.left, q.left) \n        && isSameTree(p.right, q.right);\n    }\n}\n\n```\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001071983","body":"-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode top = queue.poll();\n                if (top.left == null && top.right == null) {\n                    res += top.val;\n                    continue;\n                }\n                if (top.left != null) {\n                    top.left.val = top.val * 10 + top.left.val;\n                    queue.offer(top.left);\n                }\n                if (top.right != null) {\n                    top.right.val = top.val * 10 + top.right.val;\n                    queue.offer(top.right);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991847081","body":"## Python3\n```Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        number = 0\n        for n in num:\n            number = number * 10 + n\n        total_num = number + k\n        num_list = []\n        while total_num >= 10:\n            temp = total_num % 10\n            total_num = total_num // 10\n            num_list.append(temp)\n        num_list.append(total_num)\n        return num_list[::-1]\n```\n\n## 思路\n1. 可以用暴力解法\n2. 也可以每个位单独计算（注意进位）\n- time complexity: O(n)\n- space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992053965","body":"## 思路\n1. 暴力记录每一个c的index，然后遍历找到最小值，时间复杂度O(nm)\n2. 遍历两次：从左到右，从右到左，记录最小值，时间复杂度O(m)\n\n## Python3 \n```Python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # # 两遍遍历 O(m*n)\n        # index_list = []\n        # ans = [len(s)] * len(s)\n        # for index, char in enumerate(s):\n        #     if char == c:\n        #         index_list.append(index)\n\n        # for index, char in enumerate(s):\n        #     min_distance = len(s)\n        #     for i in index_list:\n        #         distance = abs(i-index)\n        #         if distance < min_distance:\n        #             min_distance = distance\n        #     ans[index] = min_distance\n\n        # return ans\n\n        ans = [len(s)] * len(s)\n        index = -1\n\n        # from left to right\n        for i in range(len(s)):\n            if s[i] == c:\n                index = i\n            if index == -1:\n                continue\n            ans[i] = abs(i - index)\n\n        # from right to left\n        index2 = len(s)\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                index2 = j\n            if index2 == len(s):\n                continue\n            ans[j] = min(ans[j], abs(j-index2))\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993138334","body":"## Python3\n```Python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        # stack: FILO, append, pop\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        pointer = 0\n        for i in range(min(k, len(self.stack))):\n            self.stack[pointer] += val \n            pointer += 1\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997151816","body":"## Python3\n```Python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # 旋转链表：k = k % length\n        # 先遍历一遍得到length\n        if not head or not head.next: return head\n\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n\n        # 将头尾连起来\n        cur.next = head\n        k = k % length \n        # 找到新的head\n        for i in range(length-k):\n            cur = cur.next\n\n        newHead = cur.next\n        cur.next = None\n\n        return newHead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997318504","body":"## Python3\n```Python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head: return head\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        prev = dummy\n        A = head\n          \n        while A and A.next:\n            B = A.next\n            nextB = B.next\n\n            prev.next = B\n            B.next = A \n            A.next = nextB\n\n            prev = A\n            A = nextB\n\n        return dummy.next\n```\n\n## 复杂度\n- time complexity: O(n)\n- space complexity: O(1) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998244319","body":"## Python 3\n```Python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        # 有交点在交点处走了同样的距离\n        # 无交点走了A+B，在末尾处 a == b == None\n        a = headA\n        b = headB\n\n        while a!=b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n\n        return a \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999250995","body":"## Python3\n```Python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head: return None\n        find = False\n        fast, slow = head, head\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                find = True\n                break\n\n        if find == False:\n            return None\n\n        fast = head\n\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n\n        return fast\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999842325","body":"## Python3\n```Python3\nclass ListNode:\n    def __init__(self, key = 0, val = 0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.hashmap = {} # {key: key, value: node}\n        self.size = 0\n        \n    def get(self, key: int) -> int:\n        if key not in self.hashmap:\n            return -1\n        node = self.hashmap[key]\n        self.moveToHead(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            node = self.hashmap[key]\n            node.val = value\n            self.moveToHead(node)\n\n        else:\n            node = ListNode(key, value)\n            self.addToHead(node)\n            self.hashmap[key] = node\n            self.size += 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.hashmap.pop(removed.key)\n                self.size -= 1\n\n    def addToHead(self, node):\n        next = self.head.next\n        node.prev = self.head\n        node.next = next\n        self.head.next = node\n        next.prev = node\n\n    def removeNode(self, node):\n        prev = node.prev\n        next = node.next\n        prev.next = next\n        next.prev = prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        prev = self.tail.prev\n        self.removeNode(prev)\n        return prev\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991904972","body":"### 思路\r\n\r\n- 思路与解法\r\n```\r\n- 逐位加；\r\n- 反向存，最后reverse，不然正向存，每次add数组都得挪位；\r\n```\r\n\r\n- 心得\r\n```\r\n- 第一次fail了因为大意了，这题要注意num和k的长短不一，不能一个for on num解决；\r\n```\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0, i = num.length - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while(i >= 0 || k > 0 || carry > 0){\r\n            int left = i >= 0?num[i]:0;\r\n            i--;\r\n            int right = k % 10;\r\n            k = k / 10;\r\n            int sum = left + right + carry;\r\n            res.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n***k因为是常数，其实其长度可以忽略。***\r\n\r\ntime: O(Math.max(num.length, Math.log10(k)+1))\r\nspace: O(1)，不算结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992526525","body":"### 思路\nArray遍历\n\n- 思路与解法\n```\n- 左右两边各扫一遍；\n- 第一遍扫出初始编号；\n- 第二遍更新编号找最小值；\n```\n\n- 心得\n```\n- array的题肯定不会只考array，因为是基础；\n- array一般肯定要考遍历，就像是binary tree；遍历就是左到右，右到左，左右各扫一遍，这是最基本的，可能再有结合双指针/滑动窗口的；总之就是一些结合题目已知条件需要找到合适的便利方式；\n- 这题还可以用stack，边push边更新；\n```\n\n### 代码\n```java\n//array遍历\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int ci = 20000;\n        Arrays.fill(res, 20000);\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                ci = 0;\n            }\n            res[i] = Math.min(ci, res[i]);\n            ci++;\n        }\n        \n        for(int i = s.length() - 1;i >= 0;i--){\n            if(s.charAt(i) == c){\n                ci = 0;\n            }\n            res[i] = Math.min(ci, res[i]);\n            ci++;\n        }\n        \n        return res;\n      \n    }\n}\n\n```\n\n### 复杂度\n\nArray遍历\nO(s.length());\nO(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994280501","body":"### 思路\n\n- 思路与解法\n```\n- 基本方法是push入栈，遇到特殊字符`]`则开始出栈操作，属于栈的常见操作；\n- 考点主要在写法上，尤其是String的操作上，不要使用`+`，能用StringBuilder就多用，避免额外复杂度\n```\n\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<>();\n        \n        for(int i = 0;i < s.length();i++){\n            char cur = s.charAt(i);\n            \n            if(cur == ']'){\n                StringBuilder sb = new StringBuilder();\n                \n                while(!stack.peek().equals(\"[\")){\n                    sb.append(stack.pop());\n                }\n                //pop the [\n                stack.pop();\n                //find times\n                StringBuilder sbd = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))){\n                    sbd.append(stack.pop());\n                }\n                sbd.reverse();\n                int times = Integer.valueOf(sbd.toString());\n                stack.add(sb.toString().repeat(times));\n            } else {\n                stack.add(String.valueOf(cur));\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        \n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        sb.reverse();\n        return sb.toString();\n    }\n}\n```\n\n### 复杂度\n\nO(N)，循环体会从头到尾遍历s.length();\nO(M)，要维护一个栈；M为解码后的长度；\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997308205","body":"### 思路\n\n- 思路与解法\n```\n- 做过很多遍了，主要是要凝练写法，思路要清晰且容易表达，变量设置要合理\n```\n\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        \n        ListNode pre = dummy;\n        ListNode cur = head;\n        if(head == null) return head;\n        ListNode next = cur.next;\n        \n        while(next != null) {\n            ListNode nextCur = next.next;\n            next.next = cur;\n            cur.next = nextCur;\n            pre.next = next;\n            \n            pre = cur;\n            cur = nextCur;\n            next = null;\n            if(cur != null && cur.next != null) next = cur.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```\n\n### 复杂度\n\ntime: O(N)\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997521748","body":"### 思路\n\n- 思路与解法\n```\n- 对于linkedlist和binary tree来说，遍历都是核心\n- 这里是两种遍历的综合\n- 另外就是考察对于递归的思路\n- 主要的思路是，先快慢指针找中间点===root，然后截断的左右两段linkedlist分别为左右子树\n- 注意截断的这部分的定义，可能面试的时候紧张状态下容易出错\n```\n\n### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return preOrder(head, null);\n    }\n    \n    public TreeNode preOrder(ListNode head, ListNode end) {\n        if(head == null || head == end) return null;\n        \n        ListNode fast = head;\n        ListNode slow = head;\n        \n        while(fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next;\n            if(fast != null) fast = fast.next;\n        }\n        \n        TreeNode root = new TreeNode(slow.val);\n        root.left = preOrder(head, slow);\n        root.right = preOrder(slow.next, end);\n        \n        return root;\n        \n    }\n}\n```\n\n### 复杂度\n\ntime: O(NlogN)\nspace: O(logN)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999178886","body":"### 思路\n\n- 思路与解法\n```\n- 经典的链表环问题，既是题目，也是技巧，别的题目会用到；\n- 做过的题目主要是写法问题，这里有些边界判断，dummy可用可不用；\n- 尽可能做到一次写对，不要有bug；\n```\n\n### 代码\n```java\n//with dummy\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        \n        while(slow != null && fast!= null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) break;\n        }\n        \n        if(slow == null || fast == null || fast.next == null) return null;\n        \n        fast = dummy;\n        \n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        return slow;\n    }\n}\n\n//without dummy\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return head;\n        ListNode slow = head, fast = head;\n        \n        do {\n            if(fast == null) return null;\n            slow = slow.next;\n            fast = fast.next;\n            if(fast == null) {\n                return null;\n            } else {\n                fast = fast.next;\n            }\n        } while(slow != fast);\n        \n        fast = head;\n        while(slow != fast){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n\n### 复杂\n\ntime: O(N)\nspace: O(1)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000581872","body":"### 思路\n\n//s6\n- 思路与解法\n```\n- Tree主要看遍历，DFS主要看写法；BFS主要看模版；\n- 这里主要是定义好递归返回值；\n```\n\n### 代码\n```java\n//s6\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        return preOrder(root);\n    }\n    \n    public int preOrder(TreeNode root) {\n        if(root == null) return 0;\n        \n        return 1 + Math.max(preOrder(root.left), preOrder(root.right));\n    }\n}\n```\n\n### 复杂度\ndfs\ntime: 虽然递归只进行了logN次，但是每个node依旧被遍历到了，因此时间复杂度还是O(N)\nspace: 维护递归stack的空间，由递归的层数决定，因此为O(logN);","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001087256","body":"### 思路\n\n//s6\n- 思路与解法\n```\n- Tree主要看遍历，DFS主要看写法；BFS主要看模版；\n- 这里主要是定义好递归返回值:返回当前树的路径端点和；\n- 递归尽可能不用全局变量；\n```\n\n### 代码\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return preOrder(root, 0);\n    }\n    \n    public int preOrder(TreeNode root, int val){\n        if(root == null) return -1;\n        \n        val = 10 * val + root.val;\n        \n        int l = preOrder(root.left, val);\n        int r = preOrder(root.right, val);\n        \n        if(l == -1 && r == -1) {\n            return val;\n        } else{\n            return (l == -1?0:l) + (r == -1?0:r);\n        }\n        \n    }\n}\n```\n\n### 复杂度\n\ntime: 每个节点都遍历到了，因此为O(N)。注意与递归无关。\nspace: 递归所需要的stack，一般O(logN)，亦即tree的高度;理论上是O(N)；","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991921921","body":"思路：\r\n直接模拟\r\n代码：\r\nJava：\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        /* Set up */\r\n        int n = num.length;\r\n        int cur = k;\r\n        List<Integer> res = new ArrayList();\r\n        \r\n        /* run the addition backwards digit by digit*/\r\n        int i = n;\r\n        while (--i >= 0|| cur > 0){\r\n        /* Adding a new digit*/\r\n            if (i >= 0){\r\n                cur += num[i];\r\n            }\r\n        /* Carry addition simulator*/\r\n            res.add(cur % 10);\r\n            cur = cur / 10;;\r\n        }\r\n        /* return the result reversely since we adding up reversely*/\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\nScala:\r\n```\r\nobject Solution {\r\n    def addToArrayForm(num: Array[Int], K: Int): List[Int] = {\r\n        // Set up\r\n        var res = List[Int]()\r\n        var k = K\r\n        \r\n        // Reverse the num list, and initialize the carry\r\n        // Scala variable definition 101\r\n        // carry is repeatedly folding out and most addition is taken care here\r\n        val carry = num.reverse.foldLeft(0)((sum, x)=>{\r\n          val temp = k % 10 + x + sum\r\n          k = k / 10\r\n          res :::= List(temp % 10)\r\n          temp / 10}\r\n        )\r\n        // edge case when there is k or carry left\r\n        if(k == 0){\r\n          if (carry == 1) res :::= List(1)\r\n          res\r\n        }\r\n        else{\r\n          k = k + carry\r\n          while(k > 0){\r\n            res :::= List(k % 10)\r\n            k  = k / 10\r\n          }\r\n          res\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n复杂度：\r\nTC: O(n + k)\r\nSC: O(n + k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995094216","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        return self.stack1\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while self.stack1:\n            a = self.stack1.pop()\n            self.stack2.append(a)\n        res= self.stack2.pop()\n        while self.stack2:\n            b = self.stack2.pop()\n            self.stack1.append(b)\n  \n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if len(self.stack1) == 0:\n            return True\n        else:\n            return False\n```","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001087434","body":"```\n\nclass Solution:\n    def sumNumbers(self,root):\n        self.res = []\n        self.dfs(root,'')\n        #sum(int(a) for a in res)\n        return sum(int(a) for a in self.res)\n        \n    def dfs(self,root,path):\n        if root:\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.res.append(path)\n            else:\n                self.dfs(root.left,path)\n                self.dfs(root.right,path)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829936","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>(); // LinkedList addFirst()\r\n        for (int i = nums.length - 1; i >= 0; i --) {\r\n            res.addFirst((nums[i] + k) % 10);\r\n            k = (nums[i] + k) / 10;\r\n        }\r\n        while (k > 0) {\r\n            res.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n//Time O(n), Space O(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992558904","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // two pass(forward, backward) and compare.\n       //  fp, bp edge condition\n\n        int len = s.length(); int fp = -len; \n      \n        int[] res = new int[len];\n        \n        for (int i = 0; i < len; i ++) {\n            if(s.charAt(i) == c) fp = i;\n            res[i] = i - fp;\n        }\n        \n        int bp = 2*len - 1;\n        for(int j = s.length() - 1; j >= 0; j --){\n            if(s.charAt(j) == c) bp = j;\n            res[j] = Math.min(res[j], bp - j);\n        }\n        \n        return res;\n    }\n}\n// Time: O(n). Space:O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993681672","body":"```java\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() < n)\n            stack.push(x);\n    }\n\n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0)\n            inc[i] += val;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994292058","body":"```java\npublic class Solution {\n    private int pos = 0;\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        String num = \"\";\n        for (int i = pos; i < s.length(); i++) {\n            if (s.charAt(i) != '[' && s.charAt(i) != ']' && !Character.isDigit(s.charAt(i))) {\n                sb.append(s.charAt(i));\n            } else if (Character.isDigit(s.charAt(i))) {\n                num += s.charAt(i);\n            } else if (s.charAt(i) == '[') {\n                pos = i + 1;\n                String next = decodeString(s);\n                for (int n = Integer.valueOf(num); n > 0; n--) sb.append(next);\n                num = \"\";\n                i = pos;\n            } else if (s.charAt(i) == ']') {\n                pos = i;\n                return sb.toString();\n            }\n        }\n        return sb.toString();\n    }\n}\nTime: O(n), Space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995429310","body":"```java\nclass MyQueue {\n\n    /** Initialize your data structure here. */\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();   \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n      inStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(!outStack.isEmpty()) return outStack.pop();\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n        return outStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(!outStack.isEmpty()) return outStack.peek();\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n        return outStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n// Time O(1), Space O(n);\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996782448","body":"```java\r\n// sliding window\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sortArr = arr.clone();\r\n        Arrays.sort(sortArr);\r\n        int arrSum = 0, sortedSum = 0, res = 0;\r\n        for (int i = 0; i < arr.length; i ++){\r\n            arrSum += arr[i];\r\n            sortedSum += sortArr[i];\r\n            if(arrSum == sortedSum) res ++;\r\n            \r\n        }\r\n        return res;\r\n        \r\n    }\r\n}\r\n// Time: O(nlogn). Space:O(n)\r\n\r\n/*借鉴其他人的\r\n单调栈：要想保证每一个块拼接后单调递增，就要保证每一个块的最大值是单调递增的，这时候就可以构建一个单调栈。\r\n具体做法：\r\n1.遍历数组arr中的每一个num\r\n2.当stack为空或者num>=栈顶值时：入栈（相当于添加了新的元素块）\r\n3.当栈 stack 不为空且数字 num<栈顶值 时：\r\n（1）保存栈顶值head\r\n*（2）当栈 stack 不为空且数字 num<栈顶值 时:循环出栈（此步是关键，因为num>=栈顶值时才能保证有序，所以要将前面所有的大于num的块儿合成一个）\r\n（3）将head入栈（当前块的最大值）\r\n4.遍历结束后，stack的长度就是块的个数\r\n*/\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n         Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.peek()) {\r\n                int current = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(current);\r\n            } else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997204656","body":"```java\nclass Solution {\n// fast slow pointer\n    public ListNode rotateRight(ListNode head, int k) {\n         if (head==null||head.next==null) return head;\n    ListNode dummy=new ListNode(0);\n    dummy.next=head;\n    ListNode fast=dummy,slow=dummy;\n\n    int i;\n    for (i=0;fast.next!=null;i++)//Get the total length \n    \tfast=fast.next;\n    \n    for (int j=i- k%i;j>0;j--) //Get the i-k%i th node\n    \tslow=slow.next;\n    \n    fast.next=dummy.next; //Do the rotation\n    dummy.next=slow.next;\n    slow.next=null;\n    \n    return dummy.next;\n        \n    }\n}\n// Time O(n). Space: O(1)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998024203","body":"```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n// Time O(n)  SpaceO(n),\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998850519","body":"```java\n/*如果两个链表相交，那么相交点之后的长度是相同的, pA走过的路径为A链+B链, pB走过的路径为B链+A链\npA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。\n也可以用哈希表判断。\n*/\npublic class Solution {\n   public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) return null;\n    ListNode pA = headA, pB = headB;\n    while (pA != pB) {\n        pA = pA == null ? headB : pA.next;\n        pB = pB == null ? headA : pB.next;\n    }\n    return pA;\n}\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000386063","body":"```java\nclass Node {\n        int key;\n        int value;\n        Node pre;\n        Node next;\n        \n        public Node (int key, int value){\n            this.key = key;\n            this.value = value;\n        }\n    }\n\nclass DoubleList {\n    Node head;\n    Node tail;\n    int size;\n    \n    public DoubleList(int size){\n         this.size = size;\n        head = new Node(-1,-1);\n        tail = new Node(-1,-1);\n        head.next = tail;\n        tail.pre = head;\n       \n    }\n    \n    public void remove(Node node){\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n        size --;\n    }\n    \n    public void addFirst(Node node){\n        node.next = head.next;\n        node.pre = head;\n        head.next.pre = node;\n        head.next = node;\n        size ++;\n    }\n    \n    public Node removeLast(){\n        if (tail.pre == head){\n            return null;\n        }\n        Node node = tail.pre;\n        remove(node);\n        return node;\n    }\n    \n    public int getSize(){\n        return this.size;\n    }\n}\n\nclass LRUCache {\n    HashMap<Integer, Node> map;\n    DoubleList cache;\n    int capacity;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        cache = new DoubleList(0);\n    }\n    \n    public int get(int key) {\n        if (!map.containsKey(key)) return -1;\n        Node node = map.get(key);\n        int value = node.value;\n        put(key, value);\n        return value;    \n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            Node cur = map.get(key);\n            cache.remove(cur);\n            cur.value = value;\n            map.put(key,cur);\n            cache.addFirst(cur);\n            return;\n        }\n        if(cache.getSize() == capacity){\n            Node last = cache.removeLast();\n            map.remove(last.key);\n        }\n        Node nodeAdd = new Node(key, value);\n        map.put(key, nodeAdd);\n        cache.addFirst(nodeAdd);   \n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000875337","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        return (root == null) ? 0 : (1 + Math.max(maxDepth(root.left), maxDepth(root.right)));  \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000911093","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null ) return false;\n        if(p.val != q.val) return false; // why not  if(p.val == q.val) return true;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        \n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991980237","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [float('inf') for _ in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                if s[j] == c:\n                    ans[i] = j - i\n                    break\n                    \n        for i in range(n-1,-1,-1):\n            for j in range(i,-1,-1):\n                if s[j] == c:\n                    ans[i] = min(ans[i],i-j)\n                    break\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993124094","body":"```\nclass CustomStack:\n\n    def __init__(self, size: int):\n        self.size = size\n        self.st = []\n        self.cnt = 0\n        self.incrementals = []\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.cnt += 1\n            self.st.append(x)\n            self.incrementals.append(0)\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        if self.cnt >= 1:\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.st.pop() + self.incrementals.pop()\n    def increment(self, k: int, val: int) -> None:\n        if self.incrementals:\n            self.incrementals[min(k - 1, self.cnt - 1)] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994254023","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                repeatstr = ''\n                while stack and stack[-1] != \"[\":\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                repeatcnt = ''\n                while stack and stack[-1].isdigit():\n                    repeatcnt = stack.pop() + repeatcnt\n                int_cnt = int(repeatcnt)\n                stack.append(int_cnt * repeatstr)\n        \n        return ''.join(stack)\n```\nTC:O(N)\nSC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995502694","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.size1 = 0\n        self.stack2 = []\n        self.size2 = 0\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        pop_val = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return pop_val\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        peek_val = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return peek_val\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.stack1:\n            return True\n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996444382","body":"```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        '''\n        #1\n        chunks = 0\n        for i in range(1, len(arr)+1):\n            if sorted(arr[:i]) == sorted(arr)[:i]:\n                chunks += 1\n        return chunks\n        '''\n        ''''\n        #2\n        count_a = defaultdict(int)\n        count_b = defaultdict(int)\n        ans = 0\n        \n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n        return ans\n        '''\n        \n        '''\n        #3\n        count = defaultdict(int)\n        diff_cnt = 0\n        ans = 0\n        for a, b in zip(arr, sorted(arr)):\n            if count[a] == 0: diff_cnt += 1   ## a's count as positive and b's count as negative, \n            if count[a] == -1: diff_cnt -= 1  ## subarray would match by sort if the current diff count is 0\n            count[a] += 1\n            if count[b] == 0: diff_cnt += 1\n            if count[b] == 1: diff_cnt -= 1\n            count[b] -= 1\n            if diff_cnt == 0: ans += 1\n        return ans\n        '''\n        \n        stack = []\n        for num in arr:\n            if stack and stack[-1] > num:\n                curr_max = stack[-1]\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(curr_max)\n            else:\n                stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997160848","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        lenth = 1\n        pt = head\n        while pt.next != None:\n            pt = pt.next\n            lenth += 1\n        old_tail = pt\n        true_k = k % lenth\n        if true_k == 0: return head\n        num_to_move = lenth - true_k\n        cur = head\n        while num_to_move - 1:\n            cur = cur.next\n            num_to_move -= 1\n        new_tail = cur\n        new_head = cur.next\n        old_tail.next = head\n        new_tail.next = None\n        return new_head\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997585869","body":"```    \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: return None\r\n        if not head.next: return TreeNode(head.val)\r\n\r\n        curr = head\r\n        length = 1\r\n        while curr.next:\r\n            curr = curr.next\r\n            length += 1\r\n        mid = (length - 1) // 2\r\n        pt = head\r\n        while mid - 1 > 0:\r\n            pt = pt.next\r\n            mid -= 1\r\n        \r\n        root_prev = pt\r\n        root = pt.next\r\n        root_after = root.next\r\n        root_prev.next = None\r\n    \r\n        root_node = TreeNode(root.val)\r\n        root_node.left = self.sortedListToBST(head)\r\n        root_node.right = self.sortedListToBST(root_after)\r\n        return root_node\r\n   ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998428616","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a \n        '''\n        nodes_in_B = set()\n\n        while headB != None:\n            nodes_in_B.add(headB)\n            headB = headB.next\n        while headA != None:\n            if headA in nodes_in_B:\n                return headA\n            headA = headA.next\n        return None\n    \n        '''\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999362800","body":"```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        if not head or not head.next:\n            return None\n        while fast != None and fast.next != None:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                break \n        if fast == None or fast.next == None:\n            return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n        \n        '''\n        nodeSet = set()\n        while head:\n            if head in nodeSet:\n                return head\n            else:\n                nodeSet.add(head)\n            head = head.next\n        return None\n        '''\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000018910","body":"```\nclass DLinkedNode():\n    def __init__(self):\n        self.key = 0\n        self.value = 0\n        self.prev = None\n        self.next = None\nclass LRUCache:\n    def _add_node(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        \n        self.head.next.prev = node\n        self.head.next = node\n        \n    def _remove_node(self, node):\n        prev = node.prev\n        new = node.next\n        \n        prev.next = new\n        new.prev = prev\n        \n    def _move_to_head(self, node):\n        self._remove_node(node)\n        self._add_node(node)\n    \n    def _pop_tail(self):\n        res = self.tail.prev\n        self._remove_node(res)\n        return res\n    \n    \n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.size = 0\n        self.capacity = capacity\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        \n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        node = self.cache.get(key, None)\n        if not node:\n            return -1\n        self._move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        node = self.cache.get(key)\n\n        if not node:\n            newNode = DLinkedNode()\n            newNode.key = key\n            newNode.value = value\n            self.cache[key] = newNode\n            self._add_node(newNode)\n            self.size += 1\n            \n            if self.size > self.capacity:\n                res = self._pop_tail()\n                del self.cache[res.key]\n                self.size -= 1\n        else:\n            node.value = value\n            self._move_to_head(node)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000641837","body":"```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = []\n        if root:\n            stack.append((1, root))\n        depth = 0\n        while stack:\n            cur_depth, node = stack.pop()\n            if node:\n                depth = max(depth, cur_depth)\n                stack.append((cur_depth + 1, node.left))  \n                stack.append((cur_depth + 1, node.right))\n        return depth\n        ''' \n        if not root: return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left, right) + 1\n        '''\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000977813","body":"```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        '''\n        if p and not q: return False\n        if not p and q: return False\n        if not p and not q: return True\n        \n        if p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        '''\n        \n        if not p and not q: return True\n        \n        stack = []\n        stack.append((p,q))\n        \n        while stack:\n            node1, node2 = stack.pop()\n            if not node1 and not node2:\n                continue\n            if node1 and node2 and node1.val == node2.val:\n                stack.append((node1.left, node2.left))\n                stack.append((node1.right, node2.right))\n            else:\n                return False\n        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001108764","body":"```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n      \n        ans = 0\n        def dfs(node, cur_val):\n            nonlocal ans\n    \n            cur_val = cur_val * 10 + node.val\n            if node.left:\n                dfs(node.left, cur_val)\n            if node.right:\n                dfs(node.right, cur_val)\n            \n            if not node.left and not node.right:\n                ans += cur_val\n            return\n        \n        dfs(root, 0)\n        return ans\n        \n        \n        '''\n        ans = 0\n        stack = [(root, root.val)]\n        \n        while stack:\n            node, val = stack.pop()\n            if node.left:\n                leftval = val * 10 + node.left.val\n                stack.append((node.left, leftval))\n            if node.right:\n                rightval = val * 10 + node.right.val\n                stack.append((node.right, rightval))\n            if not node.left and not node.right:\n                ans += val\n        \n        return ans\n        '''\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991748173","body":"** 思路：**\r\n1. 从后向前依次取一位数字与k相加，余数等于和模10，并存入返回数组，令k除10，继续遍历\r\n2. 遍历结束，判断k是否为0， 不为0则循环继续将余数存入数组res, k除10，继续，直至k=0\r\n3. 反转数组res并返回\r\n\r\n** 复杂度分析: **\r\n- 时间复杂度:  O(max(n, m))， 其中n为数组num的长度，m为数字k的位数\r\n- 空间复杂度:  O (1)\r\n-\r\n** 代码(C++): **\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n\r\n        while (n >= 0) {\r\n            k += num[n];\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        // for the condition that k not 0\r\n        while (k) {\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992084192","body":"**思路:**\r\n1. 从前到后遍历，计算出每个字符的距离\r\n2. 从后到前再次遍历，计算出每个字符的距离取小值\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(n)，其中n是字符串的长度\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n\r\n        vector<int> res(n, n - 1);\r\n        int idx = n - 1;\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        idx = 0;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992747551","body":"**思路:**\r\n使用数组模拟栈\r\n\r\n**时间复杂度:**\r\n- 时间复杂度: O(1) - push, pop; O(k) - increment\r\n- 空间复杂度: O(maxSize)\r\n\r\n**代码(C++):**\r\n```\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (st.size() >= size) return;\r\n        st.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (st.size() == 0) return -1;\r\n        int val = st.back();\r\n        st.pop_back();\r\n        return (val);\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = (k <= st.size()) ? k : st.size();\r\n\r\n        for (int i = 0; i < idx; ++i)\r\n            st[i] += val;\r\n    }\r\nprivate:\r\n    int size;\r\n    vector<int> st;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994060650","body":"**思路:**\r\n使用辅助栈stack\r\n\r\n**复杂度分析:**\r\n- 时间复杂度：O(N)，其中 N 为解码后的 s 的长度\r\n- 空间复杂度：O(N)\r\n**代码（C++）：**\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack<string> st;\r\n        int n = s.length();\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            string tmp = \"\";\r\n            if (isalpha(s[i])) {\r\n                while (isalpha(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);\r\n            } else if (isdigit(s[i])) {\r\n                while (isdigit(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);    \r\n            } else if (s[i] == '[') {\r\n                tmp += s[i];\r\n                st.push(tmp);\r\n            }\r\n            else if (s[i] == ']') {\r\n                while (st.top() != \"[\") {\r\n                    tmp.insert(0, st.top());\r\n                    st.pop();\r\n                }\r\n                // pop out '['\r\n                st.pop();\r\n\r\n                int repeat = stoi(st.top());\r\n                st.pop();\r\n\r\n                string newstr = \"\";\r\n                while (repeat--)\r\n                    newstr += tmp;\r\n                st.push(newstr);\r\n            }\r\n        }\r\n\r\n        while (!st.empty()) {\r\n            res.insert(0, st.top());\r\n            st.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995025905","body":"**思路:**\r\n使用两个栈head, end来实现队列\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(n)\r\n\r\n**代码(C++):**\r\n```\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        while (!end.empty()) {\r\n            head.push(end.top());\r\n            end.pop();\r\n        }\r\n\r\n        end.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        while (!head.empty()) {\r\n            end.push(head.top());\r\n            head.pop();\r\n        }\r\n\r\n        int val = end.top();\r\n        end.pop();\r\n        return val;\r\n    }\r\n    \r\n    int peek() {\r\n        while (!head.empty()) {\r\n            end.push(head.top());\r\n            head.pop();\r\n        }\r\n\r\n        return end.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return head.empty() && end.empty();\r\n    }\r\nprivate:\r\n    stack<int> head, end;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996406879","body":"**思路:**\r\n利用单调队列(monotonic queue/stack)或单调栈来存放每个有效分块(Chunk)的最大值，遍历整个数组arr，比较当前数组元素与栈里元素的大小\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为给定数组的元素个数\r\n2. 空间复杂度: O(n), n为给定数组的元素个数\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> s;\r\n\r\n        for (int i = 0;i < arr.size();i++) {\r\n            if (s.empty() || s.top() <= arr[i])\r\n                s.push(arr[i]);\r\n            else {\r\n                int max_val = s.top();\r\n\r\n                while (!s.empty() && s.top() > arr[i]) // here is a while the worst case is O(n) here, but overall worst case is O(k * n), average is O(n)\r\n                    s.pop();\r\n                s.push(max_val);\r\n            }\r\n        }\r\n\r\n        return s.size();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997087989","body":"**思路:**\r\n先计算单项链的长度n，并将链尾与链首相连，最后根据n和k的大小关系切断链表\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为给定链表的长度\r\n2. 空间复杂度: O(1)\r\n\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head || !head->next) return head;\r\n\r\n        ListNode* p = head;\r\n        int n = 1;\r\n        while (p->next) {\r\n            p = p->next;\r\n            ++n;\r\n        }\r\n\r\n        int step = n - k % n;\r\n        // p points to the last node\r\n        p->next = head;\r\n\r\n        while(step--) {\r\n            head = head->next;\r\n            p = p->next;\r\n        }\r\n\r\n        p->next = nullptr;\r\n        return head;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997338529","body":"**思路:**\r\n1. 定义一个dummy结点，令其指向给定链表的头结点\r\n2. 定义两个指针pre, cur分别指向前置节点和当前节点\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为给定链表长度\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (!head || !head->next) return head;\r\n\r\n        ListNode* dummy = new ListNode(-1);\r\n        dummy->next = head;\r\n        ListeNode *pre = dummy,  cur = head;\r\n \r\n        while (cur && cur->next) {\r\n             ListNode* nxt = cur->next;\r\n             cur->next = nxt->next;\r\n             nxt->next = cur;\r\n             pre->next = nxt;\r\n\r\n             pre = cur;\r\n             cur = cur->next;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997683315","body":"**思路:**\r\n快慢指针取中间点\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(nlogn), n为给定链表长度\r\n2. 空间复杂度: O(logn), 递归栈\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (!head) return NULL;\r\n        if (!head->next) return new TreeNode(head->val);\r\n\r\n        ListNode *slow = head, *fast = head, *last = slow;\r\n\r\n        while (fast->next && fast->next->next) {\r\n            last = slow;\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(slow->val); // slow == root\r\n        fast = slow->next; // fast == first of right subtree\r\n        last->next = NULL;//last == end of left subtree\r\n        if (head != slow)\r\n            root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(fast);\r\n\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998399150","body":"**思路:**\r\n比较两个链表是否有交叉结点，定义两个指针p, q分别指向headA, headB\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n + m), n, m为给定链表A和B长度\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *pA = headA, *pB = headB;\r\n        while(pA != pB){\r\n            pA = pA ? pA->next : headB;\r\n            pB = pB ? pB->next : headA;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999115557","body":"**思路:**\r\n双指针 fast, slow， fast每次走两步，slow每次走一步\r\n如果fast和slow相遇，令fast从头head开始，各走一步，再次相遇时即为环的入口\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为树的节点数\r\n2. 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if (!head || !head->next) return NULL;\r\n        \r\n        ListNode *slow = head, *fast = head;\r\n        \r\n        while (fast && fast->next) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            \r\n            if (fast == slow) {\r\n                fast = head;\r\n                \r\n                while (fast != slow) {\r\n                    fast = fast->next;\r\n                    slow = slow->next;\r\n                }\r\n                \r\n                return fast;\r\n            }\r\n        }\r\n        \r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000092830","body":"**思路:**\r\n双向链表 + 哈希\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(1)\r\n2. 空间复杂度: O(capacity)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass LRUCache {\r\npublic:\r\n    struct DListNode {\r\n        int key;\r\n        int val;\r\n        DListNode* prev;\r\n        DListNode* next;\r\n        DListNode(int k, int v): key(k), val(v), prev(NULL), next(NULL) {}\r\n    };\r\n\r\n    LRUCache(int capacity) {\r\n        size = capacity;\r\n\r\n        head = new DListNode(-1, -1);\r\n        tail = new DListNode(-2, -2);\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!mp.empty() && mp.count(key)) {\r\n            DListNode* node = mp[key];\r\n            removenode(node);\r\n            add2tail(node);\r\n            return node->val;\r\n        }\r\n        \r\n        return -1;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        DListNode* node = NULL;\r\n\r\n        // not found\r\n        if (mp.empty() || !mp.count(key) && size > 0) {\r\n            node = new DListNode(key, value);\r\n            add2tail(node);\r\n            size--;\r\n        } else if (!mp.count(key) && size == 0) {\r\n            node = head->next;\r\n            removenode(node);\r\n            mp.erase(node->key);\r\n\r\n            node->key = key;\r\n            node->val = value;\r\n            add2tail(node);\r\n        } else if (mp.count(key)) {\r\n            node = mp[key];\r\n            node->val = value;\r\n            removenode(node);\r\n            add2tail(node);\r\n        }\r\n\r\n        // add to hashmap\r\n        mp[key] = node;\r\n    }\r\nprivate:\r\n    unordered_map<int, DListNode*> mp;\r\n    DListNode *head, *tail;\r\n    int size;\r\n    \r\n    \r\n    void removenode(DListNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n    \r\n    void add2tail(DListNode* node) {\r\n        tail->prev->next = node;\r\n        node->prev = tail->prev;\r\n        node->next = tail;\r\n        tail->prev = node;\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000575132","body":"**思路:**\r\n层序遍历\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为树的节点数\r\n2. 空间复杂度: O(k)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n\r\n        queue<TreeNode*> qt;\r\n        qt.push(root);\r\n\r\n        int depth = 0;\r\n        while (!qt.empty()) {\r\n            size_t size = qt.size();\r\n            while (size--) {\r\n                TreeNode* node = qt.front();\r\n                qt.pop();\r\n                if (node->left) qt.push(node->left);\r\n                if (node->right) qt.push(node->right);\r\n            }\r\n            ++depth;\r\n        }\r\n\r\n        return depth;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000982884","body":"**思路：**\r\n方法一、递归\r\n方法二、迭代 +   队列\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(min(m,n)), m, n为树的节点数\r\n2. 空间复杂度: \r\n    - 递归法：O(n),这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为O(n)\r\n    O(min(logm, logn)), logm/logn为树的深度, 递归栈的空间\r\n    - 迭代法：O(k), k为树的最大宽度（最宽的一层的节点数）O(min(m, n))\r\n\r\n**代码(C++):**\r\n```C++\r\n\r\n方法一、递归法(Recursion):\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n\t\tif (!p && !q) return true;\r\n\r\n\t\tif (!p || !q) return false;\r\n \r\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n\r\n方法二、迭代法:\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        queue<TreeNode*> p1, q1;\r\n        p1.push(p);\r\n        q1.push(q);\r\n\r\n        while (!p1.empty() && !q1.empty()) {\r\n            TreeNode* node_p = p1.front();\r\n            p1.pop();\r\n            TreeNode* node_q = q1.front();\r\n            q1.pop();\r\n\r\n            if (!node_p && !node_q) continue;\r\n\r\n            if (!node_p || !node_q || (node_p->val != node_q->val)) return false;\r\n\r\n            p1.push(node_p->left);\r\n            p1.push(node_p->right);\r\n            q1.push(node_q->left);\r\n            q1.push(node_q->right);\r\n        }\r\n\r\n        return true;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001087217","body":"**思路:**\r\n方法一、递归法（DFS）\r\n方法二、迭代法(BFS)\r\n\r\n**复杂度分析:**\r\n1. 时间复杂度: O(n), n为树的节点数\r\n2. 空间复杂度: DFS -> O(logn), 树的深度; BFS -> O(n)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\nprivate:\r\n    int dfs(TreeNode* node, int num) {\r\n        if (!node) return 0;\r\n\r\n        num = num *10 + node->val;\r\n\r\n        if (!node->left && !node->right)\r\n            return num;\r\n\r\n        return dfs(node->left, num) + dfs(node->right, num);\r\n    }\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        queue<TreeNode*> qt;\r\n        qt.push(root);\r\n\r\n        int sum = 0;\r\n        while (!qt.empty()) {\r\n            size_t size = qt.size();\r\n            while (size--) {\r\n                TreeNode* cur = qt.front();\r\n                qt.pop();\r\n\r\n                if (cur->left) {\r\n                    cur->left->val += cur->val * 10;\r\n                    qt.push(cur->left);\r\n                }\r\n                if (cur->right) {\r\n                    cur->right->val += cur->val * 10;\r\n                    qt.push(cur->right);\r\n                }\r\n\r\n                if (!cur->left && !cur->right) sum += cur->val;\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991823659","body":"Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n\r\nPython\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991959488","body":"遍历两遍array， 从左往右+从右往左。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [float(\"inf\")]*len(s)\r\n\r\n        idx = float(\"inf\")\r\n        for i,v in enumerate(s):\r\n            if v == c:\r\n                idx = i\r\n            else:\r\n                if idx != float(\"inf\"):\r\n                    ans[i] = i-idx\r\n        \r\n        idx = float(\"inf\")\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n                ans[i] = 0\r\n            else:\r\n                if idx != float(\"inf\"):\r\n                    ans[i] = min(ans[i], idx-i)\r\n        \r\n        return ans\r\n```\r\n时空O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993141103","body":"# 用list 模拟 stack 就行，\r\n记录三个attributes, maxSize, size, stack\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.size = 0\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if self.size>0:\r\n            self.size-=1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        num = min(k, self.size)\r\n        for i in range(num):\r\n            self.stack[i] += val\r\n```\r\nTime: O(1) excepts O(min(k, size)) for increment\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994269545","body":"# Stack\r\nWhenever we see bracket, we can think about the stack. \r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        res = \"\"\r\n        times = \"\"\r\n        for char in s:\r\n            if char == \"[\":\r\n                stack.append((res, times))\r\n                res = \"\"\r\n                times = \"\"\r\n            elif \"0\" <= char <= \"9\":\r\n                times += char\r\n            elif \"a\" <= char <= \"z\":\r\n                res += char\r\n            elif char == \"]\":\r\n                lastRes, lastTimes = stack.pop()\r\n                res = lastRes + int(lastTimes)*res\r\n        return res\r\n```\r\nTimes: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995433101","body":"用两个栈，一个出，一个入，一些细节需要注意\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            else:\r\n                return -1\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            else:\r\n                return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997009314","body":"# 双指针\r\n双指针，注意一些edge case\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not k or not head:\r\n            return head\r\n\r\n        cur = head\r\n        fast = slow = head\r\n        prev = None\r\n        cnt = 0\r\n        count = head\r\n        while count:\r\n            cnt += 1\r\n            count = count.next  \r\n\r\n        k = k%cnt\r\n\r\n        if k == 0:\r\n            return head\r\n\r\n        while k>1:\r\n            fast = fast.next\r\n            k-=1\r\n        while fast and fast.next:\r\n            fast = fast.next\r\n            prev = slow\r\n            slow = slow.next\r\n        fast.next = head\r\n        if prev:\r\n            prev.next = None\r\n        return slow\r\n\r\n\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997240111","body":"# 两个两个得换\r\n使用 dummy 和prev， prev指上一轮的前节点，dummy用来return \r\n```python\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n        \r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        l = head\r\n        prev = dummy = ListNode()\r\n        if head and head.next:\r\n            r = head.next\r\n        else:\r\n            return head\r\n        \r\n        rr = r.next\r\n\r\n        while l and r:\r\n            r.next = l\r\n            l.next = rr\r\n            prev.next = r\r\n\r\n            prev = l\r\n            l = rr\r\n            if l and l.next:\r\n                r = l.next\r\n                rr = r.next\r\n            else:\r\n                r = None\r\n        return dummy.next\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997515916","body":"# Recursive Build\r\n我们可以递归地实现： 因为最中间的必然是一个父节点\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n            \r\n        slow = fast = head\r\n        prev = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            prev = slow\r\n            slow = slow.next\r\n        \r\n        if prev:\r\n            prev.next = None\r\n\r\n        node = TreeNode(slow.val)\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n\r\n        return node\r\n```\r\ntime: T(n) = 2*T(n/2)+O(n) =>  O(nlogn)\r\nSpace: O(logn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998092465","body":"# 思路\r\n假设A链表单独的部分用A 表示， B链表单独的部分用B表示，共同拥有部分用C表示，因为 A+C+B = B+C+A； 我们可以同时遍历两个链表并且让他们为None时跳到对方头节点, 直到两者都为空或相同，表示他们相交的节点位置或者不相交（一旦都为空一定不相交，如果A B 长度一样那么 在到达C 入口时便会跳出while）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n\r\n            a = a.next\r\n            b = b.next\r\n            \r\n            if not a and not b:\r\n                return None\r\n\r\n            if not a:\r\n                a = headB\r\n            \r\n            if not b:\r\n                b = headA\r\n            \r\n        return a\r\n```\r\n时间 O(m+n) ; m n 为各自链表长度\r\n空间 O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999074413","body":"# 快慢指针\r\nLet fast be a pointer moves in the double pace of the slow pointer. Let them start at the same time.\r\n\r\nAssume we split the LinkedList into three parts:\r\n1. A: the part starting from the head to the entry node of the cycle\r\n2. B: the part that the fast and slow meet (it must be in the cycle if the cycle exists)\r\n3. C: the part the cycle - B\r\nSince fast moves twice speed as slow:\r\nA+B+C+B = 2(A+B)\r\nThus, A=C\r\nSince right now slow pointer is at the start of C. we can redirect fast to the head and allow fast and slow to move at the same speed by 1 node each time. Then, they will meet at the entry of the cycle.\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        '''\r\n        A + B + C + B = 2(A + B)\r\n        => A = C\r\n        => let fast and slow then move in the same pace\r\n        '''\r\n        fast = slow = head\r\n        if fast and fast.next:\r\n            fast = fast.next.next\r\n        else:\r\n            return None\r\n        \r\n        slow = slow.next\r\n        while fast != slow:\r\n            if fast and fast.next:\r\n                fast = fast.next.next\r\n            else:\r\n                return None\r\n            slow = slow.next\r\n\r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        return fast\r\n```\r\nTime: O(n), Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999727604","body":"# LRU\r\n使用 linkedList 来创建 LRU 缓存。\r\n\r\n```python\r\nclass Node:\r\n    def __init__(self,key=0, value=0):\r\n        self.key = key\r\n        self.val = value\r\n        self.prev = None\r\n        self.next = None\r\n    \r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.hash = {}\r\n        self.head = Node()\r\n        self.last = Node()\r\n        self.head.next = self.last\r\n        self.last.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hash:\r\n            return -1\r\n        node = self.hash[key]\r\n\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        self.appendToHead(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hash:\r\n            node = self.hash[key]\r\n            node.val = value\r\n            \r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n\r\n            self.appendToHead(node)\r\n            return\r\n        if self.size < self.capacity:\r\n            node = Node(key, value)\r\n            self.hash[key] = node\r\n            self.appendToHead(node)\r\n            self.size+=1\r\n        else:\r\n            self.replaceNode(key, value)\r\n    \r\n    def appendToHead(self, node):\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def replaceNode(self, newKey, newVal):\r\n        deleted = self.last.prev\r\n\r\n        del self.hash[deleted.key]\r\n        deleted.key = newKey\r\n        deleted.val = newVal\r\n        self.hash[newKey] = deleted\r\n\r\n        deleted.prev.next = deleted.next\r\n        deleted.next.prev = deleted.prev\r\n        self.appendToHead(deleted)\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n操作都是常数时间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850462","body":"### 代码\n``` Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n### 复杂度\n\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992040472","body":"### 代码\n``` python3\nclass Solution: \n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev_position=float('-inf')\n        result=[]\n        for i in range(len(s)):\n            if s[i] == c:\n                prev_position = i\n            result.append(i-prev_position)\n        prev_position=float('inf')\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                prev_position =i\n            result[i]= min(result[i],prev_position-i)\n        return result\n```\n\n### 复杂度\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993194847","body":"### 代码\n\n``` Python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.size_limit=maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size_limit:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994290427","body":"### 代码\n``` Python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for e in s:\n            if e==\"]\":\n                temp=[]\n                while stack[-1] != \"[\":\n                    temp.append(stack.pop())\n                stack.pop()\n                count=0\n                order=1\n                while stack and stack[-1].isnumeric():\n                    count+=int(stack.pop())*order\n                    order*=10\n                for i in range (count):\n                    stack.extend(temp[::-1])\n            else:\n                stack.append(e)\n        return \"\".join(stack)\n\n```\n\n### 复杂度\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995502931","body":"### 代码\n``` Python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n      \n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n       \n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997339366","body":"### 代码\n``` Python3\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or head.next is None:\n            return head\n        new_head=head.next\n        prev=ListNode(0)\n        while head and head.next:\n            current=head.next\n            head.next=current.next\n            current.next=head\n            prev.next=current\n            head=head.next\n            prev=current.next\n        return new_head\n```\n\n### 复杂度\n\nTime: O(n)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997622253","body":"### 代码\n``` Python3\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        dummy=ListNode(0)\n        dummy.next=head\n        slow, fast = dummy,head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        root=TreeNode(slow.next.val)\n        root.right=self.sortedListToBST(slow.next.next)\n        slow.next=None\n        root.left =self.sortedListToBST(head)\n        return root\n```\n\n### 复杂度\n\nTime: O(n)\n\nspace: O( n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999339481","body":"### 代码\n```python3\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow=fast=head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n            if slow==fast:\n                while head:\n                    if slow==head:\n                        return head    \n                    head=head.next\n                    slow=slow.next\n        return None\n```\n### 复杂度\n\nTime: O(n)\n\nSpace: O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001108490","body":"### 代码\n``` Python3\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        result=[]\n        path=[root.val]\n        def backtracking(node):\n            if not node.left and not node.right:\n                result.append(self.convet_to_in(path))\n                return \n            if node.left:\n                path.append(node.left.val)\n                backtracking(node.left)\n                path.pop()\n            if node.right:\n                path.append(node.right.val)\n                backtracking(node.right)\n                path.pop()\n        backtracking(root)\n        return sum(result)\n    def convet_to_in(self,arr):\n        number=0\n        mag=1\n        for i in range(len(arr)-1,-1,-1):\n            number+=arr[i]*mag\n            mag*=10\n        return number\n```\n\n### 复杂度\n\nTime: O(n)\n\nSpace: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993190950","body":"# Main idea\r\nArray\r\n# Code\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        temp = self.stack[-1]\r\n        self.stack.pop()\r\n        return temp\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack),k)):\r\n            self.stack[i] += val\r\n```\r\n# Complexity\r\nTime complexity: O(1)\r\nSpace complexity: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997157943","body":"# Main idea\r\nTraverse linkedlist in order to find the length(l) and the tail node of linkedliset. \r\nFind the link which needs to be broken. (l - k % l)\r\nBreak that link and then link the tail node with the original head node.\r\n# Code\r\n```py\r\nclass Solution:\r\n        \r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return None\r\n        current = head\r\n        tail = None\r\n        l = 0\r\n        while current:\r\n            l += 1\r\n            tail = current\r\n            current = current.next\r\n\r\n        if k % l == 0:\r\n            return head\r\n        \r\n        cur = head\r\n        pre = None\r\n        i = 0\r\n        while i < l - k % l:\r\n            pre = cur\r\n            cur = cur.next\r\n            i += 1\r\n        pre.next = None\r\n        tail.next = head\r\n        return cur\r\n```\r\n# Complexity\r\nTime complexity: O(n)\r\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997297998","body":"# Main idea\r\ndummy node - pre\r\nfirst - head\r\nsecond - head.next\r\n# Code\r\n```py\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(-1)\r\n        pre = dummy\r\n        first = head\r\n        second = head.next\r\n        \r\n        while first and second:\r\n            first.next = second.next\r\n            second.next = first\r\n            pre.next = second\r\n            pre = first\r\n            first = first.next\r\n            second = first.next if first else None\r\n        return dummy.next\r\n```\r\n# Complexity\r\nTime complexity: O(n)\r\nSpace complexity: O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999962840","body":"# Code\r\n```py\r\nclass ListNode:\r\n    def __init__(self, key, val):\r\n        self.key = key\r\n        self.val = val\r\n        self.next = None\r\n        self.pre = None\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.d = {}\r\n        self.head = ListNode(-1,-1)\r\n        self.tail = ListNode(-1, -1)\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n        # key 是value, key对应的value是double linkedlist 的node\r\n    def move_to_tail(self, key):\r\n        node = self.d[key]\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n        self.tail.pre.next = node\r\n        node.pre = self.tail.pre\r\n        node.next = self.tail\r\n        self.tail.pre = node\r\n        \r\n    def get(self, key: int) -> int:\r\n        if key in self.d:\r\n            self.move_to_tail(key)\r\n            return self.d[key].val\r\n        return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.d:\r\n            self.d[key].val = value\r\n            self.move_to_tail(key)\r\n        else:\r\n            if len(self.d) == self.capacity:\r\n                del self.d[self.head.next.key]\r\n                self.head.next = self.head.next.next\r\n                self.head.next.pre = self.head\r\n           \r\n                # delete a LRU, then put new pair in     \r\n            self.d[key] = ListNode(key, value)\r\n            new = self.d[key]\r\n            self.tail.pre.next = new\r\n            new.pre = self.tail.pre\r\n            new.next = self.tail\r\n            self.tail.pre = new\r\n```\r\n# Complexity\r\nTime complexity: O(1)\r\nSpace complexity: O(capacity)\r\n            ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991759056","body":"## 思路\r\n- 倒序遍历num ，把 k 转化为每一位，做加法注意carry flag。时间复杂度 O(n)，空间复杂度为O(1)。\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) { \r\n        \r\n        int i=num.size()-1; \r\n        int carry =0; \r\n        vector<int> ret; \r\n        while(k||carry||i<num.size())\r\n        {\r\n            int value ;\r\n            if(i>=0)\r\n            {\r\n              value = k%10 + num[i] + carry; \r\n            }\r\n            else\r\n            {\r\n                value = k%10 + carry; \r\n            }\r\n            \r\n            carry = value/10; \r\n            ret.push_back(value%10); \r\n            \r\n            k = k/10; \r\n            i--; \r\n        }\r\n        \r\n        reverse(ret.begin(), ret.end()); \r\n        \r\n        return ret; \r\n        \r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991956160","body":"## 思路\n- f(i)为第i个位置的最短距离，f(i)和s字符串中在i 的前后最近的c 位置相关，有时候一次同时处理两个位置比较难，但是可分解成先处理前面的最近位置，再处理后面的最近位置则比较容易。实现方法，两次遍历，先从前往后，找到前面的最近位置，再从后往前，找到后面的最近位置，返回两次中最小的。时间复杂度为O(N)，空间复杂度为O(1)，不考虑输出的话。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        vector<int> ret(s.size(), INT_MAX); \n        // loop left. \n        int pos = -1; \n        for(int i=0; i< s.size(); i++)\n        {\n            if(s[i]==c)\n            {\n                pos = i; \n                ret[i] =0; \n            }\n            else if(pos!=-1)\n            {\n                ret[i] = i - pos; \n            }\n        }\n        pos = -1; \n        for(int i= s.size()-1; i>=0; i--)\n        {\n            if(s[i]==c)\n            {\n                pos = i; \n                ret[i] =0; \n            }\n            else if(pos!=-1)\n            {\n                ret[i] = min(ret[i], pos -i); \n            }\n        }\n        \n        return ret; \n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992810434","body":"## 思路\n- 关键点如何处理incremental  number。利用一个数组记录对应位置的incremental，当pop时，累加当前位置的incremental value，同时把该incremental value传递前一个index。使用如下例子  stack   [  1  2  3  4 5]   incremental [100 100 100  100 100]  当pop  是  5 + 100    后stack  [ 1 2 3 4]  incremental [ 100 100 100 200]  再pop是  4 + 200 。这样起到累加的效果。时间复杂度为  O(1) ，空间复杂度为 O(N)，N为最大设置stack size。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass CustomStack {\npublic:\n    \n    vector<int> stack; \n    int iSize; \n    vector<int> incSum; \n    CustomStack(int maxSize) {\n        \n        iSize = maxSize; \n        incSum.assign(iSize, 0); \n    }\n    \n    void push(int x) {\n        \n        if(stack.size() < iSize)\n        {\n            stack.push_back(x); \n        }        \n    }\n    \n    int pop() {\n        \n        if(stack.size())\n        {\n            int index = stack.size()-1;\n            int addValue = incSum[index];\n            if(index>0)\n            {\n                incSum[index-1] += addValue;                  \n            }\n            incSum[index] =0;            \n            int ret = stack.back() + addValue; \n            stack.pop_back();\n            return ret; \n        }\n        else\n            return -1; \n        \n    }\n    \n    void increment(int k, int val) {\n        \n        int index = min(k, int(stack.size()) ); \n        if(index>0)\n        {\n            incSum[index-1] += val; \n        }        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994403337","body":"## 思路\n- 对于括号匹配问题，栈是优先考虑的方法，也可以使用递归解法。一般我们定义递归方法要找到当前问题，如何进一步分解下一个子问题，最后考虑base情况如何返回，但是本问题复杂在于除了括号的嵌套，还有同层的括号。因此在递归回来后，还继续处理下一个问题。因此利用start 引用传递子问题完成到那个index，返回后继续操作。时间复杂度为O(n)，空间复杂度O(n). \n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        \n        int start =0; \n        return dfs(s, start);\n        \n    }\n    \n    string dfs(string& s, int& start)\n    {\n        string ret; \n        int num =0; \n        for( ; start< s.size(); start++)\n        {\n            if(s[start]>='0' && s[start]<='9')\n            {\n                num = (num*10 + (s[start]-'0')); \n            }\n            else if(s[start] == '[')\n            {\n                start++; \n                string tmp = dfs(s, start); \n                \n                for(int j=0; j< num; j++)\n                {\n                    ret += tmp; \n                }\n                num =0;\n            }\n            else if(s[start] == ']')\n            {\n                return ret; \n            }\n            else\n            {\n                ret.push_back(s[start]); \n            }\n        }\n        \n        return ret; \n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995404870","body":"## 思路\n- 使用两个stack来模拟queue。因为stack 为先进后出，queue 为先进先出，因为两个stack两次reverse就能实现queue。具体实现，1个stack 放push ，另外一个stack 放pop。当pop为空时，把push stack的元素push 出来，放入pop stack。时间负责度为平均为 O(1)\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass MyQueue {\npublic:\n    \n    vector<int> pushStack; \n    vector<int> popStack; \n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        \n        pushStack.push_back(x); \n        \n    }\n    \n    int pop() {\n        \n        pushAllNode(); \n        if(popStack.size())\n        {\n            int ret = popStack.back(); \n            popStack.pop_back();\n            return ret;         \n        }\n        else\n            return -1; \n        \n    }\n    \n    int peek() {\n        pushAllNode(); \n        if(popStack.size())\n        {        \n            int ret = popStack.back(); \n            return ret; \n        }\n        else\n            return -1; \n    }\n    \n    bool empty() {\n        \n        return popStack.size()==0 && pushStack.size()==0; \n        \n    }\n    \n    void pushAllNode()\n    {\n        if(popStack.size()==0 )\n        {\n            while(pushStack.size())\n            {\n                int topNode = pushStack.back(); \n                pushStack.pop_back(); \n                popStack.push_back(topNode); \n            }\n        }        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996455653","body":"## 前置知识\n-  方法1， 考虑对数组进行排序，然后遍历整个数组，记录[0 i] 之前最大数的index。如果该index = i，则表明当前数在正确的index，则表明从当前位置split 是可以保证正确的顺序。 时间复杂度O(n+nlogn+n)\n- 方法2， 因为比较关键是如果数组本身是单调递增序列，则split就为当前数组的个数。因此考虑使用递增的单调栈方法，本题困难在于 stack.top()  < num[i] 。我们要如何更新。考虑[2 1 3 4 4]。第一个栈顶为2  当处理到 1 因为1<2。我们要把栈中2 pop出来，我们要再放入 2。而不是1。也就是过去最大。时间复杂度为O(n)，空间复杂度为O(n)。\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        \n        \n        /// increase stack. \n        \n        vector<int> stack; // increase stack. \n        int imax = arr[0]; \n        for(int i=0; i< arr.size(); i++)\n        {\n           imax = max(imax, arr[i]) ;            \n           while(stack.size() && (arr[i]<stack.back()) )\n           {\n               stack.pop_back(); \n           }\n           stack.push_back(imax);  \n        }\n        \n        return stack.size(); \n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997013200","body":"## 思路\n- 比较直接，如果移动次数等于链表的元素个数，则回到原始链表。首先遍历链表，统计链表的个数N，然后对k%N求余数，移动次数范围为[0, N-1]。当为0时，则为原始链表，直接返回，考虑移动2次，对应把链表从N-2-1 处砍断，把最后前后位置交换。因此找到N- k -1 的链表元素，进行交换。时间仿真度为 O(N)，空间复杂度为O(1)。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n        if(head == NULL)\n            return head; \n        ListNode* tail = NULL; \n        int listNum = CountNum(head, tail); \n        k = k%listNum; // [0 listNum); \n        if(k==0)\n            return head; \n        k = listNum -k; // 1 --> 4   4 --->1. \n        \n        ListNode* prevNode = moveKNode(head, k-1); \n        //  cut prevNode.  And put end into beginning. \n        ListNode* nextNode = prevNode->next; \n        prevNode->next = NULL;\n        tail->next = head; \n        \n        return nextNode;                         \n    }\n    \n    int CountNum(ListNode* head, ListNode* & tail )\n    {\n        int i=0; \n\n        while(head)\n        {\n            tail = head; \n            head = head->next; \n            i++;\n        }\n        return i;             \n    }\n    \n    ListNode* moveKNode(ListNode* head, int k)\n    {\n        // k>=1 K<= maxSize; \n        while(k)\n        {\n            head = head->next; \n            k--; \n        }\n        return head; \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997277114","body":"## 思路\n- 比较直接，链表的操作注意避免环，以及利用虚头结点。因为头指针可能发生变化。交换涉及到4个结点。prevNode  -> currentNode  -> nextNode -> nextnextNode  变成  prevNode -> nextNode -> currentNode -> nextnextNode 。因此核心操作。 prevNode->next = nextNode  nextNode->next = currentNode  currentNode->next = nextnextNode.  然后更新 prevNode 和  currentNode。    时间复杂度为 O(N)，空间复杂度为 O(1)。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        \n        ListNode tmpHead; \n        tmpHead.next = head; \n        \n        ListNode* prev = & tmpHead; \n        ListNode* current = prev->next; \n        \n        while(current && current->next)\n        {\n            ListNode* nextNext = current->next->next; \n            \n            prev->next = current->next; \n            current->next->next = current; \n            \n            current->next = nextNext; \n            \n            prev = current; \n            current = nextNext; \n        }\n        \n        return tmpHead.next; \n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997445170","body":"## 思路\n- 方法1，可把链表转换为vector 。通过vector 来生成平衡二叉搜索树。时间复杂度为O(n)，空间复杂度为O(n)。\n- 方法2，进一步优化方法1的内存，先遍历链表，拿到总的size，可通过模拟中序遍历，来生成平衡二叉搜索树，则遍历顺序和链表的顺序相同。时间复杂度为O(n)，空间复杂度为 O(log N)，为递归树的深度。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        // method 1. Convert List to vector. Then generate. \n        \n        if(head == NULL)\n            return NULL; \n        vector<int> record; \n        while(head)\n        {\n            record.push_back(head->val); \n            head =head->next; \n        }\n        \n        return dfs(record, 0, record.size()-1);\n    }\n    \n    TreeNode* dfs(vector<int>& record, int start, int end)\n    {\n        if(start>end)\n            return NULL; \n        int middle = start + (end - start)/2; \n        \n        TreeNode* current = new TreeNode(record[middle]); \n        \n        current->left = dfs(record, start, middle-1); \n        current->right =dfs(record, middle+1, end); \n        \n        return current; \n        \n    }\n};\n\n```\n```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        // method 1. Convert List to vector. Then generate. \n        \n        if(head == NULL)\n            return NULL; \n        int size =0;\n        ListNode* current = head; \n        while(current)\n        {\n            size++; \n            current =current->next; \n        }\n        \n        return dfs(head, 0, size-1);\n    }\n    \n    TreeNode* dfs(ListNode* & head, int start, int end)\n    {\n        if(start>end)\n            return NULL; \n        int middle = start + (end - start)/2; \n        \n        TreeNode* nodeleft = dfs(head, start, middle-1);\n        TreeNode* current = new TreeNode(head->val);\n        head = head->next; \n        TreeNode* noderight =dfs(head, middle+1, end); \n        current->left = nodeleft; \n        current->right = noderight; \n        return current; \n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998553894","body":"-  找交叉点有两种方法，1种利用hashset 存储已经遍历的节点，当找到在set种出现的第一个节点为第一个交叉节点。第二种方法，利用双指针同时遍历两个list，当一个list走到头，切换到另外一个list。当两个碰到第一个交叉点时候，list1 list2 指向同一个节点。时间复杂度为 O(N+M)，空间复杂度为 O(1).\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        \n        // we can use map. or use switching method. \n        ListNode* list1 = headA; \n        ListNode* list2 = headB; \n        \n        while(list1!=list2)\n        {\n            if(list1 == NULL)\n                list1 = headB; \n            else\n                list1 = list1->next; \n            \n            if(list2 == NULL)\n            {\n                list2 = headA; \n            }\n            else\n                list2 = list2->next; \n        }\n        \n        return list1;         \n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999342165","body":"## 思路\n- 假设整个链表分成两部分  第一部分为 l  另外环路部分为 m 。使用快慢指针，找到位置为距离环的起点为x 。 (l + x)*2  = l + m + x  可计算得到x+l = m 。再把其中一个指针移动到起点，再移动l 后两个指针在环的起点相遇。时间复杂度为O( n )，空间复杂度为O(1)。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        \n        \n        if(head == NULL || head ->next == NULL)\n            return NULL; \n        ListNode* fast = head; \n        ListNode* slow = head; \n        \n        while(fast && fast->next)\n        {\n            fast = fast->next->next; \n            slow = slow->next; \n            if(fast ==slow)\n                break; \n        }\n        \n        if(fast != slow)\n            return NULL; \n        \n        fast = head; \n        while(fast !=slow)\n        {\n            fast =fast->next; \n            slow = slow->next; \n        }\n        \n        return fast; \n        \n    }\n};\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000064489","body":"## 思路\n- 为了实现动态的删除，插入，需要链表结构，使用list。另外需要O(1)去访问数据，需要hash map。结合两个数据结构，增加一个新的数据结构，用来存储key 到list iterator之间的关系。时间复杂度为 O(1)，空间复杂度为 O(N)。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass LRUCache {\npublic:\n    list<int> keyList; \n    unordered_map<int, int> keyToValue; \n    unordered_map<int, list<int>::iterator> keyToList; \n    int maxSize; \n    LRUCache(int capacity) {\n        maxSize = capacity; \n    }\n    \n    int get(int key) {\n        \n        if(keyToValue.count(key))\n        {\n            auto it= keyToList[key]; \n            keyList.erase(it); \n            keyList.push_front(key); \n            keyToList[key] =  keyList.begin();\n            return keyToValue[key]; \n        }\n        else\n        {\n            return -1; \n        }\n        \n    }\n    \n    void put(int key, int value) {\n        \n        // first check if has key. yes. Then remove old and change to latest. \n        if(keyToValue.count(key))\n        {\n            auto it = keyToList[key]; \n            keyList.erase(it); \n            keyList.push_front(key); \n            keyToList[key] = keyList.begin(); \n            keyToValue[key] = value; \n        }\n        // if size < maxSize. Then put it. \n        else if(keyList.size()<maxSize)\n        {\n            keyList.push_front(key); \n            keyToValue[key] = value; \n            keyToList[key] = keyList.begin(); \n        }\n        // if size == maxSize. we remove the oldest one and insert it. \n        else\n        {\n            // remove the first key. \n            keyToValue.erase(keyList.back()); \n            keyToList.erase(keyList.back());  \n            keyList.pop_back(); \n            \n            keyList.push_front(key); \n            keyToList[key] = keyList.begin(); \n            keyToValue[key] = value; \n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000531759","body":"## 思路\n- 方法1 使用前序遍历，传入parent节点的level，进入下一层。通过dfs找到最大深度。时间复杂度为O(n)，空间复杂度最差为O(n)，为树的深度\n- 方法2 使用后序遍历，计算左右孩子节点深度，比较后得到root的深度，传回。时间复杂度为O(n)，空间复杂度最差为O(n)，为树的深度\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        \n        int ret =0; \n        dfs(root, 0, ret); \n        return ret; \n    }\n    \n    void dfs(TreeNode* root, int level, int& ret)\n    {\n        if(root == NULL)\n            return; \n        \n        ret = max(ret, level+1); \n        \n        dfs(root->left, level+1, ret); \n        dfs(root->right, level+1, ret); \n    }\n};\n\n```\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        \n        return dfs(root); \n    }\n    \n    int dfs(TreeNode* root)\n    {\n        if(root == NULL)\n            return 0; \n        \n        \n        int ileft = dfs(root->left); \n        int iright = dfs(root->right); \n        return max(ileft, iright) +1; \n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001074395","body":"## 思路\n- 分析当前节点数值和上一层相关，val = prevVal*10 + currentVal。因此采用前序遍历，当为leaf 节点时，把数sum起来。时间复杂度为O(N)，空间复杂度为O(N)，为递归的深度。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n         \n        int ret =0; \n        dfs(root, 0, ret); \n        return ret; \n    }\n    \n    void dfs(TreeNode* root, int val, int& ret)\n    {\n        if(root==NULL)\n            return; \n        int currentVal = val*10 + root->val; \n        if(root->left == NULL && root->right==NULL)\n        {\n             ret += (currentVal);\n             return ; \n        }\n        \n        dfs(root->left, currentVal, ret); \n        dfs(root->right, currentVal, ret); \n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829384","body":"## 思路\r\n遍历合并，类似合并有序数组/链表。\r\n## 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    ans = [];\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        val1 = i >= 0 ? num[i] : 0;\r\n        val2 = k != 0 ? k % 10 : 0;\r\n        \r\n        sum = val1 + val2 + carry;\r\n        carry = Math.floor(sum / 10);\r\n        sum = sum % 10;\r\n        \r\n        ans.push(sum);\r\n        \r\n        i--;\r\n        k = Math.floor(k/10);\r\n    }\r\n    \r\n    if (carry != 0) {\r\n        ans.push(carry);\r\n    }\r\n\r\n    return ans.reverse();\r\n};\r\n```\r\nTC: O(max(N, logK))\r\nSC: O(max(N, logK))\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992053100","body":"## 思路\r\n正序遍历和逆序遍历，取最小值\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        \r\n        int count = n + 1;\r\n        for (int i=0; i<n; i++) {\r\n            char cur = s.charAt(i);\r\n            count = cur == c ? 0 : count + 1;\r\n            ans[i] = count;\r\n        }\r\n        \r\n        for (int i=n-1; i>=0; i--) {\r\n            char cur = s.charAt(i);\r\n            count = cur == c ? 0 : count + 1;\r\n            ans[i] = Math.min(ans[i], count);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\nTC: O(n)\r\nSC: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993189185","body":"## 思路\r\n用一个增量数组记录增值\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    Deque<Integer> stack;\r\n    int[] incre;\r\n    int size;\r\n    int max;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new LinkedList<>();\r\n        incre = new int[maxSize + 1];\r\n        max = maxSize;\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size < max) {\r\n            stack.push(x);\r\n            size++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n\r\n        int val = stack.pop();\r\n        if (incre[size] != 0) {\r\n            val += incre[size];\r\n            incre[size - 1] += incre[size];\r\n            incre[size] = 0;\r\n        }\r\n        size--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int total = Math.min(k, size);\r\n        incre[total] += val;\r\n    }\r\n}\r\n\r\n```\r\nTC: push: O(1), pop (1), increment O(1)\r\nSC: O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994208625","body":"### 思路\r\n1. 如果`s[i]`是字符，解析全部字符，比如\"abc\"，然后入栈；\r\n2. 如果`s[i]`是数字，解析全部数字，比如\"123\"，然后入栈；\r\n3. 如果`s[i]`是`'['`，放入栈内\r\n4. 如果`s[i]`是`']'`，开始解析\r\n    1. 字符串出栈，直到碰到`'['`，所有出栈的字符串拼接到一起。\r\n    2. `'['`出栈\r\n    3. 下一个栈顶的是数字，出栈，然后按照这个数字重复拼接字符串\r\n    4. 最后把处理好的字符串再放入栈内。\r\n5. 遍历结束后，所有栈内字符串出栈，反向拼接，输出\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<String> stack = new LinkedList<>();\r\n        int n = s.length();\r\n        char[] chars = s.toCharArray();\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        int i = 0;\r\n        while (i < n) {\r\n            if (Character.isLetter(chars[i])) {\r\n                while (i < n && Character.isLetter(chars[i])) {\r\n                    sb.append(chars[i]);\r\n                    i++;\r\n                }\r\n                stack.push(sb.toString());\r\n                sb.setLength(0);\r\n            } else if (Character.isDigit(chars[i])) {\r\n                while (i < n && Character.isDigit(chars[i])) {\r\n                    sb.append(chars[i]);\r\n                    i++;\r\n                }\r\n                stack.push(sb.toString());\r\n                sb.setLength(0);\r\n            } else if (chars[i] == '[') {\r\n                stack.push(\"[\");\r\n                i++;\r\n            } else if (chars[i] == ']') {\r\n                while (!stack.isEmpty() && !stack.peek().equals(\"[\")) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String str = sb.toString();\r\n                \r\n                if (stack.size() < 2) {\r\n                    return null;\r\n                }\r\n                // pop the \"[\"\r\n                stack.pop();\r\n                \r\n                // pop the number\r\n                int times = 0;\r\n                try {\r\n                    times = Integer.parseInt(stack.pop());\r\n                } catch (Exception e) { // NumberException\r\n                    return null;\r\n                }\r\n                \r\n                // repeat\r\n                sb.setLength(0);\r\n                while (times > 0) {\r\n                    sb.append(str);\r\n                    times--;\r\n                }\r\n                \r\n                // push back\r\n                stack.push(sb.toString());\r\n                sb.setLength(0);\r\n                \r\n                i++;\r\n            }\r\n        }\r\n        \r\n        while (!stack.isEmpty()) {\r\n            sb.insert(0, stack.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n- TC: O(n) n为输出字符串长度\r\n- SC: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995464008","body":"## 思路\r\n两个栈，分别负责读写\r\n## 代码\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> in;\r\n    Deque<Integer> out;\r\n    public MyQueue() {\r\n        in = new LinkedList<>();\r\n        out = new LinkedList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (empty()) {\r\n            return -1;\r\n        }\r\n        \r\n        if (out.isEmpty()) {\r\n            peek();\r\n        }\r\n        \r\n        return out.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!out.isEmpty()) {\r\n            return out.peek();\r\n        }\r\n        while (!in.isEmpty()) {\r\n            out.push(in.pop());\r\n        }\r\n        \r\n        return out.isEmpty() ? -1 : out.peek();        \r\n    }\r\n    \r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n        \r\n    }\r\n}\r\n```\r\nTC: push O(1), pop O(n), peek O(n), empty O(1)\r\nSC: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996463552","body":"## 思路\r\n单调递增栈，遍历数组，保存每个排序块的最大数字：\r\n1. 如果当前数字不小于栈顶，就入栈（分块的最大数字）\r\n2. 否则，当前数字要合并到栈顶数字的块里，栈内数字依次出栈，直到栈顶<=当前数字。再把原来的栈顶入栈。\r\n最后返回栈长度。\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList<>();\r\n        for (int num : arr) {\r\n            if (stack.isEmpty() || stack.peek() <= num) {\r\n                stack.push(num);\r\n            } else {\r\n                int top = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > num) {\r\n                    stack.pop();\r\n                }\r\n                \r\n                stack.push(top);\r\n            }\r\n        }\r\n        \r\n        return stack.size();\r\n    }\r\n}\r\n```\r\nTC: O(n)\r\nSC: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997138417","body":"## 思路\r\n1. 算出链表长度，找到实际的旋转次数 k % len\r\n2. 找倒数第k个节点的前面那个节点，顺便找到尾节点\r\n3. 头节点、尾节点、倒数第k个节点和它前面那个节点，这四个节点按照题意修改next指针。\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        int len = 0;\r\n        ListNode p = head;\r\n        while (p != null) {\r\n            len++;\r\n            p = p.next;\r\n        }\r\n        if (len == 0) {\r\n            return head;\r\n        }\r\n        \r\n        k = k % len;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        \r\n        ListNode prev = head;\r\n        ListNode tail = head;\r\n        while (tail.next != null) {\r\n            tail = tail.next;\r\n            k--;\r\n            if (k < 0) {\r\n                prev = prev.next;\r\n            }\r\n        }\r\n        \r\n        ListNode newHead = prev.next;\r\n        prev.next = null;\r\n        tail.next = head;\r\n        \r\n        return newHead;\r\n    }\r\n}\r\n```\r\nTC: O(n)\r\nSC: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997292409","body":"## 思路\r\n每次反转2个节点，定义四个指针，分别指向这两个节点，它们前面的那个节点和它们后面的那个节点。根据题意修改next指针\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode prev = dummy;\r\n        while (prev != null && prev.next != null) {\r\n            prev = swapNextPair(prev);\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n    \r\n    private ListNode swapNextPair(ListNode prev) {\r\n        if (prev == null || prev.next == null || prev.next.next == null) {\r\n            return null;\r\n        }\r\n        \r\n        // 四个指针：指向这两个节点，它们前面的节点和它们后面的节点\r\n        ListNode p1 = prev.next;\r\n        ListNode p2 = p1.next;\r\n        ListNode next = p2.next;\r\n        \r\n        prev.next  = p2;\r\n        p2.next = p1;\r\n        p1.next = next;\r\n        \r\n        // 最后返回下一组两个节点的前面的节点\r\n        return p1;\r\n    }\r\n}\r\n```\r\nTC: O(n)\r\nSC: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997585495","body":"## 思路\r\n把头节点定义成全局（类）变量，中序遍历同时遍历链表，生成树的节点\r\n## 代码\r\n```java\r\nclass Solution {\r\n    ListNode cur;\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        int len = 0;\r\n        ListNode p = head;\r\n        while (p != null) {\r\n            len++;\r\n            p = p.next;\r\n        }\r\n        \r\n        cur = head;\r\n        return inorder(head, 0, len - 1);\r\n    }\r\n    \r\n    private TreeNode inorder(ListNode head, int start, int end) {\r\n        if (start > end) {\r\n            return null;\r\n        }\r\n        \r\n        int mid = start + (end - start) / 2;\r\n        \r\n        TreeNode left = inorder(head, start, mid - 1);\r\n        TreeNode root = new TreeNode(cur.val);\r\n        cur = cur.next;\r\n        TreeNode right = inorder(head, mid + 1, end);\r\n        \r\n        root.left = left;\r\n        root.right = right;\r\n        return root;\r\n    }\r\n}\r\n```\r\nTC: O(N)\r\nSC: O(logN)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998389285","body":"### 思路\r\n双指针a和b一起遍历链表\r\na先指向headA，遍历结束后指向headB\r\nb先指向headB，遍历结束后指向headA\r\n最后a == b的时候就是相交节点，或者null表示不相交。\r\n### 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        \r\n        return pA;\r\n    }\r\n}\r\n```\r\n- TC: O(m + n)\r\n- SC: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999118827","body":"### 思路\r\n龟兔赛跑确认存在环。\r\n之后fast指针指向head，fast / slow每次移动一步，再次相遇的地方就是交点。\r\n### 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (fast == null || fast.next == null) {\r\n            return null;\r\n        }\r\n        \r\n        \r\n        fast = head;\r\n        while (fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        return fast;\r\n    }\r\n}\r\n```\r\n- TC: O(n)\r\n- SC: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000040340","body":"## 思路\r\nLinkedHashMap\r\n## 代码\r\n```java\r\nclass LRUCache {\r\n    class ListNode {\r\n        int key;\r\n        int val;\r\n        ListNode next;\r\n        ListNode prev;\r\n        ListNode(int key, int val) {\r\n            this.next = null;\r\n            this.prev = null;\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n    }\r\n\r\n    int maxSize;\r\n    ListNode head;\r\n    ListNode tail;\r\n    Map<Integer, ListNode> map;\r\n    public LRUCache(int capacity) {\r\n        maxSize = capacity;\r\n        head = new ListNode(0, 0);\r\n        tail = new ListNode(0, 0);\r\n        head.next = tail;\r\n        tail.prev = head;\r\n        map = new HashMap<>();\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        \r\n        ListNode node = map.get(key);\r\n        unlink(node);\r\n        moveToHead(node);\r\n        return node.val;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        ListNode node;\r\n        if (map.containsKey(key)) {\r\n            node = map.get(key);\r\n            node.val = value;\r\n        } else {\r\n            node = new ListNode(key, value);\r\n            if (map.size() == maxSize) {\r\n                ListNode lruNode = tail.prev;\r\n                unlink(lruNode);\r\n                map.remove(lruNode.key);\r\n            }\r\n            map.put(key, node);\r\n        }\r\n        \r\n        unlink(node);\r\n        moveToHead(node);\r\n    }\r\n    \r\n    private void unlink(ListNode node) {\r\n        ListNode prev = node.prev;\r\n        ListNode next = node.next;\r\n        if (prev != null) {\r\n            prev.next = next;\r\n        }\r\n        if (next != null) {\r\n            next.prev = prev;\r\n        }\r\n    }\r\n    \r\n    private void moveToHead(ListNode node) {\r\n        ListNode nextHead = head.next;\r\n        \r\n        head.next = node;\r\n        node.prev = head;\r\n        \r\n        nextHead.prev = node;\r\n        node.next = nextHead;\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000580485","body":"## 思路\r\n后序DFS\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```\r\nSC: O(N)\r\nTC: O(logN)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000952577","body":"## 思路\r\n先序DFS\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else {\r\n            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```\r\nSC: O(N)\r\nTC: O(logN)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001098412","body":"## 思路\r\n后序DFS\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        if (root.left == null && root.right == null) {\r\n            return root.val;\r\n        }\r\n        \r\n        int total = 0;\r\n        if (root.left != null) {\r\n            root.left.val += root.val * 10;\r\n            total += sumNumbers(root.left);\r\n        }\r\n        if (root.right != null) {\r\n            root.right.val += root.val * 10;\r\n            total += sumNumbers(root.right);\r\n        }\r\n        return total;\r\n    }\r\n}\r\n```\r\nSC: O(N)\r\nTC: O(logN)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991699058","body":"思路：\r\n创建一个out数组用于存放结果。\r\npre代表进位，sum代表总和,k代表被加数\r\n数组从n-1到0开始遍历， 但是for的判断条件有i>=0||k>0||pre>0\r\n如果i>=0，则 sum= num[i]+k%10+pre\r\n否则 sum= k%10+pre\r\n最后处理：pre = sum/10; k /= 10 添加到out数组\r\n最后翻转数组即可\r\n```Go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    n := len(num)\r\n    pre,sum:=0,0\r\n    out := []int{}\r\n    for i:=n-1;i>=0||k>0||pre>0;i--{\r\n        if i >= 0{\r\n            sum = num[i]+k%10+pre\r\n        }else{\r\n            sum =k%10 + pre\r\n        }\r\n        pre = sum/10\r\n        k /= 10\r\n        out = append(out,sum%10)\r\n    }\r\n    reverse(out)\r\n    return out\r\n}\r\nfunc reverse(out []int) []int{\r\n    for i:=0;i<len(out)/2;i++{\r\n        out[i],out[len(out)-1-i] = out[len(out)-1-i] , out[i]\r\n    }\r\n    return out\r\n}\r\n```\r\n时间复杂度O（n）\r\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991925070","body":"思路：\r\n字符的最短距离，可以从前往后遍历，以及从后往前遍历求最小值。\r\n初始化一个out数组\r\n令flag = -1 ，flag表示前一个字符c出现的位置。\r\n从前往后遍历：（1）判断是否该字符为c （2）若c存在【flag >= 0】则此时out[i] = i-flag 否则 out[i] = math.MaxInt32\r\n从后往前遍历：（1）判断是否该字符为c （2）若c存在【flag >= 0】则此时out[i] = min（out[i]，flag-i）\r\n第二次遍历记得比较大小，为了得到最优解。求个最小值。\r\n最后题目出问题的地方是：flag >= 0 考虑 字符c在第一个的情况！\r\n```Go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    out := make([]int,len(s))\r\n    flag := -1\r\n    for i :=0;i<len(s);i++{\r\n        if s[i] == c{\r\n            flag = i\r\n        }\r\n        if flag >= 0{\r\n            out[i] = i-flag\r\n        }else{\r\n            out[i] = math.MaxInt32\r\n        }\r\n    }\r\n    flag = -1\r\n    for i := len(s)-1;i>=0;i--{\r\n        if s[i] == c{\r\n            flag = i\r\n        }\r\n        if flag >= 0{\r\n            out[i] = min(out[i],flag-i)\r\n        }\r\n    }\r\n    return out\r\n}\r\nfunc min(a,b int)int{\r\n    if a < b{\r\n        return a\r\n    }\r\n        return b\r\n}\r\n```\r\n时间复杂度O（N）\r\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992622969","body":"思路：\r\n构造函数构造栈以及容量\r\n入栈需要判断栈是否满了，如果不满才可以进行入栈操作\r\n出栈需要判断栈是否为空，不为空才能出栈\r\n批量增加，要判断此时的k是否大于栈的元素，如果大于要置为k，此时一个for循环遍历批量增加\r\n```Go\r\ntype CustomStack struct {\r\n    stack []int\r\n    total int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{[]int{},maxSize}\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) <this.total{\r\n        this.stack = append(this.stack,x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) == 0{\r\n        return -1\r\n    }\r\n    out := this.stack[len(this.stack)-1]\r\n    this.stack = this.stack[:len(this.stack)-1]\r\n    return out\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack){\r\n        k = len(this.stack)\r\n    }\r\n    for i:=0;i<k;i++{\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n入栈，出栈 时间复杂度O（N）\r\n增量操作O（k）\r\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993696758","body":"思路：\r\n涉及到字符串解码，用栈是合理做法。\r\n这里的关键判断是 数字、 【、】、字符\r\n因此可以考虑用数字栈和字符串栈两个栈共同维护。\r\n遍历字符串： 用一个num和out维护当前数字num和字符串out\r\n1.若遇到数字，则num*10 + int(x-'0')，获取要重复的次数\r\n2.若遇到【则把之前的数字和字符串分别压入栈中\r\n3.若遇到】则把数字栈和字符串栈的数据弹出来，首先用数字栈弹出的数组重复增加当前字符串out,\r\n再用字符串栈弹出的原本的字符串拼接重复生成的字符串，作为最新的字符串\r\n4.若遇到字符，则直接拼接即可\r\n```Go\r\nfunc decodeString(s string) string {\r\n    numstack := []int{}\r\n    strstack := []string{}\r\n    num := 0\r\n    out := \"\"\r\n    for _,x := range s{\r\n        if x >= '0' && x <= '9'{\r\n            num = num*10 + int(x-'0')\r\n        }else if x == '['{\r\n            numstack = append(numstack,num)\r\n            strstack = append(strstack,out)\r\n            num = 0\r\n            out = \"\"\r\n        }else if x == ']'{\r\n            count := numstack[len(numstack)-1]\r\n            numstack = numstack[:len(numstack)-1]\r\n            out = strings.Repeat(out,count)\r\n            str := strstack[len(strstack)-1]\r\n            strstack = strstack[:len(strstack)-1]\r\n            out = str + out\r\n        }else{\r\n            out += string(x)\r\n        }\r\n    }\r\n    return out\r\n}\r\n```\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994932404","body":"思路：\r\n用两个栈实现一个队列。一个作为队列头栈，一个作为队列尾栈。\r\n插入则直接插入到队列尾栈。弹出和查看队列头，关键要先判断队列头栈是否为空，不空为可直接弹出值或取出队列头。\r\n如果队列头栈为空，则循环将队列尾栈压入队列头栈。\r\n判断是否为空即判断两个栈是否为空即可\r\n```Go\r\ntype MyQueue struct {\r\n    stackfront []int\r\n    stacktail []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{[]int{},[]int{}}\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.stacktail = append(this.stacktail,x)\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.stackfront) > 0{\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n        this.stackfront = this.stackfront[:len(this.stackfront)-1]\r\n        return out\r\n    }\r\n    for len(this.stacktail) > 0{\r\n        this.stackfront = append(this.stackfront,this.stacktail[len(this.stacktail)-1])\r\n        this.stacktail = this.stacktail[:len(this.stacktail)-1]\r\n    }\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n        this.stackfront = this.stackfront[:len(this.stackfront)-1]\r\n    return out\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.stackfront) > 0{\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n        return out\r\n    }\r\n    for len(this.stacktail) > 0{\r\n        this.stackfront = append(this.stackfront,this.stacktail[len(this.stacktail)-1])\r\n        this.stacktail = this.stacktail[:len(this.stacktail)-1]\r\n    }\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n    return out\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n    return len(this.stackfront) == 0 && len(this.stacktail)==0\r\n}\r\n\r\n```\r\n时间复杂度 O（n）【内部操作】 外部操作是O（1）\r\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-995952833","body":"思路：\r\n块的关键为升序，因此如果出现降序，则说明要往前遍历寻找比当前值的更小值凑成一个块。\r\n因此本题适合用栈来实现。【栈是单调栈，栈顶-》栈底依次减少】\r\n遍历数组，关键判断栈。\r\n若当前值大于栈顶值，则直接入栈。\r\n若当前值小于栈顶值，则先把栈顶值存在临时变量temp，然后for循环依次遍历栈顶，\r\n如果栈顶元素大于x则继续遍历，否则就退出for循环。将temp临时变量入栈\r\n【用temp保存此前的最大值，是为了保证后来进来的变量如果小的话，则属于前一个块】\r\n最后输出栈的长度，可以得到所分的块数。\r\n```Go\r\nfunc maxChunksToSorted(arr []int) int {\r\n    stack := []int{}\r\n    for _,x := range arr{\r\n        if len(stack)>0 && x < stack[len(stack)-1]{\r\n            temp := stack[len(stack)-1]\r\n            for len(stack)>0 && x < stack[len(stack)-1]{\r\n            stack = stack[:len(stack)-1]\r\n            }\r\n            stack = append(stack,temp)\r\n        }else{\r\n            stack = append(stack,x)\r\n        }\r\n    }\r\n    return len(stack)\r\n}\r\n```\r\n时间复杂度：O（N）\r\n空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996834375","body":"思路：\r\n本题是由倒数第N个链表和环形链表相结合。\r\n实现链表循环的关键是，将尾节点与头节点接起来。\r\n由于题目需要求倒数第k个节点，因此需要先遍历一遍链表得到sum【设head = 1，条件为head.Next != nil】\r\n因此由倒数第k个节点，可以得到整数第sum个节点 sun -= k%sum\r\n最后，找到这个点，先将head.Next作为输出保留，其次将head.Next =nil 断开链表\r\n【注意边界条件的判断，如k=0和输入链表为nil】\r\n```Go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if head == nil||k==0{\r\n        return head\r\n    }\r\n    pre := head\r\n    sum := 1\r\n    for pre.Next != nil{\r\n        pre = pre.Next\r\n        sum++\r\n    }\r\n    sum -= k %sum\r\n    pre.Next = head\r\n    for i:=0;i<sum;i++{\r\n        pre = pre.Next\r\n    }\r\n    out := pre.Next\r\n    pre.Next = nil\r\n    return out\r\n}\r\n```\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997223710","body":"思路：\r\n穿针引线\r\n由于该题只涉及到两个节点之间的交换。因此可以利用pre.Next != nil&&pre.Next.Next != nil作为条件判断\r\n即两个节点node1，node2分别表示pre的下一个，和pre的下下一个。\r\n然后开始串，node1.Next = node.2.Next 保证顺序正确，pre.Next = node2 \r\nnode2.Next = node1 形成一个闭环\r\nPS:为了保证可以正常从表头获取整个链表，前面设置一个虚拟节点。\r\n```Go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil{\r\n        return nil\r\n    }\r\n    dummy := &ListNode{Next:head}\r\n    pre := dummy\r\n    for pre.Next != nil && pre.Next.Next != nil{\r\n        node1 := pre.Next\r\n        node2 := pre.Next.Next\r\n        node1.Next = node2.Next\r\n        pre.Next = node2\r\n        node2.Next = node1\r\n        pre = node1\r\n    }\r\n    return dummy.Next\r\n}\r\n```\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997416336","body":"思路：\r\n高度平衡二叉树 =》意味着左右子树的深度都相同 =》分治算法\r\n参考链表归并排序的实现思路。并且用递归实现\r\n关注两个关键节点：1.如果是nil，则直接返回nil 2. 如果链表只有一个节点，则直接作为值返回叶节点。\r\n其次就是：\r\n快慢指针找中点，同时用一个前驱节点pre保存前一个结点待访问。\r\n找到中点后注意两个关键环节，\r\n第一个关键环节前驱结点pre.Next = nil 断开\r\n第二个关键环节为slow.Next作为输入参数。\r\n然后就是常规的把slow【中间结点】作为根结点的值，\r\n左叶子节点的值取决于 前半部分的链表递归值\r\n右叶子节点的值取决于 后半部分的链表递归值\r\n答案完毕。\r\n```Go\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    if head == nil{\r\n        return nil\r\n    }\r\n    pre := &ListNode{Next:head}\r\n    if head.Next == nil{\r\n        return &TreeNode{Val:head.Val}\r\n    }\r\n    slow := head\r\n    fast := head\r\n    for fast!= nil && fast.Next!= nil{\r\n        pre = slow\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    pre.Next = nil\r\n    root := &TreeNode{Val:slow.Val}\r\n    root.Left = sortedListToBST(head)\r\n    root.Right = sortedListToBST(slow.Next)\r\n    return root\r\n}\r\n```\r\n时间复杂度：O（n*logn）分治\r\n空间复杂度：O（logn）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998057336","body":"思路：\r\n先遍历链表A，B得到各自的长度num1，num2.\r\ngap = abs（num1-num2） 【abs为绝对值】\r\n如果num1大，则headA先移动gap步\r\n如果num2大，则headB先移动gap步\r\n然后两个链表同时移动，如果两个链表相等，则返回链表\r\n否则当一个链表走到尽头，for循环终止。返回nil\r\n```Go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    if headA == nil || headB == nil{\r\n        return nil\r\n    }\r\n    num1,num2:=0,0\r\n    cur1,cur2 := headA,headB\r\n    for cur1 != nil{\r\n        cur1 = cur1.Next\r\n        num1++\r\n    }\r\n    for cur2 != nil{\r\n        cur2 = cur2.Next\r\n        num2++\r\n    }\r\n    gap := abs(num1-num2)\r\n    if num1 > num2{\r\n        for gap > 0{\r\n            headA = headA.Next\r\n            gap--\r\n        }\r\n    }else{\r\n        for gap > 0{\r\n            headB = headB.Next\r\n            gap--\r\n        }\r\n    }\r\n    for headA != nil&& headB != nil{\r\n        if headA == headB{\r\n            return headB\r\n        }\r\n        headA = headA.Next\r\n        headB = headB.Next\r\n    }\r\n    return nil\r\n}\r\nfunc abs(x int) int{\r\n    if x < 0{\r\n        return -x\r\n    }\r\n        return x\r\n}\r\n```\r\n时间复杂度O（n） n为两个链表长度的最大值\r\n空间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998902465","body":"思路：\r\n快慢指针\r\n先处理边界条件，若为空，返回nil\r\nfor fast.Next != nil && fast.Next.Next != nil\r\n慢指针走一步，快指针走两步。当快慢指针相遇，快指针从头开始移动。\r\n当快慢指针相等时返回对应指针。\r\n如果没有环，for循环结束，直接返回nil\r\n```Go\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n    if head == nil{\r\n        return nil\r\n    }\r\n    slow := head\r\n    fast := head\r\n    for fast != nil && fast.Next != nil{\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n        if slow == fast{\r\n            fast = head\r\n            for slow != fast{\r\n                slow = slow.Next\r\n                fast = fast.Next\r\n            }\r\n            return slow\r\n        }\r\n    }\r\n    return nil\r\n}\r\n```\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999707486","body":"思路：\r\n太久不会写忘记了=-=重新复习了一下。\r\n关键LRU算法是 哈希表+双向链表组成\r\n双向链表需要pre、next，同时记录key，value值 便于查询\r\nLRU结构体需要的是 哈希表[key]*DLinkNode, capcity容量，size大小，头和尾节点\r\n同时，我们自己实现四个函数来简化设计。\r\n第一个函数添加到头，因为LRU用完一个节点要添加到头部。\r\n这里的做法是把node直接插入head和head.Next中间，同时令head.Next.prev = node ,head.next = node [注意顺序]\r\n第二个函数是移除节点：双向链表的移除很简单：\r\n直接node.prev.next = node.next    ；node.next.prev = node.prev\r\n第三个函数是移动到头节点，就是前两个函数的拼接\r\n第四个函数是删除尾节点，为了保证当size＞capcity时移除最久使用的节点。\r\n直接从尾节点读前缀节点，调用移除节点，返回该节点。\r\n\r\n对于put的话，需要检测当前当前的key是否存在，若存在则直接修改value值，并调用移动到链表头函数，\r\n如果key不存在，则添加到节点到头部，size++，并判断size是否大于capcity，若大于则移除尾节点【记得删除哈希表的key值】\r\nGO语言的删除是delete(this.cache,removed.key)\r\n对于get的话，直接判断节点是否存在，若存在则读cache并返回值，否则返回1\r\n```Go\r\ntype DLinkNode struct{\r\n    key,value int\r\n    prev,next *DLinkNode\r\n}\r\n\r\ntype LRUCache struct {\r\n    size int\r\n    capacity int\r\n    cache map[int]*DLinkNode\r\n    head,tail *DLinkNode\r\n}\r\nfunc InitDLinkNode (key,value int) *DLinkNode{\r\n    return &DLinkNode{\r\n        key:key,\r\n        value:value,\r\n    }\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    l := LRUCache{\r\n        cache:map[int]*DLinkNode{},\r\n        head:InitDLinkNode(0,0),\r\n        tail:InitDLinkNode(0,0),\r\n        capacity:capacity,\r\n    }\r\n    l.head.next = l.tail\r\n    l.tail.prev = l.head\r\n    return l\r\n}\r\n\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    if _,ok := this.cache[key];ok{\r\n        node := this.cache[key]\r\n        this.moveToHead(node)\r\n        return node.value\r\n    }else{\r\n        return -1\r\n    }\r\n}\r\n\r\n\r\nfunc (this *LRUCache) Put(key int, value int)  {\r\n    if _,ok := this.cache[key];!ok{\r\n        node := InitDLinkNode(key,value)\r\n        this.cache[key] =node\r\n        this.addToHead(node)\r\n        this.size++\r\n        if this.size > this.capacity{\r\n            removed := this.removeNodeTail()\r\n            delete(this.cache,removed.key)\r\n            this.size--\r\n        }\r\n    }else{\r\n        node := this.cache[key]\r\n        node.value = value\r\n        this.moveToHead(node)\r\n    }\r\n}\r\nfunc (this *LRUCache) addToHead(node *DLinkNode){\r\n    node.prev = this.head\r\n    node.next = this.head.next\r\n    this.head.next.prev = node\r\n    this.head.next = node\r\n}\r\nfunc(this *LRUCache) removeNode(node *DLinkNode){\r\n    node.prev.next = node.next\r\n    node.next.prev = node.prev\r\n}\r\nfunc(this *LRUCache) moveToHead(node *DLinkNode){\r\n    this.removeNode(node)\r\n    this.addToHead(node)\r\n}\r\nfunc(this *LRUCache) removeNodeTail() *DLinkNode{\r\n    node := this.tail.prev\r\n    this.removeNode(node)\r\n    return node\r\n}\r\n\r\n```\r\n时间复杂度O（1）\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000398345","body":"思路：\r\nDFS深度搜索+后续遍历\r\n\r\n```Go\r\nfunc maxDepth(root *TreeNode) int {\r\n    if root == nil{\r\n        return 0\r\n    }\r\n    left := maxDepth(root.Left)\r\n    Right := maxDepth(root.Right)\r\n    if left > Right{\r\n        return left+1\r\n    }else{\r\n        return Right+1\r\n    }\r\n}\r\n```\r\n时间复杂度O（n） 遍历了所有树的节点\r\n空间复杂度O（h）树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000886338","body":"思路：\r\n后续遍历DFS\r\n判断p，q是否相等需要满足：\r\n1.p,q 同时为nil\r\n2.不存在p，q其中一个为nil的情况\r\n3.不存在p.Val != q.Val\r\n4.p和q的子树都满足这样的条件\r\n\r\n类似的题目：\r\n1.判断p，q是否对称树  =》 区别在于遍历的时候是p.Left,q.Right  && p.Right,p.Left  \r\n```Go\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n    if p == nil && q == nil{\r\n        return true\r\n    }\r\n    if p == nil || q == nil{\r\n        return false\r\n    }\r\n    if p.Val != q.Val{\r\n        return false\r\n    }\r\n    return isSameTree(p.Left,q.Left)&&isSameTree(p.Right,q.Right)\r\n}\r\n```\r\n时间复杂度O（n）\r\n空间复杂度O（h）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001039307","body":"思路：\r\n前序遍历+扩展参数 【扩展一个临界值】\r\ndfs遍历：输入为root 和 num【根节点到该节点的数值总和】\r\n1.判断节点是否为nil 2. num += root.Val  3.若是叶子节点，则直接加到输出out 4.dfs左右叶子节点\r\n\r\n```Go\r\nfunc sumNumbers(root *TreeNode) int {\r\n    out := 0\r\n    var dfs func(root *TreeNode,num int)\r\n    dfs = func(root *TreeNode,num int){\r\n        if root == nil{\r\n            return\r\n        }\r\n        num += root.Val\r\n        if root.Left == nil && root.Right == nil{\r\n            out += num\r\n            return\r\n        }\r\n        dfs(root.Left,num*10)\r\n        dfs(root.Right,num*10)\r\n    }\r\n    dfs(root,0)\r\n    return out\r\n}\r\n```\r\n时间复杂度 O（n）\r\n空间复杂度O（h）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993100893","body":"## Note\n\n1. Push O(1), Pop O(1), Increment O(n), n is min(this.size,k);\n2. Space Complexity: O(n)\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.size=0;\n    this.stack=[];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size!==this.maxSize){\n        this.stack.push(x);\n        this.size++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size===0) return -1;\n    this.size--;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=Math.min(k-1,this.size-1);i>=0;i--){\n        this.stack[i]+=val;\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n\n","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999211338","body":"```\r\n/*\r\n * @lc app=leetcode id=142 lang=javascript\r\n *\r\n * [142] Linked List Cycle II\r\n * 环形链表 2 \r\n * 解法一： set（）\r\n * 1. 在空间复杂度为n的情况下，把每一个node都加入到set 里面，遇到的第一个相同的node就是环的入口\r\n * 2. let data = new Set(), data.has(head) ...\r\n * 解法二： two pointers\r\n * 1. 用两种方式来表示fast和slow相遇时，fast走过的路径 得出 L = D\r\n * 2. 让fast从head开始走L，slow继续走D。再次相遇的时候就是环的入口。\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    if(!head) return null;\r\n    let fast=head;\r\n    let slow=head;\r\n\r\n    //when jumping out of this loop, fast and slow are at the same node\r\n    while(fast && fast.next){\r\n        fast=fast.next.next\r\n        slow=slow.next\r\n        //Equal means there is a cycle. \r\n        if(fast==slow){\r\n            let temp=head;\r\n            while(temp!=slow){\r\n                temp=temp.next;\r\n                slow=slow.next;\r\n            }\r\n            return slow;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n// @lc code=end\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994112478","body":"```const decodeString = function (str) {\r\n  let stack = [];\r\n  let currStr = \"\";\r\n  let currNum = 0;\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (str[i] === \"[\") {\r\n      stack.push(currStr);\r\n      stack.push(currNum);\r\n      currStr = \"\";\r\n      currNum = 0;\r\n    } else if (str[i] === \"]\") {\r\n      let prevNum = stack.pop();\r\n      let prevStr = stack.pop();\r\n      currStr = prevStr + currStr.repeat(prevNum);\r\n    } else if (str[i] >= \"0\" && str[i] <= \"9\") {\r\n      currNum = currNum * 10 + Number(str[i]);\r\n    } else {\r\n      currStr += str[i];\r\n    }\r\n  }\r\n  return currStr;\r\n};```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997304442","body":"```javascript\r\nconst swapPairs = function(head) {\r\n    if(!head || !head.next) return head;\r\n    const v1 = head, v2 = head.next, v3 = v2.next;\r\n    v2.next = v1;\r\n    v1.next = swapPairs(v3);\r\n    return v2;\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998301345","body":"```javascript\r\nconst getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) return null;\r\n    var curA = headA;\r\n    var curB = headB;\r\n    while (curA != curB) {\r\n        curA = curA == null ? headB : curA.next;\r\n        curB = curB == null ? headA : curB.next;\r\n    }\r\n    return curA;\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001081601","body":"```javascript\r\nconst sumNumbers = function(root, current = 0) {\r\n    if (root === null) return 0;\r\n    let value = current * 10 + root.val;\r\n    if (root.left === null && root.right === null) return value;\r\n    return sumNumbers(root.left, value) + sumNumbers(root.right, value);\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992041436","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n## S1: 中心扩展法\n\n这是最符合直觉的思路，对每个字符分别进行如下处理：\n\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\n- 只在一个方向找到的话，直接计算字符距离。\n- 两个方向都找到的话，取两个距离的最小值。\n\n[https://camo.githubusercontent.com/efaa1cd00bcef4ff7e2cf0c5cd7a37a60d403cf9f82439dffb63a1a48dcf3e06/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f3832315f302e706e67](https://camo.githubusercontent.com/efaa1cd00bcef4ff7e2cf0c5cd7a37a60d403cf9f82439dffb63a1a48dcf3e06/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f3832315f302e706e67)\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        vector<int> res(S.length());\n\n        for (int i = 0; i < S.length(); i++) {\n            if (S[i] == C) continue;\n\n            int left = i;\n            int right = i;\n            int dist = 0;\n\n            while (left >= 0 || right <= S.length() - 1) {\n                if (S[left] == C) {\n                    dist = i - left;\n                    break;\n                }\n                if (S[right] == C) {\n                    dist = right - i;\n                    break;\n                }\n\n                if (left > 0) left--;\n                if (right < S.length() - 1) right++;\n            }\n\n            res[i] = dist;\n        }\n\n        return res;\n    }\n}\n```\n\n```jsx\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 结果数组 res\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    // 如果当前是目标字符，就什么都不用做\n    if (S[i] === C) continue;\n\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n\n- ****Time:**** $O(N^2)$，N 为 S 的长度，两层循环。\n- ***Space:** $O(1)$*\n\n## S2: 空间换时间\n\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\n\n- 因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\n- 然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n```\n\n```jsx\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 记录 C 字符在 S 字符串中出现的所有下标\n  var cIndices = [];\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) cIndices.push(i);\n  }\n\n  // 结果数组 res\n  var res = Array(S.length).fill(Infinity);\n\n  for (let i = 0; i < S.length; i++) {\n    // 目标字符，距离是 0\n    if (S[i] === C) {\n      res[i] = 0;\n      continue;\n    }\n\n    // 非目标字符，到下标数组中找最近的下标\n    for (const cIndex of cIndices) {\n      const dist = Math.abs(cIndex - i);\n\n      // 小小剪枝一下\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\n      if (dist >= res[i]) break;\n\n      res[i] = dist;\n    }\n  }\n  return res;\n};\n```\n\n- ****Time:**** $O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，*K <= N*。\n- ***Space:** $O(K)$，*K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\n\n## S3: 贪心\n\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\n\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\n3. 然后同时遍历这两个数组，计算距离最小值。\n\n**优化 1**\n\n再多想一步，其实第二个数组并不需要。\n\n因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\n\n1. 字符左侧没有出现过 `C` 字符\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\n\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\n\n**优化 2**\n\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> dist(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (dist[i] == n\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\n                    dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n```\n\n```jsx\n/**\n * 优化1：覆盖最近距离\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  // 第一次遍历：从左往右\n  // 找到出现在左侧的 C 字符的最后下标\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = i;\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\n  }\n\n  // 第二次遍历：从右往左\n  // 找出现在右侧的 C 字符的最后下标\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\n  for (let i = S.length - 1; i >= 0; i--) {\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\n  }\n\n  // 计算距离\n  for (let i = 0; i < res.length; i++) {\n    res[i] = Math.abs(res[i] - i);\n  }\n  return res;\n};\n\n/**\n * 优化2: 直接计算距离\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = 0;\n    // 记录距离：res[i - 1] + 1\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\n  }\n\n  for (let i = S.length - 1; i >= 0; i--) {\n    // 更新距离：res[i + 1] + 1\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\n  }\n\n  return res;\n};\n```\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ***Space:** $O(1)$*\n\n## S4: 窗口\n\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/07bbb9ef-1f56-41b2-9272-d313af7af06a/Untitled.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n\n        int l = S[0] == C ? 0 : n;\n        int r = S.find(C, 1);\n\n        vector<int> dist(n);\n\n        for (int i = 0; i < n; i++) {\n            dist[i] = min(abs(i - l), abs(r - i));\n            if (i == r) {\n                l = r;\n                r = S.find(C, r + 1);\n            }\n        }\n\n        return dist;\n    }\n};\n```\n\n```jsx\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\n  let l = S[0] === C ? 0 : Infinity,\n    // 窗口右边界\n    r = S.indexOf(C, 1);\n\n  const res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    // 计算字符到当前窗口左右边界的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 遍历完了当前窗口的字符后，将整个窗口右移\n    if (i === r) {\n      l = r;\n      r = S.indexOf(C, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 for _ in range(n)]\n\n        l = 0 if s[0] == c else n\n        r = s.find(c, 1)\n\n        for i in range(n):\n            res[i] = min(abs(i - l), abs(r - i))\n            if i == r:\n                l = r\n                r = s.find(c, l + 1)\n        return res\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993310567","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n## S1: 模拟\n\n直观思路是在增量操作时进行模拟，每次进行增量操作时都遍历指定的 k 个元素，但这样时间复杂度是 $O(N)$。\n\n时间优化思路是，既然我们只有在出栈时才考虑元素的值，何不将增量操作延后到出栈时，如此便需要将所有增量操作都先存起来。\n\n- 借助另一个容器来记录增量操作。\n- 在出栈时，将栈顶元素加上增量弹出，并更新增量记录。\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize): max_size_(maxSize) {\n        stack_.resize(maxSize);\n        add_.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top_ < max_size_ - 1) {\n            top_++;\n            stack_[top_] = x;\n        }\n    }\n    \n    int pop() {\n        if (top_ == -1) return -1;\n        int res = stack_[top_] + add_[top_];\n        if (top_ > 0) add_[top_ - 1] += add_[top_];\n        add_[top_] = 0; \n        top_--;\n        return res;\n\n    }\n    \n    void increment(int k, int val) {\n        int idx = min(k - 1, top_);\n        if (idx >= 0) add_[idx] += val;\n    }\nprivate:\n    vector<int> stack_;\n    vector<int> add_;\n    int top_ = -1;\n    int max_size_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n- ****Time:**** $O(1)$，所有操作的时间复杂度都是 $O(1)$。\n- ***Space:** $O(N)$*，使用了一个长度为 maxSize 的辅助数组来记录增量操作。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994202891","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n## S1: 递归\r\n\r\n![https://camo.githubusercontent.com/cfacf3e8bb0851bd0b122e218ad63e5ab2abf6d23d439dadf638ecb72298de74/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f747265652e706e67](https://camo.githubusercontent.com/cfacf3e8bb0851bd0b122e218ad63e5ab2abf6d23d439dadf638ecb72298de74/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f747265652e706e67)\r\n\r\n`n[string]` 表示解析 `[]` 模板里面的内容，然后重复 `n` 次，即得到 `n` 个 `string` 拼接起来的字符串。\r\n\r\n根据题意，`[]` 里面还可以再嵌套 `[]` ，例如 `n[m[string]]`。这种情况下，我们得先解析最内层的模板，重复 `m` 次，然后将 `m * string` 的结果作为外层模板的解析内容，再重复 `n` 次。\r\n\r\n如果嵌套的层数更多，我们也是得先找到最内层的 `[]`，就像洋葱一样，一层层剥开，然后再从内到外一层层解析和拼接。这种层层嵌套的描述很容易就让人想到了递归。\r\n\r\n按照常规，写递归时不要过多考虑前后的递归函数，想好当前递归函数需要处理些什么就好了。\r\n\r\n- 在每个递归函数里我们处理一段没有嵌套模版的字符串。\r\n- 遇到英文字母时，进行简单的拼接。\r\n- 遇到数字时，累加数字。\r\n- 遇到 `[` 时，说明接下来是一个嵌套模版，开始递归处理。递归处理嵌套模版结束后，我们回到了当前递归层级，需要的信息有两个：\r\n    1. 嵌套模版的解码字符串\r\n    2. 嵌套模版的结束坐标\r\n- 获得嵌套模版的解码字符串后，重复 n 次拼接到当前层级的解码字符串中，接着从嵌套模版的结束坐标开始继续处理当前层级的字符串。\r\n- 遇到 `]` 时，说明处理当前层级模版的递归可以结束了，返回上一种情况需要的信息，解码字符串以及模版结束的坐标。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        return decodeString(s, 0).first;\r\n    }\r\n\r\n    pair<string, int> decodeString(string s, int cur) {\r\n        int k = 0;\r\n        string decoded;\r\n        while (cur < s.size()) {\r\n            // 收集数字\r\n            if (isdigit(s[cur])) {\r\n                k = k * 10 + s[cur] - '0';\r\n                cur++;\r\n            }\r\n            // 收集字母\r\n            else if (isalpha(s[cur])) {\r\n                decoded.push_back(s[cur]);\r\n                cur++;\r\n            }\r\n            // 开始解析下一层嵌套\r\n            else if (s[cur] == '[') {\r\n                pair<string, int> res = decodeString(s, cur + 1);\r\n                // 解析完嵌套模式后\r\n                while (k-- > 0) {\r\n                    decoded.append(res.first);\r\n                }\r\n                k = 0;\r\n                cur = res.second;\r\n            }\r\n            // 结束当前递归\r\n            else if (s[cur] == ']') {\r\n                return {decoded, cur + 1};\r\n            }\r\n        }\r\n        return {decoded, -1};\r\n    }\r\n};\r\n```\r\n\r\n```jsx\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s, cur = 0) {\r\n    let k = 0;\r\n    let decoded = '';\r\n    while (cur < s.length) {\r\n        if (s[cur] === '[') {\r\n            const [str, pos] = decodeString(s, cur + 1);\r\n            decoded += str.repeat(k);\r\n            k = 0;\r\n            cur = pos;\r\n        } else if (s[cur] === ']') {\r\n            return [decoded, cur + 1];\r\n        } else if (/[0-9]/.test(s[cur])) {\r\n            k = k * 10 + parseInt(s[cur++]);\r\n        } else {\r\n            decoded += s[cur++];\r\n        }\r\n    }\r\n    return decoded;\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N)$，N 是解码后字符串的长度。\r\n- ***Space:** $O(N)$*\r\n\r\n## S2: 循环+栈\r\n\r\n可以用递归解决的问题，也可以用循环+栈来解决。\r\n\r\n这里我用了正则 `/[a-zA-Z]+|[0-9]+|\\[|\\]/` 和 `exec()` 方法来遍历字符串并把它们拆分成 `token`，比如，`lz3[ab2[c]]` 会被拆分成 `lz`, `3`, `[`, `ab`, `2`, `[`, `c`, `]`, `]`。\r\n\r\n1. 遇到字母块 (`lz`)、数字时，入栈；\r\n2. 遇到 `[` 时，入栈，用来标识当前进入一个模板解析了；\r\n3. 遇到 `]` 时，说明当前模板遍历完了，我们可以开始解析了。\r\n    1. 开始出栈，把出栈的字母块都拼接起来。\r\n    2. 等出栈到 `[` 时，说明当前模板解析完成了。\r\n    3. 继续出栈一个元素，这个元素就是当前模板要重复的次数。\r\n    4. 把 `字母块 * 次数` 重新入栈，这是因为模板是可嵌套的，当前模板外面可能还有一层模板，所以我们要把当前层级的解析结果重新入栈，接着解析外层的模板。\r\n\r\n![https://camo.githubusercontent.com/cf2e9f7f12b4e571df77f88ec55ce574760d221c5b4551e0a179d361aad35f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f737461636b2e706e67](https://camo.githubusercontent.com/cf2e9f7f12b4e571df77f88ec55ce574760d221c5b4551e0a179d361aad35f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f737461636b2e706e67)\r\n\r\n```jsx\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n    const stack = [];\r\n    const peek = () => stack[stack.length - 1]; // p.s. 这是一个不正经的栈\r\n\r\n    while (reg.lastIndex < s.length) {\r\n        let token = reg.exec(s)[0];\r\n        if (token !== ']') {\r\n            // 数字，字母，左括号通通入栈\r\n            stack.push(token);\r\n        } else {\r\n            // 遇到右括号就开始出栈\r\n            let str = '';\r\n            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n            while (peek() !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            // 丢掉左括号\r\n            stack.pop();\r\n            // 左括号前面的一定是模式重复的次数\r\n            const num = +stack.pop();\r\n            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n            stack.push(str.repeat(num));\r\n        }\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N)$，N 是解码后字符串的长度。\r\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995352740","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n## S1: 优化模拟\n\n维护两个栈，一个用来写 (push)，一个用来读 (pop)。\n\n往写栈中 push，从读栈中 pop。当读栈为空时，将写栈中的数据全部倒入读栈中。\n\n```cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        write_stack_.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (read_stack_.empty()) pour_();\n        int value = read_stack_.top();\n        read_stack_.pop();\n        return value;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (read_stack_.empty()) pour_();\n        return read_stack_.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return read_stack_.empty() && write_stack_.empty();\n    }\nprivate:\n    stack<int> write_stack_;\n    stack<int> read_stack_;\n\n    void pour_() {\n        while (!write_stack_.empty()) {\n            read_stack_.push(write_stack_.top());\n            write_stack_.pop();\n        }\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n- ****Time:**** `push` 是 $O(1)$，`pop` 均摊下来也是 $O(1)$，连续 N 次的 push 才会碰到一次 $O(N)$ 的 pop。\n- ***Space:** $O(N)$*","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998409476","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n## S1: 暴力法\r\n\r\n对链表 A 的每个节点，都去链表 B 中遍历一遍找看看有没有相同的节点。\r\n\r\n```jsx\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA;\r\n    while (pA) {\r\n        let pB = headB;\r\n\r\n        while (pB) {\r\n            if (pA === pB) return pA;\r\n            pB = pB.next;\r\n        }\r\n\r\n        pA = pA.next;\r\n    }\r\n};\r\n```\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == NULL || headB == NULL) return NULL;\r\n\r\n        ListNode *pA = headA;\r\n\r\n        while (pA != NULL) {\r\n            ListNode *pB = headB;\r\n            while (pB != NULL) {\r\n                if (pA == pB) {\r\n                    return pA;\r\n                }\r\n                pB = pB->next;\r\n            }\r\n            pA = pA->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(m*n)$，m 和 n 分别是两个链表的长度。\r\n- ***Space:** $O(1)$*\r\n\r\n## S2: 哈希表\r\n\r\n- 先遍历遍历链表 A，将所有节点都存在一个哈希表中\r\n- 再遍历链表 B，找到在哈希表中出现过的节点即为两个链表的交点。\r\n\r\n```jsx\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    const hashmap = new Map();\r\n\r\n    let pA = headA;\r\n    while (pA) {\r\n        hashmap.set(pA, 1);\r\n        pA = pA.next;\r\n    }\r\n\r\n    let pB = headB;\r\n    while (pB) {\r\n        if (hashmap.has(pB)) return pB;\r\n        pB = pB.next;\r\n    }\r\n};\r\n```\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode*> visited;\r\n        ListNode* p = headA;\r\n        while (p != NULL) {\r\n            visited.insert(p);\r\n            p = p->next;\r\n        }\r\n        p = headB;\r\n        while (p != NULL) {\r\n            if (visited.find(p) != visited.end()) return *visited.find(p);\r\n            p = p->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(m+n)$，m 和 n 分别是两个链表的长度。\r\n- ***Space:** $O(m)$*\r\n\r\n## S3: 双指针\r\n\r\n![https://camo.githubusercontent.com/c1fabf4badffd96c0857bdc66bf8ccdf9214991b45c0e1b08c54feda9d91a77e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374732e706e67](https://camo.githubusercontent.com/c1fabf4badffd96c0857bdc66bf8ccdf9214991b45c0e1b08c54feda9d91a77e/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374732e706e67)\r\n\r\n**如果两个链表有交点的话：**\r\n\r\n![https://camo.githubusercontent.com/3580f2f8d58e14290c175c9a117219b37d85e71c1d2b058a65b9982b10555f40/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374735f312e706e67](https://camo.githubusercontent.com/3580f2f8d58e14290c175c9a117219b37d85e71c1d2b058a65b9982b10555f40/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f696e74657273656374696f6e5f6f665f6c696e6b65645f6c697374735f312e706e67)\r\n\r\n**如果链表没有交点的话：**\r\n\r\n1. 两个链表长度一样时，第一次遍历结束后 pA 和 pB 都是 null，结束遍历。\r\n2. 两个链表长度不一样时，两次遍历结束后 pA 和 pB 都是 null，结束遍历。\r\n\r\n```jsx\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA,\r\n        pB = headB;\r\n    while (pA !== pB) {\r\n        pA = pA === null ? headB : pA.next;\r\n        pB = pB === null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n};\r\n```\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == NULL || headB == NULL) return NULL;\r\n        ListNode *pA = headA, *pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == NULL ? headB : pA->next;\r\n            pB = pB == NULL ? headA : pB->next;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(m+n)$，m 和 n 分别是两个链表的长度。\r\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999228303","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n## S1: 哈希表\r\n\r\n1. 从头开始遍历链表并给每个节点增加一个“已遍历”的标记。\r\n2. 如果在遍历过程中遇到了一个“已遍历”的节点，说明这是环的入口。\r\n3. 但题目不允许修改给定的链表节点，因此可以借用一个额外的哈希表来记录。\r\n4. 注意题目中没有提到节点值是否唯一，仅用节点值作为哈希表的 key 是不够的，需要用节点引用。\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        set<ListNode*> seen;\r\n        ListNode *cur = head;\r\n        while (cur != NULL) {\r\n            if (seen.find(cur) != seen.end()) return cur;\r\n            seen.insert(cur);\r\n            cur = cur->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n```jsx\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  const map = new Map();\r\n\r\n  while (head) {\r\n    if (map.has(head)) return head;\r\n    map.set(head, true);\r\n    head = head.next;\r\n  }\r\n\r\n  return null;\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N)$，N 为链表长度。\r\n- ***Space:** $O(N)$*，哈希表的空间。\r\n\r\n## S2: 双指针\r\n\r\n1. 先使用快慢指针来确定链表是否有环。\r\n2. 如果链表有环，那快慢指针相遇的点一定是在环中：\r\n    1. 接着把指针 A 移到链表头部，指针 B 留在环内；\r\n    2. 指针 A 走一步，指针 B 在环内走一圈；\r\n    3. 如果指针 A 和指针 B 相遇了，说明这个节点就是环的入口。\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        slow = fast = head\r\n\r\n        while slow != None and fast != None and fast.next != None:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                return self.findConnection(head, slow)\r\n        return None\r\n\r\n    def findConnection(self, head, loopNode):\r\n        p1 = head\r\n        while True:\r\n            p2 = loopNode\r\n            while p2.next != loopNode and p2.next != p1:\r\n                p2 = p2.next\r\n            if p2.next == p1:\r\n                return p1\r\n            p1 = p1.next\r\n```\r\n\r\n```jsx\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  let slow = head,\r\n    fast = head;\r\n  // 快慢指针确定有环\r\n  while (fast && fast.next) {\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n    // 确定有环，开始找环的第一个节点\r\n    if (slow === fast) return findConnection(head, fast);\r\n  }\r\n  return null;\r\n\r\n  // ******************************************\r\n\r\n  function findConnection(head, loopNode) {\r\n    // p1 走一步，p2 绕环一圈\r\n    let p1 = head;\r\n    while (true) {\r\n      let p2 = loopNode;\r\n      while (p2.next !== loopNode && p2.next !== p1) {\r\n        p2 = p2.next;\r\n      }\r\n      if (p2.next === p1) return p1;\r\n      p1 = p1.next;\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N*P)$，N 是环外链表的长度，P 是环的长度。\r\n- ***Space:** $O(1)$*\r\n\r\n## S3: 双指针+数学证明\r\n\r\n先用快慢指针确定链表是否有环，如果是环形链表，快慢指针会在环内的某个节点相遇。\r\n\r\n![https://camo.githubusercontent.com/7494e3463b4743509e3c205fb2cb03052ccb32e4f8794a76b31484a1550460de/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f302e706e67](https://camo.githubusercontent.com/7494e3463b4743509e3c205fb2cb03052ccb32e4f8794a76b31484a1550460de/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f302e706e67)\r\n\r\n我们分别来看一下两个指针相遇前分别走了多少路程。\r\n\r\n**快指针**\r\n\r\n假设走到相遇点之前，快指针在环内走了 n 圈，那快指针走过的总路程可以用`S(fast) = a + n(b + c) + b`来表示，其中 `(b + c)` 就是环的长度。\r\n\r\n![https://camo.githubusercontent.com/a2c1904130c03af533c210a9d368ee7a7e8c09daf1759a089f7ca4c2017d9c8c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f312e706e67](https://camo.githubusercontent.com/a2c1904130c03af533c210a9d368ee7a7e8c09daf1759a089f7ca4c2017d9c8c/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f312e706e67)\r\n\r\n**慢指针**\r\n\r\n因为慢指针在环内走不到 1 圈就会被快指针追赶上，可得慢指针走过的总路程是`S(slow) = a + b`\r\n\r\n而由于快指针的速度是慢指针速度的 2 倍，所以可得以下方程式：\r\n\r\n`2S(slow) = S(fast)` ⇒ `2(a + b) = a + n(b + c) + b`\r\n\r\n稍微整理一下我们就得到了：\r\n\r\n`a + b = n(b + c)` ⇒ `a = (n - 1)(b + c) + (b + c) - b = (n - 1)(b + c) + c`\r\n\r\n结论就是 a 的长度等于 c 的长度加上 n-1 圈环的长度。\r\n\r\n所以如果我们把其中一个指针移动到链表头部，然后让两个指针以相同的速度移动，它们会在环的入口相遇。\r\n\r\n![https://camo.githubusercontent.com/a1dcc9d04d50d017a58656b77e3a88f4a8ebfb19c4a253bdc59e80aec65d517a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f322e706e67](https://camo.githubusercontent.com/a1dcc9d04d50d017a58656b77e3a88f4a8ebfb19c4a253bdc59e80aec65d517a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f322e706e67)\r\n\r\n![https://camo.githubusercontent.com/945c0548b4d55314a55cf9dcd866b10fb910406bc4a407de1b7276faf9795664/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f332e706e67](https://camo.githubusercontent.com/945c0548b4d55314a55cf9dcd866b10fb910406bc4a407de1b7276faf9795664/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f66697273745f6e6f64655f6f665f6c6f6f705f696e5f6c696e6b65645f6c6973745f332e706e67)\r\n\r\nps. 如果 a 很长的话，fast 指针需要在环内走 n - 1 圈再加上 c 的距离，才能和 slow 指针相遇。 \r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n\r\n        while (fast && fast->next) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if (slow == fast) {\r\n                fast = head;\r\n                while (slow != fast) {\r\n                    slow = slow->next;\r\n                    fast = fast->next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n```jsx\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  let fast = head,\r\n    slow = head;\r\n\r\n  // 快慢指针确定有环\r\n  while (fast && fast.next) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n\r\n    // 确定有环，开始找环的第一个节点\r\n    if (fast === slow) {\r\n      slow = head;\r\n      while (slow !== fast) {\r\n        slow = slow.next;\r\n        fast = fast.next;\r\n      }\r\n      return slow;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N)$，N 为链表长度。\r\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999995284","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n## S1: 哈希表+双向链表\r\n\r\n首先简单介绍下什么是 LRU 缓存，熟悉的可以跳过。\r\n\r\n假设我们有一个玩具摊位，用于向顾客展示小玩具。玩具很多，摊位大小有限，不能一次性展示所有玩具，于是大部分玩具放在了仓库里。\r\n\r\n![https://camo.githubusercontent.com/0dca21fdf6a710c088d22577a29cd252a6bcb192a06198f26d1548c07f30d15d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f302e706e67](https://camo.githubusercontent.com/0dca21fdf6a710c088d22577a29cd252a6bcb192a06198f26d1548c07f30d15d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f302e706e67)\r\n\r\n如果有顾客来咨询某个玩具，我们就去仓库把该玩具拿出来，摆在摊位上。\r\n\r\n![https://camo.githubusercontent.com/7bb87a8a586af94e96c3169b23042ce8d02977288c6387f955eea4bcb6e93d24/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f312e706e67](https://camo.githubusercontent.com/7bb87a8a586af94e96c3169b23042ce8d02977288c6387f955eea4bcb6e93d24/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f312e706e67)\r\n\r\n因为摊位最上面的位置最显眼，所以我们总是把最新拿出来的玩具放在那。\r\n\r\n![https://camo.githubusercontent.com/e9a093a529a15771bb31594cc02597e85d0ddb21587a6345db467619849c06bb/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f322e706e67](https://camo.githubusercontent.com/e9a093a529a15771bb31594cc02597e85d0ddb21587a6345db467619849c06bb/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f322e706e67)\r\n\r\n不过由于摊位大小有限，很快就摆满了，这时如果又有顾客想看新玩具。\r\n\r\n![https://camo.githubusercontent.com/36ed9a1368faa6910cf61134d1c89f2fd196823f75028d75a412f013a512864d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f332e706e67](https://camo.githubusercontent.com/36ed9a1368faa6910cf61134d1c89f2fd196823f75028d75a412f013a512864d/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f332e706e67)\r\n\r\n我们只能把摊位最下面的玩具拿回仓库(因为最下面的位置相对没那么受欢迎)，然后其他玩具往下移，腾出最上面的位置来放新玩具。\r\n\r\n![https://camo.githubusercontent.com/f0a009f657005f750cb020fec0d0e74dea31cde0117bb4916260edbccd37a19f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f342e706e67](https://camo.githubusercontent.com/f0a009f657005f750cb020fec0d0e74dea31cde0117bb4916260edbccd37a19f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f342e706e67)\r\n\r\n如果顾客想看的玩具就摆在摊位上，我们就可以把这个玩具直接移到摊位最上面的位置，其他的玩具就要往下挪挪位置了。还记得我们的规则吧，最近有人询问的玩具要摆在最上面显眼的位置。\r\n\r\n![https://camo.githubusercontent.com/7addff0512995fc5e246c09bfcbfd076d6e56c11ba4b9a09146881e8b9b65f7a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f352e706e67](https://camo.githubusercontent.com/7addff0512995fc5e246c09bfcbfd076d6e56c11ba4b9a09146881e8b9b65f7a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f4c52555f352e706e67)\r\n\r\n这就是对 LRU 缓存的一个简单解释。回到计算机问题上面来，玩具摊位代表的就是缓存空间，我们首先需要考虑的问题是使用哪种数据结构来表示玩具摊位，以达到题目要求的时间复杂度。\r\n\r\n**数组？**\r\n\r\n如果选择数组，因为玩具在摊位上的位置会挪来挪去，这个操作的时间复杂度是$O(N)$，不符合题意，pass。\r\n\r\n**链表？**\r\n\r\n- 如果选择链表，在给定节点后新增节点，或者移除给定节点的时间复杂度是 $O(1)$。但是，链表查找节点的时间复杂度是 $O(N)$，同样不符合题意，不过还有办法补救。\r\n- 在玩具摊位的例子中，我们是手动移动玩具，人类只需要看一眼就知道要找的玩具在哪个位置上，但计算机没那么聪明，因此还需要给它一个脑子(哈希表)来记录什么玩具在什么位置上，也就是要用一个哈希表来记录每个 key 对应的链表节点引用。这样查找链表节点的时间复杂度就降到了 $O(1)$，不过代价是空间复杂度增加到了 $O(N)$。\r\n- 另外，由于移除链表节点后还需要把该节点前后的两个节点连起来，因此我们需要的是双向链表而不是单向链表。\r\n\r\n```html\r\n// put\r\n\r\nif key 存在:\r\n    更新节点值\r\n    把节点移到链表头部\r\n\r\nelse:\r\n    if 缓存满了:\r\n        移除最后一个节点\r\n        删除它在哈希表中的映射\r\n\r\n    新建一个节点\r\n    把节点加到链表头部\r\n    在哈希表中增加映射\r\n\r\n// get\r\n\r\nif key 存在:\r\n    返回节点值\r\n    把节点移到链表头部\r\nelse:\r\n    返回 -1\r\n```\r\n\r\n```cpp\r\nclass DLinkedListNode {\r\npublic:\r\n    int key;\r\n    int value;\r\n    DLinkedListNode *prev;\r\n    DLinkedListNode *next;\r\n    DLinkedListNode() : key(0), value(0), prev(NULL), next(NULL) {};\r\n    DLinkedListNode(int k, int val) : key(k), value(val), prev(NULL), next(NULL) {};\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : capacity_(capacity) {\r\n        // 创建两个 dummy 节点来简化操作，这样就不用特殊对待头尾节点了\r\n        dummy_head_ = new DLinkedListNode();\r\n        dummy_tail_ = new DLinkedListNode();\r\n        dummy_head_->next = dummy_tail_;\r\n        dummy_tail_->prev = dummy_head_;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!key_exists_(key)) {\r\n            return -1;\r\n        }\r\n        // 1. 通过哈希表找到 key 对应的节点\r\n        // 2. 将节点移到链表头部\r\n        // 3. 返回节点值\r\n        DLinkedListNode *node = key_node_map_[key];\r\n        move_to_head_(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (key_exists_(key)) {\r\n            // key 存在的情况\r\n            DLinkedListNode *node = key_node_map_[key];\r\n            node->value = value;\r\n            move_to_head_(node);\r\n        } else {\r\n            // key 不存在的情况：\r\n            // 1. 如果缓存空间满了，先删除尾节点，再新建节点\r\n            // 2. 否则直接新建节点\r\n            if (is_full_()) {\r\n                DLinkedListNode *tail = dummy_tail_->prev;\r\n                remove_node_(tail);\r\n                key_node_map_.erase(tail->key);\r\n            }\r\n\r\n            DLinkedListNode *new_node = new DLinkedListNode(key, value);\r\n            add_to_head_(new_node);\r\n            key_node_map_[key] = new_node;\r\n        }\r\n    }\r\nprivate:\r\n    unordered_map<int, DLinkedListNode*> key_node_map_;\r\n    DLinkedListNode *dummy_head_;\r\n    DLinkedListNode *dummy_tail_;\r\n    int capacity_;\r\n\r\n    void move_to_head_(DLinkedListNode *node) {\r\n        remove_node_(node);\r\n        add_to_head_(node);\r\n    };\r\n\r\n    void add_to_head_(DLinkedListNode *node) {\r\n        DLinkedListNode *prev_head = dummy_head_->next;\r\n\r\n        dummy_head_->next = node;\r\n        node->prev = dummy_head_;\r\n\r\n        node->next = prev_head;\r\n        prev_head->prev = node;\r\n    };\r\n\r\n    void remove_node_(DLinkedListNode *node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n        node->prev = node->next = NULL;\r\n    };\r\n\r\n    bool key_exists_(int key) {\r\n        return key_node_map_.count(key) > 0;\r\n    };\r\n\r\n    bool is_full_() {\r\n        return key_node_map_.size() == capacity_;\r\n    };\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n\r\n```jsx\r\nclass DoubleLinkedListNode {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.prev = null;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity;\r\n        // Mappings of key->node.\r\n        this.hashmap = {};\r\n        // Use two dummy nodes so that we don't have to deal with the head/tail seperately.\r\n        this.dummyHead = new DoubleLinkedListNode(null, null);\r\n        this.dummyTail = new DoubleLinkedListNode(null, null);\r\n        this.dummyHead.next = this.dummyTail;\r\n        this.dummyTail.prev = this.dummyHead;\r\n    }\r\n\r\n    _isFull() {\r\n        return Object.keys(this.hashmap).length === this.capacity;\r\n    }\r\n\r\n    _removeNode(node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        node.prev = null;\r\n        node.next = null;\r\n        return node;\r\n    }\r\n\r\n    _addToHead(node) {\r\n        const head = this.dummyHead.next;\r\n        node.next = head;\r\n        head.prev = node;\r\n        node.prev = this.dummyHead;\r\n        this.dummyHead.next = node;\r\n    }\r\n\r\n    get(key) {\r\n        if (key in this.hashmap) {\r\n            const node = this.hashmap[key];\r\n            this._addToHead(this._removeNode(node));\r\n            return node.value;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    put(key, value) {\r\n        if (key in this.hashmap) {\r\n            // If key exists, update the corresponding node and move it to the head.\r\n            const node = this.hashmap[key];\r\n            node.value = value;\r\n            this._addToHead(this._removeNode(node));\r\n        } else {\r\n            // If it's a new key.\r\n            if (this._isFull()) {\r\n                // If the cache is full, remove the tail node.\r\n                const node = this.dummyTail.prev;\r\n                delete this.hashmap[node.key];\r\n                this._removeNode(node);\r\n            }\r\n            // Create a new node and add it to the head.\r\n            const node = new DoubleLinkedListNode(key, value);\r\n            this.hashmap[key] = node;\r\n            this._addToHead(node);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\n- ****Time:**** $O(1)$\r\n- ***Space:** $O(N)$*，链表空间是 $O(N)$，哈希表空间是 $O(N)$，N 为容量大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000594331","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n## S1: DFS\n\n先计算出左子树和右子树的高度，取两者中的最大值，加上当前节点 1，就是当前二叉树的最大深度。\n\n**递归出口：**\n\n- 空节点\n- 叶子节点\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        if (root->left == nullptr && root->right == nullptr) return 1;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```\n\n```jsx\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (!root) return 0;\n    if (!root.left && !root.right) return 1;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root: return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\n\n- ****Time:**** $O(N)$，N 是二叉树的节点总数。\n- ***Space:** $O(logN)$*，递归栈的空间，最坏的情况是二叉树退化成了链表，那递归栈的深度就成了 $O(N)$。\n\n## S2: BFS\n\n**前置：**\n\n[102. 二叉树的层序遍历](https://www.notion.so/102-511fc51ad1ce4d89a97c1d21f94c44bf)\n\n也可用 BFS 的方式来遍历二叉树，每遍历一层深度就加一，再用一个全局变量来追踪深度最大值即可。\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        int maxD = 0;\n        depth(root, 0, maxD);\n        return maxD;\n    }\n    void depth(TreeNode* root, int curD, int& maxD) {\n        if (root == nullptr) {\n            maxD = max(maxD, curD);\n            return;\n        }\n        depth(root->left, curD + 1, maxD);\n        depth(root->right, curD + 1, maxD);\n    }\n};\n```\n\n```jsx\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (!root) return 0;\n\n    let height = 0;\n    const queue = [root];\n\n    while (queue.length) {\n        let len = queue.length;\n        height++;\n\n        while (len > 0) {\n            const node = queue.shift();\n            node.left && queue.push(node.left);\n            node.right && queue.push(node.right);\n            len--;\n        }\n    }\n\n    return height;\n};\n```\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        queue = []\n        if root is not None: queue.append(root)\n        height = 0\n\n        while True:\n            nodeCount = len(queue)\n            if nodeCount == 0: return height\n            height += 1\n\n            while nodeCount > 0:\n                node = queue.pop(0)\n                if node.left is not None: queue.append(node.left)\n                if node.right is not None: queue.append(node.right)\n                nodeCount -= 1\n```\n\n- ****Time:**** $O(N)$，N 是二叉树的节点总数。\n- ***Space:** $O(logN)$*，队列或者递归栈的空间，最坏的情况是二叉树退化成了链表，那空间就成了 $O(N)$。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992431278","body":"## 字符的最短距离\n\n双向遍历的思想\n\n- 从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\n- 从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\n- 这两个值取最小就是答案。\n\n```python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: \n                prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(S) - 1, -1, -1):\n            if S[i] == C: \n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```\n\n时间复杂度和空间复杂度都为O(n)\n\n像这样双向遍历的题还有   分发糖果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993133904","body":"## 设计一个支持增量操作的栈\n\n- 初始化栈\n- push和pop\n- 栈底的 k 个元素的值都增加 val\n\n```python\nclass CustomStack:\n\n    #初始化,maxSize为栈最多能容纳的元素数量\n    def __init__(self, maxSize: int):\n        self.st=[0]*maxSize\n        self.top=-1\n\n    #将元素x添加到栈顶   \n    def push(self, x: int) -> None: \n        if self.top != len(self.st) - 1:\n            self.top += 1\n            self.st[self.top] = x\n\n    #弹出栈顶元素        \n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    # 栈底的 k 个元素的值都增加 val\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n\n此类设计题需要先分析时间空间复杂度，选定合适的数据结构\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a0bb94d-5f53-4234-be93-279d4e7c753d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a0bb94d-5f53-4234-be93-279d4e7c753d/Untitled.png)\n\n贴一个C++解法\n\n```cpp\nclass CustomStack {\nprivate:\n    vector<int> vc;\n    int maxSize;\npublic:\n    CustomStack(int maxSize_) {\n        maxSize = maxSize_;\n        vc.clear();\n        vc.reserve(maxSize);\n    }\n    \n    void push(int x) {\n        if (vc.size() == maxSize) {\n            return;\n        }\n        vc.push_back(x);\n    }\n    \n    int pop() {\n        if (vc.empty()) {\n            return -1;\n        }\n        int res = vc.back();\n        vc.pop_back();\n        return res;\n    }\n    \n    void increment(int k, int val) {\n        int len=0;\n        len = std::min( k, int(vc.size()) );\n        for (int i = 0; i < len; ++i) {\n            vc[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994681985","body":"## 字符串解码\n\ns = \"3[a]2[bc]\"      \"aaabcbc\"\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        numStack=[] #存倍数\n        strStack=[] #存待拼接的字符串\n        num=0\n        result=''\n        for c in s:\n            if c.isdigit(): #遇到数字\n                num=num*10+int(c) \n            elif c=='[':    #遇到[\n                strStack.append(result) #result串入栈\n                result=''  #result清零\n                numStack.append(num)\n                num=0\n            elif c==']':    #遇到]\n                repeatTime=numStack.pop()\n                result=strStack.pop()+result*repeatTime\n            else:           #遇到字母\n                result+=c\n\n        return result\n```\n\nnum 暂存数字 遇到左括号入栈 num清零   遇到右括号从栈中取出数字作为倍数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995803666","body":"## 两个栈实现队列\n\n```python\nclass CQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def appendTail(self, value: int) -> None: #入栈是放到入栈栈里\n        self.stack_in.append(value)\n\n    def deleteHead(self) -> int:\n        if not self.stack_out:  # 出栈栈为空\n            if not self.stack_in: # 都为空\n                return -1\n            else: # 把in栈中的东西全部倒入out栈中\n                while self.stack_in:\n                    self.stack_out.append(self.stack_in.pop())\n        \n        return self.stack_out.pop()\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997198949","body":"## 旋转链表\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        #先遍历 成环+求出链表长度 再断开\n        if head==None or head.next==None:\n            return head\n        p=head\n        pre=head\n        len=0\n        while p:\n            pre=p\n            p=p.next\n            len+=1\n        pre.next=head #成环了\n        #下面是计算从链表头开始数 跳多少下能到旋转后的链表尾 即环断开的地方\n        move=len-k%len-1\n        p=head\n        while move:\n            p=p.next\n            move-=1\n        pre=p.next\n        p.next=None\n        return pre\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997536773","body":"## 有序链表转换二叉搜索树\n\n\n```python\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def findmid(head, tail):\n            slow = head\n            fast = head\n            while fast != tail and fast.next!= tail :\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        def helper(head, tail):\n            if  head == tail: return \n            node = findmid(head, tail)\n            root = TreeNode(node.val)\n            root.left = helper(head, node)\n            root.right = helper(node.next, tail)\n            return root\n            \n        return helper(head, None)\n```\n\n递归的过程\n\n- 找到中间节点作为根节点\n- 递归 中间节点的左边部分\n- 递归  中间节点的右边部分\n\n递归函数为 helper(head,tail)  返回head至tail部分的根节点","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999403096","body":"让fast每次走两步 slow每次走一步 相遇之后 一个指针从这个相遇的位置出发 一个指针从链表的头出发 相遇的地方即为环的入口\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        ##让fast每次走两步  slow每次走一步    相遇之后  一个指针从这个相遇的位置出发 \n        ## 一个指针从链表的头出发   相遇的地方即为环的入口\n        fast=head\n        slow=head\n        while fast!=None and fast.next!=None:\n            slow=slow.next\n            fast=fast.next.next\n            if(slow==fast):\n                p1=fast\n                p2=head\n                while(p1!=p2):\n                    p1=p1.next\n                    p2=p2.next\n                return p2\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000018030","body":"## LRU缓存机制\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3258393-ff47-432d-9475-88989a44b23e/Untitled.png)\n\n问题分析：\n\nget方法实现O(1)时间复杂度需要哈希表\n\n插入[关键字-值]需要链表  删除数据值要o(1)时间复杂度需要链表是双向的\n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000860678","body":"### 二叉树的最小深度和二叉树的最大深度\n\n```python\n#这是最小深度\nclass Solution:\n    def minDepth(self, root: TreeNode) -> int:\n        def helper(root):\n            if not root:\n                return 0\n            elif root.left and root.right:\n                return 1+min(helper(root.left),helper(root.right))\n            elif root.left:\n                return 1+helper(root.left)\n            elif root.right:\n                return 1+helper(root.right)\n            else:#叶子节点\n                return 1\n        return helper(root)\n```\n\n```python\n#这是最大深度\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        def helper(root):\n            if not root:\n                    return 0\n            return 1+max(helper(root.left),helper(root.right))\n        return helper(root)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991993182","body":"## Problem\r\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\r\n\r\n## Note\r\n- Intuition: scan once and mark all the c index. scan again to calculate the distance comparing the marked index.\r\n- Improvement: scan once from left to right and calculate the initial distance. scan again from right to left and update the distance. Note that from left to right, need to use Integer.MIN_VALUE / 2 to avoid overflow.\r\n\r\n## Solution\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if(s == null || s.isEmpty()){\r\n            return null;\r\n        }\r\n        \r\n        int[] res = new int[s.length()];\r\n        \r\n        int left = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                left = i;\r\n            }\r\n            res[i] = Math.abs(i - left);\r\n        }\r\n        \r\n        int right = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                right = i;\r\n            }\r\n            res[i] = Math.min(res[i], Math.abs(right - i));\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n) n is the length of s.\r\n- S: O(1) no extra space is required.\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992774750","body":"## Problem\r\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## Note\r\n- Use int array and record the maxSize and curSize\r\n\r\n## Solution\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n## Complexity\r\n- T: O(1) for push and pop, O(k) for increment.\r\n- S: O(n) n is the max size of the stack.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993936277","body":"## Problem\r\nhttps://leetcode.com/problems/decode-string/\r\n\r\n## Note\r\n- Stack\r\n- ']' is the key to decide in stack or out stack\r\n- Note that there are embeded cases\r\n\r\n## Solution\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if(s == null || s.isEmpty()){\r\n            return null;\r\n        }\r\n        \r\n        int n = s.length();\r\n        int cur = 0;\r\n        Stack<Character> stack = new Stack<>();\r\n        while(cur < n){\r\n            char c = s.charAt(cur);\r\n            if(c != ']'){\r\n                stack.push(c);  \r\n            }else{\r\n                List<Character> letters = new LinkedList<>();\r\n                while(!stack.isEmpty() && stack.peek() != '['){\r\n                    letters.add(0, stack.pop());\r\n                }\r\n                \r\n                stack.pop(); // pop the '['\r\n                \r\n                StringBuilder digits = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\r\n                    digits.insert(0, stack.pop());\r\n                }\r\n                int num = Integer.parseInt(digits.toString());\r\n                for(int i = 0; i < num; i++){\r\n                    for(char letter: letters){\r\n                        stack.push(letter);\r\n                    }\r\n                }\r\n            }\r\n            cur++;\r\n        }\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            sb.insert(0, stack.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n). n is the length of the decoded string of s.\r\n- S: O(n). n is the length of the decoded string of s.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995059482","body":"## Problem\r\nhttps://leetcode.com/problems/implement-queue-using-stacks/\r\n\r\n## Note\r\n- Stack\r\n- No need to use size variable to make the current queue size. Only need to use stack's api.\r\n\r\n## Solution\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> inStack;\r\n    Stack<Integer> outStack;\r\n    \r\n\r\n    public MyQueue() {\r\n        inStack = new Stack<>();\r\n        outStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(outStack.empty()){\r\n            toOutStack();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(outStack.empty()){\r\n            toOutStack();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n    \r\n    private void toOutStack(){\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## Complexity\r\n- T: O(1) for push and empty methods. Amortized O(1) for pop and peek methods.\r\n- S: O(n) n is the size of the queue.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996188663","body":"## Problem\r\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## Note\r\n- mono stack\r\n- non-increasing subarray cannot be divided\r\n- non-decreasing subarray can be divided\r\n\r\n## Solution\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        if(arr == null || arr.length == 0){\r\n            return 0;\r\n        }\r\n        \r\n        Stack<Integer> monoStack = new Stack<>(); // mono increasing stack\r\n        for(int num: arr){\r\n            if(monoStack.isEmpty() || num >= monoStack.peek()){\r\n                monoStack.push(num);\r\n                continue;\r\n            }\r\n            \r\n            int top = monoStack.pop();\r\n            while(!monoStack.isEmpty() && num < monoStack.peek()){\r\n                monoStack.pop();\r\n            }\r\n            monoStack.push(top);\r\n        }\r\n        \r\n        return monoStack.size();\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n) n is the length of arr\r\n- S: O(n) for the stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996976535","body":"## Problem\r\nhttps://leetcode.com/problems/rotate-list/\r\n\r\n## Note\r\n- check the size and actual k before rotating\r\n- use newHead/newTail/oldTail to point to the important nodes\r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // get the size of the list and find the oldTail\r\n        // size % k => actual k\r\n        // if actual k is 0, return head\r\n        // move from head with size - actual k -1 steps, find the newTail\r\n        // new head is newTail.next\r\n        // link oldTail with old head\r\n        // cut the newTail\r\n        // return new head\r\n        \r\n        \r\n        // T: O(n) n is the size of the list\r\n        // S: O(1) no extra space is required\r\n        \r\n        if(head == null || head.next == null || k <= 0){\r\n            return head;\r\n        }\r\n        \r\n        int size = 1;\r\n        ListNode oldTail = head;\r\n        while(oldTail != null && oldTail.next != null){\r\n            size++;\r\n            oldTail = oldTail.next;\r\n        }\r\n        \r\n        int actualK = k % size;\r\n        if(actualK == 0){\r\n            return head;\r\n        }\r\n        \r\n        ListNode newTail = head;\r\n        for(int i = 0; i < size - actualK - 1; i++){\r\n            newTail = newTail.next;\r\n        }\r\n        \r\n        ListNode newHead = newTail.next;\r\n        \r\n        oldTail.next = head;\r\n        newTail.next = null;\r\n        return newHead;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n) n is the size of the list\r\n- S: O(1) no extra space is required","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997293421","body":"## Problem\r\nhttps://leetcode.com/problems/swap-nodes-in-pairs/\r\n\r\n## Note\r\n- Sentinel nodes\r\n- Group every two nodes between two sentinel nodes\r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        \r\n        // set the dummy for return val\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        // sHead -> start -> end -> sTail\r\n        ListNode sHead = dummy;\r\n        ListNode start, end, sTail;\r\n        \r\n        while(sHead.next != null && sHead.next.next != null){ // start and end not null\r\n            // set up nodes\r\n            start = sHead.next;\r\n            end = start.next;\r\n            sTail = end.next;\r\n            \r\n            // reverse\r\n            end.next = start;\r\n            sHead.next = end;\r\n            start.next = sTail;\r\n            \r\n            // update for next loop\r\n            sHead = start;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n) n is the number of nodes in the list\r\n- S: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997564555","body":"## Problem\r\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## Note\r\n- Recursion\r\n  - solution 1. find mid to form the root and recursively form left sub tree and right sub tree\r\n  - solution 2. simulate BST inorder traversal, calculate the size of list, and recursively form all the left sub trees, then root, then right sub trees.\r\n\r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        \r\n        if(head.next == null){\r\n            return new TreeNode(head.val);\r\n        }\r\n        \r\n        return helper(head, null);\r\n    }\r\n    \r\n    private TreeNode helper(ListNode head, ListNode tail){\r\n        if(head == tail){\r\n            return null;\r\n        }\r\n        // find middle node\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while(fast != tail && fast.next != tail){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        // slow is the middle\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(head, slow);\r\n        root.right= helper(slow.next, tail);\r\n        \r\n        return root;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(nlogn). n is the number of list nodes.\r\n- S: O(logn). Extra space is required for recursion stacks. The number of stacks is the number of the height of tree. Since the tree is balanced, the height is logn.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998446840","body":"## Problem\r\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/\r\n\r\n## Notes\r\n- Can use set\r\n- Or can use two pointers\r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null){\r\n            return null;\r\n        }\r\n        \r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode pA = headA;\r\n        while(pA != null){\r\n            set.add(pA);\r\n            pA = pA.next;\r\n        }\r\n        \r\n        ListNode pB = headB;\r\n        while(pB != null){\r\n            if(set.contains(pB)){\r\n                return pB;\r\n            }\r\n            pB = pB.next;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(m + n). m + n is the number of nodes of A and B.\r\n- S: O(n). n is the number of nodes of A. Extra space is required for the set.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998947032","body":"## Problem\r\nhttps://leetcode.com/problems/linked-list-cycle-ii/\r\n\r\n## Note\r\n- Can use set\r\n- Or can use two pointers\r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        \r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode ptr = head;\r\n        while(ptr != null){\r\n            if(set.contains(ptr)){\r\n                return ptr;\r\n            }\r\n            set.add(ptr);\r\n            ptr = ptr.next;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n) n is the number of nodes of the list.\r\n- S: O(n) Extra space is required for the set.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000011417","body":"## Problem\r\nhttps://leetcode.com/problems/lru-cache/\r\n\r\n## Note\r\n- hash map + doubly linked list\r\n- list node should have both key and value\r\n- note that to create methods for linked list operation, leave the map operation in the api methods\r\n\r\n## Solution\r\n```java\r\nclass ListNode{\r\n    int key;\r\n    int val;\r\n    ListNode next;\r\n    ListNode prev;\r\n    public ListNode(){}\r\n    public ListNode(int key, int val){\r\n        this.key = key;\r\n        this.val = val;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    private Map<Integer, ListNode> map;\r\n    private ListNode head;\r\n    private ListNode tail;\r\n    private int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        this.map = new HashMap<>();\r\n        this.head = new ListNode();\r\n        this.tail = new ListNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        int res = -1;\r\n        if(map.containsKey(key)){\r\n            ListNode node = map.get(key);\r\n            res = node.val;\r\n            moveToHead(node);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.containsKey(key)){\r\n            ListNode node = map.get(key);\r\n            node.val = value;\r\n            moveToHead(node);\r\n        }else{\r\n            ListNode toAdd = new ListNode(key, value);\r\n            map.put(key, toAdd);\r\n            addToHead(toAdd);\r\n            if(map.size() > capacity){\r\n                ListNode node = removeTail();\r\n                map.remove(node.key);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void moveToHead(ListNode node){\r\n        remove(node);\r\n        addToHead(node);\r\n    }\r\n    \r\n    private void remove(ListNode node){\r\n        ListNode pre = node.prev;\r\n        pre.next = node.next;\r\n        node.next.prev = pre;\r\n    }\r\n    \r\n    private void addToHead(ListNode node){\r\n        node.next = head.next;\r\n        node.next.prev = node;\r\n        head.next = node;\r\n        node.prev = head;\r\n    }\r\n    \r\n    private ListNode removeTail(){\r\n        ListNode toRemove = tail.prev;\r\n        remove(toRemove);\r\n        return toRemove;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\n## Complexity\r\n- T: put and add operations are O(1).\r\n- S: O(capacity) for the map and list.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000620155","body":"## Problem\r\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\r\n\r\n## Note\r\n- DFS. \r\n  - if null then return 0\r\n  - recursively call on left subtree and right subtree\r\n  - result is max(left, right) + 1\r\n- BFS. \r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        \r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n        \r\n        return Math.max(left, right) + 1;\r\n    }\r\n}\r\n```   \r\n\r\n## Complexity\r\n- T: O(n). n is the number of nodes.\r\n- S: O(h). h is the height of the tree. Best case is O(logn), worst case is O(n). ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000977155","body":"## Problem\r\nhttps://leetcode.com/problems/same-tree/\r\n\r\n## Note\r\n- DFS recursion\r\n- BFS\r\n\r\n## Solution\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null){\r\n            return true;\r\n        }\r\n        \r\n        if(p == null || q == null){\r\n            return false;\r\n        }\r\n        \r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(p);\r\n        queue.offer(q);\r\n        \r\n        while(!queue.isEmpty()){\r\n            TreeNode a = queue.poll();\r\n            TreeNode b = queue.poll();\r\n            if(a == null && b == null){\r\n                continue;\r\n            }\r\n            \r\n            if(a == null || b == null){\r\n                return false;\r\n            }\r\n            \r\n            if(a.val != b.val){\r\n                return false;\r\n            }\r\n            \r\n            queue.offer(a.left);\r\n            queue.offer(b.left);\r\n            queue.offer(a.right);\r\n            queue.offer(b.right);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- DFS\r\n  - T: O(n). n is the number of tree nodes.\r\n  - S: O(h). h is the height of the tree, which is the recursion depth.\r\n- BFS\r\n  - T: O(n).\r\n  S: O(k). k is the max number of tree nodes between any two adjacent tree layers. ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15691894985":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992154137","body":"day【2】题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\n```python\n    class Solution(object):\n        def shortestToChar(self, S, C):\n            prev = float('-inf')\n            ans = []\n            for i, x in enumerate(S):\n                if x == C: prev = i\n                ans.append(i - prev)\n    \n            prev = float('inf')\n            for i in xrange(len(S) - 1, -1, -1):\n                if S[i] == C: prev = i\n                ans[i] = min(ans[i], prev - i)\n            return ans\n```\n复杂度分析\n\n- 时间复杂度：O(N)，其中 NN 是 S 的长度，遍历字符串两次。\n- 空间复杂度：O(N)，ans 数组的大小。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993648209","body":"【Day 3】1381. 设计一个支持增量操作的栈\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n1.使用list模拟栈，用变量top记录末尾元素\n\n2.push:直接在对应坐标（top+1）赋值\n\n3.pop ：返回list末尾值，对应top对应减1\n\n4.increment： 直接K和list中的k个较小值，然后，对应元素加Val，如果少于K全加\n```java\n    class CustomStack{\n        int[] length;\n        int index;\n        int maxSize;\n    \n        public CustomStack(int maxSize) {\n            length = new int[maxSize];\n            index = 0;\n            this.maxSize = maxSize;\n        }\n        public void push(int x){\n            if (index < maxSize){\n                length[index++] = x;\n            }\n        }\n        public int pop(){\n            if (index > 0){\n                return length[--index];\n            }else{\n                return -1;\n            }\n        }\n    \n        public void increment(int k, int val){\n            if (k > maxSize){\n                for (int i = 0; i < maxSize; i++){\n                    length[i] += val;\n                }\n                }else{\n                for (int i=0 ;i < k;i++){\n                        length[i] += val;\n                    }\n                }\n            }\n        \n    }\n```\n复杂度：\n\n时间复杂度：increment是O(N) pop、push 是O(1)\n\n空间复杂度：O(N)栈容量\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994534031","body":"day【4】题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n思考：成对的[]最后是重复的字符串，[前的数字是重复的次数，因此先讨论以下规则：\r\n\r\n- 如果是字母-添加到stack 当中\r\n- 如果是数字—先不急加入stack，因为可能有多位数字\r\n- 如果[，说明重复字符串开始，将数字入栈，并且数字清零\r\n- 如果是]说明字符串结束将重复字符串重复前存储的数字遍\r\n```python\r\n    class Solution:\r\n        def decodeString(self, s: str) -> str:\r\n            stack = []\r\n            for c in s:\r\n                if c == ']':#对前面的字符进行操作重复\r\n                    repeatStr = ''\r\n                    repeatCount = ''\r\n                    while stack and stack[-1] != '[':\r\n                        repeatStr = stack.pop() + repeatStr\r\n                    stack.pop()#去掉“[”\r\n                    while stack and stack[-1].isnumeric():\r\n                        repeatCount = stack.pop() + repeatCount\r\n                    stack.append(int (repeatCount) * repeatStr)\r\n                else:\r\n                    stack.append(c)\r\n            return \"\".join(stack)\r\n```\r\n复杂度：\r\n\r\n时间复杂度：O(N*k) 0整个字符串长度，k最大重复 \r\n\r\n空间复杂度：O(N)栈容量 解码后的长度 \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995396694","body":"### 【Day 5】232. 用栈实现队列\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n```python\nclass MyQueue(object):\n    def __init__(self):\n    \tself.stack=[]\n    def push(self,x):\n        self.stack.append(x)\n    def pop(self):\n    \ta = self.stack[0]\n        self.stack = self.stack[1:]\n        return a\n    def peek(self):\n        return self.stack[0]\n    def empty(self):\n        if len(self.stack)!=0:\n            return False\n        else:\n            return True\n```\n\n复杂度：\n\n时间复杂度：push:O(1)   peek:O(1)  empty：O(1) pop:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996678413","body":"### day 6  768. 最多能完成排序的块 II**\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n分割的临界点判断：\n\n一直找到下一个比当前值小的元素 把分割区块考虑为融合区块，找到一个下一个比当前值小的就融合为一块，保留当前最大值到一个栈，然后将其入另外一个栈。栈里的每一个元素就是块的最大值。\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\t\t  LinkedList<Integer> stack = new LinkedList<Integer>();\n\t\t  for (int num: arr){\n\t\t\t  if (!stack.isEmpty() && num < stack.getLast()){\n\t\t\t\t  int cur = stack.removeLast();\n\t\t\t\t  while (!stack.isEmpty() && num < stack.getLast()){\n\t\t\t\t\t  stack.removeLast();\n\t\t\t\t  }\n\t\t\t\t  stack.addLast(cur);\n\t\t\t  }else{\n\t\t\t\t  stack.addLast(num);\n\t\t\t  }\n\t\t  }\n\t\t  return stack.size();\n    }\n}\n```\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997196661","body":"### **day【7 】61. 旋转链表**\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n+ 找到链表中倒数k和k+1个节点，用快慢指针，快指针比慢指针先走K步。\n\n+ 将倒数K+1节点的next指向null\n\n+ 将尾部节点Next指向head\n\n+ 返回倒数第K个节点    右移动k位 即向右移动K%len\n\n**方法一双指针：**\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }*/\n\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k){\n        if (head == null || head.next == null)\n            return head;\n        int count = 0;\n        ListNode now = head;\n        while (now != null){\n            now = now.next;\n            count ++; //\t看链表的长度，为解决K > n 的情况\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while (fast.next != null){\n            if (k-- <= 0){\n                slow = slow.next;\n            }fast = fast.next;//fast指针比slow慢k个\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n    \n}\n```\n\n**复杂度分析**：\n\n+ 时间复杂度，O(N) 最坏情况下遍历两次\n+ 空间复杂度，O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997413083","body":"### **day8   24. 两两交换链表中的节点**\n\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n**思路**：\n\n  1.链表节点的指针，两两交换。定义两个节点的前节点和第二个节点的后续节点，然后逆转。同时改变指针位置。进行下一次交换\n\n  2.判断边界条件，为空表和只有一个节点的时候\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n         if not head or not head.next:#为空表 或者只有一个节点\n            return head\n         ans = ListNode()  # A = new 链表新节点\n         ans.next = head.next# A.next =B\n         pre = ans  # A节点\n        # 第一个节点 = head\n         while (head and head.next): #第一个节点不为空且其next不为空\n            next = head.next# B = A.next\n            n_next = next.next# Bnext= B.next\n            # 对链表进行逆转\n            next.next = head  # B.next = A\n            pre.next = next # A.next  = B\n            head.next = n_next# A.next = Bnext\n\n            # 修改指针位置，进行下一轮逆转\n            pre = head# 前置指针 = 第一个节点 pre -> B-> A-> nextB 指向A\n            head = n_next # 第一个节点 = 后指针\n         return ans.next\n```\n\n**复杂度**：\n\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997871145","body":"### **day 9  2021.9.18**   有序链表转换二叉搜索树\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n方法一：快慢指针\n\n思路：\n\n+ 获取链表中点，以中点为根节点，构造左树，造右树\n+ 获取链表中点：快指针进两步，慢指针进一步 因此快指针到达尾部时候，慢指针就在中间\n+ 考虑特殊情况，空链表和链表中只有一个节点的情况\n\n```python\n   def sortedListToBST(self,head:ListNode)->TreeNode:\n        #双指针\n        if not head or not head.next:#为空表 或者只有一个节点\n            return head\n        pre =None #中间节点\n        p1,p2 = head,head\n        while p2 and p2.next:\n            pre = p1\n            p1 = p1.next #慢指针进一步 因此快指针到达尾部时候，慢指针就在中间\n            p2 = p2.next.next #快指针进两步\n        #建立并断开前后连续连接点\n        if pre:\n            pre.next = None\n        root = TreeNode(p1.val)\n        # 递归建立左右子树\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(p1.next)\n        print(root)\n        return root\n```\n\n**复杂度分析：**\n\n+ 时间复杂度：由于主定理 T(N)=O(N)+2T(N/2),可推导出来O（nlogn）\n+ 空间复杂度为：O(logn)递归的调用深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998840298","body":"思路：\n\n+ 两指针以相同的速度从头节点移动\n+ 当A到达尾节点时候，把headA重新定位到B的头节点\n+ 当B到达尾节点时候，把headB重新定位到A的头节点\n+ A、B指针相遇时，相遇节点为两链表的起始节点 因为两个指针访问都经过A+B+C\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n#     双指针\n    a,b = headA, headB\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n    return a\n```\n\n**复杂度分析**:\n\n+ 时间复杂度：需要遍历的长度为A+B+C 所以为O(N)\n+ 空间复杂度：返回一个值O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999671746","body":"### **day11 9.20  142. 环形链表 II**\n\n**思路：双指针**\n\n+ 先设置快慢指针，快指针是慢指针的两倍\n\n+ 当快慢指针第一次相遇时候   慢指针绕完了一个环 2(L+C) = L+2C+D记录第一次相遇的位置x\n\n+ 因此L=D  ,把快指针重新定位到头节点，然后重新让快慢指针步进，再次相遇时候就为环的入口。\n\n  ```python\n  def detectCycle(self, head: ListNode) -> ListNode:\n      slow = fast = head\n      x = None\n      while fast and fast.next:\n          # #     快指针是慢指针两倍\n          fast = fast.next.next\n          slow = slow.next\n          if fast == slow:\n              x = fast\n              # 找到相遇的第一个节点，把fast赋值给x\n              break\n      if not x:\n          return None\n      fast = head\n      while fast != x:\n          fast = fast.next\n          x = x.next\n      return fast\n  ```\n\n  **复杂度分析**：\n\n  + 时间复杂度：O（N）链表的长度\n  + 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000339166","body":"### **day 12 2021.9.21 LRU 缓存机制**\n\nhttps://leetcode-cn.com/problems/lru-cache/\n\n思路：题意理解：时间复杂度为O(1)。链表移除节点复杂度为O(1)，查找却为O(N)\n\n+ 移除链表节点后把该节点前后链接起来，因此需要双向链表而不是单向链表；\n\n+ 需要用哈希表来记录每个key对应的链表引用\n\n+ 在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\n\n  ```python\n  class ListNode:\n      def __init__(self,key = 0,val = 0):\n          self.key = key\n          self.val = val\n          self.prev = None #伪头部\n          self.next = None#伪尾部\n  class LRUCache:\n      def __init__(self,capacity):\n          self.capacity = capacity\n          self.hshmap = dict()\n          self.head = ListNode()\n          self.tail = ListNode()\n          self.head.next = self.tail\n          self.tail.prev = self.head\n          self.size = 0\n      def addToHead(self,node):\n          node.prev = self.head\n          node.next = self.head.next\n          self.head.next.prev = node\n          self.head.next = node\n      def removeNode(self,node):\n          node.prev.next = node.next\n          node.next.prev = node.prev\n      def moveToHead(self,node):\n          self.removeNode(node)\n          self.addToHead(node)\n  \n      def removeTail(self):\n          node = self.tail.prev\n          self.removeNode(node)\n          return node\n      def put(self,key:int,value:int)->None:\n          if key not in self.hshmap:\n              #如果key不存在时，创造新节点\n              node = ListNode(key,value)\n  #             添加进哈希表\n              self.hshmap[key] = node\n              #添加至双向链表表头\n              self.addToHead(node)\n              self.size += 1\n              if self.size > self.capacity:\n                  #如果超出容量，删除双向链表的尾部节点\n                  removed = self.removeTail()\n                  #并删除哈希表中对应的项\n                  self.hshmap.pop(removed.key)\n                  self.size -= 1\n          else:\n              #如果key存在，通过哈希表定位，修改value\n              node = self.hshmap[key]\n              node.val = value\n              #访问就把其移动到头节点\n              self.moveToHead(node)\n      def get(self,key:int)->int:\n          if key not in self.hshmap:\n              return -1\n          #key存在时候，先通过哈希表定位，移动到头部\n          node = self.hshmap[key]\n          self.moveToHead(node)\n          return node.val\n  ```\n\n**复杂度分析**\n\n+ 时间复杂度：O（1）因为链表的操作只需要1\n\n+ 空间复杂度：O（N）需要N个容量大小的hashmap来记录key","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000873083","body":"### Day 13  二叉树的最大深度\n\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree\n\n思路：\n\n+ 输出深度是当前root的最大深度\n\n+ 深度优先搜索，比较左右节点的深度递归，取左右节点的最大\n\n+ 出口是当前节点为空\n\n  ```python\n  class Solution:\n      def maxDepth(self, root: TreeNode) -> int:\n          def dfs(root):\n              if not root :\n                  return 0\n              left = dfs(root.left)\n              right = dfs(root.right)\n              depth = max(left,right)\n              return depth +1\n          return dfs(root)\n  ```\n\n  **复杂度分析**：\n\n  时间复杂度：O(N),其中N为节点个数\n\n  空间复杂度:   O(h),h为树的深度，最坏时候为N","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xj-yan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991819951","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num2 = list()\n        while k:\n            tmp = k % 10\n            num2.append(tmp)\n            k //= 10\n        num2.reverse()\n        i, j = len(num) - 1, len(num2) - 1\n        isCarried = False\n        res = list()\n        while i >= 0 or j >= 0 or isCarried:\n            digit = (num[i] if i >= 0 else 0) +  (num2[j] if j >= 0 else 0) + (1 if isCarried else 0)\n            isCarried = True if digit >= 10 else False\n            res.append(digit % 10)\n            i -= 1\n            j -= 1\n        res.reverse()\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992551556","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n, pos = len(s), -float('inf')\n        res = [n] * n\n        for i in list(range(n)) + list(range(n)[::-1]):\n            if s[i] == c:\n                pos = i\n            res[i] = min(res[i], abs(i - pos))\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993673807","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) >= 1:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n```\nTime Complexity: O(k), Space Complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994916790","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        num = 0\n        for i in range(len(s)):\n            c = s[i]\n            if c.isnumeric():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append(res)\n                stack.append(num)\n                res = \"\"\n                num = 0\n            elif c.isalpha():\n                res += c\n            elif c == \"]\":\n                pre_num = stack.pop()\n                pre_string = stack.pop()\n                res = pre_string  + pre_num * res\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995199441","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.in_stack, self.out_stack = [], []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def move(self) -> None:\n       if not self.out_stack:\n            while self.in_stack: self.out_stack.append(self.in_stack.pop())     \n                \n    def pop(self) -> int:\n        self.move()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        return (not self.in_stack) and (not self.out_stack)\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996735826","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            largest = num\n            while stack and stack[-1] > num:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        return len(stack)\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997085874","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:   return head\n        \n        length = self.getLength(head)\n        if k % length == 0: return head\n        k = length - k % length\n        dummy = ListNode(0)\n        curt = head\n        \n        while k > 1:\n            curt = curt.next\n            k -= 1\n        newEnd = curt\n        curt = curt.next\n        newEnd.next = None\n        dummy.next = curt\n        while curt.next:\n            curt = curt.next\n        curt.next = head\n        return dummy.next\n            \n        \n    def getLength(self, head):\n        count = 0\n        curt = head\n        while curt:\n            count += 1\n            curt = curt.next\n        return count\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997292142","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = pointer = ListNode(0, head)\n        while pointer:\n            node = pointer\n            cnt = 0\n            while cnt < 2 and node:\n                cnt += 1\n                node = node.next\n            if not node: break\n            prev, curt, nxt = None, pointer.next, None\n            for i in range(2):\n                nxt = curt.next\n                curt.next = prev\n                prev = curt\n                curt = nxt\n            tail = pointer.next\n            tail.next = curt\n            pointer.next = prev\n            pointer = tail\n        return dummy.next\n```\nTime Complexity: O(n), Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997501860","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        num = []\n        while head:\n            num.append(head.val)\n            head = head.next\n        return self.buildBST(0, len(num) - 1, num)\n    \n    def buildBST(self, start, end, num):\n        if start > end: return None\n        if start == end: return TreeNode(num[start])\n        \n        mid = (start + end) // 2\n        root = TreeNode(num[mid])\n        root.left = self.buildBST(start, mid - 1, num)\n        root.right = self.buildBST(mid + 1, end, num)\n        return root\n```\nTime Complexity: O(n), Space Complexity; O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998072317","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        curtA, curtB = headA, headB\n        while curtA != curtB:\n            curtA = curtA.next if curtA else headB\n            curtB = curtB.next if curtB else headA\n        return curtA\n```\nTime Complexity: O(n), Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999068910","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        return None\n```\nTime Complexity: O(n), Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000393399","body":"```python\nclass Node:\n    def __init__(self, k, v):\n        self.key = k\n        self.val = v\n        self.prev = None\n        self.next = None\n        \nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.count = 0\n        self.d = dict()\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _update(self, n):\n        self._remove(n)\n        self._add(n)\n        \n    def _remove(self, n):\n        prev = n.prev\n        nxt = n.next\n        prev.next = nxt\n        nxt.prev = prev\n        \n    def _add(self, n):\n        nxt = self.head.next\n        self.head.next = n\n        n.next = nxt\n        nxt.prev = n\n        n.prev = self.head      \n        \n    def get(self, key: int) -> int:\n        if key in self.d:\n            n = self.d[key]\n            self._update(n)\n            return n.val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.d:\n            n = self.d[key]\n            n.val = value\n            self._update(n)\n        else:\n            n = Node(key, value)\n            self.d[key] = n\n            self.count += 1\n            if self.count > self.capacity:\n                toRemove = self.tail.prev\n                self._remove(toRemove)\n                del self.d[toRemove.key]\n                self.count -= 1\n                \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\nTime Complexity: O(1), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000546126","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        left, right = self.maxDepth(root.left), self.maxDepth(root.right)\n        return max(left, right) + 1\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000941303","body":"```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p or not q: return p == q\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001072560","body":"```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        stack, res = [], 0\n        if root:\n            stack.append(root)\n        while stack:\n            node = stack.pop()\n            if not node.left and not node.right:\n                res += node.val\n            if node.right:\n                node.right.val += node.val * 10\n                stack.append(node.right)\n            if node.left:\n                node.left.val += node.val * 10\n                stack.append(node.left)\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ychen8777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilixikun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peteruixi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user1689":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xieyj17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shamworld":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991877147","body":"```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992047270","body":"```js\nvar shortestToChar = function(s, c) {\n    let arr = [];\n    let result = [];\n    for(let i = 0;i < s.length; i++){  \n        if(s[i]===c){\n            arr.push(i)\n        }\n    }\n    for(let i = 0;i < s.length; i++){\n        if(s[i]===c){\n            result[i] = 0;\n            continue\n        }\n        \n        for(let index of arr){\n            let res = Math.abs(index-i);\n            console.log(result)\n            if(res>=result[i]) break;\n            result[i] = res;\n        }\n    }\n    return result\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993123116","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stackList = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stackList.length>=this.maxSize) return null;\n    this.stackList.push(x); \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    \n    if(this.stackList.length==0) return -1;\n    return this.stackList.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<this.stackList.length){\n        for(let i = 0; i < k; i++){\n            this.stackList[i] += val\n        }\n    }else{\n        for(let i = 0; i < this.stackList.length; i++){\n            this.stackList[i] += val\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994220422","body":"```js\nvar decodeString = function(s) {\n    let numList = [];//数组数组\n    let numStr = \"\";//数组长度 \n    let str=\"\";//中括号里面的字符串\n    let stackList = [];//字符串数组\n    let result = \"\";\n    for(let i = 0; i < s.length;i++){\n        let n = s.charAt(i);\n        if(n>=0&&n<=9){\n            numStr += n;\n        } else if (n === '['){\n            numList.push(numStr);\n            stackList.push(str);\n            str = \"\";\n            numStr = \"\";\n        } else if (n === ']'){\n            let num = numList.pop();\n            let temp = \"\"\n            for(let j = 0;j < num; j++){\n                temp += str;\n            }\n            let stackStr = stackList.length>0?stackList.pop():'';\n            str = stackStr+temp; \n            // console.log(result,stackStr,temp);\n            if(numList.length==0){\n                result += str;\n                str = \"\";\n            }\n        } else {\n            if(numList.length==0){\n                result += n;\n            }else{\n                str += n; \n            }\n            \n        }\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995375875","body":"```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.stackInList = [];\n    this.stackOutList = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackInList.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.stackOutList.length){\n        while(this.stackInList.length){\n            this.stackOutList.push(this.stackInList.pop());\n        }\n    }\n    return this.stackOutList.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stackOutList.length){\n        while(this.stackInList.length){\n            this.stackOutList.push(this.stackInList.pop());\n        }\n    }\n    if(!this.stackOutList.length) return null;\n    return this.stackOutList[this.stackOutList.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stackOutList.length && !this.stackInList.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996375507","body":"```js\nvar maxChunksToSorted = function(arr) {\n    let sortArr = [...arr];\n    sortArr.sort((a,b)=>a-b);\n    let count = 0,num1 = 0,num2 = 0;\n    for(let i = 0; i < arr.length; i++){\n        num1 += arr[i];\n        num2 += sortArr[i];\n        if(num1==num2){\n            count++;\n        }\n    }\n    return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997177785","body":"```js\nvar rotateRight = function(head, k) {\n    if(!head) return head;\n    let preNode = head;\n    let len = 1;\n    while(preNode.next!=null){\n        len++;\n        preNode = preNode.next;\n    }\n    preNode.next = head;\n    let curNode = head;\n     k = k % len;\n    for(let i = 0; i < len - k - 1; i++){\n        curNode = curNode.next;\n    }\n    let head2 = curNode.next;\n    curNode.next = null;\n    return head2\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997376829","body":"```js\nvar swapPairs = function(head) {\n    if(!head||!head.next){\n        return head;\n    }\n    let node = new ListNode(0);\n    node.next = head;\n    let temp = node;\n    while(temp.next!==null&&temp.next.next!==null){\n        let tempNode1 = temp.next;\n        let tempNode2 = temp.next.next;\n        temp.next = tempNode2;\n        tempNode1.next = tempNode2.next;\n        tempNode2.next = tempNode1;\n        temp = tempNode1;\n    }\n\n    return node.next;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997542434","body":"## 思路\n快慢指针法\n\n## 代码\n```js\nvar sortedListToBST = function(head) {\n    if(!head) return null;\n    function deep(left,right){\n        if(left==right)return null;\n        let fast = left,slow = left;\n        while(fast!=right&&fast.next!=right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        let root = new TreeNode(slow.val);\n        root.left = deep(left,slow);\n        root.right = deep(slow.next,right);\n\n        return root;\n    }\n    return deep(head,null);\n};\n```\n\n## 复杂度分析\n- 时间复杂度:O(logn);\n- 空间复杂度:O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998415095","body":"```js\nvar getIntersectionNode = function(headA, headB) {\n    if(!headA||!headB) return null;\n    let nodeA = headA,nodeB = headB;\n    while(nodeA!=nodeB){\n        nodeA = nodeA === null ? headB : nodeA.next;\n        nodeB = nodeB === null ? headA : nodeB.next;\n    }\n    return nodeA;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999227436","body":"## 思路 \n快慢指针\n## 代码\n```js\nvar detectCycle = function(head) {\n    if(!head||!head.next) return null;\n    let fast = head,slow = head;\n    do{\n        if(fast!=null&&fast.next!=null){\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        slow = slow.next;\n    }while(fast!=slow)\n    if(fast==null)return null;\n    fast = head;\n    while(fast!=slow){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n##  复杂度分析\n- 时间复杂度:O(n)\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000010810","body":"```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)){\n        const value = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key,value);\n        return value;\n    }\n    return -1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.map.has(key)){\n        this.map.delete(key);\n        this.map.set(key,value);\n    } else {\n        if(this.capacity<=this.map.size){\n            this.map.delete(this.map.keys().next().value);\n        }\n        this.map.set(key,value);\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000607050","body":"## 思路\n递归计算\n## 代码\n```js\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    if(!root.left&&!root.right) return 1;\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n};\n```\n## 复杂度分析\n- 时间复杂度:O(n)\n- 空间复杂度:O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000997204","body":"```js\nvar isSameTree = function(p, q) {\n    if(p==null&&q==null) return true;\n    if(p==null||q==null) return false;\n\n    return p.val==q.val&&isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"learning-go123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a244629128":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997406571","body":"```javascript\nvar swapPairs = function(head) {\n   if(!head || !head.next){\n       return head;\n   }\n    let node1 = head , node2 = head.next, node3 = node2.next;\n    node2.next = node1;\n    node1.next = swapPairs(node3);\n    return node2;\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001100017","body":"```javascript\nvar sumNumbers = function(root) {\n   var traverse = function(root,prevSum){\n       if(!root){\n           return 0;\n       }\n       var currSum = prevSum*10 + root.val;\n        if(!root.left && !root.right){\n           return currSum;\n       }\n       return traverse(root.left,currSum) +  traverse(root.right,currSum) \n\n   }\n   return traverse(root,0);\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhousibao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunupdong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"machuangmr":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991903092","body":"### 代码\r\n```java\r\nclass Solution {\r\n    // 思路： 1、将数组的最后一个元素和k的个位开始相加，\r\n    //       2、大于10 就向前进一位（k的前一位 + 1）\r\n     //        3、 重复以上步骤直到数组和k的位数结束\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n     List<Integer> rest = new LinkedList<>();\r\n    int len = num.length - 1;\r\n    for(int i = len;i >= 0;i--) {\r\n        int total = num[i] + k % 10;\r\n        //取 除过后一位的前面的值\r\n        k /= 10;\r\n        if(total >= 10) {\r\n            //大于10，则前面的值需要进1\r\n            k++;\r\n            total = total % 10;\r\n        }\r\n        rest.add(total);\r\n    }\r\n    while(k > 0) {\r\n        rest.add(k % 10);\r\n        k /=10;\r\n    }\r\n     Collections.reverse(rest);\r\n     return rest;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992533315","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n    int[] arr = new int[s.length()];\r\n    // 从左到右遍历，则每个s[i]的值为， 当前下标减去上个元素C的下标\r\n     int pre = Integer.MIN_VALUE / 2;\r\n     for(int i = 0;i < arr.length;i++) {\r\n         if(s.charAt(i) == c) {\r\n             pre = i;\r\n         }\r\n         arr [i] = i - pre;\r\n     }\r\n\r\n     // 从右边向右边遍历，则\bs[i]的值就等于 pre - i ;\r\n      pre = Integer.MAX_VALUE;\r\n     for(int i = s.length() -1;i >=0;i--){\r\n         if(s.charAt(i) == c) {\r\n             pre = i;\r\n         }\r\n        arr[i] = Math.min(arr[i], pre - i);\r\n     }\r\n        return arr;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993340372","body":"### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] arr = null;\r\n    int currentSize = -1;\r\n    int maxSize = 0;\r\n    public CustomStack(int maxSize) {\r\n     arr = new int[maxSize];\r\n     this.maxSize = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n     if(currentSize == maxSize - 1){\r\n         return ;\r\n     }\r\n     arr[++currentSize] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(currentSize == -1) {\r\n            return -1;\r\n        }\r\n      return arr[currentSize--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n       int size = currentSize < k - 1 ? currentSize : k -1;\r\n       for(int i = 0;i <= size;i++) {\r\n           arr[i] +=val;\r\n       }\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度，push，pop O(1) ,incre: O(N)\r\n- 空间复杂度  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994581368","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n    // 利用一个栈来存储字符\r\n    Stack<String> stack = new Stack();\r\n    for(int i = 0;i < s.length();i++) {\r\n        if(Character.isDigit(s.charAt(i)) || '[' == s.charAt(i)\r\n            || Character.isLowerCase(s.charAt(i))) {\r\n            stack.push(String.valueOf(s.charAt(i)));\r\n            continue;\r\n        }\r\n        if(']' == s.charAt(i)) {\r\n           List<String> c = new ArrayList<>();\r\n           while(!stack.isEmpty() &&!stack.peek().equals(\"[\")) {\r\n               c.add(stack.pop());\r\n           }\r\n           stack.pop();\r\n           Collections.reverse(c);\r\n           // 求[ 的数字\r\n           List<String> digit = new ArrayList();\r\n           while(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) {\r\n               digit.add(stack.pop());\r\n           }\r\n           Collections.reverse(digit);\r\n            // 内嵌括号中的字符串\r\n           String used = getUsdString(c);\r\n           // 内嵌括号中前面的数字\r\n           int value = Integer.parseInt(getUsdString(digit));\r\n           StringBuilder sb = new StringBuilder();\r\n           while(value-- > 0) {\r\n             sb.append(used);\r\n           }\r\n           stack.push(sb.toString());\r\n        }\r\n     }\r\n     List<String> res = new ArrayList<>();\r\n     while(!stack.isEmpty()) {\r\n         res.add(stack.pop());\r\n     }\r\n     Collections.reverse(res);\r\n     return getUsdString(res);\r\n    }\r\n\r\n    public String getUsdString(List<String> param) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for(String str: param) {\r\n            sb.append(str);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995688768","body":"### 代码\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = null;\r\n    Stack<Integer> s2 = null;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack();\r\n        s2 = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n         s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n          if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996702250","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n         Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.peek()) {\r\n                int current = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(current);\r\n            } else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997214766","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n     if(head == null) return null;\r\n     int length = 1;\r\n     ListNode temp = head;\r\n     while(temp.next != null) {\r\n         length++;\r\n         temp = temp.next;\r\n     }\r\n     int count = length - (k % length);\r\n     if(count == length) {\r\n       return head;\r\n     }\r\n     temp.next = head;\r\n     while(count > 0) {\r\n          temp = temp.next;\r\n          count--;\r\n     }\r\n     ListNode res = temp.next;\r\n     temp.next = null;\r\n     return res;\r\n    }\r\n}\r\n````\r\n### 复杂度 \r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997396701","body":"### 代码\r\n```java\r\nclass Solution {\r\n    // 递归\r\n    public ListNode swapPairs(ListNode head) {\r\n        // 递归终止条件，head == null 或者head.next == null\r\n        if(head == null || head. next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997896823","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head != null) {\r\n  // 递归思路：\r\n        ListNode fastPoint = head;\r\n        ListNode slowPoint = head;\r\n        ListNode pre = null;\r\n        while(fastPoint != null && fastPoint.next != null) {\r\n            // if(fastPoint.next == null || fastPoint.next.next == null) {\r\n            //     break;\r\n            // }\r\n            pre = slowPoint;\r\n            fastPoint = fastPoint.next.next;\r\n            slowPoint = slowPoint.next;\r\n        }\r\n        TreeNode treeNode = new TreeNode(slowPoint.val);\r\n        treeNode.right = sortedListToBST(slowPoint.next);\r\n        if(pre != null) {\r\n            pre.next = null;\r\n            treeNode.left = sortedListToBST(head);\r\n        }\r\n       \r\n        return treeNode;\r\n    }\r\n        return null;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(nlogn)\r\n- 空间复杂度O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998775920","body":"### 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        // 利用hash表，若两个链表有相交的点，则证明有相同的点\r\n        if(headA == null || headB == null) return null;\r\n        Set<ListNode> nodeSet = new HashSet<>();\r\n        ListNode tempA = headA;\r\n        while(tempA != null) {\r\n            nodeSet.add(tempA);\r\n            tempA = tempA.next;\r\n        }\r\n        ListNode tempB = headB;\r\n        while(tempB != null) {\r\n            if(nodeSet.contains(tempB)) {\r\n                return tempB;\r\n            }\r\n            tempB = tempB.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999589836","body":"### 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        // 利用快慢指针 推导公式见官方题解\r\n        if(head == null) return null;\r\n        ListNode fast = head, slow = head;\r\n        while(fast != null) {\r\n            slow = slow.next;\r\n            if(fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n            if(fast == slow) {\r\n                // 当在环内相交的时候，给定一个新的指针从头结点开始，\r\n                // 直到两个节点相同的的时候，就是入环的点\r\n                ListNode temp = head;\r\n                while(temp != slow){\r\n                    temp = temp.next;\r\n                    slow = slow.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000202842","body":"###  代码\r\n```java\r\n // 偷懒使用java中的LinkedHashMap\r\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\r\n\r\n    private int capacity;\r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n    @Override\r\n    public boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000714459","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n     // bfs广度优先搜索\r\n     Queue<TreeNode> queue = new LinkedList<>();\r\n     queue.add(root);\r\n     int ans = 0;\r\n     while(!queue.isEmpty()) {\r\n        int size = queue.size();\r\n        while(size > 0) {\r\n        TreeNode node = queue.poll();\r\n        if(node.left != null) {\r\n            queue.add(node.left);\r\n        }\r\n        if(node.right != null) {\r\n            queue.add(node.right);\r\n        }\r\n        size--;\r\n    }\r\n       \r\n        ans++;\r\n     }\r\n     return ans;\r\n     }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001036432","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n      \r\n        if(q == null && p == null) {\r\n            return true;\r\n        }\r\n        if(q == null || p == null) {\r\n            return false;\r\n        }\r\n          if(p.val != q.val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);   \r\n    }\r\n}\r\n````\r\n###  复杂度\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wang-hejie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991853617","body":"### 思路\n逐位相加，如果大于9，就要进位\n\n### 代码\n```js\nvar addToArrayForm = function(num, k) {\n    k = String(k).split('')\n    var length = Math.max(num.length, k.length)\n    var res = new Array(length).fill(0)\n    for (let index = length-1; index >= 0; index--) {\n        var a = num.length > 0 ? num.pop() : 0\n        var b  = k.length > 0 ?  k.pop() : 0\n        var sum = res[index] + a + +b\n        res[index] = sum % 10\n        if (sum > 9) {\n            if (index-1 >= 0) {\n                res[index - 1] = 1\n            } else {\n                res.unshift(1)\n            }\n        }\n    }\n    return res\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992074069","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n遍历s每个值，如果当前值正好是c，则跳过。否则，从当前值向左、右分别遍历，直到遇到c，再计算左右的最短距离。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let res = new Array(s.length).fill(0)\n\n    for(let i = 0; i<s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n            continue\n        }\n        let l = i - 1\n        let r = i + 1\n        let disL = Infinity\n        let disR = Infinity\n        while(l >= 0) {\n            if (s[l] === c) {\n                disL = Math.abs(i - l)\n                break\n            } else {\n                l--\n            }\n        }\n        while(r < s.length) {\n            if (s[r] === c) {\n                disR = Math.abs(i - r)\n                break\n            } else {\n                r++\n            }\n        }\n        res[i] = Math.min(disL, disR)\n    }\n\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n\n\n## 思路2\n\n先用数组存下所有c出现过的下标，再次遍历s，计算当前值和每个c出现过下标的距离，求出最小值\n\n## 关键点\n\n再次遍历s，计算最小距离时，因为indexArr存的是c出现过的下标，是递增，所以可以做一次剪枝\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let res = new Array(s.length).fill(0)\n    let indexArr = []\n\n    for(let i = 0; i<s.length; i++) {\n        if (s[i] === c) {\n            indexArr.push(i)\n        }\n    }\n\n    for(let i = 0; i<s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n            continue\n        }\n        let dist = Infinity\n        for(let j = 0; j< indexArr.length; j++) {\n            if (Math.abs(indexArr[j] - i) >= dist) {\n                break\n            }\n           dist = Math.abs(indexArr[j] - i)\n        }\n        res[i] = dist\n    }\n\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。k 为c在s出现过的次数。\n\n- 时间复杂度：$O(n*k)$\n- 空间复杂度：$O(k)$\n\n\n## 思路3\n\n第一次遍历，让s存下当前索引i左侧离着最近的c的坐标。只需要判断看i-1是否有值即可。\n\n第二次遍历，从右至左，判断当前索引i， res的左侧是否有c，或者 左侧到c的距离是否比右侧(i+1)的距离小，如果没有，则更新当前i 的值，更新成右侧的值\n\n第三次遍历，计算当前每个值和索引的距离\n\n## 关键点\n\n可以让res直接存当前距离，而不是索引来减少最后计算距离的遍历。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function (s, c) {\n    var res = Array(s.length);\n    \n    for(let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = i\n        } else [\n            res[i] = res[i-1] == void 0 ? Infinity : res[i-1]\n        ]\n    }\n\n    for(let i = s.length -1; i >= 0; i--) {\n        if (res[i] == Infinity || i - res[i] > res[i+1] - i) {\n            res[i] = res[i+1]\n        }\n    }\n\n    for (let i = 0; i < res.length; i++) {\n        res[i] = Math.abs(i -res[i])\n    }\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(3n)$\n- 空间复杂度：$O(n)$\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function (s, c) {\n    var res = Array(s.length);\n    \n    for(let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n        } else [\n            res[i] = res[i-1] == void 0 ? Infinity : res[i-1] + 1\n        ]\n    }\n\n    for(let i = s.length -1; i >= 0; i--) {\n        if (res[i] == Infinity || res[i] > res[i+1] + 1) {\n            res[i] = res[i+1] + 1\n        }\n    }\n\n    return res\n  };\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(2n)$\n- 空间复杂度：$O(n)$\n\n\n## 思路4\n\n定义l和r，分别表示当前窗口左侧c的下标和右侧的下标。只需要计算在窗户内元素到两个边界的距离即可。如果遍历到达右侧边界时，将整个窗口向后移。\n\n## 关键点\n\nindexOf的第二个参数表示从第几个开始查询，第二个参数传为当前左侧边框下标，即可\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function (s, c) {\n    let res = Array(s.length)\n    let l = s[0] === c ? 0 : -Infinity\n    let r = s.indexOf(c, 0)\n\n    for(let i = 0; i < s.length; i++) {\n        res[i] = Math.min(Math.abs(i-l), Math.abs(i-r))\n        if (i === r) {\n            l = r\n            r = s.indexOf(c, l+1)\n        }\n    }\n\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993129731","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n用数组模拟栈\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.val = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.val.length < this.maxSize) {\n        this.val.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.val.length === 0) {\n        return -1\n    }\n    return this.val.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(var i =0; i< k;i++) {\n        if (i < this.val.length) {\n            this.val[i] = this.val[i] + val\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n\n\n## 思路\n\n用increments来存所有的increment操作，increment[i]表示前i个值都加increment[i]值\n\n在pop的时候，只需要把栈顶值取出，加increment[i]。在更新维护increment[i-1]，将increment[i-1] 变成 increment[i] + increment[i-1]。然后重置increment[i]为0即可\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n    this.increments = Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.list.length === 0) return -1\n    let i = this.list.length - 1\n    this.increments[i-1] += this.increments[i]\n    let res = this.list.pop() + this.increments[i]\n    this.increments[i] = 0\n    return res\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let i = Math.min(k, this.list.length) -1\n    if (i >= 0) {\n        this.increments[i] += val\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994250486","body":"## 思路\n\n利用栈存下非`]`字符, 遇到`]`时，进行取栈。取栈时，注意栈顶的值是字符串、数字、还是`[`。如果是字符串，则继续拼接需要重复的字符串。如果是数字，则继续拼接需要重复的次数。因为`[`和`]`是成对存在的，所以在判断是否是数字，只需要判断不是`[`即可。\n\n## 关键点\n\n在组装完重复的字数后，一定要在取一次栈顶，因为此时的栈顶是`[`。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    for (const c of s) {\n        if (c == ']') {\n           let repeacStr = ''\n           let repeacNum = ''\n           while(stack.length && stack[stack.length -1] !== '[') {\n               repeacStr = stack.pop() + repeacStr\n           }\n           stack.pop()\n           while(stack.length && !isNaN(stack[stack.length -1])) {\n                repeacNum = stack.pop() + repeacNum\n            }\n            stack.push(repeacStr.repeat(Number(repeacNum)))\n        } else {\n            stack.push(c)\n        }\n    }\n    return stack.join('')\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n## 思路2\n\n每遇到`[]`，就递归`[]`内部的字符串，重复组装好后返回。递归体是，遇到`[`进入递归，遇到`]`结束递归。遇到数字和字符串，还是继续拼接。\n\n## 关键点\n\n- \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    function dfs (start) {\n        let repeatStr = ''\n        let repeatNum = ''\n        while(start < s.length) {\n            if (!isNaN(s[start])) {\n                repeatNum = repeatNum + s[start]\n            } else if (s[start] === '[') {\n                let [dfs_start, dfs_str] = dfs(start+1)\n                start = dfs_start\n                repeatStr = repeatStr + dfs_str.repeat(Number(repeatNum))\n                repeatNum = ''\n            } else if (s[start] === ']') {\n                return [start, repeatStr]\n            } else {\n                repeatStr = repeatStr + s[start]\n            }\n            start++\n        }\n        return repeatStr\n    }\n    return dfs(0)\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995381069","body":"## 思路\n\n用栈实现队列，需要将栈整体倒序，借助于另外一个栈B. A.pop -> B.push 即可实现。每次push时，需要先将栈A复原再push，push完后再做倒序操作\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/*\n * @lc app=leetcode.cn id=232 lang=javascript\n *\n * [232] 用栈实现队列\n */\n\n// @lc code=start\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.list = []\n    this.helpstack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.list.length) {\n        this.helpstack.push(this.list.pop())\n    }\n    this.helpstack.push(x)\n    while(this.helpstack.length) {\n        this.list.push(this.helpstack.pop())\n    }\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n   return  this.list.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.list[this.list.length-1]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.list.length === 0\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996470341","body":"## 思路\n\n用栈存下可以划块的最大值，如果下个值比栈顶的值要大，则直接入栈。如果小于栈顶的值，说明当前的值不能单独划块，需要和栈顶的值放到同一个块中。同时也需要继续遍历栈中的元素，因为只有前面分的块最大值要小于当前值，才能保证分块正确。不然该块应该也被划分到栈顶的块中\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let stack = []\n    for (let i = 0; i < arr.length; i++) {\n       let cur = arr[i]\n       if (stack.length && stack[stack.length - 1] > cur) {\n         let top = stack[stack.length - 1]\n         while(stack.length && stack[stack.length - 1] > cur) {\n            stack.pop()\n         }\n         stack.push(top)\n       } else {\n           stack.push(cur)\n       }\n    }\n    return stack.length\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997533133","body":"## 思路\n\n通过快慢节点，可以找到链表的中间节点。中间节点是当前树的根节点，再分别求出左节点和右节点即可。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null\n    return dfs(head, null)\n};\n\nfunction dfs (head, tail) {\n    if (head === tail) return null\n    let fast = head\n    let slow = head\n    while(fast != tail && fast.next != tail) {\n        fast = fast.next.next\n        slow = slow.next\n    }\n    let res = new TreeNode(slow.val)\n    res.left = dfs(head, slow)\n    res.right = dfs(slow.next, tail)\n    return res\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998417454","body":"## 思路\n\n两个链表相同速度向后移动，如果某一条到了尾端，继续移动一步，再下次移动时重新指向另外一条的顶部。两次遍历后，两遍的移动距离相同，都是A+B+1。如果两条链表有相交，则必然再中间某次会相遇。如果没有相交，则两次遍历结束后都同时指向了null\n\n## 关键点\n\n遍历到尾端，不立马指向另外一条链表的顶部，这样可以避免死循环和判断是否已经遍历过尾端。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let A = headA, B = headB\n    while (A != B) {\n        A = A == null ? headB : A.next\n        B = B == null ? headA : B.next\n    }\n    return A \n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n## 思路2\n\n遍历其中一条链表，并用哈希表存在改值。再遍历另外一条链表，判断哈希表中是否有该值\n\n## 关键点\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let map = new Set()\n    while(headA != null) {\n        map.add(headA)\n        headA = headA.next\n    }\n    while(headB != null) {\n        if (map.has(headB)) {\n            return headB\n        }\n        headB = headB.next\n    }\n    return null\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999240661","body":"## 思路\n\n定义快慢指针，快指针的速度是慢指针的两倍。如果他们第一次相遇时，将快指针放到链表的头部，再次相遇的时候，就是环的入口。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (head == null || head.next == null) return null;\n    let fast = (slow = head);\n    do {\n        if (fast != null && fast.next != null) {\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        slow = slow.next;\n    } while (fast != slow);\n    if (fast == null) return null;\n    fast = head;\n    while (fast != slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000058530","body":"## 思路\n\n时间负责度为1，最先想到的应该是链表。双向链表来实现 remove操作。可以利用hashmap来存储每个节点，从而快速访问到每个值。每次get或put时，都将该节点删除后，添加到head。保持链表的尾部是最旧的。\n\n## 关键点\n\n建立虚拟头节点和虚拟尾节点，从而可以快速访问到链表的头、尾节点。 \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} capacity\n */\nclass DoubleLinkedListNode{\n    constructor (key, value){\n        this.key = key\n        this.value = value\n        this.next = null\n        this.pre = null\n    }\n}\n\n\nvar LRUCache = function(capacity) {\n    this.size = capacity\n    this.map = {}\n    this.head = new DoubleLinkedListNode(null, null)\n    this.tail = new DoubleLinkedListNode(null, null)\n    this.head.next =this.tail\n    this.tail.pre = this.head\n    this.usedSpace = 0\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map[key]) {\n        let node = this.map[key]\n        this.remove(node)\n        this.addHead(node)\n        return node.value\n    }\n    return -1\n};\nLRUCache.prototype.addHead = function(node) {\n    this.map[node.key] = node\n    let cur = this.head.next\n    this.head.next = node\n    node.pre = this.head\n    cur.pre = node\n    node.next = cur\n};\nLRUCache.prototype.remove = function(node) {\n    let pre = node.pre\n    let next = node.next\n    pre.next = next\n    next.pre = pre\n    node.next = null\n    node.pre = null\n    delete this.map[node.key]\n};\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map[key]) {\n        let node = this.map[key]\n        node.value = value\n        this.remove(node)\n        this.addHead(node)\n        this.usedSpace++\n    } else {\n        if (this.usedSpace === this.size) {\n            this.remove(this.tail.pre)\n            this.usedSpace--\n        }\n        let node = new DoubleLinkedListNode(key, value)\n        this.addHead(node)\n    }\n};\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000606365","body":"## 思路\n\n递归计算左右枝的最大高度+1，就是当前节点的高度。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (root === null) {\n        return 0\n    } else {\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\n    }\n    \n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(h)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningli12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993117832","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.s = []\r\n        self.ms = maxSize\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.s)==self.ms:\r\n            pass\r\n        else:\r\n            self.s.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.s:\r\n            return -1\r\n        temp = self.s.pop()\r\n        return temp\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k >= len(self.s):\r\n            self.s = [i+val for i in self.s]\r\n        else:\r\n            for i in range(0,k):\r\n                self.s[i] += val       \r\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994138418","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        curs = ''\r\n        curn = 0\r\n        for i in s:\r\n            if i=='[':\r\n                stack.append((curs,curn))\r\n                curs = ''\r\n                curn = 0                \r\n            elif i.isdigit():\r\n                curn = curn*10+int(i)\r\n            elif i == ']':\r\n                cs,cn = stack.pop()\r\n                curs = cs+cn*curs\r\n            else:\r\n                curs += i\r\n        return curs\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996036489","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        lists = []\r\n        temp = []\r\n        for i in range(len(arr)-1):\r\n            temp.append(arr[i])\r\n            if max(temp) <= min(arr[i+1:]):\r\n                lists.append(temp)\r\n                temp = []\r\n            else:\r\n                pass\r\n        if len(lists) == 0:\r\n            return 1\r\n        else:\r\n            return len(lists)+1\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996926254","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        cur = head\n        count = 0\n        if head == None:\n            return None\n        while cur:\n            count += 1\n            \n            if cur.next == None:\n                cur.next = head\n                break\n            cur = cur.next\n        \n        pos = k% count \n        print(pos)\n        breakpoint = count - pos\n        if breakpoint == 0:\n            return head\n        else:\n            ans = cur\n            cur = cur.next \n            for i in range(breakpoint-1):\n                cur = cur.next \n            nextn = cur.next\n            cur.next = None\n            return nextn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997328501","body":"class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        cur = head\n        temp = a = ListNode(0)\n        temp.next = cur\n        while temp.next and temp.next.next:\n            cur = temp.next\n            b = cur.next\n            cur.next = b.next\n            b.next = cur\n            temp.next = b\n            temp = cur\n        return a.next\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997469725","body":"    def sortedListToBST4(self, head: ListNode) -> TreeNode:\n        p = head\n        arr = []\n        while p:\n            arr.append(p.val)\n            p = p.next\n\n        def merge(arr):\n            if len(arr) == 0:\n                return None\n            mid = len(arr) // 2\n            root = TreeNode(arr[mid])\n            root.left = merge(arr[:mid])\n            root.right = merge(arr[mid + 1:])\n            return root\n\n        return merge(arr)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998939880","body":"class Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                fast = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        return None","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000414957","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000913557","body":"class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p and q:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) and p.val == q.val\n        else: \n            return p == q\n        ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"siyuelee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doveshnnqkl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834328","body":"# Understand:\r\n```\r\n1. num array won't be empty, no leading 0's, each digit is valid [0,9]\r\n2. k is non-negative, 1 <= k <= 10^4\r\n3. output most significant -> least significant\r\n4. k can have more digits\r\n\r\ncarry,\r\n99 + 1 -> 100\r\n98 + 1 -> 99\r\n789 + 12 -> 801\r\n1 + 99 -> 100\r\n```\r\n# Plan:\r\n```\r\ngo backward from the least significant digit, record carry and current sum digit, update k\r\n\r\ncheck k > 0\r\n\r\ncheck if carry == 1\r\n\r\nuse a linkedlist and insert into the head\r\n```\r\n# Evaluate:\r\n```\r\nTime: O(number of digits inside num + number of digits inside k) \r\n= O(nums.length + number of digits inside k) = O(max(nums.length, logk))\r\n\r\nSpace: O(max(nums.length, number of digits inside k) = O(max(nums.length, logk))\r\n\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int carry = 0, newDigit = 0;\r\n        for (int pos = num.length - 1; pos >= 0; pos--) {\r\n            newDigit = num[pos] + k % 10 + carry;\r\n            carry = newDigit / 10;\r\n            newDigit %= 10;\r\n            sum.addFirst(newDigit);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            newDigit = k % 10 + carry;\r\n            carry = newDigit / 10;\r\n            newDigit %= 10;\r\n            sum.addFirst(newDigit);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) {\r\n            sum.addFirst(1);\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992584131","body":"\n# Understand:\n```\nIt is guaranteed that c occurs at least once in s.\ns[i] and c are lowercase English letters.\n1 <= s.length <= 10^4\n```\n# Plan:\n```\n\"record array\" to record the closest c index on its left\nthen record the closest c index on its right -> we can overwrite the same array with min value\n\nnote: no match on its left/right corner case\n\nmatch is guaranteed to exist though, either on its left or right\n```\n# Review:\n```\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\n0.   1.  2. 3. 4  5  6. 7. 8. 9. 10 11\nl    o   v  e  l  e  e  t  c  o  d  e\n-1, -1, -1, 0, 1. 0. 0  1. 2  3. 4. 0   -> record, left to right\n3  , 2,  1 ,0, 1. 0. 0  1. 2  2. 1. 0\n\n\n\"aaba\"\n\"b\"\n```\n\n# Evaluate:\n```\nTime: O(s.length())\nSpace: O(s.length())\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] record = new int[s.length()];\n        int curIndex = 0, nearestL = -1, nearestR = -1;\n        for (curIndex = 0; curIndex < s.length(); curIndex++) {\n            if (s.charAt(curIndex) == c) {\n                record[curIndex] = 0; \n                nearestL = curIndex;\n            } else {\n                record[curIndex] = nearestL == -1 ? -1 : curIndex - nearestL;\n            }\n        }\n        /// go from right to left, overwrite the original record array\n        for (curIndex = s.length() - 1; curIndex >= 0; curIndex--) {\n            if (s.charAt(curIndex) == c) {\n                nearestR = curIndex;\n            } else {\n                if (record[curIndex] == -1) { // left is invalid, then right is guaranteed to be valid\n                    record[curIndex] = nearestR - curIndex;\n                } else {    \n                    // two cases here: is right valid? -> can we find a match on its right?\n                    if (nearestR != -1) {\n                        record[curIndex] = Math.min(record[curIndex], nearestR - curIndex);\n                    }\n                }\n            }\n        }\n        return record;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993685604","body":"```\nclass CustomStack {\n    int capacity;\n    int size;\n    List<Integer> stack;\n    List<Integer> inc;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new ArrayList<>();\n        inc = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack.add(x);  // stack: bottom -> top\n            inc.add(0);\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        \n        int ans = stack.get(size - 1) + inc.get(size - 1);\n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n        }\n        \n        // remove the tail of inc and stack lists\n        inc.remove(size - 1); // by index, O(1)\n        stack.remove(size - 1); // this line is needed in list implementation, as we use stack[size] = x; in array but use add(x) in list implementation\n        \n        size--;\n        \n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        // empty check\n        if (size > 0) {\n            inc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n        }\n    } \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994925628","body":"\n# Understand:\n```\n1 <= s.length <= 30\ns consists of lowercase English letters, digits, and square brackets '[]'.\ns is guaranteed to be a valid input.\nAll the integers in s are in the range [1, 300].\n\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n\nk is guaranteed to be a positive integer\n\nyou may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.\n```\n# Plan: \n```\n\n2 stacks, Stack<StringBuilder>, Stack<Integer> \n\nk can be greater than 10\n\nif we see digit, build the complete integer (curFreq * 10 + s.charAt(curIndex) - '0')\n\nif we see letter, build the complete string (by curStr.append(s.charAt(curIndex));)\n\nif we see [, push curStr and curFreq into respective stacks, reset\n\n*if we see ], \ncurStr is the string to repeat\npop the top string, append the repeated string after it, it becomes the curStr\n```\n\n# Review:\n```\nInput: s = \"a3[a2[c]]e\"\nOutput: \"aaccaccacce\"\n\n\nc\n\na   2\na   3\n\n\nacc\n\na  3\n\ncurStr: aaccaccacc\n\ncurStr: aaccaccacce\n```\n# Evaluate: \n```\nTime: O(decoded res length)\n\nSpace: O(decoded res length)\n```\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        if (s.length() == 1) return s;\n        Stack<Integer> freqStack = new Stack<>();\n        Stack<StringBuilder> strStack = new Stack<>();\n        \n        int curIndex = 0;\n        StringBuilder curStr = new StringBuilder();\n        int curFreq = 0;   \n        \n        while (curIndex < s.length()) {\n            if (Character.isLetter(s.charAt(curIndex))) {\n                curStr.append(s.charAt(curIndex));\n            }\n            else if (Character.isDigit(s.charAt(curIndex))) {\n                curFreq = curFreq * 10 + s.charAt(curIndex) - '0';\n            }\n            else if (s.charAt(curIndex) == '[') {\n                strStack.push(curStr);\n                curStr = new StringBuilder();\n                \n                freqStack.push(curFreq);\n                curFreq = 0;\n            } else if (s.charAt(curIndex) == ']') {  // this part needs caution\n                StringBuilder temp = curStr; // temp is the str to repeat\n                curStr = strStack.pop();\n                \n                StringBuilder resStr = new StringBuilder();\n                int freq = freqStack.pop();\n                \n                for (int i = 0; i < freq; i++) {\n                    curStr.append(temp);\n                }\n                \n            }\n            curIndex++;\n        }\n        return curStr.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995437678","body":"```\r\nAll the calls to pop and peek are valid.\r\n\r\nTwo stacks, push only from one stack, pop only from the other stack (feeding each other before each operation)\r\n\r\nTime: O(1) amortized\r\nSpace: O(n)\r\n```\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack;\r\n    Stack<Integer> popStack;\r\n    \r\n    public MyQueue() {\r\n        pushStack = new Stack<>();\r\n        popStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return pushStack.isEmpty() && popStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996833917","body":"# Plan:\nuse the max of the chunk as the representative and store them in the stack. check if current val can be merged with the existing chunks on the stack. \n\n# Review:\n```\n0 2 9 1 2\n    \n0 2 9 \n0 9\n0 9\n\n0 2 9 \n0 9 \n0 9\n```\n\n# Complexity:\n```\nTime: O(arr.length)\nbest case, insert once, no popping\n\nSpace: O(arr.length)\n```\n# Code:\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> chunks = new Stack<>();\n        \n        for (int i = 0; i < arr.length; i++) {\n            int representative = arr[i];\n            boolean flag = true;\n            while (!chunks.isEmpty() && chunks.peek() > arr[i]) {\n                if (flag) {\n                    representative = chunks.peek();\n                    flag = false;\n                }\n                chunks.pop();\n            }\n            chunks.push(representative);\n        }\n        return chunks.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997217223","body":"\r\n```\r\nk can be greater than the linkedlist len\r\nhow to do it through one-pass? -> still need to get len if k is huge\r\nfast forward k steps, slow start from head\r\n\r\n\r\n1-2-3-4\r\n\r\nk = 10\r\n\r\nk=10%4 = 2\r\n3-4-1-2\r\n\r\n\r\n1-2-3-4-5\r\nk = 1\r\n5-1-2-3-4\r\n\r\n1-2-3-4-5\r\nk = 3\r\n3-4-5-1-2\r\n\r\nnull\r\n[1,2,3], k = 0 / or can be divisible by the len\r\n\r\nTime: O(n), n = len of linkedlist\r\nSpace: O(1)\r\n```\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        \r\n        ListNode fast = head, slow = head;\r\n        k = k % getLen(head);\r\n        \r\n        if (k == 0) return head;\r\n        \r\n        for (int step = 0; step < k; step++) {\r\n            fast = fast.next;\r\n        }\r\n        while (fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        \r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n        return newHead;\r\n        \r\n    }\r\n    \r\n    // O(n) time\r\n    private int getLen(ListNode head) {\r\n        if (head == null) return 0;\r\n        int len = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            len++;\r\n            cur = cur.next;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414928","body":"\n```\nIdea: dummy head, first, second pointers\n\n1-2\nf s. n\n0-2-1-null\n    \n1-2-3\nf s n\n\n0-2-1-3\n    c f s \n    \nTime: O(n), n = len\nSpace: O(1), three pointers\n```\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) return head;\n        ListNode dummy = new ListNode(0, head);\n        ListNode first = head, second = first.next, cur = dummy;\n        \n        while (second != null) {\n            ListNode next = second.next;\n            cur.next = second;\n            second.next = first;\n            first.next = next;\n            \n            cur = first;\n            first = first.next;\n            if (first == null) break;\n            \n            second = first.next;\n            \n            \n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998019534","body":"# Plan:\n```\ntwo pointers to find the mid as the root, recursively build the tree\n```\n```\n1,2,3\n\n1，2，3，4\n\n      3\n1 2\n\n    2\n1\n\n4\n```\n```\nTime: \nT(1) = T(0) = 1\nT(n) = 2 * T(n/2) + O(n/2)\n     = 2 * [2 * T(n/4) + O(n/4)] + O(n/2)\n     = 4 * T(n/4) + O(n)\n     = 4 * [2 * T(n/8) + O(n/8)] + O(n)\n     = 8 * T(n/8) + 3 * O(n/2)\n     = x * T(n/x) + log x * O(n/2)\n\nn/x = 1, n = x\nT(n) = n * T(1) + logn * O(n) = n + nlogn = nlogn\n\nSpace: \ndepth O(height) = O(logn), n = len of list\n```\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val, null, null);\n        \n        ListNode fast = head, slow = new ListNode(0, head);\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        ListNode newRoot = slow.next;\n        ListNode leftHalf = head;\n        ListNode rightHalf = newRoot.next;\n        \n        slow.next = null;\n        newRoot.next = null;\n        \n        TreeNode root = new TreeNode(newRoot.val);\n        root.left = sortedListToBST(leftHalf);\n        root.right = sortedListToBST(rightHalf);\n        \n        return root;\n    }\n    \n   \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998479644","body":"```\n0\n[2,6,4]\n[1,5]\n3\n2\n\nnote the termination status!\n\nrestart from the other head if reaches null\n\nTime: O(lenA + lenB) \nSpace: O(1)\n```\n# Code\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode cur1 = headA, cur2 = headB;\n       \n        while (cur1 != cur2) {\n            cur1 = cur1 == null ? headB : cur1.next;\n            cur2 = cur2 == null ? headA : cur2.next;\n        }\n        return cur1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999677877","body":"\n\n```\nhttps://drive.google.com/file/d/16PsamYHASN4-wetKwn39zrNX00NivoZe/view\n\n1. start fast (2 steps/time) and slow (1 step/time) from dummy -> do not start from head\n2. when they meet (if not return null), restart fast from dummy, 1 step/time until they meet\n\nTime: O(len)\nSpace: O(1)\n```\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        \n        ListNode slow = dummy, fast = dummy; // cannot start from head, use dummy\n        \n        while (fast != null && fast.next != null) {  // note this line, cannot be slow != fast\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        \n        if (slow != fast) return null; // no circle\n       \n        // restart from dummy\n        fast = dummy;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000019493","body":"# Idea:\n```\ndummy head and tail\n\nMap<Integer, Node> keyNodeMap + Node head + Node tail\n\nNode: key, val, pre, next\n\nget: get from map, move the target to head of linkedlist\nput: does map contain the key? \n    - yes: rm the old node of the same key from list; create this new node of new val; update map\n    - no: check capacity, if no capacity, rm from tail and map, and inc capacity; else: add a new node to head, add to map, decrement capacity\n   \nTime:get put: O(1)\nSpace:O(n) if we have n entries\n```\n# Code:\n```java\nclass LRUCache {\n    \n    class Node {\n        int key;\n        int val;\n        Node pre;\n        Node next;\n\n        Node(int key, int val, Node pre, Node next) {\n            this.key = key;\n            this.val = val;\n            this.pre = pre;\n            this.next = next;\n        }\n    }\n    \n    int capacity;\n    Map<Integer, Node> keyNodeMap; // key-node \n    Node head;\n    Node tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        keyNodeMap = new HashMap<>();\n        head = new Node(-1, -1, null, null);\n        tail = new Node(-1, -1, null, null);\n        connect(head, tail);\n    }\n    \n    private void connect(Node n1, Node n2) {\n        n1.next = n2;\n        n2.pre = n1;\n    }\n    \n    \n    public int get(int key) {\n        if (keyNodeMap.containsKey(key)) {\n            Node targetNode = keyNodeMap.get(key);\n            // move the node to the head\n            Node targetPre = targetNode.pre;\n            Node targetNext = targetNode.next;\n            connect(targetPre, targetNext);\n            \n            Node afterHead = head.next;\n            connect(head, targetNode);\n            connect(targetNode, afterHead);\n           \n            return targetNode.val;\n        } \n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        // first check if we have this key in map\n        if (keyNodeMap.containsKey(key)) {\n            // no need to change capacity\n            // rm current node of key from linkedlist\n            Node targetNode = keyNodeMap.get(key);\n            Node targetPre = targetNode.pre;\n            Node targetNext = targetNode.next;\n            connect(targetPre, targetNext);\n            \n            // create new node and add to head\n            Node afterHead = head.next;\n            Node newNode = new Node(key, value, null, null);\n            connect(head, newNode);\n            connect(newNode, afterHead);\n            // modify map\n            keyNodeMap.put(key, newNode);\n            \n        } else { // check capacity\n            if (capacity == 0) {\n                // 1. rm from tail and map\n                Node toRm = tail.pre;\n                Node newTail = toRm.pre;\n                connect(newTail, tail);\n                \n                keyNodeMap.remove(toRm.key);\n                // 2. inc capacity\n                capacity++;\n            }\n            Node newNode = new Node(key, value, null, null);\n            Node afterHead = head.next;\n            connect(head, newNode);\n            connect(newNode, afterHead);\n            keyNodeMap.put(key, newNode);\n            capacity--;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000654673","body":"\n```\nTime: O(n)\nSpace: O(height)\n```\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000974666","body":"\r\n```\r\npre-order, compare root first, empty check and then val check, recursively compare the subtrees\r\n\r\nTime: O(n). n=number of nodes\r\nSpace: O(height)\r\n```\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001099426","body":"```\r\n\r\n      1\r\n   /.     \\\r\n  2.       3\r\n   \r\n\r\n      1\r\n   /.     \\\r\n 2.       3\r\n       /.     \\ \r\n       2.     0\r\n\r\nidea: pre-order traversal, leaf (both children null) then update the sum, otherwise, traverse the children and update curSum during recursion\r\n\r\nTime: O(n), n = number of nodes\r\nSpace: O(height)\r\n```\r\n```java\r\n\r\n/*\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        int[] sum = new int[1];\r\n        sumUp(root, 0, sum);\r\n        return sum[0];\r\n    }\r\n    \r\n    private void sumUp(TreeNode cur, int curSum, int[] sum) {\r\n        if (cur == null) return;\r\n        if (cur.left == null && cur.right == null) {\r\n            curSum = curSum * 10 + cur.val;\r\n            sum[0] += curSum;\r\n            return;\r\n        }\r\n        sumUp(cur.left, curSum * 10 + cur.val, sum);\r\n        sumUp(cur.right, curSum * 10 + cur.val, sum);\r\n    }\r\n    \r\n    \r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"septasset":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennyxcao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muimi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallili":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"benngfour":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ergwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mixtureve":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leolisgit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuliangyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chun1hao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m-z-w":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinmenghan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy030988":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarryPangPang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheUsername":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwpanda":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992086263","body":"``` JavaScrpit\nconst shortestToChar = (s, c)=>{\n  s=s.split('');\n  let res = [];\n  //loop through the string array\n  for (let i=0; i<s.length; i++) {\n    let dist = Infinity;\n    if(s[i] === c) {\n      res.push(0);\n      continue;\n    }\n    \n    //nested loop to find the closest index\n    //counting forward from current i \n    for(let j=i; j<s.length; j++) {\n      if(s[j] === c) {\n        dist = j-i;\n        break;\n      }\n    }\n    //counting backward from current i\n    for(let j=i; j>=0; j--) {\n      if(s[j] === c) {\n        dist = Math.min(dist, i-j);\n        break;\n      }\n    }\n    res.push(dist);\n  }//end loop string array\n  return res;\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997268144","body":"```JavaScript\nvar swapPairs = function(head) {\n    \n  let temp = new ListNode(0, null); // maintaining a temporary reference to sync with head\n  temp.next = head;\n  let current = temp;\n  \n  while (current.next && current.next.next) {\n      let first_node = current.next;\n      let second_node = current.next.next;\n      \n      // swap the nodes using the current\n      first_node.next = second_node.next;\n      current.next = second_node;\n      current.next.next = first_node;\n      current = current.next.next;\n  }\n  return temp.next; // return the head using the same temporary reference\n  \n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fengchen321":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hewenyi666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flame0409":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowenhe":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991843707","body":"```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size() - 1;\n        int cur = k;\n        vector<int> result;\n        while(n >= 0 || cur)\n        {\n            if(n>=0)\n            {\n                cur = cur + num[n];\n            }\n            result.push_back(cur%10);\n            cur = cur / 10;\n            n--;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992234694","body":"##思路\r\n左右两边分别遍历，求最小距离\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        results = []\r\n        pos = float('-inf')\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                pos = i\r\n            results.append(i - pos)\r\n        pos = float('inf')\r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i] == C:\r\n                pos = i\r\n            results[i] = min(results[i],(pos - i))\r\n        return results\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993365730","body":"```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        a = self.stack[-1]\r\n        self.stack = self.stack[:-1]\r\n        return a\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(k ,len(self.stack))\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994694504","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n\r\n        stack = []\r\n        for char in s:\r\n            if char != \"]\":\r\n                stack.append(char)\r\n            else:\r\n                sub_str = \"\"\r\n                while(1):\r\n                    ss = stack.pop()\r\n                    if ss != \"[\":\r\n                        sub_str = ss + sub_str\r\n                    else:\r\n                        break\r\n                int_value = ''\r\n                while(1):\r\n                    if len(stack) > 0 and stack[-1] >= '0' and stack[-1] <= '9':\r\n                        int_value = stack.pop() + int_value\r\n                    else:\r\n                        int_value = int(int_value)\r\n                        break\r\n\r\n                sub_str = int_value * sub_str\r\n                stack.append(sub_str)\r\n\r\n        return (\"\").join(stack)\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996519474","body":"```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n\r\n        stack = []\r\n        for i in range(len(arr)):\r\n            if stack and stack[-1] > arr[i]:\r\n                cur_ = stack.pop()\r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop()\r\n                stack.append(cur_)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998575424","body":"```python3\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        a, b = headA, headB\r\n        while(a and b):\r\n            if a == b:\r\n                return a\r\n\r\n            if not a.next and not b.next:\r\n                return None\r\n            a = a.next if a.next else headB\r\n            b = b.next if b.next else headA\r\n        return None\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000707693","body":"```python3\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root is None:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mglslg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"max-qaq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sxr000511":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"july-aha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xyinghe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cy-sues":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991867656","body":"## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List <Integer> arr = new ArrayList <Integer>();\n        for(int i=num.length-1;i>=0;i--){\n            int p=k%10;\n            k=k/10;\n            int sum = num[i]+p;\n            if(sum>=10){\n                k+=1;\n                sum-=10;\n            }\n            arr.add(sum);\n        }\n        for(;k>0;k=k/10){\n            int s= k%10;\n            arr.add(s);\n        }\n        Collections.reverse(arr);\n        return arr;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994819648","body":"## 思路\r\n数字一个栈，字母一个栈\r\n## Code\r\n```java\r\npublic String decodeString(String s) {\r\n        \r\n        Stack<Character> stack = new Stack<>();\r\n        \r\n        for(char c : s.toCharArray())\r\n        {\r\n            if(c != ']') \r\n                stack.push(c); // 把所有的字母push进去，除了]\r\n            \r\n            else \r\n            {\r\n                //step 1: 取出[] 内的字符串\r\n                \r\n                StringBuilder sb = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\r\n                    sb.insert(0, stack.pop());\r\n                \r\n                String sub = sb.toString(); //[ ]内的字符串\r\n                stack.pop(); // 去除[\r\n                \r\n                \r\n                //step 2: 获取倍数数字\r\n                    \r\n                sb = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\r\n                    sb.insert(0, stack.pop());\r\n                    \r\n                int count = Integer.valueOf(sb.toString()); //倍数\r\n                \r\n                \r\n                //step 3: 根据倍数把字母再push回去\r\n                \r\n                while(count > 0)\r\n                {\r\n                    for(char ch : sub.toCharArray())  \r\n                        stack.push(ch);\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n        \r\n      //把栈里面所有的字母取出来，完事L('ω')┘三└('ω')｣\r\n        StringBuilder retv = new StringBuilder();\r\n        while(!stack.isEmpty())\r\n            retv.insert(0, stack.pop());\r\n\r\n        return retv.toString();\r\n    }\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998004779","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryzhao5":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mosihan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Brandylulu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivalkshfoeif":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ray-hr":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991898710","body":"# 思路 \n 1.列竖式法 \n\n2.低位到高位相加 \n \n3.考虑进位位  \n\n4.取反\n# 代码 \n```python  \n \nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        p1 = len(num) - 1\n        carry = 0\n        res = []\n        while p1 >= 0 or k != 0 or carry > 0:\n            adder1 = num[p1] if p1 >= 0 else 0\n            adder2 = k % 10\n            sum = adder1 + adder2 + carry\n            carry = 1 if sum >= 10 else 0\n            sum = sum - 10 if sum >= 10 else sum\n            res.append(sum)\n            p1 -= 1\n            k //= 10\n        return res[::-1]\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992337008","body":"# 思路 \n贪心 \n# 代码 \n```python \nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993676939","body":"# 思路 \nincrement并不提前造好maxSize长度，而是根当前栈长度同步增加长度，省一点空间 \n# 代码 \n```python \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n        self.incrementals = []\n        \n    def push(self, x: int) -> None:\n        if(self.size < self.maxSize):\n            self.stack.append(x)\n            self.incrementals.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if(self.size == 0):\n            return -1\n        self.size -= 1\n        if(self.size >= 1):\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.stack.pop() + self.incrementals.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.incrementals:\n            self.incrementals[min(k, self.size) - 1] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994717130","body":"# 思路 \n两个栈实现 \n# 代码 \n```python \nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字\n        num = 0\n        res = \"\"  # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995436141","body":"# 思路 \n一个输入栈一个输出栈 \n# 代码 \n```python \nclass MyQueue:\n\n    def __init__(self):\n\n       self.stack_in = []\n       self.stack_out = []\n\n    def push(self, x: int) -> None:\n\n        self.stack_in.append(x)\n\n    def pop(self) -> int:\n         if self.empty():\n            return None\n\n         if self.stack_out:\n             return self.stack_out.pop()\n         else:\n            for i in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n \n    def peek(self) -> int:\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return\n\n    def empty(self) -> bool:\n        return not (self.stack_in or self.stack_out)\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996397290","body":"# 思路 \n贪心算法。建立一个栈，存储每个块的最大值，栈的长度即为划分块的个数。 \n栈内元素通过比较栈顶head和数组内num进行更新：如果num>=head,将num元素push入栈，如果num<head则pop出head并存储，接着继续比较栈顶元素，直到num>=head,将之前贮存的head重新入栈。 \n# 代码 \n```python \nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997206351","body":"# 思路 \n思路及算法\n\n记给定链表的长度为 nn，注意到当向右移动的次数 k \\geq nk≥n 时，我们仅需要向右移动 k \\bmod nkmodn 次即可。因为每 nn 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k \\bmod n)(n−1)−(kmodn) 个节点（从 00 开始计数）。\n\n这样，我们可以先将给定的链表连接成环，然后将指定位置断开。\n\n具体代码中，我们首先计算出链表的长度 nn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n - 1) - (k \\bmod n)(n−1)−(kmodn) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。\n\n特别地，当链表长度不大于 11，或者 kk 为 nn 的倍数时，新链表将与原链表相同，我们无需进行任何处理。\n# 代码 \n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997319646","body":"# 思路\n可以通过递归的方式实现两两交换链表中的节点。\n\n递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\n\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\n\n用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead\n# 代码 \n```python \nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997914989","body":"# 代码 \n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999561605","body":"# 代码 \n```python\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000384624","body":"# 代码 \npython``` \nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nekomoon404":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen-ds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mokrs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niyaolanggeyo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asterqian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmstart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizzy-123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"20donkey":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992425638","body":"## **思路: 正反双指针**\n\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n### **代码**\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)):\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j-i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i-j)\n                    i -= 1\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n) n是s长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993489193","body":"## **思路1：用数组模拟**\n\n朴素的模拟方法\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = list()\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [n+val for n in self.stack]\n        else:\n            self.stack = [n+val for n in self.stack[:k]] + self.stack[k:]\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) push pop是O(1)，increment是O(n)\n- 空间复杂度：O(1)\n\n## **思路2：前缀和思想**\n\n用一个incrementals数组来记录加的数字最远加到哪里。在pop出去的时候只要对应找该位置加了多少即可，不需要全部都记录\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # 如果只剩一个元素，直接是pop出去\n        # 如果多于一个元素，pop出去的同时，更前面的元素要继承一下加的val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # 分界线的地方+val，只在pop的时候才考虑加多少\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxsize/n)  把n当作操作数的话，平均来看是maxsize/n？？？\n\n## **思路3：空间优化的前缀和**\n\nincrementals在操作的时候才更新而不是初始化的时候更新\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # 如果只剩一个元素，直接是pop出去\n        # 如果多于一个元素，pop出去的同时，更前面的元素要继承一下加的val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # 分界线的地方+val，只在pop的时候才考虑加多少\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(cnt/n)  把n当作操作数的话，平均是cnt/n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994737977","body":"## **思路：栈**\n\n碰到右括号的时候出栈，其他都是进栈，需要注意的是，数字可能是多位数\n\n### **代码**\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != \"]\":\n                if char.isdigit() and stack and stack[-1].isdigit():\n                    stack.append(stack.pop()+char)\n                else:\n                    stack.append(char)\n            else:\n                cur = \"\"\n                while stack and stack[-1] != \"[\":\n                    cur = stack.pop() + cur\n                if cur:\n                    stack.pop()\n                    stack.append(int(stack.pop()) * cur)\n        return \"\".join(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n)\n- 空间复杂度：O(n)用了一个cur作为中间变量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995924284","body":"## **思路：两个栈倒腾**\r\n\r\n之前写过O(n)的，以下是O(1)的思路\r\n\r\nO(n)也是两个栈互相倒，但是复杂度较高。两个栈stackin和stackout一个只用来进新的元素一个只用来出结果。用一个辅助的self.front变量，记录stackin最前面元素。\r\n\r\npop的时候，rather than倒进去又倒出来，可以在stackout空的时候才倒，不空的时候直接出栈顶即可。peak的时候，如果stackout非空的话，肯定就是栈顶元素，否则，就是self.front\r\n\r\n### **代码**\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stackin = []\r\n        self.stackout = []\r\n        self.front = None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.stackin:\r\n            self.front = x\r\n        self.stackin.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        if self.empty():\r\n            return \r\n        return self.stackout.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.stackout[-1] if self.stackout else self.front\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stackin and not self.stackout\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997641274","body":"### **思路：递归+双指针**\n\n把链表想象成一个绳子，每次操作是从中间把绳子拎起来。用递归的方式把问题缩小，每次找到中间的节点作为root，左边接链表的前半部分sort后的二叉搜索树，后面接链表后半部分sort后的二叉搜索树。其中中间节点用快慢指针找到。\n\n要注意的是，如果只有一个节点的话，也要退出递归的，因为这样left和listnode会一直是一样的，就出不来\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def balanced_tree(listnode):\n            if not listnode:\n                return None\n            # 如果节点只有一个的话，left就一直是listnode，退出不了递归\n            if not listnode.next:\n                return TreeNode(listnode.val)\n            # 找中点\n            prev = ListNode(-1)\n            prev.next = listnode\n            slow, fast = listnode, listnode\n            while fast and fast.next:\n                prev = prev.next\n                slow = slow.next\n                fast = fast.next.next\n            cur_head = TreeNode(slow.val)\n            prev.next = None\n            left, right = listnode, slow.next\n            # # 不加这个会有问题\n            # if fast == slow:\n            #     return cur_head\n            cur_head.left, cur_head.right = balanced_tree(left), balanced_tree(right)\n\n            return cur_head\n        return balanced_tree(head)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(nlogn) 递归复杂度可以画出递归栈。每一层递归的操作是，寻找链表中间节点，第一次是n，第二次是两块分别找，是n/2+n/2，第三次是4个n/4，每一次都是n，也就是说递归的时候，每次找中间节点用时n，一共有logn层，所以是n*logn\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998441988","body":"### **思路1：哈希**\n\n比较直接，遍历a全部放进哈希表，遍历b如果见到已经在哈希表中的则就是要找的节点，否则没有交点\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        if not a or not b:\n            return None\n        hash = {}\n        while a:\n            hash[a] = 1\n            a = a.next\n        while b:\n            if b in hash:\n                return b\n            else:\n                b = b.next\n        return None\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n### **思路2：双指针**\n\nheada交点前面长度是a，headb交点前面长度是b，相交的部分长度是c。那指针1走完a一整段再走b，指针b走完b一整段再走a，一定走的长度一样。如果两者不相交，在走完a+b+c之后也会在None处相等，所以循环的出口是指针1d的值==指针2的值\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA, headB):\n        a = headA\n        b = headB\n        while a != b:\n            if not a:\n                a = headB\n            else: \n                a = a.next\n            if not b:\n                b = headA\n            else:\n                b = b.next\n        return a\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        l1 = headA\n        l2 = headB\n        while l1 or l2:\n            if l1 == l2:\n                return l2\n            if l1:\n                l1 = l1.next\n            else:\n                l1 = headB\n            if l2:\n                l2 = l2.next\n            else:\n                l2 = headA\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaysonss":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maxsarratt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bxcharlie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zszs97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yj9676":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carreylife":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsyxiaoba":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ff1234-debug":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhsaga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heyqz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Clarence5":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aatoe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eemsyw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iciue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiayinya":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chaggle":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sqshada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingkong1994":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alwaysbest":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pzl233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangshisong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MusicOfWind":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuetong3yu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995792391","body":"- [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n用两个栈来模拟队列的操作。\n\n因为要用栈的特性来实现队列，因此不能直接操作数组的头节点。\n\n核心思路：**用一个额外的栈空间倒腾一下**。\n\n```js\nvar MyQueue = function () {\n  this.stack = []\n  this.reverseStack = []\n}\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x)\n}\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.reverseStack.length) {\n    this.move()\n  }\n  return this.reverseStack.pop()\n}\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.reverseStack.length) this.move()\n  return this.reverseStack[this.reverseStack.length - 1]\n}\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.stack.length && !this.reverseStack.length\n}\n\nMyQueue.prototype.move = function () {\n  while (this.stack.length) {\n    this.reverseStack.push(this.stack.pop())\n  }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996823049","body":"- [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/submissions/)\n\n这道题目理解比较难。\n\n但一个简单的解题思路是：_既然分组后的数组和排序后的切片数组是相等的，那无论这两个数组的顺序如何打乱，它们的和都一定是相等的。_\n\n根据这个思路，我们只要额外定义两个数进行遍历即可：\n\n```js\nvar maxChunksToSorted = function (arr) {\n  const sorted_arr = [...arr].sort((a, b) => a - b)\n\n  let ans = 0\n  let sum1 = 0\n  let sum2 = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum1 += arr[i]\n    sum2 += sorted_arr[i]\n\n    if (sum1 === sum2) ans += 1\n  }\n  return ans\n}\n```\n\n![](https://tva1.sinaimg.cn/large/008i3skNly1gxh9es9i8pj30wm0cywfm.jpg)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997199133","body":"- [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/submissions/)\n\n比较简单。\n\n因为要把每个节点向右移动 k 个节点，本质上来说也是要找到`倒数第 k 个节点。`\n\n利用前面做过的「倒数第 N 个节点」即可解决。\n\n画个图理解一下这个玩意儿：\n\nk = 2\n\nA -> B -> C -> D;\n\n_先找到 第倒数 k + 1 个节点_，在这里就是 B.\n\n将 B 指向空节点（因为要把它当作尾节点）。\n\n将之前遍历过的尾节点指向头节点。\n\n返回 _倒数第 k 个节点_。\n\n根据上面的思路，编码如下：\n\n```js\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || !k) return head\n  // 获取链表长度\n  let len = 1\n  let p = head\n  while (p.next) {\n    p = p.next\n    len += 1\n  }\n  // 找到倒数第 k + 1 个节点\n  let poi = k % len\n  if (!poi) return head\n  let fast = head\n  let slow = head\n  while (poi > 0) {\n    fast = fast.next\n    poi -= 1\n  }\n  while (fast.next) {\n    fast = fast.next\n    slow = slow.next\n  }\n  const temp = slow.next\n  slow.next = null\n  fast.next = head\n  return temp\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414558","body":"- [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n交换...\n\n```js\nvar swapPairs = function (head) {\n  const dummy = new ListNode()\n  dummy.next = head\n  let temp = dummy\n  while (temp.next && temp.next.next) {\n    const node1 = temp.next\n    const node2 = temp.next.next\n    temp.next = node2\n    node1.next = node2.next\n    node2.next = node1\n    temp = node1\n  }\n  return dummy.next\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997962477","body":"- [109. 有序链表转换平衡二叉树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/shou-hua-tu-jie-san-chong-jie-fa-jie-zhu-shu-zu-ku/)\n\n本题我会写下三种解法，思路都不难，但我在分析时间/空间复杂度的时候卡壳了，说明基本功还是不过关，需要多做训练。\n\n### 基本递归解法\n\n> 以中间节点为 root，左右递归。\n\n```js\nfunction sortedListToBST(head) {\n  // construct a arr by sorted list\n  const arr = []\n  while (head) {\n    arr.push(head.val)\n    head = head.next\n  }\n  // now we got the sorted array.\n  // construct the BST by array.\n  function buildBST(start, end) {\n    if (start > end) return null\n    const mid = (start + end) >>> 1\n    const node = new TreeNode(arr[mid])\n    node.left = buildBST(start, mid - 1)\n    node.right = buildBST(mid + 1, end)\n    return node\n  }\n\n  return buildBST(start, arr.length - 1)\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998366353","body":"- [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/)\n\n听说考察频率很高，比较简单，不作多说明。\n\n### 哈希法\n\n先遍历一遍链表 A，把走过的每个节点都存入一个额外的哈希中。然后再遍历链表 B，如果有哈希中已存在的节点则返回。\n\n```js\nvar getIntersectionNode = function (headA, headB) {\n  // hash\n  const hash = new Map()\n  let p = headA\n  while (p) {\n    hash.set(p, 1)\n    p = p.next\n  }\n  let p2 = headB\n  while (p2) {\n    if (hash.has(p2)) {\n      return p2\n    }\n    p2 = p2.next\n  }\n  return null\n}\n```\n\n时间复杂度：O(N);\n空间复杂度：O(N); _这里的 N 取决于相交点的长度，但按照最坏空间算，就是 O(N)_\n\n### 双指针法\n\n用两个指针，当 A 指针遍历到 A 链表的尾节点的时候，将它重置到 B 链表的头节点。同理，将 B 指针重置到 B 链表的头节点。\n\n在第二次遍历的过程中，如果这个两个链表有相交点的话，则它们一定会相遇，否则不会。\n\n```js\nvar getIntersectionNode = function (headA, headB) {\n  let p1 = headA\n  let p2 = headB\n  while (p1 != p2) {\n    p1 = p1 ? p1.next : head\n    p2 = p2 ? p2.next : head\n  }\n  return p1\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999177951","body":"- [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n没啥好说的。。。做了好多遍。\n\n证明可得：头节点到入口点的距离等于入口点到相交节点的距离。\n\n因此编码：\n\n```js\nvar detectCycle = function (head) {\n  if (!head || !head.next) return null\n  let fast = head\n  let slow = head\n  while (fast && fast.next) {\n    fast = fast.next.next\n    slow = slow.next\n    if (fast === slow) {\n      let p = head\n      while (p != slow) {\n        p = p.next\n        slow = slow.next\n      }\n      return p\n    }\n  }\n  return null\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000376557","body":"class DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000875512","body":"- [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)\n\nDFS 获取最大深度即可:\n\n```js\nvar maxDepth = function (root) {\n  if (!root) return 0\n  let len = 1\n  const dfs = (root, level) => {\n    len = Math.max(level, len)\n    root.left && dfs(root.left, level + 1)\n    root.right && dfs(root.right, level + 1)\n  }\n  dfs(root, 1)\n  return len\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000962095","body":"- [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n如果用递归解决这个问题的话，我们套用递归的模板：\n\n1. 递归遇到的最小情况，也即是递归的出口。\n\n2. 递归的本质就是将大问题分解成小问题进行求解，递归不断的减小才能收敛到递归出口。\n\n3. 递归调用的父问题和子问题之间没有交集（不然会无限递归）。\n\n```js\nvar isSameTree = (p, q) => {\n  // recursion outa\n  if (!q || !p) {\n    return !q && !p\n  }\n  return (\n    p.val === q.val &&\n    isSameTree(p.left, q.left) &&\n    isSameTree(p.right, q.right)\n  )\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991893740","body":"#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n```python\n// 91-day1-python\n\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        i = len(num) - 1\n        carry = 0\n        res = []\n        while i >= 0 or k != 0:\n            x = num[i] if i >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            res.append(sum % 10)\n            carry = sum // 10\n\n            i -= 1\n            k //= 10\n        if carry != 0: res.append(carry)\n        return res[::-1]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992598594","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n```cpp\n// 12-13\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> record;\n        vector<int> ans(len);\n        for (int i = 0; i < len; i++) {\n            if (s[i] == c) record.push_back(i);\n        }\n        \n        for (int i = 0; i < len; i++) {\n            int temp = INT_MAX;\n            for (int k = 0; k < record.size(); k++) {\n                temp = min(temp, abs(i - record[k]));\n            }\n            ans[i] = temp;\n        }\n        return ans;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993654649","body":"#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n```cpp\n// cpp 12-14\nclass CustomStack {\npublic:\n    int top;\n    vector<int> stk;\n    CustomStack(int maxSize) {\n        stk = vector<int>(maxSize, 0);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top + 1 < stk.size())\n            stk[++top] = x;\n    }\n    \n    int pop() {\n        if(top != -1)\n            return stk[top--];\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k && i < stk.size(); ++i) {\n            stk[i] += val;\n        }\n\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994917977","body":"#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n```cpp\n//12-15\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> nums;\n        stack<string> let;\n        int num = 0;\n        string res = \"\";\n        for (auto i : s) {\n            if (i >= '0' && i <= '9') {\n                num = num * 10 + i - '0';\n            }\n            else if (i == '[') {\n                nums.push(num);\n                num = 0;\n                let.push(res);\n                res = \"\";\n            }\n            else if (i == ']') {\n                int k = nums.top();\n                nums.pop();\n                string temp = let.top();\n                for (int i = 0; i < k; i++) {\n                    temp += res;\n                }\n                res = temp;\n                let.pop();\n            }\n            else {\n                res += i;\n            }\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995916003","body":"#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n```cpp\n// 12-16\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    stack<int> stIn;\n    stack<int> stOut;\n\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (stOut.empty()) {\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        int res = this->pop();\n        stOut.push(res);\n        return res;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996747436","body":"#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n```cpp\n// 12-17 求和-》计数\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> res = arr;\n        sort(res.begin(),res.end());\n        int ans = 0;\n        long sum1 = 0, sum2 = 0;\n        for (int i = 0; i < arr.size(); ++i) {\n            sum1 += res[i];\n            sum2 += arr[i];\n            if (sum1 == sum2) ans++;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997195378","body":"#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n```cpp\n// 12-18\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        int len = 1;\n        ListNode* pre = head;\n        ListNode* cur = head;\n        if (head == NULL) return head;\n\n        while(pre->next != NULL) {\n            len++;\n            pre = pre->next;\n        }\n        int mark = 0;\n        pre->next = head;\n        mark = len - (k % len);\n        for (int i = 1; i < mark; i++) {\n            cur = cur->next;\n        }\n        ListNode* ans = cur->next;\n        cur->next = NULL;\n        return ans;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997395498","body":"#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n```cpp\n// 12-19\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        for (auto p = dummy; p->next && p->next->next;) {\n            auto a = p->next, b = a->next;\n            p->next = b;\n            a->next = b->next;\n            b->next = a;\n            p = a;\n        }\n        \n        return dummy->next;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998046290","body":"#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n```cpp\n// 12-20 //数组\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == NULL) return NULL;\n        vector<int> nums;\n        for (auto t = head; t; t = t->next) nums.push_back(t->val);\n        return dfs(nums, 0 , nums.size()-1);\n\n    }\n    TreeNode *dfs(vector<int> &nums, int l, int r) {\n        if (l > r) return NULL;\n        int mid = (l + r + 1)/2;\n        auto root = new TreeNode(nums[mid]);\n        root->left = dfs(nums, l, mid-1);\n        root->right = dfs(nums, mid+1, r);\n        return root; \n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998863236","body":"#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n```cpp\n// 12-21\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n\n        int lenA = 0;\n        int lenB = 0;\n\n        while (curA != NULL) {\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) {\n            lenB++;\n            curB = curB->next;\n        }\n\n        curA = headA;\n        curB = headB;\n        if (lenB > lenA) {\n            swap(curB, curA);\n            swap(lenB, lenA);\n        }\n        int gap = lenA - lenB;\n        while (gap--) {\n            curA = curA->next;\n        }\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999679817","body":"#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n```cpp\n// 12-22\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while (fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n\n            if (fast == slow) {\n                ListNode* i1 = fast;\n                ListNode* i2 = head;\n                while (i1 != i2) {\n                    i1 = i1->next;\n                    i2 = i2->next;\n                }\n                return i1;\n            }\n\n        }\n        return NULL;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000389961","body":"#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\n```cpp\n// 12-23\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        cap = capacity;\n    }\n    \n    int get(int key) {\n        auto it = hash.find(key);\n        if (it == hash.end()) return -1;\n        cache.splice(cache.begin(), cache, it->second);\n        return it->second->second;\n    }\n    \n    void put(int key, int value) {\n        auto it = hash.find(key);\n        if (it != hash.end()) {\n            it->second->second = value;\n            cache.splice(cache.begin(), cache, it->second);\n            return;\n        }\n        else {\n            cache.push_front({key, value});\n            hash[key] = cache.begin();\n\n            if (hash.size() > cap) {\n                hash.erase(cache.back().first);\n                cache.pop_back();\n            }\n        }\n    }\nprivate:\n    int cap;\n    list<pair<int, int>> cache;//链表的顺序就是缓存使用的顺序\n    unordered_map<int, list<pair<int, int> >:: iterator> hash;\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000843999","body":"#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n```cpp\n// 12-24 \nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001017227","body":"#### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n```cpp\n//12-25 cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        queue<TreeNode*> que1;\n        que1.push(p);\n        que1.push(q);\n        while (!que1.empty()) {\n            TreeNode* p1 = que1.front();\n            que1.pop();\n            TreeNode* p2 = que1.front();\n            que1.pop();\n            if (p1==NULL&&p2==NULL) {\n                continue;\n            }\n            else if(!p1||!p2||p1->val!=p2->val) return false;\n            que1.push(p1->left);\n            que1.push(p2->left);\n            que1.push(p1->right);\n            que1.push(p2->right);\n        }\n        return true;\n\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crypteee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzcyes":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yliboom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenbihao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991891349","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992530602","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993570481","body":"### 基础版\n### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994744108","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995867065","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996803770","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997208716","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997403842","body":"#### 解题思路\n> 递归\n\n#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，其中 nn 是链表的节点数量\n- 空间复杂度：$O(N)$，其中 nn 是链表的节点数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998018375","body":"### 解题思路\n    分治 \n### 代码实现\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998877193","body":"### 解题思路\n    哈希法\n### 代码实现\njavaScript\n\n```\nvar getIntersectionNode = function(headA, headB) {\n   let hashMap = new Set();\n   while(headA) {\n       hashMap.add(headA);\n       headA = headA.next;\n   }\n   while(headB) {\n       if (hashMap.has(headB)) {\n           return headB;\n       }\n       headB = headB.next;\n   }\n   return null;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999634244","body":"### 解题思路1\n> 哈希法\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let hashMap = new Set();\n    while(head) {\n       if(hashMap.has(head)) {\n           return head;\n       } else {\n           hashMap.add(head);\n       }\n       head = head.next;\n    }\n    return null;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为链表节点个数\n- 空间复杂度 $O(N)$ N为链表节点个数\n\n### 解题思路2\n> 快慢指针法\n\n- 双指针第一次相遇：\n    设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；\n1.    第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；\n     若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；\n2. 第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。\n3. 下面分析此时fast 与 slow走过的 步数关系 ：\n\n   a. 设链表共有a+b个节点，其中 链表头部到链表入口有 a个节点（不计链表入口节点）， 链表环有 b 个节点；设两指针分别走了 f，s 步，\n  \n    则有：fast 走的步数是slow步数的 2 倍，即 f=2s；\nfast 比 slow多走了 n 个环的长度，即 f = s + nb f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走环的长度整数倍 ）；\n以上两式相减得：f=2nb，s = nb，即fast和slow 指针分别走了 2n，n 个环的周长 （n 是未知数，不同链表的情况不同）。\n目前情况分析：\n如果让指针从链表头部一直向前走并统计步数k，那么所有走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。\n而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。\n但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。\n- 双指针第二次相遇：\nslow指针位置不变 ，将fast指针重新指向链表头部节点 ；\n\nslow和fast同时每轮向前走 1 步；\nTIPS：此时 f=0，s=nb ；\n\n当 fast 指针走到f = a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。\n返回slow指针指向的节点。\n\n\n\n### 代码实现\n> javaScript\n\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) {\n        return null;\n    }\n    let fast = head;\n    let slow = head;\n    // 快慢指针未相遇时，快指针每次走两步，满指针每次走一步\n    do {\n        if(fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast == null) return null;\n    // 首次相遇后，快指针指向头部，此后快指针每次走一步，慢指针每次走一步\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为链表节点个数\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000211383","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000873444","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\n- 空间复杂度 $(K)$, k为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001028387","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n  if(!p && !q) return true\n  if(!p || !q) return false;\n  if(p.val != q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moxiaopao278":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991821310","body":"```go\r\nfunc addToArrayForm(num []int, k int) (ans []int) {\r\n\r\n    // 考虑直接相加k\r\n    for i := len(num) - 1; i >= 0 || k > 0; i-- {\r\n        if i >= 0 {\r\n            k += num[i]\r\n        }\r\n        ans = append(ans, k % 10)\r\n        k /= 10\r\n    }\r\n    reverse(ans)\r\n    return\r\n}\r\n\r\n// 反序的时候，直接头与尾相交换\r\nfunc reverse(num []int){\r\n    for i, n := 0, len(num); i < n/2; i++ {\r\n        num[i], num[n-1-i] = num[n-1-i], num[i]\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991993472","body":"```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    res := make([]int, n)\r\n\r\n    // 从左向右遍历, 记录c出现的前一个位置，保存 i - prev\r\n    prev := math.MinInt32 / 3\r\n    for i := 0 ; i < n; i ++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        res[i] = i - prev\r\n    }\r\n\r\n    // 从右向左遍历, 记录c出现的前一个位置，保存 prev - i\r\n    prev = math.MaxInt32 / 3\r\n    for i := n - 1; i >= 0; i --{\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        res[i] = min(res[i] , prev - i)\r\n    }\r\n\r\n    return res\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    } else {\r\n        return a\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993170573","body":"```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack {\r\n        make([]int, 0),\r\n        maxSize,\r\n    }\r\n\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) > 0{\r\n        res := this.stack[len(this.stack) -1]\r\n        this.stack = this.stack[:len(this.stack)-1]\r\n        return res\r\n    }\r\n    return -1\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    }\r\n\r\n    for i := 0; i < k; i++{\r\n        this.stack[i] += val\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994840380","body":"```go\r\nfunc decodeString(s string) string {\r\n    _, str := dnf(s,0)\r\n    return str\r\n}\r\n\r\nfunc  dnf( s string , i int) (int,string){\r\n    var mul int\r\n    var str string\r\n    var n int \r\n    var temp string \r\n    for n = i ; n < len(s); n++ {\r\n        if s[n] >= '0' && s[n] <= '9'{\r\n            mul = mul * 10 + int(s[n] - '0')\r\n        }else if( s[n] == '['){\r\n            n,temp = dnf(s,n+1)\r\n            for num := 0 ;  num < mul; num++{\r\n                str = str + temp\r\n            }\r\n            mul = 0\r\n        }else if( s[n] == ']'){\r\n            return n,str\r\n        }else{\r\n            str = str + string(s[n])\r\n        }\r\n    }\r\n    return n, str \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995271287","body":"```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Push(x int)  {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        for len(q.inStack) > 0 {\r\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\r\n            q.inStack = q.inStack[:len(q.inStack) - 1]\r\n        }\r\n    }\r\n    x := q.outStack[len(q.outStack) - 1]\r\n    q.outStack = q.outStack[:len(q.outStack) - 1]\r\n    return x\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        for len(q.inStack) > 0 {\r\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\r\n            q.inStack = q.inStack[:len(q.inStack) - 1]\r\n        }\r\n    }\r\n    x := q.outStack[len(q.outStack) - 1]\r\n    return x\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.outStack) == 0 && len(q.inStack) == 0\r\n}\r\n\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * param_3 := obj.Peek();\r\n * param_4 := obj.Empty();\r\n */\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997188096","body":"```go\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // 0. 考虑边界\r\n        if(head == null || head.next == null || k == 0) return head;\r\n\r\n        // 1. 计算链表长度\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while (now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n\r\n        // 2. 计算需要翻转的数量 \r\n        k = k % count;\r\n\r\n        // 3. 建立快慢指针\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null) {\r\n            if (k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n\r\n        // 最尾端指向头结点\r\n        fast.next = head;\r\n        // 记录要返回的头指针\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997380112","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        // 终止条件为 链表为空时， 或链表只剩一个 元素 的时候\r\n        if (head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        // 单次在做的事情\r\n        ListNode next = head.next;\r\n        head.next = swapPairs(next.next);\r\n        next.next = head;\r\n\r\n        // 返回真正的结点\r\n        return next;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999175469","body":"```go\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\r\n    pos := head;\r\n\r\n    // 用一个map记录已经访问过的结点\r\n    visted := map[*ListNode]bool{}\r\n\r\n    for  pos != nil {\r\n\r\n        // 判断是否存在于map中\r\n        if (visted[pos]){\r\n            return pos;\r\n        } else {\r\n            visted[pos] = true\r\n        }\r\n        pos = pos.Next\r\n    }\r\n\r\n    return nil\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000297501","body":"```java\r\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest){\r\n        return size() > capacity;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000871282","body":"/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n  public int maxDepth(TreeNode root) {\r\n    if (root == null) return 0;\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n  }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001018602","body":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null){\n            return true;\n        } else if (p == null || q == null){\n            return false;\n        } else if (p.val != q.val){\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yankang233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991839137","body":"> ### 思路\n>\n> 本来是想着是把两个数加起来，再依次取出个位，添加进结果中，但是这样会溢出。\n>\n> 于是选择从后往前遍历数组，末尾数字相加后添加进结果集中，同时判断一下有没有进位。\n>\n> 最后还要看看 k 和进位等于 0 没有，如果没有还要继续添加进结果集中。\n>\n> 最后需要Collections.reverse(res);反转链表\n>\n> <加法模板>\n>\n> while ( A 没完 || B 没完)\n>\n> A 的当前位\n>\n> B 的当前位\n>\n> 和 = A 的当前位 + B 的当前位 + 进位carry\n>\n> 当前位 = 和 % 10;\n>\n> 进位 = 和 / 10;\n>\n> 判断还有进位吗\n\n```java\nclass Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<>();\n            int carry = 0;//进位\n            int l1 = num.length - 1;//最右边的索引开始\n            while (l1 >= 0 || k != 0) {\n                int x = l1 < 0 ? 0 : num[l1];//最左边，也就是前面没有数了，就附上0\n                int y = k == 0 ? 0 : k % 10;//取余->取出个位数   ////最左边，也就是前面没有数了，就附上0\n                int sum = x + y + carry;\n                carry = sum / 10;\n                res.add(sum % 10);\n                l1--;\n                k = k / 10;\n            }\n            //最左边的carr可能还有，判断是不是0\n            if (carry != 0) {\n                res.add(carry);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n```\n\n> **复杂度分析**\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992038142","body":"Day2_821_字符的最短距离\n\n> ### 思路\n>\n> ```\n> * 思路 遍历字符串，找到目标字母，并用a数组记下位置 遍历字符串，\n> * 将当前位置与a数组的位置进行相减，取最小值，记住用绝对值。 C语言4ms通过。\n> ```\n\n```java\nclass Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<>();\n            int carry = 0;//进位\n            int l1 = num.length - 1;//最右边的索引开始\n            while (l1 >= 0 || k != 0) {\n                int x = l1 < 0 ? 0 : num[l1];//最左边，也就是前面没有数了，就附上0\n                int y = k == 0 ? 0 : k % 10;//取余->取出个位数   ////最左边，也就是前面没有数了，就附上0\n                int sum = x + y + carry;\n                carry = sum / 10;\n                res.add(sum % 10);\n                l1--;\n                k = k / 10;\n            }\n            //最左边的carr可能还有，判断是不是0\n            if (carry != 0) {\n                res.add(carry);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n```\n\n> **复杂度分析**\n>\n> - 时间复杂度：O(n*m)\n>   n:s的长度\n>   m:list的长度\n>\n>   空间复杂度：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993598223","body":"Day3_1381_设计一个支持增量操作的栈_lc题解_数组方法\n\n> ### 思路\n>\n> ```\n> * 思路 看lc官方题解的，利用数组方法stack[]存数据，定义变量top设置栈顶\n> ```\n\n```java\n  class CustomStack {\n        int[] stack;\n        int top;\n\n        public CustomStack(int maxSize) {\n            stack = new int[maxSize];//数组size\n            top = -1;//初始化为-1，之后添加一个就刚好从0开始了\n        }\n\n        //添加\n        public void push(int x) {\n            if(stack.length-1!=top){\n                top++;\n                stack[top] = x;\n            }\n\n        }\n\n        //取出\n        public int pop() {\n            if(top ==-1){\n                return -1;\n            }\n            top--;\n            return stack[top + 1];\n\n        }\n\n        public void increment(int k, int val) {\n            int limit = Math.min(k, top + 1);//k和数组里面的数比较，取小的\n            //数-1 = 引\n            for (int i = 0; i < limit; i++) {\n                stack[i] += val;\n            }\n\n        }\n```\n\n> **复杂度分析**\n>\n> - 复杂度分析\n>\n>   时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)O(1)，inc 操作的渐进时间复杂度为 O(k)O(k)。\n>\n>   空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O({\\rm maxSize})O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994878102","body":"Day4_394_字符串解码_lc题解\n\n> ### 思路\n>\n> ```\n> *实在是不会，栈stack不懂，看lc题解的，顺带添加了注释在代码上，引用lc题解的思路，主要就是只利用了一个栈来处理，字符串栈；以下是引用lc思路：\n> 题解这道题其实思路并不难想，因为很容易知道要用栈来解决，但是细节处会有很多不少地方要去注意和深究，首先是栈的使用，前面的题解很多都用了两个栈，一个数字栈，一个字符串栈，我这里的解法就只用一个栈，因为只用一个栈，所以不是字符栈，而是字符串栈stack\n> for循环遍历，分两种情况：\n> 遇到']'\n> 其他\n> 读到这里你可能会感到奇怪，除了]不是还有[、数字、字符这三种情况吗，为什么概括成其他呢，是的，的确如此，但是我们也显然知道]前面一定是字符串，字符串前面一定是[，而[前面也一定是数字，既然如此我们就可以直接全部一起解决\n> 读到]时，用一个while循环将[和]之间的字符串读出，我这里用了StringBuilder来提高字符串拼接性能，读出后将[pop删去，然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，我就直接用parseInt将字符串转化为数字了，然后是将上述字符串复制num倍，这样处理后再将字符串放回栈中即可，至于其他情况，直接将其转化为字符串压入栈中即可，最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\n> \n> 作者：CharlesGao\n> 链接：https://leetcode-cn.com/problems/decode-string/solution/javayi-ge-zhan-jian-ji-qing-xi-jie-jue-wen-ti-by-c/\n> ```\n\n```java\n    class Solution {\n        public String decodeString(String s) {\n            int len=s.length();\n            if(len<=0) return \"\";\n            Stack<String> stack=new Stack<>();\n            for(int i=0; i<len; i++){\n                char mid=s.charAt(i);\n                /*读到]时，用一个while循环将[和]之间的字符串读出，\n                我这里用了StringBuilder来提高字符串拼接性能，读出后将[pop删去，\n                然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\n                我就直接用parseInt将字符串转化为数字了，然后是将上述字符串复制num倍，\n                这样处理后再将字符串放回栈中即可，至于其他情况，直接将其转化为字符串压入栈中即可，\n                最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\n*/\n\n                //读到]时，用一个while循环将[和]之间的字符串读出，\n                if(mid==']'){\n                    StringBuilder fir=new StringBuilder();\n                    while(!stack.peek().equals(\"[\")){\n                        fir.insert(0,stack.pop());\n                    }\n                    //读出后将[pop删去，\n                    stack.pop();\n\n                    StringBuilder num=new StringBuilder();\n\n                    /*然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\n                    我就直接用parseInt将字符串转化为数字了*/\n                    while(!stack.isEmpty()&&(stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9')){\n                        num.insert(0,stack.pop());\n                    }\n                    int number=Integer.parseInt(num.toString());\n\n                    //，然后是将上述字符串复制num倍，这样处理后再将字符串放回栈中即可\n                    StringBuilder sec=new StringBuilder();\n                    for(int j=0; j<number; j++){\n                        sec.append(fir);\n                    }\n                    stack.push(sec.toString());\n                }\n                //至于其他情况，直接将其转化为字符串压入栈中即可\n                else{\n                    StringBuilder sb=new StringBuilder();\n                    sb.insert(0,mid);\n                    stack.push(sb.toString());\n                }\n            }\n\n            //最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\n            StringBuilder res=new StringBuilder();\n            while(!stack.isEmpty()){\n                res.insert(0,stack.pop());\n            }\n            return res.toString();\n        }\n    }\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996436288","body":"Day6_768_最多能完成排序的块2_lc题解\n\n> ### 思路\n>\n> ```\n> *实在是不会，栈stack不懂，看lc题解的，顺带添加了注释在代码上，引用lc题解的思路，\n>  * https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kua-u059/\n>  * 可以明确的是每个分块都有一个最大值head，且这些head从左到右递增，\n>  * 因此只要知道head的数量就知道块的数量，用栈来存储这些head\n>  * <p>\n>  * 遍历数组\n>  * i. 如果当前的数比前一个块的最大值小，也就是比栈顶元素小，并入前一个块\n>  * 要注意的是如果当前数比倒数第二个块的最大值也要小，前两个块也需要合并，因此这里需要用一个循环\n>  * ii. 如果当前的数比前一个块的最大值要大，这个数形成一个新的块，把当前的数加入stack中\n>  * iii. 如果栈为空，当前数直接入栈\n>  * （情况ii和iii可以合并）\n>  * <p>\n>  * 返回栈的长度\n>  *\n>  *\n>  * 首先栈里面总是存的是每一个块里面最大的数  ，最大的数由head保存，while则是用来比较如果当前数比倒数第二个块的最大值也要小，\n>  * 前两个块也需要合并，因此这里需要用一个循环\n>  * 因为之前已经stack.pop取出了一个出去，然后while还要继续去stack.peek比较num，也就是比较倒数第二个块的最大值，如果num还要大，说明就要合并在一起\n>  * 即去掉倒数第二个，由倒数第一个来顶替\n>  * 例如2，1，3，0，4，4\n>  * 最后stack是3，4，4\n>  * 其中2在里面，num==3的时候，stack为2，3\n>  * 接着num==0，这个时候0《3，\n>  * head=3，stack为2\n>  * 0《2\n>  * 弹出2，即执行stack.pop();//取出\n>  * 存回3，head\n>  */\n> ```\n>\n> 代码\n\n```java\nclass Solution {\n        public int maxChunksToSorted(int[] arr) {\n            Stack<Integer> stack = new Stack<>();\n            //for循环arr数组找每个数num\n            for (int num : arr) {\n                //如果栈中不是空的，并且取出的数是要小于栈中的栈顶，也就是外面的要小于栈内的，外面的要小，\n                //如果当前的数比前一个块的最大值小，也就是比栈顶元素小，并入前一个块\n                if (!stack.empty() && num < stack.peek()) {\n                    //可以明确的是每个分块都有一个最大值head，且这些head从左到右递增，\n                    //因此只要知道head的数量就知道块的数量，用栈来存储这些head\n                    int head = stack.pop();//取出栈顶的，赋予给head，最大值head，栈内最大的head\n                    //要注意的是如果当前数比倒数第二个块的最大值也要小，前两个块也需要合并，因此这里需要用一个循环\n                    while (!stack.empty() && num < stack.peek()) {\n                        stack.pop();//取出\n                    }\n                    stack.push(head);\n                }//如果外面的数是等于或者大于栈内的，//说明这个数形成一个新的块，把当前的数加入stack中\n                //或者是第一个数，也存入栈中\n                /* * ii. 如果当前的数比前一个块的最大值要大，这个数形成一个新的块，把当前的数加入stack中\n                 * iii. 如果栈为空，当前数直接入栈*/\n                else {\n                    stack.push(num);\n                }\n            }\n            return stack.size();\n        }\n    }\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222771","body":"**【Day 7】61. 旋转链表**\r\n\r\n> ### 思路\r\n>\r\n快慢指针-解题思路\r\n快慢指针的思路：\r\n\r\n由于k可以大于整个链表的长度，因此该链表可看做一个循环链表，为了简化问题，这里先求解了链表的长度n，则在不超过链表的长度的移动距离为k%n;\r\n分析题意，每个节点向前移动k个位置相当于将倒数第k个节点之后的节点移到头结点之前。\r\n图解：\r\n\r\n> ```\r\n>\r\n> 代码\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null||head.next==null||k==0){return head;}\r\n        ListNode tmp = head;\r\n        int count = 0;\r\n        while(tmp!=null){\r\n            tmp = tmp.next;\r\n            count += 1;\r\n        }\r\n        k = k % count;\r\n        if(k==0) return head;\r\n        ListNode p = head, fast = head, slow = head;\r\n        for(int i = 0; i < k; i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997385800","body":"**【Day 8】24. 两两交换链表中的节点**\n\n> ### 思路\n>\n> ```\n> https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/yuan-lai-hui-luo-ji-qing-xi-jian-dan-yi-8t93h/\n> ```\n>\n> 代码\n\n```java\n class Solution {\n        public ListNode swapPairs(ListNode head) {\n            ListNode resultHead = new ListNode();//虚拟头节点\n            resultHead.next = head;\n            ListNode curNode = resultHead;\n\n            while(curNode != null && curNode.next != null && curNode.next.next != null) {\n                ListNode first = curNode;//刚开始指向虚拟头节点\n                ListNode  second= first.next;//刚开始指向第一个节点\n                ListNode third = second.next;//刚开始指向第二个节点\n\n                first.next = third;\n                second.next = third.next;\n                third.next = second;\n\n                curNode = curNode.next.next;\n        }\n            return resultHead.next;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度： 整个链表需要遍历一遍，所以算法时间复杂度的上限是 O(n)\n  空间复杂度： 不管链表有多长，运行算法需要额外开辟的空间总是常数级的，算法的空间复杂度是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997532303","body":"Day9_109_有序链表转换二叉搜索树\n\n> ### 思路\n>\n> ```\n> 用两个指针，一块一慢，快的每次走两步，慢的每次走一步，\n> 这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。\n> 这时候把中间位置的结点的值作为二叉搜索树当前结点的值\n> 然后递归，构造出树\n> ```\n\n```java\n    class Solution {\n        public TreeNode sortedListToBST(ListNode head) {\n            if (head == null) {\n                return null;\n            }\n            if (head.next == null) {\n                return new TreeNode(head.val);\n            }\n            //快慢指针找中点\n            /*pre指向中点前一个\n            * slow指向中点\n            * */\n            ListNode fast = head, slow = head,pre=null;\n            while (fast!=null&&fast.next!=null){\n                fast = fast.next.next;\n                pre = slow;\n                slow = slow.next;\n\n            }\n            pre.next = null;\n\n            ListNode rightList = slow.next;\n                //中点\n            TreeNode root = new TreeNode(slow.val);\n                /*左子树*/\n            root.left = sortedListToBST(head);\n                /*右子树*/\n            root.right = sortedListToBST(rightList);\n            return root;\n        }\n    }\n```\n\n> **复杂度分析**\n>\n> ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999620251","body":"Day11_142_环形链表II_快慢指针.md\n\n> ### 思路\n>\n> ```\n> 思路来自题解\n> \n>  * 思路：慢指针移动两步，快指针移动一步，相遇之后，快指针变成头指针，然后每次快慢指针各走一步直到相遇，相遇的节点就是入环节点\n> 复杂度：时间复杂度O(n)，空间复杂度O(1)\n>  *https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/shuang-zhi-zhen-dong-hua-tu-jie-dai-ma-j-b1fc/\n> 作者：chen-wei-f\n> 链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/shuang-zhi-zhen-dong-hua-tu-jie-dai-ma-j-b1fc/\n> > ```\n\n代码\n```java\n    public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode fast1 = head;\n                while (fast1 != slow) {\n                    fast1 = fast1.next;\n                    slow = slow.next;\n                }\n                return fast1;\n            }\n        }\n        return null;\n    }\n}\n```\n\n> **复杂度分析**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000198229","body":"Day12_146_LRU缓存机制.md\n\n> ### 思路\n>\n> ```\n> 思路来自题解\n>LinkedHashMap与普通的HashMap相比是自带顺序的\n> 链接：https://leetcode-cn.com/problems/lru-cache/solution/java-shi-yong-linkedhashmapshi-xian-lru-t279i/\n> > ```\n\n代码\n```java    \nclass LRUCache {\n        private Map<Integer, Integer> map;\n        private int cap;\n\n        public LRUCache(int capacity) {\n            map = new LinkedHashMap<>();\n            cap = capacity;\n        }\n\n        public int get(int key) {\n            // key不存在，访问不到\n            if (!map.containsKey(key)) {\n                return-1;\n            }\n\n            // key存在，需要将keyPair放到最后\n            int val = map.remove(key);\n            map.put(key, val);\n            return val;\n        }\n\n        public void put(int key, int value) {\n            // key存在，将存在的keyPair放到最后，并更新上新value\n            if (map.containsKey(key)) {\n                map.remove(key);\n                map.put(key, value);\n                return;\n            }\n\n            // key不存在，直接放到最后\n            //不管有没有超出容量，这句话一定要执行。\n            map.put(key, value);\n\n            // 检查缓存容量，超出上限，则移除第一个\n            if (map.size() > cap) {\n                map.remove(map.entrySet().iterator().next().getKey());\n\n            }\n        }\n    }\n```\n\n> **复杂度分析**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000860227","body":"Day13_104_二叉树的最大深度.md\n\n> ### 思路\n>\n> ```\n> \n> 之前做过_111_二叉树的最小深度_\n> 所以不难\n> \n> \n> \n> \n> \n> > > ```\n\n代码\n```java    \n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root ==null){\n            return 0;\n        }\n        if(root.left ==null &&root.right==null){\n            return 1;\n        }\n\n        int m1 = maxDepth(root.left);\n        int m2  = maxDepth(root.right);\n        if(root.left ==null ||root.right==null){\n            return m1+m2+1;\n        }\n\n        return Math.max(m1,m2)+1;\n    }\n}\n```\n\n> **复杂度分析**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000969289","body":"Day_14_100_相同的树.md\n> ### 思路\n>\n> ```\n> \n> 一开始就想到dfs写法，判断情况就是当头节点都是空的情况，就直接true了\n> 否则看看左右子节点，左右子节点就分两种情况，if都是不为空，就判断是不是相同\n> 即要求p != null && q != null && p.val == q.val（注意并且val ==val）\n> 如果都为空，就是直接true，\n> 其他情况，比如一个空，一个不空，说明不相同，直接false\n> 所以不难\n> \n> \n> \n> \n> \n> > > ```\n\n代码\n\n```java    \n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n    class Solution {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if (p == null && q == null) {\n                return true;\n            }\n            if (p != null && q != null && p.val == q.val) {\n                return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\n\n            }\n            return false;\n\n        }\n    }\n```\n\n> **复杂度分析**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001100593","body":"Day_15_129_求根节点到叶节点数字之和.md\n> ### 思路\n>\n> ```\n> 一开始就想用dfs，递归思想，一个问题就是不知道怎么去让root.val的值变成整数，1-2=>12这样子\n>想的还是for循环之类的，没想到居然可以preSum*10+preSum即可解决，佩服；\n>另外就是不知道递归的情况，这题是两个子节点都空才算return，之前是分左右子节点的情况\n>这题不用，都是递归去，最后++\n> \n> \n> \n> > > ```\n\n代码\n\n```java    \n    class Solution {\n        public int sumNumbers(TreeNode root) {\n            return dfs(root, 0);\n\n        }\n        private int dfs(TreeNode root, int preSum) {\n            if (root == null) {\n                return 0;\n            }\n            preSum = preSum * 10 + root.val;\n            if (root.left == null && root.right == null) {\n                return preSum;\n            }\n\n            return dfs(root.left, preSum) + dfs(root.right, preSum);\n        }\n    }\n```\n\n> **复杂度分析**","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zulliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Baiqr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992601931","body":"## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> idxs;\n        for(int i=0;i<s.size();i++)\n            if(s[i]==c)\n                idxs.push_back(i);\n        int l = 0, r = 0;\n        vector<int> res(s.size(),0);\n        int idx = 0;\n        while(r<idxs.size())\n        {\n            if(idx<=idxs[l])\n                res[idx] = idxs[l] - idx;\n            else if(idx>idxs[l]&&idxs[r]>=idx)\n                res[idx] = min(idx-idxs[l],idxs[r]-idx);\n            else\n            {\n                if(l==r)\n                    l--;\n                l++;\n                r++;\n                continue;\n            }\n            idx++;\n        }\n        r--;\n        while(idx<res.size())\n        {\n            res[idx] = idx - idxs[r];\n            idx++;\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993667380","body":"## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass CustomStack {\nvector<int> st;\nint idx;\npublic:\n    CustomStack(int maxSize) {\n        st.assign(maxSize,0);\n        idx = 0;\n    }\n    \n    void push(int x) {\n        if(idx<st.size())\n            st[idx++] = x; \n    }\n    \n    int pop() {\n        if(idx>0)\n            return st[--idx];\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k&&i<idx;i++)\n            st[i] += val;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994905226","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> st_c;\r\n        stack<int> st_num;\r\n        for(int i=0;i<s.size();++i)\r\n        {\r\n            if(s[i]>='0'&&s[i]<='9')\r\n            {\r\n                int temp = s[i]-'0';\r\n                while(s[i+1]>='0'&&s[i+1]<='9')\r\n                {\r\n                    ++i;\r\n                    temp = temp * 10 + s[i]-'0';\r\n                }\r\n                st_num.push(temp);\r\n            }\r\n            else if(s[i]==']')\r\n            {\r\n                string temp = \"\";\r\n                while(st_c.top()!='[')\r\n                {\r\n                    temp = st_c.top() + temp;\r\n                    st_c.pop(); \r\n                }\r\n                st_c.pop();\r\n                for(int j=0;j<st_num.top();++j)\r\n                {\r\n                    for(int k=0;k<temp.size();++k)\r\n                    {\r\n                        st_c.push(temp[k]);\r\n                    }\r\n                }\r\n                st_num.pop();\r\n            }\r\n            else\r\n            {\r\n                st_c.push(s[i]);\r\n            }\r\n        }\r\n        string res=\"\";\r\n        while(!st_c.empty())\r\n        {    \r\n            res = st_c.top() + res;\r\n            st_c.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995904894","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass MyQueue {\r\n    stack<int> in;\r\n    stack<int> out;\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int temp;\r\n        if(out.empty())\r\n        {\r\n            while(!in.empty())\r\n            {\r\n                temp = in.top();\r\n                in.pop();\r\n                out.push(temp);\r\n            }\r\n        }\r\n        temp = out.top();\r\n        out.pop();\r\n        return temp;\r\n    }\r\n    \r\n    int peek() {\r\n        int temp;\r\n        if(out.empty())\r\n        {\r\n            while(!in.empty())\r\n            {\r\n                temp = in.top();\r\n                in.pop();\r\n                out.push(temp);\r\n            }\r\n        }\r\n        temp = out.top();\r\n        return temp;\r\n    }\r\n    \r\n    bool empty() {\r\n        return in.empty()&&out.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996831030","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int n = arr.size();\r\n        vector<int> premax(n), sumin(n);\r\n        for (int i = 0; i < n; i++)\r\n            if (i == 0) \r\n                premax[i] = arr[i];\r\n            else\r\n                premax[i] = max(premax[i - 1], arr[i]);\r\n        for (int i = n - 1; i >= 0; i--)\r\n            if (i == n - 1) \r\n                sumin[i] = arr[i];\r\n            else \r\n                sumin[i] = min(sumin[i + 1], arr[i]);\r\n        int ans = 1;\r\n        for (int i = 0; i < n - 1; i++)\r\n            if (premax[i] <= sumin[i + 1]) \r\n                ans++;\r\n        return ans;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997221805","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode* first = head;\r\n        ListNode* second = new ListNode(0,head);\r\n        head = second;\r\n        int len = 0;\r\n        for(int i=0;i<k;++i)\r\n            if(first)\r\n                first = first->next;\r\n            else\r\n            {\r\n                len = i;\r\n                break;\r\n            }\r\n        if(len!=0)\r\n        {\r\n            int move = k % len;\r\n            first = head->next;\r\n            for(int i=0;i<move;++i)\r\n                first = first->next;\r\n        }\r\n        if(first)\r\n        {\r\n            second = head->next;\r\n            while(first->next)\r\n            {\r\n                first = first->next;\r\n                second = second->next;\r\n            }\r\n            first->next = head->next;\r\n            head->next = second->next;\r\n            second->next = nullptr;\r\n        }\r\n        return head->next;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997415286","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* pre = new ListNode(0,head);\r\n        ListNode* first = pre;\r\n        ListNode* second = pre->next;\r\n        while(second&&second->next)\r\n        {\r\n            ListNode* temp = second->next->next; \r\n            first->next = second->next;\r\n            first->next->next = second;\r\n            second->next = temp;\r\n            first = second;\r\n            second = temp;\r\n        }\r\n        return pre->next;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997425217","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\n    vector<int> nums;\r\npublic:\r\n    TreeNode* buildTree(int l,int r)\r\n    {\r\n        if(l>r)\r\n            return nullptr;\r\n        int mid = (l+r+1)/2;\r\n        TreeNode* root = new TreeNode(nums[mid]);\r\n        root->left = buildTree(l,mid-1);\r\n        root->right = buildTree(mid+1,r);\r\n        return root;\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int l = 0;\r\n        while(head)\r\n        {\r\n            nums.push_back(head->val);\r\n            head = head->next;\r\n        }\r\n        return buildTree(0,nums.size()-1);\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998832549","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(!headA||!headB)\r\n            return nullptr;\r\n        ListNode *a = headA;\r\n        ListNode *b = headB;\r\n        while(a!=b)\r\n        {\r\n            if(!a)\r\n                a = headB;\r\n            else\r\n                a = a->next;\r\n            if(!b)\r\n                b = headA;\r\n            else\r\n                b = b->next;\r\n        }\r\n        return a;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999682905","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(!head)\r\n            return NULL;\r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n        while(fast->next&&fast->next->next)\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if(slow==fast)\r\n                break;\r\n        }\r\n        if(!fast->next||!fast->next->next)\r\n            return NULL;\r\n        fast = head;\r\n        while(fast!=slow)\r\n        {\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        return fast;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000377964","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nstruct DLinkeNode{\r\n    int key, value;\r\n    DLinkeNode* prev;\r\n    DLinkeNode* next;\r\n    DLinkeNode(): key(0), value(0), prev(nullptr), next(nullptr){}\r\n    DLinkeNode(int key1, int value1): key(key1), value(value1), prev(nullptr), next(nullptr){}\r\n};\r\n\r\n\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int,DLinkeNode*> mp;\r\n    DLinkeNode* head;\r\n    DLinkeNode* tail;\r\n    int max_capacity;\r\n    int size;\r\n\r\npublic:\r\n    void removeNode(DLinkeNode* node)\r\n    {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void addToHead(DLinkeNode* node)\r\n    {\r\n        node->next = head->next;\r\n        head->next = node;\r\n        node->prev = head;\r\n        node->next->prev = node;\r\n    }\r\n\r\n    void moveToHead(DLinkeNode* node)\r\n    {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    LRUCache(int capacity) {\r\n        mp.clear();\r\n        max_capacity = capacity;\r\n        size = 0;\r\n        head = new DLinkeNode();\r\n        tail = new DLinkeNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if(mp.count(key)==0)\r\n            return -1;\r\n        DLinkeNode* node = mp[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(mp.count(key)==0)\r\n        {\r\n            DLinkeNode* node = new DLinkeNode(key,value);\r\n            mp[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if(size>max_capacity)\r\n            {\r\n                DLinkeNode* temp = tail->prev;\r\n                tail->prev = temp->prev;\r\n                temp->prev->next = tail;\r\n                mp.erase(temp->key);\r\n                delete temp;\r\n                --size;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            DLinkeNode* node = mp[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000885352","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int deepth(TreeNode* root)\r\n    {\r\n        if(!root)\r\n            return 0;\r\n        return max(deepth(root->left),deepth(root->right)) + 1;\r\n    }\r\n    int maxDepth(TreeNode* root) {\r\n        return deepth(root);\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001040310","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if((p&&!q)||(!p&&q))\r\n            return false;\r\n        if(!q&&!p)\r\n            return true;\r\n        if(q->val==p->val)\r\n            return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\r\n        else\r\n            return false;\r\n        return true;\r\n    }\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simonsayshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devosend":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991914988","body":"## 思路\r\n从后往前遍历相加。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num) - 1, -1, -1):\r\n            k += num[i]\r\n            if k >= 10:\r\n                num[i] = k % 10\r\n                k = k // 10\r\n            else:\r\n                num[i] = k\r\n                return num\r\n\r\n        while k > 0:\r\n            num.insert(0, k % 10)\r\n            k = k // 10\r\n\r\n        return num\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992051439","body":"## 思路\r\n正反两次遍历，取较小的值存储到列表中返回。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = []\r\n        min = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                min = i\r\n            result.append(i - min)\r\n        \r\n        max = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                max = i\r\n            result[i] = result[i] if result[i] < max - i else max - i\r\n        \r\n        return result\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993334991","body":"## 思路\r\n使用列表模拟\r\n## 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > len(self.stack):\r\n            k = len(self.stack)\r\n\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n\r\n```\r\n## 复杂度分析\r\n - 时间复杂度：push: O(1), pop: O(1), inc: O(min(k, maxSize))\r\n - 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995606236","body":"## 思路\r\n使用双栈模拟\r\n\r\n## 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.s1) == 0 and len(self.s2) == 0\r\n\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n);\r\n- 空间复杂度：O(n);","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997209444","body":"## 思路\r\n将链表组成环形链表，记录链表的长度，遍历到指定位置断开链表\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n\r\n        count = 1\r\n        tmp = head\r\n        while tmp.next:\r\n            count += 1\r\n            tmp = tmp.next\r\n        \r\n        tmp.next = head\r\n\r\n        count -= k % count\r\n        while count > 0:\r\n            tmp = head\r\n            head = head.next\r\n            count -= 1\r\n        \r\n        tmp.next = None\r\n        return head\r\n\r\n```\r\n## 复杂度\r\n- 时间复杂度：o(n)\r\n- 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997322113","body":"## 思路\r\n迭代\r\n## 代码\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        cur = head\r\n        head = cur.next\r\n        while cur and cur.next:\r\n            tmp = cur.next.next\r\n            cur.next.next = cur\r\n            if tmp and tmp.next:\r\n                cur.next = tmp.next\r\n            else:\r\n                cur.next = tmp\r\n            cur = tmp\r\n        \r\n        return head\r\n\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998581083","body":"## 思路\r\n长的链表提前遍历n次，然后两个链表同时遍历，判断节点是否相等\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        dummyA, dummyB = headA, headB\r\n\r\n        n1 = 0\r\n        while dummyA:\r\n            n1 += 1\r\n            dummyA = dummyA.next\r\n        \r\n        n2 = 0\r\n        while dummyB:\r\n            n2 += 1\r\n            dummyB = dummyB.next\r\n        \r\n        if n1 > n2:\r\n            n = n1 - n2\r\n            while n:\r\n                headA = headA.next\r\n                n -= 1\r\n        \r\n        if n2 > n1:\r\n            n = n2 - n1\r\n            while n:\r\n                headB = headB.next\r\n                n -= 1\r\n        \r\n        while headA:\r\n            if headA is headB:\r\n                return headA\r\n            \r\n            headA = headA.next\r\n            headB = headB.next\r\n        \r\n        return None\r\n\r\n```\r\n## 复杂度分析\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999314286","body":"## 思路\r\n双指针\r\n\r\n## 代码\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n\r\n        if not head or not head.next:\r\n            return None\r\n\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n            if slow is fast:\r\n                tmp = head\r\n                while slow is not tmp:\r\n                    slow = slow.next\r\n                    tmp = tmp.next\r\n                \r\n                return slow\r\n        \r\n        return None\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000113869","body":"## 思路\r\n双向链表+哈希表\r\n\r\n## 代码\r\n```\r\nclass Node:\r\n    def __init__(self, key, value, prev=None, next=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = prev\r\n        self.next = prev\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.hashMap = {}\r\n        self.capacity = capacity\r\n        self.head = Node(None, None)\r\n        self.tail = Node(None, None)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def move_node_to_tail(self, node: Node) -> None:\r\n\r\n        self.tail.prev.next = node\r\n        node.prev = self.tail.prev\r\n\r\n        node.next = self.tail\r\n        self.tail.prev = node\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashMap:\r\n            return -1\r\n        \r\n        node = self.hashMap[key]\r\n        node.next.prev = node.prev\r\n        node.prev.next = node.next\r\n        self.move_node_to_tail(node)\r\n        return node.value\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashMap:\r\n            node = self.hashMap[key]\r\n            node.value = value\r\n            node.next.prev = node.prev\r\n            node.prev.next = node.next\r\n        else:\r\n            node = Node(key, value)\r\n            if self.capacity == len(self.hashMap.keys()):\r\n                del_node = self.head.next\r\n\r\n                self.head.next = del_node.next\r\n                del_node.next.prev = self.head\r\n\r\n                del self.hashMap[del_node.key]\r\n\r\n            self.hashMap[key] = node\r\n\r\n        self.move_node_to_tail(node)\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000609100","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if root is None:\r\n            return 0\r\n        \r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        \r\n        deep = left if left > right else right\r\n        return deep + 1\r\n```\r\n## 复杂度分析\r\n- 时间复杂度： O(n)\r\n- 空间复杂度：O(h)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"comst007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991830092","body":"# 思路：先求A+k的值，再转换成数组形式\n···\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        A = 0\n        for i,a in enumerate(num):\n            A += a*(10**(n-i-1))\n        ans = A+k\n\n        res = [int(s) for s in str(ans)]\n        return res\n···\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992445844","body":"#思路：窗口法\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        ans = [0]*n\n        if s[0]==c:\n            l =0\n        else:\n            l=n\n        r = s.find(c,1)\n        for i in range(n):\n            ans[i] = min(abs(i-l),abs(r-i))\n            if i == r:\n                l = i\n                r = s.find(c, l+1)\n        return ans\n```\n时间复杂度:O(N)\n空间复杂度:O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997193263","body":"# 思路：快慢指针找倒数第k个结点\n```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head:\n            #快慢指针找倒数第k个结点,快比慢先走k步，快到底，慢到倒数第k\n            p1 = head #慢\n            p2 = head #快\n            count = 1\n            i = 0\n            while i < k:\n                #求总结点数\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                #快指针先走k步\n                else:\n                    k = k % count  #防止k比count大\n                    i = -1 #重置i，p2从头再走k步\n                    p2 = head\n                i += 1\n\n            #p1指向倒数第k个结点\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            #是最后一个就不必反转了\n            if p1.next:\n                temp = p1.next\n            else:\n                return head\n            \n            p1.next = None\n            p2.next = head\n            return temp            \n\n\n            \n```\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997964054","body":"# 思路：快慢指针找到中点，不断递归\n```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return head\n        pre,slow,fast = None,head,head  #快慢指针找中点,pre表示中点之前的一个节点\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val) #中点为根节点\n        \n        if slow == fast:\n            return node\n        \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n\n        return node\n        \n```\n时间复杂度:O(nlogn)\n空间复杂度:O(logn）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998865468","body":"#思路：双指针，当其中一个到尾部之后，让这个指针等于另一条链表的头指针，直到二者相遇\n```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a,b = headA, headB\n        while a!=b:\n            if a:\n                a = a.next\n            else:\n                a = headB\n            if b:\n                b = b.next\n            else:\n                b = headA\n        return a\n\n```\n时间复杂度:O(N)\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999686552","body":"# 思路\n快慢指针，第一次相遇之后快指针从头开始，第二次相遇的位置就是环的起点。2（L+D）=L+2C+D\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                fast = head\n                while fast != slow:\n                    fast = fast.next\n                    slow = slow.next\n                return fast\n```\n时间复杂度：O（N）\n空间复杂度度：O（1）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000367438","body":"# 思路：双向链表+哈希表\n```\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n\n\n```\n时间复杂度：O（1）\n空间复杂度：O（c）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000974020","body":"# 思路：\n递归判断，若值不相等或结构不相等，返回false\n```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n时间复杂度：O（N）\n空间复杂度：O（H）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001106406","body":"# 思路：\nDFS\n```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(root, current):\n            if not root:\n                return 0\n            #无子节点\n            if not root.left and not root.right:\n                return current * 10 + root.val\n            ans = dfs(root.left, current*10 + root.val)+ dfs(root.right, current*10 + root.val)\n            return ans\n        return dfs(root, 0)\n```\n时间复杂度：O（n）\n空间复杂度：O（h）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biancaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cassiechris":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xvm03":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youyiqin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"juleijs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rebel-ly":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Winperrr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangcn111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991861722","body":"## 思路\r\n通过int转换实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        #字符串与int的转换\r\n        resStr = \"\"\r\n        for i in num:\r\n            resStr +=str(i)\r\n        res = str(int(resStr)+k)\r\n        reslist = []\r\n        for i in res:\r\n            reslist.append(int(i))\r\n        return reslist\r\n\r\nif __name__ == '__main__':\r\n    A = [1,2,0,0]\r\n    K = 34\r\n    ret = Solution().addToArrayForm(A, K)\r\n    print(ret)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992066017","body":"## 思路\r\n遍历两次数组实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indexList = []\r\n        for index,val in enumerate(s):\r\n            if val == c:\r\n                indexList.append(index)\r\n        resList = []\r\n        p = 0\r\n        # print(indexList)\r\n        for index,val in enumerate(s):\r\n            # print(index)\r\n            if p < len(indexList)-1 and (abs(index-indexList[p]) > abs(index-indexList[p+1])):\r\n                p += 1\r\n            resList.append(abs(index-indexList[p]))\r\n        return resList\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995282874","body":"## 思路\r\n创建List来实现\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.Alist = []\r\n        self.Blist = []\r\n        self.peekIndex = None\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.Alist.append(x)\r\n        if len(self.Alist)== 1:\r\n            self.peekIndex = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #如果B为空，就从A倒到B再处理\r\n        if len(self.Blist) == 0 and len(self.Alist) == 0:\r\n            return None\r\n        if len(self.Blist) != 0:\r\n            return self.Blist.pop()\r\n        else:\r\n            while len(self.Alist)!=0:\r\n                self.Blist.append(self.Alist.pop())\r\n            self.peekIndex = None\r\n            return self.Blist.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.Blist.__len__() == 0:\r\n            return self.peekIndex\r\n        else:\r\n            return self.Blist[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if self.peekIndex == None and len(self.Blist) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997394176","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        startHead = ListNode(-1)\r\n        startHead.next = head\r\n        tempHead = startHead\r\n        while tempHead.next and tempHead.next.next:\r\n            #先获得Node1、Node2\r\n            node1 = tempHead.next\r\n            node2 = tempHead.next.next\r\n            #进行替换\r\n            tempHead.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            #移动指针\r\n            tempHead = node1\r\n\r\n        return startHead.next\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997831018","body":"## 思路\r\n用快慢指针实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if head == None:\r\n            return head\r\n        #快慢指针\r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow#pre作为slow【中点】左边的指针存在\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None#把链路从中间断开\r\n        rootTreeNode = TreeNode(slow.val)\r\n        if fast == slow:\r\n            return rootTreeNode\r\n        rootTreeNode.left = self.sortedListToBST(head)\r\n        rootTreeNode.right = self.sortedListToBST(slow.next)\r\n        return rootTreeNode\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998354261","body":"## 思路\r\n双指针交叉实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ANode = headA\r\n        BNode = headB\r\n        ALink,BLink = False, False\r\n        while ANode and BNode:\r\n            # print(ANode.val,BNode.val)\r\n            if ANode == BNode:\r\n                return ANode\r\n            \r\n            ANode = ANode.next\r\n            BNode = BNode.next\r\n            if ANode == None and ALink != True:\r\n                ANode = headB\r\n                ALink = True\r\n            if BNode == None and BLink != True:\r\n                BNode = headA\r\n                BLink = True\r\n        # print(\"fail\")\r\n        return None\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000559005","body":"## 思路\r\nDFS实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        maxDepth = self.dfs(root, 0, 0)\r\n        return maxDepth\r\n    def dfs(self, node:TreeNode, cur:int, maxDepth:int) -> int:\r\n        if node == None:\r\n            # print(cur, maxDepth)\r\n            return maxDepth\r\n        cur += 1\r\n        maxDepth = max(cur, maxDepth)\r\n        leftMax = 0\r\n        rightMax = 0\r\n        if node.left:\r\n            leftMax = self.dfs(node.left, cur, maxDepth)\r\n        if node.right:\r\n            rightMax = self.dfs(node.right, cur, maxDepth)\r\n        # print(node.val,maxDepth,leftMax, rightMax)\r\n        return max(leftMax, rightMax, maxDepth)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiangyDeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leige635539766":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"summer506hai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihuiwen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhy3213":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995087469","body":"## 思路 \nlazy 倒\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.forward=collections.deque()\n        self.backward=collections.deque()\n\n\n    def push(self, x: int) -> None:\n        self.forward.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.backward)==0:\n            while self.forward:\n                self.backward.append(self.forward.pop())\n        return self.backward.pop()\n\n    def peek(self) -> int:\n        if not len(self.backward)==0:\n            return self.backward[-1]\n        return self.forward[0]\n\n    def empty(self) -> bool:\n        return len(self.backward)==0 and len(self.forward)==0\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998186021","body":"# 思路\n哈希\n# 代码\n```python\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        s=set()\n        while headA:\n            s.add(headA)\n            headA=headA.next\n        while headB:\n            if headB in s:\n                break\n            headB=headB.next\n        if headB:\n            return headB\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998970362","body":"# 思路\n双指针\n# 代码\n```python\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        fast,slow=head,head\n        while True:\n            if not (fast:=fast.next) or not (fast:=fast.next):\n                return None\n            slow=slow.next\n            if fast==slow:\n                break\n        slow=head\n        while slow!=fast:\n            slow=slow.next\n            fast=fast.next\n        return slow\n```\n时间O(n)\n空间O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000616433","body":"# 思路\n先序遍历非递归\n# 代码\n```python\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        q=deque([(root,0)])\n        m=0\n        while q:\n            cur,depth=q.pop()\n            while cur:\n                depth+=1\n                m=depth if m<depth else m\n                if cur.right:\n                    q.append((cur.right,depth))\n                cur=cur.left\n        return m\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000925382","body":"# 思路\n一行递归\n但我是傻子\n# 代码\n```python\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) if (p and q)and (p.val==q.val) else False if not p==q==None else True\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hibriansun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jz1433":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aduispace":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenlong201807":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992058242","body":"## 代码块\r\n\r\n```javascript\r\n\r\nvar shortestToChar = function(s, c) {\r\n  const len = s.length;\r\n  let resultArr = [];\r\n\r\n  const helpFn = (curInd, len, ori, target) => {\r\n  let left = curInd;\r\n  let right = curInd;\r\n  let minLen = len;\r\n  if (ori.charAt(curInd) === target) {\r\n    return 0;\r\n  }\r\n\r\n  while (left >= 0) {\r\n    if (ori.charAt(left) === target) {\r\n      minLen = Math.min(curInd - left, len)\r\n      break;\r\n    }\r\n    left--\r\n  }\r\n\r\n  while (right <= len) {\r\n    if (ori.charAt(right) === target) {\r\n      minLen = Math.min(right - curInd, minLen)\r\n      break;\r\n    }\r\n    right++\r\n  }\r\n\r\n  return minLen;\r\n }\r\n  for(let i = 0; i < len; i++) {\r\n    resultArr.push(helpFn(i, len, s, c));\r\n  }\r\n  \r\n  return resultArr;\r\n};\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994870925","body":"### 代码块\r\n```javascript\r\n\r\nfunction checkRate(input) {\r\n  var re = /^[0-9]+.?[0-9]*/;\r\n  //判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/;//判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/\r\n  return re.test(input);\r\n}\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n  let numStr = '';\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (checkRate(s[i])) {\r\n      numStr += s[i];\r\n      continue;\r\n    } else {\r\n      if (numStr) stack.push(numStr);\r\n      numStr = '';\r\n\r\n      if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n      } else {\r\n        let tempStr = '';\r\n        while (stack.length) {\r\n          const curStr = stack.pop();\r\n          if (curStr !== '[') {\r\n            tempStr = curStr + tempStr;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        let curNum = stack.pop();\r\n        stack.push(tempStr.repeat(curNum));\r\n      }\r\n    }\r\n  }\r\n  return stack.join('');\r\n}\r\n\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997141898","body":"### 代码块\r\n```javascript\r\n\r\nvar rotateRight = function (head, k) {\r\n  if (k === 0 || !head || !head.next) return head;\r\n  var dummy = new ListNode(0, head), cur = dummy;\r\n\r\n  let count = 0;\r\n  while (cur.next) {\r\n      cur = cur.next;\r\n      count++;\r\n  }\r\n  if (k === count) {\r\n      return head;\r\n  } else if (k > count) {\r\n      k %= count;\r\n  }\r\n\r\n  cur.next = dummy.next;\r\n  cur = cur.next;\r\n\r\n  for (let i = 0; i < count - k - 1; i++) {\r\n      cur = cur.next;\r\n  }\r\n\r\n  dummy.next = cur.next;\r\n  cur.next = null;\r\n  return dummy.next\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997758469","body":"### 代码块\r\n```javascript\r\n\r\nconst sortedListToBST = (head) => {\r\n  if (head == null) return null;\r\n  let len = 0;\r\n  let h = head;  // h初始指向头结点\r\n  while (head) { // 计算链表节点个数\r\n    len++;\r\n    head = head.next;\r\n  }\r\n\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;     // 递归出口，返回null节点\r\n    const mid = (start + end) >>> 1;  // 求mid，只是为了分治，不是用它断开链表\r\n    const left = buildBST(start, mid - 1); // 先递归构建左子树\r\n\r\n    const root = new TreeNode(h.val);      // 根据 h.val 构建节点\r\n    h = h.next;          // h指针步进              \r\n    root.left = left;    // root接上构建好的左子树        \r\n\r\n    root.right = buildBST(mid + 1, end); // 构建当前root的右子树，接上\r\n    return root;\r\n  };\r\n\r\n  return buildBST(0, len - 1);\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(log)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998484361","body":"### 代码块\r\n```javascript\r\n\r\nvar getIntersectionNode = function (headA, headB) {\r\n  if (!headA || !headB) return null;\r\n\r\n  let pA = headA,\r\n      pB = headB;\r\n  while (pA !== pB) {\r\n      pA = pA === null ? headB : pA.next;\r\n      pB = pB === null ? headA : pB.next;\r\n  }\r\n  return pA;\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999223676","body":"### 代码块\r\n```javascript\r\n\r\nvar detectCycle = function (head) {\r\n  if (!head || !head.next) return null;\r\n  let slow = head.next,\r\n    fast = head.next.next;\r\n  while (fast && fast.next) {\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n    if (fast == slow) {\r\n      slow = head;\r\n      while (fast !== slow) {\r\n        slow = slow.next;\r\n        fast = fast.next;\r\n      }\r\n      return slow;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999997004","body":"### 代码块\r\n```javascript\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n  }\r\n\r\n  get(key) {\r\n    let val = this.map.get(key);\r\n    if (val === undefined) return -1;\r\n\r\n    this.map.delete(key); // 因为被用过一次，原有位置删除\r\n    this.map.set(key, val); // 放入最下面表示最新使用\r\n    return val;\r\n  }\r\n\r\n  put(key, val) {\r\n    if (this.map.has(key)) this.map.delete(key); // 如果有，删除\r\n\r\n    this.map.set(key, val); // 放到最下面表示最新使用\r\n\r\n    if (this.map.size > this.capacity) {\r\n      // 这里有个知识点\r\n      // map的entries方法，还有keys方法(可以看mdn))，会返回一个迭代器\r\n      // 迭代器调用next也是顺序返回，所以返回第一个的值就是最老的，找到并删除即可\r\n      this.map.delete(this.map.entries().next().value[0]);\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000664917","body":"### 代码块\r\n```javascript\r\n\r\nvar maxDepth = function(root) {\r\n  if (!root) return root;\r\n\r\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\r\n};\r\n\r\n```\r\n\r\n### 时间复杂度和空间复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qibao1112":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998025598","body":"### 思路\r\n使用hashMap集合，遍历链表1加入map中，遍历链表2，判断是否map中存在，不存在加入map，存在返回当前节点\r\n\r\n### 代码实现\r\n``` java\r\nimport java.util.HashMap;\r\npublic class Solution {\r\n    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {\r\n        ListNode current1 = pHead1;\r\n        ListNode current2 = pHead2;\r\n        \r\n        HashMap<ListNode,Integer> hashMap = new HashMap<ListNode,Integer>();\r\n        while(current1!=null){\r\n            hashMap.put(current1,null);\r\n            current1 = current1.next;\r\n        }\r\n        while(current2!=null){\r\n            if(hashMap.containsKey(current2))\r\n                return current2;\r\n            current2 = current2.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：0（n）\r\n空间复杂度：o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziyue08":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992336884","body":"```javascript\r\nvar shortestToChar = function(S, C) {\r\n    var dd=[];\r\n    //从左到右，从右到左\r\n    for(var i=0;i<S.length;i++){\r\n            var left=S.lastIndexOf(C,i);\r\n            var right=S.indexOf(C,i);\r\n            if(left==-1){\t//左边不存在\r\n                dd.push(right-i);\r\n            }\r\n            else if(right==-1){\t\t//右边不存在\r\n                dd.push(i-left);\r\n            }else{               \r\n                right-i>i-left?dd.push(i-left):dd.push(right-i);\r\n            }\r\n    }\r\n    return dd;\r\n};\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994767327","body":"```javascript\r\nvar decodeString = function(s) {\r\n    let stack = []\r\n    for(let i = 0; i < s.length; i++){\r\n        if (stack.length === 0 || s[i] !== ']'){\r\n            if (/[0-9]/.test(s[i])){\r\n                for(let l = i + 1; l < s.length; l++){\r\n                    if (!/[0-9]/.test(s[l])) {\r\n                        stack.push(s.slice(i, l))\r\n                        i = l - 1;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                stack.push(s[i]);\r\n            }\r\n            continue;\r\n        }\r\n \r\n \r\n        // 核心处理。找遇到的第一个数字。如果这个数字之前还有数据，就解密这个局部串，放入栈。\r\n        // 如果这个数字之前没数据了，栈空，字符串累加\r\n        for (let j = stack.length - 1; j >= 0; j--) {\r\n            if (/[0-9]+/.test(stack[j])){\r\n                if (j === 0){\r\n                    let subStr = stack.slice(j + 2).join('').repeat(Number(stack[j]))\r\n                    stack = []\r\n                    for(let m = 0; m < subStr.length; m++){\r\n                        stack.push(subStr[m])\r\n                    }\r\n                } else {\r\n                    let subStr = stack.slice(j + 2).join('').repeat(Number(stack[j]))\r\n                    let k = stack.length - 1\r\n                    while(k !== j - 1){\r\n                        stack.pop()\r\n                        k--;\r\n                    }\r\n                    for(let p = 0; p < subStr.length; p++){\r\n                        stack.push(subStr[p])\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999469754","body":"解题思路：\r\n\r\n用快慢指针先查找链表是否有环。\r\n如果有环，则从链表起点和快慢指针相遇点向前走，必然会在环的连接点相遇。\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  // 如果链表为空，或者链表只有一个元素且无环，此时指针无法行动，则返回null\r\n  if (!head || !head.next) {\r\n    return null;\r\n  }\r\n\r\n  // 创建快慢指针\r\n  let slow = head;\r\n  let fast = head;\r\n\r\n  // 如果快指针无法移动，则退出循环\r\n  while (fast && fast.next) {\r\n    // 慢指针走一步，快指针走两步\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n\r\n    // 如果两个指针的指向相同，则表示已经查找到环。\r\n    // 但两个指针相遇的节点不一定是环的连接点，而是在环的某个位置\r\n    if (slow === fast) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // 前面的退出循环条件有两个，一个是没有找到环，一个是找到了环\r\n  // 通过快慢指针是否相同，判断是否找到环，如果没有，则返回null\r\n  if (slow !== fast) {\r\n    return null;\r\n  }\r\n\r\n  // 如果有环，而且快指针的速度是慢指针的两倍。\r\n  // 因此如果创建两个指针，从链表起始点和快慢指针相遇节点分别出发。\r\n  // 两者相遇的节点必然是环的连接点。\r\n  let startNode = head;\r\n  let meetNode = fast;\r\n\r\n  // 遍历链表，查找连接点，如果两个指针相等，则表示找到连接点。\r\n  while (startNode !== meetNode) {\r\n    startNode = startNode.next;\r\n    meetNode = meetNode.next;\r\n  }\r\n\r\n  return meetNode;\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuezhongyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watchpoints":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994605321","body":"## 思路\n- 递归也是一种栈\n\n## 代码 \n\n~~~c++\nclass Solution {\npublic:\n    \n    string decodeString(string s) {\n        int i = 0;\n        return decodeString(s, i);\n    }\n    //递归 时间复杂度 O(N) 空间复杂度 O(N)\n    string decodeString(const string& s, int& i) {\n        string res;\n        \n        while (i < s.length() && s[i] != ']') {\n            if (!isdigit(s[i]))\n                res += s[i++];\n            else {\n                int n = 0;\n                while (i < s.length() && isdigit(s[i]))\n                    n = n * 10 + s[i++] - '0';\n                    \n                i++; // '['\n                string t = decodeString(s, i);\n                i++; // ']'\n                \n                while (n-- > 0)\n                    res += t;\n            }\n        }\n        \n        return res;\n    }\n};\n~~~","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997142798","body":"## 思路\n\n1. 倒数第k个节点\n2. 链表特点不是swap ，是移动\n\n## 代码 \n时间复杂度：O(n)\n~~~c++\nclass Solution {\npublic:\n   //小白视角分析\n    // 4,5 ---怎么右移 从最后面变成最前面位置。 1,2,3  怎么右移\n    // swap 还是移动 ？\n\n    //时间复杂度：O(n)，最坏情况下，我们需要遍历该链表两次 \n    //链表 不需要swap \n    \n    //初级视角分析：\n    //右移动 k 个位置 -->倒数第k个\n\n    //中级视角分析：链表 环形队列的引用是\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n        if (NULL == head || NULL == head->next){\n            return head;\n        } \n\n        //构造一个环形链表 \n        ListNode* ptemp = head;\n        int size = 1;//最后一个不计算长度\n        while (ptemp && ptemp->next )\n        {\n            ptemp = ptemp->next;\n            size ++;\n        } // ptemp ==last\n\n        ptemp->next = head;//loop\n\n        k = k % size;\n\n        // 倒数第k个 前面一个位置。单链表特点  之前做法 双指针 \n\n        while(  -- size >= k)\n        {\n             ptemp = ptemp->next;\n        }\n\n        ListNode* myhead = ptemp->next;\n        ptemp->next = NULL;\n\n        return myhead;\n    }\n};\n~~~\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998452798","body":"~~~c++\r\nclass Solution {\r\npublic:\r\n    //time f(n)=a+b+c=o(n) space  o(1)\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        \r\n        // 思路1 观察 链表倒序变量 ，如果不同就是上一个节点分开点。无法实现倒序遍历\r\n        // 思路2 直接2个指针 next移动。 根本不会相遇。 不一定对称结构\r\n        // 思路3： \r\n        /**为什么 a, b 指针相遇的点一定是相交的起始节点? 我们证明一下：\r\n\r\n将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C；\r\n\r\n当 a 指针将链表 1 遍历完后，重定位到链表 2 的头节点，然后继续遍历直至相交点，此时 a 指针遍历的距离为 A + C + B；\r\n\r\n同理 b 指针遍历的距离为 B + C + A；**/\r\n     \r\n     if (NULL == headA || NULL == headB )\r\n     {\r\n         return NULL;//不会相交\r\n     }\r\n\r\n     //前提：题目数据 保证 整个链式结构中不存在环。\r\n\r\n     ListNode* pa = headA;\r\n     ListNode* pb = headB;\r\n     //不是环形结构，缺打造一个环形结构。这里走一步 二步区分。\r\n     //A +B +C =C+B+A\r\n     while (pa != pb)\r\n     {\r\n         pa = pa ? pa->next:headB;\r\n         pb = pb ? pb->next:headA;\r\n     }\r\n     return pa;\r\n\r\n    }\r\n};\r\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999993874","body":"~~~c++\nstruct Node\n{\n    int key;\n    int value;\n    Node* pre ;\n    Node* next;\n};\nclass LRUCache {\nprivate:\n  map<int,Node*> hash;\n  Node* head;// 头节点插入\n  Node* tail;//wei节点删除\n  int size ;\n\npublic:\n    LRUCache(int capacity) {\n     \n      size = capacity;\n      \n      //为了减少if 判断各种异常情况. \n      head = new Node();\n      tail = new Node();\n\n      // head  tail\n      head->next = tail;\n      tail->pre =head;\n\n    }\n    \n    int get(int key) {\n\n        //01 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n        if (hash.count(key) == 0 )\n        {\n            return -1;\n        }\n        Node* ptemp = hash[key];\n        //02 调整优先级, 翻转链表\n        //head-1->2->tail \n        //head-2->1->tail \n         \n         //a: move\n          ptemp->pre->next = ptemp->next;\n          ptemp->next->pre =ptemp->pre;//!!!\n\n         //b: insert\n          ptemp->next = head->next;\n          head->next->pre = ptemp;\n\n          head->next = ptemp;\n          ptemp->pre= head;\n\n\n\n       return ptemp->value;\n    }\n    //插入一个元素\n    void put(int key, int value) \n    {\n        //01 如果关键字已经存在，则变更其数据值\n        if (hash.count(key) ==1 )\n        {    \n            // '[[2],[2,1],[2,2],[2],[1,1],[4,1],[2]]\n            //head-->2 --tail \n            Node* ptemp = hash[key];\n            ptemp->value =value;\n\n            //a: move\n            ptemp->pre->next = ptemp->next;\n            ptemp->next->pre =ptemp->pre;//!!!\n\n            //b: insert\n            ptemp->next = head->next;\n            head->next->pre = ptemp;\n\n            head->next = ptemp;\n            ptemp->pre= head;\n            return ;\n        }\n        //02 不能存在，就需要插入一个元素\n     \n        //a:创建一个元素\n        \n        Node* ptemp = new Node();\n        ptemp->key = key;\n        ptemp->value =value;\n\n        //b hash\n        hash[key] = ptemp;\n\n        //c:insert 新元素放前面\n\n         // head--> tail\n         //     1 \n         ptemp->next = head->next; //why !!!\n         head->next->pre = ptemp;\n\n         head->next = ptemp;\n         ptemp->pre = head;\n\n         if (hash.size() > size)\n         {\n           // 如果超出容量，删除双向链表的尾部节点.从最后面删除\n           //head-1->2->tail \n           \n           Node* plast = tail->pre;\n           hash.erase(plast->key);\n           //1-->tail\n            \n            plast->pre->next = tail;\n            tail->pre = plast->pre;\n\n\n         }\n\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001005255","body":"~~~c++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        \r\n        if(p ==nullptr && q ==nullptr)\r\n        {\r\n            return true; //对称\r\n        }\r\n\r\n        if(p ==nullptr || q ==nullptr)\r\n        {\r\n            return false;//不对称\r\n        }\r\n        if(q->val !=p->val)\r\n        {\r\n            return false;//内存不相等\r\n        }\r\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\r\n      \r\n\r\n    }\r\n};\r\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wanghuaikuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShuchenWuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoanyang":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991921146","body":"### 思路\n先反转数组，然后循环相加\n\n### 代码\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  let x1 = num.reverse();\n  let x2 = k.toString().split('').reverse();\n  let count = x1.length > x2.length?x1.length:x2.length;\n  let result = [];\n  let isAdd = false;\n  for(let i=0;i<count;i++){\n    let num1 = x1[i] || 0;\n    let num2 = x2[i] || 0;\n    let num = Number(num1) + Number(num2);\n    if(isAdd){\n      isAdd = false;\n      num+=1;\n    }\n\n    if(num>=10){\n      num -=10;\n      isAdd = true;\n    }\n    result.push(num)\n  }\n  if(isAdd){\n    result.push(1)\n  }\n  return result.reverse()\n};\n```\n\n### 复杂度\n时间复杂度 O(n),其中n为Max(num.length,k)\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymwang-2020":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Craig-Cheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weichuliao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"banjingking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"now915":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992071295","body":"- 算法\n```js\n function shortestToChar(s, c) {\n   let result = Array(s.length).fill(0)\n   let left = 0, right = 0, shortest = Infinity\n   for (let index = 0; index < s.length; index++) {\n      if (s[index] == c) continue\n\n      left = right = index\n      while (left >= 0 || right < s.length) {\n        if (s[left] == c) {\n          shortest = index - left\n          break\n        }\n        if (s[right] == c) {\n          shortest = right - index\n          break\n        }\n        left > 0 ? left-- : ''\n        right < s.length - 1 ? right++: ''\n      }\n     result[index] = shortest\n   }\n   return result\n }\n```\n- 时间复杂度\nO(n²)\n- 空间复杂度\nO(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996515092","body":"## 单调栈\r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n  let stack = []\r\n  for (let index = 0; index < arr.length; index++) {\r\n    if (stack.length && arr[index] < stack[stack.length - 1]) {\r\n      const cur = stack[stack.length - 1]\r\n      while (stack.length && arr[index] < stack[stack.length - 1]) {\r\n        stack.pop()\r\n      }\r\n      stack.push(cur)\r\n    } else {\r\n      stack.push(arr[index])\r\n    }\r\n  }\r\n  return stack.length\r\n};\r\n```\r\n- 空间复杂度 O(n)\r\n- 时间复杂度 O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000267440","body":"## 双向链表 + map\n``` js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map()\n    this.capacity = capacity\n    this.head = new ListNode()\n    this.tail = new ListNode()\n    this.head.next = this.tail\n    this.tail.prev = this.head\n};\n\n/**\n * node\n */\nvar ListNode = function(key, val) {\n    this.key = key\n    this.value = val\n    this.next = null\n    this.prev = null\n} \n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.map.has(key)) return -1\n    let node = this.map.get(key)\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    this.insertTail(node)\n    return node.value\n};\n\nLRUCache.prototype.insertTail = function(node) {\n    this.tail.prev.next = node\n    node.prev = this.tail.prev\n    node.next = this.tail\n    this.tail.prev = node\n}\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        let node = this.map.get(key)\n        node.value = value\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        this.insertTail(node)\n    } else {\n        if (this.map.size == this.capacity) {\n            let lastNode = this.head.next\n            this.head.next = this.head.next.next\n            this.head.next.prev = this.head\n            this.map.delete(lastNode.key)\n        }\n        let node  = new ListNode(key, value)\n        this.map.set(key, node)\n        this.insertTail(node)\n    }\n};\n\n```\n- 时间复杂度 O(1)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000681714","body":"## dfs\n```js\nvar maxDepth = function(root) {\n    if (!root) return 0\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\n};\n```\n- 时间复杂度 O(n)\n- 空间复杂度 O(height)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"akxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cdd111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997169893","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        head_copy = head\r\n        n = 1\r\n        while head_copy.next:\r\n            head_copy = head_copy.next\r\n            n += 1\r\n            \r\n        if k%n == 0:\r\n            return head\r\n        \r\n        head_copy = head\r\n        acc = 1\r\n        while head_copy.next:\r\n            if acc == n-k%n:\r\n                new_head = head_copy.next\r\n                head_copy.next = None\r\n            else: \r\n                head_copy = head_copy.next\r\n                acc += 1\r\n        help_head = new_head\r\n        while help_head.next:\r\n            help_head = help_head.next\r\n        help_head.next = head\r\n        return new_head\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999278369","body":"```\r\nclass Solution:\r\n    \r\n    def getIntersect(self, head):\r\n        fast, slow = head, head\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return None\r\n        \r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if not slow or not fast:\r\n                return None\r\n            if slow == fast:\r\n                return slow\r\n        return None\r\n        \r\n        \r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        slow = self.getIntersect(head)\r\n        fast = head\r\n        if slow == None:\r\n            return None\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast\r\n```\r\ntime O(n), space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999982070","body":"```\r\nclass DLinkedNode(): \r\n    def __init__(self):\r\n        self.key = 0\r\n        self.value = 0\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    \r\n    def _add_node(self, node):\r\n        \"\"\"\r\n        \"\"\"\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        \r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def _remove_node(self, node):\r\n        prev = node.prev\r\n        new = node.next\r\n        \r\n        prev.next = new\r\n        new.prev = prev\r\n    \r\n    def _move_to_head(self, node):\r\n        self._remove_node(node)\r\n        self._add_node(node)\r\n        \r\n    def _pop_tail(self):\r\n        res = self.tail.prev\r\n        self._remove_node(res)\r\n        return res\r\n    \r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = {}\r\n        self.size = 0\r\n        self.capacity = capacity\r\n        self.head, self.tail = DLinkedNode(), DLinkedNode()\r\n\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        \r\n        node = self.cache.get(key, None)\r\n        if not node:\r\n            return -1\r\n\r\n        # move the accessed node to the head;\r\n        self._move_to_head(node)\r\n\r\n        return node.value\r\n        \r\n        \r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        \r\n        node = self.cache.get(key)\r\n\r\n        if not node: \r\n            newNode = DLinkedNode()\r\n            newNode.key = key\r\n            newNode.value = value\r\n\r\n            self.cache[key] = newNode\r\n            self._add_node(newNode)\r\n\r\n            self.size += 1\r\n\r\n            if self.size > self.capacity:\r\n                # pop the tail\r\n                tail = self._pop_tail()\r\n                del self.cache[tail.key]\r\n                self.size -= 1\r\n        else:\r\n            # update the value.\r\n            node.value = value\r\n            self._move_to_head(node)\r\n```\r\ntime O(1), space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000727439","body":"```\r\n    def maxDepthHelper(self, root, heights, height):\r\n        if root:\r\n            height += 1\r\n            heights.append(height)\r\n            self.maxDepthHelper(root.left, heights, height)\r\n            self.maxDepthHelper(root.right, heights, height)\r\n            \r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        heights = []\r\n        self.maxDepthHelper(root, heights, 0)\r\n        return max(heights, default=0)\r\n```\r\ntime O(n) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000997979","body":"```\r\nclass Solution:\r\n    \r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        \r\n        if not p and q:\r\n            return False\r\n        if p and not q:\r\n            return False\r\n        if not p and not q:\r\n            return True\r\n        else:\r\n            l = self.isSameTree(p.left, q.left)\r\n            r = self.isSameTree(p.right, q.right)\r\n        return l&r&(p.val==q.val)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001101944","body":"```\r\nclass Solution:\r\n    def sumNumbersHelper(self, root, value, values):\r\n        if root:\r\n            value = value*10 + root.val\r\n            if root.left:\r\n                self.sumNumbersHelper(root.left, value, values)\r\n            if root.right:\r\n                self.sumNumbersHelper(root.right, value, values)\r\n            if not root.left and not root.right:\r\n                values.append(value)\r\n                \r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        values = []\r\n        value = 0\r\n        self.sumNumbersHelper(root, value, values)\r\n        return sum(values)\r\n```\r\ntime O(N), space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whitewhatpin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liudi9047":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guohuijiedesu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzyhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yourspeace":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thisjustsoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ozhfo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995957695","body":"### 思路\n\n* 双栈 直接入栈 直接出栈 如果没有元素了从入栈那边一次性倒腾过来\n\n### 代码\n\n```java\nclass MyQueue {\n    Stack<Integer> out, in;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        }\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n\n\n/**\n\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n   */\n```\n\n### 复杂度\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997186827","body":"\n\n### 思路\n\n* 空链表返回 \n\n* 实际只需要翻转 k % length次 如果k为0 刚好恢复原样 返回\n\n* > 1 2 3 4 5 k = 2\n  >\n  > 4 5 1 2 3\n  >\n  > 可以发现需要找到的是3这个点 也就是 lenth - k 这个点X\n  >\n  > 然后X.next作为头结点 X的尾巴指向head\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        // 算出链表长度length  实际只需要翻转  length % k 次\n        int length = 0;\n        ListNode p = head;\n        while(p != null){\n            p = p.next;\n            length ++;\n        }\n        // 链表为空 或者刚好恢复原样\n        if(length == 0 || k % length == 0) return head;\n        k = k % length;\n        // 真正开始翻转\n        // 1.找到待翻转的点的前一个点X lenght - k\n        // 2.然后X作为head X的尾巴指向head\n        p = head;\n        int index = 1;\n        while(index < length - k){\n            p = p.next;\n            index ++;\n        }\n        // 找到新的头结点\n        ListNode newHead = p.next;\n        p.next = null;\n        // 处理尾巴\n        p = newHead;\n        while(p.next != null){\n            p = p.next;\n        }\n        p.next = head;\n        return newHead;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998096992","body":"\n\n### 思路\n\n* 太呆了 只想到了栈的做法 两个链表都倒过来 然后依次取就找到相交的点了\n* 不过白板一次过了还不错\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null){\n            return null;\n        }\n        Stack<ListNode> stackA = new Stack();\n        ListNode preA = headA;\n        while(preA != null){\n            stackA.push(preA);\n            preA = preA.next;\n        }\n    \n        Stack<ListNode> stackB = new Stack();\n        ListNode preB = headB;\n        while(preB != null){\n            stackB.push(preB);\n            preB = preB.next;\n        }\n        // 然后一起出栈\n        ListNode result = null;\n        while(!stackA.isEmpty() && !stackB.isEmpty()){\n            preA = stackA.pop();\n            preB = stackB.pop();\n            if(preA == preB){\n                result = preA;\n            }else{\n                break;\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度\n\n- 时间复杂度: O(m+n)\n- 空间复杂度: O(m+n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yyangeee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pan-qin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Crazy-xjm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"grapefruit-hellomonday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandaCure":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"panda-qin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihanchenyuhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangxiaohan05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ru8dgj0001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taoyr722":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raoshuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuangaa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blanktime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iceburgs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xlzy520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vaqua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dahuang257":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuichen17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsgouwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kkwu314":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991891441","body":"# 思路 1\n\n\n\n<aside> 💡 新建一个List<Integer>，从num的最右边的元素开始加。将超出个位数的remainder继续加到被/10的k上。将计算过的sum加入到List里。最后将剩余k加入list里然后reverse List\n\n</aside>\n\n# 代码\n\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i=n-1; i>=0; i--){\n            int sum = num[i]+k%10;\n            k/=10;\n            if (sum>=10){\n                k+=sum/10;\n                sum%=10;\n            }\n            ans.add(sum);\n        }\n        for (;k>0;k/=10){\n            ans.add(k%10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```\n\n# 复杂度分析\n\n\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)\n\n# 思路 2\n\n\n\n<aside> 💡 和上一种类似，但是直接将num[i]加到k中，再将k的个位数加到arr里\n\n</aside>\n\n# 代码\n\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i=n-1; i>=0 || k>0; i--,k/=10){\n            if (i>=0){\n                k+=num[i];\n            }\n            ans.add(k%10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度：O(N) *O*(max(*n*,log*k*))\n\n空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997217023","body":"## 思路\n\n1. 计算链表总长，简化k，最终新head为第(n-n%k) 个节点 \n2. 链表成环，从原链最后开始数new_k个，该节点的后一节点应为新链的head，从该节点断开\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k==0 || head==null || head.next==null){\n            return head;\n        }\n\n        int n=1;\n        ListNode cur=head;\n        while(cur.next!=null){\n            cur=cur.next;\n            n++;\n        }\n\n        int new_k=n-k%n;\n        if (new_k==n){\n            return head;\n        }\n        cur.next = head;\n        while(new_k-->0){\n            cur = cur.next;\n        }\n        ListNode new_head = cur.next;\n        cur.next = null;\n\n        return new_head;\n\n    }\n}\n```\n\n## 复杂度\n\n时间：O(N)\n\n空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carsonlin9996":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niuyibo0619":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996682151","body":"**思路**  \n\n* 遍历一遍数组，动态判断到目前为止能分出几个排序块，将每个块的最大值压入栈中，最终栈的长度即排序块的数量。  \n\n**代码**  \n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if len(stack)==0:\n                stack.append(i)\n            elif i >= stack[-1]:\n                stack.append(i)\n            elif i < stack[-1]:\n                    head = stack.pop()\n                    while len(stack) > 0:\n                        if i < stack[-1]:\n                            stack.pop()\n                        else:\n                            break\n                    stack.append(head)\n        return len(stack)\n```\n**复杂度**\n* 时间复杂度：O(n)，n=len(arr)\n* 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997208786","body":"**思路**\n* 先将链表闭合成环，再找到指定位置断开  \n\n**代码**\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 如果链表无节点或只有一个节点，返回head\n        if not head or not head.next:\n            return head\n        \n        n = 1   # 记录链表长度\n        p = head\n        while p.next:\n            p = p.next\n            n += 1\n\n        # k超过链表长度时相当于重置链表\n        rot = n - k % n   \n        if rot == n:\n            return head\n        \n        p.next = head  # 把链表尾部连上头\n        while rot:     # 找断开的点\n            p = p.next\n            rot -= 1\n        \n        res = p.next   # 新的起点\n        p.next = None  # 断开环\n        return res\n```\n**复杂度**\n* 时间复杂度：O(n)，n为链表长度\n* 空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000695822","body":"**思路**\n* 深度优先搜索，递归获得左右子树的深度\n\n**代码**\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return 1 + max(left_depth, right_depth)\n```\n**复杂度**\n* 时间复杂度：O(N),N为节点个数\n* 空间复杂度：O(depth), depth为树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chakochako":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991807958","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num1 = int(''.join(map(str,num)))\n        return list(map(int,list(str(num1+k))))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991999343","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        for p, v in enumerate(s):\n            if v == c:\n                prev = p\n            ans.append(p - prev)\n\n        prev = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: \n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994889788","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        multi = 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995934290","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997224375","body":"```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997224962","body":"```python\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997421075","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getLength(head: ListNode) -> int:\n            ret = 0\n            while head:\n                ret += 1\n                head = head.next\n            return ret\n        \n        def buildTree(left: int, right: int) -> TreeNode:\n            if left > right:\n                return None\n            mid = (left + right + 1) // 2\n            root = TreeNode()\n            root.left = buildTree(left, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = buildTree(mid + 1, right)\n            return root\n        \n        length = getLength(head)\n        return buildTree(0, length - 1)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998896709","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        PA, PB = headA, headB\n        while not PA == PB:\n            if not PA:\n                PA = headB\n            else:\n                PA = PA.next\n            if not PB:\n                PB = headA\n            else:\n                PB = PB.next\n            \n        return PA\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999708375","body":"```python\nclass DlinkNode:\n    def __init__(self,key = 0,value = 0) :\n        self.value = value\n        self.key = key\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.head = DlinkNode()\n        self.tail = DlinkNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n  \n\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache.get(key)\n        self.moveToHead(node)\n        return node.value\n    \n\n\n\n\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DlinkNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size = self.size + 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size = self.size - 1\n        else:\n            node = self.cache.get(key)\n            node.value = value\n            self.moveToHead(node)\n\n      \n\n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n        \n\n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000873195","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        leftMax = self.maxDepth(root.left)\n        leftRight = self.maxDepth(root.right)\n        return 1 + max(leftMax, leftRight)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001024739","body":"```python\nclass Solution:\n\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996737414","body":"# 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n# 复杂度\n时间复杂度：O(nlog(n))\n\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997947781","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998741755","body":"```java\npublic class Solution {\n     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = null==a ? headB : a.next;\n            b = null==b ? headA : b.next;\n        }\n        return a;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000961127","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sogatechnology":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ariel-mu3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sugar666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liwangping":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cecilialmw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ph2200":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yunomin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993099154","body":"##### python\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.space_left = maxSize\n        self.l = []\n\n    def push(self, x: int) -> None:\n        if self.space_left > 0:\n            self.l.append(x)\n            self.space_left -= 1\n\n    def pop(self) -> int:\n        if len(self.l) > 0:\n            self.space_left += 1\n            return self.l.pop(-1)\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.l))):\n            self.l[i] += val\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998255343","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \n        s = set()\n        node = headA\n        while node:\n            s.add(node)\n            node = node.next\n        \n        node = headB\n        while node:\n            if node in s: return node\n            node = node.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hinancy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guochiscoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shibingchao123":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995412938","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            self.stack2 = self.stack1[::-1]\r\n            self.stack1 = []\r\n            return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        elif self.stack1:\r\n            return self.stack1[0]\r\n\r\n    def empty(self) -> bool:\r\n        if (not self.stack1) and (not self.stack2):\r\n            return True\r\n        else:\r\n            return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yukicoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lhjzuibang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nadostars":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xitice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997344206","body":"class Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        pre = ListNode(0)\r\n        pre.next = head\r\n        cur = pre\r\n        while cur and cur.next and cur.next.next:\r\n            first = cur.next\r\n            second = cur.next.next\r\n            # swap\r\n            first.next = second.next\r\n            second.next = first        \r\n            cur.next = second\r\n            cur = cur.next.next\r\n        return pre.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997683031","body":"class Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(head: ListNode) -> int:\r\n            ret = 0\r\n            while head:\r\n                ret += 1\r\n                head = head.next\r\n            return ret\r\n        \r\n        def buildTree(left: int, right: int) -> TreeNode:\r\n            if left > right:\r\n                return None\r\n            mid = (left + right + 1) // 2\r\n            root = TreeNode()\r\n            root.left = buildTree(left, mid - 1)\r\n            nonlocal head\r\n            root.val = head.val\r\n            head = head.next\r\n            root.right = buildTree(mid + 1, right)\r\n            return root\r\n        \r\n        length = getLength(head)\r\n        return buildTree(0, length - 1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998584456","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        if headA is None or headB is None:\r\n            return null\r\n        pointA = headA\r\n        pointB = headB\r\n        while pointA != pointB:\r\n            if pointA is None:\r\n                pointA = headB\r\n            else:\r\n                pointA = pointA.next \r\n            if pointB is None:\r\n                pointB = headA\r\n            else:\r\n                pointB = pointB.next\r\n        return pointB","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999357483","body":"class Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000105582","body":"class LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000663830","body":"class Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root is None:\r\n            return 0\r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        return max(left, right)+1\r\n     ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000989955","body":"class Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"razor1895":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"famine330":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsu-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yxq1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zbqnb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xjlgod":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bai170":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nerrolk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bpointa":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991859929","body":"### 思路\n\n模拟竖式计算，新的一期打算开始试着用Java实现，自己不习惯Java，思路还是在Python上的思路，感觉实现得有点粗糙\n\n### Java代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n      ArrayList<Integer> klist=new ArrayList<>();\n      ArrayList<Integer> nums=new ArrayList<>();\n      for (int n:num)\n      {\n          nums.add(n);\n      }\n      while (k>0)\n      {\n          klist.add(0,k%10);\n          k=k/10;\n      }\n      int a=klist.size();\n      int b=nums.size();\n    if(a<b)\n    {\n        for (int i1=0;i1<b-a;i1++)\n        {\n            klist.add(0,0);\n        }\n    }\n    else if(b<a)\n    {\n        for (int i2=0;i2<a-b;i2++)\n        {\n            nums.add(0,0);\n        }\n    }\n  \n      ArrayList<Integer> ans=new ArrayList<>();\n      int saving=0;\n      for (int i=nums.size()-1;i>=0;i--)\n      {\n          int tmp=saving+klist.get(i)+nums.get(i);\n          ans.add(0,tmp%10);\n          saving=tmp/10 ;\n      }\n      if(saving>0)\n      {\n          ans.add(0,saving);\n      }\n\n    \n\n      \n      return ans;\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992089496","body":"### 思路\r\n\r\n两边各自遍历\r\n\r\n### Java代码\r\n```Java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l=s.length();\r\n        int idx1=-l,idx2=l*2;\r\n        int [] ans=new int[s.length()];\r\n        for (int i=0;i<l;i++)\r\n        {ans[i]=l+1;}\r\n        for (int i1=0;i1<s.length();i1++)\r\n        {\r\n            if(s.charAt(i1)==c)\r\n            {ans[i1]=0;\r\n            idx1=i1;\r\n            }\r\n            int tmp=i1-idx1;\r\n            if(tmp<ans[i1])\r\n            {ans[i1]=tmp;}\r\n\r\n        }\r\n        for (int i2=s.length()-1;i2>=0;i2--)\r\n        {\r\n            if(s.charAt(i2)==c)\r\n            {ans[i2]=0;\r\n            idx2=i2;\r\n            }\r\n            int tmp=idx2-i2;\r\n            if(tmp<ans[i2])\r\n            {ans[i2]=tmp;}\r\n\r\n        }\r\n        return ans;\r\n            }\r\n}\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993464394","body":"### 思路\n\n纯模拟\n\n### Java\n\n```Java\n\nclass CustomStack {\nList<Integer> cs;\nint tmp;\nint lim;\n    public CustomStack(int maxSize) {\n        cs=new ArrayList(); \n        tmp=0;\n        lim=maxSize;\n\n    }\n    \n    public void push(int x) {\n        if(this.tmp==this.lim)\n        {\n            return ;\n        }\n        cs.add(x);\n        tmp+=1;\n    }\n    \n    public int pop() {\n        if(tmp==0)\n        {return -1;}\n        \n        int ans=cs.get(tmp-1);\n        cs=cs.subList(0,tmp-1);\n        tmp-=1;\n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        int to_add=k;\n        if(tmp<k)\n        {to_add=tmp;}\n\n        for (int i=0;i<to_add;i++)\n        {\n            cs.set(i,cs.get(i)+val);\n        }\n         \n        \n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994170223","body":"### 思路\n\n递归\n\n### Java代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        int left=0;\n        for (int i=0;i<s.length();i++)\n        {\n            char c=s.charAt(i);\n            if(c=='[')\n            {\n             left=i;\n            }\n            if(c==']')\n            {\n                int j=left-1;\n                while(j>=0 && Character.isDigit(s.charAt(j)))\n                {j-=1;}\n                int cnt=Integer.valueOf(s.substring(j+1,left));\n                String new_String=s.substring(0,j+1);\n                \n                new_String+=s.substring(left+1,i).repeat(cnt);\n                \n                new_String+=s.substring(i+1,s.length());\n                return decodeString(new_String);\n\n            }\n        }\n        return s;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995918859","body":"### 思路\n\n一个记录进，一个记录出\n\n### 代码\n```Java\nclass MyQueue {\n    Stack<Integer> stk1;\n    Stack<Integer> stk2;\n\n    public MyQueue() {\n\nstk1=new Stack<>();\nstk2=new Stack<>();\n\n    }\n    \n    public void push(int x) {\n        stk1.push(x);\n\n    }\n    \n    public int pop() {\n        if(stk2.size()>0)\n        {return stk2.pop();}\n        while(stk1.size()>0)\n        {\n            int x=stk1.pop();\n            stk2.push(x);\n        }\n        return stk2.pop();\n\n    }\n    \n    public int peek() {\n        if(stk2.size()>0)\n        {return stk2.peek();}\n        while(stk1.size()>0)\n        {\n            int x=stk1.pop();\n            stk2.push(x);\n        }\n        return stk2.peek();    }\n    \n    public boolean empty() {\n        return stk1.size()==0 && stk2.size()==0;\n\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996347680","body":"### 思路\nmax+max_count构成组合进行比较\n\n### 代码\n``` Java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int [] new_arr=new int[arr.length];\n        int m0=-1,m0_count=0,m1=-1,m1_count=0;\n        System.arraycopy(arr,0,new_arr,0,arr.length);\n        Arrays.sort(new_arr);\n        int cnt=0;\n        for (int i=0;i<arr.length;i++)\n        {\n            if (new_arr[i]!=m0)\n            {\n                m0=new_arr[i];\n                m0_count=1;\n            }\n            else\n            {\n                m0_count+=1;\n            }\n            if (arr[i]==m1)\n            {\n                m1_count+=1;\n            }\n            else if (arr[i]>m1)\n            {\n                m1=arr[i];\n                m1_count=1;            \n            }\n         if (m0==m1 && m0_count==m1_count)\n         {cnt+=1;}\n        \n        \n\n        }\n        return cnt;\n\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997189921","body":"### 思路\r\n\r\n算的长度之后计数需要挪的步数\r\n\r\n### 代码\r\n```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        ListNode tmp=head;\r\n        ListNode pre=new ListNode();\r\n        pre.next=tmp;\r\n        int l=0;\r\n        while(tmp!=null)\r\n        {l+=1;\r\n        tmp=tmp.next;}\r\n        if(l==0)\r\n        {return null;}\r\n        k=k%l;\r\n        if(k==0)\r\n        {return head;}\r\n        int target=l-k;\r\n        tmp=head;\r\n        for(int i=0;i<target;i++)\r\n        {pre=tmp;\r\n            tmp=tmp.next;}\r\n        ListNode nxt=tmp;\r\n        pre.next=null;\r\n \r\n        while(nxt.next!=null)\r\n        {\r\n            nxt=nxt.next;\r\n        }\r\n        nxt.next=head;\r\n        return tmp;\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997341367","body":"### 思路\r\n递归\r\n\r\n###  代码\r\n``` Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null || head.next==null)\r\n        {return head;}\r\n        ListNode first=head;\r\n        ListNode second=head.next;\r\n        ListNode third=head.next.next;\r\n        second.next=first;\r\n        first.next=swapPairs(third);\r\n        return second;\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997937584","body":"### 思路\n\n快慢链表取中点，再利用递归建树\n\n### 代码\n```Java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null)\n        {return null;}\n        if(head.next==null)\n        {TreeNode t=new TreeNode(head.val);\n            return t;}\n        ListNode quick=head;\n        ListNode slow=head; \n        ListNode pre=null;\n        while(quick!=null && quick.next!=null)\n        {\n            quick=quick.next.next;\n            pre=slow;\n            slow=slow.next;\n\n        }\n        pre.next=null;\n        TreeNode t=new TreeNode(slow.val);\n        TreeNode lft=sortedListToBST(head);\n        TreeNode right=sortedListToBST(slow.next);\n        t.left=lft;\n        t.right=right;\n        return t;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998659944","body":"### 思路\r\n\r\n分别做两个指针，从开头开始走，如果到一边的结尾则去另一边的开头\r\n\r\n### Java代码\r\n``` Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a=headA;\r\n        ListNode b=headB;\r\n        int check=0;\r\n        while(a!=b)\r\n        {       \r\n        if (a.next==null)\r\n        {\r\n            if(check==2)\r\n            {return null;}\r\n            check+=1;\r\n            a=headB;\r\n        }\r\n        else\r\n        {\r\n            a=a.next;\r\n        }\r\n        if (b.next==null)\r\n        {\r\n            if(check==2)\r\n            {return null;}\r\n            check+=1;\r\n            b=headA;\r\n        }\r\n        else\r\n        {\r\n            b=b.next;\r\n        }\r\n        }\r\n    return a;\r\n    \r\n}\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999463322","body":"### 思路\n\n快慢链表\n\n### 代码\n``` Java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null || head.next==null)\n        {\n            return null;\n        }\n        ListNode quick=head.next.next;\n        ListNode slow=head.next;\n        int flag=0;\n        while(quick!=null && quick.next!=null)\n        {\n            if (quick==slow)\n            {flag=1;\n            break;}\n            quick=quick.next.next;\n            slow=slow.next;\n        }\n        if(flag==0)\n        {return null;}\n        slow=head;\n        while(slow!=quick)\n        {\n            slow=slow.next;\n            quick=quick.next;\n        }\n        return slow;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000300024","body":"### 思路\r\n\r\n建立链表\r\n\r\n### Java代码\r\n``` Java\r\nclass Node{\r\n    int key;\r\n    int val;\r\n    Node pre;\r\n    Node next;\r\n    public Node(int key,int val)\r\n    {\r\n        this.key=key;\r\n        this.val=val;\r\n    }\r\n}\r\n\r\n\r\nclass LRUCache {\r\n\r\n    Node head;\r\n    Node tail;\r\n    int capacity;\r\n    HashMap<Integer,Node> d;\r\n    public LRUCache(int capacity) {\r\n        this.head=new Node(0,0);\r\n        this.tail=new Node(0,0);\r\n        this.head.next=this.tail;\r\n        this.tail.pre=this.head;\r\n        this.capacity=capacity;\r\n        this.d=new HashMap<>();\r\n\r\n    }\r\n    public void add_point(Node n)\r\n    {\r\n        this.tail.pre.next=n;\r\n        n.pre=this.tail.pre;\r\n        this.tail.pre=n;\r\n        n.next=this.tail;\r\n    }\r\n    public void remove_point(Node n)\r\n    {\r\n        n.pre.next=n.next;\r\n        n.next.pre=n.pre;\r\n    }\r\n    public void move_point(Node n)\r\n    {\r\n        this.remove_point(n);\r\n        this.add_point(n);\r\n    }\r\n    public int get(int key) {\r\n        if(this.d.get(key)==null)\r\n        {return -1;}\r\n        move_point(this.d.get(key));\r\n        return this.d.get(key).val;\r\n\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(this.d.get(key)!=null)\r\n        {\r\n            this.d.get(key).val=value;\r\n            this.move_point(this.d.get(key));\r\n        }\r\n        else\r\n        {\r\n            if(this.d.size()==this.capacity)\r\n            {\r\n                Node nd=this.head.next;\r\n                this.d.remove(nd.key);\r\n                this.remove_point(nd);\r\n            }\r\n            Node n=new Node(key,value);\r\n            this.add_point(n);\r\n            this.d.put(key,n);\r\n        }\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000400049","body":"### 思路\n\n递归\n\n### Java代码\n``` Java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null)\n        {return 0;}\n        if(root.left==null && root.right==null)\n        {return 1;}\n        int a=maxDepth(root.left);\n        int b=maxDepth(root.right);\n        if(a>b)\n        {return 1+a;}\n        return 1+b;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000890617","body":"### 思路\n\n递归\n\n### JAVA代码\n```JAVA\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null)\n        {\n            return true;\n        }\n        else if(p==null && q!=null)\n        {\n            return false;\n        }\n        else if(p!=null && q==null)\n        {\n            return false;\n        }\n        else\n        {\n            if(p.val!=q.val)\n            {\n                return false;\n            }\n            return (isSameTree(p.left,q.left) && isSameTree(p.right,q.right));\n        }\n\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001041739","body":"### 思路\n\nDFS\n\n### JAVA代码\n```JAVA\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if(root==null)\n        {\n            return 0;\n        }\n        int ans=0;\n        Stack<TreeNode> stk=new Stack();\n        Stack<Integer> vals=new Stack(); \n        stk.push(root);\n        vals.push(root.val);\n        while(stk.size()>0)\n        {\n            TreeNode p=stk.pop();\n            int v=vals.pop();\n            if(p.left==null && p.right==null)\n            {\n                ans+=v;\n            }\n            if(p.left!=null)\n            {\n                stk.push(p.left);\n                vals.push(v*10+p.left.val);\n            }\n            if(p.right!=null)\n            {\n                stk.push(p.right);\n                vals.push(v*10+p.right.val);\n            }\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994253341","body":"### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        Stack<Integer> numStack = new Stack<>();\n        Stack<String> strStack = new Stack<>();\n        int multi = 0;\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                numStack.push(multi);\n                strStack.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int curMulti = numStack.pop();\n                for(int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(strStack.pop() + tmp);\n            } else if(c >= '0' && c <= '9') {\n                multi = multi * 10 + Integer.parseInt(c + \"\");\n            } else {\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995463189","body":"### 代码\n```java\nclass MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        dumpInStack();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        dumpInStack();\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return outStack.isEmpty() && inStack.isEmpty();\n    }\n    \n    private void dumpInStack() {\n        if(outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996416674","body":"### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < arr.length; i++) {\n            int num = arr[i];\n            int tmp = -1;\n            while(!stack.isEmpty() && stack.peek() > num) {\n                tmp = Math.max(stack.pop(), tmp);\n            }\n            if(tmp == -1) {\n                stack.push(num);\n            } else {\n                stack.push(tmp);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997132109","body":"### 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int len = 1;\n        ListNode index = head;\n        while(index.next != null) {\n            index = index.next;\n            len++;\n        }\n        index.next = head;\n        for(int i = 1; i < len - k % len; i++) {\n            head = head.next;\n        }\n        ListNode res = head.next;\n        head.next = null;\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997330558","body":"### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        ListNode cur = head;\n        while(cur != null && cur.next != null) {\n            ListNode nextStart = cur.next.next;\n            pre.next = cur.next;\n            cur.next.next = cur;\n            cur.next = nextStart;\n            pre = cur;\n            cur = cur.next;\n        }\n        return dummy.next;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997614189","body":"### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return toBST(head, null);\n    }\n    \n    private TreeNode toBST(ListNode head, ListNode tail) {\n        if(head == tail) return null;\n        ListNode slow = head, fast = head;\n        while(fast != tail && fast.next != tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = toBST(head, slow);\n        root.right = toBST(slow.next, tail);\n        return root;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998414116","body":"### 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA, b = headB;\n        while(a != b) {\n            if(a == null) {\n                a = headB;\n            } else {\n                a = a.next;\n            }\n            if(b == null) {\n                b = headA;\n            } else {\n                b = b.next;\n            }\n        }\n        return a;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999307142","body":"### 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return head;\n        ListNode fast = head, slow = head;\n        while(fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if(slow == fast) {\n                ListNode newSlow = head;\n                while(newSlow != slow) {\n                    newSlow = newSlow.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999940899","body":"### 代码\n```java\nclass LRUCache {\n    private Map<Integer, Node> map;\n    private int capacity;\n    private int count;\n    private Node head;\n    private Node tail;\n    \n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        this.capacity = capacity;\n        count = 0;\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.pre = head;\n        head.pre = null;\n        tail.next = null;\n    }\n    \n    public int get(int key) {\n        if(map.get(key) != null) {\n            Node node = map.get(key);\n            int val = node.val;\n            deleteNode(node);\n            addToHead(node);\n            return val;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if(map.get(key) != null) {\n            Node node = map.get(key);\n            node.val = value;\n            deleteNode(node);\n            addToHead(node);\n        } else {\n            Node node = new Node(key, value);\n            map.put(key, node);\n            if(count < capacity) {\n                count++;\n                addToHead(node);\n            } else {\n                map.remove(tail.pre.key);\n                deleteNode(tail.pre);\n                addToHead(node);\n            }\n        }\n    }\n    \n    private void deleteNode(Node node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n    \n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.next.pre = node;\n        node.pre = head;\n        head.next = node;\n    }\n}\n\nclass Node {\n    int key;\n    int val;\n    Node next;\n    Node pre;\n    public Node(int key, int val) {\n        this.key = key;\n        this.val = val;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000951563","body":"```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001110115","body":"```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return helper(root, 0);\n    }\n    \n    private int helper(TreeNode root, int num) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) {\n            return num * 10 + root.val;\n        }\n        return helper(root.left, num * 10 + root.val) + helper(root.right, num * 10 + root.val);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(depth)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zz10044":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"menglin-l":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991822250","body":"### 思路：\r\n#### 1.将k与num的最后一位(size - 1)数字相加，然后把得到的结果与10取模，便是数组新的最后一位，将其存入原数组中最后一位。\r\n#### 2.将1中的k与10取余，去掉个位，再与num的(size - 2)位相加，重复1过程。\r\n#### 3.利用LinkedList特性插入元素，直接返回最终结果，不需要再翻转。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> ans = new LinkedList<>();\r\n        \r\n        int sum = 0, carry = 0, len = num.length - 1;\r\n        \r\n        while (len >= 0 || k != 0) {\r\n            int x = len >= 0 ? num[len] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            \r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            \r\n            k /= 10;\r\n            len --;\r\n            \r\n            ans.addFirst(sum % 10);\r\n        }\r\n        \r\n        if (carry != 0) ans.addFirst(carry);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### Time: O(N)\r\n#### Space: O(1), 长度为26的数组算作常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991968203","body":"#### 1. Determine the distance to the nearest c on the left. \r\n####     Traverse s from left to right and count the index from the maximum, the size of s, as the distance. \r\n####     Increase the next index by one. If c occurs, change the distance to zero.\r\n#### 2. Determine the distance to the nearest c on the right.\r\n####     Traverse s from right to left. Count the index and compare it with the previous value, then take the minimum. \r\n---\r\n\r\n```Java\r\nclass Solution {\r\n    // s = \"l  o  v  e  l  e  e  t  c  o  d  e\", c = \"e\", s.length() = 12\r\n    //     12 13 14  0  1  0  0  1  2  3  4  0 \r\n    //      3  2  1  0  1  0  0  1  2  2  1  0\r\n    public int[] shortestToChar(String s, char c) {\r\n        if (s.length() == 1) return new int[]{0};\r\n        \r\n        char[] cc = s.toCharArray();// O(N)\r\n        int[] res = new int[s.length()];// O(N)\r\n        int disLeft = s.length();\r\n        int disRight = s.length();\r\n        \r\n        // O(N)\r\n        for (int i = 0; i < cc.length; i ++) {\r\n            if (cc[i] == c) {\r\n                disLeft = 0;\r\n            }\r\n            res[i] = disLeft;\r\n            disLeft ++;\r\n        }\r\n        \r\n        // O(N)\r\n        for (int j = cc.length - 1; j >= 0; j --) {\r\n            if (cc[j] == c) {\r\n                disRight = 0;\r\n            }\r\n            res[j] = Math.min(res[j], disRight);\r\n            disRight ++;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### Time: O(N)\r\n#### Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993295182","body":"### Thoughts:\r\n#### Use an array to denote that arr[i] represents the increment applied to all elements from stack[0, ..., i] or from the bottom element to the ith element.\r\n---\r\n### Code:\r\n```Java\r\nclass CustomStack {\r\n    Stack<Integer> stack = new Stack<>();\r\n    int[] additions;\r\n    int maxSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.additions = new int[maxSize + 1];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        // edge case: stack is full at maxSize\r\n        if (stack.size() == maxSize)\r\n            return;\r\n        // push val into stack\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // edge case: stack is empty\r\n        if (stack.isEmpty())\r\n            return -1;\r\n        \r\n        // get addition amount for next num and erase it from arr\r\n        int amount = additions[stack.size()];\r\n        additions[stack.size()] = 0;\r\n        \r\n        // add amount to item below next val\r\n        additions[stack.size() - 1] += amount;\r\n        \r\n        return stack.pop() + amount;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        // add val to kth index\r\n        additions[Math.min(k, stack.size())] += val;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### Complexity:\r\n#### Time: O(1) for pop and push; O(N) for increment\r\n#### Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993908961","body":"#### thoughts: Using two stacks\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass Solution {\r\n    //\"abc3[a2[c]]\"\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return \"\";\r\n        \r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resultStack = new Stack<>();\r\n        char[] strArr = s.toCharArray();//strArr = a b c 3 [ a 2 [ c ] ]\r\n        int count = 0;\r\n        String curResult = \"\";\r\n        for (int i = 0; i < s.length(); i++) {//curResult = \"accaccacc\", count = 0, countStack: , resultStack:abc,\r\n            //calculate repeat number\r\n            if (Character.isDigit(strArr[i])) {\r\n                count = count * 10 + (strArr[i] - '0');\r\n            }\r\n            //push previous decoded string into stack\r\n            else if (strArr[i] == '[') {\r\n                countStack.push(count);\r\n                resultStack.push(curResult);\r\n                count = 0;\r\n                curResult = \"\";\r\n            }\r\n            //start to decode current string\r\n            else if (strArr[i] == ']') {//repeat:3\r\n                int repeat = countStack.pop();\r\n                StringBuilder temp = new StringBuilder(resultStack.pop());//temp:\r\n                for (int j = 0; j < repeat; j++) {\r\n                    temp.append(curResult);\r\n                }\r\n                curResult = temp.toString();\r\n            }\r\n            //normal character, concat to current string, preparing for decoding\r\n            else {\r\n                curResult += strArr[i];\r\n            }\r\n        }\r\n        return curResult;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time : O(maxCount * N) where maxCount is max value of count, and n is the size of string array.\r\n#### Space : O(m + n) m is the number of letters and n is the number of digits.\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995446787","body":"#### approach: two stacks\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> s1 = new Stack<>();\r\n    private Stack<Integer> s2 = new Stack<>();\r\n\r\n    // Initialize your data structure here. \r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    // Push element x to the back of queue.\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    // Removes the element from in front of queue and returns that element. \r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    // Get the front element. \r\n    public int peek() {\r\n        if (!s2.isEmpty()) {\r\n            return s2.peek();\r\n        } else {\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    // Returns whether the queue is empty. \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time: peek() -> O(N), empty() -> O(1), pop() -> O(N), push() -> O(1)\r\n#### Space: peek() -> O(1), empty() -> O(1), pop() -> O(1), push() -> O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997161066","body":"#### approach: \r\n#### 1. traverse all nodes to compute the length\r\n#### 2. close the ring\r\n#### 3. traverse again to find the position of the new head and new tail\r\n#### 4. break the ring and get back the new head\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass Solution {\r\n    // 1  2  3  4  5\r\n    //             c\r\n    //       n\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null || k == 0) return head;\r\n         \r\n        ListNode curr = head;\r\n        ListNode newTail = head;\r\n        int len= 1;\r\n        \r\n        while (curr.next != null) {\r\n            curr = curr.next;\r\n            len ++;\r\n        }\r\n        curr.next = head;\r\n        k = k % len;\r\n        int cnt = len - k;\r\n        \r\n        while (cnt > 1) {// k: 0, cnt: 1\r\n            newTail = newTail.next;\r\n            cnt --;\r\n        }\r\n        \r\n        ListNode newHead = newTail.next;\r\n        newTail.next = null;\r\n        \r\n        return newHead;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time: O(N)\r\n#### Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997275321","body":"#### iterative approach\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass Solution {\r\n    //   1   2   3   4   5\r\n    //d  h \r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        \r\n        ListNode dummy = new ListNode(-1, head);\r\n        ListNode pre = dummy;\r\n        ListNode cur = head;\r\n        \r\n        while (cur != null && cur.next != null) {\r\n            \r\n            ListNode t = cur.next;// initialize a temporary node\r\n            // swapping\r\n            cur.next = cur.next.next;\r\n            t.next = cur;\r\n            pre.next = t;\r\n            // reinitialize the current node and pre node for the next swap\r\n            pre = cur;\r\n            cur = cur.next;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### complexity:\r\n#### Time: O(N)\r\n#### Space: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999285921","body":"#### approach:\r\n#### 1. use two pointers slow and fast\r\n#### 2. if there is a cycle, slow and fast will intersect at some node. Otherwise, the fast will reach the null\r\n#### 3. reset the either of slow and fast to the head and traverse both of them one node at a time until they meet\r\n#### 4. return the slow\r\n---\r\n\r\n#### code:\r\n```Java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) return null;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        \r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (fast == slow) break;\r\n        }\r\n        \r\n        slow = head;\r\n        \r\n        while (fast != slow) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time: O(N)\r\n#### Space: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000976025","body":"#### approach: recursion\r\n---\r\n#### code\r\n```Java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n\r\n        boolean left = isSameTree(p.left, q.left);\r\n        boolean right = isSameTree(p.right, q.right);\r\n        \r\n        if (p.val != q.val)\r\n            return false;\r\n        \r\n        return left && right;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time: O(N)\r\n#### Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001065407","body":"#### approach: recursive preorder traversal\r\n\r\n#### 1. update the pathSum in each level \r\n#### 2. do the recursive calls until reaching the leaf node\r\n#### 3. update the sum\r\n#### 4. repeat the step 1 to 3 for the right child nodes\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass Solution {\r\n    int sum = 0;\r\n    public int sumNumbers(TreeNode root) {\r\n        dfs(root, 0);\r\n        return sum;\r\n    }\r\n    \r\n    private void dfs(TreeNode root, int pathSum) {\r\n        if (root == null) return;\r\n        \r\n        if (root.left == null && root.right == null) {\r\n            sum += pathSum * 10 + root.val;\r\n        } else {\r\n            pathSum = pathSum * 10 + root.val;\r\n        }\r\n   \r\n        dfs(root.left, pathSum);\r\n        dfs(root.right, pathSum);\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time: O(N), the number of nodes\r\n#### Space: O(H), the height of the tree","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potatoma":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991866936","body":"### 思路\n\n***\n\n先在对应位置一一相加，再进行进位操作\n\n### 代码\n\n***\n\nJavascript code:\n\n```javascript\nvar addToArrayForm = function(num, k) {\n    let temp = 0;\n    const kLen = k.toString().length;\n    for (let i = 0;i < kLen;i++) {\n        if (num.length < kLen) num.unshift(0);\n        temp = k % 10;\n        k = Math.floor(k / 10);\n        num[num.length - 1 - i] += temp;\n    }\n    const nLen = num.length;\n    for (let i = nLen - 1;i > 0;i--) {\n        if (num[i] >= 10) {\n            num[i - 1] += 1\n            num[i] = num[i] % 10;\n        }\n    }\n    if (num[0] >= 10) {\n        num[0] = num[0] % 10;\n        num.unshift(1);\n    }\n    return num;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度O(max(N,logk))\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992567484","body":"### 思路1\n\n***\n\n空间换时间：先记录每一个字符C出现的下标，再遍历一次字符串S，通过下标相减的绝对值找出每个字符距离C最近的距离\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const targetIndex = [];\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) {\n            targetIndex.push(i);\n        }\n    }\n    const res = [];\n    for (let i = 0;i < s.length;i++) {\n        let min = Infinity;\n        for (let ti of targetIndex) {\n            if (min <= Math.abs(i - ti)) {\n                break;\n            }\n            min = Math.abs(i - ti);\n        }\n        res.push(min);\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N * K)，K是字符C在字符串S中出现的次数，K <= N\n\n空间复杂度：O(K)\n\n### 思路2\n\n***\n\n贪心，先从左往右遍历S，计算每个下标离左边距离C最近的距离，再从右往左遍历计算一次，如有更小的距离则覆盖\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    let targetIndex = null;\n    const res = new Array(s.length);\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex === null) {\n            res[i] = Infinity;\n        } else {\n            res[i] = Math.abs(i - targetIndex);\n        }\n    }\n    targetIndex = null;\n    for (let i = s.length - 1;i > -1;i--) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex !== null) {\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996406232","body":"### 思路1：滑动窗口\n\n***\n\n原数组与排好序后的数组比较，当窗口内的数字和相等则可以分为一个块。\n\n### 代码\n\n***\n\nJavaScript Code\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sortedArr = [...arr].sort((a, b) => a - b);\n    let sum1 = 0, sum2 = 0, res = 0;\n    for (let i = 0;i < sortedArr.length;i++) {\n        sum1 += sortedArr[i];\n        sum2 += arr[i];\n        if (sum1 === sum2) {\n            res++;\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(NlogN + N) = O(NlogN)\n\n空间复杂度：O(N)\n\n### 思路2：单调栈\n\n***\n\n通过遍历数组间接找出每个块中的最大值，当遇到更大的值时则可以将其置为新的块，推入栈顶；遇到较小的值时，则降栈顶依次弹出找到小于等于该值的项，并进行合并。\n\n### 代码\n\n***\n\nJavaScript Code\n\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (let i = 0;i < arr.length;i++) {\n        if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n            stack.push(arr[i]);\n        } else if (stack[stack.length - 1] === arr[i]) {\n            continue;\n        } else if (stack[stack.length - 1] > arr[i] && stack.length !== 1) {\n            let top = stack.pop();\n            while (stack[stack.length - 1] > arr[i]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n    }\n    return stack.length;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mahalasu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maschinist-lzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackielj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"francis-xsc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"autumndesea":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snowballbears":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiqaq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinming-gu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lovewitch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kashinggo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991847136","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        total = 0\n        index = 0\n        \n        for n in num[::-1]:\n            total += (10 ** index) * n\n            index += 1\n        \n        total += k\n        \n        res = []\n        for digit in str(total):\n            res.append(int(digit))\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992107736","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # len(s) is 1 bigger than max distance\n        res = [len(s)] * len(s)\n        \n        leftMost = rightMost = -1\n        \n        for i in range(len(s)):\n            if s[i] == c: leftMost = i\n            if leftMost != -1:\n                res[i] = i - leftMost\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: rightMost = i\n            if rightMost != -1:\n                res[i] = min(res[i], rightMost - i)\n        \n        return res\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993135666","body":"```python\nclass Node:\n    \n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.prev = None\n        \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.head = None\n        self.tail = None\n        self.maxSize = maxSize\n        self.currSize = 0\n\n    def push(self, x: int) -> None:\n        if self.currSize >= self.maxSize: return\n        \n        self.currSize += 1\n        if self.head is None: \n            self.head = Node(x)\n            self.tail = self.head\n            return\n        \n        temp = self.tail\n        self.tail.next = Node(x)\n        self.tail = self.tail.next\n        self.tail.prev = temp\n        \n    def pop(self) -> int:\n        if self.currSize == 0: return -1\n        \n        self.currSize -= 1\n        res = self.tail.val\n        self.tail = self.tail.prev\n        \n        # re-init head and tail\n        if self.tail is None:\n            self.head = None\n            return res\n        self.tail.next = None\n        \n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        curr = self.head\n        for i in range(min(k, self.currSize)):\n            curr.val += val\n            curr = curr.next\npython","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995161496","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        stack2 = []\n        while self.stack:\n            stack2.append(self.stack.pop())\n        res = stack2.pop()\n        \n        while stack2:\n            self.stack.append(stack2.pop())\n        \n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        stack2 = []\n        while self.stack:\n            stack2.append(self.stack.pop())\n        res = stack2[-1]\n        \n        while stack2:\n            self.stack.append(stack2.pop())\n        \n        return res\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack) == 0\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996246555","body":"```python\n# monotonic stack (ascending)\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        \n        for n in arr:\n            curr_max = n\n            while stack and stack[-1] > n:\n                curr_max = max(curr_max, stack.pop())\n            stack.append(curr_max)\n        \n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997154410","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n# time: (N)\n# space: O(1)\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n        count = 0\n        dummy = head\n        while dummy:\n            count += 1\n            dummy = dummy.next\n        \n        k = k % count\n        if k == 0: return head\n        \n        temp_k = k\n        dummy = head\n        while temp_k:\n            dummy = dummy.next\n            temp_k -= 1\n        \n        current = head\n        while dummy.next:\n            current = current.next\n            dummy = dummy.next\n        \n        dummy.next = head\n        res = current.next\n        current.next = None\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997288836","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n\n        dummy = ListNode(-1)\n        dummy.next = head.next\n        \n        next_batch = head.next.next\n        head.next.next = head\n        \n        head.next = self.swapPairs(next_batch)\n        \n        return dummy.next\n        \n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997450339","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n        \n        prev = head\n        slow = head\n        fast = head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        node = TreeNode(slow.val)\n        left = head\n        right = slow.next\n        prev.next = None\n\n        node.left = self.sortedListToBST(left)\n        node.right = self.sortedListToBST(right)\n        \n        return node\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998470749","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a = headA\n        b = headB\n        \n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n            \n            # if 2 list never intersect, both will reach None at the end \n            if not a and not b: return None\n        \n        return a\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999268223","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        \n        seen = set()\n        while head:\n            if head in seen:\n                return head\n            seen.add(head)\n            head = head.next\n        \n        return None\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999924297","body":"```python\nclass ListNode:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.prev = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dict = {}\n        self.head = ListNode(-1, -1)\n        self.tail = ListNode(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def remove(self, node):\n        del self.dict[node.key]\n        self.capacity += 1\n        \n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = None\n        node.next = None\n    \n    def insert(self, node):\n        self.dict[node.key] = node\n        self.capacity -= 1\n        \n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key not in self.dict:\n            return -1\n        node = self.dict[key]\n        self.remove(node)\n        self.insert(node)\n        \n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dict:\n            self.remove(self.dict[key])\n        self.insert(ListNode(key, value))\n        if self.capacity < 0:\n            self.remove(self.head.next)\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000553392","body":"```python\n# recursion: post order traversal\n# currNode max depth = max(leftNodeMax, rightNodeMax) + 1\n# time: O(N)\n# space: O(M), depth of the tree\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        \n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        \n        currMax = max(left, right) + 1\n        \n        return currMax\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000912700","body":"```python\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q: return True\n        if not p or not q: return False\n        \n        if p.val != q.val: return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001069431","body":"```Python\n# pre order traversal\n# use curr_sum to track the sum built at curr node\n# 4 cases for each node:\n# - Null: return -1 as a flag\n# - Leaf: return left_sum + right_sum\n# - node with only left child: return right_sum\n# - node with only right child: return left_sum\n\n# time: O(N)\n# space: O(H)\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return self.pre_order(root, 0)\n    \n    def pre_order(self, node, curr_sum):\n        if not node:\n            return -1\n        \n        curr_sum = curr_sum * 10 + node.val\n        left_sum = self.pre_order(node.left, curr_sum)\n        right_sum = self.pre_order(node.right, curr_sum)\n        \n        # leaf node\n        if left_sum == -1 and right_sum == -1:\n            return curr_sum\n        \n        if left_sum == -1:\n            return right_sum\n        elif right_sum == -1:\n            return left_sum\n        \n        return left_sum + right_sum\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjp1483469269":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991833580","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0\n        ans = []\n        for i in range(len(num)):\n            x = k % 10\n            k = k // 10\n            n,c = (x + num[len(num)-1-i] + c) % 10,(x + num[len(num)-1-i]+c) // 10\n            ans = [n]+ans\n        k = k+c\n        if k!=0:\n            while(k!=0):\n                ans = [k%10] + ans\n                k = k // 10\n            return ans\n        if c == 0:\n            return ans\n        else :\n            return [c]+ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992041299","body":"#### 思路\n记录下标index，以每个index为中心向周围增加给数组赋值，直到填满数组\n#### 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        index = [i for i,x in enumerate(s) if x == c]\n        ls = [-1]*len(s)\n        cnt = len(index)\n        for i in index:\n            ls[i] = 0\n        step = 0\n        while(cnt<len(s)):\n            step = step + 1\n            for i in index:\n                for j in [-step,step]:\n                    if i+j >= 0 and i+j < len(s) and ls[i+j] == -1:\n                        ls[i+j] = step\n                        cnt = cnt + 1\n        return ls\n```\n#### 复杂度分析\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993171554","body":"#### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if(len(self.stack) < self.max_size):\n            self.stack.append(x)\n        else:\n            return\n        \n    def pop(self) -> int:\n        stack = self.stack\n        if(len(stack) > 0):\n            return stack.pop(len(stack)-1)\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        stack = self.stack\n        for i in range(min(len(stack),k)):\n            stack[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994279440","body":"```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                rs = ''\n                rn = ''\n                while stack and stack[-1]!='[' :\n                    rs = stack.pop() + rs\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    rn = stack.pop() + rn\n                stack.append(rs * int(rn))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995430417","body":"```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.helpstack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        while self.stack :\n            self.helpstack.append(self.stack.pop())\n        res = self.helpstack.pop()\n        while self.helpstack :\n            self.stack.append(self.helpstack.pop())\n        return res\n\n    def peek(self) -> int:\n        return self.stack[0]\n\n    def empty(self) -> bool:\n        if self.stack :\n            return False\n        else:\n            return True\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996377877","body":"#### 思路\n借助栈存储子序列的最大值，最后输出即为栈长度\n#### 代码\n```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for x in arr:\n            if not stack or stack[-1] <= x:\n                stack.append(x)\n            elif stack[-1] > x:\n                tmp = stack[-1]\n                while stack and stack[-1] > x:\n                    stack.pop()\n                stack.append(tmp)\n        return len(stack)\n```\n#### 复杂度分析\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997126078","body":"```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        node = head\n        l = 0\n        tail = head\n        if not head:\n            return head\n        while node:\n            l += 1\n            if not node.next:\n                tail = node\n            node = node.next\n        \n        n = k % l \n        if n == 0:\n            return head\n        else:\n            node = head\n            for _ in range(l - n - 1):\n                node = node.next\n            new_head = node.next\n            node.next = None\n            tail.next = head\n        return new_head            \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997330113","body":"```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        l,r,sb,h= ListNode(),ListNode(),ListNode(),ListNode()\n        sb.next = head\n        l = sb\n        r = sb\n        h = sb\n        i = 0\n        while l and l.next and l.next.next: \n            l = l.next\n            r = l.next\n            h.next = r\n            l.next = r.next\n            r.next = l\n            h = l\n        return sb.next\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997571736","body":"```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre , slow , fast = None , head , head\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998426230","body":"```python3\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        a,b = headA,headB\n        while(a != b):\n            a = headB if not a else a.next\n            b = headA if not b else b.next\n        return a\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999321737","body":"```python3\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        Set = set()\n        node = head\n        while node and node not in Set:\n            Set.add(node)\n            node = node.next\n        return node if node else None\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999992213","body":"```python3\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000619805","body":"```python3\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(node,n):\n            if not node:\n                return n\n            else:\n                return max(dfs(node.left,n+1),dfs(node.right,n+1))\n        return dfs(root,0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000980473","body":"```python3\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n\n        return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001088799","body":"```python3\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = 0\n        node = root\n        if not node.left and not node.right:\n            return node.val\n        if node.left:\n            node.left.val = node.left.val + 10 * node.val\n            res += self.sumNumbers(node.left)\n        if node.right:\n            node.right.val = node.right.val + 10 * node.val\n            res += self.sumNumbers(node.right)\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeychengtor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelondrip":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995336582","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk1 = list()\r\n        self.stk2 = list()  # create new queue\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stk1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stk2:\r\n            return self.stk2.pop()\r\n        else:\r\n            while self.stk1:\r\n                self.stk2.append(self.stk1.pop())\r\n            return self.stk2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stk2:\r\n            return self.stk2[-1]\r\n        while self.stk1:\r\n            self.stk2.append(self.stk1.pop())\r\n        return self.stk2[-1] \r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (len(self.stk2) == 0 and  len(self.stk1)== 0)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997335631","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_node = ListNode(0,head)\r\n      \r\n        tmp = dummy_node\r\n        while tmp.next and tmp.next.next:\r\n            node1 = tmp.next\r\n            node2 = tmp.next.next\r\n\r\n            tmp.next = node2  \r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            tmp  = node1\r\n        return dummy_node.next\r\n\r\n        \r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001106143","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        def helper(node,nums):\r\n            if node:\r\n                nums.append(node.val)\r\n                if node.left:\r\n                    helper(node.left,nums[:])\r\n                if node.right:    \r\n                    helper(node.right,nums[:])\r\n            if not node.right and not node.left:\r\n                temp = ''.join(map(str,nums))\r\n                print(temp)\r\n                self.ans.append(temp)\r\n        self.ans = []\r\n        nums = []\r\n        helper(root,nums)\r\n        print(self.ans)\r\n        result = list(map(int, self.ans))\r\n\r\n        return sum(result)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jding0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jk1452470209":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tao-mao":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994346256","body":"## Idea \nUse stack\n\n## Code \n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>(); \n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < s.length(); ++i) {\n            if (s.charAt(i) != ']') {\n                stack.add(s.charAt(i));\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n                List<Character> decodedString = new ArrayList<>();\n                while (stack.peek() != '[') {\n                    decodedString.add(stack.pop());           \n                }\n                stack.pop();\n                StringBuilder times = new StringBuilder();\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    times.append(stack.pop());\n                }\n                int num = Integer.parseInt(times.reverse().toString());\n                while (num != 0) {\n                    for (int j = decodedString.size() - 1; j >= 0; j--) {\n                        stack.push(decodedString.get(j));\n                    }\n                    num--;\n                }\n            }\n        }\n        char[] result = new char[stack.size()];\n        for (int i = result.length - 1; i >= 0; i--) {\n            result[i] = stack.pop();\n        }\n        return new String(result);\n    }\n}\n```\n\n## Complexity\nTime: O(maxK^Kcount * n) Space O(sum(maxK^Kcount * n))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997084313","body":"## Idea\r\nFind the kth node, reverse it.\r\n\r\n## Code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        int i = 1;\r\n        ListNode node = head;\r\n        while (node.next != null) {\r\n            ++i;\r\n            node = node.next;\r\n        }\r\n        k = k % i;\r\n        if (k == 0) return head;\r\n        int j = i - k;\r\n        \r\n        ListNode tmp = head;\r\n        while (j > 1 && tmp != null) {\r\n            tmp = tmp.next;\r\n            --j;\r\n        }\r\n        \r\n        ListNode val = tmp.next;\r\n        tmp.next = null;\r\n        node.next = head;\r\n        \r\n        return val;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nSpace: O(1) Time: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997469561","body":"### Idea\nUse slow/fast pointers to get node in the middle, and refer to it as the root node of the treenode. Recursively doing the process.\n\n### Code\n```java \n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode tmp = slow;\n        // System.out.print(tmp);\n        while (fast != null && fast.next != null) {\n            tmp = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        tmp.next = null;\n        // System.out.println(slow.val);\n        TreeNode res = new TreeNode(slow.val);\n        res.right = sortedListToBST(slow.next);\n        res.left = sortedListToBST(head);\n        \n        return res;\n        \n        \n    }\n}\n```\n\n### Complexity\nTime: O(nlogn) Space: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998307627","body":"### Code\n\n```java \n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            if (a == null) {\n                a = headB;\n            }\n            else {\n                a = a.next;\n            }\n            if (b == null) {\n                b = headA;\n            }\n            else {\n                b = b.next;\n            }\n        }\n        return a;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999151026","body":"### Idea\nFast and slow pointers.\n\n### Code \n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null || head.next.next == null) return null;\n        ListNode slow = head.next;\n        ListNode fast = head.next.next;\n        while (fast != slow) {\n            if (slow == null || fast == null || fast.next == null) return null;\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        ListNode tmp = head;\n        while (tmp != fast) {\n            tmp = tmp.next;\n            fast = fast.next;\n        }\n        return fast;\n        \n    }\n}\n```\n\n### Complexity\nSpace: O(1) TIme: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000678446","body":"### Idea\nRecursion\n\n### Code \n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        int res = 0;\n        return helper(root);\n    }\n    public int helper(TreeNode root) {\n        if (root == null) return 0;\n        int left = helper(root.left) + 1;\n        int right = helper(root.right) + 1;\n        return Math.max(left,right);\n    }\n}\n```\n\n### Complexity\nSpace: O(logN) Time:(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000896952","body":"### Idea\nRecursion\n\n### Code\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        else if (p == null || q == null) return false;\n        if (p.val == q.val) {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        return false;\n    }\n}\n```\n\n### Complexity\nSpace: O(logn) Time: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001077010","body":"### Idea\nRecursion and always return the sum.\n\n### Code\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root == null) return 0;\n        return helper(root, root.val);\n    }\n    \n    public int helper(TreeNode root, int val) {\n        if (root == null) return 0;\n        int res = 0;\n        if (root.right != null) {\n            res += helper(root.right, val*10+root.right.val);\n        }\n        if (root.left != null) {\n            res += helper(root.left, val*10+root.left.val);\n        }\n        if (root.left == null && root.right == null) {\n            res = val;\n        }\n        return res;\n    }\n}\n```\n\n### Complexity\nSpace: O(n) Time: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agathawang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daniel-zheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922037","body":"### 思路\n---\n逐位相加\n### 代码\n---\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        int len = num.length;\n        int i = len - 1, tmp = k, carry = 0;\n        while (i >= 0 || tmp > 0 || carry > 0) {\n            int t = (i >= 0 ? num[i] : 0) + (tmp > 0 ? tmp % 10 : 0) + carry;\n            carry = t / 10;\n            ans.add(0, t % 10);\n            --i;\n            tmp /= 10;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(max(num.length, logk))\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992095276","body":"### 思路\n---\n数组的遍历\n### 代码\n---\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        Arrays.fill(ans, n + 1);\n        int pre = -n;\n        for (int i = 0; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], i - pre);\n        }\n\n        pre = 2 * n;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993181943","body":"### 思路\n---\n栈\n### 代码\n---\n```java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n    int[] add;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n        add = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top == stack.length - 1) {\n            return;\n        }\n        ++top;\n        stack[top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int res = stack[top] + add[top];\n        --top;\n        if (top >= 0) {\n            add[top] += add[top + 1];\n        }\n        add[top + 1] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int c = Math.min(top, k - 1);\n        if (c >= 0) {\n            add[c] += val;\n        }\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(1)\n+ 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994334896","body":"### 思路\n---\n栈\n### 代码\n---\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(n)\n+ 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995453258","body":"### 思路\n---\n栈\n### 代码\n---\n```java\nclass MyQueue {\n\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(1)\n+ 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996448573","body":"### 思路\n---\n单调栈\n### 代码\n---\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997202927","body":"### 思路\n---\n快慢指针\n### 代码\n---\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997398111","body":"### 思路\n---\n迭代\n### 代码\n---\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode temp = dummyHead;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return dummyHead.next;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998783850","body":"### 思路\n---\n双指针\n### 代码\n---\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(m+n), 其中 m 是链表 headA 的长度， n 是链表 headB 的长度\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999298942","body":"### 思路\n---\n双指针\n### 代码\n---\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000089302","body":"### 思路\n---\n链表\n### 代码\n---\n```java\nclass LRUCache {\n\n    class ListNode {\n        int key;\n        int value;\n        ListNode pre;\n        ListNode next;\n        public ListNode() {}\n        public ListNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    ListNode head, tail;\n    int cap, size;\n    Map<Integer, ListNode> map;\n    public LRUCache(int capacity) {\n        head = new ListNode();\n        tail = new ListNode();\n        head.next = tail;\n        tail.pre = head;\n        cap = capacity;\n        size = 0;\n        map = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            ListNode node = map.get(key);\n            removeNode(node);\n            addNode(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            ListNode node = map.get(key);\n            node.value = value;\n            removeNode(node);\n            addNode(node);\n        } else {\n            ListNode node = new ListNode(key,value);\n            if (size >= cap) {\n                ListNode delNode = tail.pre;\n                removeNode(delNode);\n            }\n            addNode(node);\n        }\n    }\n\n    private void removeNode(ListNode node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n        map.remove(node.key);\n        --size;\n    }\n\n    private void addNode(ListNode node) {\n        node.next = head.next;\n        node.pre = head;\n        head.next.pre = node;\n        head.next = node;\n        map.put(node.key, node);\n        ++size;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(1)\n+ 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000674048","body":"### 思路\n---\n递归\n### 代码\n---\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000987231","body":"### 思路\n---\nDFS\n### 代码\n---\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qizhongdd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lllouiselao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huangxuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzhengneu":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997097721","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999349798","body":"public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                fast = head;\n                while(fast != slow){\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"just-focus":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"monkofeast":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994917638","body":"# 394. Decode String\n> [Click Me](https://leetcode.com/problems/decode-string/)\n## Algo\n1. Consider innermost decoding, stack is good\n2. new a stack for final output\n3. new a list for temp saving decode\n4. travel through the original str\n    1. if not ']', continue\n    2. if ']', stop, decode\n5. \n\n## Code\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # the key here is to consider cases like jksd19[dsl]fion3[acc2[d]]\n        # this nested pattern should be decode from innermost str\n        # so stack is good for this task\n        # KEY!!!: ']' on the top of stack is the starting point to decode\n        \n        stack = []\n        decodeList = []\n        \n        # travel the ori str\n        for i in range(len(s)):\n            # if not , travel\n            if s[i] != ']':\n                stack.append(s[i])\n            # if ']', stop, start decoding\n            else:\n                while stack[-1] != '[': decodeList.insert(0, stack.pop())\n                stack.pop() # delete '['\n                # find the multi times\n                times, multi = 0, 1\n                while stack and stack[-1].isnumeric():\n                    times += multi*int(stack.pop())\n                    multi *= 10\n                stack = stack + decodeList*times\n                decodeList.clear()\n        \n        # (str).join(list): return a str\n        return \"\".join(stack)\n```\n\n## Comp\n### T: O(N)\n### S: O(max(decoded-list))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995941894","body":"# 232. Implement Queue using Stacks\n> [Click Me](https://leetcode.com/problems/implement-queue-using-stacks/)\n## Algo\n1. KEY: 1 stack in + 1 stack out = 1 queue\n2. I choose push to be O(n), other O(1)\n\n## Code\n```py\nclass MyQueue:\n    # if want to use deque\n    # from collections import deque\n    \n    # but here I just use list\n    \"\"\"\n     LC is not smart enough to check operation used.....\n     So self limit that stacks can only use pop()\n    \"\"\"\n    # 2 stacks for mutually containing\n    # stack 1 receive push(), stack take pop()\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1, self.stack2 = [], []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # I push everything to stack 2 back, stack 1 holds nothing\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        # then append at tail\n        self.stack1.append(x)\n        # then push everything back to stack 2\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # harder push() makes pop() easier\n        return self.stack2.pop()\n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # in fact a pointer will do, whatever\n        return self.stack2[-1]\n        \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self.stack2\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## Comp\n### T: O(N) for push(), O(1) for others\n### S: O(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000385103","body":"# 146. LRU Cache\n> [Click Me](https://leetcode.com/problems/lru-cache/)\n## Algo\nMemory\n\n## Code\n```py\n# OK, double link\nclass DLNode:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n    \nclass LRUCache:\n  \n    def __init__(self, capacity: int):\n        # size\n        self.cap = capacity\n        self.size = 0\n        \n        # hash for remembering loc\n        self.cache = {}\n        \n        # head & tail\n        self.head = DLNode()\n        self.tail = DLNode()        \n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    \"\"\" helper funcs \"\"\"\n    # remove a specific node\n    def remove(self, node):\n        # remove: need to remember the loc\n        prevNode = node.prev\n        nextNode = node.next\n        prevNode.next = nextNode\n        nextNode.prev = prevNode    \n    def add(self, node):\n        # add a node to the 1st loc, which is head.next\n        node.next = self.head.next\n        node.prev = self.head        \n        node.next.prev = node\n        self.head.next = node\n    def moveToHead(self, node):\n        # move a node to head\n        self.remove(node)\n        self.add(node)\n    def popLast(self):\n        # pop the last node in cache\n        res = self.tail.prev\n        self.remove(res)\n        return res\n        \n    \"\"\" Functional Funcs \"\"\"\n    def get(self, key: int) -> int:\n        # get target\n        node = self.cache.get(key, None)\n        \n        # if not exist\n        if not node: return -1\n        \n        # if exist, move to head\n        self.moveToHead(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:        \n        # get target\n        node = self.cache.get(key)\n        \n        # if already exists\n        if node:\n            self.cache[key].val = value\n            self.moveToHead(node)\n            return\n        \n        # check capacity\n        if self.size + 1 > self.cap:\n            # evict\n            prevLastNode = self.popLast()\n            del self.cache[prevLastNode.key]\n        else:\n            self.size += 1\n        \n        # we will add this node no matter what\n        addNode = DLNode(key, value)\n        self.add(addNode)\n        self.cache[key] = addNode\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n## Comp\n### T: O(1)\n### S: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhang6260":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994785258","body":"## JAVA版本\n\n使用栈来完成的，需要注意的是，数组可能存在多位的时候，从栈中取字母是否是否需要进行翻转。\n\n> ```java\n> class Solution {\n>     public  String decodeString(String s) {\n>         Stack<String> stack = new Stack<>();\n>         for(int i=0;i<s.length();i++){\n>             char temp = s.charAt(i);\n>             if(temp==']'){\n>                 StringBuffer sb = new StringBuffer();\n>                 while(!stack.isEmpty()&&!stack.peek().equals(\"[\")){\n>                     sb.append(stack.pop()+\"\");\n>                 }\n>                 if(stack.peek().equals(\"[\"))stack.pop();//弹出【\n>                 //数组可能为多位\n>                 StringBuffer num = new StringBuffer();\n>                 while(!stack.isEmpty()&&stack.peek().length()==1&&stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9'){\n>                     num.append(stack.pop());\n>                 }\n>                 num.reverse();\n>                 int n = Integer.parseInt(num.toString());\n>               \n>                 StringBuffer temp_sb = new StringBuffer();\n>                 for(int z=0;z<n;z++){\n>                     temp_sb.append(sb.toString());\n>                 }\n>                 if(stack.isEmpty()||stack.peek().equals(\"[\")){\n>                     stack.push(temp_sb.toString());\n>                 }else{\n>                     stack.push(stack.pop()+temp_sb.toString());\n>                 }\n>             }else if(stack.isEmpty()||(temp>='0'&&temp<='9')||temp=='['||stack.peek().equals(\"[\")){\n>                 stack.push(temp+\"\");\n>             }else {\n>                 stack.push(stack.pop()+temp);\n>             }\n>         }\n>         return stack.peek();\n>     }\n> }\n> ```\n\n__时间复杂度__：O(n) \n\n__空间复杂度__：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995454798","body":"## JAVA版本\n\n使用二个栈就来完成，模拟队列，要求弹出最先对栈的值，可以将栈的所有值，入栈到另一个栈中，这样在另个栈对的栈顶则是最开始进行的数字，当该栈为空后，则重复上面的操作。\n\n> ```java\n> class MyQueue {\n>     Stack<Integer> stack1;\n>     Stack<Integer> stack2;\n>     public MyQueue() {\n>         stack1 = new Stack<>();\n>         stack2 = new Stack<>();\n>     }\n>     public void push(int x) {\n>         stack1.push(x);\n>     }\n>     public int pop() {\n>         fun();\n>         if(stack2.isEmpty())return -1;\n>         return stack2.pop();\n>     }\n>     public int peek() {\n>         fun();\n>         if(stack2.isEmpty())return -1;\n>         return stack2.peek();\n>     }\n>     public boolean empty() {\n>         if(stack1.isEmpty()&&stack2.isEmpty()){\n>             return true;\n>         }else{\n>             return false;\n>         }\n>     }\n>     public void fun(){\n>         if(stack2.isEmpty()&&!stack1.isEmpty()){\n>             while(!stack1.isEmpty()){\n>             stack2.push(stack1.pop());\n>             }\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(N) \n\n__空间复杂度__：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996829045","body":"### JAVA版本\n\n使用栈，入栈的时候与栈顶的元素进行比较，如果大于栈顶元素则直接入栈，如果比栈顶元素小，则需要将栈中小于入栈的元素都出栈，最后栈中剩余的元素就是所需要的结果。\n\n>```java\n>class Solution {\n>    public int maxChunksToSorted(int[] arr) {\n>        Stack<Integer> stack=new Stack<Integer>();\n>        // int []arr={2,1,3,4,4};\n>        int res=0;\n>        for (int i = 0; i<arr.length; i++ ){\n>            if(stack.isEmpty()){\n>                stack.push(arr[i]);\n>            }else {\n>                if(stack.peek()>arr[i]){\n>                    int cur = stack.pop();\n>                    while (!stack.isEmpty() && arr[i] < stack.peek()){\n>                        stack.pop();\n>                    }\n>                    stack.push(cur);\n>\n>                }else {\n>                    stack.push(arr[i]);\n>                }\n>            }\n>        }\n>        return stack.size();\n>    }\n>}\n>```\n\n### 时间复杂度：O(n)\n\n### 空间复杂度：O(n）\n\n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997198733","body":"### JAVA版本\n\n该题注意的点有二个，1是k的取值范围是【1,2*10^9】，需要对链表的长度进行求余操作，2是：当k的长度刚好是链表的长度的时候，这个时候就直接返回链表即可。\n\n>```java\n>class Solution {\n>    public ListNode rotateRight(ListNode head, int k) {\n>        if(k==0||head==null)return head;\n>        ListNode now = head;\n>        int count = 0;\n>        while(now != null){\n>            now = now.next;\n>            count++;\n>        }\n>        k = k % count;\n>        if(k==0)return head;\n>        ListNode slow = head,fast =head;\n>        while(fast.next!=null){\n>            if(k>0){\n>                fast=fast.next;\n>                k--;\n>            }else{\n>                fast = fast.next;\n>                slow = slow.next;\n>            }\n>        }\n>        fast.next=head;\n>        ListNode res = slow.next;\n>        slow.next =null;\n>        \n>        return res;\n>    }\n>}\n>```\n\n### 时间复杂度：O(n)\n\n### 空间复杂度：O(1）\n\n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997333508","body":"## JAVA版本\n\n直接进行“穿针引线”即可【直接看代码是不好理解的，话一个图就一目了然了】，但是要注意链表的题使用虚拟头节点，可以避免一些特殊的问题。\n\n> ```java\n> class Solution {\n>     public ListNode swapPairs(ListNode head) {\n>         ListNode node = new ListNode(-1);\n>         node.next = head;\n>         ListNode cur = node;\n>         while(cur.next!=null&&cur.next.next!=null){\n>             ListNode second = cur.next.next;\n>             cur.next.next = second.next;\n>             second.next = cur.next;\n>             cur.next = second;\n>             cur = second.next;\n>         }\n>         return node.next;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(n) \n\n__空间复杂度__：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997640764","body":"## JAVA版本\n\n使用递归+快慢指针的方式来完成的，使用快慢指针来找到链表中最中间的哪个元素，然后链表左边的取构建数的左孩子，右边则去构建数的右孩子（需要断开链表的前一个节点）；最后需要考虑链表只有一个节点的情况。\n\n> ```java\n> class Solution {\n>     public TreeNode sortedListToBST(ListNode head) {\n>         if(head==null)return null;\n>         //使用快慢指针来完成的\n>         ListNode slow = head,fast = head,pre = null;\n>         while(fast!=null&&fast.next!=null){\n>             pre = slow;\n>             slow = slow.next;\n>             fast = fast.next.next;\n>         }\n>         if(pre!=null)pre.next = null;\n>         if(slow == fast)head = null; \n>         TreeNode node = new TreeNode(slow.val);\n>         node.left = sortedListToBST(head);\n>         node.right = sortedListToBST(slow.next);\n>\n>         return node;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(nlonn) \n\n__空间复杂度__：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998443269","body":"## JAVA版本\n\n方法一：可以使用hash的方式，将其中一个链表的所有的值都存在hash中，再遍历另一链表，并判断其值是否再hash中。\n\n方法二：使用双指针，同时遍历二个链表，当一个链表遍历完后，则接着另个链表进行遍历，当二个链表的指针相等的时候停止循环，（停止循环是有二种情况的，1是有重复的节点，2是未有重复节点，此时二个指针都指向的null）\n\n> ```java\n> public class Solution {\n>     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n>         //方法一 使用hash\\\n>         // HashSet<ListNode> hash = new HashSet<>();\n>          while(headA!=null){\n>              hash.add(headA);\n>              headA = headA.next;\n>          }\n>          while(headB!=null){\n>              if(hash.contains(headB))return headB;\n>              headB = headB.next;\n>          }\n>          return null;\n>     }\n> }\n> public class Solution {\n>     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n>         //方法二  使用 双指针\n>         ListNode first = headA;\n>         ListNode second = headB;\n>         while(first!=second){\n>             if(first==null)first=headB;\n>             else first = first.next;\n>             if(second ==null)second = headA;\n>             else second = second.next;\n>         }\n>         return first;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(n) \n\n__空间复杂度__：O(1) [方法1则是O(n)]\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999305817","body":"## JAVA版本\n\n使用双指针，【同样也可以使用hash来完成】，使用快慢指针的方式，如果存在换，在环中快慢指针必定会相遇的，然后将快指针指向链表头，同时以相同的速度遍历指针，最后相遇的点就是环的入口。\n\n> ```java\n> public class Solution {\n>     public ListNode detectCycle(ListNode head) {\n>         ListNode slow=head,fast=head;\n>         boolean isfist=true;\n>         while(slow!=fast||isfist){  //当相等时  结束循环\n>             isfist=false;\n>             if(fast==null||fast.next==null){\n>                 return null;\n>             }\n>             fast=fast.next.next;\n>             slow=slow.next;  \n>         }\n>             fast = head;\n>             while(slow!=fast){\n>                 slow = slow.next;\n>                 fast=fast.next;\n>             }\n>         return fast;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(n) \n\n__空间复杂度__：O(1) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000069256","body":"## JAVA版本\n\n该题只是需要自己新建一个双向的链表，然后进行操作，对链表的操作可能会出错。\n\n> ```java\n> class LRUCache {\n>     private HashMap<Integer,Linked> map = new HashMap<>();\n>     private int size,index;\n>     private Linked head,tail;\n>     public LRUCache(int capacity) {\n>         size = capacity;\n>         index = 0;\n>         head = new Linked();\n>         tail = new Linked();\n>         head.next = tail;\n>         tail.prev = head;\n>     }\n>     \n>     public int get(int key) {\n>         int res = -1;\n>         if(map.containsKey(key)){\n>             //获得目标节点，并将其从链表移除\n>             Linked cur = map.get(key);\n>             cur.prev.next = cur.next;\n>             cur.next.prev = cur.prev;\n>           \t//将节点接到头部\n>             Linked fast = head.next;\n>             head.next = cur;\n>             cur.next = fast;\n>             cur.prev = head;\n>             fast.prev = cur;\n>             res = cur.value;\n>         }\n>         return res;\n>     }\n>     \n>     public void put(int key, int value) {\n>         if(map.containsKey(key)){\n>            //获得目标节点，并将其从链表移除\n>             Linked cur = map.get(key);\n>             cur.prev.next = cur.next;\n>             cur.next.prev = cur.prev;\n> \t\t\t//将节点接到头部\n>             cur  = new Linked(key,value);\n>             Linked fast = head.next;\n>             head.next = cur;\n>             cur.prev = head;\n>             cur.next = fast;\n>             fast.prev = cur;\n>             map.put(key,cur);\n>         }else{\n>             if(index<size){\n>                 index++;\n>             }else{\n>                 //从tail的一段删除一个节点\n>                 Linked pre_t = tail.prev;;\n>                 pre_t.prev.next = pre_t.next;\n>                 tail.prev = pre_t.prev;\n>                 pre_t.next = null;\n>                 pre_t.prev = null;\n>                 map.remove(pre_t.key);\n>             }\n>           //将节点接到头部\n>             Linked  cur= new Linked(key,value);\n>             Linked fast = head.next;\n>             head.next = cur;\n>             cur.prev = head;\n>             cur.next = fast;\n>             fast.prev = cur;\n>             map.put(key,cur);\n>         }\n>     }\n>\n>     class Linked{\n>         int key,value;\n>         Linked prev,next;\n>         public Linked(){}\n>         public Linked(int key,int value){\n>             this.value = value;\n>             this.key = key;\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(1) \n\n__空间复杂度__：O(n) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000658495","body":"## JAVA版本\n\n该题主要是考察对树的遍历，树的遍历主要有二种方式，深度遍历和广度遍历，深度优先遍历主要通过使用递归的方式来完成的，广度优先则是通过是有队列的方式来完成的。\n\n> ```java\n> //通过递归的方式\n> class Solution {\n>     public int maxDepth(TreeNode root) {\n>         if(root==null)return 0;\n>         return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n>     }\n> }\n> //通过广度优先进行遍历\n> class Solution {\n>     public int maxDepth(TreeNode root) {\n>         if(root==null)return 0;\n>         int res = 0;\n>         Queue<TreeNode> queue = new LinkedList<TreeNode>();\n>         queue.offer(root);\n>         while(!queue.isEmpty()){\n>             int size = queue.size();\n>             while(size>0){\n>                 TreeNode temp = queue.poll();\n>                 if(temp.left!=null)queue.offer(temp.left);\n>                 if(temp.right!=null)queue.offer(temp.right);\n>                 size--;\n>             }\n>             res++;\n>         }\n>         return res;\n>     }\n> }\n> ```\n\n__时间复杂度__：O(N) \n\n__空间复杂度__：O(h)   （广度则是最大的一层的节点个数。） \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000982653","body":"## JAVA版本\n\n主要考察数的遍历，数的遍历有二种方式，一种通过dfs【主要是递归的方式】，另一种则是bfs的方式，【这一点要注意的是，对某个节点进行判断是否相同的时候，需要对该节点的值进行判断，已经判断其左右孩子的值是否相等，如果不相等则直接返回false】\n\n> ```java\n> //通过递归的方式\n> class Solution {\n>     //树的题 一般都是对树的遍历，\n>     public boolean isSameTree(TreeNode p, TreeNode q) {\n>         if((p==null&&q!=null)||(p!=null&&q!=null&&q.val!=p.val)||(p!=null&&q==null)){\n>             return false;\n>         }else if(p==null&&q==null)return true;\n>         return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n>     }\n> }\n> //通过广度优先进行遍历\n> class Solution {\n>     public boolean isSameTree(TreeNode p, TreeNode q) {\n>         if(p==null && q == null)return true;\n>         if(p==null || q == null)return false;\n>         Queue<TreeNode> queue_p = new LinkedList<>();\n>         Queue<TreeNode> queue_q = new LinkedList<>();\n>         TreeNode temp_p,temp_q;\n>         queue_p.offer(p);\n>         queue_q.offer(q);\n>         while(!queue_q.isEmpty()&&!queue_p.isEmpty()){\n>             int index_p=queue_p.size();\n>             int index_q=queue_q.size();\n>             if(index_p!=index_q)return false;\n>             while(index_p>0){\n>                 temp_p = queue_p.poll();\n>                 temp_q = queue_q.poll();\n>                 if((temp_p.left!=null&&temp_q.left==null)||(temp_p.left==null&&temp_q.left!=null)||(temp_p.right!=null&&temp_q.right==null)||(temp_p.right==null&&temp_q.right!=null)||temp_p.val!=temp_q.val||(temp_p.left!=null&&temp_q.left!=null&&temp_p.left.val!=temp_q.left.val)||(temp_p.right!=null&&temp_q.right!=null&&temp_p.right.val!=temp_q.right.val))return false;\n>                 \n>                 if(temp_p.left!=null)queue_p.offer(temp_p.left);\n>                 if(temp_p.right!=null)queue_p.offer(temp_p.right);\n>                 if(temp_q.left!=null)queue_q.offer(temp_q.left);\n>                 if(temp_q.right!=null)queue_q.offer(temp_q.right);\n>                 index_p--;\n>             }\n>         }\n>         if(queue_q.isEmpty()&&queue_p.isEmpty()){\n>             return true;\n>         }else{\n>             return false;\n>         }\n>     }\n> }\n> ```\n\n__时间复杂度__：O(N) \n\n__空间复杂度__：O(h)   （广度则是最大的一层的节点个数。） \n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houhao1998":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cartie-zhoumo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992087884","body":"## 思路\r\n正反两次遍历分别比较距离左边和右边的目标字符的距离。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        return res\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994238922","body":"## 思路\r\n栈+循环\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                tmp = ''\r\n                mul = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul    \r\n                tmp = tmp * int(mul)\r\n                stack.append(tmp)\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n## 复杂度\r\n时间：O(n) n为解码后的字符串长度\r\n空间：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997558431","body":"## 思路\r\nDFS，每棵子树的根结点是输入的左右两边的中点。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        vals = []\r\n        while head:\r\n            vals.append(head.val)\r\n            head = head.next\r\n        def constructBST(left, right):\r\n            if left > right:\r\n                return\r\n            mid = (left + right) // 2\r\n            node = TreeNode(vals[mid])\r\n            node.left = constructBST(left, mid-1)\r\n            node.right = constructBST(mid+1, right)\r\n            return node\r\n        return constructBST(0, len(vals)-1)\r\n```\r\n## 复杂度\r\n时间：O(N) N是链表长度。\r\n空间：O(logN)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennethalgol":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991873877","body":"##语言\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new LinkedList<>();\r\n\t\tfinal int len = num.length;\r\n\t\tfor(int i = len - 1; i >= 0; i--) {\r\n\t\t\tint sum = num[i] + k % 10;\r\n\t\t\tk /= 10;\r\n\t\t\tif(sum >= 10) {\r\n\t\t\t\tk++;\r\n\t\t\t\tsum -= 10;\r\n\t\t\t}\t\r\n\t\t\tres.add(0, sum);\r\n\t\t}\r\n\t\tfor(; k > 0; k /= 10) {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992040617","body":"#语言\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    /*\r\n    分析（非C字符的分类如下）：\r\n    1.只有左边有C字符： sdafC...\r\n    2.左右两边都有C字符：...CdsfsC...\r\n    3.只有右边有C字符：...Cdsff\r\n    (在后面可以用一句代码实现这三种情况)\r\n    */\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int[] res = new int[S.length()];\r\n        int cur = S.indexOf(C), pre = cur;\r\n        for(int i = 0; i < S.length(); i++){\r\n            if(S.charAt(i) == C){//其实就是每当遍历到C就更新cur和pre\r\n                res[i] = 0;\r\n                pre = i;\r\n                cur = S.indexOf(C, i+1);//注意：这里如果当前是最后一个C时，此时cur为-1，这也保证了上面的情况3\r\n\r\n            }else{\r\n                res[i] = Math.min(Math.abs(pre - i), Math.abs(cur - i));//\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993124305","body":"# 语言\r\njava\r\n\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(1)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994237863","body":"# 思路\r\n栈\r\n\r\n# 语言\r\njava\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995369398","body":"# 思路\r\n栈\r\n\r\n# 语言\r\njava\r\n\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack2.isEmpty()){\r\n            outStack1ToStack2();\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack2.isEmpty()){\r\n            outStack1ToStack2();\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack2.isEmpty()&&stack1.isEmpty();\r\n    }\r\n\r\n    public void outStack1ToStack2(){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n    }\r\n}\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996378125","body":"# 语言\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stk = new LinkedList<>();\r\n        for(int num : arr){\r\n            if(!stk.isEmpty() && num < stk.peek()){\r\n                int head = stk.pop();\r\n                while(!stk.isEmpty() && num < stk.peek()) {\r\n                    stk.pop();\r\n                }\r\n                stk.push(head);\r\n            }else{\r\n                stk.push(num);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997206914","body":"# 语言\r\njava\r\n\r\n# 思路\r\n三种解法\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n    /**\r\n     * 第一种解法：k次旋转，每一次旋转都是把最后一个节点拿上然后拼到头上\r\n     * 构建一个stack，从里面取出最后一个节点和倒数第二个节点拼头上\r\n     * 同时需要注意k > size 的问题，取模即可\r\n     */\r\n    class Solution1 {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (head == null) {\r\n                return null;\r\n            }\r\n            ListNode currHead = head;\r\n            ListNode p = head;\r\n            Stack<ListNode> stack = new Stack<>();\r\n            while (p != null) {\r\n                stack.push(p);\r\n                p = p.next;\r\n            }\r\n            for (int i = k % stack.size(); i > 0; i--) {\r\n                ListNode last = stack.pop();\r\n                ListNode pre = stack.peek();\r\n                if (pre != null) {\r\n                    pre.next = null;\r\n                    last.next = currHead;\r\n                }\r\n                currHead = last;\r\n            }\r\n            return currHead;\r\n        }\r\n    }\r\n\r\n    //leetcode submit region begin(Prohibit modification and deletion)\r\n\r\n    /**\r\n     * 第二种解法：将k取模拿到最小k,之后将最后k个元素拼头上，快慢指针搞定即可\r\n     */\r\n    class Solution2 {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (head == null) {\r\n                return head;\r\n            }\r\n            ListNode slow = head;\r\n            ListNode fast = head;\r\n            for (int i = 0; i < k; i++) {\r\n                if (fast.next == null) {\r\n                    //超过一轮时重新开始走,这边也可以优化成模(但是前提需要知道链表总长度至少要遍历一次),可以免去不停的循环遍历\r\n                    fast = head;\r\n                } else {\r\n                    fast = fast.next;\r\n                }\r\n            }\r\n            //快慢指针间距离为0，移动0个位置，直接返回head\r\n            if (fast == head) {\r\n                return head;\r\n            }\r\n            while (fast.next != null) {\r\n                slow = slow.next;\r\n                fast = fast.next;\r\n            }\r\n            ListNode newHead = slow.next;\r\n            fast.next = head;\r\n            slow.next = null;\r\n            return newHead;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 第三种解法：其实就是找到某一处断开链子拼到头上而已\r\n     * 先遍历一圈得出链表长度,之后取模看看链子需要从哪断开,之后断开并拼接即可\r\n     */\r\n    class Solution {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (head == null) {\r\n                return null;\r\n            }\r\n            int length = 1;\r\n            ListNode tail = head;\r\n            while (tail.next != null) {\r\n                length++;\r\n                tail = tail.next;\r\n            }\r\n            ListNode p = head;\r\n            int n = length - k % length;\r\n            for (int i = 0; i < n - 1; i++) {\r\n                p = p.next;\r\n            }\r\n\r\n            tail.next = head;\r\n            head = p.next;\r\n            p.next = null;\r\n\r\n            return head;\r\n        }\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997405022","body":"# 思路\r\n递归\r\n\r\n# 语言\r\njava\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode next = head.next;\r\n        head.next = swapPairs(next.next);\r\n        next.next = head;\r\n        return next;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂付 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997540151","body":"# 思路 \r\n快慢指针\r\n\r\n# 语言\r\njava\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n\r\n        // 快慢指针找中心节点\r\n        ListNode x = head, y = head, pre = null;\r\n        while (y != null && y.next != null) {\r\n            pre = x;\r\n            x = x.next;\r\n            y = y.next.next;\r\n        }\r\n        pre.next = null;\r\n       \r\n        // 以升序链表的中间元素作为根节点 root，递归的构建 root 的左子树与右子树。\r\n        TreeNode root = new TreeNode(x.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(x.next);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998454187","body":"# 语言\r\njava\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null){\r\n            return null;\r\n        }\r\n        ListNode pA = headA; ListNode pB = headB;\r\n        while(pA != pB){\r\n            pA = (pA == null) ? headB : pA.next;\r\n            pB = (pB == null) ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999244641","body":"# 思路\r\n快慢指针\r\n\r\n# 语言\r\njava\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode pos = head;\r\n        Set<ListNode> visited = new HashSet<ListNode>();\r\n        while(pos != null){\r\n            if(visited.contains(pos)){\r\n                return pos;\r\n            }else{\r\n                visited.add(pos);\r\n            }\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999998615","body":"# 语言\r\njava\r\n\r\n```java\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode(){\r\n\r\n        }\r\n        public DLinkedNode(int _key, int _value){\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head;\r\n    private DLinkedNode tail;\r\n\r\n    public LRUCache(int capacity){\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        // 使用伪头部和伪尾部节点\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache.put(key, newNode);\r\n            // 添加至双向链表的头部\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode tail = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000763864","body":"# 思路\r\n使用Queue\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n        queue.offer(root);\r\n        int ans = 0;\r\n        while(!queue.isEmpty()){\r\n            int size = queue.size();\r\n            while(size > 0){\r\n                TreeNode node = queue.poll();\r\n                if(node.left != null){\r\n                    queue.offer(node.left);\r\n                }\r\n                if(node.right != null){\r\n                    queue.offer(node.right);\r\n                }\r\n                size--;\r\n            }\r\n            ans++;\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000961849","body":"# 思路 \r\n使用Queue\r\n\r\n# 语言\r\nJAVA\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        }\r\n        Queue<TreeNode> queue1 = new LinkedList<TreeNode>();\r\n        Queue<TreeNode> queue2 = new LinkedList<TreeNode>();\r\n        queue1.offer(p);\r\n        queue2.offer(q);\r\n        while (!queue1.isEmpty() && !queue2.isEmpty()) {\r\n            TreeNode node1 = queue1.poll();\r\n            TreeNode node2 = queue2.poll();\r\n            if (node1.val != node2.val) {\r\n                return false;\r\n            }\r\n            TreeNode left1 = node1.left, right1 = node1.right, left2 = node2.left, right2 = node2.right;\r\n            if (left1 == null ^ left2 == null) {\r\n                return false;\r\n            }\r\n            if (right1 == null ^ right2 == null) {\r\n                return false;\r\n            }\r\n            if (left1 != null) {\r\n                queue1.offer(left1);\r\n            }\r\n            if (right1 != null) {\r\n                queue1.offer(right1);\r\n            }\r\n            if (left2 != null) {\r\n                queue2.offer(left2);\r\n            }\r\n            if (right2 != null) {\r\n                queue2.offer(right2);\r\n            }\r\n        }\r\n        return queue1.isEmpty() && queue2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dana-dai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oasans":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"changanyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997405853","body":"> # 24. 两两交换链表中的节点\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n> \r\n> ## 前置知识\r\n> * 链表的基本知识\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n> \r\n> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> ```\r\n> \r\n> ![image](https://camo.githubusercontent.com/37e86afda9f65871e855a3affee582b2c887ab3087927b4dc92801bc6d4ad26f/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30332f737761705f6578312e6a7067)\r\n> \r\n> ```\r\n> 输入：head = [1,2,3,4]\r\n> 输出：[2,1,4,3]\r\n> 示例 2：\r\n> \r\n> 输入：head = []\r\n> 输出：[]\r\n> 示例 3：\r\n> \r\n> 输入：head = [1]\r\n> 输出：[1]\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 链表中节点的数目在范围 [0, 100] 内\r\n> 0 <= Node.val <= 100\r\n> ```\r\n### 朴素交换+头结点设置\r\n\"\"\"python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        node1=ListNode(-1)\r\n        prev=node1\r\n        node1.next=head\r\n        while prev.next and prev.next.next:\r\n            node2=prev.next\r\n            node3=prev.next.next\r\n            node2.next=node3.next\r\n            node3.next=node2\r\n            prev.next=node3\r\n\r\n            prev=node2\r\n        return node1.next\r\n\"\"\"\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurence-try":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991995246","body":"```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s) for x in range (len(s))]\n        p = 0\n        count = 0\n        flag = False\n        while p < len(s):\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    res[p] = count\n            p += 1\n        count = 0\n        flag = False\n        p -= 1\n        while p >= 0:\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    if res[p] > count:\n                        res[p] = count\n            p -= 1\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996615284","body":"```py\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr_sort = arr.copy()\n        arr_sort.sort()\n        count = 0\n        for i in range (len(arr)):\n            arr_sub = arr[:(i+1)]\n            arr_sort_sub = arr_sort[:(i+1)]\n            arr_sub.sort()\n            arr_sort_sub.sort()\n            if arr_sub == arr_sort_sub:\n                count += 1\n        return count\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: \n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997406728","body":"```py\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        res = ListNode()\n        res.next = head.next\n        pre = res\n        while head and head.next:\n            p1 = head.next\n            p2 = p1.next\n            p1.next = head\n            pre.next = p1\n            head.next = p2\n            pre = head\n            head = p2\n        return res.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997494325","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        slow = head\n        fast = head\n        slow_pre = None\n        while fast and fast.next:\n            fast = fast.next.next\n            slow_pre = slow\n            slow = slow.next\n        if slow_pre:\n            slow_pre.next = None\n        node = TreeNode(slow.val)\n        if fast == slow:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998673222","body":"```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        nodes_B = set()\n        while headB:\n            nodes_B.add(headB)\n            headB = headB.next\n        while headA:\n            if headA in nodes_B:\n                return headA\n            headA = headA.next\n        return None\n```\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001106308","body":"```py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root, cur):\n            if not root: return 0\n            if not root.left and not root.right: return cur * 10 + root.val\n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n        return dfs(root, 0)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinhma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronghuanyou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-battle":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991860618","body":"## 思路\r\n\r\n## 关键点\r\n\r\n从num的最后一位往前遍历，同时维护carry进位。循环条件是num下标合法或者k大于0才结束，那么累加的时候就要注意数组num下标的合法性。最后退出循环后再检查一下carry，防止漏加。将最后结果reverse后返回即可。 \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n\r\n        int carry = 0;\r\n        for (int i = num.size() - 1, j = 0; i >= 0 || k > 0; --i, ++j) {\r\n            auto tmp = (i >= 0 ? num[i] : 0) + k % 10 + carry;\r\n            res.emplace_back(tmp % 10);\r\n            carry = tmp / 10;\r\n            k /= 10;\r\n        }\r\n\r\n        if (carry) {\r\n            res.emplace_back(carry);\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992064558","body":"## 思路\r\n\r\n## 关键点\r\n\r\n遍历s的时候，分别以当前位置往前、往后遍历，遇到期望字符c就更新dis，并结束某个方向的查找。\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res;\r\n        for (int i = 0; i < s.length(); ++i) {\r\n            int dis = s.length();\r\n            for (int pos = i; pos >= 0; --pos) {\r\n                if (s[pos] == c) {\r\n                    dis = min(i - pos, dis);\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            for (int pos = i; pos < s.length(); ++pos) {\r\n                if (s[pos] == c) {\r\n                    dis = min(pos - i, dis);\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            res.emplace_back(dis);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993130689","body":"## 思路\r\n\r\n## 关键点\r\n1、push和pop：非常简单就不说了\r\n2、increment：维护一个辅助栈，每次increment的时候就先把res栈中的所有元素都搞到tmp中，然后再从tmp中出栈搞到res，搞的时候判断个数，前k个元素加上增量值val\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : cap(maxSize) {\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        if (num < cap) {\r\n            res.push(x);\r\n            ++num;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (!res.empty()) {\r\n            --num;\r\n            auto t = res.top();\r\n            res.pop();\r\n            return t;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        while (!res.empty()) {\r\n            tmp.push(res.top());\r\n            res.pop();\r\n        }\r\n        \r\n        while (!tmp.empty()) {\r\n            if (k-- > 0) {\r\n                res.push(tmp.top() + val);\r\n            } else {\r\n                res.push(tmp.top());\r\n            }\r\n            \r\n            tmp.pop();\r\n        }\r\n    }\r\nprivate:\r\n    int cap = 0;\r\n    int num = 0;\r\n    stack<int> res;\r\n    stack<int> tmp;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994731006","body":"## 思路\r\n\r\n## 关键点\r\n\r\n从头遍历字符串\r\n1、遇到数字，一直凑数字\r\n2、遇到字母，一直凑字母\r\n3、遇到“[”，把上面凑的数字和字母都分别放到对应栈中，且复位数字和字母\r\n4、遇到“]”，表示可以结算了，分别从数字栈和字母栈中取出值，然后重复n次，进行累加\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        \r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        int num = 0;\r\n        for (int i = 0; i < s.length(); ++i) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                num = num * 10 + (s[i] - '0');\r\n            } else if ((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z')) {\r\n                res += s[i];\r\n            } else if (s[i] == '[') {\r\n                nums.push(num);\r\n                num = 0;\r\n                \r\n                strs.push(res); \r\n                res.clear();\r\n            } else {\r\n                int times = nums.top();\r\n                nums.pop();\r\n                for(int j = 0; j < times; ++ j) {\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top(); \r\n                strs.pop();\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995730357","body":"## 思路\r\n\r\n## 关键点\r\n\r\n使用2个栈\r\n1、push的时候正常push到真正栈\r\n2、pop或者peek的时候先看辅助栈，不为空就从辅助栈里面取，否则把真正栈都出栈到辅助栈，再操作辅助栈\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        realst.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int res;\r\n        if (helperst.empty()) {\r\n            while (!realst.empty()) {\r\n                helperst.push(realst.top());\r\n                realst.pop();\r\n            }\r\n        }\r\n        res = helperst.top();\r\n        helperst.pop();\r\n\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (helperst.empty()) {\r\n            while (!realst.empty()) {\r\n                helperst.push(realst.top());\r\n                realst.pop();\r\n            }\r\n        }\r\n\r\n        return helperst.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return realst.empty() && helperst.empty();\r\n    }\r\nprivate:\r\n    stack<int> realst;\r\n    stack<int> helperst;\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996792906","body":"## 思路\r\n\r\n## 关键点\r\n\r\n使用栈  \r\n1、先把第1个元素放入栈中  \r\n2、后面遍历arr的时候和栈顶比较  \r\n（1）大于栈顶就放入栈中，表示可以他们之间可以切分\r\n（2）小于栈顶说明不能切分，那么保存下栈顶元素，再出栈直到栈顶元素小于遍历的元素或者栈为空，再把保存的元素放入栈中，这是为了后面在遍历的时候依旧用它作为分界点去决定是否可以切分 \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        if (arr.empty()) {\r\n            return 0;\r\n        }\r\n        \r\n        stack<int> st;\r\n        \r\n        st.push(arr[0]);\r\n        for (int i = 1; i < arr.size(); ++i) {\r\n            if (st.empty() || st.top() < arr[i]) {\r\n                st.push(arr[i]);\r\n            } else {\r\n                auto maxtop = st.top();\r\n                while (!st.empty() && st.top() > arr[i]) {\r\n                    st.pop();\r\n                }\r\n                \r\n                st.push(maxtop);\r\n            }\r\n        }\r\n        \r\n        return st.size();\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997213124","body":"## 思路\r\n\r\n## 关键点\r\n\r\n快慢指针\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr) {\r\n            return head;\r\n        }\r\n\r\n        int len = 0;\r\n        auto tmp = head;\r\n        while (tmp != nullptr) {\r\n            tmp = tmp->next;\r\n            ++len;\r\n        }\r\n\r\n        k %= len;\r\n\r\n        auto slow = head, fast = head;\r\n        while (k--) {\r\n            fast = fast->next;\r\n        }\r\n        while (fast->next != nullptr) {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n\r\n        fast->next = head;\r\n        auto res = slow->next;\r\n        slow->next = nullptr;\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997402218","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:           \r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        \r\n        auto dummy = new ListNode(-1);\r\n        dummy->next = head;\r\n        auto tmp = dummy;\r\n        \r\n        while (tmp->next != nullptr && tmp->next->next != nullptr) {\r\n            auto fn = tmp->next;\r\n            auto sn = tmp->next->next;\r\n            auto next = sn->next;\r\n            \r\n            tmp->next = sn;\r\n            fn->next = next;\r\n            sn->next = fn;\r\n            tmp = fn;\r\n        }\r\n        \r\n        return dummy->next;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997944642","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (head == nullptr) {\r\n            return nullptr;\r\n        }\r\n        \r\n        if (head->next == nullptr) {\r\n            return new TreeNode(head->val);\r\n        }\r\n        \r\n        auto res = getMid(head);\r\n        if (res.second == nullptr) {\r\n            return nullptr;\r\n        }\r\n        \r\n        auto cur = res.second;\r\n        auto nexthead = res.second->next;\r\n        res.first->next = nullptr;\r\n        \r\n        TreeNode* root = new TreeNode(cur->val);\r\n        root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(nexthead);\r\n        \r\n        return root;\r\n    }\r\n    \r\n    pair<ListNode*, ListNode*> getMid(ListNode* head) {\r\n        auto slow = head, fast = head;\r\n        auto prev = slow;\r\n        while (fast != nullptr && fast->next != nullptr) {\r\n            prev = slow;\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        \r\n        return {prev, slow};\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998717022","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == nullptr || headB == nullptr) {\r\n            return nullptr;\r\n        }\r\n\r\n        auto lenA = getLen(headA);\r\n        auto lenB = getLen(headB);\r\n        auto diff = abs(lenA - lenB);\r\n\r\n        if (lenA > lenB) {\r\n            while (diff--) {\r\n                headA = headA->next;\r\n            }\r\n        } else {\r\n            while (diff--) {\r\n                headB = headB->next;\r\n            }\r\n        }\r\n\r\n        while (headA != nullptr && headB != nullptr) {\r\n            if (headA == headB) {\r\n                return headA;\r\n            }\r\n\r\n            headA = headA->next;\r\n            headB = headB->next;\r\n        }\r\n\r\n        return nullptr;\r\n    }\r\n\r\n    int getLen(ListNode* head) {\r\n        int res = 0;\r\n        while (head != nullptr) {\r\n            ++res;\r\n            head = head->next;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999653623","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        auto slow = head;\r\n        auto fast = head;\r\n        while (fast != nullptr && fast->next != nullptr) { \r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n\r\n            if (slow == fast) {\r\n                slow = head;\r\n                while (slow != fast) {\r\n                    slow = slow->next;\r\n                    fast = fast->next;\r\n                }\r\n\r\n                return slow;\r\n            }\r\n        }\r\n\r\n        return nullptr;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000332549","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) {\r\n        size = 0;\r\n        \r\n        this->capacity = capacity;\r\n\r\n        head = new ListNode(-1, -1);\r\n        tail = new ListNode(-1, -1);\r\n\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (um.find(key) != um.end()) {\r\n            auto node = um[key];\r\n\r\n            removeNode(key);\r\n            addToHead(key, node->value);\r\n\r\n            return node->value;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (um.find(key) != um.end()) {\r\n            removeNode(key);\r\n            addToHead(key, value);\r\n        } else {\r\n            addToHead(key, value);\r\n        }\r\n    }\r\n\r\nprivate:\r\n    void removeNode(int key) {\r\n        auto node = um[key];\r\n\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n\r\n        --size;\r\n\r\n        um.erase(key);\r\n    }\r\n\r\n    void addToHead(int key, int value) {\r\n        auto node = new ListNode(key, value, head, head->next);\r\n        head->next->prev = node;\r\n        head->next = node;\r\n\r\n        um[key] = node;\r\n        ++size;\r\n        \r\n        // 干掉链表最后一个节点\r\n        if (size > capacity) {\r\n            auto dnode = tail->prev;\r\n            removeNode(dnode->key);\r\n        }\r\n    }\r\n\r\nprivate:\r\n    class ListNode {\r\n    public:\r\n        int key;\r\n        int value;\r\n        ListNode * prev;\r\n        ListNode * next;\r\n    \r\n        ListNode(int k, int v, ListNode* p = nullptr, ListNode* n = nullptr) :\r\n            key(k), value(v), prev(p), next(n) {}\r\n    };\r\n\r\n    // 虚拟头、尾节点\r\n    ListNode* head;\r\n    ListNode* tail;\r\n    \r\n    int size; \r\n\r\n    int capacity;\r\n\r\n    unordered_map<int, ListNode*> um;\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000848597","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n\r\n        auto left = maxDepth(root->left);\r\n        auto right = maxDepth(root->right);\r\n\r\n        return 1 + max(left, right);\r\n    }\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001023843","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == nullptr || q == nullptr) {\r\n            return p == nullptr && q == nullptr;\r\n        }\r\n\r\n        if (p->val != q->val) {\r\n            return false;\r\n        }\r\n\r\n        return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991831999","body":"var addToArrayForm = function(A, K) {\n    const res = [];\n    const n = A.length;\n    for (let i = n - 1; i >= 0 || K > 0; --i, K = Math.floor(K / 10)) {\n        if (i >= 0) {\n            K += A[i];\n        }\n        res.push(K % 10);\n    }\n    res.reverse();\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992487560","body":"/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993299762","body":"/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n    this.queue = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.queue.length<this.maxSize) this.queue.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.queue.length==0) return -1;\n    return this.queue.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let i=0;\n    while(i<k&&i<this.queue.length){\n        this.queue[i] += val\n        i++\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994751248","body":"var decodeString = (s) => {\n  let stack = []\n  for (const char of s) {\n    if (char !== ']') { \n      stack.push(char)\n      continue\n    }\n    let cur = stack.pop() \n    let str = '' \n    while (cur !== '[') {\n      str = cur + str \n      cur = stack.pop() \n    }\n    let num = ''\n    cur = stack.pop() \n    while (!isNaN(cur)) {\n      num = cur + num \n      cur = stack.pop() \n    }\n    stack.push(cur)\n    stack.push(str.repeat(num))\n  }\n  return stack.join('')\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995503995","body":"var MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996640919","body":"var maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if (sum1 === sum2) count++;\n    }\n    return count;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997136000","body":"var rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997387654","body":"var swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let node = new ListNode('head')\n    node.next = head\n    let prev = node\n    let curr = node.next\n    let next = node.next.next\n    while(next) {\n        let nextNode = next.next\n        curr.next = nextNode\n        next.next = curr\n        prev.next = next\n        if(!nextNode) break\n        prev = curr\n        curr = nextNode\n        next = nextNode.next\n    }\n    return node.next\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997843200","body":"const sortedListToBST = (head) => {\n  if (head == null) return null;\n  let len = 0;\n  let h = head;  // h初始指向头结点\n  while (head) { // 计算链表节点个数\n    len++;\n    head = head.next;\n  }\n\n  const buildBST = (start, end) => {\n    if (start > end) return null;     // 递归出口，返回null节点\n    const mid = (start + end) >>> 1;  // 求mid，只是为了分治，不是用它断开链表\n    const left = buildBST(start, mid - 1); // 先递归构建左子树\n\n    const root = new TreeNode(h.val);      // 根据 h.val 构建节点\n    h = h.next;          // h指针步进              \n    root.left = left;    // root接上构建好的左子树        \n\n    root.right = buildBST(mid + 1, end); // 构建当前root的右子树，接上\n    return root;\n  };\n\n  return buildBST(0, len - 1);\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998626532","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (headA === null || headB === null) {\n        return null;\n    }\n    let left = headA, right = headB;\n    while (left !== right) {\n        left = left === null ? headB : left.next;\n        right = right === null ? headA : right.next;\n    }\n    return left;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999250694","body":"var detectCycle = function(head) {\n    if(!head) return null\n    let prev = head\n    let curr = head\n    while(curr) {\n        prev = prev.next\n        if(curr.next!=null){\n            curr = curr.next.next\n        }else{\n            return null\n        }\n        if(prev==curr){\n            let ptr = head;\n            while (ptr !== prev) {\n                ptr = ptr.next;\n                prev = prev.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000241979","body":"class ListNode {\n    constructor(key, value) {//双向链表的单个节点\n        this.key = key\n        this.value = value\n        this.next = null //指向后一个节点\n        this.prev = null //指向前一个节点\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity //容量\n        this.hashTable = {} //存放键值对信息\n        this.count = 0 //键值对数量\n        this.dummyHead = new ListNode() //dummy头节点 方便在链表从开始的地方插入\n        this.dummyTail = new ListNode()\t//dummy尾节点 方便在链表从末尾删除\n        this.dummyHead.next = this.dummyTail //dummyHead和dummyTail相互连接\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    get(key) {\n        let node = this.hashTable[key]//查找哈希表中的键值对\n        if (node == null) return -1 //不存在该键值对 返回-1\n        this.moveToHead(node) //移动到链表头\n        return node.value\n    }\n\n    put(key, value) {\n        let node = this.hashTable[key] //哈希表中查找该键值对\n        if (node == null) {\n            let newNode = new ListNode(key, value) //不存在就创建节点\n            this.hashTable[key] = newNode //加入哈希表\n            this.addToHead(newNode) //加入链表头\n            this.count++ //节点数+1\n            if (this.count > this.capacity) { //超过容量 从队尾删除一个\n                this.removeLRUItem()\n            }\n        } else {\n            node.value = value //键值对存在于哈希表中 就更新\n            this.moveToHead(node) //移动到队头\n        }\n    }\n\n    moveToHead(node) {\n        this.removeFromList(node)//从链表中删除节点\n        this.addToHead(node)//将该节点添加到链表头\n    }\n\n    removeFromList(node) {//删除的指针操作\n        let tempForPrev = node.prev\n        let tempForNext = node.next\n        tempForPrev.next = tempForNext\n        tempForNext.prev = tempForPrev\n    }\n\n    addToHead(node) {//加入链表头的指针操作\n        node.prev = this.dummyHead\n        node.next = this.dummyHead.next\n        this.dummyHead.next.prev = node\n        this.dummyHead.next = node\n    }\n\n    removeLRUItem() {\n        let tail = this.popTail()//从链表中删除\n        delete this.hashTable[tail.key]//从哈希表中删除\n        this.count--\n    }\n\n    popTail() {\n        let tailItem = this.dummyTail.prev//通过dummyTail拿到最后一个节点 然后删除\n        this.removeFromList(tailItem)\n        return tailItem\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000803346","body":"var maxDepth = function(root) {\n    if(!root) return 0\n    let res = 0;\n    let deep = (root,index)=> {\n        if(!root.left && !root.right) {\n            res=Math.max(res,index)\n            return\n        }\n        if(root.left) deep(root.left,index+1)\n        if(root.right) deep(root.right,index+1)\n    }\n    deep(root,1)\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000958393","body":"```\nvar isSameTree = function(p, q) {\n    let res = true;\n    let inorder = (p,q)=>{\n        if(!res) return\n        if(!p && q || p&&!q) {\n            res=false;\n            return;\n        }\n        else if(!p && !q){\n            return;\n        }else{\n            if(p.val!=q.val){\n                res=false;\n                return;\n            }\n            inorder(p.left,q.left);\n            inorder(p.right,q.right);\n        }\n    }\n    inorder(p,q)\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52hzecho":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993116397","body":"### 思路\r\n利用一个额外的stack来存delta\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.myStack = []\r\n        self.delta = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.myStack)<self.maxSize:\r\n            self.myStack.append(x)\r\n            self.delta.append(0)\r\n        \r\n        \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if len(self.myStack)==0:\r\n            return -1\r\n        delta = self.delta.pop()\r\n        \r\n        if self.delta:\r\n            self.delta[-1]+=delta\r\n        return self.myStack.pop()+delta\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = len(self.myStack)\r\n        if length ==0:\r\n            return None\r\n        inc_length = k\r\n        if k>length:\r\n            inc_length = length     \r\n        self.delta[inc_length-1]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push,pop O(1), increment O(min(K, maxSize))\r\n- 空间复杂度：O(maxSize)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994972347","body":"### 思路\r\n\r\n通过辅助栈作为pop的存储，通过主栈作为push的存储\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass MyQueue:\r\n    from collections import deque\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.main_stack = []\r\n        self.aux_stack = []\r\n        \r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if len(self.main_stack) == 0:\r\n            self.front = x\r\n        self.main_stack.append(x)\r\n            \r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.aux_stack)==0:\r\n            \r\n            self.aux_stack = self.main_stack[::-1]\r\n            self.main_stack = []\r\n        return self.aux_stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.aux_stack) == 0:\r\n            return self.front\r\n        return self.aux_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        \r\n        return len(self.main_stack)==0 and len(self.aux_stack)==0\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996441186","body":"### 思路\r\n从array的尾部开始计算，save当前的最小值，每次前面存在比当前最小值更小的element，则需要从新sort一次。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        if not arr:\r\n            return 0\r\n        head = [0]*len(arr)\r\n        head[0] = arr[0]\r\n        \r\n        result = 0\r\n        for i in range(1,len(arr)): \r\n            head[i] = max(arr[i],head[i-1])\r\n        print(head)\r\n        tail = float('inf')\r\n        for i in range(len(arr)-1,-1,-1):\r\n            \r\n            if tail>=head[i]:\r\n                result+=1\r\n            tail = min(tail,arr[i])\r\n        return result\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997120836","body":"### 思路\r\n\r\n找点旋转后的head，然后断开和前一个node的链接。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not k:\r\n            return head\r\n        \r\n        \r\n        \r\n        curr = head\r\n        l_len = 1\r\n        while curr.next:\r\n            curr = curr.next\r\n            l_len+=1\r\n        move = k%l_len\r\n        \r\n        curr.next = head\r\n        \r\n        curr = head\r\n        \r\n        for _ in range(l_len-move-1):\r\n            curr = curr.next\r\n        result = curr.next\r\n        curr.next = None\r\n        return result\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997306147","body":"### 思路\r\n\r\n通过recursive，每次取前两个node\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n       \r\n        if not head or not head.next:\r\n            return head\r\n        first,second = head, head.next\r\n        first.next = self.swapPairs(second.next)\r\n        second.next =first\r\n        return second\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997571971","body":"### 思路\r\n\r\n通过分治，每次从中点，left为head，right为中点后的node\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        prev = None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        prev.next = None\r\n        \r\n        return TreeNode(slow.val,self.sortedListToBST(head),self.sortedListToBST(slow.next))\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NLOGN)，其中 N 为数组长度。\r\n- 空间复杂度：O(LOGN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998317421","body":"### 思路\r\n\r\n通过set存储一个list的全部节点，然后检查另外一个list的节点，直到找到第一个相同的。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_set = set()\r\n        \r\n        while headA:\r\n            node_set.add(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            if headB in node_set:\r\n                \r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998976586","body":"### 思路\r\n\r\n同样的可以使用一个set，找到的第一个重复的node则为结果。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head:\r\n            return None\r\n        visited = set()\r\n        while head:\r\n            if head in visited:\r\n                return head\r\n            else:\r\n                visited.add(head)\r\n            head = head.next\r\n            \r\n        return None\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999810348","body":"### 思路\r\n\r\n通过双端队列，使得put和get达到O(1)的时间复杂度\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Node:\r\n    def __init__(self):\r\n        self.key = 0\r\n        self.value = 0\r\n        self.prev = None\r\n        self.next = None\r\n        \r\nclass LRUCache:\r\n    def _add_node(self,node):\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        \r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    def _remove_node(self,node):\r\n        prev = node.prev\r\n        new = node.next\r\n        prev.next = new\r\n        new.prev = prev \r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity =capacity\r\n        self.size = 0 \r\n        self.head,self.tail = Node(),Node()\r\n        self.cache={}\r\n        self.head.next,self.tail.prev= self.tail,self.head\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        node = self.cache.get(key,None)\r\n        if not node:\r\n            return -1\r\n        self._remove_node(node)\r\n        self._add_node(node)\r\n        return node.value\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        curr = self.cache.get(key,None)\r\n        if not curr:\r\n            node = Node()\r\n            node.key = key\r\n            node.value = value\r\n            self.cache[key] = node\r\n            self._add_node(node)\r\n            self.size+=1\r\n        else:\r\n            curr.value = value\r\n            self._remove_node(curr)\r\n            self._add_node(curr)\r\n        \r\n        if self.size > self.capacity:\r\n            the_node  = self.tail.prev\r\n            self._remove_node(the_node)\r\n            \r\n            self.cache.pop(the_node.key)\r\n            self.size-=1\r\n        \r\n            \r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(Capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000490427","body":"### 思路\r\n\r\n通过stack，层序遍历tree，每层增加层高计数。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        stack = [root]\r\n        ans=0\r\n        while stack:\r\n            n = len(stack)\r\n            for _ in range(n):\r\n                curr = stack.pop(0)\r\n                if curr.left:\r\n                    stack.append(curr.left)\r\n                if curr.right:\r\n                    stack.append(curr.right)\r\n            ans+=1\r\n        return ans\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(logN)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lareinawei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiajune":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzh-zh3ndu1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doublew2w":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992618576","body":"## 思路\n遍历一次数组，将字符c的位置记录下来\n\n再次遍历数组，然后比较当前字符和目标字符的最小距离\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        //遍历数组，将字符C的位置存放起来\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        //遍历数组，比较出距离的最小值\n        for (int i = 0; i < s.length(); i++) {\n            //如果当前字符夹在两个目标字符中间，则比较最小的，否则直接取\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n\n```\n## 复杂度分析\n\n时间复杂度：O（n）\n\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"toms-bigdata":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834648","body":"# 【Day 1】989. 数组形式的整数加法\n## 思路\n数字转化成数组，按位相加，注意进位\n## Golang代码\n```\nfunc reverse(num []int) {\n\tfor i, j := 0, len(num)-1; i < j; {\n\t\tnum[i], num[j] = num[j], num[i]\n\t\ti++\n\t\tj--\n\t}\n}\n\nfunc addToArrayForm(num []int, k int) []int {\n\tif k == 0 {\n\t\treturn num\n\t}\n\tk_list := make([]int, 5)\n\n\tfor i:=0;k != 0;i++{\n\t\tk_list[i] = k%10\n\t\tk/=10\n\t}\n\tmax_length := int(math.Max(float64(len(num)), float64(len(k_list)))) + 1\n\tans := make([]int, max_length)\n\treverse(num)\n\n\tfor i := 0; i < max_length; i++ {\n\t\tnum_num := 0\n\t\tk_num := 0\n\t\tans_num := ans[i]\n\t\tif i < len(num) {\n\t\t\tnum_num = num[i]\n\t\t}\n\t\tif i < len(k_list) {\n\t\t\tk_num = k_list[i]\n\t\t}\n\t\tdata := num_num + k_num + ans_num\n\t\tif data >= 10 {\n\t\t\tans[i+1] += 1\n\t\t}\n\t\tans[i] = data % 10\n\t}\n\n\treverse(ans)\n\ti := 0\n\tfor ans[i] == 0 {\n\t\ti++\n\t}\n\treturn ans[i:]\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992046651","body":"# 【Day 2】821. 字符的最短距离\n## 思路\n建立距离数组，找到首位和末位的字符，将距离数组首位字符之前和末位字符后的字符距离更新，之后将两字符之间的字母前向遍历一次，后向遍历一次，更新距离数组，返回距离数组\n## 代码\n```\nfunc shortestToChar(s string, c byte) []int {\n\tfirst_num := strings.IndexByte(s, c)\n\tlast_num := strings.LastIndexByte(s, c)\n\tarray := make([]int, len(s))\n\tif first_num == last_num {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tarray[i] = int(math.Abs(float64(i - first_num)))\n\t\t}\n\t\treturn array\n\t}\n\n\tfor k, _ := range s[:first_num] {\n\t\tarray[k] = int(math.Abs(float64(k - first_num)))\n\t}\n\tif last_num < len(s)-1 {\n\t\tfor i := last_num;i<len(s);i++{\n\t\t\tarray[i] = int(math.Abs(float64(i - last_num)))\n\t\t}\n\t}\n\tif first_num + 1 < last_num{\n\t\tperiod_num := first_num\n\t\tfor i := first_num; i < last_num; i++ {\n\n\t\t\tif s[i] == c {\n\t\t\t\tperiod_num = i\n\t\t\t}\n\t\t\tarray[i] = int(math.Abs(float64(i - period_num)))\n\t\t}\n\t\tperiod_num = last_num\n\t\tfor i := last_num; i > first_num; i-- {\n\t\t\tif s[i] == c {\n\t\t\t\tperiod_num = i\n\t\t\t}\n\t\t\tarray[i] = int(math.Min(math.Abs(float64(i-period_num)), float64(array[i])))\n\t\t}\n\t}\n\treturn array\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993081130","body":"# 【Day 3】1381. 设计一个支持增量操作的栈\n## 思路\n数组模拟栈，唯一区别在inc,比较数组长度和K值，再循环增加\n## Golang代码\n```\ntype CustomStack struct {\n\tStack []int\n\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n\tif maxSize < 0{\n\t\treturn CustomStack{}\n\t}\n\treturn CustomStack{\n\t\tStack: make([]int , 0, maxSize),\n\t}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n\tif len(this.Stack) < cap(this.Stack){\n\t\tthis.Stack = append(this.Stack, x)\n\t}\n}\n\n\nfunc (this *CustomStack) Pop() int {\n\tif len(this.Stack) == 0 {\n\t\treturn -1\n\t}else {\n\t\tpop := this.Stack[len(this.Stack)-1]\n\t\tthis.Stack = this.Stack[:len(this.Stack)-1]\n\t\treturn pop\n\t}\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n\tchange_num := int(math.Min(float64(k), float64(len(this.Stack))))\n\tfor i :=0;i<change_num;i++{\n\t\tthis.Stack[i] += val\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994827676","body":"# 【Day 4】394. 字符串解码\n## 思路\n用栈执行括号匹配\n## golang代码\n```\nfunc decodeString(s string) string {\n\tstk := []string{}\n\tptr := 0\n\tfor ptr < len(s) {\n\t\tcur := s[ptr]\n\t\tif cur >= '0' && cur <= '9' {\n\t\t\tdigits := getDigits(s, &ptr)\n\t\t\tstk = append(stk, digits)\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\n\t\t\tstk = append(stk, string(cur))\n\t\t\tptr++\n\t\t} else {\n\t\t\tptr++\n\t\t\tsub := []string{}\n\t\t\tfor stk[len(stk)-1] != \"[\" {\n\t\t\t\tsub = append(sub, stk[len(stk)-1])\n\t\t\t\tstk = stk[:len(stk)-1]\n\t\t\t}\n\t\t\tfor i:=0;i<len(sub)/2;i++{\n\t\t\t\tsub[i],sub[len(sub)-i-1] = sub[len(sub)-i-1],sub[i]\n\t\t\t}\n\t\t\tstk = stk[:len(stk)-1]\n\t\t\trepTime,_:=strconv.Atoi(stk[len(stk)-1])\n\t\t\tstk = stk[:len(stk)-1]\n\t\t\tt := strings.Repeat(getString(sub), repTime)\n\t\t\tstk = append(stk, t)\n\t\t}\n\t}\n\treturn getString(stk)\n}\n\nfunc getDigits(s string, ptr *int) string {\n\tret := \"\"\n\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\n\t\tret += string(s[*ptr])\n\t}\n\treturn ret\n}\nfunc getString(v []string) string {\n\tret := \"\"\n\tfor _, s := range v {\n\t\tret += s\n\t}\n\treturn ret\n}\n```\n复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995388032","body":"# 【Day 5】232. 用栈实现队列\n## 思路\n两个栈一个队头一个队尾，因golang语言特性，无需考虑溢出问题，push直接往队头栈推进，pop和peak判断队尾栈是否为空，为空则队头栈出，队尾栈入。\n## golang代码\n```\ntype MyQueue struct {\n\tfirstack []int\n\tsecstack []int\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tfirstack: []int{},\n\t\tsecstack: []int{},\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.firstack = append(this.firstack,x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\tif len(this.secstack) != 0{\n\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\tthis.secstack = this.secstack[:len(this.secstack)-1]\n\t\treturn popnum\n\t} else {\n\t\tif len(this.firstack) == 0{\n\t\t\treturn -1\n\t\t}else {\n\t\t\tfor len(this.firstack)!= 0{\n\t\t\t\tnum:= this.firstack[len(this.firstack)-1]\n\t\t\t\tthis.firstack = this.firstack[:len(this.firstack)-1]\n\t\t\t\tthis.secstack = append(this.secstack, num)\n\t\t\t}\n\t\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\t\tthis.secstack = this.secstack[:len(this.secstack)-1]\n\t\t\treturn popnum\n\t\t}\n\t}\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif len(this.secstack) != 0{\n\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\treturn popnum\n\t} else {\n\t\tif len(this.firstack) == 0{\n\t\t\treturn -1\n\t\t}else {\n\t\t\tfor len(this.firstack)!= 0{\n\t\t\t\tnum:= this.firstack[len(this.firstack)-1]\n\t\t\t\tthis.firstack = this.firstack[:len(this.firstack)-1]\n\t\t\t\tthis.secstack = append(this.secstack, num)\n\t\t\t}\n\t\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\t\treturn popnum\n\t\t}\n\t}\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif len(this.firstack) == 0 && len(this.secstack) == 0{\n\t\treturn true\n\t}\n\treturn false\n}\n```\n## 时间复杂度\npush:O(1)\npop,peak:因为队尾栈空时才会执行多次出入栈操作，平均时间复杂度为O(1)\nempty:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996464200","body":"# 【Day 6】768. 最多能完成排序的块 II\n## 思路\n借鉴题解\n单调栈：要想保证每一个块拼接后单调递增，就要保证每一个块的最大值是单调递增的，这时候就可以构建一个单调栈。\n具体做法：\n1.遍历数组arr中的每一个num\n2.当stack为空或者num>=栈顶值时：入栈（相当于添加了新的元素块）\n3.当栈 stack 不为空且数字 num<栈顶值 时：\n  （1）保存栈顶值head\n  *（2）当栈 stack 不为空且数字 num<栈顶值 时:循环出栈（此步是关键，因为num>=栈顶值时才能保证有序，所以要将前面所有的大于num的块儿合成一个）\n  （3）将head入栈（当前块的最大值）\n4.遍历结束后，stack的长度就是块的个数（很好理解，想一下就明白了）\n## Golang代码\n```\nfunc maxChunksToSorted(arr []int) int {\n\tif len(arr) == 0{\n\t\treturn 0\n\t}\n\tstack := []int{}\n\thead := -1\n\tfor i:=0;i<len(arr);i++{\n\t\tif len(stack) == 0 || arr[i] >= head{\n\t\t\tstack = append(stack,arr[i])\n\t\t\thead = arr[i]\n\t\t}else if arr[i]<head{\n\t\t\tfor len(stack)!= 0 &&stack[len(stack)-1]>arr[i]{\n\t\t\t\tstack = stack[:len(stack)-1]\n\t\t\t}\n\t\t\tstack = append(stack,head)\n\t\t}\n\t}\n\treturn len(stack)\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997190017","body":"# 【Day 7】61. 旋转链表\n## 思路\n将链表首尾相连成环，找到移动后的新的head断开\n## golang代码\n```\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif k==0 || head==nil || head.Next == nil{\n\t\treturn head\n\t}\n\tn:=1\n\titer:=head\n\tfor iter.Next !=nil{\n\t\titer = iter.Next\n\t\tn++\n\t}\n\tadd := n- k%n\n\tif add == n{\n\t\treturn head\n\t}\n\titer.Next = head\n\tfor add > 0{\n\t\titer = iter.Next\n\t\tadd--\n\t}\n\tret:=iter.Next\n\titer.Next = nil\n\treturn ret\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997320869","body":"# 【Day 8】24. 两两交换链表中的节点\r\n## 思路\r\n设置一个头节点，根据链表长度为单数或者双数确定终止条件，遍历链表两两交换\r\n## Golang代码\r\n```\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil{\r\n\t\treturn head\r\n\t}\r\n\tnum := 1\r\n\tnew_head := ListNode{0,head}\r\n\ta_point := &new_head\r\n\tb_point := head\r\n\tc_point := head.Next\r\n\tfor c_point != nil{\r\n\t\tc_point = c_point.Next\r\n\t\tnum++\r\n\t}\r\n\tc_point = head.Next\r\n\tb_point.Next = c_point.Next\r\n\ta_point.Next = c_point\r\n\tc_point.Next = b_point\r\n\tif num %2 == 0{\r\n\t\tfor b_point.Next != nil{\r\n\t\t\ta_point,b_point,c_point = exchangeListNode(a_point, b_point, c_point)\r\n\t\t}\r\n\t}else {\r\n\t\tfor b_point.Next.Next != nil{\r\n\t\t\ta_point,b_point,c_point = exchangeListNode(a_point, b_point, c_point)\r\n\t\t}\r\n\t}\r\n\treturn new_head.Next\r\n}\r\nfunc exchangeListNode(a_point *ListNode, b_point *ListNode, c_point *ListNode) (*ListNode, *ListNode, *ListNode) {\r\n\ta_point = a_point.Next.Next\r\n\tb_point = a_point.Next\r\n\tc_point = b_point.Next\r\n\tb_point.Next = c_point.Next\r\n\ta_point.Next = c_point\r\n\tc_point.Next = b_point\r\n\treturn a_point,b_point,c_point\r\n}\r\n```\r\n## 复杂度\r\n时间:O(n)\r\n空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997656808","body":"# 【Day 9】109. 有序链表转换二叉搜索树\n## 思路\n由题意可知，给定的有序链表相当于要构造的二叉树的中序遍历，通过二分法找到root，再通过中序遍历往树节点填充值。\n## golang代码\n```\nvar globalHead *ListNode\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tglobalHead = head\n\treturn makeTree(0,getLength(head)-1)\n}\nfunc getLength(head *ListNode) int {\n\t res := 0\n\t for ;head!=nil;head = head.Next{\n\t \tres++\n\t}\n\treturn res\n}\nfunc makeTree(left, right int) *TreeNode {\n\tif left > right {\n\t\treturn nil\n\t}\n\tmid := (left+right+1)/2\n\troot := &TreeNode{}\n\troot.Left = makeTree(left,mid-1)\n\troot.Val = globalHead.Val\n\tglobalHead = globalHead.Next\n\troot.Right = makeTree(mid+1,right)\n\treturn root\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998433464","body":"# 【Day 10】160. 相交链表\n## 思路\n判断两个链表长度，将长的剪成短的（因为，如果有相交节点，那么相交后的节点长度相同，所以截取前半段共同行走，就能找到相交点）\n## golang代码\n```\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil{\n    \treturn nil\n\t}\n\talength := getLengths(headA)\n\tblength := getLengths(headB)\n\tfor alength>blength{\n\t\theadA = headA.Next\n\t\talength--\n\t}\n\tfor blength>alength{\n\t\theadB = headB.Next\n\t\tblength--\n\t}\n\tfor alength!=0{\n\t\tif headA == headB{\n\t\t\treturn headA\n\t\t}\n\t\theadA = headA.Next\n\t\theadB = headB.Next\n\t\talength--\n\t}\n\treturn nil\n}\nfunc getLengths(head *ListNode) int {\n\tres:=1\n\tfor head.Next!=nil{\n\t\tres+= 1\n\t\thead = head.Next\n\t}\n\treturn res\n}\n```\n## 复杂度\n时间:O(m+n)\n空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999247030","body":"# 【Day 11】142. 环形链表 II\n## 思路\n快慢指针\n## golang代码\n```\nfunc detectCycle(head *ListNode) *ListNode {\n\tif head == nil || head.Next==nil{\n\t\treturn nil\n\t}\n\tslow:=head\n\tfast:=head\n\tfor fast != nil && fast.Next != nil{\n\t\tslow = slow.Next\n\t\tfast = fast.Next.Next\n\t\tif slow == fast{\n\t\t\tpre := head\n\t\t\tfor pre!= slow{\n\t\t\t\tpre = pre.Next\n\t\t\t\tslow = slow.Next\n\t\t\t}\n\t\t\treturn pre\n\t\t}\n\t}\n\treturn nil\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000146071","body":"# 【Day 12】146. LRU 缓存机制\n## 思路\n用一个map存储数据，用一个array记录顺序\n## golang代码\n```\ntype LRUCache struct {\n\tnum_map map[int]int\n\tnum_list []int\n\tcapacity int\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n\treturn LRUCache{\n\t\tnum_map: make(map[int]int),\n\t\tnum_list: make([]int, 0),\n\t\tcapacity: capacity,\n\t}\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n\tif _,ok:= this.num_map[key];ok{\n\t\tfor i,_ := range this.num_list{\n\t\t\tif this.num_list[i] == key&&i != len(this.num_list)-1{\n\t\t\t\tnum := this.num_list[i]\n\t\t\t\tthis.num_list = append(this.num_list[:i], this.num_list[i+1:]...)\n\t\t\t\tthis.num_list = append(this.num_list,num)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn this.num_map[key]\n\t}else {\n\t\treturn -1\n\t}\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\tif _,ok := this.num_map[key];ok{\n\t\tthis.num_map[key] = value\n\t\tfor i,_ := range this.num_list{\n\t\t\tif this.num_list[i] == key&&i != len(this.num_list)-1{\n\t\t\t\tnum := this.num_list[i]\n\t\t\t\tthis.num_list = append(this.num_list[:i], this.num_list[i+1:]...)\n\t\t\t\tthis.num_list = append(this.num_list,num)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}else {\n\t\tif len(this.num_list) == this.capacity{\n\t\t\tdelete_num := this.num_list[0]\n\t\t\tdelete(this.num_map,delete_num)\n\t\t\tthis.num_list = this.num_list[1:]\n\t\t\tthis.num_list = append(this.num_list,key)\n\t\t\tthis.num_map[key] = value\n\t\t}else {\n\t\t\tthis.num_map[key] = value\n\t\t\tthis.num_list = append(this.num_list,key)\n\t\t}\n\t}\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000606698","body":"# 【Day 13】104. 二叉树的最大深度\n## 思路\n没啥说的，递归\n## golang代码\n```\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\treturn getDepth(root)\n}\nfunc getDepth(node *TreeNode) int {\n\tif node.Left == nil && node.Right == nil {\n\t\treturn 1\n\t}\n\tvar leftDepth, rightDepth int\n\tif node.Left != nil {\n\t\tleftDepth = getDepth(node.Left)\n\t}\n\tif node.Right != nil{\n\t\trightDepth = getDepth(node.Right)\n\t}\n\tif leftDepth > rightDepth {\n\t\treturn leftDepth+1\n\t}else {\n\t\treturn rightDepth+1\n\t}\n}\n```\n## 复杂度\n时间:O(N)\n空间:O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000951642","body":"# 【Day 14】100. 相同的树\n## 思路\n同时遍历两棵树，情况不同返回false\n## golang代码\n```\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n\tif p==nil&&q==nil{\n\t\treturn true\n\t}\n\tif (p==nil&&q!=nil)||(p!=nil&&q==nil)||p.Val != q.Val ||(p.Left == nil && q.Left !=nil)||(p.Left != nil && q.Left ==nil)||(p.Right == nil && q.Right !=nil)||(p.Right != nil && q.Right ==nil){\n\t\treturn false\n\t}\n\tleft:=true\n\tright:=true\n\tif p.Left != nil{\n\t\tleft = isSameTree(p.Left,q.Left)\n\t}\n\tif p.Right != nil{\n\t\tright = isSameTree(p.Right,q.Right)\n\t}\n\tif left && right{\n\t\treturn true\n\t}else {\n\t\treturn false\n\t}\n}\n```\n## 复杂度\n时间：O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001094280","body":"# 【Day 15】129. 求根到叶子节点数字之和\n## 思路\n先序遍历的应用，用一个外部变量保存和，每层*10+node.val向下传递，叶子节点加和。\n## golang代码\n```\nfunc sumNumbers(root *TreeNode) int {\n\tvar ans = 0\n\tif root==nil{\n\t\treturn 0\n\t}\n\tpreorderTraversal(root, 0,&ans)\n\treturn ans\n}\nfunc preorderTraversal(node *TreeNode,num int, ans *int) {\n\tif node.Left == nil && node.Right == nil{\n\t\t*ans += num*10+node.Val\n\t}\n\tif node.Left!=nil{\n\t\tpreorderTraversal(node.Left, num*10+node.Val, ans)\n\t}\n\tif node.Right!=nil{\n\t\tpreorderTraversal(node.Right, num*10+node.Val, ans)\n\t}\n}\n```\n## 复杂度\n时间：O(n)\n空间:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaywx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wu-zonglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"socrates2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shinnost":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"v-enzo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991913378","body":"Codes\n-\n```javascript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992480645","body":"Codes\n-\n```javascript\nvar shortestToChar = function(s, c) {\n    let arrs=s.split(c)\n    let res=[]\n    for(let i=0; i<arrs.length; i++) {\n        let len=arrs[i].length\n        for(let j=0; j<arrs[i].length; j++) {\n            if(i==0){\n                res.push(arrs[i].length-j)\n            }else{\n                if(i+1<arrs.length){\n                    res.push((1+j>len-j)?(len-j):(1+j))\n                }else{\n                    res.push(j+1)\n                }\n            }\n        }\n        if(i+1<arrs.length){\n            res.push(0)\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993556331","body":"Codes\n-\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.array = [];\n    this.size = maxSize;\n};\n\nCustomStack.prototype.push = function(x) {\n    if(this.array.length < this.size){\n        this.array.push(x);\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.array.length == 0){\n        return -1;\n    }\n    return this.array.splice(this.array.length-1,1);\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < k; i++){\n        if(this.array[i]!=undefined){\n            this.array[i] =  this.array[i] + val;\n        }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994892607","body":"Codes\n-\n```javascript\nvar decodeString = function (s) {\n  let [stack, num, str] = [[], '', ''];\n    if (!isNaN(s[i])) {\n      num += s[i];\n      if (isNaN(s[i + 1])) {\n        stack.push(Number(num));\n        num = '';\n      }\n    } else if (s[i] === ']') {\n      str = '';\n      while (stack[stack.length - 1] !== '[') {\n        str = stack.pop() + str;\n      }\n      stack.pop();\n      stack.push(str.repeat(stack.pop()));\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996779061","body":"Codes\n-\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let stack = [arr[0]];\n    \n    for (let i=1; i< arr.length; i++){\n         if(arr[i] >= stack[stack.length-1]){stack.push(arr[i]);}\n         else {\n            const cur = stack[stack.length-1];\n            while(stack.length > 0 && arr[i] < stack[stack.length-1]){\n                stack.pop();\n             }\n            stack.push(cur);\n         }\n        \n    }\n    return stack.length\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998825382","body":"Codes\n-\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    if (headA == null || headB == null) {\n        return null;\n    }\n    \n    let set = new Set();\n\n    while (headA) {\n        set.add(headA);\n        headA = headA.next;\n    }\n\n    while(headB) {\n        if (set.has(headB)) {\n            return headB;\n        }\n        headB = headB.next;\n    }\n\n    return null;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000350374","body":"Codes\n-\n```javascript\n\nvar LRUCache = function(capacity) {\n    this.cache = new Map();\n    this.capacity = capacity; \n};\n\nLRUCache.prototype.get = function(key) {\n    if (this.cache.has(key)) {\n        const value = this.cache.get(key);\n        this.cache.delete(key);\n        this.cache.set(key, value);\n        return value;\n    }\n    return -1;\n};\n\nLRUCache.prototype.put = function(key, value) {\n    if (this.cache.has(key)) {\n        this.cache.delete(key);\n        this.cache.set(key, value);\n    } else {\n        if (this.cache.size >= this.capacity) {\n            this.cache.delete(this.cache.keys().next().value);\n            this.cache.set(key, value);\n        } else {\n            this.cache.set(key, value);\n        }\n    }\n};\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000834930","body":"Codes\n-\n```javascript\nvar maxDepth = function(root) {\n    let res = 0;\n    const dfs = (n, r) => {\n        if (!n) { return; }\n        if (!n.left && !n.right) {\n            res = Math.max(res, r);\n        }\n        dfs(n.left, r + 1)\n        dfs(n.right, r + 1)\n    }\n    dfs(root, 1)\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrhero-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hondrytravis":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992054401","body":"### 思路\n\n遍历每一个字符，对当前字符设左右双指针，返回较近c和当前字符距离。\n\n### 代码\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n    const result = []\n    \n    //  先找到前两个出现的位置\n    for (let i = 0, l = S.indexOf(C), r = S.indexOf(C, l + 1); i < S.length; i++) {\n        // 计算与左指针的距离\n        result[i] = Math.abs(l - i)\n        if (r === -1) continue\n\n        // 如果右指针存在,取较小的距离\n        result[i] = Math.min(result[i], r - i)\n\n        // 走到右指针则左右指针往下一个\n        if (i != r ) continue\n\n        result[i] = 0\n        l = r\n        r = S.indexOf(C, r + 1)\n    }\n    return result\n};\n```\n\n### 复杂度分析\n\n时间复杂度 O(n)\n\n空间复杂度 O(1)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996400894","body":"### 思路\n\n贪心\n\n### 代码\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  const stack = []\n  const peek = array => array.length >= 1 ? array[array.length - 1] : 0\n\n  for (const n of arr) {\n    const max = peek(stack)\n\n    if (stack.length && n < max) {\n      // 循环出栈 \n      while (stack.length && n < peek(stack)) stack.pop()\n\n      // 更新 max\n      stack.push(max)      \n    } else stack.push(n)\n  }\n  // 返回高度\n  return stack.length\n};\n```\n\n### 复杂度分析\n\n时间复杂度 O(n)\n\n空间复杂度 O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999374061","body":"### 思路\n\n创建一个set 集合，重复的一定会再次出现在 set 中\n\n### 代码\n\n```js\nvar detectCycle = function (head) {\n    const visited = new Set()\n    let cur = head\n    while (cur) {\n        // 访问过，直接返回\n        if (visited.has(cur)) return cur\n\n        visited.add(cur)\n        cur = cur.next\n    }\n    return null\n}\n```\n\n### 复杂度分析\n\n时间复杂度 O(n)\n\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awenbocc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vincentlw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lyf":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922848","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        carry = 0\n        nums = num\n        for i in range(len(num)-1,-1,-1):\n            tmp = (nums[i] + k % 10 + carry) % 10\n            carry = (nums[i] + k % 10 + carry) // 10\n            nums[i] = tmp\n            k = k // 10  \n\n        s = k + carry\n        b = []\n        while s:\n             b = [s % 10] + b\n             s = s // 10\n        return b + nums\n\n        # o n + max(0 , k-n)2  o max(1, k-n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992619471","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n        \r\n        \r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993667016","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994861397","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n        # on on","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995914928","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return \r\n        if self.s2:\r\n            return self.s2.pop()\r\n        else:\r\n            for _ in range(len(self.s1)):\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n\r\n        self.s2.append(ans)\r\n\r\n        return ans\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.s1 and not self.s2:\r\n            return True\r\n        return False\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996821710","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        A = arr\r\n        stack = []\r\n        for a in A:\r\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if stack and stack[-1] > a:\r\n                # 我们需要将融合后的区块的最大值重新放回栈\r\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                cur = stack[-1]\r\n                # 维持栈的单调递增\r\n                while stack and stack[-1] > a: stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        # 栈存的是块信息，因此栈的大小就是块的数量\r\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997218953","body":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 0 or not head or not head.next:\r\n            return head \r\n\r\n        a = head \r\n        b = head\r\n\r\n        c = 0\r\n        while b.next:\r\n            b = b.next\r\n            c += 1\r\n        k = k % (c + 1)\r\n\r\n        if k == 0:\r\n            return head \r\n\r\n        b.next = head\r\n        for i in range(c - k):\r\n            a = a.next\r\n\r\n        p = a.next\r\n        a.next = None\r\n\r\n        return p\r\n# on o1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997415745","body":"ListNode* swapPairs(ListNode* head) {\r\n    if (head == nullptr || head->next == nullptr) return head;\r\n\r\n    ListNode* first = head;\r\n    ListNode* second = first->next;\r\n\r\n    ListNode* head_of_next_group = swapPairs(second->next);\r\n\r\n    first->next = head_of_next_group;\r\n    second->next = first;\r\n\r\n    return second;\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997672114","body":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n\r\n# nlogn      log n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998888817","body":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n\r\n        while a!=b:\r\n            if a:\r\n                a = a.next\r\n            else:\r\n                a = headB\r\n            if b:\r\n                b = b.next\r\n            else:\r\n                b = headA\r\n\r\n        return a","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998932026","body":"# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head:\r\n            return head \r\n\r\n        a= head \r\n        b= head\r\n        while b and b.next:\r\n            b = b.next.next \r\n            a = a.next\r\n\r\n            if a == b:\r\n                if not b:\r\n                    return None\r\n                k = head \r\n\r\n                while k != b:\r\n                    k=k.next\r\n                    b=b.next\r\n                return b\r\n        return None\r\n \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000379503","body":"class LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        #self.space=[]\r\n        #self.a=capacity\r\n        self.capacity = capacity\r\n        self.dict={}\r\n        self.time=0\r\n\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        self.time+=1\r\n        if key in self.dict:\r\n            self.dict[key][1]=self.time\r\n            return self.dict[key][0]\r\n        return -1\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.time+=1\r\n        if len(self.dict)==self.capacity:\r\n            if key not in self.dict:\r\n                mintime=self.time\r\n                for i,t in self.dict.items():\r\n                    if t[1]<mintime:\r\n                        mintime=t[1]\r\n                        k=i\r\n                self.dict.pop(k)\r\n        self.dict[key]=[value]\r\n        self.dict[key].append(self.time)\r\n            \r\n\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000875548","body":"# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n\r\n        def height(root):\r\n            if not root:\r\n                return 0\r\n            return 1+max(height(root.left), height(root.right))\r\n        \r\n        return height(root)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000877119","body":"# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p and q:\r\n            if p.val != q.val:\r\n                return False\r\n            else:\r\n                return self.isSameTree(p.left,q.left) and self.isSameTree(q.right,p.right)\r\n        if not p and not q:\r\n            return True\r\n        else:\r\n            return False\r\n        \r\n        \r\n\r\n        ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gjts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aruseito":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"harleyszhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"badcoderchou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"auto-sk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"breezepython":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jianxinyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"anhtom2000":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhi22":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991886091","body":"```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lk = []\n        addOne = 0\n        while k:\n            k, m = divmod(k, 10)\n            lk.append(m)\n        ln = len(num); llk = len(lk)\n        res = [0 for _ in range(max(ln, llk)+1)]\n        num.reverse()\n        idx = 0\n        while idx < ln and idx < llk:\n            sum = num[idx] + lk[idx] + addOne\n            res[idx] = sum % 10\n            addOne = 0\n            if sum >= 10: addOne = 1\n            idx += 1\n        remain = num if ln > llk else lk\n        while idx < len(remain) or addOne:\n            if idx < len(remain): res[idx] += remain[idx]\n            res[idx] += addOne\n            addOne = 0\n            idx += 1\n            if res[idx] >= 10:\n                res[idx] %= 10\n                addOne = 1\n        if res[-1] == 0: res.pop()\n        res.reverse()\n        return res\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997866015","body":"```python3\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def findMid(start, end):\n            fast = slow = start\n            while fast != end and fast.next != end :\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(start, end):\n            if start == end:\n                return None\n\n            mid = findMid(start, end)\n            root = TreeNode(mid.val)\n            root.left = buildTree(start, mid)\n            root.right = buildTree(mid.next, end)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenjingjing85":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994926710","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        enTmp = ''\n        numTmp = ''\n        times = 0\n        stack = []\n        for ch in s:\n            if ch.isnumeric():\n                numTmp += ch\n            elif ch.isalpha():\n                enTmp += ch\n            elif ch =='[':\n                if numTmp != '':\n                    stack.append(int(numTmp))\n                if enTmp != '':\n                    stack.append(enTmp) \n                enTmp = ''\n                numTmp = ''\n            elif ch == ']':\n                en = stack.pop()\n                num = stack.pop()\n                en_whole = ''\n                for i in range(num):\n                    en_whole += en\n                stack.append(en)\n        return stack.pop()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995946914","body":"``` python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n\n    def pop(self) -> int:\n        return self.stack1.pop()\n\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n\n    def empty(self) -> bool:\n        return len(self.stack1) == 0\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996834329","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> mins = new Stack();\n        Stack<Integer> maxs = new Stack();\n        mins.push(arr[0]);\n        maxs.push(arr[0]);\n        int count = 1;\n        for(int i = 1; i< arr.length; i ++){        \t\n            int preMax = maxs.peek();\n            int preMin = mins.peek();\n            if(arr[i] < preMin){\n                mins.pop();\n                mins.push(i);\n            }else if(arr[i] >= preMax){\n                maxs.push(arr[i]);\n                mins.push(arr[i]);\n            }\n        }\n        while (!maxs.isEmpty()){\n            int min = mins.pop();\n            int max = maxs.pop();\n            if(maxs.isEmpty()){\n            \tbreak;\n            }\n            int preMax = maxs.peek();\n            int preMin = mins.peek();\n            if(min>= preMax){\n                count++;\n            }else if(min < preMin){\n                mins.pop();\n                mins.push(min);\n            } \n        }\n\n        return count;\n\n    }\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222060","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return null;\n        }\n        int length = 1;\n        ListNode last = head;\n        while(last.next != null){\n            last = last.next;\n            length++;\n        }\n        int count = length - k % length;\n        if(count == length){\n            return head;\n        }\n        \n        ListNode newHead = head.next;\n        ListNode newLast = head;\n        while(count > 1){\n            newLast = newLast.next;\n            newHead = newHead.next;\n            count--;\n        }\n        newLast.next = null;\n        last.next = head;\n        return newHead;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414040","body":"python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998017822","body":"``` python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def buildSubTree(head, tail):\n            if head == tail:\n                return None\n            slow = head\n            fast = head\n            while fast != tail and fast.next != tail:\n                slow = slow.next\n                fast= fast.next.next\n            mid = TreeNode(slow.val)\n            mid.left = buildSubTree(head, slow) \n            mid.right = buildSubTree(slow.next, tail)\n            return mid            \n        return buildSubTree(head, None)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999682426","body":"``` java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null){\n            if(fast.next != null){\n                fast = fast.next.next;\n                slow = slow.next;\n            }else{\n                return null;//fast.next==null说明没有环\n            }\n            if(fast == slow){\n                fast = head;\n                while(fast != slow){\n                    fast=fast.next;\n                    slow=slow.next;\n                };\n                return fast;\n            }\n        }\n\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000371492","body":"``` pythonclass ListNode:\n    def __init__(self, key=0, val=0, pre = None, next=None):\n        self.key = key\n        self.val = val\n        self.pre = pre\n        self.next = next\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.size = 0\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.pre = self.head\n        self.nodes = dict()\n\n    def get(self, key: int) -> int:\n        if key in self.nodes:\n            node = self.nodes[key]\n            self.removeNode(node)\n            self.addNodeToHead(node)\n            return node.val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.nodes:\n            node = self.nodes[key]\n            node.val = value\n            self.removeNode(node)\n            self.addNodeToHead(node)\n            return\n        if self.size >= self.capacity:\n            self.nodes.pop(self.tail.pre.key)\n            self.removeNode(self.tail.pre)\n            self.size -= 1\n        node = ListNode(key, value)\n        self.addNodeToHead(node)\n        self.nodes[key] = node\n        self.size += 1  \n\n    def removeNode(self, node):\n        node.pre.next = node.next\n        node.next.pre = node.pre\n\n    def addNodeToHead(self, node):\n        node.next = self.head.next\n        self.head.next.pre = node\n        self.head.next = node\n        node.pre = self.head    \n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000868902","body":"``` python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        return max(self.maxDepth(root.left), self.maxDepth(root.right))+1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001020581","body":"``` python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p and q:\n            return False\n        if not q and p:\n            return False\n        if p.val != q.val:\n            return False\n        if self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):\n            return True\n        return False\n        \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forlittlebeauty":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991717494","body":"## 思路\n\n***\n\n1. sum the value of the num list\n2. add k\n3. return the list form of the final value\n\n***\n\n## 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # numSum = 0\n        # for n in num:\n        #     numSum = numSum*10+n\n        # numSum += k\n        # return list(str(numSum))\n        return (list(str(int(\"\".join(map(str, num))) + k)))\n```\n\n\n\n***\n\n时间复杂度: O(n) \n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991975436","body":"## 思路\n\n***\n\n1. scan the list from left to right, when find c set the index = the position of c, so that our result array can record the distance between a character and the c show before that character.\n2. scan the list from right to left, change index whenever encounter a c. make record[i] = min(abs(i-index),record[i])\n\n***\n\n## 代码\n\n``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = []\n        index = len(s)-1\n        for i in range(len(s)):\n            if s[i]==c:\n                index = i\n            result.append(abs(index-i))\n        \n        index = 0\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                index = i\n            result[i] = min(result[i],abs(index-i))\n        return result\n```\n\n\n\n***\n\n时间复杂度: O(n) \n\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997449495","body":"## 思路\n\n***\n\n1. find the mid node, make it the tree root\n1. Make the left of the mid node to be the left child of the tree\n1. do the same to the right\n1. Do it recursively\n\n***\n\n## 代码\n\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        \n        def findMid(head):\n            slow = fast = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next\n                if fast.next:\n                    fast = fast.next\n            prev.next = None\n            return slow\n        \n        mid = findMid(head)\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        return root\n                \n\n```\n\n\n\n***\n\n时间复杂度: O(nlogn) \n\n空间复杂度: O(logn)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000382024","body":"## 思路\n\n***\n\ndictionary+doubleLinkedList\n\n***\n\n## 代码\n\n``` python\nclass Node:\n    \n    def __init__(self,key,value):\n        self.key = key\n        self.value = value\n        self.prev = self.next = None\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = dict()\n        self.left = Node(0,0)\n        self.right = Node(0,0)\n        self.left.next = self.right\n        self.right.prev = self.left\n    \n    def remove(self,node):\n        prev,nxt = node.prev,node.next\n        prev.next = nxt\n        nxt.prev = prev\n    \n    def insert(self,node):\n        prev = self.right.prev\n        nxt = self.right\n        node.next = nxt\n        node.prev = prev\n        prev.next = node\n        nxt.prev = node\n        \n        \n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.remove(node)\n            self.insert(node)\n            return node.value\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            self.remove(node)\n            node.value = value\n            self.insert(node)\n        else:\n            if self.capacity == 0:\n                lru = self.left.next\n                self.remove(lru)\n                del self.cache[lru.key]\n                self.capacity += 1\n            node = Node(key,value)\n            self.cache[key] = node\n            self.capacity -= 1\n            self.insert(node)\n        \n            \n        \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n\n\n***\n\n时间复杂度: O(1) \n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000869830","body":"## 思路\n\n***\n\ndfs\n\n***\n\n## 代码\n\n``` python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n\n\n\n***\n\n时间复杂度: O(1) \n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000977632","body":"## 思路\n\n***\n\ndfs\n\n***\n\n## 代码\n\n``` python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if (not p and q) or (p and not q):\n            return False\n        if p.val!=q.val:\n            return False\n        \n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n        \n```\n\n\n\n***\n\n时间复杂度: O(n) \n\n空间复杂度: O(logn)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991874521","body":"## 思路\n把num先变成int 然后sum_int = k+num_int 再把sum_int变成sum_array\n\n## 代码\n``` python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ## step0: corner case\n        if k == 0:\n            return num\n        ## step1: change the array to number\n        n = len(num)\n        num_int = 0\n        for i in range(n):\n            num_int += num[i]*10**(n-1-i)\n        ## step2: compute the sum\n        sum_int = num_int + k\n        sum_array = []\n        ## step3: change the sum to array\n        while sum_int != 0:\n            quotient = sum_int//10\n            remainder = sum_int%10\n            ## update sum array and int\n            sum_array.insert(0,remainder)\n            sum_int = quotient\n        \n        return sum_array\n```\n\n## 复杂度分析\n时间 O(n^2)\n\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992302693","body":"## 思路\n1. 利用c在s的位置，初始化res\n2. 先计算左侧最短距离，存入res\n3. 再计算右侧最短距离，与之前结果比较，并存入res\n\n## 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        ## step1: setup result by the postion of c\n        n = len(s)\n        result = []\n        for i in range(n):\n            if s[i]==c:\n                result.append(0)\n            else:\n                result.append(n)\n        #step2: compute the min distance from left \n        for i in range(1,n):\n            result[i] = min(result[i], result[i-1]+1)\n        #step3: compute the min distance from right and compare with previous result\n        for i in range(-2,-(n+1),-1):\n            result[i] = min(result[i],result[i+1]+1)\n        \n        return result\n    ```\n\n## 复杂度分析\n空间: O(n)\n\n时间: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993570732","body":"## 思路\n非常naive的想法， 用array来实现stack。 优化后的算法可以参考官方题解\n\n## 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.curSize = 0\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.curSize < self.maxSize:\n            self.stack.append(x)\n            self.curSize += 1\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n        if self.stack:\n            self.curSize -= 1\n            return self.stack.pop()\n        else:\n            return -1\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k,self.curSize)):\n            self.stack[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\n时间复杂度：\npop/push: O(1)\nincrement: O(min(k,curSize))\n\n空间复杂度： O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993796863","body":"## 思路\n用stack 直接解决\n遇到 ']' 清空栈 考虑到数字不一定是个位数 我们先用str来记录 count 然后记得pop掉 '['\n\n## 代码\n```pyhton\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for char in s:\n            if char == ']':\n                ## clear the stack and reset everything\n                string = ''\n                count = ''\n                while stack and stack[-1]!='[':\n                    string = stack.pop() + string\n                stack.pop() # pop the '['\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                stack.append(string*int(count))\n            else:\n                stack.append(char)\n        return ''.join(stack)\n```\n\n## 复杂度分析\n时间 O(n)\n\n空间 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995335217","body":"## 思路\n两个stack stack1装插入 stack2等到pop的时候 辅助stack1 清空\n\n## 代码\n``` pyhton\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            self.stack2 = self.stack1[::-1]\n            self.stack1 = []\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        elif self.stack1:\n            return self.stack1[0]\n\n    def empty(self) -> bool:\n        if (not self.stack1) and (not self.stack2):\n            return True\n        else:\n            return False\n\n```\n\n## 复杂度分析\n时间： O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996639250","body":"## 思路\n利用单调栈\n\n## 代码\n``` python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = [arr[0]]\n        for num in arr[1:]:\n            if stack[-1]<=num:\n                stack.append(num)\n            else:\n                curr = stack[-1] #记录栈顶\n                stack.pop()\n                while stack and stack[-1]>num:\n                    stack.pop()\n                stack.append(curr) #复位\n\n        return len(stack)\n```\n\n## 复杂度分析\n空间 O(n)\n\n时间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997182183","body":"## 思路\n遍历数组 确定长度 然后找到n-k的链表\n\n## 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if k == 0 or not head or not head.next:\n            return head\n    \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        time = n - k % n \n        if time == n:\n            return head\n        \n\n        \n        cur.next = head\n        while time :\n            cur = cur.next\n            time -= 1\n        \n        res = cur.next\n        cur.next = None\n        return res\n```\n\n## 复杂度分析\n时间：O(n)\n\n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997504404","body":"## 思路\n没思路 参考题解 快慢指针找重点 构造子树\n\n## 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n## 复杂度\n时间： O(nlogn)\n\n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998873201","body":"## 思路\n参考官方题解 使用双指针。\n使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n\n当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n\n当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n\n若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\n## 代码\n``` python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n## 复杂度\n时间复杂度: O(N)\n\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999585826","body":"## 思路\n快慢指针 确定有没有环\n再根据题解 确定环开始的位置\n\n## 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n\n## 复杂度分析\n时间: O(N)\n\n空间: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000419428","body":"## 思路\nOrdered dict\n\n## 代码\n``` python\nfrom collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self:\n            return - 1\n        \n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: void\n        \"\"\"\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n## 复杂度分析\n\n时间：O(1)\n\n空间：O(dict)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000985704","body":"## 思路\nDFS 除了几个 corner case之外 直接递归比较\n\n## 代码\n``` python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if p and not q:\n            return False\n        if not p and q:\n            return False\n        if p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度分析\n时间复杂度：O(n) n 为节点个数\n\n空间复杂度：O(h) h 为树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinnxuu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991851926","body":"# Idea\n\n---\n\n- Add numbers from right to left digit by digit. Add k's units' digit to first sum, tens' digit to second sum, hundreds' digit to third sum, and so on.\n- Beware of  the case that k > num.  (Whether k > 0 after the num loop)\n- And remember to reverse the result list.\n\n# Code (Java)\n\n---\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        \n        while (k > 0){\n            res.add(k % 10);\n            k /= 10;\n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# Complexity\n\n---\n\n- Time Complexity: O(N)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991973335","body":"## Notes\r\n\r\nTraverse the string twice, one from left to right, and one from right to left.\r\n\r\n## Code (Java)\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n]; \r\n        //left to right\r\n        int right = -10001;\r\n        for (int i = 0; i < n; i++){\r\n            res[i] = i - right;\r\n            if (s.charAt(i) == c){\r\n                res[i] = 0;\r\n                right = i;\r\n            }\r\n        }\r\n        //right to left\r\n        int left = 10001;\r\n        for (int i = n - 1; i >= 0; i--){\r\n            if (res[i] > left - i){\r\n                res[i] = left - i;\r\n            }\r\n            if (s.charAt(i) == c){\r\n                res[i] = 0;\r\n                left = i;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Complexity\r\n\r\n- Time: O(N), N is the length of string s.\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993289238","body":"\r\n```java\r\n//1.原始解法\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top != -1) {\r\n            return stack[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n//2.增加一个数组专门记录increment，优化increment操作的时间复杂度至O(1)\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top;\r\n    int[] add;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1){\r\n            return -1;\r\n        }\r\n        int res = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        } \r\n        add[top] = 0;\r\n        top--;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit > -1){\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n1. 解法1\r\n- 时间复杂度：除了increment是O(k), 其他全部是 O(1)\r\n- 空间复杂度：O(maxSize)\r\n2. 解法2\r\n- 时间复杂度：全部是 O(1)\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994034613","body":"**思路**\n\n首先将除了右括号所有的字符全部压入栈，遇右括号之后开始出栈：先分别取得字母串和倍数，再按倍数重新把字母串压入栈中。最后打印出已经整理好的栈中全部内容即可。\n\n**代码**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c);\n            } else {\n                //Push letters to stack\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek() >= 'a' && stack.peek() <= 'z' ){\n                    sb.insert(0, stack.pop()); \n                }\n                String str = sb.toString();\n                stack.pop(); //delete '['\n                //Push numbers to stack\n                StringBuilder num = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9' ){\n                    num.insert(0, stack.pop());\n                }\n                int count = Integer.valueOf(num.toString());\n                while (count > 0) {\n                    for (char ch : str.toCharArray()) {\n                        stack.push(ch);\n                    }\n                    count--;\n                }         \n            }\n        }\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为解码后的 s 的长度\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995427677","body":"### **思路**\n\n用两个栈（pushStack 和 popStack）来模拟队列，每次队列进行push操作时先检查负责popStack中是否有元素，有则全部出栈到pushStack，再进行push。pop和peek操作则是先检查pushStack中是否有元素，有则全部出栈到popStack，再进行pop或peek。\n\n### **代码**\n\n```java\nclass MyQueue {\n    Stack<Integer> pushStack;\n    Stack<Integer> popStack;\n\n    public MyQueue() {\n         pushStack = new Stack<>();\n         popStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间复杂度：push，pop，peek这三个操作为O(N)，N为栈的长度。其他操作O(1)。\n- 空间复杂度：O(N)，使用了两个栈。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996327729","body":"### **思路**\n\n栈内保存每个块的最大值。对于nums中的每个i，如果不小于当前栈顶则入栈。否则先保存现在的栈顶，再将之前比该元素大的栈内元素全部出栈（也就是将这些元素以及i全部融合入以这个栈顶值为最大值的块）。\n\n### **代码**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] nums) {\n        Stack<Integer> stack = new Stack<Integer>();\n        for (int i : nums){\n            if (!stack.empty() && i < stack.peek()){\n                int cur = stack.pop();\n                while (!stack.empty() && i < stack.peek()){\n                    stack.pop();\n                }\n                stack.push(cur);\n\n            } else {\n                stack.push(i);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997153341","body":"### 思路\r\n把链表首尾相连，再从现在的尾结点开始移动length - k 个位置到新的尾结点， 再断开环。\r\n### 代码\r\n``` java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next ==null || k == 0){\r\n            return head;\r\n        }\r\n        ListNode ptr = head;\r\n        int count = 1;\r\n        while (ptr.next != null) {\r\n            ptr = ptr.next;\r\n            count++;\r\n        }\r\n        ptr.next = head;\r\n        int add = count - (k % count);\r\n        if (add == 0) {\r\n            return head;\r\n        }\r\n        for (int i = 0; i < add ; i++) {\r\n            ptr = ptr.next;\r\n        }\r\n        ListNode res = ptr.next;\r\n        ptr.next = null;\r\n        return res;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997305840","body":"### Notes\n注意改变节点时的次序\n### Code (Java)\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while(cur.next != null && cur.next.next != null) {\n            ListNode node1 = cur.next;\n            ListNode node2 = cur.next.next;\n            cur.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            cur = node1;\n        }\n        return dummy.next;\n    }\n}\n```\n### Complexity\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997590961","body":"### **思路**\n\n通过快慢指针找出链表的中位数，作为当前树的根节点。左右继续递归建立左右子树。\n\n### **代码**\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        } \n        if (head.next == null) {\n            TreeNode res = new TreeNode(head.val);\n            return  res;\n        }\n        return dfs(head, null);\n    }\n    public TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        } \n        ListNode fast = head, slow = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode median = new TreeNode(slow.val);\n        median.left = dfs(head, slow);\n        median.right =dfs(slow.next, tail);\n        return median;\n\n    }\n}\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998312806","body":"### **思路**\n\n指针ptrA和指针ptrB分别遍历两条AB链表，设a为A链表的单独部分，b为B链表的单独部分，c为共有部分。因为 a+c+b = b+c+a，则若到链表尾则重定向到另一条链表的表头，若有相交点则两指针必然相遇。\n\n### **代码**\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null){\n            return null;\n        }\n        ListNode ptrA = headA;\n        ListNode ptrB = headB;\n        while (ptrA != ptrB){\n            if (ptrA == null){\n                ptrA = headB;\n            } else {\n                ptrA = ptrA.next;\n            }\n            if (ptrB == null){\n                ptrB = headA;\n            } else {\n                ptrB = ptrB.next;\n            }\n            if (ptrA == null && ptrB == null){\n                return null;\n            }\n        }\n        return ptrA;\n    }\n}\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(N)，N为总节点个数。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999194019","body":"# Code（Java）\n\n---\n\n```java\n//1.HashSet\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        Set<ListNode> visited = new HashSet<>();\n        ListNode pos = head;\n        while (pos != null) {\n            if (visited.contains(pos)){\n                return pos;\n            } else {\n                visited.add(pos);\n                pos = pos.next;\n            }\n        }\n        return null;\n    }\n}\n```\n\n```java\n// 2. Two Pointers\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        \n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                fast = head;\n                while (fast != slow) {\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return fast;\n            }\n        }\n        return null;\n    }\n}\n```\n\n# Complexity\n\n---\n\nSolution 1：\n\n- Time Complexity: O(N)\n- Space Complexity: O(N)\n\nSolution 2：\n\n- Time Complexity: O(N)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000162063","body":"### **思路**\n用哈希表和双向链表模拟LRU，来实现O(1)时间的get和put\n\n- 随机访问一个key的时间复杂度为O(1): 所以需用到哈希表, 用来创建mapping。\n- 删除该缓存中最后一个entry的复杂度为O(1): 双向链表\n- 插入/移动一个entry到cache的第一个位置的时间复杂度为O(1): 双向链表\n\n### **代码**\n\n```java\nclass LRUCache {\n    class DLinkedListNode{\n        int key, value;\n        DLinkedListNode prev,next;\n        DLinkedListNode(){};\n        DLinkedListNode(int _key, int _value){\n            key = _key;\n            value = _value;\n        }\n    }\n    private Map<Integer, DLinkedListNode> cache = new HashMap<Integer, DLinkedListNode>();\n    private int size, cap;\n    private DLinkedListNode head,tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        head = new DLinkedListNode();\n        tail = new DLinkedListNode();\n\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DLinkedListNode node = cache.get(key);\n        //如果不存在\n        if (node == null){\n            return -1;\n        }\n        //如果存在\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedListNode node = cache.get(key);\n        if (node == null) {//不存在则创造一个新节点，并加到链表头\n            DLinkedListNode newNode = new DLinkedListNode(key, value);\n            cache.put(key, newNode);//哈希表中也要添加该点\n            addToHead(newNode);\n            size++;\n            if (size > cap){//如果超出容量，则删除双向链表尾结点\n                DLinkedListNode tail = removeTail();\n                cache.remove(tail.key);//哈希表中也要删除尾结点\n                size--;\n            }\n        } else {\n            //如果该节点存在\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n    private void addToHead(DLinkedListNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n    private void removeNode(DLinkedListNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n     private void moveToHead(DLinkedListNode node){\n         removeNode(node);\n         addToHead(node);\n     }\n     private DLinkedListNode removeTail(){\n         DLinkedListNode res = tail.prev;\n         removeNode(res);\n         return res;\n     }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(cap)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000771258","body":"### **思路**\n\n递归，把当前树高度的问题，分解为右子树高度和左子树高度的子问题。\n\n### **代码**\n\n```java\n\n//DFS\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(N),N为节点数\n- 空间复杂度：O(h),h为树高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000984867","body":"### **思路**\n\n1. DFS\n    \n    递归，分解子问题，把当前两棵树是否相同的问题分解为：\n    \n    - 右子树是否相同\n    - 左子树是否相同\n    \n    递归出口: 当树高度为 1 时(到叶节点时)，判断递归出口\n    \n2. BFS\n    \n    借助队列进行层序遍历， 判断每层的结构是否相同。每次取队头元素的时候比较两棵树的队头元素是否一致。如果不一致，直接返回 false。如果访问完都没有发现不一致就返回 true。\n    \n    \n\n### **代码**\n\n```java\n//DFS\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null){\n            return true;\n        } else if (p == null || q == null){\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n//BFS\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(p);\n        queue.offer(q);\n        while (!queue.isEmpty()){\n            TreeNode first = queue.poll();\n            TreeNode second = queue.poll();\n            if (first == null && second == null) {\n                continue;\n            } else if (first == null || second == null) {\n                return false;\n            } else if (first.val != second.val) {\n                return false;\n            }\n            queue.offer(first.left);\n            queue.offer(second.left);\n            queue.offer(first.right);\n            queue.offer(second.right);\n        } \n        return true;\n    }\n}\n\n```\n\n### **复杂度分析**\n1. DFS\n    - 时间复杂度：O(min(m,n)), m和n分别为两棵树的节点数，min因为只需要将较少节点的树遍历完即可得到答案\n    - 空间复杂度：O(min(m,n))\n2. BFS\n    - 时间复杂度：O(N)，其中 N 为树的节点数。\n    - 空间复杂度：O(Q)，其中 Q 为队列的长度最大值，在这里不会超过相邻两层的节点数的最大值。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"missnanlan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991866075","body":"## 思路\n\n1、逐位相加法，逐位数字相加在一起，遇到相加等于 10 的时候要进位，把进位的 1 加入到下一位计算中\n\n2、将整个加数 k 加数加入数组表示数的最低位(简单点)\n\n## 关键点\n\n- 要考虑进位的情况， 比如 num=[3,6,9]，n=45\n- 要考虑 n>num 的长度 的情况，比如 num=[3,6]，n=789\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n### 解法 1 逐位相加法\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n\nvar addToArrayForm = function (n, k) {\n  var res = [];\n  for (var i = n.length - 1; i >= 0; --i) {\n    var sum = n[i] + (k % 10);\n    k = Math.floor(k / 10);\n    // 如果相加大于10，则进位，把进位的1加入到下一位计算中\n    if (sum >= 10) {\n      k++;\n      sum = sum % 10;\n    }\n    res.push(sum);\n  }\n  // 如果n>num的长度\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10);\n  }\n\n  return res.reverse();\n};\n```\n\n### 解法 2 将整个加数 k 加数加入数组表示数的最低位\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  const n = num.length;\n  for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n    if (i >= 0) {\n      k += num[i];\n    }\n    res.push(k % 10);\n  }\n  res.reverse();\n  return res;\n};\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992553025","body":"## 思路1\n\n- 找出 c 的下标的位置，放入到一个数组 tempArr 里面\n- 用 tempArr 与 i 相减得到绝对值，与 tempArr 下一个元素作比较，前一个元素比较大，则 tempArr 向后移动一个位置\n- 前一个元素小，则不需要动\n- 以上思路是参照别人的解法，感觉用两个循环不是很优雅，希望以后还是有自己的想法\n\n## 关键点\n\n- 如何求出两个下标之间的距离（两个下标相减的绝对值）\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (str, c) {\n  var answer = [];\n  var tempArr = [];\n  var k = 0;\n  // 找出 c的下标的位置，放入到一个数组tempArr里面\n  for (var i = 0; i < str.length; i++) {\n    var s = str.charAt(i);\n    if (s === c) tempArr.push(i);\n  }\n  //  用tempArr与i相减得到绝对值，与tempArr下一个元素作比较，前一个元素比较大，则tempArr向后移动一个位置\n  // 前一个元素小，则不需要动\n  for (var i = 0; i < str.length; i++) {\n    if (\n      k < tempArr.length - 1 &&\n      Math.abs(tempArr[k] - i) > Math.abs(tempArr[k + 1] - i)\n    )\n      k++;\n    answer.push(Math.abs(tempArr[k] - i));\n  }\n  return answer;\n};\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，这里有些疑问，不知道算不算O(2n)\n\n-----------\n\n## 思路2\n\n- 窗口，参照西法大佬的窗口解法\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n     \n   // 定义左边界,右边界\n    let l = s[0] === c ? 0 : Infinity, r = s.indexOf(c, 1);\n    const res = Array(s.length);\n\n    for (let i = 0; i < 1; i++) {\n        res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n        \n        // 如果滑动到边界，则继续向右滑动\n        if (i === r) {\n            l = r;\n            r = s.indexOf(c,l+1)\n        } \n    }\n\n    return res;\n\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993620721","body":"## 思路1\r\n\r\n``` javascript\r\n\r\nvar CustomStack = function (maxSize) {\r\n  this.arr = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.arr.length < this.maxSize) {\r\n    return this.arr.push(x);\r\n  }\r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function () {\r\n  if (this.arr.length > 0) {\r\n    return this.arr.pop();\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (var i = 0; i < k && i < this.arr.length; i++) {\r\n    this.arr[i] += val;\r\n  }\r\n};\r\n\r\n```\r\n\r\n时间复杂度：push 和 pop 操作的时间复杂度为 O(1)，而 increment 操作的时间复杂度为 O(k)\r\n\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994903453","body":"``` javascript\n参照西法大佬的思路，试着用js，发现测试用例没有完全过去\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  var repeatStr = \"\";\n  var repeatCount = 0;\n\n  var stack = [];\n\n  for (var i = 0; i < s.length; i++) {\n    // 出栈\n\n    if (s[i] === \"]\") {\n      repeatStr = \"\";\n      repeatCount = 0;\n\n      // 出栈是字母的话\n      while (stack[stack.length - 1] != \"[\") {\n        repeatStr = stack.pop() + repeatStr;\n      }\n\n      // pop 掉 [\n      stack.pop();\n\n      // 出栈是数字的话\n      while (stack[stack.length - 1] >= \"0\" && stack[stack.length - 1] <= \"9\") {\n        repeatCount = repeatCount*10 + Number(stack.pop());\n        stack.push(repeatStr.repeat(repeatCount));\n      }\n    } else {\n      // 入栈\n      stack.push(s[i]);\n    }\n  }\n  return stack.join(\"\");\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995932289","body":"## TODO\n用队列实现栈\n\n\n## 关键点\n\n-  借助一个辅助栈\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function () {\n  this.stack = [];\n  this.helperStack = [];\n};\n\n\n MyQueue.prototype.push = function (x) {\n    let cur = null;\n    while ((cur = this.stack.pop())) {\n      this.helperStack.push(cur);\n    }\n    this.helperStack.push(x);\n  \n    while ((cur = this.helperStack.pop())) {\n      this.stack.push(cur);\n    }\n};\n\nMyQueue.prototype.pop = function () {\n  return this.stack.pop();\n};\n\n\nMyQueue.prototype.peek = function () {\n  return this.stack[this.stack.length - 1];\n};\n\n\nMyQueue.prototype.empty = function () {\n  return this.stack.length === 0;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ ， n是栈的长度\n- 空间复杂度：$O(n)$，n是栈的长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996691566","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n  let stack = [];\n  for (var i = 0; i < arr.length; i++) {\n    let head;\n    // 合并\n    if (stack.length > 0 && stack[stack.length - 1] > arr[i]) {\n      head = stack.pop();\n      while (stack.length > 0 && stack[stack.length - 1] > arr[i]) {\n        stack.pop();\n      }\n      stack.push(head);\n    } else {\n      // 新的块\n      stack.push(arr[i]);\n    }\n  }\n  return stack.length;\n};\n\n\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997386607","body":"## 思路\n\n解法1 递归\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n    if (!head || !head.next) return;\n    const newHead = head.next; temp = A.next; A.next = temp; temp.next = A\n    head.next = newHead.next;\n    newHead.next = head;\n    return newHead;\n};\n\n\nconsole.log(\n    JSON.stringify(\n      swapPairs(\n        new ListNode(1, new ListNode(2))\n      )\n    )\n  );\n  \n\n```\n![image](https://user-images.githubusercontent.com/22790863/146675214-102971fa-0386-49c5-9325-01cf11f281bf.png)\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\n\n空间复杂度：O(n)，其中 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997993613","body":"## 思路\n\n- 双指针法\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nfunction ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction TreeNode(val, left, right) {\n  this.val = val === undefined ? 0 : val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\n// 利用快慢指针\nvar sortedListToBST = function (head) {\n  if (head == null) return null;\n  let slow = head;\n  let fast = head;\n  let preShow;\n\n  while (fast && fast.next) {\n    preShow = slow; // 保存当前slow\n    slow = slow.next; // slow走一步\n    fast = fast.next.next;\n  }\n\n  let root = new TreeNode(slow.val);\n\n  if (preShow != null) {\n    preShow.next = null;\n    root.left = sortedListToBST(head);\n  }\n\n  root.right = sortedListToBST(slow.next);\n\n  return root;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)\n\n\n## TODO\n\n- 分治\n- 分治 + 中序遍历优化","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998868344","body":"## 思路\n\n### 方法1 哈希集合\n\n- 有A、B两条链表，先创建一个哈希表，遍历A对象，存入这个海西表，\n- 然后遍历B，然后检查B是否在这个哈希表中，存在于哈希表的那个节点就是相交节点\n\n\n### 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nfunction ListNode(val, next) {\n  this.val = val === undefined ? 0 : val;\n  this.next = next === undefined ? null : next;\n}\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function (headA, headB) {\n  const visited = new Set();\n  let temp = headA;\n  while (temp) {\n    visited.add(temp);\n    temp = temp.next;\n  }\n  temp = headB;\n  while (temp) {\n    if (visited.has(temp)) return temp;\n    temp = temp.next;\n  }\n  return null;\n};\n\nlet C = new ListNode(8, new ListNode(4, new ListNode(5)));\n\nlet headA = new ListNode(2, C);\n\nlet headB = new ListNode(1, new ListNode(3, C));\n\nconsole.log(getIntersectionNode(headA, headB));\n\n```\n\n**复杂度分析**\n\n\n- 时间复杂度：$O(m+n)$， m是headA的长度，n是headB的长度 ，需要遍历两次，所以时间复杂度是O(m+n)\n- 空间复杂度：$O(m)$,  是headA的长度\n\n\n\n### 方法2 双指针\n\n- 使用a、b两个指针分别指向于链表A、B，两个指针以相同的速度向右移动\n- 如果a到达A链表的尾部的时候，使他重新指向链表B的头结点，\n- 如果b到达B链表的尾部的时候，使他重新指向链表A的头结点，\n- 两个指针相遇的时候，则相交的节点就是他们起始相交的节点，否则不存在相交节点\n\n### 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n``` javascript\n\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a != b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n```\n\n\n**复杂度分析**\n\n\n- 时间复杂度：$O(n)$， n应该是headA和headB长度最长的那个\n- 空间复杂度：$O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999630765","body":"\n## 思路\n\n### 方法1 哈希集合\n\n\n- 创建一个哈希表，然后遍历这个链表\n- 如果链表在这个哈希表出现，说明当前节点就是环的入口\n- 如果不存在的话，则无环\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\nvar detectCycle = function (head) {\n    const visited = new Set();\n    while (head) {\n        if (visited.has(head)) return head;\n        visited.add(head)\n        head = head.next\n    }\n    return null\n};\n\n```\n\n**复杂度分析**\n\n\n- 时间复杂度： O(n), n是链表的长度\n\n- 空间复杂度：O(n)，n是链表的长度，我们需要把链表的每个节点都保存在哈希表中\n\n### 方法2 双指针\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\nfunction ListNode(val, next) {\n    this.val = val === undefined ? 0 : val;\n    this.next = next === undefined ? null : next;\n}\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function (head) {\n    if (head == null || head.next == null) return null;\n    let slow = head,\n        fast = head;\n    do {\n        if (fast != null && fast.next != null) {\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        slow = slow.next;\n    } while (slow != fast)\n    \n    if (slow === null) return null;\n    // 走到这里的时候说明有两个指针第一次相遇\n    fast = head;\n    while (slow != fast) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n\nconst l1 = new ListNode(3);\nconst l2 = new ListNode(2);\nconst l3 = new ListNode(0);\nconst l4 = new ListNode(-4);\n\nl1.next = l2;\nl2.next = l3;\nl3.next = l4;\nl4.next = l2;\n\n```\n\n\n**复杂度分析**\n\n\n- 时间复杂度：$O(n)$,O(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)。\n\n- 空间复杂度：$O(1)$\n\n\n## TODO\n\nhttps://leetcode-cn.com/problems/linked-list-cycle/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000371575","body":"## 思路\n\n### 使用内置数据结构\n\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.capacity = capacity;\n  this.map = new Map();\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  const { map } = this;\n  if (this.map.has(key)) {\n    const target = map.get(key);\n    map.delete(key);    // 为啥要删除\n    map.set(key, target); // 为啥要再设置\n    return target;\n  }\n  return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  const { map, capacity } = this;\n  if (map.has(key)) map.delete(key);  // 为啥要删除，而不是直接set\n\n  map.set(key, value);\n\n  if (map.size > capacity) {\n    // 获得插入顺序的第一个 key\n    const firstKey = map.keys().next().value;\n    map.delete(firstKey);\n  }\n};\n```\n\n### 哈希表+双链表\n\n- 题目要求时间复杂度是O(1)。\n- get  如果关键字存在缓存的中，则返回关键字的值，否则返回-1\n- put 如果关键字已经存在，则变更其数据值；否则则插入，当缓存容量达到上限的时候，在写入之前删除最久未使用的的数据值\n\n如何删除最久未使用的的数据值\n为啥用双链表\n参照官方题解，没完全弄懂\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：对于 put 和 get 都是 O(1)。\n\n- 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储  capacity+1 个元素。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000869570","body":"\n## 前置知识\n\n\n- 树的深度\n\n   高度和深度是相反的，高度是从下往上数，深度是从上往下。\n   因此根节点的深度和叶子节点的高度是 0；\n\n\n## 思路\n\n### 思路1 dfs\n\n先计算出左子树和右子树的高度，然后取最大值，然后加1\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    if (root === null) {\n        return 0;\n    }\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n};\n\n\nlet tree = new TreeNode(\n    new TreeNode(9),\n    new TreeNode(20,new TreeNode(25),new TreeNode(7))\n\n    console.log(maxDepth(tree))\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(N)，其中 N 为节点数。\n\n- 空间复杂度：O(h)，其中 h 为树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001021338","body":"## 思路\n\n### 方法 1 递归\n- 分解子问题，判断左子树和右子树是否相同\n- 递归出口，当高度为1的时候，就是递归的出口\n\n\n## 代码 \n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n  if (!p || !q) {\n    return !p && !q;\n  }\n  return (\n    p.val === q.val &&\n    p.val === q.val &&\n    isSameTree(p.left, q.left) &&\n    isSameTree(p.right, q.right)\n  );\n};\n\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，n为树的节点数\n- 空间复杂度：$O(h)$, h 为树的高度\n\n\n## TODO\n层序遍历","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuanwenlai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sjingz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jlin-data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victoria011":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995340641","body":"思路\r\n\r\n使用两个 list, input 用来存输入, output 用来pop 元素(逆序输出) \r\n\r\n\r\n\r\n代码\r\n\r\n    class MyQueue:\r\n        def __init__(self):\r\n            self.input = []\r\n            self.output = []\r\n    \r\n        def push(self, x):\r\n            self.input.append(x)\r\n    \r\n        def pop(self):\r\n            self.peek()\r\n            return self.output.pop()\r\n    \r\n        def peek(self):\r\n            if not self.output:\r\n                while self.input:\r\n                    self.output.append(self.input.pop())\r\n            return self.output[-1]        \r\n    \r\n        def empty(self):\r\n            return not self.input and not self.output\r\n\r\n复杂度分析\r\n\r\nTime complexity: O(1)\r\n\r\nSpace complexity: O(1)\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999829415","body":"基本思路\n\n使用 hashmap + doubleLinkedList 。\n\n代码\n\n    class LRUCache:\n        def __init__(self, MSize):\n            self.size = MSize\n            self.cache = {}\n            self.next, self.before = {}, {}\n            self.head, self.tail = '#', '$'\n            self.connect(self.head, self.tail)\n    \n        def connect(self, a, b):\n            self.next[a], self.before[b] = b, a\n    \n        def delete(self, key):\n            self.connect(self.before[key], self.next[key])\n            del self.before[key], self.next[key], self.cache[key]\n    \n        def append(self, k, v):\n            self.cache[k] = v\n            self.connect(self.before[self.tail], k)\n            self.connect(k, self.tail)\n            if len(self.cache) > self.size:\n                self.delete(self.next[self.head])\n    \n        def get(self, key):\n            if key not in self.cache: return -1\n            val = self.cache[key]\n            self.delete(key)\n            self.append(key, val)\n            return val\n    \n        def put(self, key, value):\n            if key in self.cache: self.delete(key)\n            self.append(key, value)       \n\n复杂度分析\n\nTime complexity: O(1)\n\nSpace complexity: O(Capacity)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coreja":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991915086","body":"# 思路\n方法挺多的，可以用map以及reduce的方法把列表转字符串再转数字，最后再换成列表\n\n更合理的方法是运用列表模拟进位等操作，把k直接加到num的最后一位里，然后再进位，k自除10，num最后一位取余保留，直到k为0.\n\n# 代码\n```python\nclass Solution:\n    def addToArrayForm1(self, num: List[int], k: int) -> List[int]:\n        return list(map(int, str(int(\"\".join(map(str, num))) + k)))\n\n    def addToArrayForm2(self, num: List[int], k: int) -> List[int]:\n        return list(map(int, str(k + reduce(lambda x, y: 10 * x + y, num))))\n\n    def addToArrayForm3(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        carry = 0\n        res = []\n        while k or i >= 0:\n            left = k % 10\n            res_dig = num[i] + left + carry if i >= 0 else left + carry\n            if res_dig >= 10:\n                carry = 1\n                res_dig %= 10\n            else:\n                carry = 0\n            res.insert(0, res_dig)\n            i -= 1\n            k //= 10\n        if carry:\n            res.insert(0, 1)\n        return res\n\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n            if i < 0 and k:\n                num.insert(0, 0)\n                i = 0\n        return num\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992036434","body":"# 思路\n贪心法，从左到右+从右到左遍历，取最小值即可。\n\n简单描述就是，从第一个c开始向右遍历数组，下标c的结果取0，后面的结果就分别递增直到再次遇到c置0。同样的过程从最后一个c开始向左遍历，第二次遍历的时候和第一遍遍历的结果比较，取最小值。\n\n# 代码\n```python\nclass Solution:\n    # 贪心解法\n    def shortestToChar1(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [float('inf')] * n\n        cnt = float('inf')\n        for i in range(n):\n            if s[i] == c:\n                ans[i] = 0\n                cnt = 0\n            else:\n                cnt += 1\n                ans[i] = cnt\n        cnt = float('inf')\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                cnt = 0\n                continue\n            else:\n                cnt += 1\n                ans[i] = min(cnt, ans[i])\n        return ans\n    # 贪心法简单写法\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0 if ch == c else None for ch in s]\n\n        for i in range(1, n):\n            if ans[i] != 0 and ans[i - 1] is not None:\n                ans[i] = ans[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ans[i] is None or ans[i] != 0 and ans[i + 1] + 1 < ans[i]:\n                ans[i] = ans[i + 1] + 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992851358","body":"# 思路\nnaive思路非常好想，按照需求实现即可\n\n但是考虑到increment操作针对的是栈，栈在这里只会访问栈顶，所以可以考虑对increment使用lazy操作\n只在出栈的时候去进行之前的increment操作，以规避对栈内元素过多的操作\n\n具体就是每次increment并不直接增加到它要求的栈底的k个元素，而是用另一个数组lazy_inc保存起来，\n只在pop的时候去加上lazy_inc的top-1元素，并将这个increment加到数组中的前一个元素中(这样就把它继承下去了)\n\n# 代码\n```python\n# naive思路\nclass CustomStack1:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.cur = 0\n\n    def push(self, x: int) -> None:\n        if self.cur >= len(self.stack):\n            return\n        self.stack[self.cur] = x\n        self.cur += 1\n\n    def pop(self) -> int:\n        if self.cur <= 0:\n            return -1\n        self.cur -= 1\n        return self.stack[self.cur]\n\n    def increment(self, k: int, val: int) -> None:\n        k = self.cur if k > self.cur else k\n        for i in range(k):\n            self.stack[i] += val\n\n\n#  lazy_increment做法\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.top = 0\n        self.stack = [0] * maxSize\n        self.add = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.top >= len(self.stack):\n            return\n        self.stack[self.top] = x\n        self.top += 1\n        return\n\n    def pop(self) -> int:\n        if self.top > 0:\n            self.top -= 1\n            self.stack[self.top] += self.add[self.top]\n            if self.top > 0:\n                self.add[self.top - 1] += self.add[self.top]\n            self.add[self.top] = 0\n            return self.stack[self.top]\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(k, self.top)\n        if k > 0:\n            self.add[k - 1] += val\n```\n# 复杂度\nTC: push O(1), increment O(1), pop O(1)\nSC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994069825","body":"# 思路\n经典栈的应用，遍历字符串，如果是数字就暂存在一个tmp_num字符串里，如果是字符那就直接入栈到stack。碰到 \"[\"就说明前面的数字读完了，把tmp_num转成int数字，入栈stack。\n\n此时栈的内容基本是数字+字符+数字+字符的组合，类似于`['c', 'r', 3, 'a', 'b', 2, 'x', 'y', 'z', 5, 'a', 'a']`，如果碰到了\"]\"，那就直接把数字之前的所有字符连成一起出栈，然后再把这个串重复这个数字遍。\n\n#代码\n```python\n    # 再写一遍，计算栈，不再使用\"#\"作为分隔了，可以当以后的板子用\n    def decodeString3(self, s: str) -> str:\n        tmp_num = \"\"\n        stack = []\n        for ch in s:\n            if ch == \"[\":\n                stack.append(int(tmp_num))\n                tmp_num = \"\"\n            elif ch == \"]\":\n                i = len(stack) - 1\n                while i >= 0:\n                    if isinstance(stack[i], int):\n                        break\n                    i -= 1\n                t = stack[i]\n                tmp = \"\".join(stack[i + 1:])\n                stack = stack[:i] + [tmp * t]\n            elif 48 <= ord(ch) <= 57:\n                tmp_num += ch\n            else:\n                stack.append(ch)\n        return \"\".join(stack)\n\n    # 参考题解写的递归法\n    def decodeString(self, s: str) -> str:\n\n        def dfs(i):\n            tmp_num = \"\"\n            res = \"\"\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    tmp_num += s[i]\n                elif s[i] == '[':\n                    i, tmp = dfs(i + 1)\n                    res += tmp * int(tmp_num)\n                    tmp_num = \"\"\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n\n        return dfs(0)\n\n```\n# 复杂度\nTC: O(n)\nSC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995005971","body":"# 思路\n\n将一个栈定义为输入栈，一个栈定义为输出栈。\npush就往输入栈里压数据，pop的话就从输出栈里拿数据。如果输出栈里没有数据了，那就将输入栈的所有数据全部倒腾到输出栈里。\n\n这就好像是两个栈把底部黏在了一起，一个吃输入，一个吐输出，这就形成了一个队列。唯一要解决问题是两个栈之间的交流，即输入栈如何把数据挪到输出栈来。那要挪的时候没办法，只能一个一个搬，但是因为pop的总次数和搬运的总次数相当，所以\"均摊时间复杂度\"为 O(1)。\n这里解释一下，假设一共要pop n次，那么我一共也只需要挪n次数据(pop+push)，故均摊下来执行O(2n/n)得到O(1)的时间复杂度\n\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.front = None\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        if not self.in_stack:\n            self.front = x\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        return self.out_stack[-1] if self.out_stack else self.front\n\n    def empty(self) -> bool:\n        return len(self.in_stack) == 0 and len(self.out_stack) == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996357444","body":"# 思路\n先取arr[0]作为一个max_num，从右往左扫，找到第一个比max_num要小的元素small，这里表示从0开始到small这个区间可能是第一个\"块\"(因为它俩顺序反了，必须当成一个块)\n\n接着在这个可能的\"块\"里找一个最大值作为max_num，继续从右往左扫，重复上面的操作，直到这个块的长度不再增加(或者是max_num不变)，说明这个块确定下来了，cnt+=1.\n\n重复这个步骤，直到整个list扫完\n\n另一个思路是题解给的单调栈，比我这个好多了。\n\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        i, j = 1, n - 1\n        max_stack = [arr[0]]\n        while i < n:\n            while i < j and max_stack[-1] <= arr[j]:\n                j -= 1\n            if max_stack[-1] <= (t := max(arr[i:j + 1])):\n                if i == j:\n                    max_stack.append(t)\n                else:\n                    max_stack[-1] = t\n            i, j = j + 1, n - 1\n\n        return len(max_stack)\n\n    def maxChunksToSorted2(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            largest = i\n            while stack and stack[-1] > i:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997105242","body":"# 思路\n\n题目叫旋转链表，本质就是把链表头尾一连，然后转k下，再打开。\n\n先遍历链表，头尾相连，顺便计数得到链表长度cnt\n\n不用真的转k下，k先对cnt取余，再用cnt-取余的结果就是真正要转的次数，即k=cnt-k%cnt\n\n再将p往后遍历k次，断开链表。\n\n# 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None:\n            return head\n        p = head\n        cnt = 1\n        while p.next:\n            cnt += 1\n            p = p.next\n        p.next = head\n        k = cnt - k % cnt\n        while k != 0:\n            p = p.next\n            k -= 1\n        head = p.next\n        p.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997301228","body":"# 思路\n\n用一个空节点来作为头，省掉头的edge case。然后两个指针换来换去就行了\n\n# python\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        p = ListNode()\n        p.next = head\n        head = p\n        while (q := p.next) and q.next:\n            p.next = q.next\n            q.next = q.next.next\n            p.next.next = q\n            p = p.next.next\n        return head.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997449068","body":"# 思路\n\n题目和108很类似，四个方法，\n\n- naive思路：遍历链表找中点，把链表截断分成左中右，递归构造树，复杂度O(nlogn)，慢在每次要遍历链表\n- 参考的思路：链表顺序和树中序遍历结果相同。可以根据链表长度提前把树构造好，直接中序遍历树填空即可。复杂度O(n)\n- 上述优化：不再提前把树建好，而是用left和right来找到边界，边遍历边建树\n- 偷懒思路：把链表变成列表，可以在O(1)找到中点。\n\n# 代码\n```python\nclass Solution:\n    # naive思路，遍历链表找中点，把链表截断分成左中右，递归构造树，\n    # 复杂度O(nlogn)，慢在每次要遍历链表\n    def sortedListToBST1(self, head: ListNode) -> TreeNode:\n        if head is None:\n            return None\n        if head.next is None:\n            return TreeNode(head.val)\n        mid = end = head\n        mid_pre = None\n\n        while end and end.next:\n            mid_pre = mid\n            mid = mid.next\n            end = end.next.next\n\n        root = TreeNode(mid.val)\n        if mid_pre:\n            mid_pre.next = None\n        root.left = self.sortedListToBST1(head)\n        root.right = self.sortedListToBST1(mid.next)\n\n        return root\n\n    # 题解思路，根据链表长度提前把树构造好，直接中序遍历树填空即可\n    # 因为链表顺序和中序遍历结果相同。复杂度O(n)\n    def sortedListToBST2(self, head: ListNode) -> TreeNode:\n        p = head\n        cnt = 0\n        while p:\n            cnt += 1\n            p = p.next\n        if cnt == 0:\n            return None\n        root = TreeNode()\n        nodes = deque([root])\n        i = 1\n        while i < cnt:\n            node = nodes.popleft()\n            if i < cnt:\n                node.left = TreeNode()\n                nodes.append(node.left)\n                i += 1\n            if i < cnt:\n                node.right = TreeNode()\n                nodes.append(node.right)\n                i += 1\n        cur = head\n\n        def mid_traverse(node):\n            nonlocal cur\n            if node.left:\n                mid_traverse(node.left)\n            node.val = cur.val\n            cur = cur.next\n            if node.right:\n                mid_traverse(node.right)\n\n        mid_traverse(root)\n        return root\n    \n    # 上述方法的优化，不再提前把树建好，而是边遍历边建\n    def sortedListToBST3(self, head: ListNode) -> TreeNode:\n        cnt = 0\n        p = head\n        while p:\n            cnt += 1\n            p = p.next\n\n        def build(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode()\n            root.left = build(left, mid - 1)\n            nonlocal p\n            root.val = p.val\n            root.right = build(mid + 1, right)\n            return root\n\n        p = head\n        return build(0, cnt - 1)\n\n    # 偷懒思路，把链表转成列表，再套用上面的方法，O(n)\n    def sortedListToBST4(self, head: ListNode) -> TreeNode:\n        p = head\n        arr = []\n        while p:\n            arr.append(p.val)\n            p = p.next\n\n        def merge(arr):\n            if len(arr) == 0:\n                return None\n            mid = len(arr) // 2\n            root = TreeNode(arr[mid])\n            root.left = merge(arr[:mid])\n            root.right = merge(arr[mid + 1:])\n            return root\n\n        return merge(arr)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998222821","body":"# 思路\n\n- 朴素思想，算长度差，对齐\n- 链表互补法，A走完了从B继续走，B走完了从A继续走。两个指针都走了同样的长度\n- 第三个方法同上，写法更简洁，看代码\n\n# 代码\n\n```python\nclass Solution:\n    # 朴素思想，算长度差，对齐\n    def getIntersectionNode1(self, headA: ListNode, headB: ListNode) -> ListNode:\n        start = ListNode(0)\n        p = start\n        p.next = headA\n        cntA = 0\n        while p := p.next:\n            cntA += 1\n        p = start\n        p.next = headB\n        cntB = 0\n        while p := p.next:\n            cntB += 1\n\n        if cntA > cntB:\n            cnt = cntA - cntB\n            p, q = headA, headB\n        else:\n            cnt = cntB - cntA\n            p, q = headB, headA\n\n        while cnt:\n            p = p.next\n            cnt -= 1\n\n        while p != q and (p := p.next) and (q := q.next):\n            continue\n        return p\n\n    # 链表互补法，A走完了从B继续走，B走完了从A继续走。两个指针都走了同样的长度\n    def getIntersectionNode2(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = ListNode(), ListNode()\n        p.next, q.next = headA, headB\n        headA, headB = p, q\n\n        while p != q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p\n\n    # 同上，写法更简洁\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = headA, headB\n        while p != q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999066859","body":"## 思路\n- 快慢指针navie思路，只领会了快慢指针的表皮，没有深入理解题目第二个难点同样可以快慢指针解决\n- 快慢指针：上述方法改进。假设环形链表公共部分是a，要求的点是ans，快慢指针第一次相遇点是meet，那么起点到ans的路程是a，ans到meet是b，meet到ans是c，而快指针走的路程是慢指针的两倍\n  则有2(a+b)=a+n(b+c)+b，化简得到a+b=n(b+c)，a=n(b+c)-b。如果从起点走到ans (路程为a)就等于从meet点走n圈再回退b步。两个人可以相遇到ans点\n\n## 代码\n```python\nclass Solution:\n    # 快慢指针naive思路，只领会了快慢指针的表皮，没有深入理解题目第二个难点同样可以快慢指针解决\n    def detectCycle1(self, head: ListNode) -> ListNode:\n        fast = slow = start = ListNode(0)\n        start.next = head\n\n        meet = None\n        while fast and slow:\n            slow = slow.next\n            fast = fast.next.next if fast.next else None\n            if fast == slow:\n                meet = fast\n                break\n\n        while meet:\n            p, q = start, meet\n            while p.next != meet:\n                p = p.next\n            while q.next != meet:\n                q = q.next\n            if p != q:\n                return meet\n            meet = meet.next\n\n        return meet\n\n    # 快慢指针：上述方法改进，假设环形链表公共部分是a，要求的点是ans，快慢指针第一次相遇点是meet，\n    # 那么起点到ans的路程是a，ans到meet是b，meet到ans是c，而快指针走的路程是慢指针的两倍\n    # 则有2(a+b)=a+n(b+c)+b，化简得到a+b=n(b+c)，a=n(b+c)-b\n    # 如果从起点走到ans (路程为a)就等于从meet点走n圈再回退b步。两个人可以相遇到ans点\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = start = ListNode(0)\n        start.next = head\n        meet = None\n\n        while fast and slow:\n            slow = slow.next\n            fast = fast.next.next if fast.next else None\n            if fast == slow:\n                meet = fast\n                break\n\n        if not meet:\n            return meet\n        while (meet := meet.next) != (start := start.next):\n            continue\n        return meet\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000110367","body":"# 思路\n- 双向链表+哈希表：操作比较基本，双向链表用来维护队尾的元素，哈希表构建key到链表节点的映射\n- OrderedDict：python built-in数据结构，真香。\n# 代码\n```python\nclass ListNode:\n    def __init__(self, key=-1, val=-1, pre=None, next=None):\n        self.key = key\n        self.val = val\n        self.pre = pre\n        self.next = next\n\n\n# 双向链表+哈希表：操作比较基本，双向链表用来维护队尾的元素，哈希表构建key到链表节点的映射\nclass LRUCache1:\n    def __init__(self, capacity: int):\n        self.d = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.tail.pre = self.head\n        self.head.next = self.tail\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.d:\n            node = self.d[key]\n            if self.head.next == node:\n                return node.val\n\n            node.pre.next = node.next\n            node.next.pre = node.pre\n\n            node.pre = self.head\n            node.next = self.head.next\n\n            node.pre.next = node\n            node.next.pre = node\n\n            return node.val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.d:\n            node = ListNode(key=key, val=value, pre=self.head, next=self.head.next)\n            self.head.next.pre = node\n            self.head.next = node\n            self.d[key] = node\n            if len(self.d) > self.capacity:\n                last = self.tail.pre\n                last.pre.next = last.next\n                last.next.pre = last.pre\n                self.d.pop(last.key)\n        else:\n            self.get(key)\n            self.d[key].val = value\n\n\n# OrderedDict：python built-in数据结构，真香。\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.d = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.d:\n            self.d.move_to_end(key)\n            return self.d[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.d:\n            self.d.move_to_end(key)\n        self.d[key] = value\n        if len(self.d) > self.capacity:\n            self.d.popitem(last=False)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000545911","body":"# 思路\n- 队列：非递归写法，用队列作为辅助栈模拟层序遍历的过程\n- 递归：一行搞定，每次返回当前节点的深度，+1比较大小\n# 代码\n```python\nclass Solution:\n    # 队列：非递归写法，用队列作为辅助栈模拟层序遍历的过程\n    def maxDepth1(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        cnt = 0\n        q = deque([root])\n        while n := len(q):\n            for i in range(n):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            cnt += 1\n        return cnt\n\n    # 递归：一行搞定，每次返回当前节点的深度，+1比较大小\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        return max(self.maxDepth(root.left) + 1, self.maxDepth(root.right) + 1) if root else 0\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000911282","body":"# 思路\n- 递归：一行我秒了，有什么好说的\n  `return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) if p and q else p == q`\n- 非递归：用两个队列维护，pop出来的如果p和q都不是None就比较，然后leftright继续入队；如果有一个none那就直接看p!=q\n# 代码\n```python\nclass Solution:\n    # 递归：一行我秒了，有什么好说的\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        return p.val == q.val \\\n               and self.isSameTree(p.left, q.left) \\\n               and self.isSameTree(p.right, q.right) \\\n            if p and q else p == q\n    # 非递归：用两个队列维护，pop出来的如果p和q都不是None就比较，然后leftright继续入队；\n    # 如果有一个none那就直接看p!=q\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        queue_p = deque([p])\n        queue_q = deque([q])\n\n        while len(queue_p) and len(queue_q):\n            p = queue_p.popleft()\n            q = queue_q.popleft()\n            if p and q:\n                if p.val != q.val:\n                    return False\n                queue_p.append(p.left)\n                queue_p.append(p.right)\n                queue_q.append(q.left)\n                queue_q.append(q.right)\n            else:\n                if p != q:\n                    return False\n\n        return len(queue_p) == len(queue_q)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001072384","body":"# 思路\n\n- naive dfs思路：模拟测试写出来的。每次深搜的时候把目前的结果传递下去即可\n- dfs思路：上面方法的优化。主要是代码更简洁了。\n- bfs思路：经典层序遍历。把node和当前结果作为tuple放在队列里，到子节点再计入ans即可。\n\n# 代码\n```python\nclass Solution:\n    # naive dfs思路：模拟测试写出来的。每次深搜的时候把目前的结果传递下去即可\n    def sumNumbers1(self, root: TreeNode) -> int:\n        def dfs(root, num):\n            if not root.left and not root.right:\n                return root.val + num\n            sum = 0\n            if root.left:\n                sum += dfs(root.left, root.val * 10 + num * 10)\n            if root.right:\n                sum += dfs(root.right, root.val * 10 + num * 10)\n            return sum\n\n        return dfs(root, 0)\n\n    # dfs思路：上面方法的优化。主要是代码更简洁了。\n    def sumNumbers2(self, root: TreeNode) -> int:\n        def dfs(root, num):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return root.val + 10 * num\n            return dfs(root.left, root.val + num * 10) + dfs(root.right, root.val + num * 10)\n\n        return dfs(root, 0)\n\n    # bfs思路：经典层序遍历。把node和当前结果作为tuple放在队列里，到子节点再计入ans即可。\n    def sumNumbers(self, root: TreeNode) -> int:\n        ans = 0\n        q = deque()\n        q.append((root, 0))\n        while q:\n            node, cur = q.popleft()\n            cur += node.val\n            if node.left:\n                q.append((node.left, cur * 10))\n            if node.right:\n                q.append((node.right, cur * 10))\n            if not node.left and not node.right:\n                ans += cur\n        return ans\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weilantao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaozizhong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pearlcoastal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"greyqt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lagrangist":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996378859","body":"class Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stk;\r\n        for(int i =0;i<arr.size();i++){\r\n            if(!stk.empty()&&stk.top()>arr[i]){\r\n               \r\n                int cur = stk.top();\r\n                // 维持栈的单调递增\r\n                while(!stk.empty()&&stk.top()>arr[i]){\r\n                    stk.pop();\r\n                }\r\n                stk.push(cur);\r\n            }else{\r\n                stk.push(arr[i]);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stk.size();\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000373956","body":"class Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root)\r\n        {\r\n            return 0;\r\n        }\r\n        else\r\n        {\r\n            return (max(maxDepth(root->left),maxDepth(root->right))+1);\r\n        }\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000985243","body":"## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/) \r\n\r\n难度简单\r\n\r\n给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。\r\n\r\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\r\n\r\n```\r\n输入：p = [1,2,3], q = [1,2,3]\r\n输出：true\r\n```\r\n\r\n**示例 2：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\r\n\r\n```\r\n输入：p = [1,2], q = [1,null,2]\r\n输出：false\r\n```\r\n\r\n**示例 3：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\r\n\r\n```\r\n输入：p = [1,2,1], q = [1,1,2]\r\n输出：false\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- 两棵树上的节点数目都在范围 `[0, 100]` 内\r\n- `-104 <= Node.val <= 104`\r\n\r\n\r\n\r\n## 思路\r\n\r\n* 只有左右子树相同且当前结点的值相同才能一样\r\n* 写几个来防止空指针访问\r\n\r\n## 代码\r\n\r\n```c++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        //base case\r\n        if(!(p||q)) return true;\r\n        if((p && !q)||(q && !p)) return false;\r\n        return (isSameTree(p->left,q->left)&&isSameTree(p->right,q->right)&&p->val == q->val)?true:false;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n* 空间复杂度为递归栈深度，最大为树最大深度 O(depth)\r\n* 时间复杂度为 O(n) , n 为结点个数\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asukareisj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stefanleeee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huijunxu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naivecoder1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxqkb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995861211","body":"### 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        temp = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return temp\n\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        return self.stack1[0]\n\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        if len(self.stack1) == 0:\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996562414","body":"### 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for a in arr:\n            if stack and a < stack[-1]:\n                cur = stack[-1]\n                while stack and a < stack[-1]:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997958129","body":"### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n### 复杂度分析\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998563376","body":"### 代码\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a = headA\n        b = headB\n        while a != b:\n            if a:\n                a = a.next\n            else:\n                a = headB\n            if b:\n                b = b.next\n            else:\n                b = headA\n        return a\n```\n### 复杂度分析\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999412057","body":"### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n### 复杂度分析\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000021685","body":"### 代码\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()  \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"imsingee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"poidaze7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996784588","body":"```CPP\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count = collections.defaultdict(int)\r\n        ans = nonzero = 0\r\n\r\n        for x, y in zip(arr, sorted(arr))\r\n            count[x] += 1\r\n            if count[x] == 0: nonzero -= 1\r\n            if count[x] == 1: nonzero += 1\r\n\r\n            count[y] -= 1\r\n            if count[y] == -1: nonzero += 1\r\n            if count[y] == 0: nonzero -= 1\r\n\r\n            if nonzero == 0: ans += 1\r\n\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997157845","body":"```CPP\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        int n = 0;\r\n        ListNode* node = head;\r\n        while(node){\r\n            node = node->next;\r\n            n++;\r\n        }\r\n        if (n <= 1) return head;\r\n        if (k % n == 0) return head;\r\n        k = n - k % n;\r\n        node = head;\r\n        while(--k){\r\n            node = node->next;\r\n        }\r\n        ListNode* ret = node->next;\r\n        node->next = nullptr;\r\n        node = ret;\r\n        while(node && node->next != nullptr){\r\n            node = node->next;\r\n        }\r\n        node->next = head;\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997402514","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* dummy = new ListNode(0);\r\n        dummy->next = head;\r\n        ListNode* node = dummy;\r\n        while(node->next != nullptr && node->next->next != nullptr){\r\n            ListNode* node1 = node->next;\r\n            ListNode* node2 = node->next->next;\r\n            node1->next = node2->next;\r\n            node2->next = node1;\r\n            node->next = node2;\r\n            node = node->next->next;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998007698","body":"```CPP\r\nclass Solution {\r\nprivate:\r\n    TreeNode* buildTree(ListNode*& node, int left, int right){\r\n        if (left > right) return nullptr;\r\n        int mid = (left + right + 1) / 2;\r\n        TreeNode* root = new TreeNode();\r\n        root->left = buildTree(node, left, mid - 1);\r\n        root->val = node->val;\r\n        node = node->next;\r\n        root->right = buildTree(node, mid + 1, right);\r\n        return root;\r\n    }\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int cnt = 0;\r\n        ListNode* tmp = head;\r\n        while(tmp){\r\n            cnt++;\r\n            tmp = tmp->next;\r\n        }\r\n        return buildTree(head, 0, cnt-1);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998871192","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* pA = headA;\r\n        ListNode* pB = headB;\r\n        while(pA != pB){\r\n            pA = pA == nullptr?headB:pA->next;\r\n            pB = pB == nullptr?headA:pB->next;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999655818","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode* fast = head;\r\n        ListNode* slow = head;\r\n        while(fast != nullptr){\r\n            slow = slow->next;\r\n            if (fast->next == nullptr){\r\n                return nullptr;\r\n            }\r\n            fast = fast->next->next;\r\n            if (slow == fast){\r\n                while(head != slow){\r\n                    head = head->next;\r\n                    slow = slow->next;\r\n                }\r\n                return head;\r\n            }\r\n            \r\n        }\r\n        return NULL;\r\n    }\r\n    \r\n};\r\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999955786","body":"```CPP\r\nstruct DLinkedNode{\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr){}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr){}\r\n};\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\npublic:\r\n    LRUCache(int _capacity){\r\n        capacity = _capacity;\r\n        size = 0;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key){\r\n        if (!cache.count(key)) return -1;\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)){ // 如果cache中不存在key， \r\n            // 创建一个新的节点\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            //添加进哈希表内\r\n            cache[key] = node;\r\n            //添加至双向链表头部\r\n            addToHead(node);\r\n            ++size; // size 加1\r\n            if (size > capacity){ // cache大小超过容量\r\n                DLinkedNode* removed = removeTail(); // 删除尾部节点\r\n                cache.erase(removed->key); // 删除哈希表索引\r\n                delete removed; //防止内存泄漏\r\n                --size;\r\n            }\r\n        } else { // key在cache中\r\n            DLinkedNode* node = cache[key]; // 定位节点位置\r\n            node->value = value; // 修改value\r\n            moveToHead(node); // 移动至头部\r\n        }\r\n    }\r\n    void addToHead(DLinkedNode* node){\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    void removeNode(DLinkedNode* node){\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n    void moveToHead(DLinkedNode* node){\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n    DLinkedNode* removeTail(){\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000871306","body":"class Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        if not root.left and not root.right:\r\n            return 1\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right))+1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001032296","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == nullptr && q == nullptr){\r\n            return true;\r\n        } else if (p == nullptr && q != nullptr){\r\n            return false;\r\n        } else if (p != nullptr && q == nullptr){\r\n            return false;\r\n        }\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingbinxu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996320486","body":"**思路**\r\n采用官方思路：利用单调栈存储\r\n遇到一个数小于栈的最大值，只保留最大值，否则就相当于增加一个块\r\n弹出递增的，以前的递增会因为一个低值而必须把这个低值包含进去\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n     int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stack;\r\n        for(int i =0;i<arr.size();i++){\r\n            if(!stack.empty()&&stack.top()>arr[i]){\r\n                //遇到一个数小于栈的最大值，只保留最大值，否则就相当于增加一个块\r\n                int max = stack.top();\r\n                //弹出递增的，只保留最大值\r\n                while(!stack.empty()&&stack.top()>arr[i]){\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }else{\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n};\r\n\r\n```\r\n**复杂度**\r\n时间复杂度：遍历O（N）\r\n空间复杂度：栈存储，最大O（N）","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998833699","body":"**思路**\r\n利用两个指针走A+B+C长度一定会相交，找出那个相交点\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA == NULL || headB == NULL){\r\n            return NULL;\r\n        }\r\n        ListNode *hA = headA;\r\n        ListNode *hB = headB;\r\n        while(hA != hB)\r\n        {\r\n            hA = hA == NULL ? headB : hA->next;\r\n            hB = hB == NULL ? headA : hB->next;\r\n        }\r\n        return hA;\r\n    }\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：遍历链表O（N）\r\n空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gz712d":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smallcodebo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zymacro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florencelll":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991916994","body":"### 思路\n1.把k转为数组，做数组逐位相加的运算，需要一个tmp array记录哪一位进1了;\n\n2.把num转为数字计算后再转数组;\n\n3.边把num加到k里，边存;\n\n\n采用3，有3个步骤：\n\n1.将num未计算的最低位取出来，跟k相加\n\n2.将k未存到AL的最低位存进去\n\n3.全部完成后 reverse刚刚的AL，因为是从低位存的，但每次都是addLast操作\n\n\n\n\n### 代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = num.length - 1; i >= 0 || k > 0; i--, k /= 10) {\n            //add num to k from low bits\n            if (i >= 0) {\n                k += num[i];\n            }\n            //add k's bit to AL from low\n            res.add(k % 10);\n        }\n        //reverse\n        Collections.reverse(res);\n        return res;   \n    }\n}\n```\n\n### 复杂度分析：\n时间复杂度 O(n)，这里n是 num、k的长度中的最大值(reverse的操作应该是logn的？）\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992191732","body":"### 思路\n左右两个指针，固定左指针，右指针遍历数组，计算最小距离\n\n明早学习一下O(n)是怎么解决的\n\n### 代码\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] ch = s.toCharArray();\n        int[] res = new int[ch.length];\n        \n        for (int i = 0; i < ch.length; i++) {\n            int dis = ch.length;\n            for (int j = ch.length -1; j >= 0; j--) {\n                if (ch[j] == c) {\n                    dis = Math.min(Math.abs(j - i), dis);\n                }\n            }\n            res[i] = dis;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n时间复杂度 O(n^2)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993684390","body":"### 思路\n用数组做栈的底层，恰好是在尾部增删\n\n\n### 代码\n``` java\nclass CustomStack {\n    int[] stack;\n    int curSize;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        curSize = 0;    \n    }\n    \n    public void push(int x) {\n        if(curSize < stack.length) {\n            stack[curSize++] = x;\n        }\n    }\n    \n    public int pop() {\n        if(curSize > 0) {\n            return stack[--curSize];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        // int temp = Math.min(k,count);\n        for (int i = 0; i < k && i < curSize;i++){\n            stack[i] +=val;\n        }\n    }\n}\n\n```\n\n### 复杂度\n时间复杂度 push&pop O(1), increment O(n)\n\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999636462","body":"### 代码\n``` java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiwri-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirito1017":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997162006","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        lenth = 1\n        pt = head\n        while pt.next != None:\n            pt = pt.next\n            lenth += 1\n        old_tail = pt\n        true_k = k % lenth\n        if true_k == 0: return head\n        num_to_move = lenth - true_k\n        cur = head\n        while num_to_move - 1:\n            cur = cur.next\n            num_to_move -= 1\n        new_tail = cur\n        new_head = cur.next\n        old_tail.next = head\n        new_tail.next = None\n        return new_head","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fullstackh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carinskyrim":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziyangz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"threegold-yxh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991855499","body":"# [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n\n\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\n\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式。\n\n```java\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n```\n\n\n\n```java\n提示：\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n\n\n## 思路一\n\n模拟加法的过程即可\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //因为num的位数可以有10000位，所以肯定是超过了int，或者long的，那么只能通过数组按位计算\n        //每一位的值 = num数组在这一位上的值 + k数组在这一位上的值 + 前一位的进位\n        LinkedList<Integer> res = new LinkedList<>();\n        int carry = 0;\n        for(int i = num.length - 1; i >= 0; i--){\n            //拿当前k的最后一位 Take the last digit of the current k\n            int kLastDigital = k % 10;\n            //sum of the add\n            int sumOfAdd = num[i] + kLastDigital + carry;\n            //注意是头插到结果list中\n            res.addFirst(sumOfAdd % 10);\n\n            //处理carry和k\n            carry = sumOfAdd / 10;\n            k = k / 10;\n        }\n        //如果k提前结束了，那没有关系，后面全部加的都是0\n        //但如果是num先结束了，k还有剩余，那还要把k给处理完\n        while(k != 0){\n            int kLastDigital = k % 10;\n            int sumOfAdd = kLastDigital + carry;\n            //注意是头插到结果list中\n            res.addFirst(sumOfAdd % 10);\n            //处理carry和k\n            carry = sumOfAdd / 10;\n            k = k / 10;\n        }\n        //最后还要检查carry里面还有没有数，如果有的话，加进去\n        if(carry!=0){\n            res.addFirst(carry);\n        }\n\n        return res;        \n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992613526","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n```java\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n```\n\n示例 2：\n\n```java\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n```\n\n提示：\n1 <= s.length <= 10<sup>4</sup>\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n\n\n\n\n## 方法一：先假定这个c的坐标存在，然后从左从右遍历两次\n\n```java\n//方法一：先假定这个c的坐标存在，然后遍历两次\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //创建结果数组\n        int[] res = new int[s.length()];\n        //首先从左往右遍历，我们假定c最开始的下标是Integer.MIN_VALUE / 2\n        //除以2是为了防止负溢出\n        //它代表的含义是从左边算起的，离当前结点左边的最近的c的位置\n        int leftClosestPos = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < s.length(); i++){\n            //如果找到了c，修改pos值\n            if(s.charAt(i) == c){\n                leftClosestPos = i;\n            }\n            res[i] = i - leftClosestPos;\n        }\n        //然后再从右边开始遍历\n        //它代表的含义是从右边算起的，离当前结点右边的最近的c的位置\n        int rightClosestPos = Integer.MAX_VALUE / 2;\n        for(int i = s.length() - 1; i >= 0; i--){\n            //如果找到了c，修改pos值\n            if(s.charAt(i) == c){\n                rightClosestPos = i;\n            }\n            //这里要和已有的左边的最近值比较，看谁更小\n            res[i] = Math.min(rightClosestPos - i, res[i]);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993676570","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n\n\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n\n\n## 思路一\n\n内部用双向链表，维护一个count去保存当前的结点个数，头结点是一个虚拟结点。\n\n\n\n```java\nclass CustomStack {\n    //虚拟头结点\n    private Node virtualHead;\n    //最大值\n    private int maxSize;\n    //当前栈内结点数\n    private int count;\n    //top index\n    private Node top;\n\n\n    //初始化栈\n    public CustomStack(int maxSize) {\n        virtualHead = new Node();\n        top = virtualHead;\n        this.maxSize = maxSize;\n        this.count = 0;\n    }\n    \n    public void push(int x) {\n        //if statck is full, do nothing\n        if(count == maxSize){\n            return;\n        }\n        Node node = new Node(x);\n        top.next = node;\n        node.pre = top;\n        top = node;\n        count ++;\n    }\n    \n    public int pop() {\n        if(count == 0){\n            return -1;\n        }\n        Node node = top;\n        top = top.pre;\n        top.next = null;\n        count --;\n        return node.value;\n    }\n    \n    public void increment(int k, int val) {\n        int upLimit = count < k ? count : k;\n        Node head = virtualHead;\n        for(int i = 0; i < upLimit; i++){\n            head = head.next;\n            head.value += val;\n        }\n    }\n\n\n    //内部结点\n    class Node{\n        Node pre;\n        int value;\n        Node next;\n        public Node(){\n\n        }\n        public Node(int value){\n            this.value = value;\n        }\n        public Node(Node pre, int value, Node next){\n            this.pre = pre;\n            this.value = value;\n            this.next = next;\n        }\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994922020","body":"class Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        //乘积积累量\n        int multi = 0;\n        //注意要有两个栈\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            //把当前的res和multi都放进栈，然后置为null，避免对接下来的元素产生影响\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995934404","body":"class MyQueue {\n    //定义两个全局栈\n    Deque<Integer> stack1;//存放队列元素\n    Deque<Integer> stack2;//辅助栈\n    //初始化\n    public MyQueue() {\n        stack1 = new LinkedList<Integer>();//初始化stack1\n        stack2 = new LinkedList<Integer>();//初始化stack2 \n    }\n    \n    public void push(int x) {\n        //入队操作实现的关键：待入队的新元素 == 栈底\n        //1.将stack1中的所有元素移到stack2\n        while(!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        //2.将待入队元素 x 入栈stack2\n        stack2.push(x);\n        //3.将stack2所有元素移到stack1\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n\n    }\n    \n    public int pop() {\n        //stack1的栈顶元素即队列首元素\n        return stack1.pop();\n\n    }\n    \n    public int peek() {\n        return stack1.peek();\n\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996828560","body":"//思路一：单调递增栈\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int max = Integer.MIN_VALUE / 2;\n        Deque<Integer> stack = new LinkedList<>();\n        for(int i = 0; i < arr.length; i++){\n            //如果当前元素比max要大，或者相等，那么就把最大值放进单调栈，代表着新建了一个块，同时保存了这个块的最大值\n            if(arr[i] >= max){\n                max = arr[i];\n                stack.addFirst(max);\n            }\n            else{\n                //如果当前元素的值比单调栈栈顶的max要小，那么就说明它前面的一个块要和它合并\n                //合并后我们会继续让单调栈再出栈一个，看是不是比新的max要小，如果小的话还要再合并\n                //一直合并到arr[i] >= max为止\n                \n                //最外层的合并了，先出栈\n                int temp = stack.removeFirst();\n                //继续看更前面的块，如果arr[i]比它还要小，继续合并，只要stack不为空\n                while(!stack.isEmpty() && stack.peekFirst() > arr[i]){\n                    //继续出栈\n                    temp = stack.removeFirst();\n                }\n                //把最后出栈合并的那个块补回来\n                stack.addFirst(temp);\n            }\n\n        }\n        //返回stack的元素个数\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222026","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode cur = head;\n        int count = 0;\n        //求长度\n        while(cur!=null){\n            count+;\n            cur = cur.next;\n        }\n        //k取模\n        k = k % count;\n        //方法：先全部反转一次，然后前k个结点反转一次，后面的结点再反转一次\n        head = reverseList(head).getHead();\n        //找第k+1个结点\n        for(int i = 0; i < k; i++){\n            \n        }\n\n    }\n\n    //反转链表，并返回新链表的头结点和尾结点\n    public HeadAndTail reverseList(ListNode head){\n        ListNode curNode = null;\n        ListNode nextNode = head;\n        while(nextNode != null){\n            ListNode temp = curNode.next;\n            nextNode.next = curNode;\n            curNode = nextNode;\n            nextNode = temp;\n        }\n        HeadAndTail res = new HeadAndTail();\n        res.setHead(curNode);\n        res.setTail(head);\n        return res;\n    }\n\n\n\n    class HeadAndTail{\n        ListNode head;\n        ListNode tail;\n        public HeadAndTail(){\n\n        }\n        public ListNode getHead(){\n            return this.head;\n        }\n        public ListNode getTail(){\n            return this.tail;\n        }\n        public void setHead(ListNode head){\n            this.head = head;\n        }\n        public void setTail(ListNode tail){\n            this.tail = tail;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997348388","body":"## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n\n\n\n\n### 思路一：交换结点，注意到底是谁连谁\n\n\n\n\n\n#### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //先处理特殊情况\n        if(head == null || head.next == null){\n            return head;\n        }\n        //然后开始交换结点\n        ListNode firstNode = head;\n        ListNode secondNode = head.next;\n        ListNode nextNode = null; //这个是保存一个nextNode结点\n        //调整头结点\n        head = secondNode;\n        while(firstNode!=null && secondNode!=null){\n            //先保存好next结点\n            nextNode = secondNode.next;\n            secondNode.next = firstNode;\n            //临时保存一下\n            ListNode temp = firstNode;\n\n            //结点后移\n            firstNode = nextNode;\n            if(firstNode!=null){\n                secondNode = firstNode.next;\n            }\n            else{\n                secondNode = null;\n            }\n\n            //连接前后两组结点\n            if(secondNode == null){\n                temp.next = firstNode;\n            }\n            else{\n                temp.next = secondNode;\n            }\n\n        }\n        return head;\n    }\n}\n```\n\n\n\n\n\n#### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$\n\n\n\n\n\n\n\n### 思路二：递归\n\n终止条件：链表中没有结点，或者链表中只有一个结点，此时无法交换，return该结点/null后结束\n\n当链表中至少有两个或两个以上结点时，head为原链表第一个结点，也是交换后新链表的第二个节点\n\nheadNext为原链表的第二个结点，也是交换后新链表的第一个结点。\n\n我们的swap方法默认肯定是返回新链表的头结点，用head.next = swap(headNext.next)，headNext目前表示的是原链表的第二个结点，headNext.next表示的是链表后面部分的头结点，也是下一重递归的开头\n\n之后再把headNext.next = head;然后把head = headNext，return head即可。\n\n\n\n#### 代码\n\n```java\n//方法二：递归方法解决\n//终止条件：链表中没有结点，或者链表中只有一个结点，此时无法交换，return该结点/null后结束\n//当链表中至少有两个或两个以上结点时，head为原链表第一个结点，也是交换后新链表的第二个节点\n//headNext为原链表的第二个结点，也是交换后新链表的第一个结点，我们的swap方法默认肯定是\n//返回新链表的头结点，用head.next = swap(headNext.next),headNext目前表示的是原链表的第二个结点\n//headNext.next表示的是链表后面部分的头结点，也是下一重递归的开头\n//之后再把headNext.next = head;然后把head = headNext，return head即可。\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //递归的出口，如果没有结点或者只剩一个结点，直接返回head\n        if(head == null||head.next == null){\n            return head;\n        }\n        //维护一个headNext,headNext目前代表了当前链表的第二个结点\n        ListNode headNext = head.next;\n\n        //交换后，head是第二个结点，把它的next指向后面交换好的链表的头结点\n        head.next = swapPairs(headNext.next);\n        //headNext.next = head\n        //交换结点\n        headNext.next = head;\n        head = headNext;\n        return head;\n    }\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：$o(n)$\n\n空间复杂度：$o(n)$   因为递归栈的最大深度为n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997966869","body":"#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n\n\n## 题目\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\nGiven the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\n\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\nExample 1:\n\nInput: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n\nExample 2:\n\nInput: head = []\nOutput: []\n\nExample 3:\n\nInput: head = [0]\nOutput: [0]\n\nExample 4:\n\nInput: head = [1,3]\nOutput: [3,1]\n\n\n\n## 思路一：有序链表转换成有序数组\n\n第一种方法，把有序链表转换成有序数组，然后我们认为这个数组的中间元素就是二叉搜索树的根，它的左边部分的中间元素是左分支树的根，它的右边部分的中间元素是右分支树的根，以此类推。\n\n利用分而治之的思想将建树缩小为局部的：找到根节点，连接其左分支树根节点，连接其右分支树根节点，找到中间元素的方法：mid = left + (right - left +1) / 2; \n\n递归退出条件：left>right时return null，因为叶子节点应该都存在left == right，它们再继续往下递归，不管是左子树还是右子树都会发生left>right，return null作为结束条件\n\n\n\n### 代码\n\n```java\n//第一种方法，把有序链表转换成有序数组，然后我们认为这个数组的中间元素就是二叉搜索树的根，\n //它的左边部分的中间元素是左分支树的根，它的右边部分的中间元素是右分支树的根，以此类推\n //利用分而治之的思想将建树缩小为局部的：找到根节点，连接其左分支树根节点，连接其右分支树根节点\n //找到中间元素的方法：mid = left + (right - left +1) / 2;\n //递归退出条件：left>right时return null，因为叶子节点应该都存在left == right，它们再继续往下递归\n //不管是左子树还是右子树都会发生left>right，return null作为结束条件\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        //创建用来保存链表中元素的数组\n        List<Integer> list = new ArrayList<>();\n        //遍历链表，添加到数组中\n        for(ListNode element = head; element != null; element = element.next){\n            list.add(element.val);\n        }\n        return buildBST(0,list.size() - 1,list);\n    }\n\n    public TreeNode buildBST(int left, int right, List<Integer> list){\n        //先给出递归的出口\n        if(left>right){\n            return null;\n        }\n        //根据下标mid在list中拿到中间元素，并生成结点\n        int mid = left + (right - left + 1) / 2;\n        TreeNode root = new TreeNode(list.get(mid));\n        //连接左右子树\n        root.left = buildBST(left,mid-1,list);\n        root.right = buildBST(mid+1,right,list);\n        //最后才是返回root\n        return root;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$o(n)$ \n\n因为每一次拿到中间元素的用时都是o(1)，所以总体下来相当于遍历了整个list一次，时间复杂度为o(n)\n\n空间复杂度：$o(n)$  \n\n因为创建了大小为n的list\n\n\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998577415","body":"## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n\n\n### 思路一：双指针\n\n#### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        //双指针，indexA，indexB一起出发，indexA走到头后就从B出发，indexB走到头后再从A出发\n        //两个指针最终的交点就是结果\n        ListNode indexA = headA;\n        ListNode indexB = headB;\n        boolean isFirstTimeA = true;\n        boolean isFirstTimeB = true;\n        while(indexA != null && indexB != null && indexA != indexB){\n            indexA = indexA.next;\n            indexB = indexB.next;\n            if(indexA == null && isFirstTimeA){\n                indexA = headB;\n                isFirstTimeA = false;\n            }\n            if(indexB == null && isFirstTimeB){\n                indexB = headA;\n                isFirstTimeB = false;\n            }\n        }\n        return indexA == indexB ? indexA : null;\n    }\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$\n\n\n\n\n\n### 思路二：双指针改进\n\n思路一写麻烦了，如果两个链表没有相交，那么他们最后会同时为null！！\n\n#### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        //双指针，indexA，indexB一起出发，indexA走到头后就从B出发，indexB走到头后再从A出发\n        //两个指针最终的交点就是结果\n        ListNode indexA = headA;\n        ListNode indexB = headB;\n        while(indexA != indexB){\n            indexA = indexA != null ? indexA.next : headB;\n            indexB = indexB != null ? indexB.next : headA;\n        }\n        return indexA;\n    }\n}\n```\n\n\n\n\n\n#### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999650255","body":"#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n\n\n## 题目\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\n\n说明：不允许修改给定的链表。\n\n进阶：\n\n你是否可以使用 O(1) 空间解决此题？\n\n\n\n## 思路一\n\n方法一：用快慢指针来解决\n\n假设环外元素有m个，环内元素有n个，设置一个慢指针slow和快指针fast指向头结点\n\n假设慢指针走了m步到达入环第一个结点node处后又走了x步才与快指针相遇\n\n注意，此时慢指针一定还没有在环内走一圈，这是因为假设最坏的情况\n\n在慢指针进入环时（指向node处），快指针刚好指向node的下一个结点\n\n这种最坏情况快指针需要追整整n - 1步才能追上慢指针（一回合追一格）\n\n注意环内有n个元素意味着一个指针走n步后回到它本身，也就是指向node的指针走n - 1步后来到链表的尾巴\n\n而即使最坏情况下快指针需要追n-1步，这时慢指针也没有走完第一圈\n\n那么我们的快指针走了多少步？首先走了m步来到node，然后假设在环内里走了k圈，一共k * n步\n\n最后走了x步与慢指针相遇，一共是m + k * n + x步\n\n我们可以得到 m + k * n + x = 2 * (m + x)\n\n解得：k * n = m + x ,即m = k * n - x\n\n一个指针走了m步，等于另一个指针走了k * n - x步，假设我们设这另一个指针就是快慢指针相遇的那个位置指针\n\n它同步往前走k * n - x步会到哪里？ 相当于走了k * n步回到原位置，然后倒着走了x步来到node结点位置！！！\n\n这此前假如有一个从头结点出发的指针与其同步走m步，他们就会在node相遇！！！\n\n注意如果链表不成环，fast会先一步走到null或者fast.next为null此时直接抛null即可\n\n\n\n### 代码\n\n```java\n //方法一：用快慢指针来解决\n //假设环外元素有m个，环内元素有n个，设置一个慢指针slow和快指针fast指向头结点\n //假设慢指针走了m步到达入环第一个结点node处后又走了x步才与快指针相遇\n //注意，此时慢指针一定还没有在环内走一圈，这是因为假设最坏的情况\n //在慢指针进入环时（指向node处），快指针刚好指向node的下一个结点\n //这种最坏情况快指针需要追整整n - 1步才能追上慢指针（一回合追一格）\n //注意环内有n个元素意味着一个指针走n步后回到它本身，也就是指向node的指针走n - 1步后来到链表的尾巴\n //而即使快指针需要追n-1步，这时慢指针也没有走完第一圈\n //那么我们的快指针走了多少步？首先走了m步来到node，然后假设在环内里走了k圈，一共k * n步\n //最后走了x步与慢指针相遇，一共是m + k * n + x步\n //我们可以得到 m + k * n + x = 2 * (m + x)\n //解得：k * n = m + x ,即m = k * n - x\n //一个指针走了m步，等于另一个指针走了k * n - x步，假设我们设这另一个指针就是快慢指针相遇的那个位置指针\n //它同步往前走k * n - x步会到哪里？ 相当于走了k * n步回到原位置，然后倒着走了x步来到node结点位置！！！\n //这此前假如有一个从头结点出发的指针与其同步走m步，他们就会在node相遇！！！\n //注意如果链表不成环，fast会先一步走到null或者fast.next为null此时直接抛null即可\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        //注意不能这样写while(slow!=fast) 因为一开始它们就是相等的\n        while(true){\n            //如果链表根本不成环\n            if(fast==null||fast.next==null){\n                return null;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow==fast)break;\n        }\n        //此时已经找到了相遇点\n        //新建一个从头开始遍历的指针\n        ListNode tempIndicator = head;\n        while(tempIndicator!=fast){\n            tempIndicator = tempIndicator.next;\n            fast = fast.next;\n        }\n        return tempIndicator;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度: $o(n)$\n\n分析：因为我一开始slow没有走完一个环，为o(n)，接下来tempIndicator走了m步就结束了，也是o(n)，最后o(n)+o(n)结果还是o(n)\n\n空间复杂度：o(1)\n\n分析：只创建了三个指针\n\n\n\n\n\n## 思路二\n\n方法二，用Set集合然后遍历一下，有加不进去set里的结点直接返回\n\n\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        Set<ListNode> set = new HashSet<>();\n        ListNode indicator = head;\n        //遍历，都添加到set中，如果有加不进去的，证明那个元素为重复的，就是我们需要的返回值\n        while(indicator!=null){\n            if(set.add(indicator)== false ){\n                return indicator;\n            }\n            indicator = indicator.next;\n        }\n        //都加的进去，没有重复的，直接null\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度 $o(n)$  \n\n分析：只遍历了一遍\n\n空间复杂度：$o(n)$  \n\n分析：构造了一个set集合，辅助空间为o(n)\n\n\n\n\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000378126","body":"# [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\n\n\n## 思路一\n\n用一个哈希双向链表来储存数据即可，自己构造底层的双向链表，和表层的HashMap，注意map的结构是这样的：key ——>(key,value).双向链表的每一个结点都是(key,value)，注意一定要放key进去，否则你删除末尾结点时，删掉链表中的结点后没办法去删哈希表里的key-value，因为你拿不到key值，就只能遍历一遍哈希表，那太麻烦了，所以结点必须同时保存key和value.\n\n\n\n### 代码\n\n```java\nclass LRUCache {\n\n    //map中目前有几个元素\n    private int currentNum = 0;\n    //map中最多有几个元素\n    private int maxNum = 0;\n    //维护一个表\n    Map<Integer,ListNode> map;\n    //我要维护底层链表中一头一尾两个虚拟节点\n    ListNode head;\n    ListNode end;\n    \n\n    //不管是get还是put，在操作完一个结点后，都要把它放在底层链表的最前面\n    public LRUCache(int capacity) {\n        maxNum = capacity;\n\n        map = new HashMap<>();\n\n        head = new ListNode(-1,-1);\n        end = new ListNode(-1,-1);\n        head.next = end;\n        end.pre = head;\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        //存在\n        //在链表中移动到前面去\n        //先在链表中删除\n        ListNode tempNode = map.get(key);\n        \n        tempNode.next.pre = tempNode.pre;\n        tempNode.pre.next = tempNode.next;\n        tempNode.next =null;\n        tempNode.pre = null;\n\n        //再在链表头添加\n        tempNode.next = head.next;\n        tempNode.pre = head;\n        tempNode.next.pre = tempNode;\n        head.next = tempNode;\n        return map.get(key).value;\n    }\n\n    public void put(int key, int value) {\n        if(maxNum == 0){\n            return;\n        }\n        //新结点\n        ListNode newNode = new ListNode(key,value);\n        //首先检查map里面有没有这个结点，有的话把这个结点删掉\n        if(map.containsKey(key)){\n            //链表中删除\n            ListNode tempNode = map.get(key);\n            \n            tempNode.next.pre = tempNode.pre;\n            tempNode.pre.next = tempNode.next;\n            tempNode.next =null;\n            tempNode.pre = null;\n            \n            //从map中删除\n            map.remove(key);\n            currentNum --;\n        }\n        //再检查容量够不够，如果容量不够要删掉最久没访问的结点\n        if(currentNum == maxNum){\n            //链表中删除\n            ListNode deleteNode = end.pre;\n            deleteNode.pre.next = end;\n            end.pre = deleteNode.pre;\n            deleteNode.pre = null;\n            deleteNode.next = null;\n            //从map中删除\n            map.remove(deleteNode.key);\n            currentNum --;\n        }\n        //最后把新结点添加到链表的开头和map中\n        newNode.next = head.next;\n        newNode.pre = head;\n        head.next = newNode;\n        newNode.next.pre = newNode;\n\n        map.put(key,newNode);\n        currentNum ++;\n\n    }\n\n    //内部类：双向链表结点，这个地方也要存key值！！\n    class ListNode{\n        int key;\n        int value;\n        ListNode pre;\n        ListNode next;\n\n        public ListNode(){}\n\n        public ListNode(int key,int value){\n            this.key = key;\n            this.value = value;\n        }\n\n        public ListNode(int key,int value,ListNode pre, ListNode next){\n            this.key = key;\n            this.value = value;\n            this.pre = pre;\n            this.next = next;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(1)$\n\n因为干什么都能一下子找到结点\n\n空间复杂度：$O(n)$\n\n因为使用了规模为n的链表和对应的哈希表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000716298","body":"## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n\n\n返回它的最大深度 3 。\n\n\n\n### 思路\n\n直接先序遍历即可\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    int depth = 0;\n    public int maxDepth(TreeNode root) {\n        getDepth(root, 0);\n        return this.depth;\n    }\n\n    public void getDepth(TreeNode root, int dep){\n        if(root == null){\n            this.depth = Math.max(depth,dep);\n            return;\n        }\n        dep +=1;\n        getDepth(root.left, dep);\n        getDepth(root.right, dep);\n        return;\n    }\n}\n```\n\n\n\n\n\n#### 复杂度分析\n\n时间复杂度：$O(n)$\n\n每个结点都要遍历一遍\n\n空间复杂度：$O(height)$\n\nheight是二叉树的高度，空间是递归需要的栈\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000977948","body":"## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n\n\n### 思路一\n\n先序遍历两棵树\n\n\n\n#### 代码\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val){\n            return false;\n        }\n        else{\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n```\n\n\n\n\n\n#### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linrax":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991897178","body":"# 思路\n\n将数组从低位到高位加到k上,最后反转\n\n# 代码\n\n语言支持:java\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\n            if(i>=0){\n                k+=num[i];\n            }\n            res.add(k%10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度  O(max(n,log k)) , n为数组长度\n\n空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993654236","body":"# 思路\r\n\r\n用数组作为底层构建栈\r\n\r\n# 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int count;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        count = 0;    \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(count < stack.length) stack[count++] = x;     \r\n    }\r\n    \r\n    public int pop() {\r\n        if(count == 0) return -1;\r\n        return  stack[--count];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int temp = Math.min(k,count);\r\n        for (int i = 0; i <temp;i++){\r\n            stack[i] +=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度 push、pop 为O(1) , increment 为O(N)\r\n\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994924883","body":"# 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度  O(N)\n\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995938556","body":"\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997221984","body":"# 思路\n\n1、获取单链表的倒数第k与倒数第k+1个节点\n\n2、 将倒数第k+1个节点的next指向null\n\n3、将尾节点的next指向head\n\n4、返回倒数第k个节点\n\n# 代码\n\n语言支持:java\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度   最多遍历链表两遍 ，时间复杂度为O(n)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997413503","body":"# 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度   所有节点只遍历一遍，时间复杂度为O(n)\n\n空间复杂度  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998025090","body":"\n```java\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n```\n\n# 复杂度分析\n\n时间复杂度   `O(nlogn)`\n\n空间复杂度  `O(logn)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998846920","body":"# 代码\n\n```javascript\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a != b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n```\n\n# 复杂度分析\n\n时间复杂度   $O(N)$\n\n空间复杂度 $O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999685605","body":"# 思路\n\n遍历链表，将每个节点都插入哈希表，节点的引用做key，若当前遍历的节点存在，则为入口节点\n\n# 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度   $O(N)$\n\n空间复杂度   $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000359104","body":"class Node {\n        int key;\n        int value;\n        Node pre;\n        Node next;\n\n        public Node() {\n        }\n\n        public Node( int key,int value) {\n            this.key = key;\n            this.value=value;\n        }\n    }\n    class DoubleList{\n        private Node head;// 头节点\n        private Node tail;// 尾节点\n        private int length;\n        public DoubleList() {\n            head = new Node(-1,-1);\n            tail = head;\n            length = 0;\n        }\n        void add(Node teamNode)// 默认尾节点插入\n        {\n            tail.next = teamNode;\n            teamNode.pre=tail;\n            tail = teamNode;\n            length++;\n        }\n        void deleteFirst(){\n            if(head.next==null)\n                return;\n            if(head.next==tail)//如果删除的那个刚好是tail  注意啦 tail指针前面移动\n                tail=head;\n            head.next=head.next.next;\n\n            if(head.next!=null)\n                head.next.pre=head;\n            length--;\n        }\n        void deleteNode(Node team){\n\n            team.pre.next=team.next;\n            if(team.next!=null)\n                team.next.pre=team.pre;\n            if(team==tail)\n                tail=tail.pre;\n           team.pre=null;\n           team.next=null;\n            length--;\n        }\n        public String toString() {\n            Node team = head.next;\n            String vaString = \"len:\"+length+\" \";\n            while (team != null) {\n                vaString +=\"key:\"+team.key+\" val:\"+ team.value + \" \";\n                team = team.next;\n            }\n            return vaString;\n        }\n    }\n    Map<Integer,Node> map=new HashMap<>();\n    DoubleList doubleList;//存储顺序\n    int maxSize;\n    LinkedList<Integer>list2=new LinkedList<>();\n\n    public   LRUCache(int capacity) {\n        doubleList=new DoubleList();\n        maxSize=capacity;\n    }\n    public  void print(){\n        System.out.print(\"maplen:\"+map.keySet().size()+\" \");\n        for(Integer in:map.keySet()){\n            System.out.print(\"key:\"+in+\" val:\"+map.get(in).value+\" \");\n        }\n        System.out.print(\"              \");\n        System.out.println(\"listLen:\"+doubleList.length+\" \"+doubleList.toString()+\" maxSize:\"+maxSize);\n    }\n\n    public int get(int key) {\n        int val;\n        if(!map.containsKey(key))\n            return  -1;\n        val=map.get(key).value;\n        Node team=map.get(key);\n        doubleList.deleteNode(team);\n        doubleList.add(team);\n        return  val;\n    }\n\n    public void put(int key, int value) {\n        if(map.containsKey(key)){// 已经有这个key 不考虑长短直接删除然后更新\n           Node deleteNode=map.get(key);\n            doubleList.deleteNode(deleteNode);\n        }\n        else if(doubleList.length==maxSize){//不包含并且长度小于\n            Node first=doubleList.head.next;\n            map.remove(first.key);\n            doubleList.deleteFirst();\n        }\n       Node node=new Node(key,value);\n        doubleList.add(node);\n        map.put(key,node);\n\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922745","body":"## code\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  /**\n   * 大数相加，先将两个数反转\n   */\n  let numAStr = num.reverse();\n  let numBStr = k.toString().split('').reverse();\n  let temp = 0;\n  let result = [];\n  for (let i = 0; i < Math.max(numAStr.length, numBStr.length); i++) {\n    if (!numAStr[i]) {\n      numAStr[i] = 0;\n    }\n    if (!numBStr[i]) {\n      numBStr[i] = 0;\n    }\n    result[i] = numAStr[i] + +numBStr[i] + temp;\n    if (result[i] > 9) {\n      result[i] -= 10;\n      temp = 1;\n    } else{\n        temp = 0;\n    }\n  }\n  if (temp === 1) {\n    result.push(temp);\n  }\n  return result.reverse();\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992062594","body":"## 思路\n官方题解的思路二：空间换时间，实际上就是暴力，没有什么技术思想，但也是最容易想到的\n\n## code\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const sArr = s.split('');\n    const keyArr = [];\n    const ans = [];\n    for (let i = 0; i < sArr.length; i++) {\n        const ele = sArr[i];\n        if(ele === c){\n            keyArr.push(i);\n        }\n    }\n    for (let i = 0; i < sArr.length; i++) {\n        const ele = sArr[i];\n        let minLen = sArr.length;\n        for (let j = 0; j < keyArr.length; j++) {\n            const keyEle = keyArr[j];\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\n        }\n        ans.push(minLen);\n    }\n    return ans;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993626180","body":"## 思路\n首先想到直觉法，但其实是有优化空间的。其实本身不难。\n\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n     this.stack = [];\n     this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.pop() || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length && i < k; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994926933","body":"## code\n```js\nvar decodeString = function(s) {\n    const numStack = [];\n    const strStack = [];\n    let repeatTimes = '';\n    for (let i = 0; i< s.length; i++) {\n      const char = s[i];\n      if(!Number.isNaN(+char)){\n          repeatTimes += char;\n          continue;\n      }\n      if(repeatTimes){\n        numStack.push(+repeatTimes);\n        repeatTimes = '';\n      }\n      if(char === ']'){\n          let repeatStr = '';\n          while(strStack.length && strStack.slice(-1)[0]!=='['){\n            let a = strStack.slice(-1);\n            repeatStr = strStack.pop() + repeatStr;\n          }\n          strStack.pop();\n          strStack.push(repeatStr.repeat(numStack.slice(-1)));\n          numStack.pop();\n      }else{\n          strStack.push(char);\n      }\n    }\n    return strStack.join('');\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995491747","body":"## 思路\n双栈，感觉写的麻烦了\n\n## code\n```js\n\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    \n    while(this.outStack.length){\n        this.inStack.push(this.outStack.pop());\n    }\n    this.inStack.push(x)\n    \n    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.outStack.length){\n        return this.outStack.pop();\n    }else{\n        while(this.inStack.length){\n            this.outStack.push(this.inStack.pop());\n        }\n        return this.outStack.pop();\n    }\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.inStack.length){\n        this.outStack.push(this.inStack.pop());\n    }\n    return this.outStack[this.outStack.length-1]\n\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996813162","body":"## code\n```js\nvar maxChunksToSorted = function(arr) {\n    let sorted = arr.slice().sort((a, b) => a - b);\n    let indexs = [];\n    for (let i = 0; i < sorted.length; i++) {\n        let c = arr.indexOf(sorted[i]);\n        arr[c] = null;\n        indexs.push(c);\n    };\n\n    let max = -1, num = 0;\n    for (let i = 0; i < indexs.length; i++) {\n        max = Math.max(max, indexs[i]);\n        if (max === i) num++;\n    };\n\n    return num;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997132800","body":"## 思路\r\n感觉写的不是很好，两次遍历，第一次先算出长度（方便后期截断），同时为了尾部续接第一个。第二次是为了截断\r\n\r\n## code\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    let length = 1;\r\n    let cur = head;\r\n    if(cur === null) return null\r\n    while(cur.next){\r\n        length ++;\r\n        cur = cur.next; \r\n    }\r\n    cur.next = head; // 尾部续接\r\n    let node = {\r\n        val:head.val,\r\n        next:null,\r\n    }\r\n    let cur2 = head;\r\n    for(let i = 0;i<length-(k%length)-1;i++){\r\n        cur2 = cur2.next;\r\n    } \r\n    node.val = cur2.next.val;\r\n    node.next = cur2.next;\r\n    cur2.next = null;\r\n    \r\n    // head.val = node.val;\r\n    // head.next = node.next;\r\n    return node.next;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997404933","body":"## code\n```js\nvar swapPairs = function (head) {\n  let ret = new ListNode(0, head), temp = ret;\n  while (temp.next && temp.next.next) {\n    let cur = temp.next.next, pre = temp.next;\n    pre.next = cur.next;\n    cur.next = pre;\n    temp.next = cur;\n    temp = pre;\n  }\n  return ret.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997693753","body":"## 思路\n递归，还不是太熟\n\n## code\n```js\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998401276","body":"## 思路\n暴力，我太菜了，不说了，看讲义去了\n## Code\n```js\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) {\n        return null\n    }\n    let A = headA;\n    let B = headB;\n    while(A){\n        while(B){\n            if(A === B){\n                return B;\n            }else{\n                B = B.next;\n            }\n        }\n        A = A.next;\n        B = headB;\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999654694","body":"## 思路\n使用 Set 存取不重复节点\n## code\n```js\n var detectCycle = function(head) {\n     if (!head || !head.next) {\n         return null;\n     }\n     let node = head;\n     const nodeSet = new Set();\n     while (node) {\n        if (nodeSet.has(node)) {\n            return node;\n        }else{\n            nodeSet.add(node);\n            node = node.next;\n        }\n     }\n     return null;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000024692","body":"## 思路\n自己写的超时了。。抄的漾姐的\n\n## code\n```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000881896","body":"## 思路\n我怎么么想到呢\n\n## code\n```js\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nvar maxDepth = function (root) {\nreturn root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n  \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001022282","body":"## code\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(p == null || q == null){\n        return p == null && q == null;\n    }\n    return p.val !== q.val ? false : isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993086458","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack) > 0:\n            top = self.stack[-1]\n            self.stack.pop()\n            return top \n        else:\n            return -1 \n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(len(self.stack)):\n            if i == k:\n                return \n            self.stack[i] += val \n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995373663","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        top = self.stack1[0]\n        for i in range(1, len(self.stack1)):\n            self.stack2.append(self.stack1[i])\n        self.stack1 = self.stack2\n        self.stack2 = []\n        return top\n\n    def peek(self) -> int:\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        if len(self.stack1) == 0:\n            return True \n        return False\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999235173","body":"```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return None \n        node = self.isHasCycle(head)\n        if node is None:\n            return None \n        count = 1 \n        fast = node.next\n        while fast != node:\n            fast = fast.next\n            count += 1 \n        fast, slow = head, head\n        while count:\n            fast = fast.next\n            count -= 1 \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return fast\n    \n    def isHasCycle(self, head):\n        if not head:\n            return None \n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                return fast\n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"domorecode":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junqu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruce-young233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834504","body":"## 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        \n        vector<int> num2 = splitToArray(k);\n        \n        num = addTwoArrays(num, num2);\n        \n        reverse(num.begin(), num.end());\n        return num;\n    }\nprivate:\n    vector<int> splitToArray(int k) {\n        if (k < 0 || k > 10000) {\n            cout << \"invalid input\" << endl;\n            return {};\n        }\n        vector<int> res = {};\n        while (k) {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n    \n    vector<int> addTwoArrays(vector<int>num1, vector<int>num2) {\n        int sz1 = num1.size();\n        int sz2 = num2.size();\n        int n = 0;\n        int carry = 0;\n        while (n < sz1 && n < sz2) {\n            int sum = num1[n] + num2[n] + carry;\n            carry = sum / 10;\n            num1[n++] = sum % 10;\n        }\n        while (n < sz1) {\n            int sum = num1[n] + carry;\n            carry = sum / 10;\n            num1[n++] = sum % 10;\n        }\n        while (n < sz2) {\n            int sum = num2[n++] + carry;\n            carry = sum / 10;\n            num1.push_back(sum % 10);\n        }\n        if (carry) {\n            num1.push_back(carry);\n        }\n        return num1;\n    }\n};\n```\n\n## 复杂度\n时间 O(n)\n空间 O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995352564","body":"```cpp\nclass MyQueue {\nprivate:\n    stack<int> inStack, outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {}\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();\n        outStack.pop();\n        return x;\n    }\n\n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999242832","body":"## 代码\n```js\nvar detectCycle = function(head) {\n    if (head === null) {\n        return null;\n    }\n    let slow = head, fast = head;\n    while (fast !== null) {\n        slow = slow.next;\n        if (fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            return null;\n        }\n        if (fast === slow) {\n            fast = head;\n            while (fast !== slow) {\n                fast = fast.next;\n                slow = slow.next;\n            }\n            return fast;\n        }\n    }\n    return null;\n};\n```\n## 复杂度\n时间 O(n)\n\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daxiadaxia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"draculabo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ankidord":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993647546","body":"## 思路\r\n> + 使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n## 复杂度\r\n> + 空间: O(1)\r\n> + 时间: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923243","body":"## 思路\r\n+ > 栈\r\n## 代码\r\n+ > \r\n```python\r\ndef decodeString(self, s: str) -> str:\r\n        # time O(N)  space O(N)\r\n        stack=[]\r\n        i=0\r\n        while i<len(s):\r\n            if s[i]==\"]\":\r\n                repeated_str=''\r\n                repeated_num=''\r\n                while stack and stack[-1]!='[':\r\n                    repeated_str = stack.pop()+repeated_str  \r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeated_num=stack.pop()+repeated_num\r\n                stack.append(int(repeated_num)*repeated_str)\r\n            else:\r\n                stack.append(s[i])\r\n            i+=1\r\n        return ''.join(stack)\r\n```\r\n## 复杂度\r\n+ > 时间:O(n)\r\n+ > 空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995949762","body":"## 思路\r\n+ > 栈\r\n## 代码\r\n+ > \r\n```golang\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n```\r\n## 复杂度\r\n+ > 时间:O(1)\r\n+ > 空间:O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999538440","body":"## 思路\r\n+ > 双指针\r\n## 代码\r\n```golang\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\tif head == nil {\r\n\t\treturn nil\r\n\t}\r\n\tfast := head\r\n\tslow := head\r\n\tfor fast.Next != nil && fast.Next.Next != nil {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t\tif fast == slow {\r\n\t\t\tfor head != slow {\r\n\t\t\t\thead = head.Next\r\n\t\t\t\tslow = slow.Next\r\n\t\t\t}\r\n\t\t\treturn head\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n```\r\n## 复杂度\r\n+ > 时间:O(N)\r\n+ > 空间:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alanwgy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potato121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baijian1990":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-mx-wq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"corki418":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lovemyse1f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuroky-chen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachen-guo":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918651","body":"加法问题，重点在于进位的处理。使用carry位储存。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> tmp = new LinkedList<>();\n        int n = num.length;\n        int i = n - 1, sum = 0, carry = 0;\n        while(i >= 0 || k!=0){\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            tmp.addFirst(sum % 10);\n            i--;\n        }\n        if(carry!=0) tmp.addFirst(carry);\n        List<Integer> res = new ArrayList<>(tmp);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992204581","body":"方法1：遍历找到左右指针，向中间扩散，时间复杂度O(N)。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int left = -1;\n        int right = -1;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == c){\n                right = i;\n                int distance = 0;\n                if(left != -1){\n                    int start = left;\n                    int end = right;\n                    while(start <= end){\n                        res[start++] = distance;\n                        res[end--] = distance;\n                        distance++;\n                    }\n                } else{\n                    int end = right;\n                    while(end >= 0){\n                        res[end--] = distance++;\n                    }\n                }\n                left = i;\n            }\n        }\n        if(right!=s.length()-1){\n            int start = right;\n            int distance = 0;\n            while(start < s.length()){\n                res[start++] = distance++;\n            }\n        }\n        return res;\n    }\n}\n```\n方法2：仅供参考，时间复杂度较高（O(N^2)）\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        Map<Character,List<Integer>> map = new HashMap<>();\n        char[] charArr = s.toCharArray();\n        for(int i = 0; i < charArr.length; i++){\n            if(map.containsKey(charArr[i])){\n                map.get(charArr[i]).add(i);\n            } else{\n                List<Integer> list = new ArrayList<>();\n                list.add(i);\n                map.put(charArr[i],list);\n            }\n        }\n        int[] res = new int[charArr.length];\n        List<Integer> tmp = map.get(c);\n        for(int i = 0; i < charArr.length; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j = 0; j < tmp.size(); j++){\n                int val = Math.abs(tmp.get(j) - i);\n                min = min < val?min:val;\n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993627837","body":"利用数组作为base， 时间复杂度O(N)\n``` java\nclass CustomStack {\n    private int[] data;\n    private int head = -1;\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(head + 1 < data.length){\n            data[++head] = x;\n        }\n    }\n    \n    public int pop() {\n        if(head == -1) return -1;\n        else{\n            int pop = data[head];\n            data[head--]=0;\n            return pop;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int bound = Math.min(k,head+1);\n        for(int i = 0; i < bound; i++){\n            data[i]+=val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994924373","body":"时间复杂度O(N) N为字符串的长度\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995608320","body":"题目要点：采用两个栈实现push操作\n```java\nclass MyQueue {\n    private Stack<Integer> a;\n    private Stack<Integer> b;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        a.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996430681","body":"解题思路：采用栈作为基础数据结构，并通过arr的遍历来维护栈的单调性。\n\nobservation1: 对于单调数组，可以拆分的最多完成排序的块=数组size => return stack.size();\n\nobservation2: 入栈条件，大于数组的最大值 => 在每次pop数组、维护单调栈的过程中保留最大值，并在完成维护后入栈， stack.push(max)。\n\n时间复杂度：O(N)\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(arr[0]);\n        for(int i = 1; i < arr.length; i++){\n            int tmp = stack.peek();\n            if(arr[i] >= tmp){\n                stack.push(arr[i]);\n            } else{\n                while(arr[i] < stack.peek()){\n                    stack.pop();\n                    if(stack.isEmpty()){\n                        break;\n                    }\n                }\n                stack.push(tmp);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997152217","body":"思路：将linkedlist转化为list，在list中进行+step%mod操作，并且重建链表\n\n时间复杂度：O(N)\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int count = 0;\n        ListNode node = head;\n        if(head == null) return null;\n        while(node != null){\n            node = node.next;\n            count++;\n        }\n        int[] list = new int[count];\n        int idx = 0;\n        ListNode ptr = head;\n        for(int i = 0; i < count; i++){\n            list[i] = ptr.val;\n            ptr = ptr.next;\n        }\n        int[] tmp = new int[count];\n        for(int j = 0; j < count; j++){\n            int finalInd = (j+k) % count;\n            tmp[finalInd] = list[j];\n        }\n        ListNode headNew = new ListNode(tmp[0]);\n        ListNode iterNode = headNew;\n        int iter = 1;\n        while(iterNode != null && iter < count){\n            iterNode.next = new ListNode(tmp[iter]);\n            iter++;\n            iterNode = iterNode.next;\n        }\n        return headNew;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997293420","body":"采用递归的方式，时间复杂度O(N)\n\nbase case: 只有一个节点/节点是null，return node itself\n\nrecursive case: head节点接上递归的结果（recur(head.next.next)）head.next接上head 实现反转\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        return swapPairRec(head);\n    }\n\n    private ListNode swapPairRec(ListNode node){\n        if(node == null || node.next == null) return node;\n        ListNode nodeNext = node.next;\n        node.next = swapPairRec(node.next.next);\n        nodeNext.next = node;\n        return nodeNext;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997592995","body":"采用分而治之的思想，以及递归、双指针的方法。\n\n双指针：快慢指针，找出链表中间节点的前一个节点，作为断开处，前后分而治之。premid.next为中间节点即根节点。\n\n时间复杂度O(nlogn)\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        ListNode preMid = findPreMid(head);\n        ListNode mid = preMid.next;\n        TreeNode root = new TreeNode(mid.val);\n        preMid.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(mid.next); \n        return root;\n    }\n    private ListNode findPreMid(ListNode head){\n        ListNode pre, slow, fast;\n        pre = head;\n        slow = head;\n        fast = head.next;\n        while(fast != null && fast.next != null){\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return pre;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998233901","body":"思路：通过A1+A2(B2)+B1 = B1 + B2(A2) + A1 的方式对齐两个链表，直到两个指针相等时停下，如果返回值不为空，则说明找到了交点，如果为空，则说明无交点并返回null\n\n时间复杂度：O(N)\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode aPointer = headA;\n        ListNode bPointer = headB;\n        if(headA == null) return headB;\n        if(headB == null) return headA;\n        while(aPointer != bPointer){\n            aPointer = aPointer == null? headB:aPointer.next;\n            bPointer = bPointer == null? headA:bPointer.next;\n        }\n        return aPointer;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999340213","body":"### 思路\n\n![思路如图](https://s2.loli.net/2021/12/22/MeKHUOfs16vbtWa.png)\n\n### 复杂度分析\n时间复杂度：O(N)，空间复杂度：O(1)\n\n### 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                fast = head;\n                while(fast != slow){\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000370625","body":"### 思路\n使用双向链表+hashMap，实现O(1)复杂度下快速查找 -> hashMap；O(1)复杂度下使用头增 & 键值对有一定的顺序 -> linkedlist；O(1) 复杂度下的删除操作 -> double linkedlist。\n```java\nclass LRUCache {\n    HashMap<Integer,Node> map;\n    DoubleLinkedList cache;\n    int cap;\n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        cache = new DoubleLinkedList();\n        cap = capacity;\n    }\n    // get key and put it at the first pos;\n    public int get(int key) {\n        if(!map.containsKey(key)) return -1;\n        int val = map.get(key).value;\n        put(key,val);\n        return val;\n    }\n    \n    public void put(int key, int value) {\n        Node newNode = new Node(key,value);\n        if(map.containsKey(key)){ // put the selected node to the first pos or update the key\n            cache.delete(map.get(key)); // delete the original pos\n            cache.addFirst(newNode); // put the new-added one the the first pos\n            map.put(key,newNode); // update the map\n        } else{\n            if(map.size() == cap){\n                int k = cache.deleteLast();\n                map.remove(k);\n            }\n            cache.addFirst(newNode);\n            map.put(key,newNode);\n        }\n    }\n}\n\nclass DoubleLinkedList{\n    Node head;\n    Node tail;\n    DoubleLinkedList(){\n        head = new Node(0,0);\n        tail = new Node(0,0);\n        head.next = tail;\n        tail.prev = head;\n    }\n    void addFirst(Node node){\n        node.next = head.next;\n        node.prev = head;\n        \n        head.next.prev = node;\n        head.next = node;\n    }\n\n    int deleteLast(){\n       if(head.next == tail) return -1;\n       return delete(tail.prev); \n    }\n\n    int delete(Node node){\n        int key = node.key;\n        node.next.prev = node.prev;\n        node.prev.next = node.next;\n        return key;\n    }\n}\n\nclass Node{\n    int key;\n    int value;\n    Node prev;\n    Node next;\n    Node(int key, int value){\n        this.key = key;\n        this.value = value;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000956482","body":"### 思路\nrecursion, 有着相同的根节点&相同的左子树&相同的右子树 =》 树是相同的\n\nnotes: 必须前序&中序，中序&后序，两种遍历方式都得到相同的数组，才能确定两树相同\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001073414","body":"### 思路\n深度优先搜索，将上一层所得到的结果进位（presum*10）并和当前node的值相加\n``` java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return sumRec(root,0);\n    }\n\n    private int sumRec(TreeNode node, int preSum){\n        if(node == null) return 0;\n        int sum = 10*preSum + node.val;\n        if(node.left == null && node.right == null){\n            return sum;\n        } \n        return sumRec(node.left,sum)+sumRec(node.right,sum);\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zt4188":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jachinm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gemzq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"harrypangpang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheusername":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nina1031":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brandylulu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"clarence5":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991903023","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n复杂度：数组长度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"musicofwind":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baiqr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winperrr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiangydeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuchenwuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"craig-cheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crazy-xjm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandacure":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanrufu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"husky-gong":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991805344","body":"# 解题思路\r\n - 遍历整个array，求出array的值\r\n - 将array求出的数字和给的数字相加\r\n - 将数字转化为array\r\n\r\n# 代码\r\n```\r\nprivate static int[] arrayAddInteger (int[] A, int k) {\r\n        int temp = 0;\r\n        int idx = 0;\r\n\r\n        List<Integer> list = new ArrayList<>();\r\n\r\n        while (idx < A.length) {\r\n            temp = temp * 10 + A[idx];\r\n            idx++;\r\n        }\r\n\r\n        System.out.println(temp);\r\n\r\n        int sum = temp + k;\r\n\r\n        System.out.println(sum);\r\n\r\n        while (sum != 0) {\r\n            list.add(sum % 10);\r\n            sum /= 10;\r\n        }\r\n\r\n        // convert to array\r\n        Collections.reverse(list);\r\n\r\n        int[] result = new int[list.size()];\r\n        for (int i = 0; i < list.size() ; i++) {\r\n            result[i] = list.get(i);\r\n        }\r\n\r\n        return result;\r\n    }\r\n```\r\n\r\n# 复杂度\r\n- 时间复杂度：O(n) 需要遍历整个数组\r\n- 空间复杂度：O(n) 返回数组需要开辟N的额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991929422","body":"# 解题思路\r\n- 使用两个指针，代表一个window，左边设为left，右边设置为right\r\n- curr代表当前遍历到的S的位置\r\n- 分为三个阶段：\r\n-- 初始化：left未进入S，right为第一个e出现的位置\r\n-- 中间阶段：left和right均为S中的某一个位置\r\n-- 最后阶段：left为S中最后一个e出现的位置，right已发生越界\r\n- 需要注意：\r\n-- 每次curr扫描到一个C，代表其已到达window的右边界，则需要将左边界设置为C当前位置，并且重新设定右边界\r\n-- 更新距离时，需要使用Math.min(Math.abs(curr - left), Math.abs(curr - right))求出最小值gap，设置到结果位置result[curr] = gap\r\n-- 不能设置为Integer.MIN_VALUE 和Intger.MAX_VALUE，因为会发生越界\r\n# 代码\r\n```\r\npublic static int[] minGap(String S, Character C) {\r\n        // set window [left, right] range\r\n        int left = -S.length();\r\n        int right = 0;\r\n\r\n        // initialize right first\r\n        while (right < S.length() && S.charAt(right) != C) {\r\n            right++;\r\n        }\r\n\r\n        // curr -> current position\r\n        int curr = 0;\r\n        int[] distance = new int[S.length()];\r\n\r\n        while (curr < S.length() && right < S.length()) {\r\n            if (S.charAt(curr) == C) {\r\n                distance[curr] = 0;\r\n                // it means curr has reached to the right edge of the window\r\n                // then have to update the left, right for a new window\r\n                left = curr;\r\n                while (left == right || (right < S.length() && S.charAt(right) != C)) {\r\n                    right++;\r\n                    // if right is out of S, then set it as Integer.MAX_VALUE\r\n                    if (right == S.length()) {\r\n                        right = 2 * S.length();\r\n                    }\r\n                }\r\n            } else {\r\n                // between current window\r\n                // update gaps for Characters in this window\r\n                int gap = Math.min(Math.abs(curr - left), Math.abs(right - curr));\r\n                distance[curr] = gap;\r\n            }\r\n            curr++;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n```\r\n# 复杂度\r\n时间复杂度：O(n) 从左到右，只遍历一遍\r\n空间复杂度：O(n) 需要开辟新的空间，存储结果\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992897084","body":"# 思路\r\n1. 使用ArrayList模拟实现\r\n2. 构造函数：初始化ArrayList和maxSize\r\n3. push：如果list.size()<maxSize，才向其中添加数字；否则，返回。\r\n4. pop：判断list中是否有函数，有的话返回，并remove掉当前数字。否则，返回-1\r\n5. increment：【bottom】代表从list的0开始计算的k个元素进行加val\r\n\r\n# 代码\r\n```\r\nclass CustomStack {\r\n    List<Integer> list;\r\n    int maxSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        list = new ArrayList<>();\r\n        this.maxSize = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (maxSize > list.size()) {\r\n            list.add(x);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (list.size() > 0) {\r\n            int result = list.get(list.size() - 1);\r\n            list.remove(list.size() - 1);\r\n            return result;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        // bottom is start from 0\r\n        int cur = 0;\r\n        \r\n        while (cur <= list.size() - 1 && k > 0) {\r\n            int newVal = list.get(cur) + val;\r\n            list.set(cur, newVal);\r\n            cur++;\r\n            k--;\r\n        }\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度：O(n) 因为有increment操作，可能需要遍历所有数\r\n空间复杂度：O(n) 构造了新的数据结构用于存放数字\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994144198","body":"# How:\r\n1. Regard every [] as a **new level** -> use DFS\r\n2. Use an **global** index i to iterate input string\r\n3. In DFS, 4 cases:\r\n-- '[' go to another level and combine returned string\r\n-- ']' break current level and return\r\n-- alphabetic: append to current level string\r\n-- number: get number before '['\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    int i = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        int count = 0;\r\n        String nextLevel = \"\";\r\n        \r\n        while (i < s.length()) {\r\n            char ch = s.charAt(i);\r\n            i++;\r\n            \r\n            if (ch == '[') {\r\n                nextLevel = decodeString(s);\r\n                while (count > 0) {\r\n                    sb.append(nextLevel);\r\n                    count--;\r\n                }\r\n                \r\n            } else if(ch == ']') {\r\n                break;\r\n            } else if (Character.isAlphabetic(ch)) {\r\n                sb.append(ch);\r\n            } else {\r\n                count = count * 10 + ch - '0';\r\n            }\r\n        }\r\n        \r\n        return sb.toString();\r\n        \r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime Complexity: O(n) loop char in the string only once\r\nSpace Complexity: O(n) recursion\r\n# Note:\r\n1. Should pay attention to input, what is **valid input**\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995185363","body":"# Note\r\n1. When push a new element (we need to add it to the bottom of S1 stack)\r\n-- make S1 result stake reverse -> push to S2 stack\r\n-- add new element to S2 top\r\n-- push back to S1 -> make the new element to the bottom of previous elements\r\n\r\n# Code\r\n``` java\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        // use s1 to record final result\r\n        if (s1.isEmpty()) {\r\n            s1.push(x);\r\n        } else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n            \r\n            s2.push(x);\r\n            \r\n            while (!s2.isEmpty()) {\r\n                s1.push(s2.pop());\r\n            }\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return s1.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        return s1.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\n\r\n# Complexity\r\nTime Complexity: \r\npush: O(n)\r\npop: O(1)\r\npeek: O(1)\r\nempty: O(1)\r\n\r\nSpace Complexity:\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996441849","body":"# Note\r\nUse 2 array to record the maximum/minimum value from left and right accordingly\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // use 2 array to record the maximum/minimum value from left and right accordingly\r\n        int[] leftMax = new int[arr.length];\r\n        int[] rightMin = new int[arr.length];\r\n        \r\n        int tempMax = Integer.MIN_VALUE;\r\n        int tempMin = Integer.MAX_VALUE;\r\n        \r\n        for (int i = 0; i < arr.length; i++) {\r\n            tempMax = Math.max(arr[i], tempMax);\r\n            leftMax[i] = tempMax;\r\n        }\r\n        \r\n        for (int i = arr.length-1; i >= 0; i--) {\r\n            tempMin = Math.min(arr[i], tempMin);\r\n            rightMin[i] = tempMin;\r\n        }\r\n        \r\n        int result = 1;\r\n        \r\n        for (int i = 0; i < arr.length - 1; i++) {\r\n            if (leftMax[i] > rightMin[i+1]) {\r\n                continue;\r\n            } else {\r\n                result++;\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997144998","body":"# Note\r\n1. get new head\r\n2. set tail.next = null\r\n3. connect 2 parts\r\n4. k = 0 and input is null\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        \r\n        int size = 0;\r\n        // get size\r\n        ListNode sizeCurr = head;\r\n        while (sizeCurr != null) {\r\n            sizeCurr = sizeCurr.next;\r\n            size++;\r\n        }\r\n        \r\n        // get newhead\r\n        ListNode temp = head;\r\n        ListNode newTail = head;\r\n        \r\n        k = k % size;\r\n        \r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n        \r\n        \r\n        while (k > 0) {\r\n            k--;\r\n            temp = temp.next;\r\n        }\r\n        \r\n        while (temp.next != null) {\r\n            temp = temp.next;\r\n            newTail = newTail.next;\r\n        }\r\n        \r\n        ListNode newHead = newTail.next;\r\n        newTail.next = null;\r\n        \r\n        //connect 2 parts\r\n        temp.next = head;\r\n        \r\n        return newHead;\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime Complexity: O(n)\r\nSpace Complexti: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997325160","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode prev = new ListNode(0);\r\n        prev.next = head;\r\n        ListNode dummy = prev;\r\n        \r\n        // node交换的时候一定要按照顺序来\r\n        while(prev.next != null && head.next != null) {\r\n            ListNode newHead = head.next.next;\r\n            prev.next = head.next;\r\n            head.next.next = head;\r\n            head.next= newHead;\r\n            prev = head;\r\n            head = newHead;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997536776","body":"#Node\r\n1. Use recursion to get left and right part, until it gets the minimum case\r\n2. minimum case: head == null || head.next == null\r\n3. get mid and left part and right part\r\n4. set left part as mid.left, set right as mid.right\r\n5. return root\r\n\r\n#Code\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // minimum case\r\n        if (head == null){\r\n            return null;\r\n        }\r\n        \r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n        \r\n        // get mid and left part and right part\r\n        ListNode mid = getMid(head);\r\n        ListNode treeRoot =  mid.next;\r\n        ListNode rightPart = treeRoot.next;\r\n        ListNode leftPart = head;\r\n        mid.next = null;\r\n        \r\n        TreeNode root = new TreeNode(treeRoot.val);\r\n        root.left = sortedListToBST(leftPart);\r\n        root.right = sortedListToBST(rightPart);\r\n        \r\n        return root;\r\n    }\r\n    \r\n    private ListNode getMid(ListNode head) {\r\n        ListNode slow = new ListNode(0);\r\n        ListNode fast = new ListNode(0);\r\n        \r\n        slow.next = head;\r\n        fast.next = head;\r\n        \r\n        while (fast.next != null && fast.next.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n}\r\n```\r\n# complexity\r\nTime Complexity: O(nlogn) -> divide\r\nSpace Comlexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998384982","body":"# Solution\r\n1. If it gets to the tail of one list, then start from the other one\r\n2. If no intersection between these 2 lists, A and B will get null, then break while loop\r\n\r\n# Code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode curA = headA, curB = headB;\r\n        \r\n        while (curA != curB) {\r\n            curA = curA == null? headB : curA.next;\r\n            curB = curB == null? headA : curB.next;\r\n        }\r\n        \r\n        return curA;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime Complexity: O(n)\r\nSpace Comlexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999219022","body":"# Solution\r\n1. Use fast and slow node to find where they meet - if fast.next == null || fast.next.next == null, it means no meet. Return null\r\n2. get the meet node, use a curr node starts from head. Move curr and meet step by step, once they meet, the node is the return one.\r\n\r\n# Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return null;\r\n        }\r\n        \r\n        ListNode fast = head, slow = head;\r\n        \r\n        ListNode meet = null;\r\n        \r\n        while (meet == null && fast.next != null && fast.next.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            \r\n            if (fast == slow) {\r\n                meet = slow;\r\n            }\r\n        }\r\n        \r\n        if (meet == null) {\r\n            return null;\r\n        }\r\n        \r\n        ListNode curr = head;\r\n        while (curr != meet) {\r\n            curr = curr.next;\r\n            meet = meet.next;\r\n        }\r\n        \r\n        return meet;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime Complexity: O(n)\r\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999977908","body":"```java\r\nclass LRUCache {\r\n    // 思路：\r\n    // 1. get() 的时间复杂度为O(1)，使用map；put的时间复杂度为O(1)也使用map。\r\n    //    但是，因为要将最常使用的放在最前面，则需要考虑到一个排序的过程  \r\n    //        -> 使用linkedlist \r\n    //        -> 当capacity放满了，并且有新的放入，则将尾部的去掉\r\n    //    所以，要使用linkedlist和hashmap\r\n    //    get的时候，如果map存在该key，取出对应的val返回，并且需要把它放在linkedlist的头部\r\n    //        -> 所以，需要创建两个方程：addHead(Node)：将node放在头部，表示最近用过\r\n    //                               remove(Node)：将放在头部的node去除掉\r\n    // 2. put(int key, int value)的时间复杂度为O1\r\n    //        -> 1. 如果node存在，则将node重新放在linkedlist的头部\r\n    //              -> 首先取出node，再remove，再addHead\r\n    //        -> 2. 如果node不存在，则将node直接放在linkedlist头部\r\n    \r\n    class Node {\r\n        int key;\r\n        int val;\r\n        Node prev;\r\n        Node next;\r\n        \r\n        public Node (int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n    }\r\n\r\n    Node head;\r\n    Node tail;\r\n    int capacity;\r\n    int size;\r\n    \r\n    HashMap<Integer, Node> map;\r\n    \r\n    public LRUCache(int capacity) {\r\n        // 初始化linkedlist和hashmap\r\n        map = new HashMap<>();\r\n        head = new Node(0, 0);\r\n        tail = new Node(0, 0);\r\n        \r\n        head.next = tail;\r\n        tail.prev = head;\r\n        \r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    // get的时候，从map中拿，然后放在linkedlist最前面\r\n    public int get(int key) {\r\n        if (map.containsKey(key)) {\r\n            Node temp = map.get(key);\r\n            remove(temp);\r\n            addHead(key, temp.val);\r\n            return temp.val;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    // 从linkedlist中取出掉一个node\r\n    private void remove(Node node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        size--;\r\n        // 从map中删除\r\n        map.remove(node.key);\r\n    }\r\n    \r\n    // 加入到头结点，再判断是否超出capacity\r\n    private void addHead(int key, int val) {\r\n        Node temp = new Node(key, val);\r\n        Node next = head.next;\r\n        temp.next = next;\r\n        next.prev = temp;\r\n        head.next = temp;\r\n        temp.prev = head;\r\n        \r\n        map.put(key, temp);\r\n        size++;\r\n        \r\n        if (size > capacity) {\r\n            Node temp2 = tail.prev;\r\n            remove(temp2);\r\n        }\r\n        \r\n    }\r\n    \r\n    // 判断map中是否存在该node，如果不存在直接放在linkedlist最前面\r\n    // 如果存在该node，就取出来，再remove，再放在最前面\r\n    public void put(int key, int value) {\r\n        if (map.containsKey(key)) {\r\n            Node temp = map.get(key);\r\n            remove(temp);\r\n            addHead(key, value);\r\n        } else {\r\n            addHead(key, value);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000504176","body":"# Solution\r\n1. Use recursion to get level value from root's left and right accordingly\r\n2. compare left and right value, choose the maximum vale as depth\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        \r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n        \r\n        return Math.max(left, right) + 1;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime Complexity : O(N)\r\nSpace Complexity : O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000917660","body":"# Solution\r\n1. check whether the root is same\r\n2. check their children -> left and right accordingly\r\n3. return boolean\r\n\r\n# Code\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        \r\n        // only one is null\r\n        if (p == null || q == null) {\r\n            return false;\r\n        }\r\n        \r\n        // if value is not same\r\n        if (p.val != q.val) {\r\n            return false;\r\n        }\r\n        \r\n        // check children\r\n        boolean left = isSameTree(p.left, q.left);\r\n        \r\n        boolean right = isSameTree(p.right, q.right);\r\n        \r\n        return left && right;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001081985","body":"# Code\r\n```java\r\nclass Solution {\r\n    int result = 0;\r\n    int curr = 0;\r\n    public int sumNumbers(TreeNode root) {\r\n        if (root == null) {\r\n            return result;\r\n        }\r\n        \r\n        curr = curr * 10 + root.val;\r\n        \r\n        if (root.left == null && root.right == null) {\r\n            result += curr;\r\n        } else {\r\n            sumNumbers(root.left);\r\n            if (root.left != null) {\r\n                curr /= 10;\r\n            }\r\n            sumNumbers(root.right);\r\n            if (root.right != null) {\r\n                curr /= 10;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(N)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996427410","body":"思路：\r\n大概使用stack是想到的， 具体的先局部再整体容我琢磨琢磨\r\n\r\n```\r\ndefmaxChunksToSorted(self, arr: List[int]) ->int:\r\n        if not arr \r\n          return0;\r\n    \r\n    st = [];\r\n    st.append(arr[0]);\r\n    for(inti=1;i<len(arr)i++){\r\n        \r\n        if(arr[i]>=st[-1]){\r\n            st.append(arr[i]);\r\n            continue;\r\n        }\r\n        inttemp = st[-1];\r\n        while(st && arr[i] < st[-1]_\r\n            st.pop();\r\n        \r\n        st.append(temp); \r\n    }\r\n    return len(st)\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiabin123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991742873","body":"## Idea\n1. Use a carry variable to record previous sum's tenth value\nWhile loop (if num is not empty or k larger than zero or carry larger than zero): \n2. Pop num array's last element as variable LAST. If empty num, LAST = 0\n3. Append the ones digit of the summation to the ans array left side\n4. Update the carry to the summation's tens digit\n\n## Code:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        ans = collections.deque()\n        while num or k>0 or carry > 0:\n            last = num.pop() if num else 0\n            cur = (carry + last + k%10)%10\n            carry = (carry + last + k%10)//10\n            k = k//10\n            ans.appendleft(cur)\n        return ans\n```\n\n## Complexity:\nTime: O(max(N, log_10(K)). N is the length of num array. Since we divide K by 10 every loop till K is zero, the complexity of this operation will be log base 10 of K.\nSapce: O(1). The space for carry, last is O(1). The space for the ans is O(max(N, log_10(K)).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991976277","body":"## Idea\nArray to record position of the C. \n\n## Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        for i in range(len(s)):\n            if s[i] == c:\n                pos.append(i)\n        \n        ans = []\n        p1, p2 = math.inf, math.inf\n        if len(pos) == 1:\n            p1 = 0\n        else:\n            p1 = 0\n            p2 = 1\n        for i in range(len(s)):\n            if p2 != math.inf and i > pos[p2] and p2<len(pos)-1:\n                p1 += 1\n                p2 += 1\n            if i <= pos[p1] or  p2 == math.inf:\n                ans.append(abs(pos[p1] - i))\n            else:\n                ans.append(min(abs(i - pos[p1]),abs(pos[p2] - i) ))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993041736","body":"## Idea\nArray\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.capacity = maxSize\n        self.cache = []\n\n    def push(self, x: int) -> None:\n        if len(self.cache) < self.capacity:\n            self.cache.append(x)\n\n    def pop(self) -> int:\n        if not self.cache:\n            return -1\n        return self.cache.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.cache) <= k:\n            for i in range(len(self.cache)):\n                self.cache[i] += val\n        else:\n            for i in range(k):\n                self.cache[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## Complexity:\nTine: Push: O(1). Pop: O(1). Increment: O(min(K, N))\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994191258","body":"## Idea\nStack\n\n## Code:\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack =[]\n        num = \"\"\n        string = \"\"\n        for i in s:\n            if i.isdigit():\n                if string:\n                    stack.append(string)\n                    string = \"\"\n                num += i\n                \n            elif i.isalpha():\n                if num:\n                    stack.append(int(num))\n                    num == \"\"\n                string += i\n            else:\n                if i == \"[\":\n                    if num:\n                        stack.append(int(num))\n                        num = \"\"\n                else:\n                    tmp = string\n                    string = \"\"\n                    while type(stack[-1])!=int:\n                        tmp = stack.pop()+tmp\n                    stack.append(stack.pop()*tmp)\n        ans = string\n        while stack:\n            if type(stack[-1]) != int:\n                ans = stack.pop() + ans\n            else:\n                ans *= stack.pop()\n        return ans\n```\n## Complexity:\nTime: O(maxK^countK * N). N is the max length of encoded string. count K is the amount of numbers. maxK is the largest number\nSpace: O(sum(maxK^countK *N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995302413","body":"## Idea\nStack\n## Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        tmp = self.stack[0]\n        self.stack = self.stack[1:]\n        return tmp\n\n    def peek(self) -> int:\n        return self.stack[0]\n\n    def empty(self) -> bool:\n        return len(self.stack) == 0\n```\n\n## Complexity:\nTime: push, peak, empty: O(1) pop: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996305169","body":"## Idea\nMonotonic Stack. The stack will store the largest element of each chunk.\n\n## Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            largest = i\n            while stack and stack[-1] > i:\n                largest = max(largest, stack.pop())\n            stack.append(largest)\n        return len(stack)\n```\n## Complexity:\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997112997","body":"## Idea:\nScan through the linkedlist to get its length (l) at first. Then redo the scan to get the node at l - (k%l). It's the new head. Disconnect the link between the new head and its previous node. Relink the old tail and the old head. Return the new head.\n\n## Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not k:\n            return head\n        dummy = head\n        length = 0\n        tail = None\n        while dummy:\n            length += 1\n            if not dummy.next:\n                tail = dummy\n            dummy = dummy.next\n        if k%length==0:\n            return head\n        pre, newhead = None, head\n        length -= k % length\n        while length > 0:\n            pre = newhead\n            newhead = newhead.next\n            length -= 1\n        pre.next = None\n        tail.next = head\n        return newhead\n```\n## Complexity:\nTime: O(N)\nSpace: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997321495","body":"## Idea:\nRelink the second node's next to first node, and first node's next to next second node. Need an extra pointer to record previous first node at each iteration\n\n## Code\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        new_head = head.next\n        pre_tail = None\n        while head:\n            first = head\n            second = None\n            if head.next:\n                second = head.next\n            if second:\n                first.next = second.next\n                second.next = first\n            else:\n                break\n            if pre_tail:\n                pre_tail.next = second\n            pre_tail = first\n            head = first.next\n        return new_head\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997563008","body":"## Idea:\r\nDFS. Every time find current linkedlinst's mid point, build its corresponding treenode. Then, seperate the linked list to two parts, the first part's tail is the node before the mid node. The second part's head is the node next to mid node. Current treenode's left side is built on the first part linked list. It's right side is built on the second part linked list. Recursively these steps until there is no lniked list or only one element in the linkedlist.\r\n\r\n## Code:\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        first, second = head, head\r\n        pre = None\r\n        while second and second.next:\r\n            pre = first\r\n            first = first.next\r\n            second = second.next.next\r\n        second = first.next\r\n        root = TreeNode(first.val)\r\n        pre.next = None\r\n        first = head\r\n        root.left = self.sortedListToBST(first)\r\n        root.right = self.sortedListToBST(second)\r\n        return root\r\n```\r\n\r\n## Complexity:\r\nTime: O(NlogN)\r\nSpace: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998421087","body":"## Idea:\r\nChasing poblem. Let's say linkedlist A length is l1 + l3, inkedlist B length is l2+l3, and the intersected linkedlist length is l3. We also have l2 = l1 + c. We first iterate though both linkedlist till one is at the end. Here, linkedlist A will finish first, which means, linkedlist B is c positions away from the end. We assign a pointer PB to the beginning of linkedlist B, and let linkedlist B finish the rest steps. Also keep moving PB at the same time. When linkedlist B is finished, PB has already moved c. Now, we assign another pointer PA to the beigning of linkedlist A. Currently, PA and PB are at the same steps away from the intersected point. We move PA and PB step by step till they meet. If one of them hits the tail first, which means there is not intersection. Otherwise, the intersected node will be the node they meet.\r\n\r\n## Code:\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        dummyA, dummyB, dummyC = headA, headB, None\r\n        while dummyA and dummyB:\r\n            dummyA= dummyA.next\r\n            dummyB=dummyB.next\r\n        if not dummyA:\r\n            dummyC = dummyB\r\n            dummyA = headB\r\n            dummyB = headA\r\n        else:\r\n            dummyC = dummyA\r\n            dummyA = headA\r\n            dummyB = headB\r\n        while dummyC:\r\n            dummyA = dummyA.next\r\n            dummyC = dummyC.next\r\n        while dummyA and dummyB and dummyA!=dummyB:\r\n            dummyA=dummyA.next\r\n            dummyB=dummyB.next\r\n        return dummyA if dummyA else None\r\n```\r\n## Commplexity:\r\nTime: Average: O(l1+l2+l3). l1, l3 is the length of the linkedlist not intersected part. l2 is the length of the intersected part. \r\nTime: Worst: O(m+n). There is not intersection, the worst case will be the length of linkedlist A + linkedlistB\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999200032","body":"## Idea\nTwo pointers; Fast pointer's speed is twice of the slow one until they meet or the fats one hits the tails. Let's assume it has cycle. The length of cycle is A and the length of acyclic part is B. When fast pointer meets the slow one, the slow one moves B + C and the fast one moves B + C + kA. Here, k is an int. It means the slow one still needs to move A-C to get the intersected node. We have A-C = B + kA, because B + C + kA = 2 * (B + C) which has B = kA-C and (k-1) A is the intersected point. Thus, when we reset the fast point to the head, and let the slow pointer on fast pointer continue moving step by step, they will meet at the intersected pointer.\n\n## Code:\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if not fast or not fast.next:\n            return None\n\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n            \n        return fast\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999960314","body":"## Idea\nOrdered Dictionary\n\n## Code:\n```python\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity =capacity\n        self.dict = collections.OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.dict:\n            return -1\n        self.dict.move_to_end(key)\n        return self.dict[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dict:\n            self.dict[key] = value\n            self.dict.move_to_end(key)\n        else:\n            if len(self.dict)>=self.capacity:\n                self.dict.popitem(last=False)\n            self.dict[key] = value\n```\n\n## Complexity:\nTime: O(1) to put and get\nSpace: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000563071","body":"## Idea\nDFS. In the dfs function, the termination condition is the node is null, which returns 0. If current node is not null, we get its left subtree's depth and right subtree's depth. Then return 1 + max(left, right), because we need to find the max depth of current subtree whose root is current node. It means, we need to find the larger depth of current node's left subtree and right subtree and plus that value with current node's depth 1.\n\n## Cod\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return 1 + max(left, right)\n```\n\nComplexity:\nTime: O(N). N: # of nodes\nSpace: O(N). Recursion has O(N) space in the stack ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000945252","body":"## Idea\nDFS. Preorder scan both trees and compare current node's value whether are same. If not same return False, else continue to scan subtree till none. Return true only if both trees hit none.\n\n## Code:\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n## Complexity\nTime: O(N)\nSpace: O(N). ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001077926","body":"## Idea\nDFS. Preorder scan the tree. The dfs function holds two inputs, current node and the number built by previuos step (pre). The termination condition is the node is leaf node or None. If the node is leaf node, we update pre to 10 * pre + node.val. In other conditions, we also update pre to 10 * pre + node.val and update the node to its left/right child\n\n## Code\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        def dfs(root, cur):\n            nonlocal ans\n            if not root:\n                return\n            if not root.left and not root.right:\n                ans += cur * 10 + root.val\n                return\n            cur = cur * 10 + root.val\n            dfs(root.left, cur)\n            dfs(root.right, cur)\n        dfs(root, 0)\n        return ans\n```\n\n## Complexity\nTime: O(N). dfs needs to scan all nodes\nSpace: O(H). H: the height of the tree. ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zliu1413":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ts4331":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xueniuniu98":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"louxibai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelh93":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qin-pan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xulli1996":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beckyyu96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"renxumei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liangsen-zju":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hellowxwworld":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asaoba":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiahui-z":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falsity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallatte":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzuojun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"atree716":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoguanggit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abouty":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zippend":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tjuaachen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"goddessiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyingxuhalo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lemon-hoyoung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huzizailushang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"25829365639":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liang233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neal0408":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991914566","body":"### 思路\r\n倒着 按位相加，大于 10进位。但是写的有点乱七八糟。\r\n\r\n### 代码\r\n```Python3\r\nclass Solution:\r\n\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        A = num[::-1]\r\n        B = []\r\n        # 将 k 变数组。\r\n        while k:\r\n            B.append(k % 10)\r\n            k = (k - k % 10) // 10\r\n\r\n        # A比 B 短的时候。\r\n        if len(A) < len(B):\r\n            A, B = B, A\r\n\r\n        # 把 B加到 A 中。\r\n        for i in range(len(B)):\r\n            A[i] = A[i] + B[i]\r\n\r\n        # A 中超过 10 的做进位，超过 A 长度的做列表添加。\r\n        for i in range(len(A)):\r\n            if A[i] >= 10:\r\n                if i < len(A) - 1:\r\n                    A[i + 1] = A[i + 1] + A[i] // 10\r\n                    A[i] = A[i] % 10\r\n                else:\r\n                    A.append(A[i] // 10)\r\n                    A[i] = A[i] % 10\r\n\r\n        return A[::-1]\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992553389","body":"```Python3\nclass Solution:\n\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(s):\n            if x == c:\n                prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994833206","body":"### 思路\n这道题不太会， 应该是要先找到匹配的括号然后在做运算。。但是自己写不对。。。\n### 代码\n```Python3\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)\n            else:\n                res += c\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995480197","body":"### 思路\n今天这个简单一点，终于是会写了。  一个顺序栈一个逆序栈来弥补没办法直接弹出队首的缺点。\n\n### 代码\n```python3\nclass MyQueue:\n    \n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n    \n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n        \n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```\n### 复杂度分析\n时间复杂度：push、peek O(1)。pop() O(1) 最坏 O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996747509","body":"这道题属实是不太会。。。\r\n\r\n```python3\r\n    def maxChunksTOSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n        return len(stack)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997221290","body":"### 思路\n做成环形链表 然后找到断点。断点的next 是新的头节点\n### 代码\n```Python3\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```\n### 复杂度分析\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997401363","body":"```Python3\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997954923","body":"```Python3\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998811359","body":"```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999579676","body":"```python3\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000337172","body":"```Python3\nclass LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000877086","body":"```Python\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001026779","body":"```py\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taylucky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jocelinlx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vuesch":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992583311","body":"## 参考题解的中心扩展法\n## js代码\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n// 定义最终返回结果\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    // 如果当前是目标字符，就什么都不用做\n    if (S[i] === C) continue;\n\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993664212","body":"## 思路\n没思路，作为并不是科班出身的本人来说，对前置知识**栈**和**前缀和**都不知道，先看题解了\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.max = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.max) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  var res = this.stack.pop();\n  return res == null ? -1 : res;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (var i = 0; i < this.stack.length; i++) {\n    if (i < k) {\n      this.stack[i] += val;\n    }\n  }\n};\n```\n## 复杂度分析\n- 时间复杂度：push 和 pop 操作的时间复杂度为 O(1)O(1)，increment 操作的时间复杂度为 O(min(k, cnt))O(min(k,cnt))\n\n- 空间复杂度：O(1)O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994859042","body":"## 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let len = s.length; stack = []\n  for(let i = 0; i < len; i++){\n    if(s[i] !== ']'){\n      stack.push(s[i])\n    } else {\n      let c = stack.pop()\n      let str = \"\"\n      while(c !== '['){\n        str = c + str \n        c = stack.pop()\n      }\n      let last = stack[stack.length - 1]\n      if(!Number.isNaN(parseInt(last))) {\n        stack.pop()\n        while(!Number.isNaN(parseInt(stack[stack.length - 1]))){\n          last = stack.pop() + last\n        }\n        let result = \"\"\n        for(let j = 0; j < last; j++){\n          result += str\n        }\n        stack.push(result)\n      } else {\n        stack.push(str)\n      }\n    }\n  }\n  return stack.join(\"\");\n};\n```\n## 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998513932","body":"## 思路\n单独遍历\n## 代码\n```js\nlet data = new Set();\nwhile (A !== null) {\n  data.add(A);\n  A = A.next;\n}\nwhile (B !== null) {\n  if (data.has(B)) return B;\n  B = B.next;\n}\nreturn null;\n```\n## 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001024888","body":"## 思路\n递归\n## 代码\n```js\nvar isSameTree = function (p, q) {\n  if (!p || !q) {\n    return !p && !q;\n  }\n  return (\n    p.val === q.val &&\n    isSameTree(p.left, q.left) &&\n    isSameTree(p.right, q.right)\n  );\n};\n```\n## 复杂度分析\n- 时间复杂度：O(N)O(N)，其中 N 为树的节点数。\n\n- 空间复杂度：O(h)O(h)，其中 h 为树的高度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yulecc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995900885","body":"## 思路\n使用两个栈实现队列，一个输入，一个输出，输入输出时倒腾一下，比如输出时将输入栈所有元素都添加到输出栈，最低层元素，即最先进栈元素就暴露在输出栈栈顶\n## 代码\n```java\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<>();\n    Stack<Integer> popStack = new Stack<>();\n\n    public MyQueue() {\n    }\n    \n    public void push(int x) {\n        while (!popStack.empty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.empty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.empty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996795491","body":"## 思路\n首先还是要找到从左边开始最小的块。\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n## 复杂度\n- 时间复杂度: O(N \\log N)O(NlogN)，其中 NN 为 arr 的长度。\n- 空间复杂度: O(N)O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222485","body":"## 思路\n先遍历得链表长度为n，则若索引从0开始，新链表的尾节点索引为n-k%n-1，注意判断边界条件，比如head=null || head.next=null || k%n=0时不旋转\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        ListNode lastNode = head;\n        int n = 1;\n        while (lastNode.next != null) {\n            lastNode = lastNode.next;\n            n++;\n        }\n        int k %= n;\n        if (k == 0) return head;\n        ListNode newLastNode = head;\n        for (int i = 1; i < n - k; i++) {\n            newLastNode = newLastNode.next;\n        }\n        lastNode.next = head;\n        ListNode newHeadNode = newLastNode.next;\n        newLastNode.next = null;\n        return newHeadNode;\n    }\n}\n```\n## 复杂度\n- 时间：O(n)，遍历两次链表\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414730","body":"### 思路\n创建哑结点\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode temp = dummyHead;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return dummyHead.next;\n    }\n}\n```\n### 复杂度\n- 时间：O(n)\n- 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998899244","body":"### 思路\n标记后恢复\n### 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode tmp = headA;\n        while (tmp != null) {\n            tmp.val -= (int)Math.pow(10, 5);\n            tmp = tmp.next;\n        }\n        ListNode ans = null;\n        tmp = headB;\n        while (tmp != null) {\n            if (tmp.val <= 0) {\n                ans = tmp;\n                break;\n            }\n            tmp = tmp.next;\n        }\n        tmp = headA;\n        while (tmp != null) {\n            tmp.val += (int)Math.pow(10, 5);\n            tmp = tmp.next;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 时间：O(m + n)\n- 空间：O(1)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000889206","body":"### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n**思路**\n\n- 递归，二叉树深度公式：depth(node) = max(depth(node.left), depth(node.right)) + 1\n\n**代码**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }    \n}\n```\n\n**复杂度**\n\n- 时间：O(n)，n为节点数\n- 空间：O(depth)，depth为树深","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001040564","body":"### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n**思路**\n\n递归，联想求树深度\n\n**代码**\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) { \n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \n    }\n}\n```\n\n**复杂度**\n\n- 时间：O(min(m, n))\n- 空间：O(min(depth(m), depth(n)))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995114076","body":"\r\n# thought\r\n  每次在push的时候，就是push在底部。 push之前把stack1先倒腾到stack2，Stack2.append().再倒回去\r\n 那pop \r\n stack1 321 --》 stack2 123 + 4 ---〉 stack1 4321 # push\r\n stack1 4321 pop1 # pop\r\n\r\n\r\n# code\r\nclass MyQueue:\r\n      def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack2.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n\r\n\r\n    def pop(self) -> int:       \r\n        return self.stack1.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        return self.stack1[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return False if self.stack1 else True\r\n\r\n\r\n# completity\r\ntime & space O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997295637","body":"\n# thought\nRecursion\n\n# code\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\t if not head or not head.next:\n              return head\n        node = head\n        next_node = node.next\n        node.next = self.swapPairs(next_node.next) # 不是在主函数里面接下一个，而是直接在这里就把之后翻转的给接上了。\n        next_node.next = node \n\n        return next_node    \n\n\t\n\n        \n# complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997473584","body":"\n\n\n\n\n# thought\n函数：构造树\n\t…递归函数返回条件…\n\t 找中点\n\t以中点为root = TreeNode（） \tlt = 中点前链表构建树 （调用函数\n\tRt = 中点后链表构建树 （调用函数\n\troot.left = lt\n\tRoot.right = rt \n\t返回 root\n\n\n# code\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        # mid node as head, construct a tree.\n        # store 2 list in two stack. (wrong, 不需要把节点存stack里面)\n        #  我只要把中点找到，然后把左半部分链表传到构造树的函数里面，右半部分链表传到构造树的函数里面。\n        #  root.left = 左半部分链表排好的。root.right = 右半部分链表排好的。\n        slow, fast  = head, head\n        pre = None\n\n        # omg, 递归的边界条件又忘了。。。。递归三要素！！\n        if not head:\n            return\n        if not head.next: # 叶子节点，返回它自己！！\n            return TreeNode(head.val) # ??? #解决33行Nonetype has no attribute 问题。\n\n        while fast and fast.next:\n            pre = slow # 记录slow前一个，也就是前半段链表的最后一个节点。\n            slow = slow.next\n            fast = fast.next.next\n        # print(slow.val,left_stack)\n        # print(pre, slow.val, fast.val)\n        pre.next = None\n        root = TreeNode(slow.val) # 每次递归都要TreeNode吗？？？\n        left_tree = self.sortedListToBST( head )\n        right_tree = self.sortedListToBST( slow.next )\n        root.left = left_tree\n        root.right = right_tree\n        return root\n\n# com\n\n时间复杂度：O(nlogn)，其中 nn 是链表的长度。\n设长度为 nn 的链表构造二叉搜索树的时间为 T(n)???，递推式为 T(n) = 2 \\cdot T(n/2) + O(n)T(n)=2⋅T(n/2)+O(n)，根据主定理，T(n) = O(n \\log n)T(n)=O(nlogn)。\n\n空间复杂度：O(\\log n)O(logn)，这里只计算除了返回答案之外的空间。平衡二叉树的高度为 O(\\log n)O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998421866","body":"\n\n# thought\n 循环条件：不相等\n     a + common + b = b + common + a  \n     if come to end, go for another linkedlist, \n 退出循环：相等/ 都为None  \n if == .return ; if none, none.\n\n\n# code\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n              while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA \n        #如果不相交，不管两条链表长度是否一致都会走到另一条链表上的终点。因为 a + b = b + a（见下面）\n        # 26 4 1 5\n        # 15 2 6 4\n```\n# com\nTime: O(M + N)\nSpace: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001109268","body":"\n\n\n# thought:\n1 dfs\n2 bfs\n\n\n# code\n```\n# Bfs\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        # bfs， 每层记录当前的路径上的总和，到叶子的时候返回。\n        queue = collections.deque([(root, 0)])\n        res = 0\n        while queue:\n            node, value = queue.popleft()\n            if node.left:\n                queue.append((node.left, value * 10 + node.val))\n            if node.right:\n                queue.append((node.right, value * 10 + node.val))    \n            if not node.left and not node.right:\n                res += value * 10 + node.val # 到叶子节点了，res （总路径和）= 这条历史路径和+他自己。        \nreturn res\n\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n         def dfs(root, cur):\n               if not root: return 0\n               if not root.left and not root.right: return cur * 10 + root.val\n       \t\treturn dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n         return dfs(root, 0)\n\n\n```\n\n# com\n## dfs\nTime： O（n）  #Q：dfs 时间复杂度为啥是O（n）呀？\nSpace: O(h) # 树的高度\n## bfs \nTime： O（n）\nSpace：O(len(queue)) 最坏O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yohannjin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993528830","body":"思路：既然堆不能直接操作数据，那么就考虑使用向量进行管理。\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        //memo.reserve(maxSize);\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if(memo.size()< max)\n        {\n            memo.emplace_back(x);\n        }\n    }\n    \n    int pop() {\n        if(memo.empty())\n        {\n            return -1;\n        }\n        else\n        {\n            int tmp = memo.back();\n            memo.pop_back();\n            return tmp;\n        }\n    }\n    \n    void increment(int k, int val) {\n\n        int tmp = k;\n        if(memo.size() < k)\n        {\n            tmp = memo.size();\n        }\n        for(int i = 0; i < tmp ; i++)\n        {\n            memo[i] += val;\n        }\n    }\nprivate:\n    int max = 0;\n    vector<int> memo;\n\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993956550","body":"思路： 使用两个stack, 一个放数字，一个放字符，需要注意的是多位数字需要转换\n\n```cpp\nstring decodeString(string s) {\n        stack<int> num;\n        stack<char> letter;\n        int i = 0;\n        while(i < s.length())\n        {\n            if( isdigit(s[i]) ) //convert number and push to number stack\n            {\n                string tmp_num;\n\n                while(isdigit(s[i]))\n                {\n                    tmp_num.push_back(s[i]);\n                    i++;\n                }\n                int number{0};\n                int carry = 1;\n                while(!tmp_num.empty())\n                {\n                    number += carry * (tmp_num.back() - '0');\n                    tmp_num.pop_back();\n                    carry*=10;\n                }\n                num.push(number);\n                i--;\n            }\n            else if(s[i] == ']') //calculation unit reached\n            {\n               int times = num.top();\n               num.pop();\n               string str{};\n\n               while(true)\n               {\n                   char top = letter.top();\n                   letter.pop();\n\n                   if(top == '[')\n                   {\n                       break;\n                   }\n                   else \n                   {\n                       str.push_back(top);\n                   }\n               }\n            \n               reverse(str.begin(), str.end());\n               for(int j = 0; j< times; j++)\n               {\n                   for(auto k: str)\n                   {\n                       letter.push(k);\n                   }\n               }\n            }\n            else\n            {\n                letter.push(s[i]);\n            }\n            i++;\n        }\n\n        s.clear();\n        while(!letter.empty())\n        {\n            s.push_back(letter.top());\n            letter.pop();\n        }\n        reverse(s.begin(), s.end());\n        return s;            \n    }\n```\n\ntime: O(n), space: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995566639","body":"思路： 两个stack, 互相倒腾\n\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() \n    {\n        memo1 = {};\n        memo2 = {};\n    }\n    \n    void push(int x) \n    {\n        memo1.push(x);\n    }\n    \n    int pop() \n    {\n        if(memo1.empty())\n        {\n            return -1;\n        }\n\n        while(!memo1.empty())\n        {\n            memo2.push(memo1.top());\n            memo1.pop();\n        }\n\n        int ans = memo2.top();\n        memo2.pop();\n\n        while(!memo2.empty())\n        {\n            memo1.push(memo2.top());\n            memo2.pop();\n        }\n\n        return ans;\n    }\n    \n    int peek() \n    {\n        while(!memo1.empty())\n        {\n            memo2.push(memo1.top());\n            memo1.pop();\n        }\n\n        int tmp = memo2.top();\n\n        while(!memo2.empty())\n        {\n            memo1.push(memo2.top());\n            memo2.pop();\n        }\n        return tmp;\n    }   \n    \n    bool empty() \n    {\n        if(memo1.empty())\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\nprivate:\n    stack<int> memo1;\n    stack<int> memo2;\n\n    \n    \n};\n```\ntime = O(n);\nspace = O(n);","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997339183","body":"思路： 使用双栈实现，暴力直观\n\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n\n        if(!head)\n        {\n            return nullptr;\n        }\n        else if(head->next == nullptr)\n        {\n            return head;\n        }\n\n        vector<ListNode*> memo1;\n        vector<ListNode*> memo2;\n\n        int cnt = 0;\n        while(true)\n        {\n            if(cnt%2)\n            {\n                memo1.emplace_back(head);\n            }\n            else\n            {\n                memo2.emplace_back(head);\n            }\n\n            if(head->next == nullptr)\n            {\n                break;\n            }\n            else\n            {\n                head = head->next;\n                cnt++;\n            }\n        }\n\n        for(int i = 0; i < memo1.size();i++)\n        {   \n            if(i == 0)\n            {\n                //initialize list\n                head = memo1[0];\n                head->next = memo2[0];\n            }\n            else\n            {\n                head->next = memo1[i];\n                head = head->next;\n                head->next = memo2[i];\n            }\n            head = head->next;            \n        }\n\n        if(memo2.size()!= memo1.size())\n        {\n            head->next = memo2.back();\n            head = head->next;\n            head->next = nullptr;\n        }\n        else\n        {\n            head->next = nullptr;\n        }\n        \n        return memo1.front();\n    }\n};\n```\n\ntime: O(n), Space: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000694540","body":"dfs, use stack to store the node which have 2 branches, so do not have to go back to every node again, which saves some time.\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) \r\n    {\r\n        if(!root)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        int depth = 1;\r\n        int depth_max = 1;\r\n        stack<pair<TreeNode*, int>> q;\r\n\r\n        \r\n        while(true)\r\n        {\r\n            if(root->left && root->right)\r\n            {\r\n                q.push(make_pair(root, depth));\r\n                root = root->left;\r\n                depth++;\r\n            }\r\n            else if(root->left)\r\n            {\r\n                root = root->left;\r\n                depth++;\r\n            }\r\n            else if(root->right)\r\n            {\r\n                root = root->right;\r\n                depth++;\r\n            }\r\n            else\r\n            {\r\n                if(q.empty())\r\n                {\r\n                    depth_max = max(depth_max,depth);\r\n                    return depth_max;\r\n                }\r\n                else\r\n                {\r\n                    root = q.top().first;\r\n                    depth_max = max(depth_max,depth);\r\n                    depth = q.top().second;\r\n                    q.pop();\r\n                    root->left = nullptr;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n```\r\nTime: O(n);\r\nSpace: O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000914663","body":"recursion\n\n```cpp\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n\n        if(!p && !q)\n        {\n            return true;\n        }\n        else if(p && !q || !p && q || p->val != q->val )\n        {\n            return false;\n        }\n    \n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        \n    }\n};\n```\nTime: O(n);\nSpace： O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codewithiris":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991714436","body":"### 思路\n\n\n模拟,将num和k从个位起逐位相加，最终然后反转vector即可。\n例如:  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = [1, 2, 3, 4]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = 12  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6, 4]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6, 4, 2]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6, 4, 2, 1]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [1, 2, 4, 6] \n\n\n### 代码\n\n\n``` C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        int n = num.size() - 1;\n        int flag = 0;\n        while(n >= 0 || k != 0){\n            int a = n < 0 ? 0 : num[n];\n            int b = k != 0 ? (k % 10) : 0;\n            int tmp = a + b + flag;\n            ans.push_back(tmp % 10);\n            flag = tmp / 10;\n            --n; k/=10;\n        }\n        if(flag != 0){\n            ans.push_back(flag);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度: O(max(n,len(k)),其中n是num的长度, len(k)是k的长度\n- 空间复杂度：O(n), n是ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991940147","body":"### 思路\n\n\n&nbsp;&nbsp;初始化ans均为1.  \n&nbsp;&nbsp;第一次遍历字符串s，将ans中对应字符c的位置设置为0.    \n&nbsp;&nbsp;第二次遍历字符串s，遇到非字符c的便从左侧或者右侧寻找字符c，取最小值填入ans中.    \n\n\n### 代码\n\n\n``` C++\n\nclass Solution {\npublic:\n    void findC(string& s, int i, char c, vector<int>& ans){\n        int left = i - 1, right = i + 1, n = s.size();\n        while(left >= 0 || right < n){\n            if(left >= 0 && right < n){\n                if(s[left] == c || s[right] == c){\n                    ans[i] = right - i;\n                    return ;\n                }\n            }else if(left >= 0 && s[left] == c){\n                ans[i] = i - left;\n                return ;\n            }else if(right < n && s[right] == c){\n                ans[i] = right - i;\n                return ;\n            }\n            --left;\n            ++right;\n        }\n    }\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n, 1);\n        for(int i = 0; i < n; ++i){\n            if(s[i] == c) ans[i] = 0;\n        }\n        for(int i = 0; i < n; ++i){\n            if(s[i] != c) findC(s, i, c, ans);\n        }\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度: O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992857589","body":"### Note\n\n\n&nbsp;&nbsp;Use vector to store the data.\n&nbsp;&nbsp;Record the curIndex and execute the push, pop and increment operation through the curIndex.\n\n\n### Solution\n\n\n``` C++\n\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top, size;\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        size = maxSize;\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != size -1){\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1) return -1;\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < min(top + 1, k); ++i){\n            stk[i] += val;\n        }\n    }\n};\n\n```\n\n**Complexity**\n- T: O(1) for push and pop operation, O(k) for increment operation\n- S: O(n): n is the 'maxSize'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993807919","body":"### Note\n\n\n* Use a stack to store the number and another stack to store the string.  \n* When faced with the char, add it into the temporary string. \n* When faced with the '[', push the temporary string into the string stack. \n* When faced with the ']', pop the top number of the number stack and repeat the content of the temporary string. \n* Finally, add the top element of the string stack to the temporary string.\n\n\n### Solution\n\n\n``` C++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n = s.size();\n        stack<int> digit_stk;\n        stack<string> str_stk;\n        string str = \"\";\n        for(int i = 0; i < n; ++i){\n            if(isdigit(s[i])){\n                int a = s[i] - '0';\n                while(isdigit(s[++i])){\n                    a = a * 10 + s[i] - '0';\n                }\n                digit_stk.push(a);\n                --i;\n            }else if(s[i] == '['){\n                str_stk.push(str);\n                str = \"\";\n            }else if(s[i] == ']'){\n                string tmp;\n                for(int j = 0; j < digit_stk.top(); ++j){\n                    tmp += str;\n                }\n                str = tmp;\n                digit_stk.pop();\n                str = str_stk.top() + str;\n                str_stk.pop();\n            }else{\n                str += s[i];\n            }\n\n        }\n        return str;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n): iterate over the string s once.\n- S: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994999406","body":"### Note\n\n\n* Use two stacks to store the integer. Out_stack is to store the elements like the queue while the in_stack helps to push elements into the out_stack.  \n* Push: When faced with the push operation, push all the elements of the out_stack into the in_stack and after that, push the new element in. Then, push all the elements of the in_stack into the out_tack.  \n* Peek: Return the top element of the out_stack because the out_stack's distribution is already the same as the queue.  \n* Pop: Pop out the top element and return that integer.  \n* Empty: If the out_stack is empty, return 'true'.  \n\n\n### Solution\n\n\n``` C++\n\nclass MyQueue {\npublic:\n    stack<int> in_queue;\n    stack<int> out_queue;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        while(!out_queue.empty()){\n            in_queue.push(out_queue.top());\n            out_queue.pop();\n        }\n        in_queue.push(x);\n        while(!in_queue.empty()){\n            out_queue.push(in_queue.top());\n            in_queue.pop();\n        }\n    }\n    \n    int pop() {\n        int tmp = out_queue.top();\n        out_queue.pop();\n        return tmp;\n    }\n    \n    int peek() {\n        return out_queue.top();\n    }\n    \n    bool empty() {\n        if(out_queue.empty()) return true;\n        return false;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n)\n- S: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996198587","body":"### Note\n\n\n* Use a stack to record the number.\n* When the stack is not empty and the number is smaller than the top of the stack, pop the numbers in the stack until the top of the stack is bigger then the number.\n* When the number is bigger than the top of the stack, just push the number into the stack.\n* Return the size of the stack.\n\n\n### Solution (C++)\n\n\n``` C++\n\n class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int maxx = arr[0];\n        stack<int> stk;\n        stk.push(arr[0]);\n        for(int i = 1; i < arr.size(); ++i){\n            if(arr[i] >= maxx){\n                maxx = arr[i];\n                stk.push(arr[i]);\n            }else{\n                while(!stk.empty() && stk.top() > arr[i]){\n                    stk.pop();\n                }\n                stk.push(maxx);\n            }\n        }\n        return stk.size();\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n)\n- S: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996869582","body":"### Note\n\n\n* Special case judgment: 1.k == 0; 2.head == nullptr; 3. head->next == nullptr(only 1 element in the linked list). In all 3 cases above, return head.  \n* Traverse the list and record the length of the linked list. Get the breakpoint of the linked list / the end of the answer list through this formula:\n<center>Breakpoint Index = Length of the linked list - k % Length of the linked list.</center>  \n\n* Connect the tail of the original linked list to the head, break at the breakpoint and return the new head of the list.  \n\n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(k == 0 || head == nullptr || head->next == nullptr) return head;\n        ListNode* iter = head;\n        int n = 1;\n        while(iter->next != nullptr){\n            ++n;\n            iter = iter->next;\n        }\n        int num = n - k % n;\n        if(num == n) return head;\n        iter->next = head;\n        while(num--){\n            iter = iter->next;\n        }\n        ListNode* ans = iter->next;\n        iter->next = nullptr;\n        return ans;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n), traverse the entire list at most twice\n- S: O(1), only constant space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997226675","body":"### Note (Iteration)\n\n\n* Set a dummy head and point out to the head of the linked list.  \n* Draw the figure and then find the process involves 3 nodes: The previous node will point the second nodes, the first node will point out the second node's next node and finally the second node point out the first node.  \n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* tmp = dummy;\n        while(tmp->next != nullptr && tmp->next->next != nullptr){\n            ListNode* node1 = tmp->next;\n            ListNode* node2 = tmp->next->next;\n            tmp->next = node2;\n            node1->next = node2->next;\n            node2->next = node1;\n            tmp = node1;\n        }\n        return dummy->next;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n), n is the number of the nodes in linked list.\n- S: O(1), only constant space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997420659","body":"### Note (Recursion)\n\n\n* The median is found by the fast and slow Pointers, and the median is used as the child root node. \n* The left part of the median is its left subtree, and the right part is its right subtree.\n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    TreeNode* buildTree(ListNode* left, ListNode* right){\n        if(left == right) return nullptr;\n        ListNode* slow = left;\n        ListNode* fast = left;\n        while(fast != right && fast->next != right){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        TreeNode* node = new TreeNode(slow->val);\n        node->left = buildTree(left, slow);\n        node->right = buildTree(slow->next, right);\n        return node;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n\n```\n\n**Complexity**\n- T: O(nlogn)\n- S: O(logn), the height of the binary search tree is O(logn).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998076143","body":"### Note (Hash Set)\n\n\n* Iterate over linked list A, storing the nodes in linked list A in the hash set.  \n* Then iterate through the linked list B, and the first node it encounters that also exists in the hash set is the result returned. If the node is not found after iterating through linked list B, return nullptr.  \n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode* > hashset;\n        ListNode* tmp = headA;\n        while(tmp!=nullptr){\n            hashset.insert(tmp);\n            tmp = tmp->next;\n        }\n        tmp = headB;\n        while(tmp!=nullptr){\n            if(hashset.count(tmp)) return tmp;\n            tmp = tmp->next;\n        }\n        return nullptr;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(m+n)\n- S: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998977769","body":"### Note (Fast and slow pointer)\n\n\n* The fast and slow pointers both point to the head node. The fast pointer takes two steps at a time while the slow pointer takes one step at a time. The first traversal determines if the linked list has a circle. If the fast and slow pointers meet, the linked list has a circle, and make the fast pointer point to the head node.\n* In the second traversal process, both the fast pointer and the slow pointer move one step at atime, and their meeting node is the entry node of the circle in this linked list.\n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == nullptr || head->next == nullptr) return nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        int flag = 0;\n        while(fast!=nullptr && fast->next!= nullptr){\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow == fast){\n                flag = 1;\n                break;\n            }\n        }\n        if(flag){\n            fast = head;\n            while(fast != slow){\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return slow;\n        }\n        return nullptr;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n): The worst case scenario is to go through the list twice. O(n) + O(n) = O(n)\n- S: O(1): Use fast and slow pointers' space, so that is O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000228669","body":"### Question\nhttps://leetcode.com/problems/lru-cache/  \n\n\n### Note (List and Map)\n\n\n* List are used for sequential storage, bringing elements forward to the front of the list when they are accessed.\n* Map is used to map the location of key-value pairs in the list.\n\n### Solution (C++)\n\n\n``` C++\n\nclass LRUCache {\nprivate:\n    int capacity_;\n    list<pair<int, int>> cache_;\n    unordered_map<int, list<pair<int, int>>::iterator> m_;\npublic:\n    LRUCache(int capacity) {\n        capacity_ = capacity;\n    }\n    \n    int get(int key) {\n        const auto it = m_.find(key);\n        if(it == m_.end()) return -1;\n        cache_.splice(cache_.begin(), cache_, it->second);\n        return it->second->second;\n    }\n    \n    void put(int key, int value) {\n        const auto it = m_.find(key);\n        if(it != m_.end()){\n            it->second->second = value;\n            cache_.splice(cache_.begin(), cache_, it->second);\n            return;\n        }\n        if(cache_.size() == capacity_){\n            const auto& node = cache_.back();\n            m_.erase(node.first);\n            cache_.pop_back();\n        }\n        cache_.emplace_front(key,value);\n        m_[key] = cache_.begin();\n    }\n};\n\n```\n\n**Complexity**\n- T: O(1): O(1) for both 'put' and 'get' operation.\n- S: O(capacity): List and map store up to 'capacity' elements.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000801905","body":"### Question\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n\n### Note (Recursion)\n\n\n* The recursive formula: maxLength = max(maxLeftLength, maxRightLength) + 1\n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n): Iterate over all the nodes when recurse.\n- S: O(Depth): The recursive depth is the height of the binary tree.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000942888","body":"### Question \nDay13 100\nhttps://leetcode-cn.com/problems/same-tree/\n\n\n### Note (DFS)\n\n\n* Compare the two nodes from the P tree and Q tree respectively. If they are both null pointers, return true(The previous nodes are the same). If one of the pointers is a null pointer, return false. If their values are different, return false.  \n* Use deep first search to traverse the trees.  \n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q == nullptr) return true;\n        else if(p == nullptr || q == nullptr || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n\n```\n\n**Complexity**\n- T: O(min(m, n)): If they are the same tree, the time complexity is O(m) = O(n). If not, the time complexity is O(min(m,n)).\n- S: O(min(m, n)): The worst situation is that the nodes are equal to the depth of the tree.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001043484","body":"### Question \nDay14 129\nhttps://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n\n### Note (DFS)\n\n\n* The traversal starts at the root node and computes the current number when a child node is encountered:  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = num*10 + node->val\n\n* Use Depth-First-Search and the exit of the recursion is that the left and right nodes do not exist.\n\n### Solution (C++)\n\n\n``` C++\n\nclass Solution {\npublic:\n    void dfs(TreeNode* node, int num, int& ans){\n        if(node == nullptr) return;\n        num = num*10 + node->val;\n        if(node->left == nullptr && node->right == nullptr){\n            ans += num;\n            return ;\n        }\n        dfs(node->left, num, ans);\n        dfs(node->right, num, ans);\n    }\n    int sumNumbers(TreeNode* root) {\n        int ans = 0;\n        dfs(root, 0, ans);\n        return ans;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n): All the nodes of this tree will be traversed over.\n- S: O(n): The space complexity is the O(Depth of this tree). However, the worst situation is that the depth is equal to the number of nodes.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zwx0641":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991715965","body":"思路：\r\n从后往前遍历数组，k+num[i]的模就为结果数组的前一位，k /= 10\r\n存在遍历结束k还大于0的情况，用k/=10处理\r\n``` java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        while (i >= 0 || k > 0) {\r\n            if (i >= 0) {\r\n                k = num[i] + k;\r\n            }\r\n            ans.add(0, k % 10);\r\n            k/= 10;\r\n            i--;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n时间O(n) 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991928973","body":"思路：\n从前往后从后往前两次遍历\ntmp记录c出现的位置\n第一次遍历ans[i]存放s中i位置字符与前一个c的距离\n第二次遍历比较min(ans[i], s中i位置字符与后一个c的距离)\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        //Arrays.fill(ans, s.length() + 1);\n        int i = 0, j = s.length() - 1, tmp = -1;\n        while (i < s.length()) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                tmp = i;\n            } \n            if (tmp != -1) {\n                ans[i] = i - tmp;\n            } else {\n                ans[i] = s.length() + 1;\n            }\n            \n            i++;\n        }\n        tmp = -1;\n        while (j >= 0) {\n            if (s.charAt(j) == c) {\n                ans[j] = 0;\n                tmp = j;\n            }\n            if (tmp != -1) ans[j] = Math.min(ans[j], tmp - j);\n            \n            j--;\n        }\n        \n        return ans;\n    }\n}\n```\n时间：O(n)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992640911","body":"思路：\n使用数组来存放作为CusStack，cur表示当前需要填的数组位置  \npush就转化为放入cur位置，pop就为获取cur-1位置的值  \ninc就为数组前k个数加上val  \n``` java\nclass CustomStack {\n    int[] stack;\n    int cur = 0;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (cur >= stack.length) {\n            return;\n        }\n        stack[cur] = x;\n        cur++;\n    }\n    \n    public int pop() {\n        if (cur == 0) {\n            return -1;\n        }\n        cur--;\n        return stack[cur];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < cur; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n时间：O(k) \n空间：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993881189","body":"\n``` java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> stack1 = new Stack<>();\n        Stack<String> stack2 = new Stack<>();\n        String ans = new String();\n        int num = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '[') {\n                stack1.push(num);\n                stack2.push(ans);\n                num = 0;\n                ans = \"\";\n            } else if (ch == ']') {\n                int j = stack1.pop();\n                String str = stack2.pop();\n                for (int k = 0; k < j; k++) {\n                    str += ans;\n                }\n                ans = str;\n            } else if (ch >= '0' && ch <= '9') {\n                num = num * 10 + (ch - '0');\n            } else {\n                ans += ch;\n            }\n        }\n        return ans;\n    }\n}\n```\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995195865","body":"思路：\n一个栈用来入列，一个用来出列\n``` java\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if (!s2.isEmpty()) {\n            return s2.pop();\n        } else {\n            while(!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if (!s2.isEmpty()) {\n            return s2.peek();\n        } else {\n            while(!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n```\n时间: push O(1) pop,peek O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996071896","body":"``` java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (!stack.isEmpty() && stack.peek() > arr[i]) {\n                int tmp = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                    stack.pop();\n                }\n                stack.push(tmp);\n            } else {\n                stack.push(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997212848","body":"``` java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        ListNode dummy = head;\n        \n        int len = 1;\n        while (dummy.next != null) {\n            dummy = dummy.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) return head;\n\n        \n        dummy.next = head;\n        for (int i = 0; i < len - k; i++) {\n            dummy = dummy.next;\n        }\n        ListNode ans = dummy.next;\n        dummy.next = null;\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997303366","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000865290","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001004086","body":"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxj783428795":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991716414","body":"### 思路\r\n\r\n将K的每位与A的每位相加，如果大于10，则下一次相加要进位。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n\r\n    let answer = []; \r\n    let carry = 0; // 进位\r\n    for (let i = 1; i <= num.length || k >= 1; i++) {\r\n        let num1 = num.length - i >= 0 ? num[num.length - i] : 0;\r\n        let num2 = k % 10;\r\n        let sum = num1 + num2 + carry; //每位的和记得加上上一位的进位\r\n        if (sum >= 10) { \r\n            answer.unshift(sum % 10);\r\n            carry = Math.floor(sum / 10)\r\n        } else {\r\n            answer.unshift(sum)\r\n            carry = 0\r\n        }\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (carry !== 0) { // 出循环后，如果最后进位不为0，则将进位添加到数组首位\r\n        answer.unshift(carry)\r\n    }\r\n    return answer;\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(N)，其中 N 为 num 和 k 中较长的长度。\r\n- 空间复杂度：O(N)，其中 N 为 answer 的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991931122","body":"### 思路\r\n\r\n第一次循环：找到s中所有c的下标。\r\n第二次循环：循环对比s中每个字符，到所有c的下标的距离，取其中的最小值放入answer中\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n\r\nvar shortestToChar = function (s, c) {\r\n    let indexs = []; // 存储所有c在s中的下标\r\n    let answer = []; // 存储结果\r\n    for (let i = 0; i < s.length; i++) { // 第一遍循环先找到所有c在s中的下标\r\n        if (c === s[i]) {\r\n            indexs.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < s.length; i++) { // 第二遍循环\r\n        let distance = 0;\r\n        if (c === s[i]) { // 如果当前位等于c，则将0放入answer\r\n            answer.push(distance)\r\n        } else {\r\n            distance = Math.abs(i - indexs[0]);\r\n            for (let j = 1; j < indexs.length; j++) {// 循环判断当前位和每一个c的距离，取最小值\r\n                distance = Math.min(distance, Math.abs(i - indexs[j]));\r\n            }\r\n            answer.push(distance)\r\n        }\r\n    }\r\n    return answer;\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(NM)，其中 N 为s的长度，M为s中c出现的次数。\r\n- 空间复杂度：O(N+M)，其中 N 为s的长度，M为s中c出现的次数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992645250","body":"### 思路\r\njs用数组模拟栈，可以直接用数组的push和pop方法表示栈的入栈和出栈\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.values = [];\r\n    this.size = 0;\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.size < this.maxSize) {\r\n        this.values.push(x);\r\n        this.size += 1;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (this.size) {\r\n        this.size -= 1;\r\n        return this.values.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let range = k < this.size ? k : this.size\r\n    for (i = 0; i < range; i++) {\r\n        this.values[i] += val;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n  - push ：O(1)，数组在末位添加元素，复杂度为O(1)。\r\n  - pop：O(1)，数组从末尾删除元素，复杂度为O(1)。\r\n  - increment：O(min(k,N))，其中N为数组长度，k为需要操作的元素数量。\r\n- 空间复杂度：O(N)，其中N为maxSize。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993865862","body":"### 思路\r\n\r\n1. 循环遍历字符串，将字符从头开始压栈，如果遇到']'，则开始出栈，直到'['。将括号之间的字符串标记为需要重复的字符串。\r\n2. 继续出栈，直到字符不为数字为止，这期间出栈的数字记为需要重复的次数。\r\n3. 循环创建重复字符串，并压入栈中\r\n4. 进入下一轮循环。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let stack = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === ']') {\r\n            let str = ''\r\n            let count = ''\r\n            while (stack.length && stack[stack.length - 1] != '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            stack.pop();\r\n            while (stack.length && Number.isInteger(+stack[stack.length - 1])) {\r\n                count = stack.pop() + count;\r\n            }\r\n            for (let j = 0; j < +count; j++) {\r\n                stack.push(str)\r\n            }\r\n        } else {\r\n            stack.push(s[i])\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994972024","body":"### 思路\r\n\r\n1.使用两个栈，一个为输入栈，一个为输出栈。\r\n2.数据入队列时，把数据压入输入栈。\r\n3.数据出队列时，如果输出栈为空，则依次弹出输入栈的所有元素，并压入输出站。然后弹出输出栈的第一个元素。\r\n4.peek方法就是返回输入栈的第一个元素，或输出站的最后一个元素。\r\n5.empty方法就是判断两个栈是否都为空。\r\n\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function () {\r\n    this.inStack = [];\r\n    this.outStack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.inStack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (this.outStack.length === 0) {\r\n        while (this.inStack.length > 0) {\r\n            this.outStack.push(this.inStack.pop())\r\n        }\r\n    }\r\n    return this.outStack.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    return this.inStack[0] || this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return this.inStack.length === 0 && this.outStack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n  - push() : O(1)\r\n  - peek() : O(1)\r\n  - empty() : O(1)\r\n  - pop() : O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996041621","body":"### 思路\r\n\r\n1. 分块的标准是：前面的块的最大值，要小于后面块的最小值。这样才能保证块分别排序再链接后，是整体升序的。\r\n2. 因此，循环遍历整个数组，当数组为空或者栈顶值大于当前元素，说明当前元素应该和前面的块分到一起。\r\n\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    let stack = [];\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (stack.length !== 0 && stack[stack.length - 1] > arr[i]) {\r\n            let temp = stack.pop();\r\n            while (stack.length !== 0 && stack[stack.length - 1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp);\r\n        } else {\r\n            stack.push(arr[i])\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997127515","body":"### 思路\r\n1. 找到链表的tail，以及长度\r\n2. 将tail的next指向head，形成环。\r\n3. 在长度-k处断开链表即可\r\n\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n    if (!head) return head;\r\n    let length = 1;\r\n    let next = head;\r\n    while (next.next) {\r\n        length++;\r\n        next = next.next;\r\n    }\r\n    //这时的next是链表的最后一个元素\r\n    let move = k % length;\r\n    if (!move) return head;\r\n    //将tail的next指向head，形成环\r\n    next.next = head;\r\n    //然后再第length-move处断开环\r\n    let step = length - move;\r\n    let newTail = head;\r\n    while (--step > 0) {\r\n        newTail = newTail.next\r\n    }\r\n    let answer = newTail.next;\r\n    newTail.next = null\r\n    return answer\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(n) n为链表长度\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997228405","body":"### 思路\r\n1. 两两交换节点，会形成闭环，所以要保存下下个节点作为当前节点的下个节点。\r\n2. 也要保存当前节点的前一个节点，用于下两个节点与上两个节点之间的连接。\r\n3. 要判断边界情况，比如链表长度为0和1的时候，直接返回head就行。\r\n\r\n\r\n### 代码\r\n```javascript\r\nvar swapPairs = function (head) {\r\n    let curr = head;\r\n    if (!head || !head.next)\r\n        return head;\r\n    let answer = head.next;\r\n    let prev = null;\r\n    while (curr) {\r\n        let next = curr.next;\r\n        if (!next) {\r\n            prev.next = curr;\r\n            return answer\r\n        }\r\n        let nextnext = next.next;\r\n        next.next = curr;\r\n        curr.next = nextnext;\r\n        if (prev) {\r\n            prev.next = next;\r\n        }\r\n        prev = curr;\r\n        curr = curr.next;\r\n    }\r\n    return answer\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997425314","body":"### 思路\r\n1.找到中间节点作为二叉树的根节点。\r\n2.找到根节点左侧链表的中间节点作为根节点左侧子树的根节点，右侧同理\r\n3.循环以上步骤\r\n\r\n\r\n### 代码\r\n```javascript\r\nvar sortedListToBST = function (head) {\r\n    if (!head) return null;\r\n    return dfs(head, null);\r\n};\r\n\r\nvar dfs = (head, tail) => {\r\n    if (head === tail) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while (fast !== tail && fast.next !== tail) {\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n    }\r\n    let root = new TreeNode(slow.val, dfs(head, slow), dfs(slow.next, tail));\r\n    return root;\r\n}\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998075041","body":"### 思路\r\n\r\n先遍历A链表，将左右节点存储在set中\r\n在遍历B链表，如果节点在set中已存在，则当前节点就是相交起始节点\r\n\r\n\r\n### 代码\r\n```javascript\r\nvar getIntersectionNode = function (headA, headB) {\r\n    let set = new Set();\r\n    while (headA) {\r\n        set.add(headA);\r\n        headA = headA.next;\r\n    }\r\n    while (headB) {\r\n        if (set.has(headB)) return headB;\r\n        headB = headB.next;\r\n    }\r\n    return null\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(N) N为a或b的节点数\r\n- 空间复杂度：O(N) N为a或b的节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998908730","body":"\r\n### 思路\r\n1. 用快慢指针，快指针每次走两步，慢指针每次走一步。\r\n2. 当两个指针第一次相遇时，将快指针重置到head。并且快指针从此时开始每次走一步。\r\n3. 当两个指针再次相遇，就是环的入口。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n    if (!head || !head.next) return null;\r\n    let fast = head.next.next;\r\n    let slow = head.next;\r\n    while (fast !== slow) {\r\n        if (!fast || !slow || !fast.next) {\r\n            return null\r\n        }\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n    }\r\n    fast = head;\r\n    while (fast !== slow) {\r\n        if (!fast || !slow || !fast.next) {\r\n            return null\r\n        }\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    return fast\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000317562","body":"### 思路\r\n1. 使用双向链表，每次put或get时，都将节点放置于链表head处。\r\n2. 使用map保存链表中的节点。空间换取时间，可以做到O(1)时间去到链表的值。\r\n\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.maxSize = capacity;\r\n    this.size = 0;\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.map = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    let node = this.map.get(key);\r\n    if (node) {\r\n        if (this.head === node) { } else if (this.tail === node) {\r\n            let prev = node.prev;\r\n            prev.next = null;\r\n            this.head.prev = node;\r\n            node.next = this.head;\r\n            this.head = node;\r\n            this.tail = prev;\r\n        } else {\r\n            let prev = node.prev;\r\n            let next = node.next;\r\n            prev.next = next;\r\n            next.prev = prev;\r\n            this.head.prev = node;\r\n            node.next = this.head;\r\n            node.prev = null;\r\n            this.head = node;\r\n        }\r\n        return node.val\r\n    } else {\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    //先看链表中存不存在这个key;\r\n    if (this.map.get(key)) {\r\n        //如果存在，则更新这个节点\r\n        let node = this.map.get(key);\r\n        node.val = value;\r\n        //将节点放到链表头部\r\n        if (this.head) {\r\n            if (this.head === node) { } else if (this.tail === node) {\r\n                let prev = node.prev;\r\n                prev.next = null;\r\n                this.head.prev = node;\r\n                node.next = this.head;\r\n                node.prev = null;\r\n                this.head = node;\r\n                this.tail = prev;\r\n            } else {\r\n                let prev = node.prev;\r\n                let next = node.next;\r\n                prev.next = next;\r\n                next.prev = prev;\r\n                this.head.prev = node;\r\n                node.next = this.head;\r\n                node.prev = null;\r\n                this.head = node;\r\n            }\r\n        } else {\r\n            this.head = node;\r\n            this.tail = node;\r\n        }\r\n    } else {\r\n        //如果不存在，则创建新节点\r\n        let node = new DoubleLinkedNode(key, value);\r\n        //在map中存储新节点\r\n        this.map.set(key, node)\r\n        //将节点放到链表头部\r\n        if (this.head) {\r\n            this.head.prev = node;\r\n            node.next = this.head;\r\n            this.head = node;\r\n        } else {\r\n            this.head = node;\r\n            this.tail = node;\r\n        }\r\n        //链表长度+1；\r\n        this.size = this.size + 1;\r\n        //判断是否超出容量\r\n        if (this.size > this.maxSize) {\r\n            //如果超出，则将尾节点移除\r\n            //在map中移除尾节点\r\n            this.map.delete(this.tail.key)\r\n            //将链表尾节点往前移一位\r\n            let prev = this.tail.prev;\r\n            prev.next = null;\r\n            this.tail.prev = null;\r\n            this.tail = prev;\r\n            this.size--\r\n        }\r\n    }\r\n};\r\n\r\nfunction DoubleLinkedNode(key, value) {\r\n    this.key = key;\r\n    this.val = value;\r\n    this.prev = null;\r\n    this.next = null;\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：均为O(1)\r\n- 空间复杂度：O(N)，n为capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000407431","body":"### 思路\r\n1. 如果当前节点为空，则以当前节点为子树的深度为0。\r\n2. 递归比较节点左右两侧子节的高度即可算出树的最大深度\r\n\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n    if (!root) return 0;\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(n) ，每个节点都会运行一次maxDepth\r\n- 空间复杂度：O(depth)，函数调用栈占用的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000998267","body":"\r\n### 思路\r\ndfs，判断两个节点，是否不同时为空，或节点的值不相同。\r\n递归判断节点的左右两侧子节点。\r\n\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n    if (p === null && q === null) {\r\n        return true;\r\n    }\r\n    if (p === null || q === null) {\r\n        return false;\r\n    }\r\n    if (p.val !== q.val) {\r\n        return false;\r\n    }\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right , q.right);\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n- 空间复杂度：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001043412","body":"### 思路\r\n1. 遍历每个节点，如果节点存在，则用当前值+前一个值*10\r\n2. 如果当前节点不存在任何子节点，则直接返回计算后的值\r\n3. 如果存在任一左右子节点，则递归计算。\r\n\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumNumbers = function (root) {\r\n    return dfs(root, 0)\r\n};\r\n\r\nvar dfs = function (node, preSum) {\r\n    if (!node) {\r\n        return 0;\r\n    }\r\n    let sum = preSum * 10 + node.val;\r\n    if (!node.left && !node.right) {\r\n        return sum\r\n    } else {\r\n        return dfs(node.left, sum) + dfs(node.right, sum)\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baddate":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991718618","body":"### 题目\n\n[https://leetcode-cn.com/problems/add-to-array-form-of-integer/](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路\n\n基本的加减法思路，从最低位开始，逐位相加，大于10就进1位（直接在原数k上操作），把结果存到一个新的数组res中，\n如果最后k仍然大于0，说明最终结果位数大于两个加数，这时候再将k值加到结果数组res中，\n最后再翻转该数组即可得到最终结果。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for(int i = n-1;i >= 0;i--)\n        {\n            int temp = num[i] + k % 10;\n            k /= 10;\n            if(temp >= 10)\n            {\n                k++;\n                temp -= 10;\n            }\n            res.push_back(temp);\n        }\n        while(k > 0)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为max(num数组长度，k的位数）。\n- 空间复杂度：O(N)，其中 N 为res数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992549533","body":"### **思路**\r\n\r\n两次遍历（正向&反向），取最小值\r\n\r\n### **代码**\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.length(),0);\r\n        int temp = INT_MIN/2;\r\n        for (int i=0;i<s.length();i++)\r\n        {\r\n            if(s[i]==c)\r\n            {\r\n                temp=i;\r\n            }\r\n            res[i]=i-temp;\r\n        }\r\n        temp = INT_MAX/2;\r\n        for (int i=s.length()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)\r\n            {\r\n                temp=i;\r\n            }\r\n            res[i]=min(temp-i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 字符串长度，遍历两次。\r\n- 空间复杂度：O(N)，N为res的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993616865","body":"### 思路\r\n\r\n使用`vector`模拟栈，然后用一个变量`top`记录末尾元素\r\n\r\n`push`操作：直接在对应坐标（`top+1`）赋值\r\n\r\n`pop`操作：返回`vector`末尾值，`top`对应要减1（这里不能直接删除，因为之后可能还有其他操作）\r\n\r\n`inc`操作：直接取`k`和`vector`的size中的较小值，然后对应坐标增加`val`\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top + 1 != stk.size())\r\n        {\r\n            ++top;\r\n            stk[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top == -1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stk[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int m = min(top+1, k);\r\n        for(int i=0;i<m;i++)\r\n        {\r\n            stk[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：`O(k)+O(1)*3`，主要是根据`inc`操作时的`k`值改变，`pop`、`push`、`构造函数`均为`O(1)`\r\n- 空间复杂度：`O(maxSize)`，`vector`的大小占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994929145","body":"### 思路\n\n难点在于如果出现嵌套的情况，需要从内向外拼接，所以可以使用一个辅助栈的方法来处理，感觉有点类似于写计算器时的逆波兰表达式\n\n如果是数字，就直接压栈\n\n如果是字母或者左括号，直接压栈\n\n如果是右括号，执行出栈操作，如果左括号出栈，则临时字符串拼接完成，之后根据栈顶数字构造一个新的字符串，然后压栈，知道碰到下一个右括号，如此循环\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top();\n                                 \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995539514","body":"### 思路\r\n\r\n使用两个栈模拟，一个做主要，一个做临时跳转。\r\n\r\npush：直接stk1入栈\r\n\r\npop：stk1一次入栈stk2，stk2的栈顶即为队列首位，移除之后，再将stk2入栈stk1\r\n\r\npeek：类似pop，去掉移除栈顶元素的操作\r\n\r\nempty：判空stk1即可\r\n\r\n====\r\n\r\n优化：\r\n\r\n每次再将stk2压入stk1有点复杂，所以可以直接用stk2做输出栈，而stk1做输入栈；这样只要stk2栈不空，栈顶元素就一直是队列首个元素；还有一点要注意，这时候要两个栈同时为空队列才是空。\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int ret;\r\n        while(!stk1.empty())\r\n        {\r\n            stk2.push(stk1.top());\r\n            stk1.pop();\r\n        }\r\n        ret = stk2.top();\r\n        stk2.pop();\r\n        while(!stk2.empty())\r\n        {\r\n            stk1.push(stk2.top());\r\n            stk2.pop();\r\n        }\r\n        return ret;\r\n    }\r\n    \r\n    int peek() {\r\n        int ret;\r\n        while(!stk1.empty())\r\n        {\r\n            stk2.push(stk1.top());\r\n            stk1.pop();\r\n        }\r\n        ret = stk2.top();\r\n        while(!stk2.empty())\r\n        {\r\n            stk1.push(stk2.top());\r\n            stk2.pop();\r\n        }\r\n        return ret;\r\n    }\r\n    \r\n    bool empty() {\r\n        return stk1.empty() && stk2.empty();\r\n    }\r\n};\r\n\r\n//========优化\r\n\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() {\r\n\r\n    }\r\n    void helper() {\r\n        while(!stk1.empty())\r\n        {\r\n            stk2.push(stk1.top());\r\n            stk1.pop();\r\n        }\r\n    }\r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(stk2.empty()) {\r\n            helper();\r\n        }\r\n        int ret = stk2.top();\r\n        stk2.pop();\r\n        return ret;\r\n    }\r\n    \r\n    int peek() {\r\n        if(stk2.empty()) {\r\n            helper();\r\n        }\r\n        int ret = stk2.top();\r\n        return ret;\r\n    }\r\n    \r\n    bool empty() {\r\n        return stk1.empty() && stk2.empty();\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：push/empty操作是O(1)，pop/peek操作平均也是O(1)\r\n- 空间复杂度：O(N)，N为队列元素数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996715299","body":"### 思路\r\n\r\n根据题意可以推出：分块意味着左边块的最大值一定≤右边的最小值，顺着这个思路，只要找到左边最大值≤右边最小值的时候，就是一个块的分界线\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int sz = arr.size();\r\n        vector<int> lptr(sz, INT_MIN);\r\n        vector<int> rptr(sz, INT_MAX);\r\n        lptr[0] = arr[0];\r\n        rptr[sz - 1] = arr[sz - 1];\r\n        for (int i = 1; i < sz; ++i) {\r\n            lptr[i] = max(lptr[i - 1], arr[i]);\r\n            rptr[sz - 1 - i] = min(rptr[sz - i], arr[sz - 1 - i]);\r\n        }\r\n        int res = 1;\r\n        for (int i = 0; i < sz - 1; ++i) {\r\n            res += lptr[i] <= rptr[i + 1];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，两次遍历，N为数组长度\r\n- 空间复杂度：O(N)，两个辅助数组，N为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997147472","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/rotate-list/submissions/](https://leetcode-cn.com/problems/rotate-list/submissions/)\r\n\r\n### 思路\r\n\r\n首先遍历计算链表的大小`sz`；然后保存原始head指针为`prev`，为了之后链接头尾；对于k值，如果大于`sz`，其实会出现重复，所以我们直接计算`k%sz`，就是我们需要移动的次数；如果`k%sz`刚好是`0`，则不需要改变，直接返回`head`即可；我们通过计算`temp=sz-k%sz`可以计算出最终结果的头指针`nhead`，所以，再从头遍历链表，直到遍历到`nhead`前一个，即`temp==1` 的时候，我们需要将此时的指针`next`置空，否则最终结果就是环形链表了，但同时也要将`nhead`指向`head->next`作为最终返回值；最后，我们需要找到链表的尾指针，然后将尾指针指向我们之前保存的`prev`指针，返回`nhead`即可。\r\n\r\n### 代码\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL||head->next==NULL || k==0) return head;\r\n        int sz=0;\r\n        ListNode* ptr=head;\r\n        while(ptr!=NULL)\r\n        {\r\n            ptr = ptr->next;\r\n            sz++;\r\n        }\r\n        cout<<sz;\r\n        k%=sz;\r\n        ListNode* prev=head;\r\n        int temp=sz-k;\r\n        if(temp==sz) return head;\r\n        while(head!=NULL&&temp!=1)\r\n        {\r\n            temp--;\r\n            head=head->next;\r\n        }\r\n        ListNode* nhead=head->next;\r\n        ListNode* tmp=head->next;\r\n\r\n        head->next=nullptr;\r\n        while(tmp!=NULL&&tmp->next!=NULL)\r\n        {\r\n            tmp=tmp->next;\r\n        }\r\n        tmp->next=prev;\r\n        return nhead;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，两次遍历链表\r\n- 空间复杂度：O(1)，临时变量，常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997324713","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/](https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/)\r\n\r\n### 思路\r\n\r\n链表迭代，构造一个临时节点`nhead`指向`head` ，nhead作为最终结果的指针不动，用一个新指针`prev`指向`nhead`用来执行交换操作\r\n\r\n特殊情况：链表大小为0或1的时候直接返回`head`\r\n\r\n### 代码\r\n\r\n```cpp\r\n/* 迭代思路 */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head == nullptr || head->next == nullptr) return head;\r\n        ListNode* nhead = new ListNode(-1);\r\n        nhead->next = head;\r\n        ListNode* prev = nhead;\r\n\r\n        while(head != nullptr && head->next != nullptr)\r\n        {\r\n            prev->next = head->next;\r\n            head->next = prev->next->next;\r\n            prev->next->next = head;\r\n            prev = head;\r\n            head = head->next;\r\n        }\r\n        return nhead->next;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，N为链表大小\r\n- 空间复杂度：O(1)，构造了一个临时节点，其余均在原链表上操作","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997934559","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n### 思路\r\n\r\n计算中位数，然后左右分别递归\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return makeTree(head, nullptr);\r\n    }\r\n\r\n    TreeNode* makeTree(ListNode* left, ListNode* right) {\r\n        if(left == right)\r\n        {\r\n            return nullptr;\r\n        }\r\n        ListNode* mid = calcMedian(left, right);\r\n        TreeNode* root = new TreeNode(mid->val);\r\n        root->left = makeTree(left, mid);\r\n        root->right = makeTree(mid->next, right);\r\n        return root;\r\n    }\r\n\r\n    ListNode* calcMedian(ListNode* head, ListNode* end) {\r\n        ListNode* fast;\r\n        ListNode* slow;\r\n        fast = head;\r\n        slow = head;\r\n        while(fast != end && fast->next != end)\r\n        {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(nlogn)，二分构造二叉树\r\n- 空间复杂度：O(logn)，平衡二叉树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998463809","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/intersection-of-two-linked-lists/](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n### 思路\r\n\r\n使用`cover`集合存储`headA`中的每一个节点，然后遍历`headB`，如果有节点在`cover`中出现，则说明是相交节点，返回即可，如果没有在`cover`中出现，说明不相交。\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headB == NULL || headA == NULL) return NULL;\r\n        ListNode* pa = headA;\r\n        unordered_set<ListNode*> cover;\r\n        while(pa != NULL)\r\n        {\r\n            cover.insert(pa);\r\n            pa = pa->next;\r\n        }\r\n        pa = headB;\r\n        while(pa != NULL)\r\n        {\r\n            if(cover.count(pa))\r\n            {\r\n                return pa;\r\n            }\r\n            pa = pa->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：`O(M+N)`，M，N分别为`headA`和`headB`的长度\r\n- 空间复杂度：`O(M)`，M为`headA`的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999696794","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/linked-list-cycle-ii/](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n### 思路\r\n\r\n使用快慢指针，二者会在环上某一点相遇\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slow = head, *fast = head;\r\n        while (fast != nullptr) {\r\n            slow = slow->next;\r\n            if (fast->next == nullptr) {\r\n                return nullptr;\r\n            }\r\n            fast = fast->next->next;\r\n            if (fast == slow) {\r\n                ListNode *ptr = head;\r\n                while (ptr != slow) {\r\n                    ptr = ptr->next;\r\n                    slow = slow->next;\r\n                }\r\n                return ptr;\r\n            }\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000310979","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/lru-cache/](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n### 思路\r\n\r\n哈希表 + 双向链表\r\n\r\n双向链表按照被使用的顺序存储键值对\r\n\r\n哈希表通过缓存数据的键映射到其在双向链表中的位置\r\n\r\n### 代码\r\n\r\n```cpp\r\nstruct LinkListNode\r\n{\r\n    int key, val;\r\n    LinkListNode* prev;\r\n    LinkListNode* next;\r\n    LinkListNode() : key(0), val(0), prev(nullptr), next(nullptr) {}\r\n    LinkListNode(int k, int v) : key(k), val(v), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    LinkListNode* dhead;\r\n    LinkListNode* dtail;\r\n    unordered_map<int, LinkListNode*> cache;\r\n    int size;\r\n    int cap;\r\n\r\n    void addToHead(LinkListNode* node) {\r\n        node->prev = dhead;\r\n        node->next = dhead->next;\r\n        dhead->next->prev = node;\r\n        dhead->next = node;\r\n    }\r\n    \r\n    void removeNode(LinkListNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(LinkListNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    LinkListNode* removeTail() {\r\n        LinkListNode* node = dtail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n\r\n    LRUCache(int capacity) {\r\n        cap = capacity;\r\n        size = 0;\r\n        dhead = new LinkListNode();\r\n        dtail = new LinkListNode();\r\n        dhead->next = dtail;\r\n        dtail->prev = dhead;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if(!cache.count(key))\r\n        {\r\n            return -1;\r\n        }\r\n        LinkListNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->val;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            LinkListNode* node = new LinkListNode(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > cap) {\r\n                LinkListNode* removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            LinkListNode* node = cache[key];\r\n            node->val = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)，N为缓存容量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000654279","body":"## 思路\nDFS 递归左右子树，取最大值\n\n## 代码\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        return root  == nullptr ? 0 :  max(maxDepth(root->left), maxDepth(root->right))+1;\n    }\n};\n```\n**复杂度分析：**\n- 时间复杂度：O(N)，N为树节点数\n- 空间复杂度：O(height)，递归需要的栈空间，height 为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000906518","body":"### 题目\r\n\r\n[https://leetcode-cn.com/problems/same-tree/](https://leetcode-cn.com/problems/same-tree/)\r\n\r\n### 思路\r\n\r\n二者均为空，相同\r\n\r\n只有一个为空，不同\r\n\r\n都不为空，但是值不同，不同\r\n\r\n递归左右子树\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p == nullptr && q==nullptr) return true;\r\n        if(p == nullptr || q==nullptr) return false;\r\n        if(p->val != q->val) return false;\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(min(M,N))，M和N分别为二者节点数\r\n- 空间复杂度：O(min(M,N))，M和N分别为二者节点数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"courtneyz94":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991738847","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans, i = [],len(num) -1\n        while k > 0 or i >= 0:\n            k,rmd = divmod(k + (num[i] if i >= 0 else 0),10)\n            ans.append(rmd)\n            i -= 1\n        return reversed(ans)\n```\n### Time Complexity O(n) , Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991977177","body":"```python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = -len(S)\n        ans = []\n        for i in range(len(S)):\n            if S[i] == C: \n                prev = i\n            ans.append(i - prev)\n\n        prev = 2 * len(S)\n        for i in range(len(S) - 1, -1, -1):\n            if S[i] == C: \n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```\ntime complexity: o(n) space complexity: o(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997332546","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        prev = dummy\n        dummy.next = head\n        \n        while head and head.next:\n            sec = head.next\n            prev.next = sec\n            head.next = sec.next\n            sec.next = head\n            prev = prev.next.next\n            head = head.next\n            \n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997422159","body":"```python\ndef sortedListToBST(self, head):\n    if not head:\n        return \n    if not head.next:\n        return TreeNode(head.val)\n    slow, fast = head, head.next.next\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n    tmp = slow.next\n    slow.next = None\n    root = TreeNode(tmp.val)\n    root.left = self.sortedListToBST(head)\n    root.right = self.sortedListToBST(tmp.next)\n    return root\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000867678","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left, right) + 1\n         \n        \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feifan-bai":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991744742","body":"\n### 思路\n1. Add the k to the num array from the last digit\n2. Iterated with each digit to update the num array\n3. Deal with the carry situation(if need carry, num.insert(0, 0))\n\n\n*### 代码*\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num)-1\n\n        while k > 0:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k!= 0:\n                num.insert(0, 0)\n                i = 0\n        return num\n\n```\n\n- *复杂度分析**\n- 时间复杂度：O(N), N = max(num,len(k)) \n- 空间复杂度：O(N), N = max(len(num), len(k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992022067","body":"### 思路\n\n1. Traverse from left to right, record the last position where c appears,  ans_l = i - prev_l\n2. Traverse from right to left, record the last position where c appears, ans_r = prev_r - i\n3. Final ans = min(ans_l, ans_r)\n\n*### 代码*\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev_l,  prev_r = float('-inf'), float('inf')\n        ans = []\n        \n        for i, char in enumerate(s):\n            if char == c:\n                prev_l = i\n            ans.append(i - prev_l)\n        \n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev_r = i\n            ans[i] = min(ans[i], prev_r - i)\n        \n        return ans\n\n```\n\n- *复杂度分析*\n- 时间复杂度：O(N), N = len(s)\n- 空间复杂度：O(N), N = len(ans)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993145847","body":"### 思路\n1. Using top, add[] array to record the top postion and increasement of stack.\n2. Push, if not reaching the limitation, top += 1, add new element\n3. Pop, if not empty, return original value of top + add[top]\n4. Increment, add[lim] + val\n\n*### 代码*\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.add = [0] * maxSize\n        self.top = -1\n        \n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        res = self.stk[self.top] + self.add[self.top]\n        if self.top != 0:\n            self.add[self.top-1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k-1, self.top)\n        if lim >= 0:\n            self.add[lim] += val\n```\n\n- *复杂度分析*\n- 时间复杂度：O(1)\n- 空间复杂度：O(N), N = maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994093637","body":"*思路*\n1. Using a stack to store the number times and string to store the chars.\n2. When facing the char, added it to string\n3. When facing the '[', append the c\n4. When facing the ']', find the top number of times the stack and string[1:] * times \n\n*代码*\n\n```\nstack = []\n        res = \"\"\n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                string = ''\n                while not stack[-1].isnumeric():\n                    string = stack.pop() + string\n                times = ''\n                while stack and stack[-1].isnumeric():\n                    times = stack.pop() + times\n                if times:\n                    string = string[1:] * int(times)\n                if stack:\n                    stack.append(string)\n                else:\n                    res += string\n        return res + ''.join(stack)\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995088521","body":"*思路*\n1. Using 2 stacks to finalize the Quene\n2. Stack2 to store the elements reversely from stack 1\n3. Stack1 and front to implement the quene \n\n*代码*\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        # Push element x to the back of queue\n        if not self.stack1:\n            self.front = x\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            self.front = None\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        return self.front\n\n    def empty(self) -> bool:\n        if not self.stack1 and not self.stack2:\n            return True\n        return False\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996246216","body":"*思路*\n1. Monotonic stack\n2. Non-increasing subarray cannot be divided(stack[-1] > num)\n3. Non-decreasing subarray can be divided(stack[-1]<= num, stack.append(num))\n*代码*\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                cur_max = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(cur_max)\n        return len(stack)\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997126339","body":"*思路*\n1. slow, fast pointer\n2. find the len of list\n3. find the k node of list\n4. find the new head node\n*代码*\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        len = 0\n        cur = head\n        while cur:\n            len += 1\n            cur = cur.next\n        k %= len\n        if k == 0: return head\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        newHead = slow.next\n        slow.next = None\n        fast.next = head\n        return newHead\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997236036","body":"*思路*\n1. Recursion\n2. If link list is 0 or 1, return head\n3. save next node, pre node\n4. swap the nodes\n*代码*\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997540563","body":"*思路*\n1. fast moves two step, slow moves one step, to get the mid of the list\n2. buld the tree with mid, (left, mid), (mid.next, right)\n*代码*\n```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n            \n        return buildTree(head, None)\n```\n*复杂度分析*\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998264818","body":"*思路*\n1. Curculate two points to the end\n2. When p1 == p2, end the while loop\n3. The end point is the intersection\n*代码*\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            p1 = p1.next if p1 else headB\n            p2 = p2.next if p2 else headA\n        return p1\n```\n*复杂度分析*\n- 时间复杂度：O(N), N = len(headA) + len(headB)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998967221","body":"*思路*\n1. Slow, fast points with 1 step, 2 steps each time.\n2. If there exists a cycle, fast and slow points will be met at a position.\n3. Find the postion by two points\n*代码*\n```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head or not head.next: return\n        fast, slow = head, head\n        start = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                while slow != start:\n                    slow = slow.next\n                    start = start.next\n                return slow\n        return None\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999745894","body":"*思路*\r\n1. Hash table + double linked list\r\n2. Double linked list stores the key-value pairs, with the order that the pairs near the head are the most recently used.\r\n3. Hash table maps the key of the cached data to its position in the Double linked list.\r\n4. First use the hash table to find the position of the cache item, then move it to the head of the double linked list.\r\n\r\n*代码*\r\n```\r\nclass Node:\r\n    def __init__(self, key, val, next = None, prev = None):\r\n        self.key = key\r\n        self.val = val\r\n        self.next = None\r\n        self.prev = None\r\n\r\nclass DoubleList:\r\n    def __init__(self):\r\n        self.head = Node(-1, -1)\r\n        self.tail = Node(-1, -1)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.size = 0\r\n\r\n    def addFirst(self, x):\r\n        x.next = self.head.next\r\n        x.prev = self.head\r\n        self.head.next.prev = x\r\n        self.head.next = x\r\n        self.size += 1\r\n    \r\n    def remove(self, x):\r\n        x.prev.next = x.next\r\n        x.next.prev = x.prev\r\n        self.size -= 1\r\n\r\n    def removelast(self):\r\n        if self.size == 0: \r\n            return None\r\n        last_node = self.tail.prev\r\n        self.remove(last_node)\r\n        return last_node\r\n    \r\n    def getSize(self):\r\n        return self.size\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.map = {}\r\n        self.cache = DoubleList()\r\n    \r\n    def get(self, key: int) -> int:\r\n        if key not in self.map:\r\n            return -1\r\n        val = self.map[key].val\r\n        self.put(key, val)\r\n        return val\r\n    \r\n    def put(self, key:int, value:int) -> None:\r\n        new_item = Node(key, value)\r\n        if key in self.map:\r\n            self.cache.remove(self.map[key])\r\n            self.cache.addFirst(new_item)\r\n            self.map[key] = new_item\r\n        else:\r\n            if self.capacity == self.cache.getSize():\r\n                last_node = self.cache.removelast()\r\n                self.map.pop(last_node.key)\r\n            self.cache.addFirst(new_item)\r\n            self.map[key] = new_item\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n*复杂度分析*\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N), N = capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000478025","body":"*思路*\n1. Recursion, return the maxDepth of the left and right subtree\n\n*代码*\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(Depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000905392","body":"*思路*\n1. 判断几个特殊情况(子树全为空，其中有一个为空)\n2. 递归调用函数直至最底层(DFS)\n*代码*\n```\ndef isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q: \n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and \\\n            self.isSameTree(p.right, q.right)\n```\n*复杂度分析*\n- 时间复杂度：O(N), N = min(m, n), m, n 为p, q 节点数\n- 空间复杂度：O(N), N = min(m, n)，m, n 为p, q 节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001047623","body":"*思路*\n1. DFS 从根节点开始，遍历每个节点\n2. 如果遇到叶子节点，将叶子节点val加到数字之和\n3. 如果当前节点不是叶子节点，则计算数字，对子节点递归\n*代码*\n```\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root: \n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n```\n*复杂度分析*\n- 时间复杂度：O(N), N = 节点数\n- 空间复杂度：O(N), N = 节点数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangnn2018":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991753962","body":"思路： 把数组num转换成整数，与k相加，再将得到的和转换成对应的数组\n代码：\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        nn=0\n        '''\n        for i in reversed(range(len(num))):\n            nn = nn + 10 ** (len(num) - 1 - i) * num[i]\n        '''\n        for n in num:\n            nn = nn*10+n\n        sum=nn+k\n        strs=str(sum)\n        l=[]\n        for j in range(len(strs)):\n            l.append(int(strs[j]))\n        return l\n复杂度（不是很确定对不对.....）：\n时间复杂度：O(N)，N是num+k的位数\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991943786","body":"#### 思路\r\n先遍历`s`找到所有等于`c`的元素下标，并存在数组`lab`里，  \r\n再次遍历`s`计算所有元素的下标与数组`lab`里元素值的差的绝对值，取最小的一个。\r\n\r\n#### 代码\r\n  ```python\r\n      class Solution(object):\r\n      def shortestToChar(self, s, c):\r\n          \"\"\"\r\n          :type s: str\r\n          :type c: str\r\n          :rtype: List[int]\r\n          \"\"\"\r\n          lab=[]\r\n          for i in range(len(s)):\r\n              if s[i]==c:\r\n                  lab.append(i)\r\n\r\n          res=[0]*len(s)\r\n          for i in range(len(s)):\r\n              lab0 = [abs(j-i) for j in lab]\r\n              res[i]=min(lab0)\r\n          return res\r\n ```\r\n#### 复杂度\r\n时间复杂度：O(NM), N为数组`s`的长度, M为数组`lab`的长度。  \r\n空间复杂度：O(M), M为数组`lab`的长度，最差情况下等于数组`s`的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992851295","body":"#### 思路\r\n创建列表[]，对列表操作实现相关功能。\r\n\r\n#### 代码\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return -1\r\n        else:\r\n            return self.stack.pop(-1)\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(k,len(self.stack))):\r\n            self.stack[i]=self.stack[i]+val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n#### 复杂度\r\n* 时间复杂度: O(N), 由increment的遍历带来的；\r\n* 空间复杂度：O(N), 栈的生成占用的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994147853","body":"#### 思路\r\n* `nums`存数字；`res`存字符串(res从空字符串一直变成最终的结果字符串；中间入栈后清零，记录中间字符串)；\r\n* `num`计算多位数字对应的整数\r\n* 遇到`[`就入栈，遇到`]`就出栈。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N), N为字符串长度，一层for循环；\r\n* 空间复杂度：O(M), 结果字符串的长度。\r\n\r\n#### 代码\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []  # 记录左括号之前的字符串\r\n        nums = [] #记录数字\r\n        num = 0\r\n        res = \"\"  # 实时记录当前可以提取出来的字符串\r\n        for i in s:\r\n            if i.isdigit():\r\n                num = num * 10 + int(i)\r\n            elif i == \"[\":\r\n                stack.append(res)\r\n                nums.append(num)\r\n                res, num = \"\", 0\r\n            elif i == \"]\":\r\n                topstr = stack.pop()\r\n                topnum = nums.pop()\r\n                res = topstr + res * topnum\r\n            else:\r\n                res = res + i\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995269506","body":"#### 思路\r\n* 存的时候直接`append()`就行。\r\n* 删除并返回队首元素的时候，需要从`stack1`倒腾到`stack2`，这样才能使`stack1`栈底（即队首）的元素变成`stack2`的栈顶。\r\n* 返回队首元素的时候，记得把`pop()`出的元素，再`append()`回去，不然就被删了。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N), pop函数的for循环；\r\n* 空间复杂度：O(N), 引入了两个栈。\r\n\r\n#### 代码\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n              \r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stack1.append(x) \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not (self.stack1 or self.stack2)\r\n        \r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996656471","body":"#### 思路\r\n* 从右到左遍历，找出每个元素右侧的最小值`mint[i]`；\r\n* 从左到右遍历，找出每个元素左侧的最大值`maxt[i]`；\r\n* 如果左侧的最大值**小于等于**右侧的最小值，则可以在此分块，res+1\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N), 3个独立的for循环；\r\n* 空间复杂度：O(N), 两个数组。\r\n\r\n#### 代码\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        res=1\r\n        maxt=[0]*len(arr)\r\n        maxt[0]=arr[0]\r\n        mint=[0]*len(arr)\r\n        mint[-1]=arr[-1]\r\n        for i in reversed(range(len(arr)-1)):\r\n            mint[i]=min(arr[i],mint[i+1])\r\n\r\n        for i in range(1,len(arr)):\r\n            maxt[i]=max(arr[i],maxt[i-1])\r\n\r\n        for i in range(len(arr)-1):\r\n            if maxt[i] <= mint[i+1]:\r\n                res=res+1\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997070063","body":"#### 思路\r\n* 遍历链表，找出并记录原链表的尾节点`m`和长度`n`；\r\n* 再次遍历链表，找到倒数第`k+1`个节点，该节点是旋转后的尾节点，`next`节点是新链表的头节点；\r\n* 使该节点的`next`指向`NULL`；\r\n* 使原先尾节点`m`的`next`指向原先的头节点`head`。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N), 2次遍历；\r\n* 空间复杂度: O(1)。\r\n\r\n#### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        p=head #遍历链表，找出原链表的尾节点和长度\r\n        q=head #遍历链表，找到倒数第k+1个节点，即新链表的头节点\r\n        n=0 #n 记录链表的长度\r\n        while p: \r\n            n=n+1\r\n            m=p #记录原先的尾节点\r\n            p=p.next\r\n\r\n        if n==0 or k==0:\r\n            return head\r\n\r\n        kk=k%n #取余数\r\n        if kk==0: # 等于0表示旋转后还是原来的样子\r\n            return head\r\n\r\n        j=1\r\n        while q:\r\n            if j==n-kk: #找出倒数第k+1个节点\r\n                mm=q.next #这是旋转后的头节点\r\n                q.next=p #该节点是旋转后的尾节点，该节点的next指向NULL\r\n                m.next=head # 使原先尾节点的next指向原先的头节点\r\n                break \r\n            q=q.next\r\n            j=j+1\r\n            \r\n        return mm #返回旋转后的头节点\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997312926","body":"#### 思路\r\n* 回溯\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N)；\r\n* 空间复杂度: O(1)。\r\n\r\n#### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n        p=head.next\r\n        head.next=self.swapPairs(p.next)\r\n        p.next=head\r\n        return p\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997491054","body":"#### 思路\r\n* 快慢指针找到中间节点，中间节点即为根节点\r\n* 去掉中间节点，左右断开\r\n* 前半段递归找左子树, 后半段递归找右子树\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N^2)；\r\n* 空间复杂度: O(1)。\r\n\r\n#### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not head:\r\n            return \r\n        slow = head\r\n        fast = head\r\n        p = head\r\n        #快慢指针找到中间节点\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            p = slow\r\n            slow = slow.next\r\n        #中间节点为根节点\r\n        root = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return root\r\n        #去掉中间节点，左右断开\r\n        p.next = None\r\n        next_head = slow.next\r\n        #前半段递归找左子树\r\n        root.left = self.sortedListToBST(head)\r\n        #后半段递归找右子树\r\n        root.right = self.sortedListToBST(next_head)\r\n        return root","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998288471","body":"#### 思路\r\n* a+c+b+**c**\r\n* b+c+a+**c**\r\n* 让`pa`遍历完链表`A`之后开始遍历链表`B`，让`pb`遍历完链表`B`之后开始遍历链表`A`，这样两个指针同时到达相交点。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(m+n), m和n分别是两个链表的长度；\r\n* 空间复杂度: O(1)。\r\n\r\n#### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"  \r\n        pa=headA\r\n        pb=headB\r\n        while pa != pb: \r\n            #如果pa指针走完了链表a，接着开始走b\r\n            if pa:\r\n                pa=pa.next\r\n            else:\r\n                pa=headB\r\n            #如果pb走完了链表b,接着走b\r\n            if pb:\r\n                pb=pb.next\r\n            else:\r\n                pb=headA\r\n        #走到两个链表相交的节点时，pa和pb走了相同的路程。\r\n        return pa\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999081795","body":"\r\n#### 思路\r\n* 2倍速快指针与1倍速慢指针。`2(a+b)=a+b+c+b`\r\n* 若无环，fast会走到NULL; 若有环，快慢指针终将相遇。\r\n* 快慢指针相遇的节点到入环的第一个节点的距离c，与从头到入环的第一个节点的距离a相等。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N)；\r\n* 空间复杂度: O(1)。\r\n\r\n#### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        # 快慢指针相遇的节点到入环的第一个节点的距离，与 从头到入环的第一个节点的距离相等\r\n        fast = head\r\n        slow = head\r\n        while fast and fast.next: #若无环，fast会走到NULL\r\n            fast=fast.next.next\r\n            slow=slow.next\r\n            if fast == slow: #若有环，快慢指针终将相遇\r\n                    temp = head\r\n                    while temp!=slow:\r\n                        slow=slow.next\r\n                        temp=temp.next\r\n                    return temp\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999840337","body":"#### 思路\r\n* 哈希表，，但无序，\r\n* 调用`collections.OrderedDict()`先删再插入，使每次使用过的`key`变到最后面\r\n\r\n#### 复杂度\r\n* 时间复杂度: `O(N)`, `N=capacity`；\r\n* 空间复杂度: `O(N)`。\r\n\r\n#### 代码\r\n```python\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        self.data = collections.OrderedDict()\r\n        self.capacity = capacity \r\n\r\n    def get(self, key):\r\n        if key in self.data: #如果存在，就先删除\r\n            self.data[key] = self.data.pop(key) #再重新插入，变成末尾\r\n            return self.data[key]\r\n        return -1\r\n\r\n    def put(self, key, value):\r\n        if key in self.data: #key存在，先删除\r\n            self.data.pop(key)  \r\n        self.data[key] = value #再插入key，这时在最后面\r\n        if len(self.data)>self.capacity: #如果长度超了\r\n            self.data.popitem(last = False) #把前面的删掉一个\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000468485","body":"#### 思路\r\n* 递归\r\n\r\n#### 复杂度\r\n* 时间复杂度: `O(N)` ；\r\n* 空间复杂度: `O(1)`。\r\n\r\n#### 代码\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if not root:\r\n            return 0\r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        return max(left,right)+1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000953822","body":"#### 思路\r\n* 递归\r\n*  左右子树分别递归\r\n* 注意边界条件\r\n\r\n#### 复杂度\r\n* 时间复杂度: `O(N)` ,N为两棵树的最小节点数；\r\n* 空间复杂度: `O(N)`。\r\n\r\n#### 代码\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not p and not q: #同时为空，true\r\n            return True\r\n        if not p or not q: #有一个先空了，false\r\n            return False\r\n        if p.val != q.val: #都没空，但值不等，false\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right)\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-curiosity":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991771477","body":"### 思路\ntraverse each digit of the `num` and `k` in reverse order and do add operation\nreverse the list and return\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        int p = num.length - 1;\n        List<Integer> list = new LinkedList<>();\n        while( p >= 0 || k > 0 || carry > 0) {\n            int cur = k % 10 + carry;\n            if(p >= 0) {\n                cur += num[p];\n                p--;\n            }\n            list.add(cur % 10);\n            carry = cur / 10;\n            k = k / 10;\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- TC = O(max(M,N)), M is the length of num, N is the numbers of digits of k\n- SC = O(1), use constant space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991983018","body":"### 思路\niterate twice, from left to right, then from right to left, \nalways update the shortest distance\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\n        int len = s.length();\n        int loc = -20000;   // -2*10^4\n        char[] ch = s.toCharArray();\n\n        int[] ans = new int[len];\n        \n        // from left to right\n        for(int i = 0; i < len; ++i) {\n            if( ch[i]  == c ) {\n                loc = i;\n                ans[i] = 0;\n            } else {\n                ans[i] = i - loc;\n            }\n        }\n        \n        // from right to left\n        for(int i = len - 1; i >= 0; --i) {\n            if( ch[i]  == c ) {\n                loc = i;\n            } else {\n                ans[i] = Math.min(ans[i], Math.abs(loc - i));\n            }\n        }\n        \n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(N)\n- Space Complexitty = O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992699387","body":"### 思路\nusing array to simulate stack\n\n### 代码\n\n\n```java\n\nclass CustomStack {\n\n    private int[] stack;\n    private int pointer;\n    private int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.pointer = 0;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if( pointer < maxSize ) {\n            stack[pointer] = x;\n            ++pointer;\n        }\n    }\n    \n    public int pop() {\n        if( pointer > 0 ) {\n            --pointer;\n            return stack[pointer];\n        } else {\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k, pointer);\n        for(int i = 0; i < min; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty\n\t- SC = O(maxSize)\n\t- CustomStack O(1)\n\t- push TC = O(1)\n\t- pop TC = O(1)\n\t- increment TC = O(k)\n- Space Complexitty = O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993881706","body":"### 思路\n+ use stack, build string from inner\n+ iterate the string S\n\t+ if current character is digit, add to num\n\t+ if current character is letter, add to current string\n\t+ if current character is open square brackets, push num and current string into stack\n\t+ if current character is close square brackets, pop and build a new string\n\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        // stack for number\n        Stack<Integer> numStack = new Stack<>();\n        // stack for string\n        Stack<StringBuilder> stringStack = new Stack<>();\n        int num = 0;\n        for(char c: s.toCharArray()) {\n            if(Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } else if(c == '[') {\n                stringStack.add(sb);\n                numStack.add(num);\n                sb = new StringBuilder();\n                num = 0;\n            } else if(Character.isLetter(c)) {\n                sb.append(c);\n            } else {\n                StringBuilder strTemp = stringStack.pop();\n                int numTemp = numStack.pop();\n                for(int i = 0; i < numTemp; i++) {\n                    strTemp.append(sb);\n                }\n                sb = strTemp;\n            }\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(S), S the length of the decoded string\n- Space Complexitty = O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995507741","body":"### 思路\n+ Two Stacks\n\n### 代码\n\n\n```java\n\nclass MyQueue {\n\n    private Stack<Integer> s1 = new Stack<Integer>();\n    private Stack<Integer> s2 = new Stack<Integer>();\n    private int front;\n\n    public MyQueue() {\n        this.s1 = s1;\n        this.s2 = s2;\n    }\n    \n    // push element x to the back of queue\n    public void push(int x) {\n        if (s1.empty()) {\n            front = x;\n        }\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(!s2.empty()) {\n            return s2.peek();\n        }\n        return front;\n    }\n\n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n**复杂度分析**\n- Time Complexitty \n\t- Push - O(1) per operation\n\t- Pop - 摊还复杂度 O(1) per operation\n\t- peek - O(1) per operation.\n\t- empty - O(1) per operation.\n- Space Complexitty = O(N)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996478503","body":"### 思路\n+ the division of each chunks could be baesd on local maximum\n+ iterate arr:\n     + when stack is empty, push arr[i]\n     + when arr[i] >= stack.peek(). a new chunks could start with arr[i], so push arr[i]\n     + when arr[i] < stack.peek()\n\t     + must be included in previous chunck which can put arr[i] into correct order\n\t     + pop stack until find a num less than arr[i] or the stack is empty\n     + return the size of stack\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int i = 0; i < arr.length; i++) {\n            if(stack.isEmpty() || arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                int head = stack.pop();\n                while(!stack.isEmpty() && arr[i] < stack.peek() ) {\n                    stack.pop();\n                }\n                stack.push(head);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(N)\n- Space Complexitty = O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997135608","body":"### 思路\n\n\n### 代码\n\n\n```java\n\nclass Solution {\n  public ListNode rotateRight(ListNode head, int k) {\n    if (head == null) return null;\n    if (head.next == null) return head;\n\n    ListNode old_tail = head;\n    int n;\n    for(n = 1; old_tail.next != null; n++)\n      old_tail = old_tail.next;\n    old_tail.next = head;\n\n    // find new tail : (n - k % n - 1)th node\n    // and new head : (n - k % n)th node\n    ListNode new_tail = head;\n    for (int i = 0; i < n - k % n - 1; i++)\n      new_tail = new_tail.next;\n    ListNode new_head = new_tail.next;\n\n    new_tail.next = null;\n\n    return new_head;\n  }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(N)\n- Space Complexitty = O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997283657","body":"### 思路\nrecursion\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n```\n\n**复杂度分析**\n- Time Complexitty = O(N)\n- Space Complexitty = O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997589084","body":"### 思路\n\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(NlogN)\n- Space Complexitty = O(logN)\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001067793","body":"### 思路\nDFS\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(N)\n- Space Complexitty = O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yrtryannn":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991794054","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n        for(int i = n - 1;i >= 0;i--){\n            int sum = A[i] + K % 10;       \n            K /= 10;    \n            if(sum >= 10){\n                K++;                       \n                sum -= 10;                  \n            }\n            res.add(sum);\n        }\n        while (K > 0) {\n            res.add(K % 10);\n            K /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992055428","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        if (list.isEmpty()) {\n            return new int[0];\n        }\n        int[] res = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            if (list.contains(i)) {\n                res[i] = 0;\n            } else {\n                res[i] = rearchMinDistance(i, list);\n            }\n        }\n        return res;\n    }\n\n    public int rearchMinDistance(int index, ArrayList<Integer> list) {\n        int minValue = 10000;\n        for (int i = 0; i < list.size(); i++) {\n            minValue = Math.min(minValue, Math.abs(index - list.get(i)));\n        }\n        return minValue;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992989378","body":"```\nclass CustomStack {\n\n    int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995218550","body":"```\nclass MyQueue {\n    public Stack<Integer> a;\n    puiblic Stack<Integer> b;\n    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997155912","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null|| k == 0)  return head;\n        int n = 0;\t\t\t  \n        ListNode tail = null; \n        for(ListNode p = head; p != null ; p = p.next){\n            tail = p;\n            n++;\n        }\n        k %= n;\n        ListNode p = head;\n        for(int i = 0; i < n - k - 1; i++)  p = p.next; \n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;  \n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998453215","body":"```\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000573880","body":"```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int leftHeight = maxDepth(root.left);\n            int rightHeight = maxDepth(root.right);\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zwmanman":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991814629","body":"### 思路\nCalculate the total sum in the array, each number * 10^idx.\nThen sum up with the k \nOut each digit in the total sum\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        idx = len(num) - 1\n        sum_num = 0\n        res = []\n        for number in num:\n            sum_num = number * (10**idx) + sum_num\n            idx -= 1\n            \n        sum_num += k\n        \n        for digit in (str(sum_num)):\n            res.append(int(digit))\n            \n        return res\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，需要遍历数组。\n- 空间复杂度：O(N)，存储返回的数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991959149","body":"### 思路\nIterate s and store index of c in a dictionary\nIterate s again and calculate the min diff of c index in dictionary \n\n### 代码\n\n\n```Python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        dictC = {}\n        dictC[c] = []\n        res = []\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                dictC[c].append(i)\n        \n        for i in range(len(s)):\n            res.append(min([abs(i - ele) for ele in dictC[c]]))\n            \n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(NM)，其中 N 为数组长度, M为dictionary长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992839893","body":"### 思路\n\nCreate a stack and a global variable to keep the max size\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = []\n        self.maxEle = maxSize\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxEle:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack) > 0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(min(len(stack), k))，为增量k和数组长度中的较小值\n- 空间复杂度：O(Maxsize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993933745","body":"### 思路\n\nUse a stack to track element in the string. \n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        \n        \n        for item in s:\n            if item != ']':\n                stack.append(item)\n            else:\n                repeat_str = ''\n                repeat_num = ''\n                while stack and stack[-1] != '[':\n                    repeat_str = stack.pop() + repeat_str\n                    \n                stack.pop()\n                \n                while stack and stack[-1] in ('0123456789'):\n                    repeat_num = stack.pop() + repeat_num\n                \n                stack.append(int(repeat_num) * repeat_str)\n                \n        return \"\".join(stack)\n                \n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为字符串长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995350001","body":"### 思路\n\nUse two stack\n1. push: Everything will be pushed to stack1 first\n2. pop: while stack2 is not empty, pop() from stack2, else move everything to stack2\n3.peek: if stack is not empty, return last element from stack2 else return front\n3. empty: when both stack1 and stack2 are empty then it is empty\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n        self.front = None\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack1) == 0:\n            self.front = x\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2) == 0:\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            return self.front\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) for pop()，O(1) for other method\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996387783","body":"### 思路\n\n1.use a dict to store each occurrence of a number\n2. count the different of occurrence \n3.when there is no diff ans + 1 \n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        dict1 = collections.defaultdict(int)\n        non_zero_count = 0\n        ans = 0\n        for a, b in zip(arr, sorted(arr)):\n            if dict1[a] == 0:\n                non_zero_count += 1\n            if dict1[a] == -1:\n                non_zero_count -= 1\n            dict1[a] += 1 \n            \n            if dict1[b] == 0:\n                non_zero_count += 1\n            if dict1[b] == 1:\n                non_zero_count -= 1\n            dict1[b] -= 1\n            \n            if non_zero_count == 0:\n                ans += 1\n\n                \n        return ans\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996926331","body":"### 思路\n1. Calculate length of the list\n2. find tail and last k+1 node\n3. connect tail and head\n4. cut k+1 node with next\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next or k == 0:\n            return head\n        \n        length = 1\n        \n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n            \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        fast = head\n        slow = head\n        \n        while fast.next:\n            if k <= 0:\n                slow = slow.next\n            k -= 1\n            fast = fast.next\n            \n        temp = slow.next\n        slow.next = None\n        fast.next = head\n        \n        return temp\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997320027","body":"### 思路\n\ncreate dummy node\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode()\n        dummy.next = head.next\n        pre = dummy\n        \n        while head and head.next:\n            nextNode = head.next\n            n_next = nextNode.next\n            \n            nextNode.next = head\n            head.next = n_next\n            pre.next = nextNode\n            \n            pre = head\n            head = n_next\n            \n            \n        return dummy.next\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为List长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997446755","body":"###思路\n1.fast and slow node to find mid point\n2.left will be left tree and right will be right tree\n\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n        \n        return self.dfs(head, None)\n        \n        \n    def dfs(self, head, tail):\n        if head == tail:\n            return None\n        slow = head\n        fast = head\n        \n        while fast != tail and fast.next != tail:\n            slow = slow.next\n            fast = fast.next.next\n            \n        root = TreeNode(slow.val)\n        root.left = self.dfs(head, slow)\n        root.right = self.dfs(slow.next, tail)\n        return root\n        \n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998170719","body":"### 思路\r\n1. two pointers each starts from listA and listB\r\n2. lenght(listA) + length(listB) = length(listB) + length(listA)\r\n3. when there is intersection, the common node is where they met\r\n\r\n### 代码\r\n\r\n\r\n```python（此处换成你的语言，比如js，py 等）\r\n\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        p1 = headA\r\n        p2 = headB\r\n        \r\n        while p1 != p2:\r\n            if not p1:\r\n                p1 = headB\r\n            else:\r\n                p1 = p1.next\r\n                \r\n            if not p2:\r\n                p2 = headA\r\n            else:\r\n                p2 = p2.next\r\n        return p1\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为两个链表长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999127924","body":"### 思路\n\nUsing a set to track all the node, if it shows again, return that node\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        \n        pointer = head\n        helper = set()\n        \n        while head != None:\n            if head in helper:\n                return head\n            else:\n                helper.add(head)\n                head = head.next\n               \n        return None\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为LinkedList长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999891152","body":"### 思路\n\n1. use a dictionary to store key: node \n2. use a doubly linked list to track latest used node\n3. every operation will cause the node remove from current location and add to the end of linked list\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\n（此处撰写代码）\nclass Node(object):\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.prev = None\n\nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.dict = {}\n        self.head = Node(-1, -1)\n        self.tail = Node(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key in self.dict:\n            node = self.dict[key]\n            self._remove(node)\n            self._add(node)\n            return node.val\n        else:\n            return -1\n            \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.dict:\n            self._remove(self.dict[key])\n        node = Node(key, value)\n        self._add(node)\n        self.dict[key] = node\n        if len(self.dict) > self.capacity:\n            node = self.head.next\n            self._remove(node)\n            del self.dict[node.key]\n            \n    def _remove(self, node):\n        p = node.prev\n        n = node.next\n        p.next = n\n        n.prev = p\n        \n        \n        # h, 1, 2, 3 t\n    def _add(self, node):\n        p = self.tail.prev\n        p.next = node\n        node.prev = p\n        node.next = self.tail\n        self.tail.prev = node\n        \n        \n        \n        \n        \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N Capacity。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000405401","body":"### 思路\n\nRecursion\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.dfs(root)\n        \n        \n    def dfs(self, root):\n        if not root:\n            return 0\n        \n        l = self.dfs(root.left)\n        r = self.dfs(root.right)\n        \n        return max(l, r) + 1\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logn)，其中 N Node. number。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000890993","body":"### 思路\n1. First check input node(recursion exist)\n2. Check left subtree and right subtree\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        \n        if not p or not q:\n            return False\n        \n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n            \n       \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为Node个数。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001075803","body":"### 思路\n\n1. iterate until leaf node and calculate the sum on that path\n2. calculate left and right sum of that node\n\n### 代码\n\n\n```pthon（此处换成你的语言，比如js，py 等）\n（此处撰写代码）\n\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        return self.dfs(root, 0)\n        \n    def dfs(self, root, curr):\n        if not root:\n            return 0\n        \n        curr = curr * 10 + root.val\n        \n        if not root.left and not root.right:\n            return curr\n        \n        l = self.dfs(root.left, curr)\n        r = self.dfs(root.right, curr)\n\n        return l + r\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为Node个数。\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kmshui":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991820454","body":"```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def num_to_lst(n):\n            result = []\n            while n:\n                result.append(n % 10)\n                n = n // 10\n\n            return result[::-1]\n        \n        k_lst = num_to_lst(k)\n        i = len(num) - 1\n        j = len(k_lst) - 1\n        \n        result = []\n        \n        carry = 0\n        while i >= 0 or j >= 0 or carry:\n            left = num[i] if i >= 0 else 0\n            right = k_lst[j] if j >= 0 else 0\n            \n            s = left + right + carry\n            result.append(s % 10)\n            carry = s // 10\n            \n            i -= 1\n            j -= 1\n            \n        return result[::-1]\n```\nTime: O(max(n, m))\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992038994","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = [float('inf') for _ in range(len(s))]\r\n        right = [float('inf') for _ in range(len(s))]\r\n        \r\n        cur_min = float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                left[i] = 0\r\n                cur_min = 0\r\n            else:\r\n                cur_min += 1\r\n                left[i] = cur_min\r\n                \r\n        cur_min = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right[i] = 0\r\n                cur_min = 0\r\n            else:\r\n                cur_min += 1\r\n                right[i] = cur_min\r\n                \r\n        result = [min(left[i], right[i]) for i in range(len(s))]\r\n        \r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993139062","body":"```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.arr = [float('inf') for _ in range(maxSize)]\r\n        self.top = 0\r\n        self.size = maxSize\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top != self.size:\r\n            self.arr[self.top] = x\r\n            self.top += 1\r\n            \r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.top == 0:\r\n            return -1\r\n        ret = self.arr[self.top-1]\r\n        self.top -= 1\r\n        return ret\r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top > 0:\r\n            for i in range(min(k, self.top)):\r\n                self.arr[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994218980","body":"```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        \n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                unit = ''\n                while stack and stack[-1].isalpha():\n                    unit = stack.pop() + unit\n                stack.pop()\n\n                count = ''\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                stack.append(int(count) * unit)\n        \n        return ''.join(stack)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smilejohnson":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991822957","body":"1. 取 k 的最后一位 lastOfk\n2. 取 num 的最后一位 lastOfNum\n3. 如果 sum(lastOfNum + lastOfk + flag) 大于等于10，进位标记为1，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n4. 如果 sum(lastOfNum + lastOfk + flag) 小于10， 进位标记为0，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n5.  然后遍历完 num, k 并确保flag最后的值为 0\n\n``` java\nclass Solution {\n    // 取 k 的最后一位 lastOfk\n    // 取 num 的最后一位 lastOfNum\n    // 如果 sum(lastOfNum + lastOfk + flag) 大于等于10，进位标记为1，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n    // 如果 sum(lastOfNum + lastOfk + flag) 小于10， 进位标记为0，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n    // 然后遍历完 num, k 并确保flag最后的值为 0\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        // 遍历k\n        int index = num.length - 1; // num 的最后一位\n        int flag = 0; // 进位\n        int lastOfNum = 0;\n        int lastOfk = 0;\n        int sum = 0;\n        while (k > 0 && index >= 0) {\n            lastOfk = k % 10;\n            k /= 10;\n            lastOfNum = num[index--];\n            sum = lastOfk + lastOfNum + flag;\n            if (sum >= 10) {\n                flag = 1;\n                res.addFirst(sum % 10);\n            } else {\n                flag = 0;\n                res.addFirst(sum);\n            }\n        }\n        \n        while (k > 0) {\n            lastOfk = k % 10;\n            k /= 10;\n            sum = lastOfk + flag;\n            if (sum >= 10) {\n                flag = 1;\n                res.addFirst(sum % 10);\n            } else {\n                flag = 0;\n                res.addFirst(sum);\n            }\n           \n        }\n\n        while (index >= 0) {\n            lastOfNum = num[index--];\n            sum = lastOfNum + flag;\n            if (sum >= 10) {\n                flag = 1;\n                res.addFirst(sum % 10);\n            } else {\n                flag = 0;\n                res.addFirst(sum);\n            }\n        }\n\n        if (flag == 1) {\n            res.addFirst(1);\n        }\n\n        return res;\n    }\n}\n```\n\n---\n- Time: O(max(m,n)) \n- Space: O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992112172","body":"思路：字符串 s 中的两个 c 之间用双指针法算距离，第一个 c 和最后一个 c 直接循环计算\n---\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 1. 统计 c 的个数并且将 c 对应的值置为0\n        char[] chs = s.toCharArray();\n        int length = chs.length;\n        int[] res = new int[length];\n        List<Integer> boundaries = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            if (chs[i] == c) {\n                res[i] = 0;\n                boundaries.add(i);\n            } else {\n                res[i] = -1;\n            }\n        }\n        if (boundaries.isEmpty()) return res;\n        // 2. 值为0的下标，两两一对，利用双指针法将其范围内的值置为离其最近的举例\n        for (int i = 1; i < boundaries.size(); i++) {\n            getShortestDistance(res, boundaries.get(i - 1), boundaries.get(i));\n        }\n        // 3. 处理第一个0和最后一个0\n        int first = boundaries.get(0);\n        int value = 0;\n        while (first >= 0) {\n            res[first--] = value++;\n        }\n\n        int last = boundaries.get(boundaries.size() - 1);\n        value = 0;\n        while (last < length) {\n            res[last++] = value++;\n        }\n\n        return res;\n    }\n\n    // 计算数组在 [start,end] 范围内举例边界较短的举例\n    private void getShortestDistance(int[] nums, int start, int end) {\n        int value = 0;\n        while (start < end) {\n            nums[start++] = value;\n            nums[end--] = value;\n            value++;\n        }\n        if (start == end) nums[start] = value;\n    }\n}\n```\n---\n- Time: O(2N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993086622","body":"# 思路\n用数组模拟栈，从数组尾部添加、弹出，increase的时候，从第0个元素到第 min(k, arr.size) 元素增加 val\n\n# 代码\n```java\nclass CustomStack {\n    int capacity;\n    int count;\n    List<Integer> myStack;\n\n    public CustomStack(int maxSize) {\n        this.capacity = maxSize;\n        this.count = 0;\n        this.myStack = new LinkedList<>();\n\n    }\n\n    public void push(int x) {\n        if (this.count < this.capacity) {\n            this.count++;\n            this.myStack.add(x);\n        }\n    }\n\n    public int pop() {\n        if (this.count == 0) {\n            return -1;\n        }\n        // 弹出栈顶元素\n        int remove = this.myStack.remove(--this.count);\n        return remove;\n    }\n\n    public void increment(int k, int val) {\n        if (k > this.count) {\n            k = this.count;\n        }\n        for (int i = 0; i < k; i++) {\n            this.myStack.set(i, this.myStack.get(i) + val);\n        }\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994305942","body":"# 思路\n- 当前为 [ 时递归，并累加 num 此递归函数的返回值（内层字符串）\n- 当前为 ] 时，返回当前 res\n- 当前为数字时更新 num\n- 当前为字母时更新 res\n\n# 代码\n```java\nclass Solution {\n    int index;\n    public String decodeString(String s) {\n        if (s == null || s.length() == 0) return s;\n        char[] str = s.toCharArray();\n        this.index = 0;\n        StringBuilder res = dfs(str);\n        return res.toString();\n    }\n\n    // 当前为 [ 时递归，并累加 num 此递归函数的返回值（内层字符串）\n    // 当前为 ] 时，返回当前 res\n    // 当前为数字时更新 num\n    // 当前为字母时更新 res\n    private StringBuilder dfs(char[] str) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        while (index < str.length) {\n            if (str[index] >= '0' && str[index] <= '9') {\n                num = 10 * num + str[index] - '0';\n            } else if (str[index] == '[') {\n                index++;\n                StringBuilder inside = dfs(str);\n                while (num-- > 0) {\n                    res.append(inside);\n                }\n                num = 0;\n            } else if (str[index] == ']') {\n                break;\n            } else {\n                res.append(str[index]);\n            }\n            index++;\n        }\n        return res;\n    }\n}\n```\n\n# 复杂度\n- Time : O(N)\n- Space: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996760480","body":"# 思路\n将数组与排序之后的标准数组做对比，如果当前数组遍历到的位置数字出现次数与标准数组一致，我们就可以将其看作一个块，将统计 map 都清空，继续统计\n\n# 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // [1,1,0,0,1]\n        // [0,0,1,1,1]\n        int[] standard = arr.clone();\n        Arrays.sort(standard);\n        Map<Integer, Integer> mapStandard = new HashMap<>();\n        Map<Integer, Integer> mapChunks = new HashMap<>();\n        int res = 0;\n        for (int i = 0; i < arr.length; i++) {\n            mapChunks.put(arr[i], mapChunks.getOrDefault(arr[i], 0) + 1);\n            mapStandard.put(standard[i], mapStandard.getOrDefault(standard[i], 0) + 1);\n            if (mapStandard.equals(mapChunks)) {\n                mapChunks.clear();\n                mapStandard.clear();\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n# 时间复杂度\n- Time: O(n)\n- Space: O(n)\n但是由于用了额外的map，而且涉及大量的查询、插入和清空的操作，所以实际执行效率会比较慢","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997156579","body":"# 思路\n由栗子可知，当 k < n(n 为链表中的节点个数)时，是将最后 k 个节点拿到头部去；如果 k > n，则将 k % n 个节点拿到头部\n算法步骤：\n1. 计算链表节点个数 n \n2. 如果 k == 0 或者 k % n == 0，即如果不需要移动或者移动后与原链表相同，则直接返回原链表的头\n3. 计算实际需要挪动的第几个节点 int indexOfNewHaed = count - k % count; 由于断开链表的时候我们需要前一个节点，所以也定义了 prev 指针\n4. 从链表头部出发，走 indexOfNewHaed 步，则 curr 指针来到了新链表的头部，prev 断开与 curr 的连接\n5. curr 继续往前走，当 curr 走到 null 时，prev 来到了原来链表的尾部，将 prev.next 指向原来链表的头几点即将新链表串了起来\n\n# 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null)\n            return null;\n        \n        int count = 0; // 统计链表节点个数\n        ListNode curr = head;\n        while (curr != null) {\n            curr = curr.next;\n            count++;\n        }\n        if (k == 0 || k % count == 0)\n            return head;\n        \n        int indexOfNewHaed = count - k % count;\n        ListNode prev = null;\n        curr = head;\n        while (indexOfNewHaed-- > 0) {\n            prev = curr;\n            curr = curr.next;\n        }\n\n        // 此时 curr 来到了新的头部\n        // 先断开之前的连接\n        prev.next = null;\n        ListNode headNew = curr;\n        while (curr != null) {\n            prev = curr;\n            curr = curr.next;\n        }\n\n        prev.next = head;\n\n        return headNew;\n\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997307266","body":"# 思路\n递归，递归函数的返回值是当前两个节点反转后的头，入参数为原来链表中两个节点的头。首先两个节点完成反转，记录新的头和新的尾，新的尾指向下一对的头（用递归生成），返回当前这一段的新头\n\n# 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // 到达尾部，返回\n        if (head == null || head.next == null)\n            return head;\n        \n        ListNode headNew = head.next;\n        ListNode next = headNew.next;\n        headNew.next = head;\n        head.next = swapPairs(next);\n\n        return headNew;\n    }\n}\n```\n\n# 复杂度\n- Time: O (N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997594386","body":"# 思路\r\n1. 首先找到根节点对应的链表节点的位置，通过遍历链表节点数量 cnt，cnt 除以 2 即为根节点的位置\r\n2. 走到根节点位置，构造根节点 root , 并断开左右连接，递归构造左右子树\r\n\r\n# 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null)\r\n            return null;\r\n        // 统计链表中节点个数\r\n        int cnt = 0;\r\n        ListNode curr = head;\r\n        while (curr != null) {\r\n            curr = curr.next;\r\n            cnt++;\r\n        }\r\n        // 如果能够构造成BST，则树的根节点在链表中的下标\r\n        int indexRoot = cnt / 2;\r\n        if (indexRoot == 0) {\r\n            return new TreeNode(head.val);\r\n        }\r\n        \r\n        // 来到根节点所对应的链表中的节点位置\r\n        ListNode prev = null;\r\n        curr = head;\r\n        while (indexRoot-- > 0) {\r\n            prev = curr;\r\n            curr = curr.next;\r\n        }\r\n        TreeNode root = new TreeNode(curr.val);\r\n        \r\n        // 构造左子树\r\n        prev.next = null; // 断链\r\n        root.left = sortedListToBST(head);\r\n\r\n        // 构造右子树\r\n        ListNode right = curr.next;\r\n        curr.next = null; // 断链\r\n        root.right = sortedListToBST(right);\r\n\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n- Time：O(NlogN)\r\n- Space：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998467151","body":"# 思路\n先分别统计链表 A、B 的节点个数 countA,countB，长的那个先走 abs(countA - countB)步，然后两个链表一起走，直到相遇(返回相遇点)或有一个走完(返回null)\n\n# 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // 思路：先分别统计链表 A、B 的节点个数 countA,countB，长的那个先走 abs(countA - countB)步，然后两个链表一起走，直到相遇(返回相遇点)或有一个走完(返回null)\n        if (headA == null || headB == null)\n            return null;\n\n        int countA = 0, countB = 0;\n        ListNode currA = headA, currB = headB;\n        while (currA != null) {\n            countA++;\n            currA = currA.next;\n        }\n        while (currB != null) {\n            countB++;\n            currB = currB.next;\n        }\n\n        // 长的链表先走 diff 步\n        int diff = 0;\n        currA = headA;\n        currB = headB;\n        if (countA > countB) {\n            diff = countA - countB;\n            while (diff-- > 0) currA = currA.next;\n        } else {\n            diff = countB - countA;\n            while(diff-- > 0) currB = currB.next;\n        }\n\n        // 然后两个链表一起走，直至相遇\n        while (currA != null && currB != null) {\n            if (currA == currB)\n                return currA;\n            currA = currA.next;\n            currB = currB.next;\n        }\n\n        // 未找到相遇点\n        return null;\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999284957","body":"# 思路思路：\n快慢指针，快指针一次走两步，慢指针一次走一步，当两指针相遇时，快指针复位，复位之后快慢指针每次走一步直至相遇，相遇点就为所求\n\n# 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        // 思路：快慢指针，快指针一次走两步，慢指针一次走一步，当两指针相遇时，快指针复位，复位之后快慢指针每次走一步直至相遇，相遇点就为所求\n        if (head == null)\n            return head;\n\n        ListNode fast = head, slow = head;\n        boolean begin = true;\n        while (begin || fast != slow) {\n            begin = false;\n            fast = fast.next;\n            if (fast == null)  return null;\n            fast = fast.next;\n            if (fast == null) return null;\n            slow = slow.next;\n        }\n\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n \n        return slow;\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000054293","body":"# 思路\n- 双向链表 + HashMap\n- 建议背下来\n# 代码\n```java\nclass LRUCache {\n\n    class DoubleList {\n        int key;\n        int value;\n        DoubleList prev;\n        DoubleList next;\n\n        public DoubleList() {}\n\n        public DoubleList(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n    }\n\n    Map<Integer, DoubleList> cache;\n    int capacity;\n    int count;\n    DoubleList dummyHead;\n    DoubleList dummyTail;\n\n\n    public LRUCache(int capacity) {\n        cache = new HashMap<>();\n        this.capacity = capacity;\n        this.count = 0;\n        this.dummyHead = new DoubleList(-1, -1);\n        this.dummyTail = new DoubleList(-1, -1);\n        this.dummyHead.next = this.dummyTail;\n        this.dummyTail.prev = this.dummyHead;\n    }\n\n    private void delete(DoubleList node) {\n        DoubleList prev = node.prev;\n        DoubleList next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        this.count--;\n    }\n\n    private void add2Head(DoubleList node) {\n        DoubleList headOld = this.dummyHead.next;\n        this.dummyHead.next = node;\n        node.prev = this.dummyHead;\n        node.next = headOld;\n        headOld.prev = node;\n        this.count++;\n    }\n\n    private DoubleList deleteLast() {\n        DoubleList tail = this.dummyTail.prev;\n        // 倒数第二个节点为新的尾\n        DoubleList tailSecond = tail.prev;\n        tailSecond.next = this.dummyTail;\n        this.dummyTail.prev = tailSecond;\n        this.count--;\n        return tail;\n    }\n    \n    public int get(int key) {\n        if (this.cache.containsKey(key)) {\n            DoubleList node = cache.get(key);\n            delete(node);\n            add2Head(node);\n            return node.value;\n        } else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        DoubleList node = new DoubleList(key, value);\n        // 存在\n        if (cache.containsKey(key)) {\n            DoubleList toDelete = cache.get(key);\n            delete(toDelete);\n            add2Head(node);\n        } else { // 不存在\n            // 超容量\n            if (this.count >= this.capacity) {\n                DoubleList last = deleteLast();\n                cache.remove(last.key);\n            }\n            add2Head(node);\n        }\n        cache.put(key, node);\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space : O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000648963","body":"# 思路\n- 递归：左右子树的最大深度加上本层的深度\n- 迭代：只有下一层还有节点，就往下遍历\n\n# 代码\n\n## 递归\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n\n        int leftDepth = maxDepth(root.left);\n        int rightDepth = maxDepth(root.right);\n\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}\n```\n\n\n## 迭代\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int depth = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            depth++;\n            while (size-- > 0) {\n                TreeNode node = queue.poll();\n                if (node.left != null)  queue.offer(node.left);\n                if (node.right != null)  queue.offer(node.right);\n            }\n        }\n\n        return depth;\n    }\n}\n```\n\n\n# 复杂度\n- Time: O(N)\n- Space: 递归O(height)  迭代O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000987439","body":"# 思路\n- 递归\n- 退出条件：如果两个树都为空，那么我们认为它们是同一棵树；如果（在两个树不都为空的情况下）仅有一颗树为空，则它们不是同一棵树\n- 单层判断逻辑：两个根节点的值是否相同\n- 递归逻辑：递归判断左右子树\n\n# 代码\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null)\n            return true;\n        if (p == null || q == null)\n            return false;\n\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n# 复杂度\n- Time: O(min(Np, Nq))\n- Space: O(min(Hp, Hq))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001100547","body":"# 思路\n到达一个节点时，计算累加和，并加该累加和继续往下传递。当到达叶子节点时，将该路径上的累加和加到最终的 res 中\n\n# 代码\n```java\nclass Solution {\n    int res;\n    \n    public int sumNumbers(TreeNode root) {\n        res = 0;\n        if (root == null)\n            return res;\n        dfs(root, 0);\n        return res;\n        \n    }\n\n    private void dfs(TreeNode node, int sum) {\n        if (node == null)\n            return;\n\n        sum = 10 * sum + node.val;\n\n        // 到达叶子节点\n        if (node.left == null && node.right == null) {\n            res += sum;\n        }\n\n        dfs(node.left, sum);\n        dfs(node.right, sum);\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space: O(H)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzgwebgit":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991824949","body":"思路\n数组尾数与k 逐项相加，大于10 则进位\n\n代码\n\nvar add = function(num, k) {\n    const res = [];\n    const len = num.length;\n    for (let i = len - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992185429","body":"思路\n找到C在S中的所有索引，通过对比S[i]在C Array中最小的偏移量得到结果更新arr[i]。\n\n代码\njavascript\nvar shortestToChar = function(s, c) {\n   const sArr = s.split('')\n   const len = sArr.length\n   const resArr = []\n   const arr = []\n   for(let i = 0;i<len;i++){\n       if(s[i] == c){\n          resArr.push(i) \n       }\n   }\n   for (let i = 0; i < len; i++) {\n       arr[i] =resArr.reduce((cur, item) => {\n            return Math.min(cur, Math.abs(i - item))\n        },100)\n    }\n    return arr\n};\n**复杂度分析**\n- 时间复杂度：O(MN)，其中N为S的length，M为C在S中的数量。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993408129","body":"思路\n利用js数组的push和pop\n\n代码\nvar CustomStack = function(maxSize) {\n    this.size = maxSize\n    this.list = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if(this.list.length<this.size){\n        this.list.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n   return this.list.length?this.list.pop():'-1'\n};\n\nCustomStack.prototype.increment = function(k, val) {\n   let len = Math.min(k, this.list.length);\n    for (let i = 0; i < len; i++) {\n        this.list[i] += val;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994812688","body":"思路：找到第一个[计数，当找到对应数量的]后，截取循环前面数字次，然后替换掉原字符串，重复上面步骤，直到没有 [ ] 为止\n\n\nvar decodeString = function(s) {\n    while (/\\d\\[.*?\\]/g.test(s)) {\n        const len = s.length;\n        let i = 0;\n        let n = 0,\n            start = 0,\n            end = 0;\n        for (i; i < len; i++) {\n            if (s[i] === '[') {\n                n++;\n                if (n === 1) {\n                    start = i;\n                }\n            } else if (s[i] === ']') {\n                n--;\n                if (n === 0) {\n                    end = i;\n                    const str = s.slice(start, end + 1);\n                    const num = parseInt(s.match(/\\d.*/) &&\n                        s.match(/\\d.*/)[0]);\n                    s = s.replace(str, (e) => {\n                        let strP = ''\n                        for (let index = 0; index < num; index++) {\n                            strP += str.slice(1, str.length - 1);\n                        }\n                        return strP;\n                    });\n                    s = s.slice(0, start - num.toString().length) + s.slice(start);\n                    break;\n                }\n            }\n        }\n    }\n    return s;\n};\n复杂度：O(n2)\n空间度：0（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995821059","body":"### 思路\n\n 利用数组的 shift push 和数组的属性一次进行操作\n\n### 代码\n\n```\nvar MyQueue = function() {\n  this.list = []\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.list.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.list.length>0?this.list.shift():'null'\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n   return this.list.length>0?this.list[0]:'null'\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.list.length>0?false:true\n};\n```\n### 复杂度\n时间复杂度： o(N)\n空间复杂度： o(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996586073","body":"### 思路\n找到数组左边最小值，然后依次对比，\n### 代码\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const minWithIndex = new Map();\n    for(let i = arr.length-1; i > -1; i--){\n        if(i == arr.length-1){\n            minWithIndex.set(i, arr[i]);\n        }\n        else{\n            minWithIndex.set(i, Math.min(minWithIndex.get(i+1), arr[i]));\n        }\n    }\n    let blocks = 1, max = 0;\n    for(let i = 0; i < arr.length; i++){\n        max = arr[max]>=arr[i]? max:i;\n        if(arr[max] <= minWithIndex.get(i+1)){\n            blocks++;\n        }\n    }\n    return blocks;\n};\n```\n### 复杂度\n时间复杂度：o（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997187126","body":"### 思路\n\n通过设置链表长度，头部指针、尾部指针移动指针\n\n### 代码\n\n```\nvar rotateRight = function(head, k) {\n    if(!head) return head;\n    let preNode = head;\n    let len = 1;\n    while(preNode.next!=null){\n        len++;\n        preNode = preNode.next;\n    }\n    preNode.next = head;\n    let curNode = head;\n     k = k % len;\n    for(let i = 0; i < len - k - 1; i++){\n        curNode = curNode.next;\n    }\n    let head2 = curNode.next;\n    curNode.next = null;\n    return head2\n};\n```\n### 复杂度\n时间复杂度：o(n)\n空间复杂度：o(1）","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001085065","body":"### 解题思路\n\n使用DFS，依次对比树的根节点、左子树和右子树\n\n### 代码\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function (root) {\n    return dfs(root, 0)\n};\n\nvar dfs = function (node, preSum) {\n    if (!node) {\n        return 0;\n    }\n    let sum = preSum * 10 + node.val;\n    if (!node.left && !node.right) {\n        return sum\n    } else {\n        return dfs(node.left, sum) + dfs(node.right, sum)\n    }\n}\n```\n### 复杂度\n时间复杂度：o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brent-liu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825083","body":"### 思路\n\t1. 创造一个空列表，用来存储结果\n\t2. 取出num列表的每一个数字，按照位次和K对应的位次相加，如果超过10就进位，获得num和k在每一个位次上的和\n\t3. 将每一位次的和按照相应的顺序append到list中，就得到结果\n### 代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n-1; i >= 0; --i){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                k ++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;    \n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(max(O, logk)) \n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992112514","body":"### 思路\n\t1. 显示字符串s中存在字符c的位置i\n\t2. 从前往后遍历字符串s，记录每个位置从前往后数与i的距离\n\t3. 从后往前遍历字符串s，记录每个位置从后往前数与s的距离\n\t4. 取两个距离取最小值\n\n### 代码\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993560211","body":"### 思路\n\t1. 用数组来模拟栈，规定数字进来必须从最后一个index位进来，从最后一个index位出去。\n\t2. 栈顶位置其实就是ind= -1时的值，找一个变量记录栈顶位置即可\n\n### 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n### 复杂度分析\n- 时间复杂度：O(k)\n- 空间复杂度：O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994871300","body":"### 思路\n\t递归，推出BNF\n### 代码\nclass Solution {\n    String src;\n    int ptr;\n\n    public String decodeString(String s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n\n    public String getString() {\n        if (ptr == src.length() || src.charAt(ptr) == ']') {\n            // String -> EPS\n            return \"\";\n        }\n\n        char cur = src.charAt(ptr);\n        int repTime = 1;\n        String ret = \"\";\n\n        if (Character.isDigit(cur)) {\n            // String -> Digits [ String ] String\n            repTime = getDigits(); \n            ++ptr;\n            String str = getString(); \n            ++ptr;\n            while (repTime-- > 0) {\n                ret += str;\n            }\n        } else if (Character.isLetter(cur)) {\n            // String -> Char String\n            ret = String.valueOf(src.charAt(ptr++));\n        }\n        \n        return ret + getString();\n    }\n\n    public int getDigits() {\n        int ret = 0;\n        while (ptr < src.length() && Character.isDigit(src.charAt(ptr))) {\n            ret = ret * 10 + src.charAt(ptr++) - '0';\n        }\n        return ret;\n    }\n}\n\n### 复杂度分析\n- 时间复杂度：O(S)\n- 空间复杂度：O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995925088","body":"### 思路\n\t用双向链表来实现push和pop\n### 代码\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<> ();\n    Stack<Integer> popStack = new Stack<> ();\n\n    public MyQueue() {\n\n    }\n\n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n\n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n\n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n \n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996807382","body":"### 思路\n\t滑动窗口\n### 代码\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n \n### 复杂度分析\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998881943","body":"### 思路\n\t利用哈希表储存链表headA的各个节点，遍历链表headB，遍历链表headB的各个节点，判断节点是否在哈希表中\n### 代码\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode temp = headA;\n        while (temp != null) {\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while (temp != null) {\n            if (visited.contains(temp)) {\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n \n### 复杂度分析\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999280811","body":"### 思路\n\t利用哈希表储存链表的各个节点，遍历链表，一旦遍历时候发现这个节点之前遍历过，那就说明有环。\n### 代码\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hdyhdy":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825388","body":"思路：\n首先设立一个存放答案的切片。\n接着让数据数组从最后一位开始向前遍历，同时与k数的余数相加。\n相加完判断该值的大小，如果大于十输入到答案切片的时候要减十。\n最后再对答案切片做一个反转。\n\n```\nfunc addToArrayForm(num []int, k int) []int {\n    ans := make([]int,0)\n    for i := len(num) - 1; i >=0; i -- {\n        tem := num[i] + k % 10\n        k = k / 10\n        if tem >= 10 {\n            ans = append(ans,tem - 10)\n            k ++ \n        }else {\n            ans = append(ans,tem )\n        }   \n    }\n    for ; k > 0; k /= 10 {\n        ans = append(ans, k%10)\n    }\n    reverse(ans)\n    return ans \n}\n\nfunc reverse(num []int) {\n    for i, n := 0, len(num); i < n/2; i++ {\n        num[i], num[n-1-i] = num[n-1-i], num[i]\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992030869","body":"思路：两次遍历，前后遍历，设立更新目标字符的位置。然后在两次遍历得出的相对位置中找到最小值。\n```\nfunc shortestToChar(s string, c byte) []int {\n    n := len(s)\n    res := make([]int, n)\n    left, right := math.MinInt32/2, math.MaxInt32/2\n\n    for i :=0; i < n ;i++ {\n        if s[i] == c{\n            left = i\n        } \n        res[i] = i - left\n    }\n    for i := n-1;i >= 0;i -- {\n        if s[i] == c {\n            right = i\n        }\n        res[i] = min(res[i], right-i)\n    }\n    return res\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }else {\n        return a\n    }\n}\n```\n时间空间复杂度都为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993081170","body":"思路：结构体添加一个变量c，用于记录需要操作的位置。push和pop需要注意的地方在注意变量c在不同值的情况下操作是不一样的。\n```\ntype CustomStack struct {\n    stack []int\n    c int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        stack : make([]int,maxSize),\n        c : 0,\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.c < len(this.stack){\n        this.stack[this.c] = x\n        this.c ++ \n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if this.c != 0 {\n\t\tthis.c--\n\t\treturn this.stack[this.c]\n\t}\n\treturn -1\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    if k > this.c {\n\t\tfor i := 0; i < this.c; i++ {\n\t\t\tthis.stack[i] += val\n\t\t}\n\t} else {\n\t\tfor i := 0; i < k; i++ {\n\t\t\tthis.stack[i] += val\n\t\t}\n\t}\n\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n复杂度：\n时间：初始化、Pop和Push都为1，inc循环，所以最多为k\n空间：创建了maxsize大小的，所以空间为maxsize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994311212","body":"这道题的思路是用栈去解决。\n首先设立两个栈，一个放数字，一个放字符。\n然后分条件操作。如果遇到字符，就把连续的字符保留下来。如果是遇到数字的话，那么首先将数字保留。如果遇到了【符号，那么就首先将字符和数字压住栈，接着把字符和数字保留的变量清零。如果遇到了】的话，那么就首先把栈中最顶的元素压出来，然后再将压入栈的元素与当前保留的字符相加。\n```\nfunc decodeString(s string) string {\n    numStack := []int{}\n    strStack := []string{}\n    num := 0\n    result := \"\"\n    for _, char := range s {\n        if char >= '0' && char <= '9' {\n            n, _ := strconv.Atoi(string(char))\n            num = num*10 + n\n        }else if char == '[' {\n            strStack = append(strStack,result)\n            result = \"\"\n            numStack = append(numStack,num)\n            num = 0 \n        }else if char == ']' {\n            count := numStack[len(numStack)-1]\n            numStack = numStack[:len(numStack)-1]\n            str := strStack[len(strStack)-1]\n            strStack = strStack[:len(strStack)-1]\n            result = string(str) + strings.Repeat(result, count)\n        }else {\n            result += string(char)\n        }\n    }\n    return result\n}\n```\n空间复杂度为n时间复杂度也为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995339289","body":"思路：用数组实现栈，用栈实现队列\n```\ntype MyQueue struct {\n    in Stack\n    out Stack\n}\n\ntype Stack []int\n\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n    this.in = append(this.in, x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n    if len(this.in) == 0 {\n        return -1\n    }\n    que := this.in[0]\n    this.in = this.in[1:]\n    this.out = append(this.out, que)\n    return this.out[len(this.out)-1]\n}\n\n\nfunc (this *MyQueue) Peek() int {\n    return this.in[0]\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n    if len(this.in) == 0 {\n        return true\n    }\n    return false \n}\n```\n时间复杂度和空间复杂度均为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996479326","body":"```\nfunc maxChunksToSorted(arr []int) int {\n    stack := []int{}\n    for _,x := range arr{\n        if len(stack)>0 && x < stack[len(stack)-1]{\n            temp := stack[len(stack)-1]\n            for len(stack)>0 && x < stack[len(stack)-1]{\n            stack = stack[:len(stack)-1]\n            }\n            stack = append(stack,temp)\n        }else{\n            stack = append(stack,x)\n        }\n    }\n    return len(stack)\n}\n```\n复杂度为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997196662","body":"```\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc rotateRight(head *ListNode, k int) *ListNode {\n    if k == 0 || head == nil || head.Next == nil {\n        return head\n    }\n    n := 1\n    tem := head \n    for tem.Next != nil {\n        n ++\n        tem = tem.Next\n    }\n    k = n - k%n\n    tem1 := tem.Next\n    tem.Next = head\n    tem2 := head\n    for i :=0 ; i < k-1; i ++ {\n        tem2 = tem2.Next\n    }\n    ans := tem2.Next\n    tem2.Next = tem1\n    return ans \n}\n```\n复杂度n，1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997347277","body":"```\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    dummy := &ListNode{}\n\tdummy.Next = head\n    prev := dummy\n\n    for head != nil && head.Next != nil {\n        next := head.Next\n        head.Next = next.Next\n        next.Next = head\n        prev.Next = next\n\n        prev = head\n        head = head.Next\n    }\n    return dummy.Next\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997531092","body":"思路：分治，中点\n```\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    return buildTree(head, nil)\n}\n\nfunc getMedian(left,right *ListNode) *ListNode{\n    fast, slow := left, left\n    for fast != right && fast.Next != right {\n        fast = fast.Next.Next\n        slow = slow.Next\n    }\n    return slow \n}\n\nfunc buildTree (left,right *ListNode) *TreeNode{\n    if left == right {\n        return nil\n    }\n    mid := getMedian(left, right)\n    root := &TreeNode{mid.Val, nil, nil}\n    root.Left = buildTree(left, mid)\n    root.Right = buildTree(mid.Next, right)\n    return root\n}\n```\n时间复杂度O(nlogn)\n空间为O（logn）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998391054","body":"思路：哈希表，双指针（分别从两个链表进行遍历，遍历到头就转到另外一个链表，如果他们有相遇的可能性的话中途会相遇的，没有地方相遇最后都会指向nil）\n```\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    if headA == nil || headB == nil {\n        return nil\n    }\n    pa, pb := headA, headB\n    for pa != pb{\n        if pa == nil {\n            pa = headB\n        }else {\n            pa = pa.Next\n        }\n        if pb == nil {\n            pb = headA\n        }else {\n            pb = pb.Next\n        }\n    }\n    return pa\n}\n```\n时间复杂度（N）\n空间（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999206101","body":"方法一：map\n```\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    ans := make(map[*ListNode]bool)\n    for head != nil {\n        if ans[head] == true{\n            return head\n        }\n        ans[head] = true\n        head = head.Next\n    }\n    return nil\n}\n```\n时间复杂度为n空间为n\n方法2：快慢指针\n```\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    slow,fast := head, head\n    for fast != nil {\n        slow = slow.Next\n        if fast.Next == nil {\n            return nil\n        }\n        fast = fast.Next.Next\n        if fast == slow {\n            pre := head\n            for pre != slow {\n                pre = pre.Next\n                slow = slow.Next\n            }\n            return pre\n        }\n    }\n    return nil\n}\n```\n时间为n空间为1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999985892","body":"思路：\n双链表以及哈希表\n关键在于把访问过的都放在最前面，这样才能实现题目的O（1）的要求\n```\ntype LRUCache struct {\n    size int\n    capacity int\n    cache map[int]*DLinkedNode\n    head, tail *DLinkedNode\n}\n\ntype DLinkedNode struct {\n    key, value int\n    prev, next *DLinkedNode\n}\n\nfunc initDLinkedNode(key, value int) *DLinkedNode{\n    return &DLinkedNode{\n        key :key,\n        value:value,\n    }\n}\n\nfunc Constructor(capacity int) LRUCache {\n    l :=LRUCache{\n        cache : map[int]*DLinkedNode{},\n        head : initDLinkedNode(0, 0),\n        tail : initDLinkedNode(0, 0),\n        capacity: capacity,\n    }\n    l.head.next = l.tail\n    l.tail.prev = l.head\n    return l\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n    if _,ok := this.cache[key]; !ok{\n        return -1\n    }\n    node := this.cache[key]\n    this.moveToHead(node)\n    return node.value \n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if _,ok := this.cache[key]; !ok {\n        node := initDLinkedNode(key, value)\n        this.cache[key] = node\n        this.addToHead(node)\n        this.size++\n        if this.size > this.capacity {\n            removed := this.removeTail()\n            delete(this.cache, removed.key)\n            this.size -- \n        }\n    } else {\n        node :=this.cache[key]\n        node.value = value\n        this.moveToHead(node)\n    }\n}\n\nfunc (this *LRUCache) addToHead(node *DLinkedNode){\n    node.prev = this.head \n    node.next = this.head.next\n    this.head.next.prev = node \n    this.head.next = node\n}\n\nfunc (this *LRUCache) removeToHead(node *DLinkedNode){\n    node.prev.next = node.next\n    node.next.prev = node.prev\n}\n\nfunc (this *LRUCache) moveToHead(node *DLinkedNode){\n    this.removeToHead(node)\n    this.addToHead(node)\n}\n\nfunc (this *LRUCache) removeTail() *DLinkedNode {\n    node := this.tail.prev\n    this.removeToHead(node)\n    return node \n}\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n```\n复杂度\n时间复杂度：对于 put 和 get 都是 O(1)O(1)。\n\n空间复杂度：O(capacity)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000597462","body":"思路：首先判断是否为空，如果是空就返回0.然后用递归的方式，寻找左右子树的深度最大值，这其中的最大值再加上1就是包含某个节点的最大深度。然后可以通过从根节点这样遍历得到答案。\n```\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    return max(maxDepth(root.Left),maxDepth(root.Right)) + 1\n}\n\nfunc max(x,y int) int {\n    if x > y {\n        return x\n    }else {\n        return y\n    }\n}\n```\n复杂度：\n时间为n\n空间为depth","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000956679","body":"思路：采用深度优先遍历，设置条件当两个节点val不同，或者一个节点存在另外一个节点不存在的时候输出false等条件判断。\n```\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p != nil && q!=nil && p.Val != q.Val || p != nil && q ==nil || p == nil && q !=nil{\n        return false\n    }else if p == nil && q == nil{\n        return true\n    }\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}\n```\n时间空间复杂度都为min（n,m）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001094563","body":"思路：利用dfs解决。\n```\nfunc sumNumbers(root *TreeNode) int {\n    return dfs(0,root)\n}\n\nfunc dfs(pre int,root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    pre = pre* 10 + root.Val\n    if root.Left == nil && root.Right == nil {\n        return pre\n    }\n    return dfs(pre ,root.Left) +dfs(pre ,root.Right)\n}\n```\n时间复杂度 n\n空间复杂度 为h，最多的时候为n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simbafl":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825575","body":"-- java版\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for(int i=n-1;i>=0;--i){\r\n            int sum = num[i] + k % 10;\r\n            k = k /10;\r\n            if(sum >= 10){\r\n                k += 1;\r\n                sum -=10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for(; k>0; k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n-- python版\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for i in range(len(num)-1, -1, -1):\r\n            k += num[i] \r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        while k:\r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        return res\r\n```\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for n in num[::-1]:\r\n            k += n \r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        while k:\r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        return res\r\n```\r\n说到底还是遍历，时间复杂度：O(max(k, len(num)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992440289","body":"-- java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i=0;i<n;++i){\r\n            if(s.charAt(i) == c){prev = i;}\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i=n-1; i>=0; --i){\r\n            if (s.charAt(i) == c){prev = i;}\r\n            ans[i] = Math.min(ans[i], prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n-- python\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i \r\n            ans.append(i-prev)\r\n        prev = float('inf')\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c:\r\n                prev = j\r\n            ans[j] = min(ans[j], prev-j)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993533857","body":"-- python\r\n\r\n```py\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top > -1:\r\n            res = self.stack[self.top]\r\n            self.top -= 1\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        num = min(self.top+1, k)\r\n        for i in range(num):\r\n            self.stack[i] += val\r\n```\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994734954","body":"-- python \r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c \r\n            print(stack)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995339557","body":"--java\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> stackA;\r\n    private Stack<Integer> stackB;\r\n\r\n    public MyQueue() {\r\n        stackA = new Stack<Integer>();\r\n        stackB = new Stack<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stackA.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(stackB.isEmpty()) {\r\n            while(!stackA.isEmpty()){\r\n                stackB.push(stackA.pop());\r\n            }\r\n        }\r\n        return stackB.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(stackB.isEmpty()) {\r\n            while(!stackA.isEmpty()){\r\n                stackB.push(stackA.pop());\r\n            }\r\n        }\r\n        return stackB.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if(stackA.isEmpty() && stackB.isEmpty()){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n-- python\r\n```py\r\nclass MyQueue(object):\r\n\r\ndef __init__(self):\r\n    self.stack1 = []\r\n    self.stack2 = []\r\n\r\ndef push(self, x):\r\n    self.stack1.append(x)\r\n\r\ndef pop(self):\r\n    if not self.stack2:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n    return self.stack2.pop()\r\n\r\ndef peek(self):\r\n    if not self.stack2:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n    return self.stack2[-1]\r\n\r\ndef empty(self):\r\n    return not self.stack1 and not self.stack2\r\n```\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997162697","body":"--python\r\n\r\n1. 闭合为环\r\n2. 找到对应位置\r\n3. 再打开\r\n\r\n```py\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next or not k:\r\n            return head\r\n        cnt = 1\r\n        current = head\r\n        while current.next:\r\n            current = current.next\r\n            cnt += 1\r\n        tail = current\r\n        k = k % cnt\r\n        n = self.findRightNode(head, k)\r\n        tail.next = head\r\n        head = n.next\r\n        n.next = None\r\n        return head\r\n\r\n        \r\n    def findRightNode(self, head, k):\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        p = dummy\r\n        q = dummy\r\n        for i in range(k):\r\n            p = p.next\r\n        while p.next:\r\n            p = p.next\r\n            q = q.next\r\n        return q\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997322970","body":"--python\r\n```py\r\n1. 递归\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        start = head.next\r\n        head.next = self.swapPairs(start.next)\r\n        start.next = head\r\n        return start\r\n\r\n2. 迭代\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        start = head.next\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        while dummy.next and dummy.next.next:\r\n            p = dummy.next\r\n            q = dummy.next.next\r\n            p.next = q.next\r\n            dummy.next = q\r\n            q.next = p \r\n            dummy = dummy.next.next\r\n        return start\r\n```\r\n时间复杂度: O(n)\r\n空间复杂度: O(1), 但递归比迭代多了栈的使用\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997831546","body":"```py\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def findMid(start, end):\n            fast = slow = start\n            while fast != end and fast.next != end :\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(start, end):\n            if start == end:\n                return None\n\n            mid = findMid(start, end)\n            root = TreeNode(mid.val)\n            root.left = buildTree(start, mid)\n            root.right = buildTree(mid.next, end)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998703705","body":"> https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n最坏情况会遍历完两个链表，时间复杂度O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999535107","body":"--py\r\n```py\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n\r\n        slow = head\r\n        fast = head\r\n        \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n                \r\n        if not fast or not fast.next:\r\n            return None\r\n        \r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000314692","body":"--py\n```py\nclass LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000584421","body":"```py\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001013579","body":"```py\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825675","body":"**思路：**\r\nAdding up by digits.\r\nIn the array, we start from the very end element.\r\nFor the integer k, each time we use the last digit (k % 10),\r\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\r\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\r\n\r\n**代码**\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum > 9) {\r\n               k += 1;\r\n               sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**Time Complexity**\r\nTime: O(n), one for loop; \r\nSpace: O(n), use one arraylist","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991971762","body":"**Thoughts**\r\n1. Get all indices of c, go through s to compare i with indices of c\r\n2. Traverse s from head and tail side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\r\n\r\n**Code**\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        ArrayList<Integer> list = new ArrayList<>();\r\n        int[] res = new int[n];\r\n        int p = 0; \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                list.add(i);\r\n            }\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\r\n                p++;\r\n            }\r\n            res[i] = Math.abs(list.get(p) - i);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // in case out of boundry \r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(prev - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n**Time Complexity**\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992900427","body":"**Thoughts**\r\n\r\nUsing two stack to stimulate the customStack, so for PUSH and POP, we can just go with the same operations. The second Stack will be used to hold the POP of first Stack, then we use an var to count and compare with k.\r\n\r\n**Code**\r\n\r\n```java\r\n    Stack<Integer> stack;\r\n    Stack<Integer> stack2 = new Stack<Integer>();\r\n    int s;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new Stack<Integer>();\r\n        s = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() < s) {\r\n            stack.push(x);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack.size() == 0) {\r\n            return -1;\r\n        }\r\n        return stack.pop();\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int count = 0;\r\n        if (k > stack.size()) {\r\n            while (stack.size() > 0) {\r\n                int tmp = stack.pop();\r\n                stack2.push(tmp + val);\r\n            }\r\n            while (stack2.size() > 0) {\r\n                int tmp = stack2.pop();\r\n                stack.push(tmp);\r\n            }\r\n        } else {\r\n            while (stack.size() > 0) {\r\n                int tmp = stack.pop();\r\n                stack2.push(tmp);\r\n            }\r\n            while (stack2.size() > 0) {\r\n                int tmp = stack2.pop();\r\n                count++;\r\n                if (count <= k) {\r\n                    stack.push(tmp + val);\r\n                } else {\r\n                    stack.push(tmp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n**Time Complexity**\r\n* Time: PUSH and POP O(1), increment O(k)\r\n* Space: O(n), n is the size of the stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923912","body":"**Thoughts**\n1. Using two stacks to record the number and characters\n2. Traversing s, when it's number(digit), push(c);\n\t\t\twhen it's `[`, save current sb to stack;\n\t\t\twhen it's `]`, do the multiplication;\n\t\t\twhen it's char, append to sb\n\t\t\t\n**Code**\n```java\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        Deque<Integer> stack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        for (Character c: s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                stack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = sbStack.pop();\n                int count = stack.pop();\n                for (int i = 0; i < count; i++) {\n                    tmp.append(sb.toString());\n                }\n                sb = tmp;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995907767","body":"**Thoughts**\n\nUsing two stacks to stimulate the FIFO sequence, one var to record the front element of the queue\n\n**Code**\n```java\nclass MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n**Complexity**\n* Time: O(1), Push and Pop are constant time\n* Space: O(1) no extra space used","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996818577","body":"**Thoughts**\n\nUsing a LinkedList as a Stack, always add the new element to the tail of the LinkedList.\n\nTraversing arr, if num >= peek of stack, push num to stack; if num < peek of stack, keep popping till num >= peek, push the first peek back.\n\nAfter all, the stack will save the greatest num for each chunk of the arr, size of stack indicates how many chunks we have.\n\n**Code**\n```java\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        for (int num: arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997013677","body":"**Thoughts**\n\n1. traverse the list to locate tail of the list\n2. find the node to be the new head\n3. connect the tail and head to make the list a ring\n4. depart the ring at the new head\n\n**Code**\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) {\n            return head;\n        }\n        int n = 0;\n        ListNode tail = null, tmp = head;\n        // to get the length of list, and locate tail node\n        while (tmp.next != null) {\n            tail = tmp;\n            n++;\n            tmp = tmp.next;\n        }\n        k %= n; // in case k > n\n        ListNode p = head;\n        // locate (n - k)th node \n        for (int i = 0; i < n - k - 1; i++) {\n            p = p.next;\n        }\n        // create a ring, then depart it at p.next, which is the new head\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997290816","body":"**Thoughts**\n\nUse dummyhead point to head, another pointer pre to track the current node\n\n**Code**\n\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        while (pre.next != null && pre.next.next != null) {\n            ListNode start = pre.next;\n            ListNode end = pre.next.next;\n            pre.next = end;\n            start.next = end.next;\n            end.next = start;\n            pre = start;\n        }\n        return dummy.next;\n    }\n```\n**Complexity**\n* Time: O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998005175","body":"**Thoughts**\r\n\r\nSplit the linkedlist intor three parts:\r\n* the mid node, which will be the root of tree\r\n* the left part, will be left subtree\r\n* the right part, will be right subtree\r\nUse fast and slow pointers to locate the mid point(root), use recursion to genarate left and right subtrees\r\n\r\n**Code**\r\n\r\n```java\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        } else if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode pre = slow;\r\n        while (fast != null && fast.next != null) {\r\n            pre = slow; // pre is the previous node of slow\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.right = sortedListToBST(slow.next);\r\n        slow.next = null;\r\n        pre.next = null;\r\n        root.left = sortedListToBST(head);\r\n        return root;\r\n    }\r\n```\r\n\r\n**Complexity**\r\n\r\n* Time: O(nlogn)\r\n* Space: O(logN), height of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998431211","body":"**Thoughts**\n\n* Only two list are not empty, intersection would exist\n* If intersection exist, assume a + c  = m, b + c = n, if a = b, then pa will return the start point of c; if a != b, pa runs out the list, continue with headB, so a + c + b, and pb will have b + c + a, both of pa and pb will arrive at the intersection\n* If not exits, pa and pb will become null\n\n**Code**\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return headA == null ? headB : headA;\n        }\n\n        ListNode pa = headA, pb = headB;\n        while (pa != pb) {\n            pa = pa == null ? headB : pa.next;\n            pb = pb == null ? headA : pb.next;\n        }\n        return pa;\n    }\n```\n\n**Complexity**\n* Time: O(m + n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999266719","body":"**Thoughts**\n\nThis is a problem based on judging if a list has cycle, so the first half part would be the same by using fast and slow pointer. If cycle exists, fast pointer will meet slow finally.\n\nSo when fast meet slow, the position is the start of cycle. Use another pointer points to head, and start a loop, when pointer catch slow, return.\n\n**Code**\n```java\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n```\n\n**Complexity**\n* Time:O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999993309","body":"**Thoughts**\nThere would be two data structures, one for saving data, another for tracking the recently used.\n\nFor data store, a hashmap can realize O(1) read and write\nFor tracking, linkedlist is better in add and remove compared with array. \nA doublylinkedlist is better than a single one, we can manage the \"latest\" at head, and least recently used at tail.\n\n**Code**\n```java\nclass LRUCache {\n    class DoublyLinkedNode {\n        int key;\n        int value;\n        DoublyLinkedNode prev;\n        DoublyLinkedNode next;\n        public DoublyLinkedNode() {};\n        public DoublyLinkedNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    Map<Integer, DoublyLinkedNode> cache;\n    DoublyLinkedNode head, tail;\n    private int size, capacity;\n    public LRUCache(int capacity) {\n        cache = new HashMap<Integer, DoublyLinkedNode>();\n        head = new DoublyLinkedNode();\n        tail = new DoublyLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n        size = 0;\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        //1. get value from cache\n        //2. find node in the list\n        //3. remove node and put it to head\n        DoublyLinkedNode tmp = cache.get(key);\n        if (tmp != null) {\n            remove(tmp);\n            addToHead(tmp);\n            return tmp.value;\n        } else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        //1. check cache: if exist, update value\n        //      remove -> addToHead\n        //2. not exist, cache put\n        // size++, check capacity\n        //  if exceed, remove tail\n        DoublyLinkedNode node = cache.get(key);\n        if (node == null) {\n            DoublyLinkedNode cur = new DoublyLinkedNode(key, value);\n            cache.put(key, cur);\n            addToHead(cur);\n            size++;\n            if (size > capacity) {\n                DoublyLinkedNode tail = removeTail();\n                size--;\n                cache.remove(tail.key);\n            }\n        } else {\n            node.value = value;\n            cache.put(node.key, node);\n            remove(node);\n            addToHead(node);\n        }\n    }\n\n    private void remove(DoublyLinkedNode node) {\n        node.next.prev = node.prev;\n        node.prev.next = node.next;\n    }\n\n    private void addToHead(DoublyLinkedNode node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private DoublyLinkedNode removeTail() {\n        DoublyLinkedNode node = tail.prev;\n        remove(node);\n        return node;\n    }\n}\n```\n\n**Complexity**\n* Time: O(1) write and read\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000514818","body":"**Thoughts**\n\nBasic DFS\n\n**Code**\n```java\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n\n        return Math.max(left, right) + 1;\n    }\n```\n\n**Complexity**\nTime: O(n), each node will be visited once\nSpace: O(height), the space for stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000894157","body":"**Thought**\n\nBasic recursion\n\n**Code**\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001091507","body":"**Thoughts**\n\nDFS: each time we visit a new level, the current value should * 10, then add the node.val, if it's the leaf node, return the total value.\n\n**Code**\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int i) {\n        if (root == null) {\n            return 0;\n        }\n\n        int tmp = i * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return tmp;\n        }\n\n        return dfs(root.left, tmp) + dfs(root.right, tmp);\n    }\n}\n```\n\n**Complexity**\n* Time: O(n), every node visited once\n* Space: O(n), stack size","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sendsproject":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825885","body":"思路：使用数列式两数相加模板，注意carry 的进位和取模操作 \r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        p1 = len(num) -1 \r\n        carry = 0 \r\n        results = []\r\n        while p1 >=0 or k != 0 or carry>0:\r\n            add1 = num[p1] if p1 >=0 else 0 \r\n            add2 = k %10\r\n            sum = add1 + add2 + carry\r\n            carry = 1 if sum >= 10 else 0\r\n            sum = sum - 10 if sum >= 10 else sum\r\n            results.append(sum)\r\n            p1 -= 1\r\n            k //= 10\r\n        return results[::-1]\r\n\r\n时间复杂度 O(N)\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991972064","body":"解题思路：\r\n\r\n方法1： \r\n\r\n遍历列表两次，第一次遍历的时候储存所有c字符出现的位置，第二次遍历计算距离c字符下标的距离\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #pos 储存每个c出现的位置\r\n        pos, res = [],[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                pos.append(i)\r\n        \r\n        #p指针在pos数组\r\n        p =0\r\n        # 再次遍历字符串\r\n        for i in range(len(s)):\r\n            # 如果当前i 小于pos[0],说明这个字符出现在第一个c字符的前面\r\n            # 那么直接用pos[0] - i \r\n            #这里pos[0] 储存的是character c 在S中出现的下标， 所以可以直接减\r\n            if i < pos[0]:\r\n                res.append(pos[0]-i)\r\n            # 如果当前i大于pos最后一个位置，说明这个字符出现在最后一个c字符的后面\r\n            #那么直接用i-pos[-1]\r\n            elif i > pos[-1]:\r\n                res.append(i - pos[-1])\r\n            # 如果就是字符就是c，那么数值为0，同时给p+1 为下一步做准备\r\n            elif i == pos[p]:\r\n                res.append(0)\r\n                p+=1\r\n            ##在两个c之间，所以返回距离的最小值\r\n            else:\r\n                res.append(min(pos[p]-i,i-pos[p-1]))\r\n        return res\r\n```\r\n\r\n时间复杂度O(N)\r\n空间复杂度O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993157125","body":"暴力解，前缀和没看懂答案 -贴一个暴力解答案\r\n\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        self.st = []\r\n        self.count = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x):\r\n        if self.count <self.maxSize:\r\n            self.st.append(x)\r\n            self.count+=1\r\n\r\n    def pop(self):\r\n        if self.count==0:\r\n            return -1\r\n        self.count-=1\r\n        return self.st.pop()\r\n\r\n    def increment(self, k, val):\r\n        for i in range(0, min(self.count,k)):\r\n            self.st[i]+= val\r\n\r\n\r\n时间复杂度O(1), increment -- O(N)\r\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994265782","body":"  把所有字符一个个放到 stack 里， 如果碰到了 ]，就从 stack 找到对应的字符串和重复次数，decode 之后再放回 stack 里\n\n``` python\ndef decodeString(self, s):\n        stack = []\n        for c in s:\n            if c != ']':\n                stack.append(c)\n                continue\n                \n            strs = []\n            while stack and stack[-1] != '[':\n                strs.append(stack.pop())\n            \n            # skip '['\n            stack.pop()\n            \n            repeats = 0\n            base = 1\n            while stack and stack[-1].isdigit():\n                repeats += (ord(stack.pop()) - ord('0')) * base\n                base *= 10\n            stack.append(''.join(reversed(strs)) * repeats)\n        \n        return ''.join(stack)\n\n\n时间复杂度O（N）\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995383073","body":"解题思路：\n\nstack - 后进先出\n\nqueue  - 前进先出\n\n使用两个栈形成负负得正\n\n```python\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n        \n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n时间复杂度: push -O(1), peek/pop -- O(1) worst case O(N)\n空间复杂度: O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997423924","body":"解题思路：抄的答案，需要注意后面指针的用法 老是写错 \n\n```python\n   class Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n\n时间复杂度 O(N)\n空间复杂度O（N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998967558","body":"解题思路：使用双指针可以使用O（1）的空间解决，另外一个思路是用set 但是需要额外的储存空间\n\n```python\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head == None or head.next == None:\n            return None\n        fast, slow = head, head\n        \n        while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n                if fast == slow:\n                    break\n        \n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n        return None\n\n时间复杂度O（N）\n空间复杂度 O（1）\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000605287","body":"解题思路：可以用BFS 模版 每层+1 或者DFS 递归，这里贴一个BFS的答案\n\n```python\nclass Solution(object):\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        queue = collections.deque([root])\n        depth = 0\n        while queue:\n            size = len(queue)\n            depth +=1\n            for _ in range(size):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return depth\n\n时间复杂度 O(N) \n空间复杂度O(N)\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000962087","body":"解题思路： 分治，我们先去看看树的右边，再去看看树的左边，如果两边都是一样的 而且根的value 也是一样的，那么这两颗就是一样的树\n\n```python\n\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p or not q: \n            return p == q\n        if p.val != q.val:\n            return False\n        \n        outside = self.isSameTree(p.left, q.left)\n        inside = self.isSameTree(p.right, q.right)\n        isSame = outside and inside\n        \n        return isSame\n\nTime Complexity : O(N)\nSpace Complexity : O(N) \n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoxingbiao":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991828392","body":"**思路：**\n\n各位相加，从低到高位计算。nums数组从nums.length-1的位置开始遍历，每次遍历都与当前k的个位值相加，并加上当前一个进位值，\n在判断是否大于9，更新进位值。\n\n细节处理：当k的位数大于nums.length时，在遍历完nums数组后还要处理剩下的k，直到k为0。如果最后进位值为一，要在ans数组头部加1。\n\n**代码：**\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> ans = new LinkedList<Integer>();\n\n        int jinwei = 0;\n        for(int i = num.length - 1;i >= 0;i--){\n            int a = num[i] + (k % 10) + jinwei;\n            if(a >= 10){\n                jinwei = 1;\n                a %= 10;\n            }\n            else{\n                jinwei = 0;\n            }\n            ans.add(0,a);\n            k = k / 10;\n        }\n\n        while(k != 0){\n            if(jinwei != 0){\n                int a = (k % 10) + jinwei;\n                if(a >= 10){\n                    jinwei = 1;\n                    a %= 10;\n                }\n                else{\n                    jinwei = 0;\n                }\n                ans.add(0, a);\n            }\n            else{\n                ans.add(0, k % 10);\n            }\n\n            k = k / 10;\n\n        }\n\n        if(jinwei != 0){\n            ans.add(0,1);\n        }\n\n        return ans;\n\n\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(max(nums.length,len(k))),因为List是用LinkedList实现，所以在链表头部插入元素的时间复杂度为O(1)。\n\n空间复杂度：O(ans.size())。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992063676","body":"**思路：**\n\n双指针法，left表示当前字符左边第一个字符c的位置，right表示当前字符右边第一个字符c的位置。遍历该字符串，计算每个字符到left和right的距离，把较小值存在ans数组对应位上。当i大于right时，更新left和right的值。\n\n细节处理：当right == length，只有左侧有字符c，对每个元素只需计算abs(i - left)。\n\n**代码**\n```\nclass Solution {\n\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] ans = new int[length];\n        int left = 0, right = 1;\n        while(left < length && s.charAt(left) != c){\n            left++;\n        }\n        while(right < length && s.charAt(right) != c){\n            right++;\n        }\n\n        for(int i = 0;i < length;i++){\n            if(i > right){\n                if(right != length){\n                    left = right;\n                    right++;\n                    while(right < length && s.charAt(right) != c){\n                        right++;\n                    }\n                }\n            }\n\n            if(right == length){\n                ans[i] = Math.abs(left - i);\n            }\n            else{\n                ans[i] = Math.min(Math.abs(left-i),Math.abs(right - i));\n            }\n        }\n\n        return ans;\n\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度:O(n) 只需要遍历一遍字符串且s.charAt()的复杂度为O(1)。\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993108546","body":"**思路**\n\n用一个数组模拟栈，top指针指向当前栈顶。\n\n**代码**\n\n```\nclass CustomStack {\n\n    int[] data;\n    int top;\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < data.length - 1){\n            data[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        int peek = -1;\n        if(top >= 0){\n            peek = data[top--];\n        }\n        return peek;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < Math.min(k, top + 1);i++){\n            data[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**复杂度**\n\n时间复杂度：push(),pop()在O(1)时间内完成，increment在O(n)的时间内完成。故时间复杂度为O(n)。\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994260529","body":"**思路**\n\n使用两个栈，一个保存括号内字符串重复的次数，一个保存该字符串。\n遍历字符串：遇到左括号就把它前面的数字压入数字栈，把它之前的字符串压入字符串栈；遇到右括号，数字栈顶元素k出栈，把当前括号内的字符串重复k次赋给temp，字符串栈顶元素出栈，与temp拼接，保存到结果字符串中；遇到字符，就append到当前字符串。\n\n**代码**\n\n```\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        Stack<String> stackStr = new Stack<>();\n        Stack<Integer> stackInt = new Stack<>();\n        int times = 0;\n\n        for(Character c : s.toCharArray()){\n            if(c >= '0' && c <= '9'){\n                times = times * 10 + Integer.parseInt(String.valueOf(c));\n            }\n            else if(c == '['){\n                stackInt.push(times);\n                stackStr.push(sb.toString());\n                times = 0;\n                sb = new StringBuilder();\n            }\n            else if(c == ']'){\n                int k = stackInt.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i = 0;i < k;i++){\n                    temp.append(sb);\n                }\n                sb = new StringBuilder(stackStr.pop() + temp);\n            }\n            else{\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(n * max(k))\n\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997547424","body":"**思路**\n\n二叉搜索树的中序遍历是一个升序数组，那么构造一个二叉搜索树只需对一个升序数组进行如下操作:\n1)找到当前链表的中间节点2)中间节点作为根节点3)以中间节点分隔左右两侧的链表，递归构建左右子树。\n\n**代码**\n\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        if(head.next == null){\n            return new TreeNode(head.val);\n        }\n\n        ListNode pre = head;\n        ListNode p = pre.next;\n        ListNode q = p.next;\n\n        while(q!=null && q.next!=null){\n            pre = pre.next;\n            p = p.next;\n            q = q.next.next;\n        }\n\n        pre.next = null;\n        TreeNode root = new TreeNode(p.val);\n\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        \n        return root;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000844827","body":"**思路**\n\n拿到能用递归解决的题目，只需考虑三个问题：1）终止条件是什么？2）每一层的具体操作是什么？3）返回值是什么？\n\n先考虑第一个问题，求树的最大深度，终止条件就是当树为空树时，树深为0。第二个问题，对某个节点，我们要知道它所在的深度，就是它的左子树深度和右子树深度的较大值加1。第三个问题，返回值就是当前节点所在深度。\n\n**代码**\n\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n\n        int depth = 1;\n        int leftdepth = maxDepth(root.left);\n        int rightdepth = maxDepth(root.right);\n        depth = depth + Math.max(leftdepth,rightdepth);\n        return depth;\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(n)\n\n空间复杂度：O(logn)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linyang4":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991828416","body":"## 代码\n```JavaScript\nconst addToArrayForm = (num, k) => {\n    const result = []\n    let carry = 0 // 是否进位\n    for(let i = num.length - 1; i >= 0 || k > 0; i--) {\n        const numItem = num[i] || 0\n        let sum = numItem + (k % 10) + carry\n        if (sum >= 10) {\n            sum = sum - 10\n            carry = 1\n        } else {\n            carry = 0\n        }\n        k = Math.floor(k / 10)\n        result.push(sum)\n    }\n    if (carry === 1) {\n        result.push(1)\n    }\n    return result.reverse()\n};\n```\n\n## 复杂度分析\nM是num的长度, N是k的长度\n- 时间复杂度: O(max(M, logN))\n- 空间复杂度: O(max(M, N))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992359109","body":"## 思路\r\n1. 创建一个index数组, 用于记录字符 c 在字符串 s 中出现的所有位置\r\n2. 循环字符串 s, 计算 s 中的每一个字符与 index 数组中的每一个 index 相减的绝对值, 然后取所有绝对值中最小的一个作为该字符与目标字符 c 的最短路径\r\n\r\n## 代码\r\n```JavaScript\r\nconst shortestToChar = (s, c) => {\r\n    const result = []\r\n    const cIndexs = []\r\n    // 第一次循环, 记录c在s中所有的位置\r\n    for(let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            cIndexs.push(i)\r\n        }\r\n    }\r\n    // 第二次循环, 计算最短距离\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) { \r\n            result.push(0)\r\n        } else {\r\n            let minDis =  Math.abs(cIndexs[0] - i)\r\n            for(let j = 1; j < cIndexs.length; j++) {\r\n                const dis = Math.abs(cIndexs[j] - i)\r\n                if (minDis > dis) {\r\n                    minDis = dis\r\n                }\r\n            }\r\n            result.push(minDis)\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度: O(M*N), N为字符串 s 的长度, M为字符 c 在字符串 s 中出现的次数\r\n- 空间复杂度: O(N), N为字符 c 在字符串 s 中出现的次数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993102889","body":"## 思路\n1. 构造函数: 创建数组保存栈的值, 并且创建一个变量用于记录数组最大容纳数量\n2. push操作: 先比较数组的长度和最大容纳数量, 如果2个值相等, 不进行任何操作, 否则把数据添加到数组末尾\n3. pop操作: 先判断数组是否为空, 为空就返回-1, 否则移除数组最后一位的数据并返回\n4. inc操作: 取数组的长度和k中较小的进行遍历, 然后进行加等操作\n\n## 代码\n```JavaScript\nvar CustomStack = function(maxSize) {\n    this._data = []\n    this._maxSize = maxSize\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this._data.length !== this._maxSize) {\n        this._data.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if (this._data.length !== 0) {\n        return this._data.pop()\n    } else {\n        return -1\n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(k, this._data.length); i++) {\n        this._data[i] = this._data[i] + val\n    }\n};\n```\n\n## 复杂度\n### 时间复杂度\n- push: O(1)\n- pop: O(1)\n- inc: O(min(K, N)),","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994735827","body":"## 思路\n递归实现\n\n\n## 代码\n```JavaScript\n// 获取最近的一个 \"]\" 的位置\nconst getRightIndex = (arr, leftIndex) => {\n    let count = 1\n    for(let i = leftIndex + 2; i < arr.length; i++) {\n        if (arr[i] === '[') {\n            count++\n        } else if (arr[i] === ']') {\n            count--\n        }\n        if (count === 0) {\n            return i\n        }\n    }\n}\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n        if (isNaN(s[i])) {\n            result += result = ''s[i]\n        } else {\n            let num, leftIndex\n            // 取出数字, 并计算最近的 \"[\" 的位置\n            for (let j = i + 1; j < s.length - 1; j++) {\n               if (isNaN(s.slice(i, j))) {\n                   num = Number(s.slice(i, j -1))\n                   leftIndex = j - 1\n                   break\n               }\n            }\n            const rightIndex = getRightIndex(s, leftIndex)\n            // 递归子串\n            const subResult = decodeString(s.slice(leftIndex + 1, rightIndex))\n            result += subResult.repeat(num)\n            i = rightIndex\n        }\n    }\n    return result\n};\n```\n\n## 复杂度\n- 时间复杂度: O(N) \n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995794228","body":"## 思路\n1. 创建2个栈, push栈和pop栈\n2. push操作: 数据直接存到push栈\n3. pop操作: 分2种情况\n    - 情况1: pop栈中有数据, 直接移除pop栈顶的元素并返回\n    - 情况2: pop栈中无数据, 需要把push栈中所有元素移到pop栈中, 此时pop栈中元素的顺序就和整个队列的先后顺序一致了, 再移除pop栈顶的元素并返回\n4. peek操作: 分2种情况\n    - 情况1: pop栈中有数据, 直接返回pop栈顶的元素   \n    - 情况2: pop栈中无数据, 需要把push栈中所有元素移到pop栈中, 此时pop栈中元素的顺序就和整个队列的先后顺序一致了, 再返回pop栈顶的元素\n5. empty操作: \n    - 2个栈都为空的情况下, 返回true \n    - 只要有一个栈不为空, 返回false\n\n## 代码\n```JavaScript\nvar MyQueue = function() {\n    this._pushStack = []\n    this._popStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this._pushStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this._popStack.length === 0) {\n        while(this._pushStack.length !== 0) {\n            this._popStack.push(this._pushStack.pop())\n        }\n    }\n    return this._popStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this._popStack.length === 0) {\n        while(this._pushStack.length !== 0) {\n            this._popStack.push(this._pushStack.pop())\n        }\n    }\n    return this._popStack[this._popStack.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this._popStack.length === 0 && this._pushStack.length === 0\n};\n```\n\n## 复杂度分析\n1. push操作\n    - 时间复杂度: O(1)\n    - 空间复杂度: O(1)\n2. pop操作\n    - 时间复杂度: 最坏的情况下为O(n), 最好的情况下为O(1)\n    - 空间复杂度: O(1)\n3. peek操作\n    - 时间复杂度: 最坏的情况下为O(n), 最好的情况下为O(1)\n    - 空间复杂度: O(1)\n4. empty操作\n    - 时间复杂度: O(1)\n    - 空间复杂度: O(1)\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996780369","body":"## 思路\n滑动窗口, 把原数组从小到大排序, 遍历数组, 如果排序后数组的前n项与原数组的前n项相等, 那么这n项就可以作为一个组, 然后继续遍历, 找下一个符合条件的组\n\n\n## 代码\n```JavaScript\nconst maxChunksToSorted = function(arr) {\n    const sortedArr = [...arr].sort((left, right) => left - right)\n\n    let result = sum1 = sum2 = 0\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i]\n        sum2 += sortedArr[i]\n        if (sum1 === sum2) {\n            result++\n        }\n    }\n    return result\n}\n```\n\n## 复杂度\n- 时间复杂度: O(NlogN), 主要是数组排序的时间\n- 空间复杂度: O(N), 需要开辟空间存排序后的数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222457","body":"## 思路\n先把链表连接成环, 然后计算需要移动的次数, 移动链表的头, 最后断开环\n\n## 代码\n```JavaScript\nconst rotateRight = (head, k) => {\n    // 获取链表长度\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n    // 计算需要移动的次数\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    // 移动指针到新的head\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    // 设置链表尾部\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n\n## 复杂度分析\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997410169","body":"## 思路\n1. 创建一个哨兵节点, next指向head\n2. 创建一个指针节点, 初始指向哨兵节点\n3. 遍历链表, 每次交换指针节点后面2个节点(分别叫做前节点和后节点), 然后把指针节点指向前节点\n\n\n## 代码\n```JavaScript\nconst swapPairs = (head) => {\n    const guardNode = new ListNode(null, head)\n    let curNode = guardNode\n    while(curNode.next !== null && curNode.next.next !== null) {\n        const node1 = curNode.next\n        const node2 = curNode.next.next\n        curNode.next = node2\n        node1.next = node2.next\n        node2.next = node1\n        curNode = node1\n    }\n    return guardNode.next\n};\n\n```\n\n## 复杂度\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997901743","body":"## 思路\n创建一个数组存储节点的值, 然后递归获取数组的中间位置(mid)的值作为根(父)节点, 用[0, mid-1]区间的值来构建左子树, [mid+1, len-1]区间的值构建右子树\n\n\n## 代码\n```JavaScript\nconst sortedListToBST = (head) => {\n    const arr = []\n    while(head) {\n       arr.push(head.val)\n       head = head.next\n    }\n\n    const buildBST = (start, end) => {\n        if (start > end) {\n            return null\n        }\n        const mid = Math.ceil((start + end) / 2)\n        const treeNode = new TreeNode(arr[mid])\n        treeNode.left = buildBST(start, mid - 1)\n        treeNode.right = buildBST(mid + 1, end)\n        return treeNode\n    }\n    return buildBST(0, arr.length - 1)\n};\n```\n\n## 复杂度\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998813546","body":"## 思路\n1. 创建2个指针A和B, 分别指向A链表的head和B链表的head; 创建2个指针, 初始为空, 用于存取2个链表的尾节点\n2. A指针遍历A链表, B指针遍历B链表\n   - 当A指针到达A链表末尾时, 保存A链表的尾节点, 如果此时B链表的尾节点不为空, 判断2个尾节点, 如果尾节点相等, 说明2个链表有相交节点, 然后A指针指向B链表的head; 如果尾结点不相等, 说明2个链表没有相交节点, 直接返回空\n   - B指针的逻辑类似, 当指针到达B链表末尾时, B指针指向A链表的head继续遍历, 直到2个指针相等\n\n\n## 代码\n```JavaScript\nconst getIntersectionNode = (headA, headB) => {\n    let pointA = headA\n    let pointB = headB\n    let tailA = tailB = null\n    while(pointA !== pointB) {\n        if (pointA && pointA.next === null) {\n            tailA = pointA.next\n            if (tailB && tailB !== tailA) {\n                return null\n            }\n        }\n\n        if (pointB && pointB.next === null) {\n            tailB = pointB.next\n            if (tailA && tailA !== tailB) {\n                return null\n            }\n        }\n        if (pointA === null) {\n            pointA = headB\n        } else {\n            pointA = pointA.next\n        }\n\n        if (pointB === null) {\n            pointB = headA\n        } else {\n            pointB = pointB.next\n        }\n    }\n    return pointA\n}\n```\n\n## 复杂度\n- 时间复杂度: O(m+n), m和n分别为2个链表的长度, 2个指针分别遍历了2个链表\n- 空间复杂度: O(1), 只创建了2个指针\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999394221","body":"## 思路\n快慢指针法\n1. 创建2个指针, 快指针和慢指针, 默认都指向头节点\n2. 遍历链表, 快指针每次移动2个节点, 慢指针每次移动1个节点\n3. 如果快指针为空或者快指针的next为空, 说明没有环, 跳出遍历, 直接返回空\n4. 如果快指针和慢指针相等, 把快指针指向链表头, 并设置快指针和慢指针一样每次移动一个节点, 当快指针和慢指针再次相遇时, 就是环的起始节点了\n\n\n## 数学推导\n这里只关注有环的情况下, 没环会在第一轮遍历时就直接跳出的\n\n假设链表没环区域的长度是a, 环的长度是b, 快指针移动的距离是f, 慢指针移动的距离是s, 由于快指针的速度是慢指针的2倍, 所以在同一个时间点, 总有 f = 2s\n### 第一次相遇\n此时f跟s的关系可以表示为 f = s + nb(n>=1), 可以把n理解为快指针在追慢指针前套的圈数,  结合 f = 2s, 得到 s = nb, 即此时慢指针移动的距离恰好是环长度的倍数\n### 第二次相遇\n结合第一次相遇, 此时慢指针只需要再移动a个节点, 就可以移动到环的开始节点了\n\n\n## 代码\n```JavaScript\nvar detectCycle = function(head) {\n    let fast = slow = head\n    while(fast && fast.next) {\n        fast = fast.next.next\n        slow = slow.next\n        if (fast === slow) {\n            fast = head\n            while(fast !== slow) {\n                fast = fast.next\n                slow = slow.next\n            }\n            return fast\n        }\n    }\n    return null\n};\n```\n\n## 复杂度\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000324556","body":"## 思路\n创建一个双向链表用于存key和value, 一个map用于存储链表节点\n1. get时, 如果key在map中能找到对应的node, 返回node的val并且把node移动到链表头, 否则返回-1\n2. put时\n    - key存在, 找到对应的node, 修改node的val, 并把node移动到链表头\n    - key不存在, 创建新的node并移动到链表头, 如果map的size超过了cache的capacity, 需要同时把链尾的节点移除并且把map中的键值对移除\n\n\n## 代码\n```JavaScript\nfunction ListNode(key, val) {\n    this.pre = null\n    this.next = null\n    this.key = key\n    this.val = val\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity\n    this.listNodeMap = new Map()\n    this.guardHead = new ListNode(null, null)\n    this.guardTail = new ListNode(null, null)\n    this.guardHead.next = this.guardTail\n    this.guardTail.prev = this.guardHead\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    const node = this.listNodeMap.get(key)\n    if (node) {\n        // 移动到head\n        this.moveToHead(node)\n        return node.val\n    } else {\n        return -1\n    }\n}; \n\nLRUCache.prototype.moveToHead = function(node) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    this.guardHead.next.prev = node\n    node.next = this.guardHead.next\n    node.prev = this.guardHead\n    this.guardHead.next = node\n}\n\nLRUCache.prototype.addToHead = function(node) {\n    node.next = this.guardHead.next\n    this.guardHead.next.prev = node\n    node.prev = this.guardHead\n    this.guardHead.next = node\n}\n\nLRUCache.prototype.removeTail = function() {\n    this.guardTail.prev = this.guardTail.prev.prev\n    this.guardTail.prev.next = this.guardTail\n}\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    let node = this.listNodeMap.get(key)\n    if (node) {\n        this.moveToHead(node)\n        node.val = value\n        return \n    }\n    \n    node = new ListNode(key, value)\n    this.addToHead(node)\n    if (this.listNodeMap.size === this.capacity) {\n        this.listNodeMap.delete(this.guardTail.prev.key)\n        this.removeTail()\n    }\n    this.listNodeMap.set(key, node)\n};\n```\n\n## 复杂度\n- 时间复杂度: O(1)\n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000606944","body":"## 思路\r\n递归获取左子树和右子树的深度, 然后比较大小\r\n\r\n\r\n## 代码\r\n```JavaScript\r\nvar maxDepth = function(root) {\r\n    if (!root) { return 0 }\r\n    let leftDepth = maxDepth(root.left)\r\n    let rightDepth = maxDepth(root.right)\r\n    return leftDepth > rightDepth ? leftDepth + 1 : rightDepth + 1\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(height)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000989046","body":"## 思路\n递归\n\n递归项: 比较2个树相等可以抽象为, 2个树根节点的值相等, 左右子树对应相等\n\n递归退出条件: 对应节点的值不相等, 或者左右子树不相等\n\n\n## 代码\n```JavaScript\nvar isSameTree = function(p, q) {\n    if (p === null && q === null) {\n        return true\n    } else if (p!== null && q!== null) {\n        // 比较节点值是否相等\n        const isNodeSame = p.val === q.val\n        if (!isNodeSame) { return false }\n        const isLeftSame = isSameTree(p.left, q.left)\n        if (!isLeftSame) { return false }\n        const isRightSame = isSameTree(p.right, q.right)\n        if (!isRightSame) { return false }\n        return true\n    } else {\n        return false\n    }\n};\n```\n\n## 复杂度\nm, n分别为2个树的节点数\n- 时间复杂度: O(min(m, n))\n- 空间复杂度: O(min(m, n))\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"charlestang":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829254","body":"思路：\r\n从最后一位开始，模拟竖式加法，逐位向前求和。\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        p = n - 1\r\n        carry = 0\r\n        while k > 0 or p >= 0:\r\n            last = k % 10\r\n            new = carry + last + (num[p] if p >= 0 else 0)\r\n            if p >= 0:\r\n                num[p] = new % 10\r\n            else:\r\n                num.insert(0, new % 10)\r\n            carry = new // 10\r\n            k = k // 10\r\n            p = p - 1\r\n        if carry == 1:\r\n            num.insert(0, 1)\r\n        return num\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992080862","body":"## 思路\n1. 找出 c 的下标的数组，复杂度 O(n) 遍历一次，这个下标数组是天然有序的；\n2. 从头开始，每个字母的下标去 1 里找出的下标数组里找插入位置，然后比较两侧的距离，选小的。复杂度  O(n log(n))\n总体复杂度 n log(n)\n\n## 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        indices = [i for i, ci in enumerate(s) if ci == c]\n        res = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                res.append(0)\n            else:\n                insert = bisect.bisect_left(indices, i)\n                cur = insert if insert < len(indices) else insert - 1\n                pre = insert - 1 if insert > 0 else 0\n                res.append(min(abs(i-indices[cur]), abs(i-indices[pre])))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993204166","body":"###  思路\n\n用两个变量记录最大值和当前长度。\n\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.curSize = 0\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.curSize < self.maxSize:\n            self.stack.append(x)\n            self.curSize += 1\n\n    def pop(self) -> int:\n        if self.curSize > 0:\n            self.curSize -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.curSize)):\n            self.stack[i] += val\n\n```\n\n**复杂度分析**\n\n时间复杂度，push 和 pop 都是 O(1)\ninc 复杂度是 O(k)\n空间复杂度是 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994292470","body":"### 思路\n\n使用递归方法实现：\n 1. 遇到字母就直接输出结果；\n 2. 遇到数字就计算数字；\n 3. 遇到中括号，就递归计算中括号内的内容，重复2里面计算的数字次，输出；\n\n利用递归的栈记住中间结果。\n\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def process() -> str:\n            nonlocal i\n            res = ''\n            count = 0\n            while i < len(s):\n                c = s[i]\n                i += 1\n                if ord('a') <= ord(c) <= ord('z'):\n                    res += c\n                elif ord('0') <= ord(c) <= ord('9'):\n                    count = count * 10 + int(c)\n                elif c == '[':\n                    res += process() * count\n                    count = 0\n                elif c == ']':\n                    return res\n            return res\n        i = 0\n        return process()\n```\n\n**复杂度分析**\n\n因为每个字符遍历了一遍，所以 O(n)\n             ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995400421","body":"### 思路\n\n双栈实现队列，主要问题在于：栈的定义是先进后出，而队列的定义是先进先出。\n\n所以，我们实现的时候，用两个栈，第一个栈专门用于入栈，而第二个队列则只用于出栈。\n\n当我们把第一个栈元素逐一弹出并加入第二个栈后，里面元素的数量会颠倒，正好符合队列的定义。\n\n我们可以在 peek 的时候进行这个操作，如果第二个栈有元素，就访问第二个栈，如果第二个栈是空的\n就把第一个栈搬空放到第二个栈。这样子操作，peek 在第二个栈为空的时候，复杂度O(n)，但是平均到\nn 次的话，因为只搬了一次，所以平均复杂度只有O(1)。\n\npop 很好实现，就是 peek 的基础上，对第二个栈执行一个 pop，所以复杂度同 peek。\n\npush的复杂度本就O(1)\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        ans = self.peek()\n        self.stack2.pop()\n        return ans\n\n    def peek(self) -> int:\n        if self.stack2: return self.stack2[-1]\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```\n\n**复杂度分析**\n\n时间复杂度：push, pop, peek, empty 平均复杂度都是 O(1)\n\n空间复杂度：O(n) 因为用了两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996413557","body":"### 思路\n\n切割后，排序，再合并，和原来的数组排序后一致，说明每一块的最大值，和排序后的对应值，位置相同。\n\n每一块的最大值是块切割的边界。可以用一个栈记住每一块的最大值。\n\n同时要保证，这一块里的最小值要 **不小于** 上一块的最大值。\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for n in arr:\n            if not stack or n >= stack[-1]:\n                stack.append(n)\n            else:\n                head = stack.pop()\n                while stack and n < stack[-1]: stack.pop()\n                stack.append(head)\n        return len(stack)\n```\n\n**复杂度分析**\n\n时间复杂度：O(n) 每个元素最多进栈一次，出栈一次\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996915075","body":"### 思路\n\n计算长度，然后取模，然后计算新的头部节点位置。\n\n可以把链表串起来，然后一起移动头尾指针，这样找到新头尾后截断。\n\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return head\n        \n        cnt = 1\n        tail = head\n        while tail.next:\n            cnt += 1\n            tail = tail.next\n        \n        # make a circle\n        tail.next = head\n\n        move = cnt - (k % cnt)\n        while move > 0:\n            head = head.next\n            tail = tail.next\n            move -= 1\n        \n        tail.next = None\n        return head\n```\n\n**时间复杂度** \nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997228855","body":"### 思路\n\n递归：假设我们已经知道如何做这件事情。那么我们拿到一个链表，交换头两个节点的顺序，剩下的就调用自己完成就可以了。\n\n边界：只有一个节点或者空链表，直接返回。\n\n### 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next: return head\n        p = head.next\n        head.next = self.swapPairs(p.next)\n        p.next = head\n        return p\n```\n\n**时间复杂度**\nO(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997564521","body":"### 思路\n\n如果想要二叉树平衡，则左子树和右子树的节点树尽可能一样多。\n\n那我们每次找到中间的数字，作为根节点。然后对前面的数字递归调用，作为左子树，右子树同理。\n\n通过快慢指针可以找到中间的节点。\n\n### 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        # 1. 边界条件\n        if not head: return None\n        if not head.next: return TreeNode(val=head.val)\n\n        # 2. 分割\n        p = slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        while p.next != slow:\n            p = p.next\n        p.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n**复杂度分析**\n\n * 时间复杂度： 找到中间的节点，复杂度是O(n)，构造 BST 是 O(Log(n))，总时间复杂度是 O(n Log(n))\n * 空间复杂度：O(Log(n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998094213","body":"### 思路\n\n双指针，把两个链表联成环遍历一遍后，如果有交点，比如会在交点遇到，如果没有交点比如会在最后的结尾遇到。因为两个链表各遍历一遍，正好走过的节点一样多。\n\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = headA, headB\n        while headA != headB:\n            headA = headA.next if headA else q\n            headB = headB.next if headB else p\n        return head\n```\n **时间复杂度** O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999313763","body":"### 思路\n\n哈希，记住链表的每个指针\n\n然后遍历链表，遇到见过的节点就是环起点。\n\n### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        d, p = {head: True}, head\n        while p:\n            r = d.get(p.next, None)\n            if r != None:\n                return p.next\n            p = p.next\n            d[p] = True\n        return None\n```\n\n**时间复杂度** O(n)\n\n空间复杂度 O(n)\n\n### 思路2\n\n快慢指针，快指针移动速度是慢指针的两倍。所以，如果有环，快指针一定会追上慢指针，否则会到队尾。\n\n快指针追上慢指针的时候，走过的距离是慢指针的两倍。假设在环上的 x 位置追上。慢指针走过的环的部分，\n快指针已经走过两遍了。慢指针走过的环外部分，快指针走过了相当于两倍的长度。所以，从相遇点 x，到环的\n起始位置长度，正好等于从链表起点到环入口的位置。\n\n### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        p = slow = fast = head\n        while fast:\n            if not fast.next: return None\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                while p != slow:\n                    slow, p = slow.next, p.next\n                return p\n        return None\n```\n\n**时间复杂度** O(n)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000203179","body":"### 思路\n\n使用双链链表存储缓存数据。插入，删除，更新，都可以做到 O(1)。\n\n使用哈希记录 key 和 对应的节点。查询可以做到 O(1)。\n\n### 代码\n\n```python\nclass ListNode:\n    def __init__(self, key: int = 0, val: int = 0, prev: ListNode = None, next: ListNode = None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.next = next\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n\n        self.head = ListNode()\n        self.tail = ListNode()\n\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        node = self.cache.get(key, None)\n        if node:\n            self.moveToHead(node) # 节点存在的话，搬到头部\n            return node.val\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        node = self.cache.get(key, None)\n        if node:\n            node.val = value\n            self.moveToHead(node)\n        else:\n            if self.capacity == 0: # 容量用完的话，腾位子\n                node = self.removeLast()\n                del(self.cache[node.key])\n            else:\n                self.capacity -= 1 # 容量还有就消耗一个容量\n            node = ListNode(key, value)\n            self.cache[key] = node\n            self.insertFirst(node)\n            \n    \n    def moveToHead(self, node: ListNode):\n        prev = node.prev\n        next = node.next\n\n        prev.next = next\n        next.prev = prev\n\n        self.insertFirst(node)\n\n    def removeLast(self) -> ListNode:\n        node = self.tail.prev\n        prev = node.prev\n\n        prev.next = self.tail\n        self.tail.prev = prev\n\n        return node\n        \n    def insertFirst(self, node: ListNode):\n        first = self.head.next\n\n        self.head.next = node\n        node.prev = self.head\n\n        node.next = first\n        first.prev = node\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000633462","body":"### 思路\n\n递归。左子树的最大深度 和  右子树的最大深度 加一 就是整颗数的最大深度。\n\n边界。空树是 0。\n\n### 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        if not root.left and not root.right: return 1\n        left, right = 0, 0\n\n        if root.left:\n            left = self.maxDepth(root.left)\n        if root.right:\n            right = self.maxDepth(root.right)\n        return max(left, right) + 1\n```\n\n**时间复杂度** O(2^h) h是树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000967861","body":"### 思路\n\n递归\n\n边界：如果两个树都为空，则返回 True，如果其中一棵树为空，返回False\n\n### 代码\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q: return True\n        if not p or not q: return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n**时间复杂度** O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001047624","body":"### 思路\n\n深度优先遍历树，找到每个根到叶子的路径生成数字。\n\n### 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        nums = []\n\n        def dfs(root: TreeNode, n: List[int]):\n            if not root.left and not root.right:\n                num = 0\n                for a in n:\n                    num = num * 10 + a\n                nums.append(num * 10 + root.val)\n            else:\n                if root.left:\n                    dfs(root.left, n + [root.val])\n                if root.right:\n                    dfs(root.right, n + [root.val])\n        dfs(root, [])\n        return sum(nums)\n```\n\n**时间复杂度** O(n) 每个节点访问一次。\n\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flower-f":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829635","body":"### 解题思路\n题型：模拟\n思路：模拟加法运算，大于或等于 10 就向前进位\n\n### 代码\n\n```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n    let carry = 0; // 记录进位\n    let i = num.length - 1; // 记录当前 num 数字的指针\n    const res = []; // 结果\n\n    // 当 i >= 0 或 k > 0 或 carry > 0 的时候，说明需要继续进行加法\n    while(i >= 0 || k > 0 || carry > 0) {\n        const k_add = k > 0 ? k % 10 : 0; // k 提供的加数\n        const num_add = i >= 0 ? num[i] : 0; // num 提供的加数\n        const sum = k_add + num_add + carry; // 求和\n        res.push(sum % 10); // 存储结果\n        carry = Math.floor(sum / 10); // 计算进位\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n\n    return res.reverse();\n};\n```\n\n### 复杂度\n时间：O(max(n, m))\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992054660","body":"### 解题思路\n使用双指针，因为对于一个点来说，影响距离的字符 c 最多只有两个（当两个 c 在该点的不同方向）。\n具体思路见代码注释。\n\n### 代码\n\n```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n    const arr: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            arr.push(i); // 存储所有的字符 c 位置\n        }\n    }\n\n    const res: number[] = [];\n    let cur = 0; // 当前选择的下标\n    let index1, index2; // 双指针\n    if (arr.length === 1) {\n        index1 = index2 = arr[0];\n    } else {\n        index1 = arr[cur], index2 = arr[++cur];\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        // 当超越了 index2 指针的时候，就需要交换指针了\n        // 此处需要考虑数组边界\n        if (i > index2 && cur + 1 <= arr.length - 1) {\n            index1 = index2;\n            index2 = arr[++cur];\n        }\n\n        const dist1 = Math.abs(index1 - i);\n        const dist2 = Math.abs(index2 - i);\n        res.push(Math.min(dist1, dist2));\n    }\n\n    return res;\n};\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993190380","body":"### 解题思路\n使用数组模拟栈\n\n### 代码\n\n```typescript\nclass CustomStack {\n    maxSize: number;\n    stack: number[];\n\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n        this.stack = [];\n    }\n\n    push(x: number): void {\n        if(this.stack.length < this.maxSize) {\n            this.stack.push(x);\n        }\n    }\n\n    pop(): number {\n        if (this.stack.length === 0) {\n            return -1;\n        }\n        return this.stack.pop();\n    }\n\n    increment(k: number, val: number): void {\n        let needPop = Math.min(k, this.stack.length); // 需要弹出栈顶的元素数量\n\n        for(let i = 0; i < needPop; i++) {\n            this.stack[i] = this.stack[i] + val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度\n时间 O(k)\n空间 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994383806","body":"### 解题思路\n使用两个栈，一个存储倍数，一个存储字符串。遇到 [ 进栈，] 出栈。具体思路见代码注释。\n\n### 代码\n\n```typescript\nfunction decodeString(s: string): string {\n    const numStack: number[] = []; // 存储倍数的栈\n    const strStack: string[] = []; // 存储字符串的栈\n\n    let num = 0; // 暂存倍数\n    let str = ''; // 暂存字符串\n\n    for (const ch of s) {\n        if(!isNaN(+ch)) {\n            // 如果是数字\n            num = num * 10 + parseInt(ch);\n        } else if (ch === '[') {\n            // 入栈\n            numStack.push(num);\n            strStack.push(str);\n            // 清零\n            str = '';\n            num = 0;\n        } else if (ch === ']') {\n            // 出栈\n            const times = numStack.pop(); // 重复倍数\n            const temp = strStack.pop();  // 取出当前栈顶字符串\n            str = temp + str.repeat(times); // 更新 str\n        } else {\n            // 如果是字母\n            str += ch;\n        }\n    }\n\n    return str;\n};\n```\n\n### 复杂度\n时间：O(n * maxRepeatTimes)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995472754","body":"### 解题思路\n两个栈，其中一个只能 push，另一个只能 pop。\n\n### 代码\n\n```typescript\nclass MyQueue {\n    stack1: number[];\n    stack2: number[];\n    constructor() {\n        this.stack1 = [];\n        this.stack2 = [];\n    }\n\n    push(x: number): void {\n        this.stack1.push(x);\n    }\n\n    pop(): number {\n        if(this.stack2.length) {\n            return this.stack2.pop();\n        }\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n        return this.stack2.pop();\n    }\n\n    peek(): number {\n        if(this.stack2.length) {\n            return this.stack2[this.stack2.length - 1];\n        }\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty(): boolean {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n复杂度：\n时间：O(n)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996392625","body":"### 解题思路\n将栈中每一个减序列压缩合并成该序列的最大的值，最终返回栈的长度。\n\n### 代码\n\n```typescript\nfunction maxChunksToSorted(arr: number[]): number {\n    const stack: number[] = [];\n    for (const num of arr) {\n        if (stack.length && num < stack[stack.length - 1]) {\n            const top = stack[stack.length - 1];\n            while (stack.length && num < stack[stack.length - 1]) {\n                stack.pop();\n            }\n            stack.push(top);\n        } else {\n            stack.push(num);\n        }\n    }\n    return stack.length;\n};\n```\n\n### 复杂度\n时间：O(n)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997178091","body":"### 解题思路\n假设链表长度为 n。首先显然需要 k % n，然后只需要将链表的后 k 个节点移动到链表的最前面，然后将链表的后 k 个节点和前 n - k 个节点连接到一块即可。问题就转变成了找到链表的尾节点、头节点（已知）、第 n - k 个节点。\n\n### 代码\n\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if (head === null || k === 0) {\n        // return null\n        return head;\n    }\n    let n = 0; // 链表长度\n    let tail = null; // 存储尾节点\n    for (let p = head; p !== null; p = p.next) {\n        n++;\n        tail = p;\n    }\n    k %= n;\n    let nk = head; // 第 n - k 个节点\n    for (let i = 0; i < n - k - 1; i++) {\n        nk = nk.next;\n    }\n    tail.next = head;\n    head = nk.next;\n    nk.next = null;\n\n    return head;\n};\n```\n\n### 复杂度\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997415679","body":"### 解题思路\n思路见代码注释\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) {\n        return head;\n    }\n    const res = head.next; // 答案\n    let preNode = new ListNode(-1); // 表示虚拟头节点\n    preNode.next = head;\n\n    let cur = head; \n    // A.next = B.next;\n    // B.next = A;\n    // preA.next = B;\n    while (cur && cur.next) {\n        const B = cur.next;\n        const nextB = B.next;\n        // A 节点的 next 指向 nextB\n        cur.next = nextB;\n        // B 节点的 next 指向 A\n        B.next = cur;\n        // preA 节点的 next 指向 B\n        preNode.next = B;\n        // 修改 preNode\n        preNode = cur;\n        // 移动 cur\n        cur = nextB;\n    }\n    return res;\n};\n```\n\n### 复杂度\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997568356","body":"### 解题思路\n二叉搜索树的任意一个节点，当前节点的值必然大于所有左子树节点的值，且必然小于所有右子树节点的值。获取当前链表的中点，以链表中点为根，中点左边的值都小于它，可以构造左子树；中点右边的值都大于它，可以构造右子树。获取链表的中点，可以使用快慢指针解决。\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) {\n        return null;\n    }\n    return dfs(head, null);\n\n    function dfs(head, tail) {\n        if (head === tail) {\n            return null;\n        }\n\n        // 查找链表中点\n        let slow, fast;\n        slow = fast = head;\n        while (fast !== tail && fast.next !== tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        // 此时慢指针即为中点\n        const root = new TreeNode(slow.val);\n\n        // 递归构建左子树\n        root.left = dfs(head, slow);\n        // 右子树\n        root.right = dfs(slow.next, tail);\n\n        return root;\n    }\n};\n```\n\n### 复杂度\n设链表长度为 n\n时间：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为 O(nlogn)\n空间：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998423261","body":"### 解题思路\n- 如果指针 pA 不为空，则将指针 A 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。\n- 如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let curA = headA, curB = headB;\n\n    while (curA !== curB) {\n        curA = curA ? curA.next : headB;\n        curB = curB ? curB.next : headA;\n    }\n\n    return curA;\n};\n```\n\n### 复杂度\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999263781","body":"### 解题思路\n使用快慢指针，可以证明如果链表存在环，则快慢指针最终将会相遇。\n\n设链表共有 a + b 个节点，其中链表头部到链表入口 有 a 个节点（不计链表入口节点），链表环有 b 个节点。\n根据：\nf = 2s（fast 走的步数是 slow 步数的 2 倍）\nf = s + nb (fast 比 slow 多走了 n 个环的长度）\n推出：\nf = 2nb，s = nb （fast 和 slow 分别走了 2n，n 个环的周长）\n\n从 head 结点走到入环点需要走：a + nb， 而 slow 已经走了 nb，那么 slow 再走 a 步就是入环点了。\n如何知道 slow 刚好走了 a 步？fast 从 head 开始，和 slow 指针一起走，相遇时刚好就是 a 步。\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let slow, fast;\n    slow = fast = head;\n    while (fast && fast.next) {\n        fast = fast.next.next;\n        slow = slow.next;\n\n        // 若存在环\n        if (slow === fast) {\n            break;\n        }\n    }\n\n    // 边界特判\n    if (fast === null || fast.next === null) {\n        return null;\n    }\n\n    // 寻找节点\n    fast = head;\n    while (slow !== fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n\n    return fast;\n};\n```\n\n### 复杂度\n\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000012664","body":"### 解题思路\n\n双链表 + 哈希表\n\n### 代码\n\n```javascript\n/** \n * @param {number} key\n * @param {number} value\n */\nvar DoubleLinkedListNode = function(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n    // 通过 dummy 节点减少边界处理\n    this.dummyHead = new DoubleLinkedListNode(null, null);\n    this.dummyTail = new DoubleLinkedListNode(null, null);\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @return {boolean}\n */\nLRUCache.prototype._isFull = function() {\n    return this.map.size === this.capacity;\n}\n\n/** \n * @param {DoubleLinkedListNode}\n * @return {DoubleLinkedListNode}\n */\nLRUCache.prototype._removeNode = function(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    // 删除节点\n    node.prev = null;\n    node.next = null;\n    return node;\n}\n\n/** \n * @param {DoubleLinkedListNode}\n */\nLRUCache.prototype._addToHead = function(node) {\n    const head = this.dummyHead.next;\n    node.next = head;\n    head.prev = node;\n    node.prev = this.dummyHead;\n    this.dummyHead.next = node;\n}\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map.has(key)) {\n        // get 的要放到链表头\n        const node = this.map.get(key);\n        this._addToHead(this._removeNode(node));\n        return node.value;\n    } else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        // 若已存在，修改值，然后将其放到链表头\n        const node = this.map.get(key);\n        node.value = value;\n        this._addToHead(this._removeNode(node));\n    } else {\n        if (this._isFull()) {\n            // 容量已满，去除尾节点，同时删除哈希表中的对应 key\n            const node = this.dummyTail.prev;\n            this.map.delete(node.key);\n            this._removeNode(node);\n        }\n        // 添加头节点\n        const node = new DoubleLinkedListNode(key, value);\n        this.map.set(key, node);\n        this._addToHead(node);\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```\n\n### 复杂度\n\n时间：O(1)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000598935","body":"### 解题思路\n如果知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 `maxDepth = max(l, r) + 1`，所以可以使用递归解决\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n\n    const left = maxDepth(root.left), right = maxDepth(root.right);\n    const maxHeight = Math.max(left, right) + 1;\n\n    return maxHeight;\n};\n```\n\n### 复杂度\n时间：O(N) N 为节点数\n空间：O(H) H 为树高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000978287","body":"### 解题思路\n\n递归\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if (!p && !q) {\n        return true;\n    }\n    if (!p || !q) {\n        return false;\n    }\n\n    return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n\n### 复杂度\n\n时间：O(N)，其中 N 为树的节点数\n空间：O(H)，其中 H 为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001098066","body":"### 解题思路\n\nDFS\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (!root) {\n        return 0;\n    }\n    let res = 0;\n    dfs(root, 0);\n    return res;\n\n    function dfs(root, sum) {\n        if (!root) {\n            return;\n        }\n\n        sum = sum * 10 + root.val;\n\n        // 到达叶子节点\n        if (!root.left && !root.right) {\n            res += sum;\n        }\n\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n    }\n};\n```\n\n### 复杂度\n\n时间：O(N)，N为节点个数\n空间：O(H)，H为树高","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829645","body":"### 思路\n本来的思路是直接算，然后翻转，遇到几个问题\n1. 数据会超过int的范围，需要用BigInteger(Java)\n2. 循环次数过多\n然后看了题解，将k当成一个整体与每一位运算\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(Max(N,logK))，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992082947","body":"### 思路\n粗暴做法，直接选出所有的C，然后一个个比较，取最小值，看题解之后发现可以先找出在右边的最小值，再找出在左边的最小值\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\t\tint N = s.length();\n\t\tint[] ans = new int[N];\n\t\tint pre = -N;\n\t\tfor(int i = 0; i<N;i++) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = i-pre;\n\t\t}\n\t\tpre = 2*N;\n\t\tfor(int i = N-1; i>=0;i--) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = Math.min(ans[i],pre-i);\n\t\t}\n\t\treturn ans;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993123932","body":"### 思路\n栈具有先进后出的特性，可以用数组来实现\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int maxSize = 0;\n    int size = 0;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if(size<maxSize) {\n            this.stack[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if(size>0) {\n            int result = stack[size -1];\n            size --;\n            return result;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i<size; i++) {\n            stack[i] = stack[i]+ val;\n        }\n    }\n}\n```\n### 时空复杂度\n时间复杂度\npush O(1) pop O(1) increment O(min(K,N))\n空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994435449","body":"### 思路\n使用栈，遇到了]就开始出栈，一直到[，这样拼成一个新的字符之后，根据之前的数字重新入栈，这个数字可能是好几位，所以要特殊处理下\n\n### 代码\n```java\nclass Solution {\n    static Stack<String> strings = new Stack<>();\n    public static String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        for(int i = 0; i < chars.length; i++) {\n            if(chars[i] != ']') {\n                if(Character.isDigit(chars[i])) {\n                    int tempCal = 0;\n                    while(Character.isDigit(chars[i])){\n                        tempCal = tempCal*10 + chars[i] - '0';\n                        i++;\n                    }\n                    i--;\n                    strings.push(String.valueOf(tempCal));\n                } else {\n                    strings.push(String.valueOf(chars[i]));\n                }\n\n            } else {\n                String poped, temp = \"\", newString=\"\";\n                while(!(poped = strings.pop()).equals(\"[\")) {\n                    temp = poped + temp;\n                }\n                poped = strings.pop();\n                int cal = Integer.parseInt(poped);\n                for(int j = 0; j < cal;j++) {\n                    newString += temp;\n                }\n                strings.push(newString);\n            }\n        }\n        String ans = \"\";\n        while(!strings.isEmpty()) {\n            ans = strings.pop()+ans;\n        }\n        return ans;\n    }\n}\n```\n### 时间复杂度\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995358488","body":"## 思路\n使用两个栈实现，结合栈FILO的特性和队列FIFO的要求，可以在push的时候进行一次倒腾，均摊时间复杂度可以缩短整体的时间复杂度到O(1)\n## 代码\n```java\nimport java.util.Stack;\n\nclass MyQueue {\n    Stack<Integer> stack;\n    Stack<Integer> tempStack;\n\n    public MyQueue() {\n        this.stack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        if(stack.isEmpty()) {\n            stack.push(x);\n        } else {\n          while(!stack.isEmpty()) {\n              tempStack.push(stack.pop());\n          }\n          stack.push(x);\n          while(!tempStack.empty()) {\n              stack.push(tempStack.pop());\n          }\n        }\n    }\n    \n    public int pop() {\n        return stack.pop();\n    }\n    \n    public int peek() {\n        return stack.peek();\n    }\n    \n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n```\n时间复杂度\npush O(N)\npop O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996823481","body":"### 思路\n滑动窗口\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n### 复杂度\n时间 O(NLogN)\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997127298","body":"### 思路\n把链表头尾相连，连城一个环，然后开始转\n\n### 代码\n```java\nclass Solution {\n    public static ListNode rotateRight(ListNode head, int k) {\n        if(head == null) {\n            return head;\n        }\n        ListNode pointer = head;\n        int listSize = 1;\n        while (pointer.next != null) {\n            pointer = pointer.next;\n            listSize ++;\n        }\n        pointer.next = head;\n        int m = k / listSize;\n        for(int i = 0; i < (m+1)*listSize-k;i++) {\n            head = head.next;\n            pointer = pointer.next;\n        }\n        pointer.next = null;\n        return head;\n    }\n}\n```\n### 复杂度\n时间复杂度 O(N)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414891","body":"### 思路\n递归\n### 代码\n```go\nfunc swapPairs(head *ListNode) *ListNode {\n    head = swap(head)\n    return head\n}\n\nfunc swap(node *ListNode) *ListNode{\n\tif node == nil||node.Next==nil{\n\t\treturn node\n\t}\n\ttemp := node.Next\n\tnode.Next = temp.Next\n\ttemp.Next = node\n\tnode = temp\n\tnode.Next.Next = swap(node.Next.Next)\n\treturn node\n}\n```\n### 复杂度\n时间复杂度 O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998020129","body":"### 思路\n分治\n### 代码\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n### 复杂度\n时间复杂度O(NlogN)\n空间复杂度O(logN)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000716420","body":"### 思路\r\n子问题\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) {\r\n            return 0;\r\n        }\r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n}\r\n```\r\n### 时间复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000960036","body":"### 思路\n利用BFS的方法，一边遍历一边判断，代码很长，不过执行速度是很可观的，因为可以很快终止不一致的场景\n### 代码\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if((p!=null)^(q!=null)) {\n            return false;\n        }\n        if(p == null) {\n            return true;\n        }\n        if( p.val != q.val) {\n            return false;\n        }\n        List<TreeNode> QueueP = new ArrayList<>();\n        QueueP.add(p);\n        List<TreeNode> QueueQ = new ArrayList<>();\n        QueueQ.add(q);\n        while((!QueueP.isEmpty()) && (!QueueQ.isEmpty())) {\n            TreeNode AL = QueueP.get(0).left;\n            TreeNode BL = QueueQ.get(0).left;\n            if((AL!=null)^(BL!=null)) {\n                return false;\n            } else if(AL != null) {\n                if(AL.val != BL.val) {\n                    return false;\n                } else {\n                    QueueP.add(AL);\n                    QueueQ.add(BL);\n                }\n            }\n            TreeNode AR = QueueP.get(0).right;\n            TreeNode BR = QueueQ.get(0).right;\n            if((AR!=null)^(BR!=null)) {\n                return false;\n            } else if(AR != null) {\n                if(AR.val != BR.val) {\n                    return false;\n                } else {\n                    QueueP.add(AR);\n                    QueueQ.add(BR);\n                }\n            }\n            QueueP.remove(0);\n            QueueQ.remove(0);\n        }\n        return true;\n    }\n}\n```\n### 复杂度\n时间复杂度O(min(p,q))\n空间复杂度O(min(p,q))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001102687","body":"### 思路\n使用DFS，似乎还有回溯\n### 代码\n```java\nclass Solution {\n    List<Integer> numberRecords = new ArrayList<>();\n\n    public void DFS(TreeNode treeNode, int value) {\n        value = value * 10 + treeNode.val;\n        if(treeNode.left == null && treeNode.right == null) {\n            numberRecords.add(value);\n            return;\n        }\n        if(treeNode.left !=null) {\n            DFS(treeNode.left, value);\n        }\n        if(treeNode.right != null) {\n            DFS(treeNode.right, value);\n        }\n    }\n\n    public int sumNumbers(TreeNode root) {\n        DFS(root,0);\n        int result = 0;\n        for(int v:numberRecords) {\n            result+=v;\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n+ 时间复杂度 O(N)\n+ 空间复杂度 O(N) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awesomelittle76":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991830816","body":"思路\n大整数的存储\n从高位到低位存，方便进位\n例：123456789 -> [9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n相加\n用代码模拟两数相加\n[A3, A2, A1, A0] + [B2, B1, B0]\n-> C0 = A0 + B0 如果 C0 > 10，则进位\n-> C1 = A1 + B1 + t(有进位则为1，否则为0)\n-> C2 = A2 + B2 + t\n-> C3 = A2 + t\n\nTS语法部分\nTS中的Number数据类型并不是int，所以在取余数的时候，要额外做取整\n\n代码\n\nfunction addToArrayForm(num: number[], k: number): number[] {\n  num.reverse();\n  for (let i = 0; i < num.length; i++) {\n    k += num[i];\n    num[i] = k % 10;\n    k = (k / 10) | 0;\n  }\n  while (k > 0) {\n    num.push(k % 10);\n    k = (k / 10) | 0;\n  }\n  num.reverse();\n  return num;\n}\n\n\n分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992346123","body":"思路\n设想\n1. 对每一个位置，找到左边最近的 c，再找到右边最近的 c\n2. 计算左右分别距离是多少，取最小值\n步骤\n1. 从左到右遍历字符串，用 j 来表示当前最后一个 c 在什么位置，就可以求得第 i 个元素，左边最近的 c 的距离\n2. 同理从右到左遍历字符串，求得右边最近的 c 的位置\n3. 取 min\n注意点\n1. ts中，生成填充数组如果直接 new Array(5) 仅仅是具有length属性，遍历的时候依然是空的，需要 fill 具体的值\n2. for loop中，计算距离要想清楚是 i-j 还是 j-i，当从左向右遍历时，找到是左侧最近的 c，j <= i，反之 j >= i\n3. for loop 中，维护 j 可以写在第一个 for 分句里，for (let i = 0, j = -1 ... ) 这样，和写在外面 let j=-1 是一样的，这样更简洁\n\n代码\nfunction shortestToChar(s: string, c: string): number[] {\n    const n = s.length\n    let res:number[] = new Array(n).fill(-1)\n    for (let i = 0, j = -1; i < n; i++) {\n        if (s[i] === c) j = i\n        if (j !== -1) res[i] = i - j\n    }\n    for (let i = n-1, j = -1; i >=0; i--) {\n        if (s[i] === c) j = i\n        if (j !== -1) res[i] === -1 ? res[i] = j - i : res[i] = Math.min(j - i, res[i])\n    }\n    return res\n};\n分析\n时间复杂度：O(2n)\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993436197","body":"思路\n用数组模拟一个栈，维护变量 top 记录栈顶的位置，用辅助数组 add 来实现 O(1) 的 inc 操作。\n● push：当前元素未达到上限 -> top + 1，推元素入数组\n● pop：当前数组不为空 -> top - 1，推元素出数组\n● inc：考虑到只有在 pop 的时候，才会明确元素有无被增量操作，因此可以在 inc 中操作 add 数组，记录每个位置元素的增量，在 pop 的时候具体执行增量操作。\n\n代码\nclass CustomStack {\n    arr : number[]\n    add : number[]\n    top :number\n\n    constructor(maxSize: number) {\n        this.arr = new Array(maxSize).fill(0)\n        this.add = new Array(maxSize).fill(0)\n        this.top = -1\n    }\n\n    push(x: number): void {\n        if (this.top != this.arr.length - 1) {\n            this.top += 1\n            this.arr[this.top] = x\n        }\n    }\n\n    pop(): number {\n        if (this.top === -1) return -1\n        const res = this.arr[this.top] + this.add[this.top]\n        if (this.top != 0) this.add[this.top - 1] += this.add[this.top]\n        this.add[this.top] = 0\n        this.top -= 1\n        return res\n    }\n\n    increment(k: number, val: number): void {\n        const p = Math.min(k - 1, this.top)\n        if (p >= 0) this.add[p] += val\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n分析\n● 时间复杂度：O(1)\n● 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994687549","body":"## 思路\n将右括号作为停止递归的条件:\n1. 字母 => 把当前的字母加到 res 里\n2. 数字 => 找到最后一个数字字符的位置，将这一位前面的字符用递归加到 res 里\n\n注意\n在遇到右括号并处理数字的时候，要记得过滤右括号\n\n## 代码\n```\nfunction decodeString(s: string): string {\n    let u = 0\n    const dfs = (s: string) : string => {\n        let res = ''\n        while(u < s.length && s[u] !== ']'){\n            // s[u]为字母\n            if ((s[u] >= 'a' && s[u] <= 'z') \n            || (s[u] >= 'A' && s[u] <= 'Z'))  {\n                res += s[u]\n                u += 1\n            }\n            // s[u]为数字\n            else if (s[u] > '0' && s[u] < '9') {\n                let k = u\n                // 找数字的最后一位\n                while (s[k] >= '0' && s[k] <= '9') k += 1\n                // 取数字字符串，转为数字，如共重复 32 次\n                let num = parseInt(s.substr(u, k - u)) \n                // u 跳到所有数字字符的后一位\n                u = k + 1\n                const y = dfs(s)\n                // 过滤括号\n                u += 1\n                // 重复 num 次\n                while(num --){ \n                    res += y\n                }\n            }\n        }\n        return res\n    }\n    return dfs(s)\n};\n```\n## 分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995694731","body":"## 思路\n用数组的 push 实现 push；pop 时用另一个数组存 pop 出来的元素；用 index 取 0 做 peek 和 empty 。\n\n## 代码\nclass MyQueue {\n  q: number[];\n  s: number[];\n  constructor() {\n    this.q = [];\n    this.s = [];\n  }\n\n  push(x: number): void {\n    this.q.push(x);\n  }\n\n  pop(): number {\n    while (this.q.length > 1) {\n      this.s.push(this.q.pop()!);\n    }\n    const res = this.q.pop();\n    while (this.s.length) {\n      this.q.push(this.s.pop()!);\n    }\n    return res!;\n  }\n\n  peek(): number {\n    return this.q[0];\n  }\n\n  empty(): boolean {\n    return this.q.length === 0;\n  }\n}\n\n## 分析\npush 时间 O(1) 空间O(n)\npop  时间 O(2n) 空间O(2n)\npeek  时间 O(1) 空间O(1)\nempty  时间 O(1) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996644807","body":"思路\n\n贪心\n将整个数组 a 排序记作 b，a 的第一部分和b 的第一部分应该是一样的，a 的第二部分和b 的第二部分应该是一样的，依次类推。\n从左往右遍历 a，当扫描到第一个位置 n，使得a[0,n] 和 b[0,n] 的元素是一致的，那么 [0,n] 就可以作为一个区间，依次类推。\n\n代码\nfunction maxChunksToSorted(arr: number[]): number {\n  let res = 0;\n  // 把原始数组 arr 进行排序\n  let b = [...arr].sort((a, b) => a - b);\n  // 定义 map，key 是 arr 的每一个元素，值的初始值为 0\n  let m = new Map();\n  arr.forEach((x) => m.set(x, 0));\n  // m[arr[i]] 的值是否为零，也就是在这个区间里，arr[i] 同时在 arr 和 b 里\n  for (let i = 0, s = 0; i < arr.length; i++) {\n    if (m.get(arr[i]) === 1) s -= 1;\n    else if (m.get(arr[i]) === 0) s += 1;\n    m.set(arr[i], m.get(arr[i]) - 1);\n    if (m.get(b[i]) === -1) s -= 1;\n    else if (m.get(b[i]) === 0) s += 1;\n    m.set(b[i], m.get(b[i]) + 1);\n    if (!s) res += 1;\n  }\n  return res;\n}\n\n分析\n时间复杂度 O(nlogn)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997134277","body":"思路\n设链表长度为 n，每旋转 n 次就会恢复原状，因此旋转 k 次取模即可，即计算 k % n 次。\n旋转 k 次，即把链表后 k 个节点移到开头，然后把结尾指向原来的头结点。\n1. 遍历链表，求长度，取 k % n\n2. 跳 n - k - 1 次，可以跳到后 k 个节点的前一个节点，将这个节点指向空节点，这个节点的下一个节点，作为头结点\n3. 尾节点指向原来的头结点\n4. 返回新的头结点\n\n代码\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n  if (!head) return head;\n  // 计算链表长度\n  let n = 0, p = head;\n  while (p !== null) {\n    n += 1;\n    p = p.next!;\n  }\n  // 对 k 取模，如果等于零直接返回\n  k = k % n;\n  if (!k) return head;\n  // 找到 n-k-1 个节点\n  p = head;\n  while (n - k - 1 > 0) {\n    p = p.next!;\n    n -= 1;\n  }\n  // 后一个节点是新的头结点\n  const newH = p!.next;\n  // n-k-1 个节点指向 null\n  p!.next = null;\n  // 找到原来的尾节点，指向原来的头节点\n  let tail = newH;\n  while (tail!.next != null) tail = tail!.next;\n  tail!.next = head;\n  // 返回新的头结点\n  return newH;\n}\n\n分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997318324","body":"思路\n创建虚拟头结点 dummy，指向 head：dummy -> head -> 2 -> 3 -> 4 -> 5，交换指针：\ndummy -> 2\n2 -> head \nhead -> 3\n完成后，链表变成 dummy -> 2 -> 1 -> 3 -> 4 -> 5，将指向 dummy 的指针往后移动继续之前的操作，直到结尾。\n\n代码\nfunction swapPairs(head: ListNode | null): ListNode | null {\n  if (!head) return null;\n  const dummy = new ListNode(-1);\n  dummy.next = head;\n  let temp = dummy;\n  while (temp.next && temp.next.next) {\n    const a = temp.next,\n      b = temp.next.next;\n    temp.next = b;\n    a.next = b.next;\n    b.next = a;\n    temp = a;\n  }\n  return dummy.next;\n}\n分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001015060","body":"思路\n相同的定义：树的形状一样，每个节点值也一样\n因此按照相同的顺序，遍历两个树，比较对应位置的值，如果不一样，返回 false，如果都一样，返回 true。\n\n代码\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    // 特判\n    if (!p && !q) return true\n    if (!p || !q || p.val !== q.val) return false\n    // 递归对比每个节点\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n分析\n时间复杂度：O(min(p,q))\n空间复杂的：O(min(p,q))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001110724","body":"思路\ndfs 获取从根节点开始的每个数字，规律是 number =  number * 10 + k。\n\n代码\nfunction sumNumbers(root: TreeNode | null): number {\n  let ans = 0;\n  const dfs = (root: TreeNode, num: number) => {\n    num = num * 10 + root.val;\n    if (!root.left && !root.right) ans += num;\n    if (root.left) dfs(root.left, num);\n    if (root.right) dfs(root.right, num);\n  };\n  if (root) dfs(root, 0);\n  return ans;\n}\n分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arya-03":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991831460","body":"**代码1**\r\n初始版本，除了代码短，没有优点。执行用时：4928 ms, 在所有 Python3 提交中击败了6.65%的用户，内存消耗：15.6 MB, 在所有 Python3 提交中击败了27.26%的用户。\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        len_A=len(num)\r\n        sum=0\r\n        sum_a=0\r\n        for i in range(len_A):\r\n            sum_a=sum_a+num[i]*pow(10,(len_A-1-i))\r\n        sum=sum_a+k\r\n        result=list(map(int, str(sum)))\r\n        return result\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995437067","body":"### 思路\r\n **「输入栈」会把输入顺序颠倒；如果把「输入栈」的元素逐个弹出放到「输出栈」，再从「输出栈」弹出元素的时候，则可以负负得正，实现了先进先出。**\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999622868","body":"```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluetomlee":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991833123","body":"```\r\n// train of thought：\r\n// Add up each number.Then fill the next one\r\n// the first step is traverse the array ,then the index value add then k of index number.\r\n// the second step is check boundary condition to ensure all numbers added.because num's array size is correct, but not sure k is correct\r\n// the third step is reversing array\r\n\r\n// complexity analysis：O(n)\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int size = num.size();\r\n        for(int n = size - 1; n >= 0; n--) {\r\n            int sum = num[n] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                // for next loop to complement\r\n                k++;\r\n                sum = sum % 10;\r\n            }\r\n            res.push_back(sum);\r\n        }\r\n\r\n        for (; k > 0; k /= 10) {\r\n            res.push_back(k % 10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992556798","body":"```\n// thought:\n// double pointer，\n// i record c's index\n// j record current loop index\n// complexity analysis: O(n)\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector <int>res;\n        int length = s.size();\n        int i = 0;\n        for (int k = 0; k < length; k++) {\n            if (s[k] == c) {\n                i = k;\n            }\n        }\n        for (int k = 0; k < length; k++) {\n            if (s[k] == c) {\n                i = k;\n                res.push_back(0);\n            } else if (s[k] != c) {\n                res.push_back(abs(i) - abs(k));\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993577684","body":"```\n// 熟悉c++操作用法，resize设置长度，min比三目运算更友好\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int count;\n\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        count = -1;\n    }\n    \n    void push(int x) {\n        if (count != stack.size() - 1) {\n            ++count;\n            stack[count] = x;\n        }\n    }\n    \n    int pop() {\n        if (count == -1) {\n            return -1;\n        }\n        --count;\n        return stack[count + 1];\n    }\n    \n    void increment(int k, int val) {\n        int size = min(k, count + 1);\n        for(int j = 0; j < size; ++j) {\n            stack[j] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994852656","body":"```\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995717363","body":"```\nclass MyQueue {\nprivate: \n    stack<int> inStack;\n    stack<int> outStack;\n\n    void inToOut() {\n        while(!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        inStack.push(x);\n    }\n    \n    int pop() {\n        if (inStack.empty()) {\n            inToOut();\n        }\n        int out = outStack.top();\n        outStack.pop();\n        return out;\n    }\n    \n    int peek() {\n        if (outStack.empty()) {\n            inToOut();\n        }\n        return outStack.top();\n    }\n    \n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996818722","body":"···\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = nonzero = 0\n\n        for x, y in zip(arr, sorted(arr))\n            count[x] += 1\n            if count[x] == 0: nonzero -= 1\n            if count[x] == 1: nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1: nonzero += 1\n            if count[y] == 0: nonzero -= 1\n\n            if nonzero == 0: ans += 1\n\n        return ans\n\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997212621","body":"```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n // 思路：Link the linked list to a cycle ring.\n // then find the last one of the new linked list and cut it off.\n // boundary condition： if n / k  ==  int，we dont have to do anything.\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        int length = 1;\n        if(k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n\n        ListNode *p = head;\n\n        // linked list to loop\n        while(p->next != nullptr) {\n            length++;\n            p = p->next;\n        }\n        // p become the last item\n        int step = length - k % length;\n\n        if (step == length) {\n            return head;\n        }\n\n        p->next = head;\n        while(step--){\n            p = p->next;\n        }\n\n        // cut it off\n        ListNode *res = p->next;\n        p->next = nullptr;\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997375849","body":"```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n // 1、递归\n // 2、万能的dummyHead\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998051360","body":"## 思路\n既定了是有序链表，则使用快慢指针先找到中位数，比如[1，2，3，4，5]，慢指针走到3的时候，快指针就走到了5.所以慢指针就是中位数\n中位数就是平衡二叉树的root。再来构造平衡二叉树\n\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* getMiddle(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMiddle(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998883827","body":"```\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode *> visited;\n        ListNode *temp = headA;\n        while (temp != nullptr) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp != nullptr) {\n            if (visited.count(temp)) {\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999685587","body":"```\n// 快慢指针 相遇表示有环，重置慢指针，块指针每次一步 相遇即是入口\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr) {\n            slow = slow->next;\n            if (fast->next == nullptr) {\n                return nullptr;\n            }\n            fast = fast->next->next;\n            if (fast == slow) {\n                ListNode *ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000875153","body":"## dfs实现\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        if (!root->left) {\n            return 1 + maxDepth(root->right);\n        }\n        if (!root->right) {\n            return 1 + maxDepth(root->left);\n        }\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001039285","body":"```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n // bfs 每层的结构都一样，循环到下一个。如果不一致就return false\n // dfs 到最底部检测是否一致\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n       if (p == NULL && q == NULL) {\n           return true;\n       }\n       if (p == NULL || q == NULL) {\n           return false;\n       }\n       if (p->val != q->val) {\n           return false;\n       }\n       return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stackvoid":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991833487","body":"## 思路\n\n- 建一个新数组，并从末尾遍历原始数组。\n- new[i]=(old[j]+k)%10   k=(old[j]+k)/10 是整个解题的核心。\n- 注意边界，返回正确结果即可。\n\n## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] cur = new int[num.length + 5];\n        int i = num.length - 1, j = 0;\n        for (; i >= 0; i--, j++) {\n            cur[j] = (k + num[i]) % 10;\n            k = (k + num[i]) / 10;\n        }\n        while (k != 0) {\n            cur[j++] = k % 10;\n            k = k / 10;\n        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int indexR = 0, indexCur = j - 1; indexR < j; indexR++, indexCur--) {\n            result.add(cur[indexCur]);\n        }\n        return result;\n    }\n}\n```\n\n\n\n## 算法分析\n\n时间复杂度：2次遍历数组，时间复杂度为O(N)\n\n空间复杂度：O(N)\n\nN 为 数组长度或K的最大值。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992078285","body":"## 思路\n\n- 遍历数组 寻找数组s中字符c出现的位置。\n- 遍历数组 寻找数组当前字符与mark中的距离 并取最小值\n- 返回结果数组即可\n\n## 代码\n\n```java\n\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> mark = new ArrayList<>();\n        char[] chars = s.toCharArray();\n        //1.遍历数组 寻找数组s中字符c出现的位置\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                mark.add(i);\n            }\n        }\n        //2.遍历数组 寻找数组当前字符与mark中的距离 取最小值\n        int[] result = new int[chars.length];\n        for (int j = 0; j < chars.length; j++) {\n            int distance = Integer.MAX_VALUE;\n            for (int k = 0; k < mark.size(); k++) {\n                int disTmp = Math.abs(j - mark.get(k));\n                if (disTmp < distance) {\n                    distance = disTmp;\n                }\n            }\n            result[j] = distance;\n        }\n        return result;\n    }\n}\n```\n\n\n\n## 复杂度分析\n\n时间复杂度：2次遍历数组，其中第二次遍历数组，还需再遍历中间结果数组，时间复杂度为O(N^2)\n\n空间复杂度：O(N)\n\nN 为 数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993194248","body":"### 思路\n\n- push和pop注意边界即可\n- inc 从栈底(数组0号)开始遍历，依次加上对应的val即可，注意 for 循环里的边界条件即可\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int maxSize;//数组最大长度\n    int curIndex;//当前数组下标\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        curIndex = -1;\n    }\n\n    public void push(int x) {\n        if (curIndex >= maxSize - 1) {\n            return;\n        }\n        curIndex++;\n        stack[curIndex] = x;\n    }\n\n    public int pop() {\n        if (curIndex < 0) {\n            return -1;\n        }\n        int resultValue = stack[curIndex];\n        curIndex--;\n        return resultValue;\n    }\n\n    public void increment(int k, int val) {\n        //栈底开始遍历\n        for (int index = 0; index < k && index <= curIndex; index++) {\n            stack[index] = stack[index] + val;\n        }\n    }\n}\n\n```\n\n### 复杂度分析\n\n- push：时间复杂度O(1)  空间复杂度O(1)\n- pop：时间复杂度O(1)  空间复杂度O(1)\n- inc：时间复杂度O(k)  空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994522512","body":"### 思路\n\n本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。\n\n算法流程：\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n- 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n- 当 c 为字母时，在 sb 尾部添加 c；\n- 当 c 为 [ 时，将当前 multi 和 sb 入栈，并分别置空置 0：\n     记录此 [ 前的临时结果 sb 至栈，用于发现对应 ] 后的拼接操作；\n     记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n     进入到新 [ 后，sb 和 multi 重新记录。\n- 当 c 为 ] 时，stack 出栈，拼接字符串 res = lastSb + curMulti * sb，其中:\n- lastSb是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n- curMulti是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n- 返回字符串 sb。\n\n### 代码\n\n```java\nimport java.util.LinkedList;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public String decodeString(String s) {\n        LinkedList<Integer> numStack = new LinkedList<>();\n        LinkedList<String> strStack = new LinkedList<>();\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        for (Character c : s.toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                sb.append(c);\n            } else if (c >= '0' && c <= '9') {\n                //从数组中获取的重复次数\n                multi = multi * 10 + Integer.valueOf(c + \"\");\n            } else if (c == '[') {\n                //关键点--次数和历史结果 要入栈\n                numStack.addLast(multi);\n                //重置multi参数\n                multi = 0;\n                strStack.addLast(sb.toString());\n                //重置SB\n                sb = new StringBuilder();\n            } else {\n                StringBuilder lastSb = new StringBuilder(strStack.removeLast());\n                int curMulti = numStack.removeLast();\n                for (int i = 0; i < curMulti; i++) {\n                    lastSb.append(sb.toString());\n                }\n                sb = new StringBuilder(lastSb.toString());\n            }\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：1次遍历数组，时间复杂度为O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995582511","body":"### 思路\n\n本题难点在于两个栈要互相配合，不同时机需要清空另外一个栈。\n\n构建辅助栈 stackA和stackReverse， 一定要注意 不能用 for(;i<stackA.size();),因为不管是push还是pop，stack都是变化的。\n这样i就完全不准了。\n\n### 代码\n\n```java\n\n\nimport java.util.LinkedList;\nclass MyQueue {\n\n    LinkedList<Integer> stackA;\n    LinkedList<Integer> stackReverse;\n\n    public MyQueue() {\n        stackA = new LinkedList<>();\n        stackReverse = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (stackReverse.size() > 0) {\n            //一定注意 stackReverse 是变化值\n            while (stackReverse.size() != 0) {\n                stackA.push(stackReverse.pop());\n            }\n        }\n        stackA.push(x);\n        stackReverse.clear();\n    }\n\n    public int pop() {\n        if (stackReverse.size() == 0) {\n            while (stackA.size() != 0) {\n                stackReverse.push(stackA.pop());\n            }\n        }\n        stackA.clear();\n        return stackReverse.pop();\n    }\n\n    public int peek() {\n        if (stackReverse.size() == 0) {\n            while (stackA.size() != 0) {\n                stackReverse.push(stackA.pop());\n            }\n        }\n        return stackReverse.peek();\n    }\n\n    public boolean empty() {\n        if (stackA.size() == 0 && stackReverse.size() == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：push() O(N);pop() O(N);peek O(N);empty() O(1)\n\n空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996634014","body":"### 思路\r\n\r\n我们知道数组 arr 在排序之后一定跟整个数组排序后相应的地方完全相同，即 expect = sorted(arr)。如果前 k 个元素的个数减去排序后前 k 个元素的个数都为 0 的话，那这前 k 个元素是可以成为一个合法的分块的。对于整个数组可以重复这一过程。\r\n\r\n用变量 nonzero 来计数目前差值不等于 0 的字符的个数。\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度: O(NlogN)，其中 N 为 arr 的长度。\r\n空间复杂度: O(N)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997207423","body":"### 思路\n\n- 1.找到链表总长度，顺便找到尾部节点。\n- 2.找到k对应在链表中的位置。\n- 3.将pre-k的节点 next 置为null，k对应的节点即为新的head。\n- 4.将首位连在一起。\n\n### 代码\n\n```java\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        int listSize = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            listSize++;\n            tail = tail.next;\n        }\n        //多亏测试用例\n        if (k % listSize == 0) {\n            return head;\n        }\n\n        int realK = listSize - (k % listSize);\n        ListNode kNode = head;\n        for (int i = 0; i < realK - 1; i++) {\n            kNode = kNode.next;\n        }\n        ListNode newHead = kNode.next;\n        kNode.next = null;\n        tail.next = head;\n        return newHead;\n    }\n}\n```\n### 复杂度分析\n\n- 时间复杂度: O(N)，其中N为链表的长度。\n- 空间复杂度: O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997395893","body":"### 思路\n\n假设链表总长是偶数，那么递归函数执行到终止条件时，head 就等于 null。如果链表链表总长是偶数，那么递归函数执行到终止条件时，head.next 就等于 null。\n递归函数内，我们要改变 1->2 的指向，将其改为 2->1。\n那后面的节点怎么办呢？不用担心，这是由下一层递归函数来解决。下一层递归函数返回后的节点是 4，就是4->3->...这样的了，也就是后面的节点都已经串联好了。所以我们只需要将 1 节点指向 4 就可以啦\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //递归的终止条件\n        if (head == null || head.next == null) {\n            return head;\n        }\n        //假设链表是 1->2->3->4\n        //这句就先保存节点2\n        //留下递归前的‘练习方式’\n        ListNode tmp = head.next;\n        //继续递归，处理节点3->4\n        //当递归结束返回后，就变成了4->3\n        //于是head节点就指向了4，变成1->4->3\n        head.next = swapPairs(tmp.next);\n        //将2节点指向1\n        tmp.next = head;\n        return tmp;\n    }\n}\n```\n### 复杂度分析\n\n- 时间复杂度: O(N)，其中N为链表的长度。\n\n- 空间复杂度: O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997733299","body":"### 思路\n\n1. 先找到链表中间节点，可以使用快慢指针\n2. 构建二叉树即可\n\n### 代码\n```java\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return dfs(head, null);\n    }\n\n    public TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) return null;\n        ListNode fast = head, slow = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n```\n\n### 复杂度分析\n时间复杂度：O(LogN)\n\n空间复杂度：O(LogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998768353","body":"### 思路\r\n比较简单，创建两个栈，两个链表分别入栈，然后分别top，看两个栈顶节点是否一致，一直到不一致那个节点完成遍历。\r\n\r\n### 代码\r\n```java\r\npublic class Solution {\r\n\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        LinkedList<ListNode> stackA = new LinkedList<>();\r\n        LinkedList<ListNode> stackB = new LinkedList<>();\r\n        ListNode curNodeA = headA;\r\n        ListNode curNodeB = headB;\r\n        while (curNodeA != null) {\r\n            stackA.push(curNodeA);\r\n            curNodeA = curNodeA.next;\r\n        }\r\n        while (curNodeB != null) {\r\n            stackB.push(curNodeB);\r\n            curNodeB = curNodeB.next;\r\n        }\r\n        ListNode crossNode = null;\r\n        int minSize = Math.min(stackA.size(), stackB.size());\r\n        for (int i = 0; i < minSize; i++) {\r\n            ListNode tmpNodeA = stackA.pop();\r\n            ListNode tmpNodeB = stackB.pop();\r\n            if (tmpNodeA.equals(tmpNodeB)) {\r\n                crossNode = tmpNodeA;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return crossNode;\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999336648","body":"### 思路\n暴力解比较简单。HashSet 只要有这样的节点，即找到了对应的环入口。\n\n### 代码\n\n```java\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        HashSet hashSet = new HashSet();\n        ListNode curNode = head;\n        while (curNode != null) {\n            if (hashSet.contains(curNode)) {\n                return curNode;\n            }\n            hashSet.add(curNode);\n            curNode = curNode.next;\n        }\n        return null;\n    }\n}\n```\n\n### 算法分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000019652","body":"### 思路\nLinkedHashMap 应用。比较简单。\n\n### 代码\n```java\nclass LRUCache {\n\n    LinkedHashMap<Integer, Integer> cacheHolder;\n    int capacity;\n\n    public LRUCache(int capacity) {\n        cacheHolder = new LinkedHashMap(capacity, 0.75f, true) {\n            @Override\n            protected boolean removeEldestEntry(Map.Entry eldest) {\n                return size() > capacity;\n            }\n        };\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n       return cacheHolder.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        cacheHolder.put(key, value);\n    }\n}\n```\n\n### 算法分析\n时间复杂度：O(1)\n\n空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000609251","body":"## 思路\n1. 深度递归遍历，返回每一个树节点 max(左节点深度，右节点深度)；直到叶子节点为止。\n2. 宽度遍历，多少层就是多少深度。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int leftDept = maxDepth(root.left);\n        int rightDept = maxDepth(root.right);\n        return Math.max(leftDept, rightDept) + 1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000976453","body":"## 思路\n树的遍历，然后比较当前节点的值是否相等和此节点的左右结构是否一样即可。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        boolean ans = false;\n        if (p.val == q.val) ans = true;\n        boolean left = isSameTree(p.left, q.left);\n        boolean right = isSameTree(p.right, q.right);\n        return ans && left && right;\n    }\n}\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001092670","body":"## 思路\n树的层序遍历；每次到下一层遍历都要 * 10，中间结果保存比较重要，看题目条件即可。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root == null) return 0;\n\n        LinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        int ans = 0;\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left != null) {\n                node.left.val = node.val * 10 + node.left.val;\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                node.right.val = node.val * 10 + node.right.val;\n                queue.offer(node.right);\n            }\n            if (node.left == null && node.right == null) {\n                ans += node.val;\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cszys888":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834012","body":"## 思路\r\n1. 转换num成一个integer，叫做int_num\r\n2. 利用python内置加法求和 int_num和k，得到 int_result\r\n3. 创建一个空数组，利用除法将int_result 转换成数组\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # transform num to an integer\r\n        int_num = 0\r\n        for digit in num:\r\n            int_num = int_num*10 + digit\r\n        \r\n        int_result = int_num + k\r\n\r\n        result = []\r\n        while int_result // 10 > 0:\r\n            result.append(int_result % 10)\r\n            int_result = int_result// 10\r\n        result.append(int_result)\r\n        result.reverse()\r\n        return result\r\n```\r\n\r\n## 复杂度分析\r\ntime complexity: o(N)\r\nspace complexity: o(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991992449","body":"## 思路\n1. 扫描s，记录c出现的位置，存在叫做locations的list里面\n2. 遍历locations里面记录的位置，根据每个位置去计算它周围与它距离最近的点的距离。这个过程也会正好遍历一次s字符串\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        locations = []\n        n = len(s)\n        for i in range(n):\n            if s[i] == c:\n                locations.append(i)\n        \n        result = []\n        for i in range(locations[0]):\n            result.append(abs(locations[0] - i))\n        for idx in range(1, len(locations)):\n            mid = (locations[idx]+locations[idx - 1])//2\n            for i in range(locations[idx-1],mid+1):\n                result.append(abs(locations[idx-1] - i))\n            for i in range(mid+1,locations[idx]):\n                result.append(abs(locations[idx] - i))\n        for i in range(locations[-1], n):\n            result.append(abs(locations[-1] - i))\n        \n        return result\n```\n\n## 复杂度分析\n时间复杂度：O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993017938","body":"## 思路\n用O(1)的时间复杂度实现所有的操作，除了increment function\n\n## 代码\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<=self.maxSize - 1:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            val = self.stack[- 1]\n            self.stack.pop()\n            return val\n\n\n    def increment(self, k: int, val: int) -> None:\n        if k > len(self.stack):\n            k = len(self.stack)\n        for idx in range(k):\n            self.stack[idx] = self.stack[idx] + val\n```\n\n## 复杂度\n时间复杂度:\nCustomStack: O(1)\npush: O(1)\npop: O(1)\nincrement: O(N)\n空间复杂度：\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994284242","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                tmp = \"\"\n                char = stack.pop()\n                while char != '[':\n                    tmp = char + tmp\n                    char = stack.pop()\n                digit = \"\"\n                print(stack)\n                while stack and stack[-1].isdigit():\n                    digit = stack.pop() + digit\n                digit = int(digit)\n                word = [tmp for _ in range(digit)]\n                word = \"\".join(word)\n                for t in word:\n                    stack.append(t)\n        return \"\".join(stack)\n```                \n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995432208","body":"```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n        self.head = 0\n        self.tail = 0\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n        self.tail += 1\n\n    def pop(self) -> int:\n        self.head += 1\n        return self.queue[self.head - 1]\n\n    def peek(self) -> int:\n        return self.queue[self.head]\n\n    def empty(self) -> bool:\n        if self.head == self.tail:\n            return True\n        else:\n            return False\n```\n\nTime Complexity: O(1)\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996429297","body":"```python3\n\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        non_zero_cnt = 0\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            if count[a] == -1: non_zero_cnt -= 1\n            if count[a] == 0: non_zero_cnt += 1\n            count[a] += 1\n            if count[b] == 1: non_zero_cnt -= 1\n            if count[b] == 0: non_zero_cnt += 1\n            count[b] -= 1\n            if non_zero_cnt == 0: ans += 1\n\n        return ans\n```\n\nTime complexity: O(NlogN)\nSpace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997146914","body":"\n# note\n1. corner cases\n2. count the length of linked list\n3. connect the linked list and make it linked list loop\n4. move forward until the new tail\n5. cut it back into linked list (non-loop)\n\n# code\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head:\n            return head\n\n        cur = head\n        n = 1\n\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        cur.next = head\n\n        move_next = n - k % n\n\n        while move_next:\n            cur = cur.next\n            move_next -= 1\n        \n        new_head = cur.next\n        cur.next = None\n\n        return new_head\n```\n\n# complexity\nTime: O(N)\nSpace: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997629361","body":"```python3\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def tree_length(head):\n            length = 0\n            while head is not None:\n                length += 1\n                head = head.next\n            return length\n        \n        def dfs(left, right):\n            if right < left:\n                return None\n            mid = (left + right + 1)//2\n            node = TreeNode()\n            node.left = dfs(left, mid - 1)\n            nonlocal head\n            node.val = head.val\n            head = head.next\n            node.right = dfs(mid + 1, right)\n            return node\n        \n        length = tree_length(head)\n        return dfs(0, length - 1)\n```\n\ntime comp: O(N)\nspace comp: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998496907","body":"```python3\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        na = 0\n        p1 = headA\n        while p1:\n            p1 = p1.next\n            na += 1\n        \n        nb = 0\n        p2 = headB\n        while p2:\n            p2 = p2.next\n            nb += 1\n\n        # align the length of two linked lists\n        if na > nb:\n            diff = na - nb\n            while diff:\n                headA = headA.next\n                diff -= 1\n        else:\n            diff = nb - na\n            while diff:\n                headB = headB.next\n                diff -= 1\n        \n        # start two pointers moving to the end\n        p1 = headA\n        p2 = headB\n        while (p1 is not None and p1!=p2):\n            p1 = p1.next\n            p2 = p2.next\n        return p1\n```\n\ntime comp: O(M+N)\nspace comp: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999319166","body":"定义快慢指针，快指针一次走两步，慢指针一次走一步\n如果快指针便成null，说明没有环\n如果快慢指针第一次相遇，说明有环，此时设置第三个指针，从头出发\n当第三指针与慢指针相遇，两指针处于环开始的地方，返回第三指针\n\n```python3\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        \n        fast = slow = head\n        while fast is not None and fast.next is not None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                ptr = head\n                while ptr!=slow:\n                    ptr = ptr.next\n                    slow = slow.next\n                return ptr\n        return None\n```\n\ntime comp: O(N)\nspace comp: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000042097","body":"```python3\nclass DLinkedList:\n    def __init__(self, key = None, value = None):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n\nclass LRUCache:\n    from collections import deque\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.capacity = capacity\n        self.size = 0\n        self.head = DLinkedList()\n        self.tail = DLinkedList()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.movetohead(node)\n            return node.value\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.movetohead(node)\n        else:\n            node = DLinkedList(key, value)\n            self.addtohead(node)\n            self.cache[key] = node\n            self.size += 1\n            if self.size > self.capacity:\n                del self.cache[self.removetail().key]\n                self.size -= 1\n    \n    def movetohead(self, node):\n        self.removenode(node)\n        self.addtohead(node)\n    \n    def addtohead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removenode(self, node):\n        node.next.prev = node.prev\n        node.prev.next = node.next\n\n    def removetail(self):\n        node = self.tail.prev\n        self.removenode(node)\n        return node\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rootdavid":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834365","body":"```cpp\n// 参考题解：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n      int n = num.size();\n      \n      vector<int> res;\n      int sum = 0, carry = 0;\n      int i = n - 1;\n\n      // 从后往前遍历是因为符合加法运算逻辑\n      while (i >= 0 || k != 0) {\n        // 对齐计算位数，补0\n        int x = i >= 0 ? num[i] : 0;\n        // %10 取个位\n        int y = k != 0 ? k % 10 : 0;\n\n        sum = x + y + carry;\n\n        carry = sum / 10;\n\n        i--;\n        k /= 10;\n\n        res.push_back(sum % 10);\n        \n      }\n\n      // 计算最后一位的时候，可能有进位问题，有进位的话补入结果数组\n      if (carry != 0) res.push_back(carry);\n\n      // res数组是倒序的，所以需要反转\n      reverse(res.begin(), res.end());\n\n      return res;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992473664","body":"```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n      int n = s.size();\n\n      // 初始化最小值，除2因为怕最大整数越界\n      int prev = INT_MIN / 2;\n      vector<int> res(n);\n\n      for (int i = 0; i < n; i++) {\n        if (s[i] == c) prev = i;\n        res[i] = i - prev;\n      }\n\n      prev = INT_MAX / 2;\n\n      for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == c) prev = i;\n        res[i] = min(res[i], prev - i);\n      }\n\n      return res;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993427654","body":"```cpp\nclass CustomStack {\npublic:\n    vector<int> stk, add;\n    int top;\n\n    CustomStack(int maxSize) {\n      stk.resize(maxSize);\n      add.resize(maxSize);\n\n      top = -1;\n    }\n    \n    void push(int x) {\n      if (top != stk.size() - 1) {\n        ++top;\n        stk[top] = x;\n      }\n    }\n    \n    int pop() {\n      if (top == -1) return -1;\n\n      int res = stk[top] + add[top];\n\n      if (top != 0) add[top - 1] += add[top];\n\n      add[top] = 0;\n\n      --top;\n      \n      return res;\n    }\n    \n    void increment(int k, int val) {\n      int lmt = min(k - 1, top);\n\n      if (lmt >= 0) add[lmt] += val;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994781072","body":"```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n      stack<int> nums;\n      stack<string> strs;\n\n      string cur;\n      int num = 0;\n\n      for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '[') {\n          nums.push(num);\n          strs.push(cur);\n\n          num = 0;\n          cur = \"\";\n        } else if (s[i] == ']') {\n          int t = nums.top();\n          nums.pop();\n\n          string tmp = cur;\n          cur = strs.top();\n          strs.pop();\n\n          while(t--) cur += tmp;\n        } else if (isdigit(s[i])) {\n          num = num * 10 + s[i] - '0';\n        } else {\n          cur += s[i];\n        }\n      }\n\n      return cur;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995392125","body":"```cpp\nclass MyQueue {\npublic:\n    stack<int> s1, s2;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n      s1.push(x);\n    }\n    \n    int pop() {\n      peek();\n      int top = s2.top();\n      s2.pop();\n      return top;\n    }\n    \n    int peek() {\n      if (s2.empty()) {\n        while (!s1.empty()) {\n          s2.push(s1.top());\n          s1.pop();\n        } \n      }\n\n      return s2.top();\n    }\n    \n    bool empty() {\n      return s1.empty() && s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996407553","body":"```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n      stack<int> maxStk;\n\n      maxStk.push(arr[0]);\n\n      for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < maxStk.top()) {\n          int maxNum = maxStk.top();\n          while (!maxStk.empty() && arr[i] < maxStk.top()) maxStk.pop();\n          maxStk.push(maxNum);\n        } else {\n          maxStk.push(arr[i]);\n        }\n      }\n\n      return maxStk.size();\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997177905","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n      int n = 0;\n      ListNode* tail;\n\n      if (!head) return head;\n\n      for (auto p = head; p; p = p->next) {\n        n++;\n        tail = p;\n      }\n\n      k %= n;\n\n      if (!k) return head;\n\n      auto p = head;\n      for (int i = 0; i < n - k - 1; i++) {\n        p = p->next;\n      }\n\n      tail->next = head;\n      head = p->next;\n      p->next = nullptr;\n\n      return head;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997360359","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      auto dummy = new ListNode(-1);\n      dummy->next = head;\n\n      for (auto p = dummy; p->next && p->next->next;) {\n        auto a = p->next, b = a->next;\n\n        p->next = b;\n        a->next = b->next;\n        b->next = a;\n\n        p = a;\n        \n      }\n\n      return dummy->next;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997707791","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n      return build(head, nullptr);\n    }\n\n    TreeNode* build(ListNode* l, ListNode* r) {\n\n      if (l == r) return nullptr;\n      \n      auto mid = getMid(l, r);\n      auto root = new TreeNode(mid->val);\n      root->left = build(l, mid);\n      root->right = build(mid->next, r);\n\n      return root;\n    }\n    \n    ListNode* getMid(ListNode* left, ListNode* right) {\n      ListNode* fast = left;\n      ListNode* slow = left;\n\n      while (fast != right && fast->next != right) {\n        fast = fast->next->next;\n        slow = slow->next;\n      }\n\n      return slow;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998404969","body":"```CPP\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      ListNode* p1 = headA;\n      ListNode* p2 = headB;\n\n      while (p1 != p2) {\n        if (p1 == NULL) p1 = headB;\n        else p1 = p1->next;\n\n        if (p2 == NULL) p2 = headA;\n        else p2 = p2->next;\n      }\n\n      return p1;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999576423","body":"```CPP\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n       auto fast = head;\n       auto slow = head;\n       \n       while (fast != NULL && fast->next != NULL) {\n         fast = fast->next->next;\n         slow = slow->next;\n\n        if (fast == slow) break;\n         \n       }\n\n       if (fast == NULL || fast->next == NULL) return NULL;\n\n       slow = head;\n\n       while (slow != fast) {\n         fast = fast->next;\n         slow = slow->next;\n       }\n\n       return slow;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000388450","body":"```CPP\r\nclass LRUCache {\r\npublic:\r\n    struct Node {\r\n      int key, val;\r\n      Node *left, *right;\r\n      Node(int _key, int _val): key(_key), val(_val), left(NULL), right(NULL) {}\r\n    }*L, *R;\r\n\r\n    unordered_map<int, Node*> hash;\r\n    int n;\r\n    \r\n    LRUCache(int capacity) {\r\n      n = capacity;\r\n      L = new Node(-1, -1), R = new Node(-1, -1);\r\n      L->right = R, R->left = L;\r\n    }\r\n\r\n    void remove(Node* p) {\r\n      p->right->left = p->left;\r\n      p->left->right = p->right;\r\n    }\r\n\r\n    void insert(Node* p) {\r\n      p->right = L->right;\r\n      p->left = L;\r\n      L->right->left = p;\r\n      L->right = p;\r\n    }\r\n    \r\n    int get(int key) {\r\n      if (!hash.count(key)) return -1;\r\n      auto p = hash[key];\r\n      remove(p);\r\n      insert(p);\r\n\r\n      return p->val;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n      if (hash.count(key)) {\r\n        auto p = hash[key];\r\n        p->val = value;\r\n        remove(p);\r\n        insert(p);\r\n      } else {\r\n        if (hash.size() == n) {\r\n          auto p = R->left;\r\n          remove(p);\r\n          hash.erase(p->key);\r\n          delete p;\r\n        }\r\n        auto p = new Node(key, value);\r\n        hash[key] = p;\r\n        insert(p);\r\n      }\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000876229","body":"```CPP\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n      if (!root) return 0;\r\n      return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzichengtech":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991835034","body":"## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 关键点\n\n-多次利用三元运算符来判断决定变量的值，进位算是难点  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n          int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length-1;\n        while (k>0 || i>=0){\n            int x = i <0 ?0:num[i];\n            int y = k%10;\n            k = k/10;\n            int sum = x+y+carry >=10 ? x+y+carry-10:x+y+carry;\n            result.add(sum);\n            carry = x+y+carry >= 10 ? 1:0;\n            i--;\n        }\n        if(carry == 1){\n            result.add(carry);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992418443","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 分析\n\n-  利用两个指针，双指针法，并且建立两个长度为s.length的数组空间，一个指针从左往右遍历，同时往一个数组中存值，如果遇到目标字母，则往向数组对应位置存入0，如果不是目标字母，就往数组中存入上一个数组的值再加1，另一个指针从右往左遍历同理，最后比较两个数组中相同下标的值，小的值留下并存入第一个数组中，得到最后要求的数组。需要注意的是两个指针遍历开始时第一个元素如果是目标字母则赋值为0，不是则赋值为1000。(因为遍历的时候如果没有出现目标字母，无法判断该字母到目标字母的距离，只能等相反方向遍历的指针来计算其到最近的目标字母的距离)，具体请见代码。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n         int len = s.length();\n        int[] left = new int[len];\n        int[] right = new int[len];\n        left[0] = s.charAt(0) == c ?0:1000;\n        for (int i = 1; i < s.length(); i++) {\n            left[i] = s.charAt(i) == c?0:left[i-1]+1;\n        }\n        right[len-1] = s.charAt(len-1) == c ?0:1000;\n        for (int i = len-2; i >=0; i--) {\n            right[i] = s.charAt(i) == c?0:right[i+1]+1;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            left[i] = Math.min(left[i],right[i]);\n        }\n        return left;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993207467","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 关键点\n\n-  index代表的是栈中元素的个数，\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\npackage com.wzc;\n\n    class CustomStack {\n        int[] stack;\n        int index;\n        public CustomStack(int maxSize) {\n             stack = new int[maxSize];\n             index = 0;\n        }\n\n        public void push(int x) {\n            if (index == stack.length){\n               return;\n            }\n            stack[index++] = x;\n        }\n\n        public int pop() {\n            if (index == 0){\n                return -1;\n            }\n            return stack[--index];\n        }\n\n        public void increment(int k, int val) {\n            k = Math.min(k,index);\n            for (int i = 0; i < k; i++) {\n                stack[i] = stack[i]+val;\n            }\n        }\n    }\n\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995865306","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n \n\n说明：\n\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n\n \n\n示例：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n```\n## 关键点\n\n-  利用两个栈进行操作，其中一个栈作为辅助栈（a），主要就是入栈操作需多写几行代码，入栈一个元素前先检测b栈中是否有元素，如果有元素则将b栈中的栈顶元素逐个压入a栈中，直到b栈为空为止，然后将新元素入栈a栈，没有元素则将新元素直接入栈a，最后将a栈全部元素出栈压入b栈中。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n\n    Stack<Integer> a;\n    Stack<Integer> b;\n    public MyQueue() {\n//        a相当于辅助栈\n         a = new Stack<Integer>();\n         b = new Stack<Integer>();\n    }\n\n    public void push(int x) {\n        while (!b.isEmpty()){\n            a.push(b.peek());\n            b.pop();\n        }\n        a.push(x);\n        while(!a.isEmpty()) {\n            b.push(a.peek());\n            a.pop();\n        }\n    }\n\n    public int pop() {\n        return b.pop();\n    }\n\n    public int peek() {\n        return b.peek();\n    }\n\n    public boolean empty() {\n        return b.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998634241","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 关键点\n\n-  该题可以利用HashSet空间结构，存储其中一个链表所有值，然后通过遍历另一个链表，如果遍历过程中发现在HashSet中有相同的值，则返回该节点，如果遍历中从头到尾都没有返回节点，最后返回null值，该方法虽能解决但是需要O（n）的空间复杂度，因此可以使用下面这个方法。\n- 我们可以考虑让两个链表的指针到交点的距离一致，然后同时遍历两个指针，这样当两个指针指向的节点的值相同时就找到了交点并且返回该节点，问题就是怎么让两个链表的指针到交点的距离一致，我们先让两个指针从各自的链表的头节点同时遍历，我们可以发现一个现象，当有一个指针先到达交点了，它和另一个指针的距离就是两个链表长度之差，因此我们可以做，当其中一个链表的指针先到达链尾处，下次移动时，该指针正常会指向null，但我们让它指向另一个链的头节点，另一个指针到达队尾同理，当另一个指针指向另一个链的头节点时，发现两个指针到交点的距离相同了，接着同时遍历，指向的节点相同时就找到交点了。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n     if (headA == null ||headB == null){\n           return null;\n       }\n       ListNode p1 = headA;\n       ListNode p2 = headB;\n       //如果两个链表没有节点，如果链表长度相同则headA，headB最终同时指向null,只有一个指针为空，问题不大\n       while (headA !=headB){\n           headA = headA == null ?  p2: headA.next;\n           headB = headB == null ?  p1: headB.next;\n       }\n       return headA;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n ，m为链表长度。\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999292368","body":"\n## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n\n## 关键点\n\n-  详细解析见[https://blog.csdn.net/Jiaodaqiaobiluo/article/details/120430551](https://blog.csdn.net/Jiaodaqiaobiluo/article/details/120430551)\n- 以及[https://blog.csdn.net/Jiaodaqiaobiluo/article/details/120412788](https://blog.csdn.net/Jiaodaqiaobiluo/article/details/120412788)\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npackage com.wzc;\n\npublic class solution05 {\n    public ListNode detectCycle(ListNode head) {\n        ListNode inLoop = getNodeLoop(head);\n        if (inLoop == null){\n            return null;\n        }\n        int loopCount = 1;\n//        统计环中节点个数\n        for (ListNode n = inLoop;n.next != inLoop;n = n.next){\n            loopCount++;\n        }\n//        利用剑指offer21题的方法，查找倒数第loopCount个节点\n        ListNode fast = head;\n        for (int i =0;i<loopCount;i++){\n            fast = fast.next;\n        }\n        ListNode slow = head;\n        while (fast != slow){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n\n    private ListNode getNodeLoop(ListNode head) {\n        if (head == null ||head.next == null){\n            return null;\n        }\n        ListNode fast = head.next;\n        ListNode slow = head;\n        while (slow !=null && fast !=null){\n            if (slow == fast){\n                return slow;\n            }\n            slow = slow.next;\n            fast = fast.next;\n            if (fast !=null){\n                fast = fast.next;\n            }\n        }\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000808478","body":"\n## 题目地址(104. 二叉树的最大深度)\n\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n## 题目描述\n\n```\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n```\n\n\n## 关键点\n\n-  记住两个要点，当遍历到的节点为空的时候返回0，当左右子树都遍历完成后，返回左右子树两者中的最大值再加1。\n- 从底部到顶部返回值得到最大深度，因此采用后序遍历比较好\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n   if (root == null){\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left,right)+1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991835437","body":"思路：\n先用reduce计算num对应数值，\n然后加上k后转成iterable的str对象\n再利用map从高位到低位依次转成整数，\n最后转成list\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int, str(k+reduce(lambda a, b: a*10+b, num))))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992498036","body":"* 暴力破解\n* 先找出字符c在字符串s中的下标\n* 然后计算s中每个字母到c下标的距离中的最短的那个\n```\n class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_idx = [ i for i in range(len(s)) if s[i] == c ]\n        return [ min(abs( i - j )  for j in c_idx) for i in range(len(s)) ]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993048405","body":"题解\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\n对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\n对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1。\n对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\n代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n分析\n时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\n空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994729165","body":"题解\n使用列表来模拟栈的特性\n依次遍历整个字符串\n1、如果该字符不是']',直接压栈\n2、对']'的处理：\n1）、首先不停的pop出[XXX]之间的字符串，直到遇到'['为止\n2）、接下来分析要重复多少次\n3）、字符串换数字后就是重复倍数，重复字符串\n4）、最后相加，压栈\n最后得到答案\n代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l_s = list(s)\n        stack = []\n        for word in l_s:\n            if word != ']':\n                stack.append(word)\n            else:\n                #字符列表\n                temp = []\n                while stack[-1] != '[' and stack:\n                    temp.append(stack.pop())\n                temp = temp[::-1]\n                #然后弹出'['\n                stack.pop()\n                #数字列表\n                nums = []\n                while len(stack) >= 1:\n                    if  stack[-1].isdigit():\n                        nums.append(stack.pop())\n                    else:\n                        break\n                nums = nums[::-1]\n                result = 0\n                for num in nums:\n                    result = result * 10 + int(num)\n                ll = temp * result\n                stack += ll\n        return ''.join(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994941954","body":"'''python\n'''\n操作两个栈，一个「输入栈」，一个「输出栈」。\n当 push() 新元素的时候，放到「输入栈」的栈顶。\n当 pop() 元素的时候，从「输出栈」弹出元素。如果「输出栈」为空，则把「输入栈」的元素逐个 pop() 并且 push() 到「输出栈」中，这一步会把「输入栈」的栈底元素放到了「输出栈」的栈顶。此时再从「输出栈」的 pop() 元素的顺序与「输入序」相同。\n\n'''\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996302142","body":"使用单调栈，每个元素代表每个块中的最大值\n\n复杂度分析\n\n时间复杂度：O(N)，其中 N 为数组长度。\n空间复杂度：O(N)\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            # 递增栈\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                cur_max = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(cur_max)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997128839","body":" 找尾节点，形成环形链表\n 尾节点移动 length - k 步，（右移k步 == 左移 length - k 步）\n 找到头节点，断开头尾连接\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        tail = head\n        length = 1\n        while tail.next:\n            length += 1\n            tail = tail.next\n        tail.next = head\n\n        k = k % length\n        for _ in range(length - k):\n            tail = tail.next\n\n        head = tail.next\n        tail.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997307817","body":"思路：\n 假设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换\n 当head 为空或者 next 为空，即当前无节点或者只有一个节点，不再进行交换\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997481105","body":"分析：\n特里处理：如果head为空返回空，如果head.next为空返回值为head.val的树节点\n用快慢指针找链表中间节点（slow每次走一步，fast每次走两步，循环停止时slow指向中间节点）\n找中间节点时记录一下slow的前一个节点pre，后面将链表分成前后两部分时有使用到\n创建树的根节点，把slow的值赋给它，并断开链表中间节点和左边子链表的连接\n递归链表中间节点左右两边的子链表，找子链表的中间节点，再找子链表的子链表的中间节点，如此循环往复，直到符合特例处理的条件递归返回\n复杂度：\n时间复杂度：O(nlogn)，每次递归找中点O(n)，递归次数O(logn)\n空间复杂度：O(logn)，平衡二叉树的高度O(logn)\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return None\n        elif not head.next:\n            return TreeNode(head.val)\n        \n        pre, slow, fast = None, head, head\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        pre.next = None\n\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998070992","body":"# 题解：\n 将两个无环链表串起来，同时遍历，要么走到相交的节点，要么走到最后空节点\n# 复杂度：\n O(M+N)\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999405131","body":"思路：快慢指针，如无环，快指针先走到队尾，如有环，必相遇，相遇时，快指针比慢指针多走的路为环的倍数,第一次相遇后再想办法去找环入口\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast  and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break;\n        if not fast or not fast.next: \n            return None\n        fast = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999956793","body":"```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到头部(变成最新访问的)，所以定义一个方法\n    def move_node_to_header(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到头部节点前\n            #                   hashmap[key]                     hashmap[key]\n            #                       |                                 |\n            #                       V        -->                      V\n            # header <-> next  ... node                   header <-> node <-> next\n            node.prev = self.head\n            node.next = self.head.next\n            self.head.next.prev = node\n            self.head.next = node\n            \n    def add_node_to_header(self, key,value):\n        new = ListNode(key, value)\n        self.hashmap[key] = new\n        new.prev = self.head\n        new.next = self.head.next\n        self.head.next.prev = new\n        self.head.next = new\n        \n    def pop_tail(self):\n        last_node = self.tail.prev\n        # 去掉链表尾部的节点在哈希表的对应项\n        self.hashmap.pop(last_node.key)\n        # 去掉最久没有被访问过的节点，即尾部Tail之前的一个节点\n        last_node.prev.next = self.tail\n        self.tail.prev = last_node.prev\n        return last_node\n    \n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到头部（变成最新访问的）\n            self.move_node_to_header(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到链表头部\n            self.move_node_to_header(key)\n        else:\n            if len(self.hashmap) >= self.capacity:\n            # 若cache容量已满，删除cache中最不常用的节点 \n                self.pop_tail()\n            self.add_node_to_header(key,value)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000569249","body":"```python\n#递归求解，递归条件是节点为空（返回高度0）\n#首先如果节点为空，返回高度为0；节点不空则继续递归\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000894788","body":"```python\n# 比较两个根节点：\n# 当两节点都为空，相同，返回True；\n# 当两节点只有一个为空，不同，返回False；\n# 当两节点值不相同，不同，返回False\n# 当两个节点值相同，则拿这两个节点的左子树相互比较、右子树相互比较，左右子树全部相同，最后结果才是相同\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else :\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001042541","body":"```python\n# 特例处理：root为空返回0\n# 递归包含两个参数，当前节点node和从根到当前节点为止的十进制数num\n# 当左节点存在，进入左节点的递归；当node的右节点存在，进入右节点的递归\n# 当当前节点是叶子节点，直接把num加到结果中\n# 返回结果\n\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        self.res = 0\n        if root is None:\n            return self.res\n        \n        self.dfs(root,root.val)\n        return self.res\n\n    def dfs(self,node,num):\n            if not node.left and not node.right:\n                self.res += num\n            if node.left:\n                self.dfs(node.left, num * 10 + node.left.val)\n            if node.right:\n                self.dfs(node.right, num * 10 + node.right.val)\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleswork":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991835905","body":"### 思路\n\n因为A.length最大为10000，所以不能采用类型转换来做，只能采用模拟的办法\n\n设置i作为进位，若对应位与i一起相加后大于10，说明有进位，就将i设置为1，结果对10取余；若小于10则直接进行下一高位的计算。\n\n我设置的条件时num和k同时大于0，若跳出说明至少有一个参数已经到了最高位了，那么未到最高位的参数就以基本相同的思路继续计算。\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       int key = num.size()-1;\n       int i = 0;\n       while(key>=0 && k){\n           num[key] = i + num[key] + k%10;\n           i = 0;\n           if(num[key] >= 10){\n               i = 1;\n               num[key] %= 10;\n           }\n           k /= 10;\n           key--;\n       }\n       //当k比num长时\n           while(k){\n               int sum = k%10+i;\n               num.insert(num.begin(),sum%10);\n               i = sum/10;\n               k /= 10;\n           }\n       \n       //当num比k长时\n           while(key>=0){\n                num[key] = i + num[key] + k%10;\n                i = 0;\n                if(num[key] >= 10){\n                    i = 1;\n                    num[key] %= 10;\n           }\n               key--;\n           }\n       \n       if(i) num.insert(num.begin(),1);\n       return num;\n       //如果num的长度大于k，那到这里就结束了\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(max(numlen,klen))  (numlen为num的长度，klen为k的长度)；\n\n空间复杂度：O(max(numlen,klen))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992043684","body":"### 思路\n\n遍历每一个字符，对当前字符设左右双指针，返回较近c和当前字符距离。\n有一点需要注意，可能左指针或右指针在向左向右遍历时，会遍历到字符头和尾，此时就需要处理距离异常的问题。通过下面这行代码就能确保得到最短且正确（某一指针遍历到边界但另一指针仍在找c这一情况）的距离：\n\n```cpp\nres.push_back(max(abs(i-left),abs(i-right)));\n```\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> res;\n        for(int i = 0;i<len;i++){\n            int left = i;\n            int right = i;\n            while(s[left]!=c && s[right]!=c){\n                if(left>0) left--;\n                if(right<len) right++;\n            }\n            res.push_back(max(abs(i-left),abs(i-right)));\n        }\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n^2)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993098877","body":"### 思路\n\n用数组模拟栈\n\n栈有两种，一种是top指向栈顶元素，另一种是top指向栈顶元素上一空间。我模拟的是第一种。\n\n### 代码\n\n```cpp\nclass CustomStack {\npublic:\n    //用数组模拟栈，便于实现inc\n    //移动top指针从而实现\n    vector<int> Stack;  //栈\n    int top;            //栈顶指针\n\n    CustomStack(int maxSize) {\n        Stack.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top!=Stack.size()-1){\n            ++top;\n            Stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1) return -1;\n        --top;\n        return Stack[top+1];\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0;i<k && i<Stack.size();i++){\n            Stack[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n**复杂度分析**\n\npush：O(1)\n\npop：O(1)\n\nincrement：O(n)\n\n### 有个问题\n\n```cpp\nvoid push(int x) {\n        if(top!=Stack.size()-1){\n            ++top;\n            Stack[top] = x;\n        }\n    }\n//if里面的语句用!=就是对的\n//if里面的语句用<就错了\n//我不理解\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994698864","body":"### 思路\n\n主要就是栈，一个数字栈num，存储数字；一个字符栈str，存储**[**、**]**、以及**字母**这些字符\n\n具体push、pop怎么操作我就不讲了，讲讲我做的时候碰到的问题，后者说是一些细节。\n\n1、在**num[str]** 系统外的字符，我们不能将他入str栈（至少按照我的代码的思路不行），那就需要额外判断，那么什么情况下可以判断当前进入循环的字符是系统外的呢？当str栈为空时，说明当前进入循环的字符是系统外字符。怎么理解？若当前进入循环的字符是系统内的字符，那么str栈里至少有一个 **“[”** 。\n\n弄明白判断条件，就可以直接在遍历循环开头进行判断，若为系统外字符，直接加入res字符串即可。\n\n2、会出现[]套[]的情况，那就需要在pop到 **[**的时候进行判断，判断str栈是否为空（判断num栈也行），**如果非空**，说明存在**[]**套**[]**的情况，就需要把当前括号内的temp重新pop回去，这时候又有两种情况（看3）；**若为空**，说明不存在**[]**套**[]**的情况，直接存入res即可。\n\n3、把当前括号内的temp重新pop回去，这时候又有两种情况：\n\n其一是str栈top是**正常的字符** ，也就是像**2[3a[a]]**这种情况，那么只需要把top取出来和temp进行连接，把top pop出来后，再把连接后的字符串push回去即可；\n\n其二是str栈top是 **[**，也就是像2[3[a]]这种情况，这时候我们要是按照第一种情况那样操作，那肯定是不行，把**[** 给连接到temp里去了。这时候我们直接push回去即可。\n\n\n\n还有就是因为存在**[]**套**[]**的情况，stack需要string类型，不能用char。\n\n\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    //判断一个字符串是否全部为数字(主要就是判断一个而已)\n    bool isNumber(string str){\n        for(char s:str){\n            if(!isdigit(s)) return false;\n        }\n        return true;\n    }\n    string decodeString(string s) {\n        stack<int> num;\n\t    stack<string> str;\n\t    string res;\n\t    int i = 0;\n\t    while (i < s.length()) {\n\t\t    string istr;         //转化为字符串进行处理\n\t\t    istr.push_back(s[i]);\n\t\t    if (str.empty() && !isNumber(istr) && istr != \"[\") {      //处理外面的字符\n\t\t\t    res += istr;\n\t\t\t    i++;\n\t\t\t    continue;\n\t\t    }\n\t\t    if (s[i] > '0'&&s[i] <= '9') {      //数字压入数字栈\n\t\t\t    int temp = s[i] - 48;\n\t\t\t    while (s[i + 1] >= '0'&&s[i + 1] <= '9') {\n\t\t\t\t    temp = temp * 10 + s[++i] - 48;\n\t\t\t    }\n\t\t\t    i++;\n\t\t\t    num.push(temp);\n\t\t\t    continue;\n\t\t    }\n\t\t    if (istr == \"[\" || isalpha(s[i])) {    // [ 或字母压入str栈\n\t\t\t    str.push(istr);\n\t\t\t    i++;\n\t\t\t    continue;\n\t\t    }\n\t\t    if (istr == \"]\") {\n\t\t\t    int weight = num.top();\n\t\t\t    num.pop();\n\t\t\t    string temp = \"\";\n\t\t\t    while (str.top() != \"[\") {\n\t\t\t\t    temp = str.top() + temp;\n\t\t\t\t    str.pop();\n\t\t\t    }\n\t\t\t    str.pop();          //把 [ pop出去\n\t\t\t    string temp1;\n\t\t\t    while (weight--) {\n\t\t\t\t    temp1 += temp;                   //不直接存进res是因为有[]套[]的情况\n\t\t\t    }\n\t\t\t    if (!str.empty()) {                  //如果str栈非空，说明存在[]套[]的情况，要把temp重新存进栈\n                    if(str.top() != \"[\"){            //会不会有3[2[a]]的情况，如果有就要改，提交一下试试\n\t\t\t\t        temp1 = str.top() + temp1;\n\t\t\t\t        str.pop();\n\t\t\t\t        str.push(temp1);          \n                    }\n                    else str.push(temp1);\n\t\t\t    }\n\t\t\t    else res += temp1;\n\t\t\t    i++;\n\t\t    }\n\t    }\n\t    return res;\n    }\n};\n```\n\n\n\n**复杂度分析**\n\n时间复杂度：稍稍大于O(n)\n\n空间复杂度：O(n)，两个stack\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995407914","body":"### 思路\n\n两个栈实现列表，不考虑任何进阶的思想，就是两个栈之间互相倒（dao，第三声）。\n\n### 代码\n\n```c++\nclass MyQueue {\npublic:\n    stack<int> queue1;  //主栈\n    stack<int> queue2;  //辅栈\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        queue1.push(x);\n    }\n    \n    int pop() {\n        while(!queue1.empty()){\n            queue2.push(queue1.top());\n            queue1.pop();\n        }\n        int temp = queue2.top();\n        queue2.pop();\n        while(!queue2.empty()){\n            queue1.push(queue2.top());\n            queue2.pop();\n        }\n        return temp;\n    }\n    \n    int peek() {\n        while(!queue1.empty()){     \n            queue2.push(queue1.top());\n            queue1.pop();\n        }\n        int temp = queue2.top();\n        while(!queue2.empty()){\n            queue1.push(queue2.top());\n            queue2.pop();\n        }\n        return temp;\n    }\n    \n    bool empty() {\n        if(queue1.empty() && queue2.empty()) return true;\n        return false;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n**复杂度分析**\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996711447","body":"### 思路 \n\n单调栈\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i =0;i<arr.size();i++){\n            if(!stack.empty()&&stack.top()>arr[i]){\n                int cur = stack.top();\n                while(!stack.empty()&&stack.top()>arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }else{\n                stack.push(arr[i]);\n            }\n        }\n        return stack.size();\n    }\n};\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997133116","body":"### 思路\n\n找三个节点，头节点、尾节点、倒数第二个节点。每一次remote做如下操作：\n\n1、尾节点指向头节点\n\n2、倒数第二个节点更新为尾节点\n\n3、尾节点更新为头节点\n\n重复k次即可\n\n但 k有可能很大，就要对链表长度取余，因为每循环链表长度次remote会和原链表相同。\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || head->next == nullptr) return head;\n        int count = 1;\n        ListNode* temp = head;\n        while(temp->next != nullptr){\n             count++;\n             temp = temp->next;\n        }\n        k = k%count;\n        while(k--){\n            ListNode* cur = head;\n            //找到倒数第二个节点\n            while(cur->next->next != nullptr){\n                cur = cur->next;\n            }\n            ListNode* tail = cur->next;   //尾节点\n            tail->next = head;            //尾节点指向头节点\n            cur->next = nullptr;          //倒数第二个节点成为尾节点\n            head = tail;                  //更新头节点\n        }\n        return head;\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n) n为链表长度\n\n空间复杂度：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997319366","body":"### 思路\n\n我想试试递归，迭代还是很好理解的。\n\n就是最简单的思路，奇偶相邻两个节点进行swap，这不是最重要的。重要的是替换后对应节点之间的连接需要更新。\n\n比如[1,2,3,4]，如果仅仅只是swap，那么在[3,4]两个节点swap之后，3就会被孤立出来，单独指向4，没有前序节点。那么解决方法就是在[1,2]两个节点swap结束之后，事先让节点“1”(这里的1指的是值为1的节点)指向节点“4”，这样就能解决链路断连的情况。\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    void swap(ListNode* node1,ListNode* node2){\n         ListNode* temp = node2->next;\n         node2->next = node1;\n         node1->next = temp;\n    }\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || head->next == nullptr) return head;\n        ListNode* headreal = head->next;   //记录最后需要返回的首节点\n        ListNode* node1 = head;\n        ListNode* node2 = head->next;\n        while(true){\n            swap(node1,node2);\n            ListNode* temp = node1;\n            node1 = node1->next;\n            if(!node1) break; \n            node2 = node1->next;\n            if(!node2) break;\n            temp->next = node2;\n        }\n        return headreal;\n\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997534308","body":"### 思路\n\n递归构建搜索树\n\n二分实现平衡（注意边界控制）\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution { \npublic:\n    TreeNode* DFS(ListNode* head,ListNode* tail){\n        if(head == tail) return nullptr;\n\n        //找中间节点\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast != tail && fast->next != tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        //找到中间节点，作为根节点，递归构造左右子树\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = DFS(head,slow);        //二分注意边界\n        root->right = DFS(slow->next,tail);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(!head) return nullptr;\n        return DFS(head,nullptr);\n\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(logn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998405674","body":"# 第十天（天气🌤）\n\n### 思路一\n\n将两链表起始遍历位置设为同一相对位置，这样往下遍历就一定能同时到达相交的节点，返回即可。\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int getLength(ListNode *head){\n        int length = 0;\n        while(head){\n            length++;\n            head=head->next;\n        }\n        return length;\n    }\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        int lengthA = getLength(headA);\n        int lengthB = getLength(headB);\n        int distract = abs(lengthA-lengthB);\n        if(lengthA>lengthB){\n            while(distract--){\n                headA = headA->next;\n            }\n        }\n        else{\n            while(distract--){\n                headB = headB->next;\n            }\n        }\n        while(headA && headA!=headB){\n            headA = headA->next;\n            headB = headB->next;\n        }\n        return headA;\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(max(lenA,lenB))   计算链表长度产生的复杂度\n\n空间复杂度：O(1)\n\n\n\n\n\n### 思路二\n\n设置双指针，分别首先各自遍历两链表，当其中任一指针遍历到链表尾，转而遍历另一链表，在遍历一个周期之后，两指针的相对位置会相同，在第二次遍历即可找到相交节点。\n\n乍一看比较难理解，画一下就知道了，两个圈加起来的长度是相等的。\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* key1 = headA;\n        ListNode* key2 = headB;\n        while(key1 != key2){\n            key1 = key1 == NULL ? headB : key1->next;\n            key2 = key2 == NULL ? headA : key2->next;\n        }\n        return key1;\n    }\n};\n```\n\n\n\n**复杂度分析**\n\n时间复杂度：O(n+m)  两链表相加之后长度相同，所以才会同时到达第一个相交节点\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999241688","body":"## 思路一\n\n哈希表，遍历一个节点就加入哈希表，如果再次遍历到这个节点说明有，返回即可。\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_map<ListNode*,int> hash;\n        ListNode* cur = head;\n        while(cur && hash[cur] == 0){\n            hash[cur]++;\n            cur = cur->next;\n        }\n        if(hash[cur] == 1) return cur;\n        return NULL;\n\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n) \n\n空间复杂度：O(n)\n\n\n\n## 思路二\n\n快慢指针，若有相等表明有环。但仅仅是有环，还需要再加一个指针去碰环头。这个就有一个证明的过程了，具体可以看leetcode官解\n\n### 代码\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head || !head->next) return NULL;\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast && fast->next){\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow) break;\n        }\n        if(slow != fast) return NULL; //说明未成环\n        ListNode* cur = head;\n        while(cur != slow){\n            cur = cur->next;\n            slow = slow->next;\n        }\n        return cur;\n\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000000231","body":"### 思路\n\nlucifer的思路确实比较完善，算是对链表这一数据结构又复习了一遍，不戳。\n\n### 代码\n\n```cpp\nclass DulNode{\n    public:\n        int key;\n        int value;\n        DulNode* prior;\n        DulNode* next;\n        DulNode() :key(0),value(0),prior(NULL),next(NULL) {};                      //默认构造函数\n        DulNode(int k,int val) :key(k),value(val),prior(NULL),next(NULL) {};       //有参构造函数\n    };\n\nclass LRUCache {\npublic:\n    \n    LRUCache(int capacity) :capamax(capacity) {\n        //构造两个假节点作为头尾节点，这样就不需要将真头尾节点特殊考虑\n         dummy_head = new DulNode();\n         dummy_tail = new DulNode();\n         dummy_head->next = dummy_tail;\n         dummy_tail->prior = dummy_head;\n    }\n    \n    int get(int key) {\n        if(!is_exist(key)) return -1;\n        DulNode* node = hash[key];  //通过hash找到该节点\n        move_to_head(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if(is_exist(key)){\n            DulNode* node = hash[key];  //找节点\n            node->value = value;        //改值\n            move_to_head(node);         //挪节点\n        }\n        else{\n            if(is_full()){\n                hash.erase(dummy_tail->prior->key);   //在hash里删除\n                del_node(dummy_tail->prior);          //删除节点\n            }\n            DulNode* node = new DulNode(key,value);\n            add_to_head(node);                        //添加节点\n            hash.emplace(key,node);\n        }\n        \n    }\nprivate:\n    //设置一个哈希表来记录缓存内节点以各种操作\n    unordered_map<int,DulNode*> hash;\n    DulNode* dummy_head;\n    DulNode* dummy_tail;\n    int capamax;\n\n    void add_to_head(DulNode* node){\n        DulNode* temp = dummy_head->next;\n        dummy_head->next = node;\n        node->next = temp;\n        node->prior = dummy_head;\n        temp->prior = node;\n    }\n\n    void del_node(DulNode* node){\n        node->prior->next = node->next;\n        node->next->prior = node->prior;\n    }\n\n    void move_to_head(DulNode* node){\n        del_node(node);\n        add_to_head(node);\n    }\n\n    bool is_full(){\n        if(hash.size() == capamax) return true;\n        return false;\n    }\n\n    bool is_exist(int key){\n        if(hash.find(key) != hash.end()) return true;\n        return false;\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n**时间复杂度**\n\n时间复杂度：O(1) 因为有哈希和双向链表，所以时间复杂度都是O(1)\n\n空间复杂度：O(n) 主要就是双向链表和哈希表，双向链表多两个节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000841791","body":"### 思路\n\nDFS遍历树，每往下遍历一次就加一，回溯的时候去左右子树深度的较大值。\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right))+1;\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n)\n\n空间复杂度：O(h)  树深度大小的递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001010745","body":"### 思路\n\nDFS+对某一节点需要进行的操作。那么主要就是弄清对某一节点需要进行哪些判断。怎么样的树可以称为是相同的树？\n\n**相同的树**：结构相同，对应位置相同节点的值也相同。\n\n根据以上定义，就可以分析对当前遍历到的两个节点需要进行的操作了。\n\n1、两节点是否为空，若同时为空，则必定为相同的树（因为压根没有）；\n\n2、若两节点不同时为空，且也不同时非空，则必不为相同的树（一个有一个没有）；\n\n3、若两节点都非空，但值不同，仍然不是相同的树；\n\n4、若均不满足上述情况，说明到当前两节点为止的树为相同的树，继续往左右DFS；\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p&&!q){\n            return true; //两棵树均为空则必相同\n        }\n        else if(!p||!q){\n            return false; //有一棵树为空\n        }\n        else if(p->val!=q->val){\n            return false;  //根节点不相等\n        }\n        else{\n            //深度优先遍历\n            return isSameTree(p->left, q->left)&&isSameTree(p->right, q->right);\n        }\n\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n)\n\n空间复杂度：O(h) h为两树相同部分的深度 ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devil-lin":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991836687","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n\n        int n = num.size();\n        for(int i = n - 1; i >= 0 || k; i --)\n        {\n            if(i >= 0)\n                k += num[i];\n            res.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992604905","body":"```\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992689479","body":"链表或者数组都可以\n没啥好说的，两三分钟就完了\n\n```\nclass CustomStack {\npublic:\n    vector <int> v;\n    int top, maxsize;\n\n    CustomStack(int maxSize) {\n        v.resize(maxSize);\n        maxsize = maxSize;\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top == maxsize - 1) return;\n        v[++ top] = x;\n    }\n    \n    int pop() {\n        if(top == -1) return -1;\n        top --;\n        return v[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for(int i = 0; i < lim; i ++) v[i] += val;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994256805","body":"栈就完了\n```\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                stk.pop_back();\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                while (repTime--) t += o; \n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996399468","body":"并查集\n```\nclass Solution {\npublic:\n    int end=0;\n    bool check(vector<int>&temp,vector<int>&store){\n        sort(store.begin(),store.end());\n        for(int i=store.size()-1;i>=0;i--){\n            if(store[i]!=temp[i]){\n                return false;\n            }\n        }\n        end=store.size()>=temp.size()?-1:temp[store.size()];\n        return true;\n    }\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int>temp=arr;\n        vector<int>store;\n        int res=0;\n        bool flag1=false;\n        end=temp[0];\n        sort(temp.begin(),temp.end());\n        for(int i=0;i<arr.size();i++){\n            if(i+1==arr.size()){\n                res++;\n                break;\n            }\n            store.push_back(arr[i]);\n            if(arr[i]==end){\n                flag1=true;\n            }\n            if(flag1&&check(temp,store)){\n                flag1=false;\n                res++;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997153513","body":"参考前面C++大佬的思路，复刻了\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next) return head;\n\n        ListNode* p = head;\n        int n = 1;\n        while (p->next) {\n            p = p->next;\n            ++n;\n        }\n\n        int step = n - k % n;\n        // p points to the last node\n        p->next = head;\n\n        while(step--) {\n            head = head->next;\n            p = p->next;\n        }\n\n        p->next = nullptr;\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997383506","body":"```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997968274","body":"之前的AC代码？？？\n直接搬了（\n```\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999494960","body":"经典快慢链表\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr) {\n            slow = slow->next;\n            if (fast->next == nullptr) {\n                return nullptr;\n            }\n            fast = fast->next->next;\n            if (fast == slow) {\n                ListNode *ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr->next;\n                    slow = slow->next;\n                }\n                return ptr;\n            }\n        }\n        return nullptr;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000823336","body":"极其经典的递归题目\n\n```\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001021786","body":"可恶，整半天还真就那个nullptr判岔劈了\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) \n        {\n            return true;\n        } \n        else if (p == nullptr || q == nullptr) \n        {\n            return false;\n        } \n        else if (p->val != q->val) \n        {\n            return false;\n        } \n        else \n        {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"spacker-343":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991838535","body":"### 思路\r\n\r\n首先得想法是把两个数加起来，再依次取出个位，添加进结果中，但是这样会溢出。\r\n于是选择从后往前遍历数组，末尾数字相加后添加进结果集中，同时判断一下有没有进位。\r\n最后还要看看 k 和进位等于 0 没有，如果没有还要继续添加进结果集中。\r\n添加数字时，要保证顺序，所以每次插入在数组开头，也就是 0 的索引位置，使用 LinkedList 而不是 ArrayList 会提升插入的性能\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new LinkedList<>();\r\n        int carry=0;\r\n        for(int i=num.length-1; i>=0; i--){\r\n            int sum=0;\r\n            sum=num[i]+k%10+carry;\r\n            k/=10;\r\n            carry=sum/10 > 0 ? 1:0;\r\n            sum%=10;\r\n            res.add(0, sum);\r\n        }\r\n        while(k!=0){\r\n            int sum=k%10+carry;\r\n            carry=sum/10 > 0 ? 1:0;\r\n            sum%=10;\r\n            k/=10;\r\n            res.add(0, sum);\r\n        }\r\n        if(carry!=0){\r\n            res.add(0, 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992038217","body":"### 思路\r\n第一眼感觉用双指针能做，找到第一个 c 字符出现位置和第二个 c 字符出现位置，然后分别求出到当前 i 的距离，再进行比较，如果没出现第二个 c 字符（也就是 right2 == s.length() ），那么就直接取第一个 c 字符到当前 i 的距离就好。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res=new int[s.length()];\r\n        int right=0;\r\n        int right2=1;\r\n        while(right<s.length() && s.charAt(right)!=c){\r\n            right++;\r\n        }\r\n        while(right2<s.length()&&s.charAt(right2)!=c){\r\n            right2++;\r\n        }\r\n        for(int i=0; i<res.length; i++){\r\n            // 如果索引i大于第二个c字符所在位置则更新right和right2\r\n            if(i>right2){\r\n                if(right2!=s.length()){\r\n                    right=right2;\r\n                    right2=right+1;\r\n                    while(right2<s.length()&&s.charAt(right2)!=c){\r\n                        right2++;\r\n                    }\r\n                }\r\n            }\r\n            if(right2==s.length()){\r\n                // 说明此时只有right指针在c字符上\r\n                res[i]=Math.abs(right-i);\r\n            }else{\r\n                res[i]=Math.min(Math.abs(right-i), right2-i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993121333","body":"### 思路\r\n由于栈容量大小固定，因此考虑使用数组来模拟，并用一个index指针指向栈顶元素\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] customStack;\r\n    int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        customStack=new int[maxSize];\r\n        index=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index==customStack.length-1){\r\n            return;\r\n        }\r\n        customStack[++index]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(index==-1){\r\n            return -1;\r\n        }\r\n        int res=customStack[index];\r\n        customStack[index--]=0;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int inc=Math.min(index+1, k);\r\n        for(int i=0; i<inc; i++){\r\n            customStack[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间复杂度: O(1) push pop O(min(index+1, k)) increment\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994219771","body":"### 思路\r\n使用一个栈存储除了 ']' 的字符，遇到 ']' 就开始往结果中添加字符，可能遇到 aabbc 这种没带 ']' 的情况，所以最后还得判断一下栈是否为空。\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res=new StringBuilder();\r\n        Stack<Character> stack=new Stack<>(); \r\n        for(int i=0; i<s.length();  i++){\r\n            char c=s.charAt(i);\r\n            if(c==']'){\r\n                // 转字符\r\n                StringBuilder temp=new StringBuilder();\r\n                char ch=stack.pop();\r\n                while(ch>='a' && ch<='z'){\r\n                    temp.append(ch);\r\n                    ch=stack.pop();\r\n                }\r\n                temp.reverse();\r\n                // 转数字\r\n                StringBuilder sb=new StringBuilder();\r\n                if(!stack.isEmpty()){\r\n                    char cnum=stack.pop();\r\n                    while(cnum>='0' && cnum<='9'){\r\n                        sb.append(cnum);\r\n                        if(stack.isEmpty()){\r\n                            break;\r\n                        }\r\n                        cnum=stack.pop();\r\n                        if(cnum>='a' && cnum<='z'||cnum=='['){\r\n                            stack.push(cnum);\r\n                        }\r\n                    }\r\n                }\r\n                sb.reverse();\r\n\r\n                int num=Integer.valueOf(sb.toString());\r\n                for(int j=0; j<num; j++){\r\n                    if(!stack.isEmpty()){\r\n                        for(char m:temp.toString().toCharArray()){\r\n                            stack.push(m);\r\n                        }\r\n                    }else {\r\n                        // 避免重复入栈\r\n                        res.append(temp);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            stack.push(c);\r\n        }\r\n        // 检查栈是否为空\r\n        if(!stack.isEmpty()){\r\n            StringBuilder temp=new StringBuilder();\r\n            char ch=stack.pop();\r\n            while(ch>='a' && ch<='z'){\r\n                temp.append(ch);\r\n                if(stack.isEmpty()){\r\n                    break;\r\n                }\r\n                ch=stack.pop();\r\n            }\r\n            temp.reverse();\r\n            res.append(temp);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(n) 每个字符会出栈，入栈一次\r\n空间复杂度：O(n) 所有字符入栈的情况","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995395407","body":"### 思路\n用两个栈，peek和pop操作，若out栈不为空，则直接从out栈中取\n\n### 代码\n```java\nclass MyQueue {\n\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn=new LinkedList<>();\n        stackOut=new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {\n        // 如果出栈为空，则把入栈的所有元素放入到出栈中\n        if(stackOut.isEmpty()){\n            while(!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n        }\n        // 否则直接返回出栈栈顶元素\n        return stackOut.pop();\n    }\n    \n    public int peek() {\n        if(stackOut.isEmpty()){\n            while(!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n        }\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        return stackIn.isEmpty()&&stackOut.isEmpty();\n    }\n}\n```\n### 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996439821","body":"### 思路\r\n和一个已经排序好的数组，同时计数并存进map中，如果两个map键值对一样，说明可以进行分组排序，此时res+1\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sortarr=Arrays.copyOf(arr, arr.length);\r\n        Arrays.sort(sortarr);\r\n        Map<Integer, Integer> countA=new HashMap<>();\r\n        Map<Integer, Integer> countB=new HashMap<>();\r\n        int res=0;\r\n        for(int i=0; i<arr.length; i++){\r\n            countA.put(arr[i], countA.getOrDefault(arr[i], 0)+1);\r\n            countB.put(sortarr[i], countB.getOrDefault(sortarr[i], 0)+1);\r\n            if(countA.equals(countB)){\r\n                res++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n^2)，排序为O（nlogn）,for遍历一遍数组是O（n），map每个键值对进行比较也是O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997150936","body":"### 思路\n链表尾部接上头结点，第count-k节点的下一个节点为最新头结点，新的尾结点的next指针赋值为null\n### 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return null;\n        }\n        int count=1;\n        // 找到尾结点同时统计链表长度\n        ListNode tail=head;\n        while(tail.next!=null){\n            count++;\n            tail=tail.next;\n        }\n        // 防止循环走太多次，减少循环次数\n        k %= count;\n        if(k==0){\n            // 取模后等于0说明不进行翻转\n            // 向右移动数组长度个单位，就相当于没有移动\n            return head;\n        }\n        // 将尾结点接上头结点\n        tail.next=head;\n        ListNode p=head;\n        for(int i=1; i<count-k; i++){\n            p=p.next;\n        }\n        // 从1开始，第count-k个节点的下一个节点为头结点\n        head=p.next;\n        // 第count-k个节点为新的尾结点\n        p.next=null;\n        return head;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997312882","body":"### 思路\n找到起始节点，和终止节点就行了\n### 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode b=head;\n        // i<k就是k个一组翻转链表啦\n        for(int i=0; i<2; i++){\n            if(b==null){\n                return head;\n            }\n            b=b.next;\n        }\n        // 翻转后返回的就是头结点\n        ListNode res=reverse(head, b);\n        // head变为尾结点了\n        head.next=swapPairs(b);\n        return res;\n    }\n\n    // 翻转[a, b)区间\n    private ListNode reverse(ListNode a, ListNode b){\n        if(a==b){\n            return a;\n        }\n        if(a.next==b){\n            return a;\n        }\n        ListNode head=reverse(a.next, b);\n        a.next.next=a;\n        a.next=null;\n        return head;\n    } \n}\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997760864","body":"### 思路\r\n快慢指针找中点，中点为根节点，记录中点前一个节点来断开左子树与中点的连接，中点下一个节点为右子树最小节点\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head==null){\r\n            return null;\r\n        }\r\n        ListNode slow, fast, pre;\r\n        pre=null;\r\n        slow=fast=head;\r\n        while(fast.next!=null&&fast.next.next!=null){\r\n            fast=fast.next.next;\r\n            pre=slow;\r\n            slow=slow.next;\r\n        }\r\n        if(pre!=null){\r\n            pre.next=null;\r\n        }\r\n        TreeNode root=new TreeNode(slow.val);\r\n        if(pre!=null){\r\n            pre.next=null;\r\n            root.left=sortedListToBST(head);\r\n        }else{\r\n            root.left=null;\r\n        }\r\n        root.right=sortedListToBST(slow.next);\r\n        return root;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(nlgn)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998730805","body":"### 思路\n最小公倍数\n### 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode l1=headA;\n        ListNode l2=headB;\n        while(l1!=l2){\n            l1=l1!=null?l1.next:headB;\n            l2=l2!=null?l2.next:headA;\n        }\n        return l1;\n    }\n}\n```\n### 复杂度\n时间复杂度：O（n）\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999299105","body":"### 思路\n双指针。\n### 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null){\n            return null;\n        }\n        ListNode slow, fast;\n        slow=fast=head;\n        while(fast.next!=null&&fast.next.next!=null){\n            fast=fast.next.next;\n            slow=slow.next;\n            if(fast==slow){\n                break;\n            }\n        }\n        // 判断一下是因为哪种情况退出循环的\n        if(fast.next==null||fast.next.next==null){\n            return null;\n        }\n        ListNode p=head;\n        while(p!=slow){\n            p=p.next;\n            slow=slow.next;\n        }\n        return p;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000068134","body":"### 思路\n使用双向链表、虚拟头结点来方便删除和增加元素，使用hashmap，key到链表节点的映射来快速获取节点，双向链表节点设置属性key可以方便的在删除尾结点后移除map中它的键值对映射\n### 代码\n```java\nclass LRUCache {\n\n    class DoubleLinkedListNode{\n        // 这个key是用来移除map中的键值对\n        int key, val;\n        DoubleLinkedListNode prev, next;\n        public DoubleLinkedListNode() {}\n        public DoubleLinkedListNode(int key, int val) {\n            this.key=key;\n            this.val=val;\n        }\n    }\n\n    // 统一增加和删除节点的操作逻辑\n    DoubleLinkedListNode dummyHead, dummyTail;\n    // 最大容量和当前容量\n    int cap, size;\n    // 值到链表节点的映射\n    Map<Integer, DoubleLinkedListNode> cache;\n\n    public LRUCache(int capacity) {\n        size=0;\n        cap=capacity;\n        cache=new HashMap<>();\n        dummyHead=new DoubleLinkedListNode();\n        dummyTail=new DoubleLinkedListNode();\n        dummyHead.next=dummyTail;\n        dummyTail.prev=dummyHead;\n    }\n\n    private DoubleLinkedListNode removeNode(DoubleLinkedListNode node){\n       // 设置两个被牵连的节点\n        node.next.prev=node.prev;\n        node.prev.next=node.next;\n        // 再设置当前节点\n        // 其实这个置空也没用，因为没有到他的gcroot它就会被回收\n        // 而addToHead中是直接被覆盖了\n        node.prev=null;\n        node.next=null;\n        return node;\n    }\n\n    private void addToHead(DoubleLinkedListNode node){\n        DoubleLinkedListNode head=dummyHead.next;\n        // 设置当前节点\n        node.next=head;\n        node.prev=dummyHead;\n        // 设置两个被牵连的节点\n        head.prev=node;\n        dummyHead.next=node;\n    }\n    \n    public int get(int key) {\n        if(cache.containsKey(key)){\n            DoubleLinkedListNode node=cache.get(key);\n            // 需要把该节点提到链表首部因为已经使用了\n            // 而且还要把节点之前所在位置断开连接\n            addToHead(removeNode(node));\n            return node.val;\n        }else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if(cache.containsKey(key)){\n            // 存在就更新值\n            DoubleLinkedListNode node=cache.get(key);\n            node.val=value;\n            addToHead(removeNode(node));\n        }else {\n            // 不存在就添加值\n            if(size==cap){\n                // 如果已经满了，移除尾结点\n                DoubleLinkedListNode tail=dummyTail.prev;\n                removeNode(tail);\n                cache.remove(tail.key);\n                size--;\n            }\n            DoubleLinkedListNode node=new DoubleLinkedListNode(key, value);\n            // 头插法\n            addToHead(node);\n            cache.put(key, node);\n            size++;\n        }\n    }\n}\n```\n### 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000863860","body":"### 思路\n递归\n### 代码\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        if(root.left==null&&root.right==null){\n            return 1;\n        } \n        int left=maxDepth(root.left);\n        int right=maxDepth(root.right);\n        int childMaxDepth=Math.max(left,right);\n        return childMaxDepth+1;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000892045","body":"### 思路\n分为无孩子，有一个孩子，有两个孩子三种情况来设置递归终止条件。\n### 代码\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null){\n            return true;\n        }\n        if(p==null||q==null){\n            return false;\n        }\n        if(p.val!=q.val){\n            return false;\n        }\n        // 为false了就不用往下递归了\n        if(!isSameTree(p.left, q.left)){\n            return false;\n        }\n        if(!isSameTree(p.right, q.right)){\n            return false;\n        }\n        return true;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"de0002ou":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991842436","body":"### 思路\n\n把数字转换成数组，对应位相加传入新数组，考虑进位情况\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        list_k = []\n        while k > 0:\n            temp = k%10\n            list_k.insert(0,temp)\n            k-=temp\n            k/=10\n        res = []\n        add_up = 0\n        while list_k and num:\n            i = list_k.pop()+num.pop()\n            if i+add_up< 10:\n                res.insert(0,int(i+add_up))\n                add_up = 0\n            else:\n                res.insert(0,int(i-10+add_up))\n                add_up = 1\n        while list_k and not num:\n            i = list_k.pop()\n            if i+add_up< 10:\n                res.insert(0,int(i+add_up))\n                add_up = 0\n            else:\n                res.insert(0,int(i-10+add_up))\n                add_up = 1\n        while num and not list_k:\n            i = num.pop()\n            if i+add_up< 10:\n                res.insert(0,int(i+add_up))\n                add_up = 0\n            else:\n                res.insert(0,int(i-10+add_up))\n                add_up = 1\n        while not num and not list_k:\n            if add_up == 1:\n                res.insert(0,1)\n            return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度，需要遍历整个数组。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992191538","body":"### 思路\n\n从左到右遍历然后从右到左遍历，取距离的最小值\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre = float('-inf')\n        res = []\n        for i,number in enumerate(s):\n            if number == c:\n                pre = i\n            res.append(i - pre)\n        pre = float('inf')\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                pre = j\n            res[j] = min(res[j], pre - j)\n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993216818","body":"### 思路\n\n队列实现，按要求来\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass CustomStack:\n    def __init__(self, maxSize: int):\n\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)< self.maxSize:\n            self.stack.append(x)\n        else:\n            pass\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        x = min(k,len(self.stack))\n        for i in range(x):\n            self.stack[i] = self.stack[i] + val\n```\n\n**复杂度分析**\n时间复杂度：push和pop操作的渐进时间复杂度为O(1)O(1), inc操作的渐进时间复杂度为O(k)O(k)\n空间复杂度：用到了一个maxSize的数组作为辅助空间，渐进空间复杂度为O(maxSize)O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994753055","body":"### 思路\n\n两个栈\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, num = [], \"\", 0\n        for c in s:\n            if '0' <= c <= '9':\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append((num, res))\n                res, num = \"\", 0\n            elif c == ']':\n                cur_num, last_res = stack.pop()\n                res = last_res + cur_num * res\n            else:\n                res += c\n        return res\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995424872","body":"### 思路\n\n两个栈\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n\n    def push(self, x: int) -> None:\n        self.stack_in.append(x)\n\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for i in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n\n    def peek(self) -> int:\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n        return not (self.stack_in or self.stack_out)\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996418566","body":"### 思路\n\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        ans = 0\n        cur_max = 0\n        for i in range(len(arr)):\n            if arr[i] > cur_max:\n                cur_max = arr[i]\n            if cur_max == i:\n                ans += 1\n        return ans\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997169203","body":"### 思路\n\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head or not head.next: return head\n        # 求链表长度\n        _len = 0\n        cur = head\n        while cur:\n            _len += 1\n            cur = cur.next\n        # 对长度取模\n        k %= _len\n        if k == 0: return head\n        # 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # newHead 是倒数第 k 个节点，即新链表的头\n        newHead = slow.next\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997330522","body":"### 思路\n迭代法\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        sub = self.swapPairs(head.next.next)\n        new_head = head.next\n        new_head.next = head\n        head.next = sub\n        return new_head\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997609489","body":"### 思路\n双指针找中点\n从中点开始添加\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def findmid(head, tail):\n            slow = head\n            fast = head\n            while fast != tail and fast.next!= tail :\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        def helper(head, tail):\n            if  head == tail: return \n            node = findmid(head, tail)\n            root = TreeNode(node.val)\n            root.left = helper(head, node)\n            root.right = helper(node.next, tail)\n            return root\n            \n        return helper(head, None)\n\n```\n\n**复杂度分析**\n时间复杂度：O(nlogn)O(nlogn)，每次递归找中点O(n)，递归次数O(logn)\n空间复杂度：O(logn)O(logn)，平衡二叉树的高度O(logn)O(logn)，也就是递归过程中栈的最大深度，即需要的空间\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998522422","body":"### 思路\n双指针\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            if A:\n                A = A.next\n            else:\n                A = headB\n            if B:\n                B = B.next \n            else:\n                B = headA\n        return A\n\n\n```\n\n**复杂度分析**\n* 时间：o(m+n)\n* 空间：o((1)\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999642877","body":"### 思路\n双指针\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n   class Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        c = s = f = head # 初始化快慢指针的起点和相遇点\n        while f and f.next: # 快指针循环条件\n            s,f = s.next,f.next.next # 快慢指针同时右移动\n            if s == f: # 相遇点\n                while c != s: # 寻找入环点\n                    c,s = c.next,s.next # 同时移动直到相遇\n                return c # 返回入环点\n        return None # 未相遇，返回空\n\n```\n\n**复杂度分析**\n* 时间复杂度：O(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)。\n* 空间复杂度：O(1）。我们只使用了 三个指针。\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000255296","body":"### 思路\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nfrom collections import OrderedDict as OD\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.od = OD()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.od:\n            self.od.move_to_end(key)\n        return self.od.get(key,-1)\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.od:\n            del self.od[key]\n        self.od[key] = value\n        if len(self.od) > self.capacity:\n            self.od.popitem(last = False)\n\n\n\n```\n\n**复杂度分析**\n* 时间复杂度O(1)\n* 空间复杂度O(n)\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000602542","body":"### 思路\n递归\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1+max(self.maxDepth (root.left), self.maxDepth(root.right))\n\n\n```\n\n**复杂度分析**\n* 时间复杂度：O(n)O(n)，其中 nn 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n* 空间复杂度：O(\\textit{height})O(height)，其中 \\textit{height}height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001006005","body":"### 思路\n递归\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\n\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if p == None and q==None:\n            return True\n        if p == None and q!=None:\n            return False\n        if q == None and p!=None:\n            return False\n        if p.val == q.val:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n        return False\n\n\n```\n\n**复杂度分析**\n* 时间复杂度：O(n)，其中 nn 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n* 空间复杂度：O(height)，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991842636","body":"### 思路\n\n先把k与个位相加。从低到高逐位检查是否大于等于十。如果是，则算出carry on (n // 10) 并加入到前一位，以及当前位保留的值 (n %= 10)。到了最高位如果还大于等于10 则需要在前面手动增加位数，并继续进行计算carry on 和保留值。\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num[-1] += k\n        \n        i = len(num) - 1\n        \n        while i > 0 and num[i] > 9:\n            num[i-1] += num[i] // 10\n            num[i] %= 10\n            i -= 1\n            \n        while num[0] > 9:\n            num = [num[0] // 10] + num\n            num[1] = num[1] % 10\n            \n        return num\n        \n ```\n### 复杂度\nTime Complexity: O(len(num)) \n\nSpace Complexity: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992254880","body":"### 思路\n\n从左往右、从右往左遍历数组两遍，分别计算出当前位置距离左边target character（如果存在）的最短的距离，以及右边target character的最短距离，并取较小的那个存入答案。计算时可以加入dp思想。\n\n\n### 代码\n\n```python\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        \n        res = [0 if cha == c else n for cha in s]\n        for i in range(1, n):\n            res[i] = min(res[i], res[i-1] + 1)\n            \n        for i in range(n-2, -1, -1):\n            res[i] = min(res[i], res[i+1]+1)\n            \n        return res\n```\n\n### 复杂度\nTime: O(n)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993313421","body":"### 思路\nstack是有限制的array 可以push, pop操作可以直接用array的function来做。\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:        \n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n\n```\n\n### 复杂度\n\npush, pop的Time Complexity 都是 O(1)\n\nincrement 的Time Complexity是O(k)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994502435","body":"### 思路\n看见类似括号的对称关系要想到用stack。\n算法需要遍历整个字符串，这里的括号有点类似四则运算的括号，内层的先处理，外层的后处理。遍历时遇见数字就在当前数字num的基础上num * 10+新数字，遇见字母就在stack最后一位加上新字母（因为字母都连在一起，而且遇见开括号时已经向stack推了空str “”，所以现在stack最后一位一定是str），遇见开括号时将空字符串“”push进stack，遇见闭括号的时候就把stack的后三位都pop出来，进行一次运算。后三位是：[......., str2, num, str1] ,把他们合并成：str2 + num * str1，作为新的字符串放在stack末尾。 之后就把stack里最后剩下的都join在一起就是答案。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        it = 0\n        num = 0\n        stack = [\"\"]\n        \n        while it < len(s):\n            \n            if s[it].isdigit():\n                num = num*10 + int(s[it])\n            elif s[it] == \"[\":\n                stack.append(num)\n                num = 0\n                stack.append(\"\")\n            elif s[it] == \"]\":\n                str1 = stack.pop()\n                rep = stack.pop()\n                str2 = stack.pop()\n                stack.append(str2 + str1*rep)\n            else:\n                stack[-1] += s[it]\n                \n            it += 1\n            \n        return \"\".join(stack)\n```\n### 复杂度\nTime Complexity: O(n)\nSpace Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995286810","body":"### 思路\n把一个stack中的元素转移到另一个stack把栈头转成栈尾，等同于逆序。这个class中有一个input stack和output stack。input stack负责存储输入，output stack负责把元素按照queue的方式输出。O(1)时间复杂度的秘诀就是不要重复来回倒，每个元素只转一次。输出时检查output是否为空，output stack若不为空则直接输出，如果空了就再把input全部倒进去。\n\n### 代码\n\n```python\n\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []\n        self.output = []\n\n    def push(self, x: int) -> None:\n        self.input.append(x)\n        \n    def pop(self) -> int:\n        self.move()           \n        return self.output.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.output[-1]\n\n    def empty(self) -> bool:\n        return len(self.input) == 0 and len(self.output) == 0\n\n    def move(self):\n        if not self.output:\n            while self.input:\n                self.output.append(self.input.pop())\n        \n```\n\n### 复杂度\nTime: O(1)\nSpace: O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996996522","body":"### 思路\nrotate可以把链表想象成一个环，计算出需要转的steps，并在新的地方截断。创建一个tail 指针，作用有1:计算出链表长度，用于step数取模。2.将链表首位相连变成环。3:找到新的tail的位置方便截断。\n\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k ==0:\n            return head        \n        \n        tail = head        \n        l = 0        \n        while tail.next:\n            l += 1\n            tail = tail.next            \n        l += 1\n        \n        tail.next = head\n        \n        k %= l\n        step = l-k\n        \n        for _ in range(step):            \n            head = head.next\n            tail = tail.next\n        \n        tail.next = None\n        \n        return head\n        \n\"\"\"\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        l = 0\n        \n        ptr = head\n        while ptr:\n            l += 1\n            ptr = ptr.next\n        \n       \n        k %= l\n        if k== 0:\n            return head\n        \n        slow = fast = head\n        \n        for _ in range(k):\n            fast = fast.next\n        \n        \n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        \n        new_head = slow.next\n        \n        slow.next = None\n        fast.next = head\n        \n        return new_head\n\"\"\"\n```\n\n### 复杂度\nTime Complexity: O(n)\n\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997316190","body":"### 思路\niterative 解法：需要prev, first, second 三个指针。prev：用于上两个node和下两个node进行连接。first和second是一组内需要交换的两个node。先用这三个指针将first和second交换，first就成新的prev连接之后的一组node。\nrecursive解法：需要两个指针first, second。 second之后的node放入recursive function。之后进行轮换，first之后接recursive function返回的值，second之后接first，最后返回second。\n\n### 代码\n```python\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(-1)\n        dummy.next = head\n        \n        prev_node = dummy\n    \n        while head and head.next:\n            first_node = head\n            second_node = head.next\n            \n            prev_node.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n            \n            prev_node = first_node\n            head = first_node.next\n        \n        return dummy.next\n        \n    \"\"\"\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        first_node = head\n        second_node = head.next\n        \n        first_node.next = self.swapPairs(second_node.next)\n        second_node.next = first_node\n        \n        return second_node\n    \"\"\"\n```\n\n### 复杂度\nTime Complexity: O(N)\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997634085","body":"### 思路\ninorder traverse binary search tree will visit nodes in a sorted order. Build the tree recursively in a inorder traverse way. Use two pointer variables to make sure the left tree and right tree are balanced in size (左边build的节点数和右边build的节点数一致). In each recursion, move the head ptr to the next.\n\n还有straight forward的想法就是每次找到中点作为根节点，然后左边和右边分别用recursive function build成左子树和右子树。TC: O(NlogN) SC:O(logN)。该方法优化可以先将linked list转化为array。每次找中点就不用遍历了。\n\n### 代码\n```python \nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def length(node):\n            cnt = 0\n            while node:\n                cnt+= 1\n                node = node.next\n            return cnt\n        \n        def inorder(l, r):\n            nonlocal head\n            if l > r:\n                return None\n            \n            mid = (l+r)//2\n            leftRoot = inorder(l, mid-1)\n            root = TreeNode(head.val)\n            head = head.next\n            root.left = leftRoot\n            root.right = inorder(mid+1, r)          \n            return root\n        \n        return inorder(0, length(head)-1)\n        \n        \n        \n    \"\"\"\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        #TC: O(NlogN) SC:O(logN) (space used for recursion stack, since it is a balanced binary tree, height is logN)\n        \n        if not head:\n            return head\n        \n        middle = self.findMiddle(head)       \n        node = TreeNode(middle.val)\n        if middle == head:\n            return node\n        \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(middle.next)\n        \n        return node\n        \n    def findMiddle(self, head):\n        if not head:\n            return None\n        \n        prev = None\n        slow, fast = head, head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        if prev:\n            prev.next = None\n        \n        return slow\n    \n    \"\"\"\n```\n\n### 复杂度\nTC: O(N)\n\nSC: O(logN) (The recursive stack takes logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998509074","body":"### 思路\n利用双指针。指针a从headA出发一直遍历到tail，之后再放到headB往后遍历，指针b从headB出发一直遍历到tail，之后再放到headA往后遍历。如果有intersection，两个指针会在非tail的位置相遇，否则会都在tail(None)相遇。\n        证明：假设从headA到intersection距离为A，headB到intersection距离为B，从intersection到最后的距离为C(如果有intersection)。那么第二次到达intersection的时候指针a走的距离为A+C+B, 指针b走的距离为B+C+A\n\n\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    \n        a = headA\n        b = headB\n        \n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n    \n    \"\"\"\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        node_in_B = set()\n        \n        while headB:\n            node_in_B.add(headB)\n            headB = headB.next\n        \n        while headA:\n            if headA in node_in_B:\n                return headA\n            else:\n                headA = headA.next\n        return None\n    \"\"\"\n```  \n\n### 复杂度\nTC: O(m+n)\n\nSC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999325702","body":"### 思路\nstraightforward方法是用set，遍历linked list 同时存入set，第一个遇到的重复的就是环的入口。\n另一个是快慢指针方法，利用第一次相遇时快指针走的长度是慢指针两倍，计算出各个部分的长度关系。\n\n### 代码\n\n```python\nclass Solution:\n \n    \"\"\"\n    def detectCycle(self, head: ListNode) -> ListNode:\n        visited = set()\n        \n        while head:\n            if head in visited:\n                return head\n            visited.add(head)\n            head = head.next\n        return None\n    \"\"\"\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n            \n            if slow == fast:\n                break\n        else:\n            return None\n        \n        while head != slow:\n            head = head.next\n            slow = slow.next\n            \n        return head\n ```\n\n### 复杂度\nTC: O(N)\n\nSC: O(1)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000072544","body":"### 思路\nget的时间复杂度为O(1)想到hash map。 cache满了要删除最旧访问过的节点，涉及到要对存储的节点按新旧排序，有array或者linked list可选，需要满足时间复杂度O(1)只能用linked list，tail放最新的node， head是最旧的node。 需要注意的点有：每操作完一个node需要把这个node mark成最近的放在tail，每次put要check cache是不是满了，以及cache里是否已经有这个key。\n\n### 代码\n```python\nclass Node:\n    def __init__(self, k, v):\n        self.key = k\n        self.val = v\n        \n        self.prev = None\n        self.next = None\n\nclass DoubleLinkedList:\n    def __init__(self):\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        \n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n        \n    def addToTail(self, x):\n        x.prev = self.tail.prev\n        x.next = self.tail\n        \n        self.tail.prev.next = x\n        self.tail.prev = x\n        \n        self.size += 1\n        \n    def remove(self, x):\n        x.prev.next = x.next\n        x.next.prev = x.prev\n        \n        self.size -= 1\n        \n    def removeFromHead(self):\n        if self.head.next == self.tail:\n            return None\n        \n        first = self.head.next\n        self.remove(first)\n        return first\n        \n    def size():\n        return self.size\n        \n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.size = capacity\n        self.map = dict()\n        self.cache = DoubleLinkedList()\n\n    def get(self, key: int) -> int:\n        if key not in self.map:\n            return -1\n        \n        node = self.map[key]\n        self.cache.remove(node)\n        self.cache.addToTail(node)\n        \n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.map:\n            node = self.map[key]\n            self.cache.remove(node)\n        \n        new_node = Node(key, value)\n        self.cache.addToTail(new_node)\n        self.map[key] = new_node\n        \n        if len(self.map) > self.size:\n            old_node = self.cache.removeFromHead()\n            del self.map[old_node.key]\n\n```\n\n### 复杂度\nTC: O(1)\nSC: O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000980829","body":"### 思路\nrecursion，先保证当前的节点相同，再判断左右子树是否一致。\n\n### 代码\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \n        if not p and not q:\n            return True\n        if p and not q:\n            return False\n        if not p and q:\n            return False\n        if p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        \n### 复杂度\nTC: O(N)\n\nSC: O(H)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001061258","body":"### 思路\n用dfs，每次把当前node的val和carry on结合成新的数字。到了叶节点(no left and no right) 就把当前数字加到res上。 \n\n\n### 代码\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        self.res = 0 \n        self.dfs(root, root.val)\n        return self.res\n        \n    def dfs(self, node, carry):\n        \n        if node.left:\n            self.dfs(node.left, carry*10+node.left.val)\n        \n        if node.right:            \n            self.dfs(node.right, carry*10+node.right.val)\n            \n        if not (node.left or node.right):\n            self.res += carry\n\n### 复杂度\nTC: O(N)\n\nSC: O(H)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blankpathfind":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991843440","body":"### 思路\n\nv1\n笨方法，先把list转成字符串，字符串转成int，相加之后结果转字符串，字符串拆开成list，害\n\n### 代码\n\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = [str(i) for i in num]\n        num = \"\".join(num)\n        num = int(num)\n        num = str(num+k)\n        num = [int(i) for i in num]\n        return num\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992597115","body":"### 思路\n\n开始想的是遍历，看两边最近的e,后来改成生成一个list存放e所在的index然后再遍历一遍list看最近的abs()\n\n### 代码\n\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        inlist = []\n        outlist = []\n        for i,s_i in enumerate(s):\n            if s_i == c:\n                inlist.append(i)\n        for i in range(len(s)):\n            tmp = [abs(l-i) for l in inlist]\n            outlist.append(min(tmp))\n        return outlist\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(2N)，其中 N 为数组长度。\n- 空间复杂度：O(2N)，空间复杂度较高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993555623","body":"### 思路\r\n\r\n用list作为栈\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            tmp = self.stack[-1]\r\n            self.stack = self.stack[:-1]\r\n            return tmp\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > 0:\r\n            if len(self.stack) < k:\r\n                self.stack = [(i+val) for i in self.stack]\r\n            else:\r\n                for i,s in enumerate(self.stack):\r\n                    if i < k:\r\n                        self.stack[i] = s + val\r\n                    else:\r\n                        break\r\n\r\n\r\n\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994928642","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n\n        for c in s:\n            if c == '[': # 将[之前的multi和字符存入stack\n                stack.append([res, multi])\n                res, multi = \"\", 0\n            elif c == ']':\n                tmp, cur_multi = stack.pop()\n                res = tmp + res * cur_multi\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)\n            else:  # 字符串\n                res += c\n        return res\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995843825","body":"### 思路\r\npython 用list处理比较简单\r\n\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.deque = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.deque.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.deque) == 0:\r\n            return \r\n        tmp = self.deque[0]\r\n        self.deque = self.deque[1:]\r\n        return tmp\r\n\r\n\r\n    def peek(self) -> int:\r\n        return self.deque[0]\r\n\r\n    def empty(self) -> bool:\r\n        if len(self.deque) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tangjy149":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991843767","body":"### 思路\n我是从末位数的方面来考虑，因为需要进行整数的加法，那么k+arr[len-1]%10的值一定是最终和的末位数，那么便从数组的最后一位开始遍历，与k进行相加并取模放入ans数组（因为是从末尾开始，因此需要insert插入到ans的首位）\n\n### Code\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        int len = num.size()-1;\n        for(int i=len;i>=0;i--){\n            k=k+num[i];\n            ans.insert(ans.begin(),k%10);\n            k/=10;\n        }\n        // 此处的处理是为了防止k过大的情况\n        if(k){\n            while(k>9){\n                ans.insert(ans.begin(),k%10);\n                k/=10;\n            }\n            ans.insert(ans.begin(),k);\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度分析\n时间复杂度：O(n)（主要花销在遍历)  \n\n空间复杂度：O(n)(开辟了新的数组用于存储结果)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993110188","body":"### 思路\n用数组进行模拟即可，c++的vector本身就有push_back和pop_back的使用方式，但该题需注意，需要对添加的数进行计数，因为本身数组的大小已经被限制了maxsize，因此不能通过数组的size进行判断数据（应该），所以我添加了count进行计算当前数组已经有多少数据，来对pop和push情况进行判断\n\n### 代码\n```c++\nclass CustomStack {\npublic:\n    int count;// 计数\n    vector<int> helper;\n    CustomStack(int maxSize) {\n        helper.resize(maxSize);\n        count=0;\n    }\n    \n    void push(int x) {\n        if(count<helper.size()){\n            helper[count]=x;\n            count++;\n        }\n    }\n    \n    int pop() {\n        if(--count<0){\n            count=0;\n            return -1;\n        }\n        return helper[count];\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<min(k,count);i++){\n            helper[i]+=val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度\n时间复杂度：push=O(1) pop=O(1) increment=O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994691375","body":"### 思路\n每个字符串可以归结为两类数据，数字和字符，其中根据格式要求，数字会作用于后面[]的字符进行重复。此时因为存在多重[]的情况，可以考虑使用栈的特性，压入栈后弹出，这样可以满足解码的处理顺序（印象中处理多项式加减也是用栈的形式，因为存在一定情况需要提前计算，而非一定是从左到右）  \n综上，设置两个栈，分别存储数字和字符，遇到[，则将当前暂存的数和字符压入栈，遇到]则进行弹出处理，进行字符的循环，最后进行拼接\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> alpha;\n        stack<int> num;\n        int flag=0,temp;// temp存储数字栈弹出的数字\n        string str=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]>='0' && s[i]<='9'){\n                flag=flag*10+s[i]-'0';\n                cout<<flag<<endl;\n            }else if(s[i]=='['){\n                num.push(flag);\n                alpha.push(str);\n                str=\"\";\n                flag=0;\n            }else if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z')){\n                str+=s[i];\n            }else if(s[i]==']'){\n                temp=num.top();\n                num.pop();\n                cout<<str<<endl;\n                for(int j=0;j<temp;j++){\n                    alpha.top()+=str;\n                }\n                str=alpha.top();\n                alpha.pop();\n            }\n        }\n        return str;\n    }\n};\n```\n\n### 复杂度\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995734933","body":"### 思路\n通过栈来实现队列，其实也就是从先进后出，改为先进先出。那么使用一个栈是完成不了的，需要两个栈来完成顺序的变化。s1负责接收输入的数据，而s2则负责输出，当需要pop操作的时候，在s2无数据时，将s1中的数据导入s2中，两次先进后出其实也就恢复了正常顺序，s2进行弹出数据即可，其他操作类似。\n\n### 代码\n```c++\nclass MyQueue {\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        while(s2.empty()){\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int temp=s2.top();\n        s2.pop();\n        return temp;\n    }\n    \n    int peek() {\n        int temp=this->pop();\n        s2.push(temp);\n        return temp;\n    }\n    \n    bool empty() {\n        return s1.empty()&&s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n### 复杂度\n时间复杂度：O(n) 最大开销源于颠倒s1中数据的操作  \n空间复杂度：O(n) 两个栈的使用","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997168323","body":"### 思路\n旋转链表我把它理解为建立循环链表再在适当的地方断链。因此，解题逻辑是，遍历链表并确定节点数量counts，然后链尾ptr2与头部ptr1相连，随后进行指针移动（指针移动不是k，而是counts-k%counts），随后尾部断链，返回头部即可\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==nullptr) return head;\n        ListNode *ptr1=head;\n        ListNode *ptr2=head;\n        int count=1;\n        while(ptr2->next){\n            ptr2=ptr2->next;\n            count++;\n        }\n        ptr2->next=ptr1;\n        int temp=count-k%count;\n        while(temp--){\n            ptr2=ptr2->next;\n            ptr1=ptr1->next;\n        }\n        ptr2->next=nullptr;\n        return ptr1;   \n    }\n};\n```\n\n\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997401978","body":"### 思路\n第一次写这道题的思路是传统思路，先添加头节点，这样便于操作，然后设置两个指针p1和p2，之后对链表进行遍历每次将p2和p2->next进行互换，p1作为记录节点不进行交换。  \n随后通过网上的学习，发现这道题有大佬通过递归来解决，也进行了学习，这里主要使用第二种方式。  \n整体思路是，将整个链表规划为已经整理和未整理的部分，那么未整理部分也就是当前需要处理的两个对换节点head和newxNode，按照递归的层级逻辑，head->next应该是上一次递归返回的节点，然后再将nextNode->next指针指向head，完成对换\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head==nullptr || head->next==nullptr) return head;\n        ListNode *p1=head->next;\n        head->next=swapPairs(p1->next);\n        p1->next=head;\n        return p1;\n    }\n};\n```\n### 复杂度\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997566788","body":"### 思路\n因为本身链表已经是有序，那么只需递归寻找中间节点，便可以满足二叉搜索树的性质，寻找中间节点通过快慢指针进行。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==nullptr) return nullptr;\n        return dfs(head,nullptr);\n    }\n\n    TreeNode* dfs(ListNode* start,ListNode* end){\n        if(start==end) return nullptr;\n        // 快慢指针寻找中间节点\n        ListNode *ptr1=start;\n        ListNode *ptr2=start;\n        while(ptr1!=end&&ptr1->next!=end){\n            ptr1=ptr1->next->next;\n            ptr2=ptr2->next;\n        }\n        // 生成左右子树\n        TreeNode* node=new TreeNode(ptr2->val);\n        node->left=dfs(start,ptr2);\n        node->right=dfs(ptr2->next,end);\n        return node;\n    }\n};\n```\n\n### 复杂度\n时间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998431519","body":"### 思路\n我走完我的路，就去走你的路，我一共走了我+你的路；  \n你走完你的路，也来走我的路，你一共走了你+我的路；  \n这意味着我们走的路其实是一样多，如果两条路存在交点，那一定会遇见。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA==nullptr || headB==nullptr) return nullptr;\n        ListNode *ptr1=headA;\n        ListNode *ptr2=headB;\n        while(ptr1!=ptr2){\n            ptr1=(ptr1==nullptr?headB:ptr1->next);\n            ptr2=(ptr2==nullptr?headA:ptr2->next);\n        }\n        return ptr1;\n    }\n};\n```\n\n### 复杂度 \n时间复杂度：O(A链长度+B链长度)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999238686","body":"### 思路\n快慢指针，分两部分  \n第一部分：通过快慢指针来判定是否存在环，quick=2*slow，只要能相遇就一定有环，若无环则直接返回null  \n第二部分：从第一次相遇点开始，再设置q=head，与slow指针同时向后移动，再次相遇则是第一次入环节点  \n令head到入环节点距离=a，入环节点到第一次相遇点=b，环中剩余部分（第一相遇到入环）=x  \na+b=slow  2（a+b）=quick  \n又quick=a+b+x+b（相当于比slow多走一个环的距离x+b）  \n解之可得，a=x  \n故从head从头开始移动和slow继续移动，最终相遇点为入环点\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head==nullptr) return nullptr;\n        ListNode *ptr1=head;\n        ListNode *ptr2=head;\n        bool flag=false;\n        while(ptr1->next!=nullptr && ptr1->next->next!=nullptr){\n            ptr1=ptr1->next->next;\n            ptr2=ptr2->next;\n            if(ptr2==ptr1){\n                flag=true;\n                break;\n            }\n        }\n        if(!flag) return nullptr;\n        ListNode *p=head;\n        ListNode *q=ptr1;\n        while(p!=q){\n            p=p->next;\n            q=q->next;\n        }\n        return p;\n    }\n};\n```\n\n### 复杂度\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000007604","body":"### 思路\nLRU缓存是计算机进程管理用的机制，为了腾出内存空间，需要将最近最久未使用的进程移除。  \n用笔画的话，可以将整个存放空间看作类似栈的形式，每次操作之后就放在最上，每次新元素插入就移除最下面的元素，从而达到lru的策略。  \n但实际编码不能用这样的方式，每次操作元素可看作两步：查找和移动  \n查找最快应该是采用hashtable的形式，但移动不行，因此还需其他数据结构辅助  \n数组和链表时间复杂度都较高，移动采取双向链表的形式，可以克服问题\n综上，采用哈希表+双向链表来模拟机制\n\n### 代码\n```c++\nclass LRUCache {\nprivate:\n    unordered_map<int, std::list<std::pair<int, int>>::iterator> helper;\n    std::list<std::pair<int, int>> lru;\n    int _capacity;\npublic:\n    LRUCache(int capacity): _capacity(capacity) {\n\n    }\n    \n    int get(int key) {\n        auto it=helper.find(key);\n        if (it!=helper.end()) {\n            lru.splice(lru.begin(),lru,it->second);// 将it->second值拼接到lru\n            return it->second->second;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        auto it = helper.find(key);\n        if (it != helper.end()) {\n            lru.splice(lru.begin(), lru, it->second);\n            it->second->second = value;\n            return;\n        }\n        lru.push_front(pair<int,int>(key,value));//因为刚刚插入，属于刚刚操作过，放在链表开始位置\n        helper[key] = lru.begin();\n        if (helper.size() > _capacity) {\n            helper.erase(lru.back().first);\n            lru.pop_back();\n        }\n    }\n\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n### 复杂度\n时间复杂度:O(1)  \n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000621946","body":"### 思路\n简单的dfs，深度每次取左右子数中的最大的+1\n\n### 代码\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr) return 0;\n        return max(maxDepth(root->left),maxDepth(root->right))+1;\n    }  \n};\n```\n\n### 复杂度\n时间复杂度 O(n)  \n空间复杂度 O(树深度=递归层数)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000975275","body":"### 思路\n递归判断左子树和右子树\n\n### 代码\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==nullptr && q==nullptr) return true;\n        if(p==nullptr || q==nullptr) return false;\n        if(p->val!=q->val) return false;\n        return isSameTree(p->left,q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991846050","body":"### 思路\r\n\r\niterate the array and integer from right to left, sum up and store in the ArrayList.\r\nuse a carry variable to store the tens.\r\nreverse the ArrayList in the end.\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n\r\n        while(len >= 0 || k != 0){\r\n            int x = len < 0 ? 0 : num[len];\r\n            int y = k == 0 ? 0 : k % 10;\r\n\r\n            int sum = carry + x + y;\r\n            res.add(sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            len--;\r\n            k = k / 10;\r\n        }\r\n\r\n        if (carry > 0) res.add(1);\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992149394","body":"### 思路\r\n\r\n从左到右，然后从右到左遍历两遍\r\n找到C并记录它和S[i]的距离，最后取最小值\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; // create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store char c\r\n                                         // /2 to avoid index out of bound\r\n\r\n        for(int i = 0; i < s.length(); i++){ // from left to right\r\n            if(s.charAt(i) == c) dummy = i;  // find first c, store it and calculate the next number \r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;            // from right to left\r\n        for(int i = s.length() - 1; i >= 0; i--){ \r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);  // compare to find the min and store it\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993170998","body":"### 思路\n\n用数组模拟栈\n\n### 代码\n\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < stack.length - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1){\n            return -1;\n        }else{\n            top--;\n            return stack[top + 1];\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top+1);\n        for(int i = 0; i < limit; i++){\n            stack[i] = stack[i] + val;\n        }\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(k)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994328575","body":"### 代码\r\n\r\n``` Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                rStr = ''\r\n                rCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    rStr = stack.pop() + rStr\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    rCount = stack.pop() + rCount\r\n                stack.append(rStr * int(rCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995439328","body":"### 思路\r\nuse 2 stacks, one for push, another for pop and seek.\r\n\r\n### 代码\r\n\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        while(!s2.isEmpty()){\r\n            s1.push(s2.pop());\r\n        }\r\n        s1.push(x);\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty()&&s2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996262848","body":"### 思路\r\n\r\nuse monotonic stack \r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n\r\n        for(int num : arr){\r\n            if(!stack.isEmpty() && num < stack.peek()){\r\n                int top = stack.pop();\r\n                // use while because num needs to compare every element in stack\r\n                while(!stack.isEmpty() && num < stack.peek()){\r\n                stack.pop();\r\n                }\r\n                stack.push(top);\r\n            }else{\r\n                stack.push(num);\r\n            }\r\n\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997076924","body":"### 思路\n\n双指针，环形linked list\n\n### 代码\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        \n        int n = 1;\n        ListNode iter = head;\n        while(iter.next != null){\n            iter = iter.next;\n            n++;\n        }\n        k = k % n;\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while(fast.next != null){\n            if(k <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n            k--;\n        }        \n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n\n        return res;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997334583","body":"### 思路\r\n\r\ncreate a dummy head to store the head, traverse the LinkedList and swap with the 2 pointers\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode pre = new ListNode();\r\n        pre.next = head;\r\n        ListNode temp = pre;\r\n        while(temp.next != null && temp.next.next != null){\r\n            ListNode s = temp.next, f = temp.next.next;\r\n            temp.next = f; \r\n            s.next = f.next;\r\n            f.next = s;\r\n            temp = s;\r\n        }\r\n        return pre.next;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997625941","body":"### 思路\n\nuse slow/fast pointer to find the middle value of the linked list\nbuild tree based on that root, using recursion\n### 代码\n\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null){\n            return null;\n        }\n        return buildTree(head, null);\n    }\n    public TreeNode buildTree(ListNode head, ListNode tail){\n        if(head == tail){\n            return null;\n        }\n        ListNode fast = head, slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = buildTree(head, slow);\n        root.right = buildTree(slow.next, tail);\n        return root;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998469887","body":"### 思路\n2 pointers, they first traverse their own list, then traverse each other's LinkedList. If they met, that's the intersection.\n\n### 代码\n\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b){\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(M+N)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999278497","body":"### 思路\n2 pointers\n\n### 代码\n\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast != null){\n            slow = slow.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }else{\n                return null;\n            }\n            \n            if(fast == slow){\n                ListNode ptr = head;\n                while(ptr != slow){\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000066409","body":"### 思路\n\n双向链表+哈希表\n\n### 代码\n\n\n```java\nclass Node{\n    public int key, val;\n    public Node prev, next;\n    public Node(int k, int v){\n        this.key = k;\n        this.val = v;\n    }\n}    \nclass DoubleList{\n    private Node head, tail;\n    private int size;\n    public DoubleList(){\n        head = new Node(0,0);\n        tail = new Node(0,0);\n        head.next = tail;\n        tail.prev = head;\n        size = 0;\n    }\n    public void addLast(Node x){\n        x.prev = tail.prev;\n        x.next = tail;\n        tail.prev.next = x;\n        tail.prev = x;\n        size++;\n    }\n    public void remove(Node x){\n        x.prev.next = x.next;\n        x.next.prev = x.prev;\n        size--;\n    }\n    public Node removeFirst(){\n        if(head.next == tail) return null;\n        Node first = head.next;\n        remove(first);\n        return first;\n    }\n    public int size(){\n        return size;\n    }\n\n}\nclass LRUCache {\n    private HashMap<Integer, Node> map;\n    private DoubleList cache;\n    private int cap;\n\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n        map = new HashMap<>();\n        cache = new DoubleList();\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        makeRecent(key);\n        return map.get(key).val;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            deleteKey(key);\n            addRecent(key, value);\n            return;\n        }\n        if(cap == cache.size()){\n            deleteLeastRecent();\n        }\n        addRecent(key,value);\n    }\n\n    private void makeRecent(int key){\n        Node x = map.get(key);\n        cache.remove(x);\n        cache.addLast(x);\n    }\n    private void addRecent(int key, int val){\n        Node x = new Node(key, val);\n        cache.addLast(x);\n        map.put(key, x);\n    }\n    private void deleteKey(int key){\n        Node x = map.get(key);\n        cache.remove(x);\n        map.remove(key);\n    }\n    private void deleteLeastRecent(){\n        Node deletedNode = cache.removeFirst();\n        int deletedKey = deletedNode.key;\n        map.remove(deletedKey);\n    }\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000633785","body":"### 思路\n\n递归\n\n### 代码\n\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n        return 1 + Math.max(leftMax, rightMax);\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(h), h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000971434","body":"### 思路\n\n递归\n\n### 代码\n\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null || q == null){\n            return false;\n        }\n        if(p.val != q.val){\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(h), h为树的高度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nweass":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991846310","body":"## 思路\n\n考虑到需要进位，需要的位数可能发生变化，新增一个List储存结果\n\n双指针遍历两个整数，使用一个add记录进位\n\n类似题目有大数加减法\n\n## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int i = num.length - 1;\n        int j = 0;\n        int add = 0;\n        ArrayList<Integer> resList = new ArrayList<>();\n        while(i >= 0 || k > 0 ||add != 0){\n            int x = i < 0 ? 0 : num[i];\n            int y = k == 0 ? 0 : k % 10;  \n\n            int result = x + y + add;\n            add = result /10;\n            resList.add(result % 10);\n            i--;\n            k = k / 10;\n        }\n        Collections.reverse(resList);\n        return resList;\n    }\n}\n```\n\n## 复杂度分析\n\n空间：使用了一个新建List保存结果，List大小为num[]或k的位数 O(n)\n\n时间：遍历一遍num[] 长度n或k的位数m中最大的一个，O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997213426","body":"## 思路\n\n\n\n从倒数第K个节点断开，尾节点指向头节点，倒数第K个节点作为头节点返回\n\n## 代码\n\n```java\nclass Solution {\n   public ListNode rotateRight(ListNode head, int k) {\n        //边界处理\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n\n        //一个快指针，一个慢指针\n        ListNode fast = head;\n        ListNode slow = head;\n\n        //记录链表的长度\n        int len = 0;\n        while (len < k && fast != null) {\n            len++;\n            fast = fast.next;\n        }\n\n        /**\n         * 如果fast为null，则代表k的值大于链表的长度\n         * 那么实际上：当k值大于链表的长度时，旋转k次的结果等于旋转（k%链表的长度）次\n         * 比如：链表为： 1---2---3，k为：4\n         * k的长度要大于链表的长度，所以k=4%3，k=1，即整个链表实际上只需要旋转一次即可\n         */\n        if (fast == null) {\n            k = k % len;\n            //如果k==0，则实际上不用旋转，直接返回即可\n            if (k == 0) {\n                return head;\n            }\n            //否则快指针从头开始，重新先走k次，此时的k已经是和len取模的结果了\n            fast = head;\n            for (int i = 0; i < k; i++) {\n                fast = fast.next;\n            }\n        }\n        //此时，慢指针和快指针继续同时走\n        while (fast != null && fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        //当快指针走到底时，此时慢指针的下一个节点就是新的头节点\n        ListNode newHead = slow.next;\n        //慢指针当前节点就是尾节点\n        slow.next = null;\n        //快指针的下一节点（就是原来链表的最后一个节点）链上原来的头节点即可\n        fast.next = head;\n        //最后返回新的头节点\n        return newHead;\n    }\n\n}\n```\n\n\n\n## 复杂度分析\n\n遍历一遍时间复杂度为O(n)\n\n原地交换空间复杂度为O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997610374","body":"## 思路\r\n\r\n递归构建二叉树，每层的步骤为\r\n\r\n1.找到链表中点，作为当前的根\r\n\r\n2.当前节点左边作为左子树，并进入下一层（同理构建右子树）\r\n\r\n## 代码\r\n\r\n```java\r\nclass Solution {\r\n  public TreeNode sortedListToBST(ListNode head) {\r\n      if(head == null) return null;\r\n      return build(head,null);\r\n  }\r\n  private TreeNode build(ListNode head, ListNode tail){\r\n      if(head == tail) return null;\r\n      ListNode fast = head;\r\n      ListNode slow = head;\r\n      \r\n      //找到中点\r\n      while(fast != tail && fast.next != tail){\r\n          fast = fast.next.next;\r\n          slow = slow.next;\r\n      }\r\n      //构建左右子树\r\n      TreeNode root = new TreeNode(slow.val);\r\n      root.left = build(head, slow);\r\n      root.right = build(slow.next, tail);\r\n      return root;\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：递归树的深度为 logn，每一层的方法复杂度为 n，因此总的时间复杂度为O(nlogn)\r\n- 空间复杂度：空间复杂度为递归树的高度O(logn)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998439137","body":"## 思路\n\n双指针遍历两个链表，链表A长m，链表B长n，当指针遍历完一个链表后，重新指向另一个链表的头节点重新开始遍历\n\n如果链表相交，当两个指针相同时，两个指针都刚好走过了 m + n\n\n## 代码\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null ){\n            return null;\n        }\n\n        ListNode pa = headA;\n        ListNode pb = headB;\n        while(pa != pb){\n            pa = pa == null? headB : pa.next;\n            pb = pb == null? headA : pb.next;\n        }\n        return pa;\n    }\n}\n```\n\n\n\n## 复杂度分析\n\n时间复杂度遍历两个链表O(m + n)\n\n空间复杂度使用两个指针O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000607398","body":"## 思路\n\n### BFS\n\n层次遍历，每下一层，深度加1\n\n### DFS\n\n深度遍历，递归返回左右子树的最大深度加1\n\n## 代码\n\n```java\n    \n//BFS\npublic int maxDepth(TreeNode root) {\n        int max = 0;\n        if(root == null) return max;\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.add(root);\n        \n        while(!queue.isEmpty()){\n            int size = queue.size();\n            while(size > 0){\n                TreeNode cur = queue.poll();\n                if(cur.left != null) queue.add(cur.left);\n                if(cur.right != null) queue.add(cur.right);\n                size--;\n            }\n            max++;\n        }\n        return max;\n    }\n\n```\n\n```java\npublic int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\n    }\n```\n\n\n\n## 复杂度分析\n\n### BFS\n\nwhile循环次数为二叉树的节点数，时间复杂度为O(n)\n\n使用额外队列保存，空间复杂度为O(n)\n\n### DFS\n\n时间复杂度：O(N)，其中 N 为节点数。\n\n空间复杂度：O(h)，其中 h 为树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yugaoh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991848642","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int carry  = 0;//进位\n        int i = num.size() - 1;\n        vector<int> vec;\n\n        while(i >= 0 || k != 0)\n        {\n            int n1 = i >= 0 ? num[i] : 0;\n            int n2 = k >= 0 ? k % 10 : 0;\n\n            int value = n1 + n2 + carry;\n            vec.push_back(value % 10);\n            carry = value / 10;\n\n            --i;\n            k = k / 10;\n        }\n\n        if(carry != 0)\n            vec.push_back(carry);\n        \n        reverse(vec.begin(), vec.end());\n\n        return vec;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992079459","body":"#思路\n\n先找到字符串中的第一个char c，令right指向这个位置，则从数组开始至第一个c的最近距离都是abs(i-right)\n然后令left指向right，则left到right之间的距离都是abs(j - left)和abs(j - right)的最小值\n最后是最后一个char c右边的部分，left指向这个最后的char c，则右边部分的最短距离都是abs(j - left)\n\n#代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> vec;\n        int left = 0;\n        int right = 0;\n\n        for(int i = 0; i < len; i++)\n        {\n            if(c == s[i])\n            {\n                right = i;\n                break;\n            } \n        }\n\n        for(int j = 0; j < right; j++)\n        {\n            vec.push_back(abs(j - right));  \n        }\n        left = right;\n\n        for(int i = left; i < len; i++)\n        {\n            if(c == s[i])\n            {\n                right = i;\n                for(int j = left; j < right; j++)\n                {\n                    int tmp = abs(j - left) < abs(j - right) ? abs(j - left) : abs(j - right);\n                    vec.push_back(tmp);\n                }\n                left = right;   \n            }  \n        }\n\n        if(left <= len - 1)\n        {\n            for(int i =left; i < len; i++)\n            {\n                vec.push_back(abs(i - left));\n            }\n        }\n\n        return vec;\n    }\n};\n```\n\n#复杂度\n\n时间复杂度O(n2)\n\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993340696","body":"#用静态数组实现stack\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) \n    :_top(-1)\n    ,_size(maxSize)\n    ,_data(new int[_size]())\n    {\n        \n    }\n    \n    void push(int x) {\n        if( !full() )\n        {\n            _data[++_top] = x;\n        }\n    }\n    \n    int pop() {\n        if( !empty() )\n        {\n            return _data[_top--];\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int count = min(k, _top+1);\n        for(int i = 0; i < count; i++)\n        {\n            _data[i] += val;\n        }\n    }\n\n    bool empty()\n    {\n        return _top == -1;\n    }\n\n    bool full()\n    {\n        return (_top == _size - 1);\n    }\n\nprivate:\n    int _top;\n    int _size;\n    int *_data;\n};\n\n#用动态数组实现stack\nclass CustomStack {\npublic:\n    CustomStack(int maxSize)\n\t{\n\t\tvec.resize(maxSize);\n\t\ttop = -1;\n\t}\n\t\n\tvoid push(int x) \n\t{\n\t\tif(top != vec.size() - 1)\n\t\t{\n            ++top;\n\t\t\tvec[top] = x;\n\t\t}\n\t}\n\t\n\tint pop()\n\t{\n\t\tif(top != -1)\n\t\t{\n\t\t\treturn vec[top--];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tvoid increment(int k, int val)\n\t{\n\t\tint count = min(k, top + 1);\n\t\tfor(int i = 0; i < count; i++)\n\t\t{\n\t\t\tvec[i] += val;\n\t\t}\n\t}\n\t\nprivate:\n\tvector<int> vec;\n\tint top;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994680125","body":"数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) { \n        stack<int> num;\n        stack<string> strs;\n        int value = 0;\n\n        for(int i = 0; i < s.size(); ++i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                value = 0;\n                while(isdigit(s[i]))\n                {\n                    //防止连续数字\n                    value = value * 10 + s[i] - '0';\n                    i++;\n                }\n                num.push(value);\n\n                //当不满足while条件时，此时i指向的不是数字，要回退\n                //一步，因为for循环里有自增\n                --i;\n            }\n\n            else if(s[i] == '[' || s[i] >= 'a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z')\n            {\n                string tmp(1, s[i]);\n                strs.push(tmp);\n            }\n\n            else\n            {\n                int times = num.top();//遇到']'，弹出数字栈顶元素\n                num.pop();\n\n                string str = \"\";\n                while(strs.top() != \"[\")\n                {\n                    str = strs.top() + str;\n                    strs.pop();\n                }\n                strs.pop();\n\n                string tmp;\n                for(int i = 0; i < times; ++i)\n                {\n                    tmp += str;\n                }\n                strs.push(tmp);\n                //每结束一对[]的解码，就将其压入栈中，最后按顺序拼接即可\n            }\n        }\n\n        //当for循环执行完毕时，所有的字符串都存在strs栈里，按顺序拼接起来即可\n        string res;\n        while(strs.size() != 0)\n        {\n            res = strs.top() + res;\n            strs.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999981197","body":"class LRUCache {\nstatic class Node {\nprivate int key;\nprivate int value;\nNode prev, next;\npublic Node(int key, int value) {\nthis.key = key;\nthis.value = value;\n}\n}\n\nprivate int capacity;\nprivate Map<Integer, Node> map;\nprivate Node dummyhead, dummytail;\n\npublic LRUCache(int capacity) {\n    this.capacity = capacity;\n    this.map = new HashMap<>();\n    this.dummyhead = new Node(-1, -1);\n    this.dummytail = new Node(-1, -1);\n    this.dummyhead.next = this.dummytail;\n    this.dummytail.prev = this.dummyhead;\n}\n\npublic int get(int key) {\n    Node node = getNode(key);\n    if(null == node) return -1;\n    return node.value;\n}\n\nNode getNode(int key) {\n    Node node = map.get(key);\n    if(null == node) return null;\n    disconnect(node);\n    insertHead(node);\n    return node;\n}\n\nvoid disconnect(Node node) {\n    node.next.prev = node.prev;\n    node.prev.next = node.next;        \n}\n\nvoid insertHead(Node node) {\n    node.next = dummyhead.next;\n    dummyhead.next.prev = node;\n    node.prev = dummyhead;\n    dummyhead.next = node;        \n}\n\npublic void put(int key, int value) {\n    Node node = getNode(key);\n    if(null != node) {\n        node.value = value;\n    }\n    else {\n        node = new Node(key, value);\n        insertHead(node);\n        \n        map.put(key, node);\n        if(map.size() > capacity) {\n            Node tail = dummytail.prev;\n            disconnect(tail);\n            map.remove(tail.key);\n        }\n    }\n}\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dahaiyidi":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991849235","body":"## Question\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### Note\n\n- 思路不难：将数字从最后一位开始计算加法\n- 注意进位\n- 注意有一方先遍历完毕的情况\n\n### Complexity\n\n- 时间O：max(n, logk)\n- 空间O：1 (返回值不计算在内)\n\n## Python\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        \n        for i in  range(len(num) - 1, -1, -1):\n            add = num[i] + k % 10  # k包含进位信息\n            k = k // 10\n\n            if add >= 10:\n                add -=10\n                k += 1 # 将进位1加到k上\n\n            res.append(add % 10)\n\n        # 若k不是零\n        while k != 0:\n            res.append(k % 10)\n            k = k // 10\n        \n        return res[::-1]\n```\n\n## C++\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for(int i = num.size() - 1; i >= 0; i--){\n            int add = num[i] + k % 10;\n            k /= 10;\n            if (add >= 10){\n                k++;\n                add = add - 10;\n            }\n\n            res.push_back(add % 10);\n        }\n        while (k != 0){\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992490670","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Question \r\n\r\n#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\r\n\r\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式\r\n\r\n### Note\r\n\r\n- 思路不难，重要的是不要被题目吓到\r\n- 从left到right扫一遍，从right 到left扫一遍，两者取最小值\r\n\r\n### Complexity\r\n\r\n- 时间O：N\r\n- 空间O：1\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num_s = len(s)\r\n        res = [-1] * num_s  # res 最终的值必<num_s， 也可以使用Integer.MAX_VALUE / 2\r\n\r\n        # 从left到right扫一遍，从right 到left扫一遍，两者取最小值\r\n        \r\n        n = num_s\r\n        for i in range(num_s):\r\n            if s[i] == c:\r\n                n = 0\r\n            res[i] = n\r\n            n += 1\r\n        \r\n        n = num_s\r\n        for i in range(num_s -1, -1, -1):\r\n            if s[i] == c:\r\n                n = 0\r\n            res[i] = min(res[i], n)\r\n            n += 1\r\n        \r\n        return res\r\n\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int num_s = s.size();\r\n        vector<int> res(num_s, num_s);\r\n\r\n        int n = num_s;\r\n        for(int i = 0; i < num_s; i++){\r\n            if(s[i] == c){\r\n                n = 0;\r\n            }\r\n            res[i] = n;\r\n            n++;\r\n        }\r\n\r\n        n = num_s;\r\n        for(int i = num_s - 1; i >= 0; i--){\r\n            if(s[i] == c){\r\n                n = 0;\r\n            }\r\n            res[i] = min(res[i], n);\r\n            n++;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993622129","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Question \r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度中等62\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 使用数组模拟\r\n- 额外使用一个数组模拟increment，以降低increment函数的时间复杂度\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：1\r\n- 空间O：maxSize\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.add = [0] * maxSize\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        self.top -= 1\r\n        if self.top != -1:\r\n            self.add[self.top] += self.add[self.top + 1]  # 更新add\r\n        self.add[self.top + 1] = 0\r\n        return ret\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k-1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk, add;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != stk.size() - 1){\r\n            top++;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        int res = -1;\r\n        if(top != -1){\r\n            res = stk[top] + add[top];\r\n            top -= 1;\r\n            if(top != -1){\r\n                add[top] += add[top + 1];\r\n            }\r\n            add[top + 1] = 0;            \r\n        }\r\n        return res;\r\n\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k - 1, top);\r\n        if (lim >= 0) {\r\n            add[lim] += val;\r\n        }\r\n\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994856839","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Problem\r\n\r\n#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n难度中等960\r\n\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k* ，例如不会出现像 `3a` 或 `2[4]` 的输入。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 将字符、数字、[...]看成一组，由于[]存在嵌套，所以需要借用栈，不停压入状态\r\n- 注意数字可能是多位数，字符串可能存在多个字符\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：n\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n\r\n        for c in s:\r\n            if c == '[': # 将[之前的multi和字符存入stack\r\n                stack.append([res, multi])\r\n                res, multi = \"\", 0\r\n            elif c == ']': # 取出[之前存入stack的multi和字符\r\n                tmp, cur_multi = stack.pop()\r\n                res = tmp + res * cur_multi\r\n            elif '0' <= c <= '9':  # 有可能数字是多位数字\r\n                multi = multi * 10 + int(c)\r\n            else:  # 字符串\r\n                res += c\r\n        return res\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<pair<string, int>> st;\r\n        string res = \"\";\r\n        int multi = 0;\r\n        for(auto c: s){\r\n            if(c == '['){\r\n                st.push(make_pair(res, multi));\r\n                res = \"\";\r\n                multi = 0;\r\n            }\r\n            else if(c == ']'){\r\n                string tmp = st.top().first;\r\n                for(int i = 0; i < st.top().second; i++){\r\n                    tmp += res;\r\n                }\r\n                res = tmp;\r\n                st.pop();\r\n            }\r\n            else if((c >= '0') && (c <= '9')){\r\n                multi = multi * 10 + (c - '0');\r\n            }\r\n            else {\r\n                res += c;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995867970","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Problem\r\n\r\n#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n难度简单517\r\n\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\r\n\r\n实现 `MyQueue` 类：\r\n\r\n- `void push(int x)` 将元素 x 推到队列的末尾\r\n- `int pop()` 从队列的开头移除并返回元素\r\n- `int peek()` 返回队列开头的元素\r\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\r\n\r\n \r\n\r\n**说明：**\r\n\r\n- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\r\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n**进阶：**\r\n\r\n- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 只要st_out不为空，就可以一直从st_out pop。 peek同理。\r\n- 在push时，不需要将st_out添加到st_in中，可以直接push。\r\n- 当push时，若st_in为空，可以设置front等于该待push的值，以当做peek使用（当st_out 为空时）。\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O： 摊还复杂度1\r\n- 空间O：n\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.st_in, self.st_out = [], []\r\n        self.st_in_front =None\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.st_in) == 0:\r\n            self.front = x\r\n        self.st_in.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st_out) == 0:\r\n            for _ in range(len(self.st_in)):\r\n                self.st_out.append(self.st_in.pop())\r\n        \r\n        if len(self.st_out):\r\n            return self.st_out.pop()\r\n\r\n    def peek(self) -> int:        \r\n        if len(self.st_out): \r\n            return self.st_out[-1]\r\n        return self.st_in_front\r\n        \r\n    def empty(self) -> bool:\r\n        return len(self.st_in) == 0 and len(self.st_out) == 0\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n\r\n    stack<int> st1, st2;\r\n    int st1_front;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(st1.empty()){\r\n            st1_front = x;\r\n        }\r\n        st1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(st2.empty()){\r\n            while(!st1.empty()){\r\n                st2.push(st1.top());\r\n                st1.pop();\r\n            }\r\n        }\r\n        if(!st2.empty()){\r\n            int tmp = st2.top();\r\n            st2.pop();\r\n            return tmp;\r\n\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    int peek() {\r\n        if(!st2.empty()){\r\n            return st2.top();\r\n        }\r\n        return st1_front;\r\n    }\r\n    \r\n    bool empty() {\r\n        return (st1.empty() && st2.empty());\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996764141","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Problem\r\n\r\n#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n难度困难109\r\n\r\n*这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为`2000`，其中的元素最大为`10**8`。*\r\n\r\n`arr`是一个可能包含**重复元素**的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 重要的是要分析规律。\r\n- 从首到尾部遍历\r\n  - if  arr[i] > max(arr[:i])， 则可以在之前的结果上多一个区域\r\n  - if arr[i] < max(arr[:i])，就需要更复杂的分析：将arr[i] 和arr[i-1]放置到同一块区域，而arr[i-1]所在的区域，需要寻找满足arr[i] 刚好>= max(arr[:j]) 可以设置一个stack存储截止到某区域最大的值。\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：n\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        st = [] \r\n        for num in arr:\r\n            if st and st[-1] > num:\r\n                head = st.pop()\r\n                j = len(st) - 1\r\n                while j >= 0 and st[j] > num:\r\n                    st.pop()\r\n                    j -= 1\r\n                st.append(head)\r\n            else:\r\n                st.append(num)\r\n        \r\n        return len(st)\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st;\r\n        for(auto num: arr){\r\n            if(!st.empty() && st.top() > num){\r\n                int head = st.top(); // 存储最后一个区域的最大值\r\n                st.pop();\r\n                while(!st.empty() && st.top() > num){\r\n                    st.pop();  // 抛弃，直到遇到刚好st[j] <= num\r\n                }\r\n                st.push(head);\r\n            }\r\n            else{\r\n                st.push(num);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997161501","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Problem\r\n\r\n#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n难度中等683\r\n\r\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 计算总节点数num\r\n- 首尾连接，寻找倒数第k+1个节点，也就是找到第num - k的节点。从该节点处切断链表即可。\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：1\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        p = head\r\n        num = 1\r\n        # 计算总节点数\r\n        while p and p.next:\r\n            p = p.next\r\n            num += 1\r\n        \r\n        # 链接成环\r\n        p.next = head\r\n\r\n        k = k % num # 计算新k\r\n        # 找到倒数第k + 1 个节点，也就是找到第num - k的节点\r\n        \r\n        pre = head\r\n        for _ in range(num - k - 1):\r\n            pre = pre.next\r\n        \r\n        head = pre.next\r\n        pre.next = None\r\n        return head\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(!head || !head->next){\r\n            return head;\r\n        }\r\n        int num = 1;\r\n        ListNode * p = head;\r\n        while(p && p->next){\r\n            p = p->next;\r\n            num++;\r\n        }\r\n\r\n        p->next = head;\r\n\r\n        k %= num;\r\n\r\n        p = head;\r\n        for(int i = 0; i < num - k - 1; i++){\r\n            p = p->next;\r\n        }\r\n        head = p->next;\r\n        p->next = NULL;\r\n        return head;\r\n\r\n    }\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997324998","body":"## Problem\r\n\r\n#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n难度中等1173\r\n\r\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 简单的反转链表\r\n\r\n- 为了更加通用，设置应该nx.next = pre.next, 而不是nx.next = cur, 因为在别的反转题目中，cur与pre中间可能还有节点，如每3个反转\r\n\r\n- ![image-20211219114535548](imgs/image-20211219114535548.png)\r\n\r\n  \r\n\r\n- \r\n\r\n  \r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：1\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head:\r\n            return head\r\n        \r\n        dummy = ListNode(0, head)\r\n        #  初始化pre, cur\r\n        pre = dummy\r\n        cur = dummy.next\r\n        while cur and cur.next:\r\n            nx = cur.next\r\n            cur.next = nx.next\r\n            nx.next = pre.next\r\n            pre.next = nx\r\n            # 下一循环的pre，cur\r\n            pre = cur\r\n            cur = cur.next\r\n        return dummy.next\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(!head){\r\n            return head;\r\n        }\r\n        ListNode* dummy = new ListNode(0, head);\r\n        ListNode* pre = dummy;\r\n        ListNode* cur = pre->next;\r\n        while(cur && cur->next){\r\n            ListNode* nx = cur->next;\r\n            cur->next = nx->next;\r\n            nx->next = pre->next;\r\n            pre->next = nx;\r\n            pre = cur;\r\n            cur = cur->next;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\nFrom : https://github.com/dahaiyidi/awsome-leetcode","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998769367","body":"## Problem\r\n\r\n#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n++\r\n\r\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\r\n\r\n题目数据 **保证** 整个链式结构中不存在环。\r\n\r\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 直接看下图：\r\n- ![img](../imgs/clipboard-16400923934201.png)\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：m + n\r\n- 空间O：1\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n\r\n        l1 = headA\r\n        l2 = headB\r\n        flag = False\r\n        while l1 != l2:\r\n            l1 = l1.next if l1 else headB\r\n            l2 = l2.next if l2 else headA\r\n\r\n        return l1\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA==NULL || headB==NULL)\r\n            return NULL;\r\n        ListNode * p1=headA;\r\n        ListNode* p2= headB;\r\n        while(p1!=p2){\r\n            p1=p1==NULL?headB:p1->next;\r\n            p2=p2==NULL?headA:p2->next;\r\n        }\r\n        return p1;        \r\n    }\r\n```\r\n\r\n\r\n\r\nFrom : https://github.com/dahaiyidi/awsome-leetcode","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999512626","body":"## Problem\r\n\r\n#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n++\r\n\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 利用快慢指针\r\n- 在相交点处，将slow设置为head, fast停留在相交点。 然后fast和slow每次均移动一步，再次相交点就是进入环的第一个节点\r\n- 注意：初始状态为： slow = fast = head\r\n- ![image-20211221214321975](../imgs/image-20211221214321975.png)\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：1\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\n#python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        # if not head or not head.next:\r\n        #     return None\r\n\r\n        slow = head\r\n        fast = head\r\n        # 寻找交点\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n                \r\n        # 无环\r\n        # print(fast, fast.next)\r\n        if not fast or not fast.next:\r\n            return None\r\n        \r\n        #有环\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\n# c++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode* fast=head,*slow=head;\r\n\r\n        while(fast!=NULL){\r\n            slow=slow->next;\r\n            if(fast->next==NULL)\r\n                return NULL;\r\n            fast=fast->next->next;\r\n            if(slow==fast){\r\n                slow=head;\r\n                while(slow!=fast)\r\n                {\r\n                    slow=slow->next;\r\n                    fast=fast->next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return NULL;\r\n        \r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\nFrom : https://github.com/dahaiyidi/awsome-leetcode","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000356319","body":"## Problem\r\n\r\n#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n++\r\n\r\n运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU) 。\r\n\r\n实现 `LRUCache` 类：\r\n\r\n- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存\r\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。\r\n- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\r\n\r\n**进阶**：你是否可以在 `O(1)` 时间复杂度内完成这两种操作？\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 哈希表 + 双向链表\r\n- 使用self.head 和self.tail 简化判断\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：1\r\n- 空间O：capacity\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\n# 在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，减少判断\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            self.moveToHead(node)\r\n            return node.value\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        # 若在cache中\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n\r\n        # 若不在cache中\r\n        else:\r\n            node =  DLinkedNode(key, value)\r\n            # 添加到head.next\r\n            self.addToHead(node)\r\n\r\n            # 更新cache\r\n            self.cache[key] = node\r\n\r\n            # 满了，要删除tial.prev\r\n            if self.size > self.capacity: \r\n                self.cache.pop(self.tail.prev.key)\r\n                self.remove(self.tail.prev)\r\n                \r\n\r\n    def addToHead(self, node):\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        node.prev = self.head\r\n        self.head.next = node\r\n        self.size += 1\r\n        \r\n    def remove(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        self.size -= 1\r\n        return \r\n\r\n    def moveToHead(self, node):\r\n        self.remove(node)\r\n        self.addToHead(node)\r\n\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nstruct DLinkedNode{\r\n    int key,value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode():key(0),value(0),prev(NULL),next(NULL){}\r\n    DLinkedNode(int _key,int _value):key(_key),value(_value),prev(NULL),next(NULL){}\r\n};\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode *> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\npublic:\r\n    LRUCache(int _capacity):capacity(_capacity),size(0) {\r\n        head=new DLinkedNode();\r\n        tail=new DLinkedNode();\r\n        head->next=tail;\r\n        tail->prev=head;\r\n    }\r\n    int get(int key){\r\n        if(!cache.count(key)){\r\n            return -1;\r\n        }\r\n        DLinkedNode* node=cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(!cache.count(key)){\r\n            //key 不存在，需创建新的节点\r\n            DLinkedNode* node=new DLinkedNode(key,value);\r\n            cache[key]=node;\r\n            addToHead(node);\r\n            size++;\r\n            if(size>capacity){// 超出容量，删除tail节点\r\n                DLinkedNode* removed =removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                size--;\r\n            }\r\n        }\r\n        else{//key 存在则刷新\r\n            DLinkedNode * node=cache[key];\r\n            node->value=value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n    void addToHead(DLinkedNode* node){\r\n        node->prev=head;\r\n        node->next=head->next;\r\n        node->next->prev=node;\r\n        head->next=node;\r\n    }\r\n    void removeNode(DLinkedNode* node){\r\n        node->prev->next=node->next;\r\n        node->next->prev=node->prev;\r\n    }\r\n    void moveToHead(DLinkedNode*node){\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n    DLinkedNode* removeTail(){\r\n        DLinkedNode* node=tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\nFrom : https://github.com/dahaiyidi/awsome-leetcode","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000861138","body":"## Problem\r\n\r\n#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\r\n\r\n\r\n\r\n给定一个二叉树，找出其最大深度。\r\n\r\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\r\n\r\n**说明:** 叶子节点是指没有子节点的节点。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 递归\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：height 树的高度\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        l = self.maxDepth(root.left)\r\n        r = self.maxDepth(root.right)\r\n        return max(l, r) + 1\r\n```\r\n\r\n### C++\r\n\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root){\r\n            return 0;\r\n        }\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\nFrom : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000980191","body":"## Problem\r\n\r\n#### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\r\n\r\n\r\n\r\n给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。\r\n\r\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 普通递归\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：min(m,n)\r\n- 空间O：min(m,n)\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n\r\n        if not p and not q:\r\n            # 若都为none\r\n            return True\r\n\r\n        if not p or not q:\r\n            # 若只有一个为none\r\n            return False\r\n        \r\n        if p and q:\r\n            # 若两者都不为none\r\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(!p && !q){\r\n            return true;\r\n        }\r\n        if(!p || !q){\r\n            return false;\r\n        }\r\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\nFrom : https://github.com/dahaiyidi/awsome-leetcode","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuzekuan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991849933","body":"思路\n1 定义常量n，同时遍历两个数组，从末尾开始遍历，条件是两个指针的索引同时大于等于0， 将对应索引上的值相加再加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n\n2 1的循环跳出，说明此时其中一个数组已经到头了，遍历当前索引大于0的数组，将当前的索引的值 加上n 添加到集合，剩下的值依次加入到集合，循环结束，输出结果。 3.最后一个输出的数若取整为1要进一位。\n\n关键点\n循环的条件，取模，取整 集合容器的选取：方便从头部插入数据的集合，链表 边界问题：最后一个输出的数若取整为1要进一位\n\n代码\n语言支持：Java\nJava Code:\n\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //选取Linked集合从头部插入数据\n        LinkedList<Integer> linkedList =new LinkedList<>();\n        //定义常量n,记整除结果\n        String kStr=\"\"+k;\n        int n=0;\n        int i=num.length-1;\n        int j=kStr.length()-1;\n        while(i>=0&&j>=0){\n            int temp=num[i]+Integer.valueOf(\"\"+kStr.charAt(j));\n            //将对应索引上的值相加再加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n            linkedList.addFirst((temp+n)%10);\n            n=(temp+n)/10;\n            i--;\n            j--;\n        }\n        //说明k已经遍历完，单独遍历剩下的数据\n        while(i>=0){\n            //将对应索引上的值加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n            linkedList.addFirst((num[i]+n)%10);\n            n=(num[i]+n)/10;\n            i--;\n        }\n        //说明num已经遍历完，单独遍历剩下的数据\n        while(j>=0){\n            //将对应索引上的值加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n            linkedList.addFirst((Integer.valueOf(\"\"+kStr.charAt(j))+n)%10);\n            n=(Integer.valueOf(\"\"+kStr.charAt(j))+n)/10;\n            j--;\n        }\n        //边界问题，最后一个存在数值进1\n        if(n==1){\n            linkedList.addFirst(1);\n        }\n        return linkedList;\n    }\n}\n\n复杂度分析\n\n令 n 为数组长度。\n\n时间复杂度：O(n)  n为两个数组中较长的长度\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997155527","body":"## 思路\n可以使用两个指针去遍历链表，先将第一个指针 b 移动K步，再将第二个指针 preK 从链表开头进行遍历。当 b.next 为空时，指针 b 就是倒数第一个节点，指针 preK 就是第 K-1 个节点。\n\n如果k的长度大于链表长度，那么可以在第一次移动指针 b 时计算链表长度。当 b 指针移动k步时，如果K的长度大于链表节点的话，那么 b 指针就会为 null，也就计算出了链表长度 n 的值，然后将 k mod n 重新计算 b 指针的位置。\n## 关键点\n双指针 \n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        int n = 0 ;\n        ListNode b = head ;\n        while(n < k && b != null){\n            b = b.next ;\n            n ++ ;\n        }\n        if(n == 0) return head ;\n        // 如果b为 null，那么k大于节点长度，重新计算。\n        if(b == null){\n            k %= n ;\n            if(k == 0) return head;\n            for(b = head,n = 0;n < k;n ++){\n                b = b.next ;\n            }\n        }\n        ListNode kPre = head ;\n        while(b.next != null){\n            b = b.next ;\n            kPre = kPre.next ;\n        }\t\n        // 将第 k-1 个后面的节点移动到 head 前。\n        ListNode kNode = kPre.next ;\n        kPre.next = null ;\n        b.next = head ;\n        return kNode ;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999611457","body":"## 思路\n遍历链表，把每个链表节点都存入list中，同时每存入一个节点就判断一次list中是否存在该节点，如果存在就返回该节点\n如果链表遍历结束也没有存入相同的节点，就返回null\n## 关键点\n双指针\n-  \n\n## 代码\n\n- 语言支持：java\n\njava Code:\n\n```java\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        List<ListNode> list = new LinkedList<>();\n        ListNode node = null;\n        while(head != null) {\n        if(list.contains(head)) {\n            node = head;\n            break;\n        }\n        list.add(head);\n        head = head.next;\n        }\n        return node;\n    }\n}\n\n```\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alfie100":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850071","body":"\n### 最低位相加模拟\n\n#### 思路\n模拟加法：A + k\n\n`当前位 = （A的当前位 + k） % 10`\n\n`当前位的进位 = （A的当前位 + k） // 10`\n\n这样可将 k 整体看作为进位，省略了变量carry\n\n#### 代码[Python]\n```Python []\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        res = []\n        while num or k:     # 若num未遍历完，【或】k未遍历完（k>0）\n            x = (num.pop() if num else 0) + k   # 若num未遍历完，pop一下；否则，设为0\n            k = x // 10\n            res.append(x%10)\n        \n        return res[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：$O(\\max(n, \\log k))$，其中 $n$ 为数组长度。\n- 空间复杂度：$O(\\max(n, \\log k))$，其中 $n$ 为数组长度。开辟了新的存储空间。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991929448","body":"### 正向遍历 + 反向遍历\r\nLeetCode 原题连接：[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n### 思路\r\n对于每个字符 s[i] 找出其距离左边及右边下一个目标字符 C 的距离，左右距离中的较小值即为答案。\r\n\r\n`从左往右遍历：`\r\n假设上一个 C 出现的位置为 pre，则当前 i 位置的字符距离 $C$ 的距离为 i-pre （pre <= i）；\r\n\r\n`从右往左遍历：`\r\n假设上一个 C 出现的位置为 pre，则当前 i 位置的字符距离 C 的距离为 pre-i （i <= pre）；\r\n\r\n\r\n### 代码 【Python】\r\n\r\n```python []\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        n = len(s)\r\n        ans = []\r\n\r\n        # 正序遍历\r\n        pre = -n    # 设为较小的 -n 即可（距离的最大值不可能超过n）\r\n        for (i, ch) in enumerate(s):\r\n            if ch == c:\r\n                pre = i\r\n            ans.append(i-pre)\r\n\r\n        # 逆序遍历\r\n        pre = 2*n   # 设为较大的 2*n 即可（距离的最大值不可能超过n）\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pre = i\r\n            ans[i] = min(ans[i], pre-i)\r\n        \r\n        return ans\r\n\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)，其中 n 为字符 s 长度。\r\n\r\n- 空间复杂度：O(n)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992623543","body":"【Python】**直接模拟 ：**\r\n\r\n```Python []\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) >= 1:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(k)，其中 k 为增量函数 inc(int k, int val) 中的元素个数 k 。\r\n- 空间复杂度：O(maxSize), 其中 maxSize 为栈中最多能容纳的元素数量。\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994499816","body":"### 辅助栈\r\nLeetCode题目连接：[https://leetcode-cn.com/problems/decode-string/](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n### Python代码\r\n\r\n【简洁版】：\r\n```Python []\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = ''\r\n        for ch in s:\r\n            # if '0' <= ch <= '9':\r\n            if ch.isdigit():    # 0-9 【可能不止一位，需累计】\r\n                num = 10*num + int(ch)\r\n            elif ch == '[':     # 遇到左括号，入栈 (str, int) - 之前的字符串和括号外的数字\r\n                stack.append((res, num))\r\n                num = 0\r\n                res = ''\r\n            elif ch == ']':     # 遇到右括号，出栈 (str, int)\r\n                last_res, cur_num = stack.pop()\r\n                res = last_res + cur_num*res    # 之前的字符 + 当前字符*当前倍数\r\n            else:   # 有效字符，如is alpha\r\n                res += ch\r\n        \r\n        return res\r\n```\r\n\r\n【易理解版】：\r\n```Python []\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        \r\n        for ch in s:\r\n            if ch != ']':   # 非右括号]，入栈\r\n                stack.append(ch)\r\n\r\n            else:\r\n                sub = ''\r\n                while stack[-1] != '[': # 出栈，直至遇到'['\r\n                    sub = stack.pop() + sub\r\n                \r\n                stack.pop()     # '['出栈\r\n\r\n                # 计算 [ 前面的数字倍数\r\n                num = ''\r\n                while stack and '0'<=stack[-1]<='9':\r\n                    num = stack.pop() + num\r\n                num = int(num)\r\n\r\n                # 入栈当前计算得到字符串，如 2[bc] -> bcbc\r\n                stack.append(num * sub)\r\n        \r\n        return ''.join(stack)\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n  为字符长度。\r\n- 空间复杂度：O(n)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995002078","body":"### 直接模拟\r\n\r\n#### Python代码：\r\n```python []\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop()) \r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop()) \r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.s1 or self.s2:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)。\r\n- 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996031258","body":"## 【Python双解】\r\n**LeetCode题目连接：**[https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n\r\n\r\n### 1. 单调栈\r\n可采用单调栈（单调不减），其中单调栈中的每一个元素代表每一块中的最大值。\r\n\r\n### Python代码\r\n\r\n```Python []\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \r\n        stack = [arr[0]]\r\n        for num in arr[1:]:\r\n            \r\n            if num >= stack[-1]:    # 大于栈顶【栈中的最大值】\r\n                stack.append(num)\r\n            else:                   # 小于栈顶\r\n                cur_ma = stack.pop()    # 记录下栈顶\r\n                while stack and num < stack[-1]:    # 移除栈中大于当前值num的所有元素\r\n                    stack.pop()\r\n                stack.append(cur_ma)    # 栈顶复位\r\n        \r\n        return len(stack)\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：$O(n)$，其中 $n$ 为数组 $arr$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n\r\n\r\n\r\n\r\n\r\n### 2. 排序 + 前缀和\r\n\r\n`arr`元素存在重复，简单的排序计数不可行。\r\n为排除重复元素的干扰，可采用`前缀和` 等方法排除重复项的干扰。\r\n\r\n### Python代码\r\n\r\n```Python []\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n                \r\n        prex, prey = 0, 0\r\n        ans = 0\r\n        for (x, y) in zip( arr, sorted(arr) ):  # '未排序' 与 '排序后' 的比较\r\n            prex += x\r\n            prey += y\r\n            if prex == prey:    # 前缀和与排序后的相等，独立成块数目+1\r\n                ans += 1\r\n        \r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：$O(n \\log n)$，涉及到排序，其中 $n$ 为数组 $arr$ 的长度。\r\n- 空间复杂度：$O(n)$。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997212199","body":"### 遍历链表\r\n\r\n### Python 代码\r\n\r\n```Python []\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or k==0:\r\n            return head\r\n\r\n        cur = head\r\n        n = 1\r\n        while cur.next:     # 遍历链表，计算链表总长度n\r\n            n += 1\r\n            cur = cur.next\r\n        \r\n        k = k % n           # 计算模长【k可能大于n】\r\n        if k == 0:\r\n            return head\r\n\r\n        cur.next = head     # end -> head 【成环】\r\n\r\n        cnt = n-1-k\r\n        cur = head\r\n        while cnt:          # 遍历从head开始的前n-k项\r\n            cnt -= 1\r\n            cur = cur.next\r\n        \r\n        # print(cur.val)\r\n        res = cur.next\r\n        cur.next = None     # 从head开始的第n-k项断开\r\n\r\n        return res\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997408987","body":"### 遍历链表\r\n\r\n### Python 代码【迭代】\r\n\r\n```Python []\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n\r\n        dummy_head = ListNode(0, head)\r\n        tmp = dummy_head\r\n        while tmp.next and tmp.next.next:\r\n            first = tmp.next\r\n            second = tmp.next.next\r\n\r\n            first.next = second.next\r\n            second.next = first\r\n            tmp.next = second\r\n\r\n            tmp = first\r\n        \r\n        return dummy_head.next\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998039601","body":"\r\n### 遍历+分治\r\n\r\n### Python 代码\r\n\r\n\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        \r\n        # 快慢指针得到中位节点ListNode\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        # 根据左右节点建立树\r\n        def BuildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)    # mid为 ListNode 类型，需要转化为 TreeNode 类型\r\n            root = TreeNode(mid.val)\r\n            root.left = BuildTree(left, mid)\r\n            root.right = BuildTree(mid.next, right)\r\n            return root\r\n        \r\n        return BuildTree(head, None)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998896906","body":"### 双指针遍历\r\n\r\n\r\n### Python 代码\r\n\r\n```Python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n\r\n        if not headA or not headB:\r\n            return headA == headB\r\n        \r\n        head1 = headA\r\n        head2 = headB\r\n        while head1 != head2:\r\n            head1 = head1.next if head1 else headB\r\n            head2 = head2.next if head2 else headA\r\n        \r\n        return head1\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(m+n)。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999307672","body":"### LeetCode题目连接：\r\n[https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n\r\n\r\n\r\n### 思路 \r\n**双指针**\r\n使用快慢指针 fast 与 slow，其中 slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针将与 slow 指针在环中相遇。\r\n\r\n待 fast 与 slow 相遇时，同时设置另一个从 head 开始的指针 start，随后 start 与 slow 每次向后移动一个位置，最终 start 和 slow 将在入环处相遇。\r\n\r\n![leetcode|100](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\r\n\r\n\r\n### Python 代码\r\n\r\n```Python []\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n\r\n        fast, slow = head, head\r\n        while True:\r\n            if not fast or not fast.next:\r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n        \r\n        start = head\r\n        while slow != start:\r\n            start = start.next\r\n            slow = slow.next\r\n        return slow\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n 为链表长度。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000389223","body":"**LeetCode题目连接：** 146. LRU 缓存机制 [https://leetcode-cn.com/problems/lru-cache/](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n\r\n\r\n\r\n### 思路\r\n**哈希表+双向链表**\r\n根据 key 在哈希表中存储其对应的链表格式\r\n\r\n### Python 代码\r\n\r\n```Python []\r\n\r\nclass listNode:\r\n    def __init__(self, key=0, val=0):\r\n        self.key = key\r\n        self.val = val\r\n        self.pre = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.hashmap = dict()\r\n        self.head = listNode()\r\n        self.tail = listNode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n\r\n    def _removeNode(self, node):\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n    \r\n    def _addToHead(self, node):\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n\r\n    def _moveToHead(self, node):\r\n        self._removeNode(node)\r\n        self._addToHead(node)\r\n    \r\n\r\n    def get(self, key: int) -> int:\r\n        if not key in self.hashmap:\r\n            return -1\r\n        node = self.hashmap[key]\r\n        self._moveToHead(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.hashmap:\r\n            node = listNode(key, value)\r\n            self.hashmap[key] = node\r\n            self._addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed_node = self.tail.pre\r\n                self._removeNode(removed_node)\r\n                self.hashmap.pop(removed_node.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.hashmap[key]\r\n            node.val = value\r\n            self._moveToHead(node)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(capacity)。\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000399498","body":"\r\n**LeetCode题目连接：** 104. 二叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree//)\r\n\r\n\r\n\r\n\r\n### 思路\r\nDFS：深度优先搜索\r\nBFS：广度优先搜索 【层序遍历】\r\n\r\n### Python 代码\r\n\r\n\r\n(1) DFS：\r\n```Python []\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n\r\n        def dfs(root):\r\n            if not root:\r\n                return 0\r\n            return max(dfs(root.left), dfs(root.right)) + 1\r\n        \r\n        return dfs(root)\r\n```\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)。\r\n- 空间复杂度：O(h)，其中 h 为二叉树的高度。\r\n\r\n<br>\r\n\r\n(2) BFS：\r\n```Python []\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if not root:\r\n            return 0\r\n        deque = collections.deque([root])\r\n        depth = 0\r\n        while deque:\r\n            for _ in range(len(deque)):\r\n                node = deque.popleft()\r\n                if node.left:\r\n                    deque.append(node.left)\r\n                if node.right:\r\n                    deque.append(node.right)\r\n            depth += 1\r\n        \r\n        return depth\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)。\r\n- 空间复杂度：O(n)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000997341","body":"**LeetCode题目连接：** 100. 相同的树 [https://leetcode-cn.com/problems/same-tree/](https://leetcode-cn.com/problems/same-tree/submissions/)\r\n\r\n\r\n\r\n\r\n### 思路\r\nDFS：深度优先搜索\r\nBFS：广度优先搜索 【层序遍历】\r\n\r\n### Python 代码\r\n\r\n\r\n(1) DFS：\r\n```Python []\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        \r\n        def dfs(node1, node2):\r\n            if not node1 and not node2:\r\n                return True\r\n            elif not node1 or not node2:\r\n                return False\r\n            \r\n            if node1.val != node2.val:\r\n                return False\r\n            \r\n            return dfs(node1.left, node2.left) and dfs(node1.right, node2.right)\r\n        \r\n        return dfs(p, q)\r\n```\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(m, n))，其中 m 和 n 分别为两个二叉树的节点数。\r\n- 空间复杂度：O(min(m, n))。\r\n\r\n<br>\r\n\r\n(2) BFS：\r\n```Python []\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n\r\n        deque = collections.deque([(p, q)])\r\n        while deque:\r\n            node1, node2 = deque.popleft()\r\n            \r\n            if not node1 and not node2:\r\n                continue\r\n            elif not node1 or not node2:\r\n                return False\r\n            \r\n            if node1.val != node2.val:\r\n                return False\r\n            \r\n            deque.append((node1.left, node2.left))\r\n            deque.append((node1.right, node2.right))\r\n        \r\n        return True\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(m, n))，其中 m 和 n 分别为两个二叉树的节点数。\r\n- 空间复杂度：O(min(m, n))。\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryan0218":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850174","body":"class Solution {\n\npublic List addToArrayForm(int[] num, int k)\n {\n\nList res = new ArrayList();\n\nint n = num.length;\n\nfor (int i = n-1; i >= 0; --i)\n{\n\nint sum = num[i] + k % 10;\n\nk /= 10;\n\nif (sum >= 10)\n{\n\nk ++;\n\nsum -= 10;\n}\n\nres.add(sum);\n}\n\n\nfor (; k > 0; k /= 10)\n{\n\nres.add(k % 10);\n}\n\nCollections.reverse(res);\n\nreturn res;\n}\n}\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997329012","body":"class Solution {\n\n   public ListNode swapPairs(ListNode head)\n\n {\n      \n   if(head == null || head.next == null)\n          \n   return head;\n       \n  ListNode newHead = head.next;\n    \n   head.next = swapPairs(head.next.next);\n      \n   newHead.next = head;\n        \n return newHead;\n  \n   }\n\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wodong0012":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850483","body":"判断k是否倒序遍历数组，在与k % 10 相加 之后在将k /10 ， 在判断结果>10 ，++k并且将结果-10，在存入数组中\n同时k的位数会大于数组长度，需要加一个循环插入大于的数据\n\n```c++\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> results = vector<int>();\n        int listSize = num.size();\n        int temp;\n        for (int i = listSize - 1; i >= 0; i--)\n        {\n            if (k != 0)\n            {\n                temp = num[i] + k % 10;\n                k /= 10;\n                if (temp >= 10)\n                {\n                    ++k; // 进位\n                    temp -= 10;\n                }\n            }\n            else\n            {\n                temp = num[i];\n            }\n            results.push_back(temp);\n        }\n        while (k > 0)\n        {\n            results.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(results.begin(), results.end());\n\n        return results; \n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992559080","body":"先获取到每一个e的位置。并保存到数组中。\n再次遍历字符串，进入循环后拿到当前位置的位置，在判断位置集合是否只有1个数量，有就直接添加到结果集合中。\n没有就比较大小存入结果集合中。\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> cI = vector<int>();\n        vector<int> outRes = vector<int>();\n\n        for (int i = 0; i < s.length(); ++i)\n        {\n            if (s[i] == c)\n            {\n                cI.push_back(i);\n            }\n        }\n        int index = 0;\n        for (size_t i = 0; i < s.length(); ++i)\n        {\n            int oneNum = cI[0] - i;\n            oneNum = abs(oneNum);\n            if (cI.size() == 1)\n            {\n                outRes.push_back(oneNum);\n                continue;\n            }\n            \n            int twoNum = cI[1] - i;\n            twoNum = abs(twoNum);\n            if (oneNum <= twoNum)\n                outRes.push_back(oneNum);\n            else\n                outRes.push_back(twoNum);\n\n\n            if (i > cI[0] && i >= cI[1]) // 不会抛越界异常\n            {\n                cI.erase(cI.begin());\n            }\n        }\n\n        return outRes;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993579527","body":"实现方式有很多，可以是数组也可以是 其他集合，这里采用集合实现\n\n```c++\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : index(-1)\n    {\n        stack.resize(maxSize);\n    }\n\n    void push(int x)\n    {\n        if (index != stack.size() - 1)\n        {\n            ++index;\n            stack[index] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (index >= 0)\n        {\n            int num = stack[index];\n            index--;\n            return num;\n        }\n        return -1;\n    }\n\n    void increment(int k, int val)\n    {\n        for (size_t i = 0; i < k; ++i)\n        {\n            if (stack.size() <= k && stack.size() == i)\n            {\n                break;\n            }\n\n            stack[i] = stack[i] + val;\n        }\n    }\n\nprivate:\n    vector<int> stack;\n    int index;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994894036","body":"使用数字一个栈，字母一个栈来解题\n\n```c++\n\nclass Solution {\npublic:\n    string src; \n    size_t ptr;\n\n    /**\n     * @brief Get the Digits object\n     * \n     * @return int \n     */\n    int getDigits() {\n        int ret = 0;\n        while (ptr < src.size() && isdigit(src[ptr])) {\n            // 每次都乘以10 ， 在加上下一个数组，也就是数字栈。\n            ret = ret * 10 + src[ptr++] - '0';\n        }\n        return ret;\n    }\n\n    string getString() {\n        if (ptr == src.size() || src[ptr] == ']') {\n            return \"\";\n        }\n\n        char cur = src[ptr]; int repTime = 1;\n        string ret;\n\n        if (isdigit(cur)) {\n            // String -> Digits [ String ] String\n            // 解析 Digits\n            repTime = getDigits(); \n            // 是数字就过滤左括号\n            ++ptr;\n            // 解析 String ， 内部还有[] 还是会回到getString中\n            string str = getString(); \n            // 解析完字符串后一定要过滤右括号\n            ++ptr;\n            // 构造字符串\n            while (repTime--) ret += str; \n        } else if (isalpha(cur)) {\n            // String -> Char String\n            // 解析 Char\n            ret = string(1, src[ptr++]);\n        }\n        \n        return ret + getString();\n    }\n\n    string decodeString(string s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995788662","body":"创建两个栈，一个输入站和一个输出栈，用输入住栈控制 `push`操作，输出栈控制 `pop`和`peek`操作。\n1. 当`push`操作时，将数据存入输入站。\n2. 当`pop`时 ，如果输出栈为空，将输入栈的所有数据依次弹栈并压入输出栈中。然后在访问输出栈数据并弹栈。\n3. 当`peek`时，也是一样判断输出栈是否为空，为空压栈操作。在弹出输出栈数据。\n4. 当`empt`时，判断两个栈是否为空即可。\n\n```c++\n\nclass MyQueue {\nprivate:\n    stack<int> inStack;\n    stack<int> outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            // 将输入栈的元素存到输出栈中\n            outStack.push(inStack.top());\n            // 输入站的元素弹栈\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    // 弹栈操作\n    int pop() {\n        // 如果输出栈为空，就将 输入站中的数据 从栈顶依次压入输出栈， 这样就倒序了。\n        if (outStack.empty()) {\n            in2out();\n        }\n        int num = outStack.top(); // 访问栈顶元素\n        outStack.pop(); // 将输出栈元素弹出\n        return num;\n    }\n\n    int peek() {\n        // 如果输出栈为空，就将 输入站中的数据 从栈顶依次压入输出栈， 这样就倒序了。\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top(); // 访问栈顶元素\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996720285","body":"前块max <= 后块min\n\t - 正向 维护前一块最大值 当一旦最大值 > cur 向前合并块，直到最大值 <= cur\n\t - 要存每个块的maxNum ， 向前操作用stk处理\n\n```c++\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997369612","body":"        使用递归实现：每次都将第三个节点传入进去\n        重要的点在于第一个判断是否为空\n```c++\n\nclass Solution {\npublic:\n    ListNode *swapPairs(ListNode *head)\n    {\n        if (nullptr == head || nullptr == head->next)\n            return head;\n\n        // 交换节点\n        // 拿到第二个节点\n        ListNode *newHead = head->next;\n\n        // 在将第三个节点传进去\n        head->next = swapPairs(newHead->next);\n        // 改变第二个节点的指向 于 第一个节点\n        newHead->next = head;\n\n        return newHead;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997878079","body":"     找中位数，使用快慢指针实现，快指针走两步，慢指针走一步\n     直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。\n\n```c++\n\nclass Solution {\npublic:\n\n    /**\n     * 找中位数，使用快慢指针实现，快指针走两步，慢指针走一步\n     * 直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。\n     * @param left\n     * @param right\n     * @return\n     */\n    ListNode *getMedian(ListNode *left, ListNode *right) {\n        ListNode *fast = left;  // 1  -> 2\n        ListNode *slow = left;  // 1  -> 2\n        while (fast != right && fast->next != right) {\n            fast = fast->next->next;\n            slow = slow->next;  // 2  中位数\n        }\n        return slow;\n    }\n\n    TreeNode *buildTree(ListNode *left, ListNode *right) {\n        if (left == right) {\n            return nullptr;\n        }\n\n        // 查找中位数结点\n        ListNode *mid = getMedian(left, right);\n        // 构建跟结点\n        TreeNode *root = new TreeNode(mid->val);\n        // 构建左节点\n        root->left = buildTree(left, mid);\n        // 构建右节点\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode * sortedListToBST(ListNode *head) {\n        return buildTree(head, nullptr);\n    }\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999586818","body":"使用一个set集合保存遍历过的节点，如果包含节点说明有环。\n\n```c++\n\nListNode *detectCycle(ListNode *head)\n    {\n        if (nullptr == head || nullptr == head->next)\n        {\n            return nullptr;\n        }\n\n        ListNode *newHead = head;\n        int index = 0;\n\n        unordered_set<ListNode *> visited;\n        while (head != nullptr)\n        {\n            if (visited.count(head))\n            {\n                return head;\n            }\n            visited.insert(head);\n            head = head->next;\n        }\n        return nullptr;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000349793","body":"使用双向链表+HashMap实现，链表设置头尾节点，\nget：查找key是否存在，Y：返回节点，并将节点移动到头部。\nput：查找key是否存在，Y：移动节点到头部。 容量超出则删除尾部节点。\n不用看我，我只是学习官方题解来打卡了而已。\n\n```c++\n\n\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000867063","body":"使用递归调用，在左右两个节点中获取最大的值在加上当前节点，就获得结果\n\n```c++\n\n\nclass Solution {\npublic:\n\n\n    int maxDepth(TreeNode* root) {\n        if(nullptr == root) return 0;\n        return max(maxDepth(root->left) , maxDepth(root->right))+1;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001012978","body":"    解题思路：\n        先判断 p是否为空。 Y：在判断q是否为空。\n                        N：一样判断q是否为空\n        在对比两者的值是否相同，Y：递归再次调用左右两个节点。\n        最终返回就是结果\n\n\n```c++\n\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(nullptr == p){\n            if( nullptr == q){\n                return true;\n            }else{\n                return false;            \n             }\n        }else{\n            if(nullptr == q){\n                return false;\n            }\n        }\n\n        if(p->val == q->val){\n            return isSameTree(p->left , q->left)  && isSameTree(p->right , q->right) ;\n        }else{\n            return false;\n        }\n    }\n};\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junbuer":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991851273","body":"思路\n\n逐位相加，每次记录进位carry，直到k和num的每一位数都处理完，最后反转结果数组\n\n代码\n\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            i = len(num) - 1\n            n = []\n            carry = 0\n            while k or (i >= 0) or carry:\n                if i >= 0:\n                    sum_ = num[i] + k % 10 + carry\n                else:\n                    sum_ = k % 10 + carry\n                n.append(sum_ % 10)\n                carry = sum_ // 10\n                k //= 10\n                i -= 1\n            n.reverse()\n            return n\n\n复杂度\n\n+ 时间复杂度 (max(n,  len(k)))\n+ 空间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992204112","body":"### 思路\n\n两次遍历取最小值：\n\n+ 正向遍历，计算当前字符与左边最近的字符c的距离\n+ 反向遍历，计算当前字符与右边最近的字符c的距离\n\n最后输出两次遍历的距离的最小值\n\n### 代码\n```python\n    class Solution(object):\n        def shortestToChar(self, s, c):\n            \"\"\"\n            :type s: str\n            :type c: str\n            :rtype: List[int]\n            \"\"\"\n            pre = float('-inf')\n            dis = []\n            for i in range(len(s)):\n                if s[i] == c: \n                    pre = i\n                dis.append(i - pre)\n            pre = float('inf')\n            for i in range(len(s) - 1, -1, -1):\n                if s[i] == c:\n                    pre = i\n                dis[i] = min(dis[i], pre - i)\n            return dis\n```\n### 复杂度分析\n\n+ 时间复杂度：O(n)， 两次遍历\n+ 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993270558","body":"### 思路\n\n使用数组模拟，将数组的末尾作为栈顶\n\n### 代码\n\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.Stack = [] \n        self.maxSize =maxSize\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.Stack) < self.maxSize:\n            self.Stack.append(x)\n        \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.Stack):\n            return self.Stack.pop()\n        else:\n            return -1\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, len(self.Stack))):\n            self.Stack[i] += val\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：push和pop为O(1)，increment为O(k)\n+ 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994696271","body":"### 思路\n\n+ 如果为数字则更新重复次数d\n+ 如果为字母则更新字符串string\n+ 如果为'['则入栈\n+ 如果为']'则出栈，并将栈顶的字符串添加到string\n\n### 代码\n```python\n    class Solution(object):\n        def decodeString(self, s):\n            \"\"\"\n            :type s: str\n            :rtype: str\n            \"\"\"\n            stk = []\n            string = \"\"\n            d= 0\n            for c in s:\n                if c.isdigit():\n                    d = d * 10 + int(c)\n                elif c.isalpha():\n                    string += c\n                elif c == '[':\n                    stk.append([d, string])\n                    d, string = 0, \"\"\n                else:\n                    cur_d, last_str = stk.pop()\n                    string = last_str + cur_d * string\n            return string \n  ```                                 \n### 复杂度分析\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995619512","body":"### 思路\n\n定义两个栈`in`和`out`。`in`在进队时压栈；`out`在需要出队将`in`的内容出栈并压入`out`，然后`out`出栈\n\n### 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = []\n        self.top = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stk1.append(x)\n          \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stk2) == 0:\n            while len(self.stk1):\n                self.stk2.append(self.stk1.pop())\n        return self.stk2.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stk2):\n            return self.stk2[-1]\n        return self.stk1[0]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stk1) or len(self.stk2):\n            return False\n        else:\n            return True\n```\n\n### 复杂度分析\n\n+ 时间复杂度：`push`，`pop`，`peek` ，`empty`都为O(1)；`pop`最好时为O(1)，最差为O(n)\n+ 空间复杂度： O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996584473","body":"思路\n\n+ 计数排序\n  + 两个数组的计数信息如果一致，那么两个数组的排序结果一致；\n\n  + 遍历排序后的arr_s和arr，比较当前阶段arr_s和arr的计数信息是否一致，如果一致表示可以在此处分块。\n\n\n代码\n\n+ 计数排序\n\n```python\n    class Solution(object):\n        def maxChunksToSorted(self, arr):\n            \"\"\"\n            :type arr: List[int]\n            :rtype: int\n            \"\"\"\n            count = collections.defaultdict(int) \n            bound = 0 \n            ans = 0\n            for x, y in zip(arr, sorted(arr)): \n                if count[x] == -1: \n                    bound -= 1 \n                if count[x] == 0: \n                    bound += 1 \n                count[x] += 1\n    \n                if count[y] == 1: \n                    bound -= 1 \n                if count[y] == 0: \n                    bound += 1 \n                count[y] -= 1\n    \n                if bound == 0: \n                    ans += 1\n            return ans\n\n```\n复杂度分析\n\n+ 时间复杂度：O(N*logN)\n\n+ 空间复杂度：O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997320509","body":"### 思路\n\n创建哑节点dummy，设置temp指针，初始指向dummy。将temp指针后的两个节点node1和node2交换，然后更新temp指针指向交换后的第二个节点即node1。直到temp后的任一节点为`NULL`\n\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        temp = dummy\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = node.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return dummy.next\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997871889","body":"### 思路\n\n+ 寻找链表的中位数节点，作为根节点\n+ 将中位数左边的节点作为左子树，右边的节点作为右子树\n\n### 代码\n```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n\n        def find_mid(left, right):\n            fast = slow = left\n            while fast !=right and fast.next !=right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def Tree(left, right):\n            if left == right:\n                return None\n            mid = find_mid(left, right)\n            root = TreeNode(mid.val)\n            root.left = Tree(left, mid) \n            root.right = Tree(mid.next, right) # 右半部分的中位数节点\n            return root\n        return Tree(head, None)          \n```\n### 复杂度分析\n\n+ 时间复杂度：O(N * log N)\n+ 空间复杂度：O(log N)，平衡二叉树的高度为 O(log N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998752021","body":"### 思路\n\n利用双指针\n\n定义`s1`和`s2`分别指向两个链表的头节点`headA`和 `headB`，`s1`遍历`headA`链表加`headB`链表，`s2`遍历`headB`链表加`headA`链表，当`s1 = s2`时返回`s1`。\n\n### 代码\n\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if headA == None or headB == None:\n            return None\n        s1 = headA\n        s2 = headB\n        while s1 != s2:\n            s1 = headB if (s1 == None) else s1.next\n            s2 = headA if (s2 == None) else s2.next\n        return s1\n```\n### 复杂度分析\n\n+ 空间复杂度：O(m + n)\n+ 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999631421","body":"### 思路\n\n遍历链表中的每个节点，并用哈希表记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。\n\n```python\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return None\n        curr = head\n        hashmap = defaultdict()\n        while curr.next:\n            if curr.next in hashmap:\n                return curr.next\n            else:\n                hashmap[curr] = curr.val\n                curr = curr.next\n        return None\n```\n### 复杂度分析\n\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000324671","body":"### 思路\n\n哈希表+双向链表\n\n### 代码\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict() \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        node.next.prev = node\n        self.head.next = node\n  \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n```\n### 复杂度分析\n+ 时间复杂度：O(1)\n+ 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000847640","body":"### 思路\n\n深度优先搜索\n\n### 代码\n\n```python\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        else:\n            r = self.maxDepth(root.right)\n            l = self.maxDepth(root.left)\n        return max(r, l) + 1\n        \n```\n### 复杂度分析\n\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000991180","body":"### 思路\n\n树的遍历\n\n+ 深度优先搜索DFS：递归实现\n+ 广度优先搜索BFS：队列实现\n### 代码\n```python\n# DFS\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)   \n\n# BFS\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        que1 = [q]\n        que2 = [p]\n        while que1 and que2:\n            node1 = que1.pop()\n            node2 = que2.pop()\n            if node1.val != node2.val:\n                return False\n            l1, r1 = node1.left, node1.right\n            l2, r2 = node2.left, node2.right\n            if (not l1) ^ (not l2) or (not r1) ^ (not r2):\n                return False\n            if l1:\n                que1.append(l1)\n            if r1:\n                que1.append(r1)\n            if l2:\n                que2.append(l2)\n            if r2:\n                que2.append(r2)\n        return not que1 and not que2\n```\n### 复杂度分析\n\n+ 时间复杂度：O(min(m,n))\n+ 空间复杂度：O(min(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lonkang":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991852775","body":"// 使用BigInt偷个懒\n```js\nvar addToArrayForm = function(A, K) {\n  let N = '';\n  A.forEach( e =>{\n    N = N+e\n  })\n\n  return String(BigInt(N) + BigInt(K)).split('').map(e => Number(e))\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992551403","body":"### 思路：\n参考官方题解算双向遍历\n\n### 代码：\n```js\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n\n    let l = i,\n      r = i,\n      tmp = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        tmp = Math.min(tmp, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        tmp = Math.min(tmp, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = tmp;\n  }\n  return res;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993335660","body":"### 思路：\njs的数组即是栈也是队列简直无敌；\n### 代码：\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\nif(this.list.length<this.maxSize) {\n    this.list.push(x)\n}\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.list.pop()\n    return res === null ? -1 : res;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n for (var i = 0; i < this.list.length; i++) {\n    if (i < k) {\n      this.list[i] += val;\n    }\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994632105","body":"### 思路：\n利用栈解题，注意字母前面的数字可能有多位\n\n遇到 \"数字\" 、\"[\"、\"字母\" 入栈（即不是右括号\"]\"的都入栈）\n\n遇到右括号\"]\"则出栈，一直出栈直到不等于左括\"[\"时停止出栈\n\n取出\"[ ]\"括号之间要的字符串str，然后取得数字，计算str重复次数后的字符串pushStr，然后pushStr再入栈\n\n最后把栈的元素拼接起来即可\n### 代码：\n\n```js\nvar decodeString = (str) => {\n  if (!str) {\n    return ''\n  }\n\n  let stack = []\n\n  // 存字母前的数字，可能有多位\n  let numstr = ''\n\n  for (let s of str) {\n    // 多位数字的处理\n    if (Number.isInteger(+s)) {\n      numstr += s\n      continue\n    }\n\n    if (numstr) {\n      stack.push(+numstr)\n      numstr = '' // 注意置空\n    }\n\n    // 不是右括号直接入栈\n    if (s != ']') {\n      stack.push(s)\n      continue\n    }\n\n    // 遇到右括号，需要出栈，直到不等于左括号\n    let str = ''\n    while (stack.length && stack.slice(-1) != '[') {\n      let top = stack.pop()\n      top += str\n      str = top\n    }\n\n    // 删掉左括号\n    stack.pop()\n\n    // 取得数字\n    let count = +stack.pop()\n\n    // 字符拼接对应的次数\n    let pushStr = str.repeat(count)\n\n    stack.push(pushStr)\n  }\n\n  return stack.join('')\n}\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998508072","body":"###  思路：使用hash表\r\n### 代码\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  const visited = new Set()\r\n  let temp = headA\r\n  while (temp !== null) {\r\n    visited.add(temp)\r\n    temp = temp.next\r\n  }\r\n  temp = headB\r\n  while (temp !== null) {\r\n    if (visited.has(temp)) {\r\n      return temp\r\n    }\r\n    temp = temp.next\r\n  }\r\n  return null\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000238125","body":"### 思路\r\n- 利用es6中的Map\r\n- 利用Map Iterator对象的next()取到第一个值进行删除\r\n### 代码\r\n```js\r\nclass LRUCache {\r\n  constructor(size) {\r\n    this.size = size\r\n    this.map = new Map()\r\n  }\r\n  get(key) {\r\n    if (this.map.get(key)) {\r\n      let temp = this.map.get(key)\r\n      this.map.delete(key)\r\n      this.map.set(key, temp)\r\n      return temp\r\n    }\r\n    return -1\r\n  }\r\n  put(key, value) {\r\n    if (this.map.has(key)) {\r\n      this.map.delete(key, value)\r\n    }\r\n    this.map.set(key, value)\r\n    if (this.map.size > this.size) {\r\n      this.map.delete(this.map.keys().next().value)\r\n    }\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000862520","body":"### 思路\r\n- 通过递归调用函数\r\n\r\n### 代码\r\n```js\r\nconst maxDepth = function(root) {\r\n    if(root===null) return 0 // 直到root为空就返回\r\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000997603","body":"### 思路：\r\n1.前端可以直接判断两个数组是否相同\r\n2.参考官解可以使用递归\r\n### 代码1\r\n```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    return JSON.stringify(p) === JSON.stringify(q)\r\n};\r\n```\r\n### 代码2：\r\n```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if(p === null && q === null) return true\r\n    if(p === null || q === null) return false // 不能一个为空一个不为空\r\n    if(p.val!==q.val){\r\n        return false;\r\n    }\r\n    return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wbcz":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991853411","body":"1.数组A转换成整数，\n2.A和K再求和\n3.每位数分开\n4.再生成新数组\n\nJavaScript:\n\nConst getNewSum =（A，K）=>{\n  return（Number（ A.join（，））+K).split（，）\n}\n\n时间复杂度  O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992619409","body":"时间换空间\n\nfunction shortDistance(S, C) {\n  let arrIndexs = []\n  let resNewArr = []\n  for(let i=0; i< S.length; i++) {\n    if(S[i] == C) {\n      arrIndexs.push(i)\n    }\n  }\n\n  for(let i=0; i< S.length; i++) {\n    if(S[i] == C) {\n      resNewArr[i] = 0\n    }\n    \n    for(const index of arrIndexs) {\n      resNewArr[i] = Math.abs(index -i)\n    } \n  }\n  return resNewArr\n}\n\n下标组成的数组长度为K, 字符串长度为N,时间复杂度O(K+N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993682060","body":"数组模拟栈，先定义一个数组栈，然后对数组实现pop和push方法即可，inc方法需要用到指定次数循环k次；\n\n时间复杂度，数组的pop和push方法，O(1)\nInc方法，k次循环，复杂度O（k）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995950900","body":"核心思路，通过两个栈来解决问题，通过循环保证push的元素是唯一的，所以每次pop和push都是栈底元素","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414130","body":"\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let res = head.next;\n  let now = head;\n  let preNode = new ListNode();\n  preNode.next = head;\n  while (now && now.next) {\n    let nextNode = now.next;\n    let nnNode = nextNode.next;\n    now.next = nnNode;\n    nextNode.next = now;\n    preNode.next = nextNode;\n    preNode = now;\n    now = nnNode;\n  }\n  return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997939280","body":"var sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999632512","body":"let data = new Set();\nwhile (head) {\n  if (data.has(head)) {\n    return head;\n  } else {\n    data.add(head);\n  }\n  head = head.next;\n}\nreturn null;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aakk474548":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991855322","body":"## 思路\n\n#### 这不就是数组转成字符串加完再转成数组吗？<br/>\n\n结论：大整数算不了。估计这就是题的意义之一，大整数如何存储和加减运算\n\n#### 两层循环，从后向前逐位比。<br/>\n\n结论：想想觉得蠢，应该不至于。\n\n#### 看题解看一半<br/>\n\n思路偷到了：从num的最后一位开始加，加完了个位存起来，突突突接着往前加。<br/>\n脑子： ‘我会了‘，手：’你会个屁‘。\n\n#### 遇到几个问题再看题解之后再来<br/>\n\n- 边界：边界是num的长度或k的长度，两者共同决定循环次数，也就是最终数组长度。k.length>num.length时，得把k一位一位补完，k.length<num.length时要把num一位一位补完。<br/>\n- k的变化：全程就是对k的相加、取值和算出下一个k。相加就是num遍历结束前，k每次要和num[i]相加。取值就是k相加完取出个位。下一个k就是 除10 取整。<br/>\n- 空间：能不能不多创建那个数组。好像不能，原数组操作，向数组头添加，会增加时间复杂度。<br/>\n- 提示：提示真有用啊。再看提示其实就明白了，1就是两个正经整数，2 按位加的时候你放心做加法，没想着在这再坑你一道。\n\n## 代码\n\n```javascript\nvar addToArrayForm = function(num, k) {\n    const n = num.length;\n    const res = []\n    for(let i = n - 1; i >=0 || k != 0; i--){\n        if(i >=0){\n        \t// 相加\n            k += num[i]            \n        }\n        // 取值\n        res.push(k % 10)\n        // 下一个k\n        k = Math.floor(k / 10)\n    }\n    res.reverse()\n    return res\n};\n```\n\n## 复杂度\n时间:   O(n) <br/>\n空间:   O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992523517","body":"## 思路\n\n#### 暴力解法\n1. 先遍历一遍，把所有的位置存放在一个数组arr中\n2. 遍历s，把每个i，都拿去和arr遍历比对，计算出最小值\n3. 将最小值存储在 res 数组中\n\n#### 正反双指针\n1. 遍历两次，先从左到右，再从右到做。\n2. 先声明一个最小的整数prev当作无穷小数。\n3. 从左向右循环，遇到c则将索引赋值给prev。结果数组res每次赋值为i - prev。不用考虑前几个没遇到c的情况，一会从右向左会处理的。题干也保证了一定有c。\n4. 再将prev设置为最大整数。\n5. 从右向左循环，遇到c则将索引赋值给prev。结果数组res每次赋值为，res[i]和 prev - i 的最小值。\n\n## 代码\n\n```javascript\n    var shortestToChar = function(s, c) {\n        const len = s.length;\n        //声明成最小安全数\n        let prev = -Number.MAX_SAFE_INTEGER;\n        // 结果\n        const res = []\n        // 从左向右\n        for(let i = 0; i < len; i++){\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n        // 此时结果大概为[-9999999999,-9999999999, 0,1,2,3,4]\n        //把prev设置为最大\n        prev = Number.MAX_SAFE_INTEGER;\n        // 从右向左\n         for(let i = len - 1; i >= 0; i--){\n\n            if (s.charAt(i) == c) prev = i;\n            // 取最小值\n            res[i] = Math.min(res[i], prev - i);\n        }\n        return res\n    };\n```\n\n## 复杂度\n时间复杂度: O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993461467","body":"## 思路\n没啥说的了，模拟一个栈的入栈出栈\n\n## 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    console.log('max' + maxSize)\n    this.maxSize = maxSize;\n    this.value = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.maxSize == this.value.length){\n        return \n    }else{\n        this.value.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.value.length == 0){\n        return -1\n    }else{\n        return this.value.pop()\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n\n    let len;\n    if(this.value.length < k){\n        len = this.value.length\n    }else{\n        len = k\n    }\n    for(let i = 0; i < len; i++){\n        this.value[i]+=val \n    }\n\n};\n```\n\n## 复杂度\n这哪有复杂度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994689916","body":"## 思路\n\n有括号匹配的都得用栈吧。通过入栈暂存，这样就可以处理多个嵌套括号得问题。\n\n## 代码\n\n```javascript\nvar decodeString = function(s) {\n     let mulStack = [], strStack = [], num = 0, res = ''\n    for (const c of s) {   \n        if (!isNaN(c)) {  \n             num = num * 10 + Number(c)\n        } else if (c == '[') {  \n            strStack.push(res)\n            mulStack.push(num) \n            res = '' \n            num = 0\n        } else if (c == ']') {  \n            res = strStack.pop() + res.repeat(mulStack.pop())\n        } else {                   \n            res += c\n        }\n    }\n    return res;\n};\n```\n\n## 复杂度\n时间: O(n)\n空间: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995754217","body":"## 思路\n\n双栈，一个入队栈，一个出队栈\n\n## 代码\n\n```javascript\nvar MyQueue = function() {\n    this.inArr = []\n    this.outArr = []\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inArr.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.outArr.length == 0){\n        this.in2out()\n    }\n    return this.outArr.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n     if(this.outArr.length == 0){\n        this.in2out()\n    }\n    return this.outArr[this.outArr.length - 1]\n};\n\n/**\n * @return {boolean}\n */\n\nMyQueue.prototype.empty = function() {\n    return this.inArr.length == 0 && this.outArr.length == 0\n};\nMyQueue.prototype.in2out = function() {\n    while(this.inArr.length){\n        this.outArr.push(this.inArr.pop())\n    }\n};\n```\n\n## 复杂度\n时间 O(1)\n空间 O (1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000323466","body":"## 代码\n```javascript\nclass ListNode {\n    constructor(key, value) {//双向链表的单个节点\n        this.key = key\n        this.value = value\n        this.next = null //指向后一个节点\n        this.prev = null //指向前一个节点\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity //容量\n        this.hashTable = {} //存放键值对信息\n        this.count = 0 //键值对数量\n        this.dummyHead = new ListNode() //dummy头节点 方便在链表从开始的地方插入\n        this.dummyTail = new ListNode()\t//dummy尾节点 方便在链表从末尾删除\n        this.dummyHead.next = this.dummyTail //dummyHead和dummyTail相互连接\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    get(key) {\n        let node = this.hashTable[key]//查找哈希表中的键值对\n        if (node == null) return -1 //不存在该键值对 返回-1\n        this.moveToHead(node) //移动到链表头\n        return node.value\n    }\n\n    put(key, value) {\n        let node = this.hashTable[key] //哈希表中查找该键值对\n        if (node == null) {\n            let newNode = new ListNode(key, value) //不存在就创建节点\n            this.hashTable[key] = newNode //加入哈希表\n            this.addToHead(newNode) //加入链表头\n            this.count++ //节点数+1\n            if (this.count > this.capacity) { //超过容量 从队尾删除一个\n                this.removeLRUItem()\n            }\n        } else {\n            node.value = value //键值对存在于哈希表中 就更新\n            this.moveToHead(node) //移动到队头\n        }\n    }\n\n    moveToHead(node) {\n        this.removeFromList(node)//从链表中删除节点\n        this.addToHead(node)//将该节点添加到链表头\n    }\n\n    removeFromList(node) {//删除的指针操作\n        let tempForPrev = node.prev\n        let tempForNext = node.next\n        tempForPrev.next = tempForNext\n        tempForNext.prev = tempForPrev\n    }\n\n    addToHead(node) {//加入链表头的指针操作\n        node.prev = this.dummyHead\n        node.next = this.dummyHead.next\n        this.dummyHead.next.prev = node\n        this.dummyHead.next = node\n    }\n\n    removeLRUItem() {\n        let tail = this.popTail()//从链表中删除\n        delete this.hashTable[tail.key]//从哈希表中删除\n        this.count--\n    }\n\n    popTail() {\n        let tailItem = this.dummyTail.prev//通过dummyTail拿到最后一个节点 然后删除\n        this.removeFromList(tailItem)\n        return tailItem\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wujunhong-max":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991855361","body":"## 思路\n1. 逐位相加，将数组的每一位和整数的每一位相加，若得到的数大于等于10，则进位\n2. 将得到的数放进新数组中，转置数组\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n\n    vector<int> num1;\n    int n= num.size();\n    for(int i = n-1; i>=0; i--)  // vector数组是从左往右的，num[0]是最左边的数\n    {\n        int sum = num[i]+k%10;  // 逐位相加\n        k /= 10;\n        if(sum>=10)\n        {\n            k++;\t\t\t// 进位加1\n        }\n        num1.push_back(sum%10);\n        sum = 0;\n    }\n    while(k>0)\t\t// 考虑整数k比数组 位数多 的情况\n    {\n        num1.push_back(k%10);\n        k /= 10;\n    }\n    reverse(num1.begin(), num1.end());  // 数组反转\n    return num1;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992505294","body":"## 思路\n\n1. 将出现字符的下标数字存在数组a中\n2. 遍历字符串，将每个字符下标与整个数组a比较，将最短距离存进answer数组中\n## 代码\n\n暴力解法：\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> a;\n\n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i] == c)\n                a.push_back(i);  // 将出现字符的下标数字存在数组a中\n        }\n\n        vector<int> answer;\n        for(int i=0; i<s.size(); i++)  // 遍历字符串\n        {\n            int num = s.size();\n            for(int j=0; j< a.size(); j++)   // 将每个字符下标与整个数组a比较，将最短距离存进answer数组中\n            {\n                num = min(num, abs(a[j]-i));\n            }\n            answer.push_back(num);\n        }\n        return answer;\n    }\n};\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993594632","body":"## 思路\n\n用vector数组模拟栈\n\n- 创建一个预留一定空间的vector数组\n- 判断数组中的个数是否超出容器，进而执行push操作，判断数组是否为空，进而执行pop操作\n- 判断数组中的个数，决定对哪些元素进行加法\n\n## 代码\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        a.reserve(maxSize);  // 预留长度, 里面的空间不能访问\n    }\n    \n    void push(int x) {\n        if(a.size()<a.capacity())   // 判断数组中的个数是否超出容器\n        {\n            a.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(a.size())    // 判断数组是否为空\n        {\n            int num = a.back();\n            a.pop_back();\n            return num;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(a.size() != 0)\n        {\n            int m=0;\n            int n = a.size();\n            m = (n <= k)? n:k;   \n            for(int i=0; i<m; i++)\n            {\n                a[i] += val;\n            }\n            \n        }\n    }\npublic:\n    vector<int> a;\n};\n\n```\n\n## 复杂度\n\n时间复杂度：初始化（构造函数）、`push` 操作和 `pop` 操作的渐进时间复杂度为 O(1)，`inc` 操作的渐进时间复杂度为 O(k)。 \n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994922489","body":"### 思路\n\n- 括号匹配，用栈解决\n- 用两个栈分别存储字符串的重复次数以及当前解码的字符串\n- 最开始str栈内存入“” \n- 每次遇到字母，表示该字母属于str栈顶的待解码字符串，可以直接在str栈顶字符串末尾加入该字母。\n- 每次碰到数字要读取完整的数字，此时遍历过了一次'[' ，就在字符串栈中新开一层\n- 每次遇到']'表示已经完成一个字符串的解码，此时栈顶字符串就是一个“【】”里面需要重复的字符串，重复次数为num栈顶元素次数，记录两个栈顶元素，分别减少一层， 将解码结果加入str栈顶字符串末尾\n- 遍历完s字符串，str栈顶就是最终解码结果\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s)\n    {\n        str.push_back(\"\"); // 创建空的一层\n        for(int i=0; i<s.size(); i++)   // 遍历字符串s\n        {\n            if(isalpha(s[i]))   // 判断字符是否为字母\n                str.back() += s[i];  // 字母直接加在一层中\n            else if(isdigit(s[i]))  // 判断字符是否为数字\n            {\n                int x=0;\n                while(isdigit(s[i]))\n                {\n                    // 若s[i] == '0', 转化为整型数字是48, 不符合，所以要 -'0'转化\n                    x = x*10 + s[i] - '0'; \n                    i++;            //考虑后面的字符也是数字\n                } // 读取重复次数，此时已经遍历过一个'['\n                num.push_back(x);\n                str.push_back(\"\"); //因为遍历过一个'[', 所以新开一层\n            }\n            else // 如果是']'则出栈一次\n            {\n                int a = num.back();\n                string sstr = str.back();\n                str.pop_back();\n                num.pop_back();\n                while (a -- ) str.back() += sstr;//更新最内一层的字符串\n            }\n        }\n        return str.back();  //最后的结果是栈底\n    }\nprivate:\n    vector<int> num; // 数字栈，存储重复的次数的栈\n    vector<string> str; // 记录最内一层字符串的栈， 有'【'就开一层\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994991083","body":"## 思路\n\n用两个栈模拟队列，队尾push，队头pop\n\n## 代码\n\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        while(!b.empty())  // 如果b非空\n        {\n            a.push(b.top());\n            b.pop();\n        }\n        a.push(x);\n        while(! a.empty())\n        {\n            b.push(a.top());\n            a.pop();\n        }\n    }\n    \n    int pop() {\n        int ret = b.top();\n        b.pop();\n        return ret;\n    }\n    \n    int peek() {\n        return b.top();\n    }\n    \n    bool empty() {\n        return b.empty();\n    }\nprivate:\n    stack<int> a,b;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414033","body":"## 思路\r\n\r\n- 先考虑没有节点和一个节点的情况\r\n-  在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断，这样可以将head节点当做普通节点 ，不用单独考虑了 \r\n- 用prev指针指向虚拟节点，cur指针指向要交换的第一个节点，cur->next是要交换的第二个节点\r\n\r\n## 代码\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head == nullptr || head->next == nullptr)  \r\n            return head;\r\n        ListNode* dummy = new ListNode(-1, head);  // 创建虚拟节点，虚拟节点的next指向头节点\r\n        ListNode* prev = dummy;\r\n        ListNode* cur = prev->next;\r\n\r\n        while(cur != nullptr && cur->next != nullptr)   // 要交换的两者不为空\r\n        {\r\n            ListNode* p1 = cur->next;\r\n            cur->next = p1->next;\r\n            p1->next = cur;\r\n            prev->next = p1;\r\n\r\n            prev = cur;\r\n            cur = prev->next;\r\n        }\r\n       \r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001040315","body":"## 思路\n\n- 比较两个树是否相同，可以将树的节点放进队列，逐一对比\n- 先考虑是否有空树的情况，然后将两个树的根节点压进队列中\n- 如果队列不空，取出两个数比较，再将取出数的左右节点压进队列\n\n## 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == NULL && q == NULL)    return true;\n        if(p == NULL || q == NULL)    return false;\n        queue<TreeNode*> que;\n        que.push(p);\n        que.push(q);\n        while(!que.empty())\n        {\n            TreeNode* leftNode = que.front(); que.pop();\n            TreeNode* rightNode = que.front(); que.pop();\n            if(!leftNode && !rightNode)\n            {\n                continue;\n            }\n            if(!leftNode || !rightNode || (leftNode->val != rightNode->val))\n            {\n                return false;\n            }\n            que.push(leftNode->left);\n            que.push(rightNode->left);\n            que.push(leftNode->right);\n            que.push(rightNode->right);\n        }\n        return true;\n\n    }\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pengfeicchen":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991857243","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int K) {\n        List<Integer> res = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; --i) {\n            res.add(0, (num[i] + K) % 10);\n            K = (num[i] + K) / 10;\n        }\n        while (K > 0) {\n            res.add(0, K % 10);\n            K /= 10;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992175534","body":"class Solution {\n    public int[] shortestToChar(String S, char C) {\n        char[] cc = S.toCharArray();\n        int[] result = new int[cc.length];\n        List<Integer> index = new ArrayList<>();\n        for(int i=0;i<cc.length;i++){\n            if(cc[i]==C){\n                index.add(i);\n                System.out.print(i);\n            }\n        }\n        int count=0;\n        for(int i=0;i<cc.length;i++){\n            if(i==index.get(count)){\n                if(count<index.size()-1){\n                    count++;\n                }\n                result[i] = 0;\n            }else if(count==0 && i<index.get(count)){\n                result[i] = index.get(count)-i;\n            }else if(count==index.size()-1 && i>index.get(count)){\n                result[i] = i - index.get(count);\n            }else if(count>0){\n                if(i-index.get(count-1) < index.get(count)-i){\n                    result[i] = i-index.get(count-1);\n                }else{\n                    result[i] = index.get(count)-i;\n                }\n            }\n        }\n        return result;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993223866","body":"// time:O(n) space:O(n)\npublic int[] arr;\n    public int size;\n    public int max;\n    public _1381_DesignaStackWithIncrementOperation(int maxSize) {\n        size = 0;\n        max = maxSize;\n        arr = new int[1001];\n    }\n    \n    public void push(int x) {\n        if (size < max) {\n            arr[size++] = x;\n        }\n    }\n    \n    public int pop() {\n        if (size < 1) return -1;\n        int res = arr[size - 1];\n        size--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int j = k < size ? k : size;\n        for (int i = 0; i < j; i++) {\n            arr[i] += val;\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994565174","body":"public class Solution {\n    public String decodeString(String s) {\n        Stack<Integer> nums = new Stack<Integer>();\n        Stack<Character> chars = new Stack<Character>();\n        int count = 0;\n        for (int i = 0; i < s.length(); i ++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                count = count * 10 + (c - '0');\n            }\n            else if (c == ']') {\n                int repeat = nums.pop();\n                String tmp = \"\";\n                while (chars.peek() != '[') {\n                   tmp = chars.pop() + tmp;     \n                }\n                chars.pop();\n                for (int j = 0; j < repeat; j ++) {\n                    for (int k = 0; k < tmp.length(); k ++) {\n                        chars.push(tmp.charAt(k));\n                    }\n                }\n            }\n            else {\n                if (count != 0) {\n                    nums.push(count);\n                }   \n                count = 0;\n                chars.push(c);\n            }\n        }\n        String result = \"\";\n        while (!chars.isEmpty()) {\n            result = chars.pop() + result;\n        }\n        return result;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995500758","body":"class MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        //stack1 the node sequence pops up and presses in stack2 \n        if (stack2.isEmpty()) {// on the condition that : stack2 for, stack1, O(1)\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());//stack1stack2\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996553017","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] maxOfLeft = new int[n];\n        int[] minOfRight = new int[n];\n \n        maxOfLeft[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\n        }\n \n        minOfRight[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\n        }\n \n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\n        }\n \n        return res + 1;\n    }\n}　　","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997166349","body":"class Solution {\n  public ListNode rotateRight(ListNode head, int k) {\n    if (head == null) return null;\n    int l = 1;\n    ListNode tail = head;\n    while (tail.next != null) {\n      tail = tail.next;\n      ++l;\n    }\n    k %= l;\n    if (k == 0) return head;\n    \n    ListNode prev = head;\n    for (int i = 0; i < l - k - 1; ++i) {\n      prev = prev.next;\n    }\n    \n    ListNode new_head = prev.next;\n    prev.next = null;\n    tail.next = head;\n    return new_head;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997346532","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode *dummy = new ListNode(-1), *pre = dummy;\n        dummy->next = head;\n        while (pre->next && pre->next->next) {\n            ListNode *t = pre->next->next;\n            pre->next->next = t->next;\n            t->next = pre->next;\n            pre->next = t;\n            pre = t->next;\n        }\n        return dummy->next;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998173661","body":"public class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        int lenA = getLength(headA), lenB = getLength(headB);\r\n        if (lenA > lenB) {\r\n            for (int i = 0; i < lenA - lenB; ++i) headA = headA.next;\r\n        } else {\r\n            for (int i = 0; i < lenB - lenA; ++i) headB = headB.next;\r\n        }\r\n        while (headA != null && headB != null && headA != headB) {\r\n            headA = headA.next;\r\n            headB = headB.next;\r\n        }\r\n        return (headA != null && headB != null) ? headA : null;\r\n    }\r\n    public int getLength(ListNode head) {\r\n        int cnt = 0;\r\n        while (head != null) {\r\n            ++cnt;\r\n            head = head.next;\r\n        }\r\n        return cnt;\r\n    }\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999758590","body":"class LRUCache {\n    static class Node {\n        private int key;\n        private int value;\n        Node prev, next;\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    private int capacity;\n    private Map<Integer, Node> map;\n    private Node dummyhead, dummytail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n        this.dummyhead = new Node(-1, -1);\n        this.dummytail = new Node(-1, -1);\n        this.dummyhead.next = this.dummytail;\n        this.dummytail.prev = this.dummyhead;\n    }\n    \n    public int get(int key) {\n        Node node = getNode(key);\n        if(null == node) return -1;\n        return node.value;\n    }\n    \n    Node getNode(int key) {\n        Node node = map.get(key);\n        if(null == node) return null;\n        disconnect(node);\n        insertHead(node);\n        return node;\n    }\n    \n    void disconnect(Node node) {\n        node.next.prev = node.prev;\n        node.prev.next = node.next;        \n    }\n    \n    void insertHead(Node node) {\n        node.next = dummyhead.next;\n        dummyhead.next.prev = node;\n        node.prev = dummyhead;\n        dummyhead.next = node;        \n    }\n    \n    public void put(int key, int value) {\n        Node node = getNode(key);\n        if(null != node) {\n            node.value = value;\n        }\n        else {\n            node = new Node(key, value);\n            insertHead(node);\n            \n            map.put(key, node);\n            if(map.size() > capacity) {\n                Node tail = dummytail.prev;\n                disconnect(tail);\n                map.remove(tail.key);\n            }\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000692284","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        int a = maxDepth(root.left);\n        int b = maxDepth(root.right);\n        return Math.max(a,b)+1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000968595","body":"class Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stonehit":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991858521","body":"## 思路\r\n逐位相加，记录进位，计算后头插到结果数组\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        for(int i = num.length - 1;i >= 0 || k > 0;i--){\r\n            int dec = (k % 10) + carry;\r\n            dec += i >= 0 ? num[i] : 0;\r\n            k = k / 10;\r\n            carry = 0;\r\n            if(dec >= 10){\r\n                carry = 1;\r\n                dec = dec % 10;\r\n            }\r\n            res.add(0,dec);\r\n        }\r\n        if(carry != 0)  res.add(0,1);\r\n        return res;\r\n    }\r\n\r\n\r\n}\r\n```\r\n## 复杂度\r\n空间O(N)\r\n时间O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992550562","body":"## 思路\r\n前后各遍历一次，记录为C的索引位置\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int[] res = new int[S.length()];\r\n        int index = -S.length();\r\n        for(int i = 0;i<S.length();i++){\r\n            if(S.charAt(i) == C){\r\n                index = i;\r\n                res[i] = 0;\r\n            }else{\r\n                res[i] = i-index;\r\n            }\r\n        }\r\n        index = 10000;\r\n        for(int j = S.length() - 1;j>=0;j--){\r\n            if(S.charAt(j) == C){\r\n                index = j;\r\n            }else{\r\n                res[j] = Math.min(index-j,res[j]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间O(N)\r\n空间O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994900268","body":"## 代码\r\n```java\r\nclass Solution {\r\n    Stack<Object> stack;\r\n    public String decodeString(String s) {\r\n        String res = \"\";\r\n        stack = new Stack();\r\n        int num = 0;\r\n        for(int i = 0;i<s.length();i++){\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)){\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if(c == '['){\r\n                stack.push(num);\r\n                num = 0;\r\n            }\r\n            else if(c == ']'){\r\n                String tmp = strAppendPush();\r\n                int cnt = (int)stack.pop();\r\n                String temp = String.join(\"\", Collections.nCopies(cnt, tmp));\r\n                stack.push(temp);\r\n            }else{\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n        return new StringBuilder(strAppendPush()).reverse().toString();\r\n\r\n    }\r\n    public String strAppendPush(){\r\n        StringBuilder sb = new StringBuilder();\r\n        while(!stack.isEmpty() && stack.peek() instanceof String){\r\n            sb.append(stack.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度\r\n时间O(N)\r\n空间O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995841218","body":"## 代码\r\n```java\r\nclass MyQueue {\r\n    public Stack<Integer> instack;\r\n    public Stack<Integer> outstack;\r\n\r\n    public MyQueue() {\r\n        instack = new Stack<>();\r\n        outstack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        instack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!outstack.isEmpty()){\r\n            return outstack.pop();\r\n        }else{\r\n            while(!instack.isEmpty()){\r\n                outstack.push(instack.pop());\r\n            }\r\n            return outstack.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n         if(!outstack.isEmpty()){\r\n            return outstack.peek();\r\n        }else{\r\n            while(!instack.isEmpty()){\r\n                outstack.push(instack.pop());\r\n            }\r\n            return outstack.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return instack.isEmpty() && outstack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n#复杂度 \r\n空间O(N)\r\n时间O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997946035","body":"## 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        ListNode slow = head,fast =head;\r\n        ListNode pre = null;\r\n        while(fast!=null && fast.next!=null){\r\n            pre = slow;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        pre.next = null;\r\n        TreeNode tree = new TreeNode(slow.val);\r\n        tree.left = sortedListToBST(head);\r\n        tree.right = sortedListToBST(slow.next);\r\n        return tree;\r\n    }\r\n}\r\n```\r\n## 复杂度 \r\nO(N)\r\nO(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991860708","body":"### 思路：\n\n将对应元素从个位起往前依次相加，当有进位时，需要考虑进位，这里我为了方便使用了链表的数据结构，把数组num和k都放到了两个链表上，依次遍历两个链表，并把结果存在一个新的链表上\n\n### 代码：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list1 = new LinkedList<>();\n        LinkedList<Integer> list2 = new LinkedList<>();\n        LinkedList<Integer> list3 = new LinkedList<>();\n        for (int i : num) {\n            list1.addLast(i);\n        }\n        while (k != 0) {\n            list2.addFirst(k % 10);\n            k /= 10;\n        }\n        int carried = 0;\n        while (list1.size()!=0||list2.size() != 0 || carried != 0) {\n            int n1 = list1.size() != 0 ? list1.removeLast() : 0;\n            int n2 = list2.size() != 0 ? list2.removeLast() : 0;\n            int sum = n1 + n2 + carried;\n            int inser = sum % 10;\n            carried = sum / 10;\n            list3.addFirst(inser);\n        }\n        return list3;\n    }\n}\n```\n\n### 时空复杂度：\n\n- 时间复杂度： O(max(n,len(k)) \n- 空间复杂度：O(n)\n- 这里不是很会分析\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992070313","body":"### 思路：\n\n遍历一边字符串将所有元素进行比较进而选中待比较元素，再将其向前向后分别进行遍历查找最近的字符c，设置两个标记flag1和flag2。当只有一边出现了字符c，则肯定有一边的距离为0，此时flag1和flag2必有一个是false，这是我们选用左边距离和右边距离的最大值(把没出现c的那一边剔除)；当两边都有字符c，此时flag1和flag2都为true，这时选用左边距离和右边距离的最小值(两边都有距离)\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] dis = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            char temp = s.charAt(i);\n            boolean flag1 = false, flag2 = false;\n            int distance_1 = 0, distance_2 = 0;\n            for (int left = i; left >= 0; left--) {\n                char temp1 = s.charAt(left);\n                if (temp1 == c) {\n                    distance_1 = Math.abs((i - left));\n                    flag1 = true;\n                    break;\n                }\n            }\n            for (int right = i; right <= s.length() - 1; right++) {\n                char temp2 = s.charAt(right);\n                if (temp2 == c) {\n                    distance_2 = Math.abs((i - right));\n                    flag2 = true;\n                    break;\n                }\n            }\n            int distance = flag1 && flag2 ? Math.min(distance_1, distance_2) : Math.max(distance_1, distance_2);\n            dis[i] = distance;\n        }\n        return dis;\n    }\n}\n```\n\n### 时空复杂度：\n\n- 时间复杂度：*O*(*N*^2）\n- 空间复杂度：*O*(*N*)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993554513","body":"### 思路：\n\n用一个LinkList来实现栈(LinkList方便对末尾进行操作，同时也能随机访问每一个节点)，设置一个变量length表示当前栈的长度，一个变量maxSize表示最大长度即可完成初始化，剩下的进栈、出栈和增量操作无非是LinkList的增删改遍历罢了。\n\n### 代码：\n\n```java\nclass CustomStack {\n    LinkedList<Integer> stack;\n    int maxSize;\n    int length;\n\n    public CustomStack(int maxSize) {\n        stack = new LinkedList<>();\n        this.maxSize = maxSize;\n        length = 0;\n    }\n\n    public void push(int x) {\n        if (length < maxSize) {\n            stack.addLast(x);\n            length++;\n        }\n    }\n\n    public int pop() {\n        if (length <= maxSize && length > 0) {\n            length--;\n            return stack.removeLast();\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        int idx = Math.min(length, k);\n        for (int i = 0; i < idx; i++) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n### 时空复杂度：\n\n-时间复杂度：初始化（构造函数）、`push` 操作和 `pop` 操作的渐进时间复杂度为 O(1)*O*(1)，`inc` 操作的渐进时间复杂度为 *O*(*k*)。\n\n-空间复杂度：*O*(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994824942","body":"### 思路：\n\n本质上就是括号的匹配，由此可以想到用栈的方法，用一个索引遍历字符串，当遇到数字时，直接进栈(需要`进行解析`，比如字符串“123a”里的123，要让他变为一个单独的元素“123”再进栈，索引跟着移动)；当遇到左括号'['或者字母，直接进栈；当遇到右括号']'，索引+1表示越过当前右括号指向右括号的下一个字符，栈进行连续出栈，用一个中间链表记录中间结果，直到遇见最近的左括号'['为止(此时中间结果逆序，需进行翻转)，这时再执行依次出栈操作，此时的栈顶元素必是解析后的数字，表明对应的字符串应该出现的次数，将上述翻转后的中间结果重复该数字次，再添加进栈。重复上述三个判断，直至索引遍历完字符串，这时只需要把栈中元素依次添加到字符串中即可。\n\n例如：\"23[a2[bc]]\"\n\n栈的变化应该是：                        \n\n- [\"23\",\"[\",\"a\",\"2\",\"[\",\"b\",\"c\"] -> [\"23\",\"[\",\"a\",\"bcbc\"]->.....\n\n### 代码：\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stack = new LinkedList<>();\n        ptr = 0; // 之前陷入死循环是句子int ptr = 0;在此处重新定了ptr(相当于局部变量了)，在getNums()函数里的更新的是上面的全局变量ptr，此处的局部变量没有被更新到\n        while (ptr < s.length()) {\n            if (Character.isDigit(s.charAt(ptr))) { // 一个或多个数字进行解析后直接进栈\n                String digit = getNums(s);\n                stack.addLast(digit);\n            } else if (Character.isLetter(s.charAt(ptr)) || s.charAt(ptr) == '[') {\n                // 左括号'['或字母直接进栈\n                stack.addLast(String.valueOf(s.charAt(ptr++)));\n            } else {\n                // 右括号']'出栈,直至遇见左括号'['\n                ptr++; // 跳过该右括号\n                LinkedList<String> sub = new LinkedList<>();// 用一个中间sub接收，一开始用了Stringbuilder(是整体反转，不是元素反转)\n                while (!stack.getLast().equals(\"[\")) {\n                    sub.addLast(stack.removeLast());\n                }\n                Collections.reverse(sub); // 元素反转\n                String o = getStr(sub);\n                stack.removeLast(); // 将左括号出栈\n                int repTime = Integer.parseInt(stack.removeLast()); // 此时栈顶为当前 sb 对应的字符串应该出现的次数\n                StringBuilder sb = new StringBuilder();\n                while (repTime-- > 0) {\n                    // sb.append(sb); //此处重复添加了\n                    sb.append(o);\n                }\n                stack.addLast(sb.toString());\n            }\n        }\n\n        return getStr(stack);\n\n    }\n\n    public String getNums(String s) {\n        // 将字符串了的长数字进行解析\n        StringBuilder digit = new StringBuilder();\n        while (Character.isDigit(s.charAt(ptr))) {\n            digit.append(s.charAt(ptr++));\n        }\n        return digit.toString();\n    }\n\n    public String getStr(LinkedList<String> list) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : list) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n}\n```\n\n### 时空复杂度：\n\n- 时间复杂度：*O*(*n*)，n为字符串的长度\n- 空间复杂度：*O*(*n*)，用了一个辅助栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995497995","body":"### 思路：\n\n用两个栈来实现一个队列，一个用来专注于进，一个用来专注于出。\n\n* 初始化队列：即初始化两个栈。\n* 入队：直接在栈1入栈即可。\n* 出队：当栈2不空时，栈2直接出栈；当栈2为空，栈1不为空时，将栈1元素依次出栈再入栈2，最后对栈2出栈即可；当栈1和栈2均为空，这时表示是一个空队列，返回值-1，表示出队失败。\n* 队列判空：判断栈1和栈2的长度是否都为0即可。\n\n### 代码：\n\n```java\nimport java.util.LinkedList;\n\nclass MyQueue {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stack1.addLast(x);\n    }\n\n    public int pop() {\n        if (stack2.size() != 0) return stack2.removeLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.removeLast();\n        }\n        return -1;\n    }\n\n    public int peek() {\n        if (stack2.size() != 0) return stack2.getLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.getLast();\n        }\n        return -1;\n    }\n\n    public boolean empty() {\n        return stack1.size() == 0 && stack2.size() == 0;\n    }\n}\n\n/*\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n### 时空复杂度：\n\n- 时间复杂度：\n  - 初始化队列：*O*(1)\n  - 入队：*O*(1)\n  - 出队：*O*(1)，最坏*O*(n)\n  - 判空：*O*(1)\n- 空间复杂度：*O*(1),只考虑额外消耗的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996493479","body":"#### 思路：\r\n\r\n用一个单调不减辅助栈存储每个排序块的最大值。具体来说：\r\n\r\n- 遍历数组获得当前元素`num`，\r\n\r\n  - 栈空或`num`大于等于栈顶元素：说明`num`不会影响当前排序块，直接进栈，把当前`num`当作一个只有一个元素的排序块\r\n\r\n  - 栈不空且`num`小于栈顶元素：说明`num`会影响当前排序块，需要把`num`并入当前排序块。用中间变量`head`存储出栈的元素，此时，`head`仍是当前排序块的最大值，若`num`仍小于栈顶元素(非`head`，已经出栈了)，则循环出栈，一直到`num`大于等于栈顶元素为止，再把`head`(当前排序块的最大值)入栈(`num`元素并入了当前排序块），此时的栈是单调不减栈，表示现今每一个排序块的最大值。\r\n  - 循环往复，直至遍历结束。\r\n\r\n- 遍历结束后，该单调不增辅助栈存储的是所有排序块的最大值，也即栈的长度就是排序块的最大数量。\r\n\r\n#### 代码：\r\n\r\n```java\r\nimport java.util.LinkedList;\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        for (int num : arr) {\r\n            if (list.isEmpty() || num >= list.getLast()) {\r\n                list.addLast(num);\r\n            } else {\r\n                int head = list.removeLast();\r\n                while (!list.isEmpty() && num < list.getLast()) list.removeLast();\r\n                // 上面的代码用了短路与,如果判断条件num < list.getLast()在前,当栈为空时会出现判断错误，所以一定需要先确保栈不空再进行栈顶元素的判断\r\n                list.addLast(head);\r\n            }\r\n        }\r\n        return list.size();\r\n    }\r\n}\r\n```\r\n\r\n#### tips:\r\n\r\n> 对栈顶元素进行判断时，一定要先对栈空与否进行判断。\r\n\r\n#### 时空复杂度：\r\n\r\n- 时间复杂度：*O*(n)\r\n  - 总体O(n)遍历，局部的判断属于【有限个数】的时间复杂度，所以是O(1)\r\n  - 计算一下每个元素入栈几次，出栈几次。\r\n- 空间复杂度：*O*(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997224322","body":" #### 思路：\n\n一个链表，右循环`k`位，实际循环`k = k%n`位(逆序)，保留从左到右`s = n-k`位(正序)。于是很直观的：\n\n- 将所有元素入栈，顺便计算元素个数`n`\n- 重新建立一个链表：\n  - 将原有链表从左到右`s`位用尾插法入链\n  - 出栈`k`位元素用头插法入链表\n\n#### 代码：\n\n```java\nimport java.util.LinkedList;\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null) return null;\n        LinkedList<Integer> stack = new LinkedList<>();\n        ListNode res = null;\n        ListNode tail = null;\n        ListNode cur = head;\n        int n = 0;\n        while (cur != null) {\n            n++;\n            stack.addLast(cur.val);\n            cur = cur.next;\n        }\n        int rotateNum = k % n;\n        int oriNum = n - rotateNum;\n        cur = head;\n        while (oriNum-- > 0) {\n            if (res == null) {\n                res = new ListNode(cur.val);\n                tail = res;\n            } else {\n                tail.next = new ListNode(cur.val);\n                tail = tail.next;\n            }\n            cur = cur.next;\n        }\n        while (rotateNum-- > 0) {\n            if (res == null) {\n                res = new ListNode(stack.removeLast());\n            } else {\n                ListNode temp = new ListNode(stack.removeLast());\n                temp.next = res;\n                res = temp;\n            }\n        }\n        return res;\n    }\n}\n```\n\n#### tips:\n\n> 要注意链表的构建和头插尾插法。\n\n#### 时空复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，建立辅助栈的开销，不考虑答案新建的链表。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997331047","body":"#### 思路：\n\n把链表元素存进数组里，交换好顺序再重新建链。\n\n#### 代码：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        int n = 1;\n        ListNode cur = head;\n        while (cur.next != null) {\n            n++;\n            cur = cur.next;\n        }\n        int[] nums = new int[n];\n        cur = head;\n        int idx = 0;\n        while (cur != null) {\n            nums[idx++] = cur.val;\n            cur = cur.next;\n        }\n        for (int i = 0, j = 1; i < n && j < n; i += 2, j += 2) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n        ListNode tail = null;\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0) {\n                head = new ListNode(nums[i]);\n                tail = head;\n            } else {\n                tail.next = new ListNode(nums[i]);\n                tail = tail.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n#### 时空复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997854910","body":"#### 思路：\n\n可以定一个快慢指针，快指针每次走两步，慢指针每次走一步，当快指针到达链表末尾时，慢指针刚好到达链表的中点，此时慢指针即为树的根节点，然后再递归中点左边的节点，再递归右边节点。\n\n> 本质上是一个先序遍历？\n\n#### 代码：\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        return bst(head, null);\n    }\n\n    public TreeNode bst(ListNode head, ListNode tail) {\n        // 这里的尾指针指向末尾元素的下一个元素\n        if (head == tail) return null;\n        ListNode fast = head, slow = head;\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = bst(head, slow);\n        root.right = bst(slow.next, tail);\n        return root;\n    }\n}\n```\n\n#### 时空复杂度：\n\n- 时间复杂度：O(nlogn)，logn是递归树深度，n是每层递归树的操作数\n- 空间复杂度：O(logn)，递归树深度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998873041","body":"#### 思路：\n\n将哈希表记录链表`A`，然后遍历链表B，看链表B的结点是否在哈希表中，在表则为交叉结点。\n\n#### 代码：\n\n```java\nimport java.util.HashMap;\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        HashMap<ListNode, Integer> map = new HashMap<>();\n        ListNode cur = headA;\n        int idx = 0;\n        while (cur!=null){\n            map.put(cur,idx++);\n            cur = cur.next;\n        }\n        cur = headB;\n        while (cur!=null){\n            if (map.containsKey(cur)){\n                return cur;\n            }\n            cur = cur.next;\n        }\n        return null;\n    }\n}\n```\n\n#### 时空复杂度：\n\n- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表`headA`和`headB`的长度。需要遍历两个链表各一次。\n- 空间复杂度：O(m)，额外用了一个哈希表。m是链表 `headA`的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999355006","body":"#### 思路：\n\n用确定的点`[遍历过的点]`判断不确定的点`[成环的第一个点]`，很容易想到哈希表的方法。具体来说：\n\n- 用哈希表存储访问过的元素：\n  - 当链表的结点数不大于1时，表明不成环，返回`null`\n  - 遍历链表(循环结束条件为节点为`null`或节点不存在于哈希表中)，当当前节点存在哈希表中，则表示该节点就是成环的第一个节点\n\n#### 代码：\n\n```java\nimport java.util.Hashset;\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n * int val;\n * ListNode next;\n * ListNode(int x) {\n * val = x;\n * next = null;\n * }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        HashSet<ListNode> set = new HashSet<>();\n        ListNode cur = head;\n        while (!set.contains(cur)&&cur!=null) {\n            set.add(cur);\n            cur = cur.next;\n        }\n        return cur;\n    }\n}\n```\n\n#### 时空复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，用了额外的哈希表。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000290540","body":"#### 思路：\n\n之前想到用哈希表和一个队列来做。是想着越在队列开头的元素就越新，越在队列后面的就越旧，使用时更新哈希表和队列。但是这样的结构无法解决的问题是：当队列中间的元素被使用时，这个元素就是最新的，应该怎么把他弄到开头？进行交换很不方便。\n\n思路是没错的，我们可以把队列改成一个双链表即可解决该问题。\n\n#### tips:\n\n> 可以在链表的头尾增加两个哑结点，方便对边界进行操作。\n\n#### 代码：\n\n```java\nimport java.util.HashMap;\nimport java.util.LinkedList;\n\nclass LRUCache {\n    // 构造一个双链表\n    class DLinkedList {\n        int key, val;\n        DLinkedList prev, next;\n\n        public DLinkedList() {\n        }\n\n        public DLinkedList(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    HashMap<Integer, DLinkedList> map;\n    DLinkedList head, tail;\n    int maxSize,size;\n\n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        head = new DLinkedList();\n        tail = new DLinkedList();\n        head.next = tail;\n        tail.prev = head;\n        maxSize = capacity;\n        size = 0;\n    }\n\n    public int get(int key) {\n        DLinkedList node = map.get(key);\n        if (node != null) {\n            moveToHead(node);\n            return node.val;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        DLinkedList node = map.get(key);\n        if (node == null) {\n            DLinkedList newNode = new DLinkedList(key, value);\n            map.put(key,newNode);\n            addToHead(newNode);\n            size++;\n            if (size > maxSize) {\n                DLinkedList tail = removeTail();\n                map.remove(tail.key);\n                size--;\n            }\n        }else{\n            node.val = value;\n            moveToHead(node);\n        }\n    }\n\n    public void addToHead(DLinkedList node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    public void removeNode(DLinkedList node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    public void moveToHead(DLinkedList node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    public DLinkedList removeTail() {\n        DLinkedList res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n/*\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n#### 时间复杂度：\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)，用了一个双链表。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000712855","body":"#### 思路：\n\n求深度很容易想到DFS。具体为：\n\n- 明确递归内容：每个结点`node`的深度为：`max(node.left,node.right)+1`\n- 递归终止条件：当访问到的结点为空。\n\n#### 代码：\n\n```Java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public int dfs(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(dfs(root.left), dfs(root.right)) + 1;\n    }\n\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return dfs(root);\n    }\n}\n```\n\n#### 时空复杂度：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)，height为二叉树高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000959687","body":"#### 思路：\n\n可以通过搜索的方式判断两个二叉树是否相同。\n\n于是，有两种遍历方法：\n\n- DFS(**先对根结点进行逻辑处理，然后递归与他邻接的点**)：\n  - 两个根结点都为空，相同；一空一不空，不同；\n  - 两个根结点都不空，但是二者的值不相等，不同；\n  - 递归两个根节点的左结点和右结点；\n- BFS(**根结点不空则入队，队不空时循环，出队结点，对出队结点的邻接点进行逻辑处理，满足条件的入队**)：\n  - 两个根结点都为空，相同；一空一不空，不同；\n  - 两个根结点不空时，分别入队；\n  - 两个队不空时，循环：\n    - 出队，两个结点值不相等，不同；两个结点的左/右结点一空一不空，不同；\n    - 当左/右结点不空时，入队，要注意左/右结点的入队顺序要一致，先入左结点，再入右结点，左右结点的值留在出队的时候再判断；\n\n#### 代码：\n\n- DFS:\n\n  ```java\n  /**\n   * Definition for a binary tree node.\n   * public class TreeNode {\n   * int val;\n   * TreeNode left;\n   * TreeNode right;\n   * TreeNode() {}\n   * TreeNode(int val) { this.val = val; }\n   * TreeNode(int val, TreeNode left, TreeNode right) {\n   * this.val = val;\n   * this.left = left;\n   * this.right = right;\n   * }\n   * }\n   */\n  class Solution {\n      public boolean isSameTree(TreeNode p, TreeNode q) {\n          if (p == null & q == null) return true;\n          if (p == null || q == null) return false;\n          if (p.val != q.val) return false;\n          return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n      }\n  }\n  ```\n\n- BFS：\n\n  ```jav\n  import java.util.LinkedList;\n  import java.util.Queue;\n  \n  /**\n   * Definition for a binary tree node.\n   * public class TreeNode {\n   * int val;\n   * TreeNode left;\n   * TreeNode right;\n   * TreeNode() {}\n   * TreeNode(int val) { this.val = val; }\n   * TreeNode(int val, TreeNode left, TreeNode right) {\n   * this.val = val;\n   * this.left = left;\n   * this.right = right;\n   * }\n   * }\n   */\n  class Solution {\n      public boolean isSameTree(TreeNode p, TreeNode q) {\n          if (p == null & q == null) return true;\n          if (p == null || q == null) return false;\n          Queue<TreeNode> queue1 = new LinkedList<>();\n          Queue<TreeNode> queue2 = new LinkedList<>();\n          queue1.offer(p);\n          queue2.offer(q);\n          while (!queue1.isEmpty() && !queue2.isEmpty()) {\n              TreeNode node1 = queue1.poll(), node2 = queue2.poll();\n              if (node1.val != node2.val) return false;\n              TreeNode left1 = node1.left, right1 = node1.right;\n              TreeNode left2 = node2.left, right2 = node2.right;\n              // ^ 异或符，相同为0，不同为1\n              if (left1 == null ^ left2 == null) return false;\n              if (right1 == null ^ right2 == null) return false;\n              if (left1!=null&&left2!=null){\n                  queue1.offer(left1);\n                  queue2.offer(left2);\n              }\n              if (right1!=null&&right2!=null){\n                  queue1.offer(right1);\n                  queue2.offer(right2);\n              }\n          }\n          return queue1.isEmpty()&&queue2.isEmpty();\n      }\n  }\n  ```\n\n#### 时空复杂度：\n\n- 时间复杂度：\n  - DFS：O(min(m,n))\n  - BFS：O(min(m,n))\n  - m和n分别时两个二叉树的结点数，访问的结点数不会超过较少的二叉树结点数。\n- 空间复杂度：\n  - DFS：O(min(m,n))，DFS的空间复杂度取决于递归调用层数(二叉树高度)，最坏情况下，二叉树的高度等于结点数。\n  - BFS：O(min(m,n))，BFS的空间复杂度取决于队列里的结点个数，队列结点数不会超过较少的二叉树结点数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991861963","body":"### 思路\n- k转为数组，处理两个数组的相加。\n- 双指针移动计算两个数组，标志位处理进位，结果存入stack，最后转为list\n\n### 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] numK = intToArray(k);\n        int a = num.length - 1;\n        int b = numK.length - 1;\n        boolean isUp = false;\n        Stack<Integer> stack = new Stack();\n        List<Integer> list = new LinkedList();\n        while(a>=0 || b>=0 || isUp){\n            int result = 0;\n            if(isUp){\n                result = 1;\n                isUp = false;\n            }\n            if(a <0 && b<0){\n                //result += 0;\n            }else if(a <0){\n                result += numK[b];\n            }else if(b <0){\n               result += num[a];\n            }else{\n                result += num[a] + numK[b];\n            }\n            a--;\n            b--;\n\n            if(result >= 10){\n                isUp = true;\n            }\n            stack.push(result % 10);\n            System.out.print(\"stack: [\");\n            System.out.print( result % 10);\n            System.out.print(\"]\");\n        }\n\n        while(!stack.isEmpty()){\n            list.add(stack.pop());\n        }\n        return list;\n    }\n\n    public int[] intToArray(int k) {\n        System.out.print(\"intToArray: [\");\n        String temp =  String.valueOf(k);\n        int[] result = new int[temp.length()];\n        for(int i=0; i<temp.length(); i++){\n            result[i] = Integer.parseInt(String.valueOf(temp.charAt(i)));\n             System.out.print(result[i]);\n        }\n        System.out.print(\"]\");\n        return result;\n    }\n```\n\n### 复杂度\nO(3n)  O(2n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992124867","body":"### 思路\n通过正反两次遍历，每次遍历计算当前char与前一个指定的c的下标差。\n\n### 代码\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int cIndex = -1;\n        for(int i=0; i<s.length(); i++){\n            if(s.charAt(i) == c){\n                result[i]=0;\n                cIndex = i;\n                continue;\n            }\n\n            if(cIndex == -1){\n                result[i]=-1;\n                continue;\n            }else{\n                result[i]=i-cIndex;\n            }\n        }\n\n\n        cIndex = -1;\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i) == c){\n                result[i]=0;\n                cIndex = i;\n                continue;\n            }\n            if(cIndex != -1){\n                int temp = cIndex -i;\n                if(result[i]==-1 || temp < result[i] ){\n                    result[i]=temp;\n                }\n                \n            }\n        }\n\n\n        return result;\n    }\n}\n\n### 复杂度\nO(n) O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993579886","body":"### 思路\n数组模拟栈，用变量记录index，标志栈顶。\n\n### 代码\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n\n### 复杂度\n- push/pop 时间 O(1)\n- increment 时间 O(k)\n- 空间 O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997349916","body":"### 思路\n三个指针，两个指针操作节点调换以及步长2移动，一个指针记录pre节点\n\n### 代码\n```java \nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode tempA = head;\n        ListNode tempB = head.next;\n        ListNode tempC = null;\n\n        head = head.next;\n\n        while(tempA != null && tempB != null){\n            System.out.println(\"tempA: \"+tempA.val+\". tempB: \"+tempB.val);\n\n            tempA.next = tempB.next;\n            tempB.next = tempA;\n\n            if(tempC != null){\n                tempC.next =  tempB;\n            }\n            tempC = tempA;\n\n            tempA = tempA.next;\n            if(tempA != null){\n                tempB = tempA.next;\n            }\n        }\n\n        return head;\n    }\n}\n```\n### 复杂度\n- 时间：O(n) \n- 空间：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darkpmm":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991863806","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len=num.size();\n        vector<int> ans;\n        for(int i=len-1 ; i>=0 ; --i){\n            int sum = num[i]+k%10;\n            k = k/10;\n            if(sum>=10){\n                sum = sum%10;\n                k++;\n            }\n            ans.push_back(sum);\n        }\n        while(k>0){\n            ans.push_back(k%10);\n            k=k/10;\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pf135145":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991864094","body":"### 思路\r\n\r\n因为js在大数计算时有精度问题，因此把每一位单独计算\r\n\r\n把k转化成数组方便计数\r\n\r\n在这里为了方便所以把数组反转了\r\n\r\n考虑首位可能会出现进位问题再单独处理下\r\n\r\n\r\n### 代码\r\n\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let over = false;\r\n  let kArr = k.toString().split('');\r\n  let index = 0;\r\n  let newArr = [];\r\n  num.reverse();\r\n  kArr.reverse();\r\n  while (index < num.length || index < kArr.length) {\r\n      let i = num[index] || 0\r\n      let k = Number(kArr[index]) || 0\r\n      let res = i + k\r\n      if (index > 0 && over) {\r\n          res += 1\r\n      }\r\n      if (res >= 10) {\r\n          over = true;\r\n          newArr.push(res - 10)\r\n      } else {\r\n          over = false;\r\n          newArr.push(res)\r\n      }\r\n      index ++\r\n  }\r\n  if (over) newArr.push(1);\r\n  return newArr.reverse()\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度： o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992271708","body":"### 思路\n\n把长字符串转成数组A\n\n先存储目标字符在数组中出现的位置存储为数组B\n\n循环数组A，对比每项和数组B首个数字的差值，若小于零，则取第二位对比两个差值的绝对值，取小的，注意下是否数组B已取完\n\n### 解题\n\n```js\nvar shortestToChar = function(s, c) {\n  let sArr = s.split('');\n  let tarArr = []\n  sArr.forEach((o, idx) => {\n    if (o === c) tarArr.push(idx)\n  })\n  let newArr = []\n  sArr.forEach((o, idx) => {\n    let tarIdx = tarArr[0]\n    if (idx > tarIdx) {\n      if (tarArr.length ==1 || idx - tarIdx < tarArr[1] - idx) {\n        newArr.push(idx - tarIdx)\n      } else {\n        tarArr.shift()\n        newArr.push(tarArr[0] - idx)\n      }\n    } else {\n      newArr.push(tarIdx - idx)\n    }\n  })\n  return newArr\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)？","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993684809","body":"### 解体\n\n使用数组模拟栈\n\n\n### 代码\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this._stack = [];\n    this._size = maxSize || 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this._stack.length < this._size) {\n        this._stack.push(x)\n    } \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this._stack.length > 0 ? this._stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    this._stack.forEach((o, idx) => {\n        if (idx < k) this._stack[idx] += val\n    })\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994904291","body":"### 解题\n\n使用栈的思想遇到右括号“]”时出栈\n\n\n### 代码\n\n```js\nvar decodeString = function(s) {\n  let start = /^(\\d*)\\[/\n  let end = /^\\]/\n  let str = /^[a-z]+/\n  let stack = []\n  let res = ''\n  let index = 0\n  while(index < 10) {\n    if (start.test(s)) {\n      const res = start.exec(s)\n      console.log(res[0], 'start')\n      s = s.replace(res[0], '')\n      stack.push({\n        type: 'number',\n        val: res[1] || 1\n      })\n      console.log(stack, 'start')\n      continue;\n    }\n    if (str.test(s)) {\n      const res = str.exec(s)\n      console.log(res[0], 'str')\n      s = s.replace(res[0], '')\n      stack.push({\n        type: 'string',\n        val: res[0]\n      })\n      console.log(stack, 'str')\n      continue;\n    }\n    if (end.test(s)) {\n      const res = end.exec(s)\n      console.log(res[0], 'end')\n      s = s.replace(res[0], '')\n      let str = stack.pop().val\n      let before = stack.pop()\n      let num = 1;\n      while(before.type == 'string') {\n        str = before.val + str\n        before = stack.pop()\n      }\n      num = before.val\n      stack.push({\n        type: 'string',\n        val: str.repeat(num)\n      })\n      console.log(stack, 'end')\n      continue;\n    }\n    index ++\n  }\n\n  stack.forEach(o => {\n    res = res + o.val\n  }) \n\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995903676","body":"### 解题\n\n使用两个栈，用于在pop的时候存储数据\n\n\n### 代码\n\n```js\nvar MyQueue = function() {\n  this._stack = []\n  this._mockStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this._stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this._stack.length) {\n    this._mockStack.push(this._stack.pop())\n  }\n  let res = this._mockStack.pop()\n  while (this._mockStack.length) {\n    this._stack.push(this._mockStack.pop())\n  }\n  return res\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this._stack[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this._stack.length === 0\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997221862","body":"### 解题\n\n将链表首位相连，需要挪动的个数转换为需要截断的位置\n\n\n### 代码\n\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n  if (!head.next) {\n    return head\n  }\n  let length = 1\n  let tempHead = head\n  let tempTail = head\n  while (tempTail.next) {\n    tempTail = tempTail.next\n    length ++\n  }\n  let realNum\n  if (k > length) {\n    realNum = length - length % k\n  } else {\n    realNum = length - k\n  }\n  tempTail.next = tempHead\n  let temp = tempHead;\n  while (realNum > 1) {\n    temp = temp.next\n    realNum --\n  }\n  tempHead = temp.next\n  temp.next = null\n  return tempHead\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997402713","body":"### 解题\n\n在奇数位交换cur和next\n\n记录一个pre用于交换位置后修改上一个链表的next\n\n\n### 代码\n\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n  if (!head || !head.next) {\n    return head\n  }\n  let cur = head\n  let pre = null\n  let res = head.next\n  let index = 0;\n  while (cur.next) {\n    if (index % 2 === 0) {\n      let temp = cur.next\n      cur.next = temp.next\n      temp.next = cur\n      if (pre) {\n          pre.next = temp\n      }\n      pre = cur\n    } else {\n      cur = cur.next\n    }\n    index ++\n  }\n  return res\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998885164","body":"### 解题\n\n双指针\n\n### 代码\n\n```js\nvar getIntersectionNode = function(headA, headB) {\n  let a = headA\n  let b = headB\n  let res = null\n  while (a && b) {\n    if (a === b) {\n      res = a\n      break\n    }\n    b = b.next || headA\n    a = a.next || headB\n  }\n  return res\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999681117","body":"### 解题\n\n双指针解决环形链表\n\n### 代码\n\n```js\nvar detectCycle = function(head) {\n    if (head === null || head.next === null) return null;\n    while (head) {\n        if (head.val === 'labuladong') {\n            return head;\n        }\n        head.val = 'labuladong';\n        head = head.next;\n        console.log('aaaa')\n    }\n    return null;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000373273","body":"### 解题\n\n使用数组模拟一个栈，每次获取和更新都把那一项放到栈顶\n\n### 代码\n\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n  this._list = []\n  this.len = capacity\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n  let idx = -1\n  this._list.forEach((item, i) => {\n    if (item.key === key) {\n      idx = i\n    }\n  })\n  if (idx === -1) {\n      console.log(this._list, 'get')\n    return -1\n  } else {\n    let res = this._list.splice(idx, 1)\n    this._list.unshift(res[0])\n    console.log(this._list, 'get')\n    return this._list[0].value\n  }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n  let idx = -1\n  this._list.forEach((item, i) => {\n    if (item.key === key) {\n      idx = i\n      item.value = value\n    }\n  })\n  if (idx === -1) {\n    if (this._list.length < this.len) {\n      this._list.unshift({\n        key: key,\n        value: value\n      })\n    } else {\n      this._list.pop()\n      this._list.unshift({\n        key: key,\n        value: value\n      })\n    }\n  } else {\n    let res = this._list.splice(idx, 1)\n    this._list.unshift(res[0])\n  }\n  console.log(this._list, 'put')\n};\n \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000885726","body":"### 解题\n\n\n### 代码\n\n```js\nvar maxDepth = function(root) {\n    let deep = 0 \n    let maxDeep = 0 \n    function get(root) {\n        if(!root) return\n        deep += 1 \n        maxDeep = deep > maxDeep ? deep : maxDeep \n        get(root.left)\n        get(root.right)\n        deep -= 1 \n    }\n    get(root)\n    return maxDeep\n};\n \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhnn120":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991865405","body":"### 思路\n逐位相加的思路，记录进位数。遍历完k和数组，遍历过程中，数组超出范围时，以0代替当次累加。遍历完毕后，如果存在进位，则将进位数增加到首部。\n### 代码\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  let i = num.length - 1, carry = 0,res = [];\n  while (i >= 0 || k > 0) { \n    let sum = ( i < 0 ? 0 : num[i] ) + k%10 + carry;\n    if (sum >= 10) {\n      carry = 1;\n      sum = sum % 10;\n    } else { \n      carry = 0\n    }\n    res.push(sum)\n    i--;\n    k = parseInt(k/10)\n  }\n  if (carry === 1) { \n    res.push(carry)\n  }\n  return res.reverse();\n};\n```\n### 复杂度\n时间复杂度：O(MAX(M,N)) M 数组长度，N k长度\n\n空间复杂度：O(MAX(M,N)) M 数组长度，N k长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992496590","body":"### 思路\n正反遍历数组，得到两种情况的距离值取最小值。若目标元素下标为pre，则从左到右遍历得到左邻目标元素距离为pre-i，从右到左遍历的得到右邻目标元素距离为i-pre。注意两次pre的初始值，由于数组长度在1到10^4。取初始值为±(10^4+1),使不存在目标元素时值为最大。\n### 代码\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function(s, c) {\n  const length = s.length,result = [];\n  let pre = -Math.pow(10,4) - 1\n  for(let i = 0; i < length; i++){\n    if(s[i] === c){\n      pre = i\n    }\n    result.push(i-pre)\n  }\n  pre = Math.pow(10,4) + 1\n  for(let i = length-1; i >=0; i--){\n    if (s[i] === c) { \n      pre = i\n    }\n    let range = pre - i;\n    if (result[i] > range) {\n      result[i] = range\n    }\n  }\n  return result;\n};\n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993532681","body":"### 思路\n通过数组模拟栈的操作。由于栈的特性，只有数据在出栈时，才会获取到其真正的值。因此对于增量操作采用辅助数组记录下增量值，在出栈时再进行累加，将增量操作的时间复杂度从O(N)将为O(1)\n### 代码\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n  this.add = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length < this.maxSize){\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if(this.stack.length === 0){\n    return -1\n  }\n  let index = this.stack.length - 1\n  let rest = this.add[index] || 0\n  this.add[index] = 0;\n  if (rest) {\n    this.add[index-1] = rest + (this.add[index-1] || 0);\n  }\n  return this.stack.pop() + rest;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  k = Math.min(this.stack.length, k)\n  if(k > 0){\n    this.add[k-1] = val + (this.add[k-1] || 0)\n  }\n};\n```\n### 复杂度\n时间复杂度：O(1)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994841593","body":"### 思路\n通过栈来进行[]的匹配，逐个遍历，当前字符不为]的进行入栈操作，否则一直出栈直到遇到[字符。如果下一位是数字则遍历直到非数字后进行重复字符串生成，将字符串入栈直到遍历完整个字符串，将栈中元素拼接返回\n### 代码\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let len = s.length; stack = []\n  for(let i = 0; i < len; i++){\n    if(s[i] !== ']'){\n      stack.push(s[i])\n    } else {\n      let c = stack.pop()\n      let str = \"\"\n      while(c !== '['){\n        str = c + str \n        c = stack.pop()\n      }\n      let last = stack[stack.length - 1]\n      if(!Number.isNaN(parseInt(last))) {\n        stack.pop()\n        while(!Number.isNaN(parseInt(stack[stack.length - 1]))){\n          last = stack.pop() + last\n        }\n        let result = \"\"\n        for(let j = 0; j < last; j++){\n          result += str\n        }\n        stack.push(result)\n      } else {\n        stack.push(str)\n      }\n    }\n  }\n  return stack.join(\"\");\n};\n```\n### 复杂度\n空间复杂度 O(N)\n时间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995864050","body":"### 思路\n通过栈来模拟队列操作一般情况下在每次pop和peek操作时，需要将所有的元素出栈才能返回目标元素，通过一个缓存栈来将pop和peek操作时出栈的元素依次入栈。此时缓存栈栈顶元素即为队列头部元素。后续pop和peek操作时，如果缓存栈中存在元素，则对缓存栈进行出栈操作，如果不存在元素则对原本的栈内所有元素进行出栈操作保持到缓存栈中。\n### 代码\n```\nvar MyQueue = function() {\n  this.stack = []\n  this.cacheStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (this.cacheStack.length === 0) { \n    let c = this.stack.pop()\n    while (c) { \n      this.cacheStack.push(c);\n      c = this.stack.pop();\n    }\n  }\n  return this.cacheStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (this.cacheStack.length === 0) { \n    let c = this.stack.pop()\n    while (c) { \n      this.cacheStack.push(c);\n      c = this.stack.pop();\n    }\n  }\n  return this.cacheStack[this.cacheStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.cacheStack.length === 0 && this.stack.length === 0\n};\n```\n### 复杂度\n时间复杂度：O(1)，所有元素都只进行两次入栈和两次出栈操作\n空间复杂度：O(N), 两个栈的长度等于目标队列长度","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998022570","body":"### 思路\n思路通过快慢指针在链表中查找中间节点作为二叉树的根，左右链表递归求的左右子树\n### 代码\n```\nvar sortedListToBST = function (head) {\n    if (!head) return null;\n    return dfs(head, null);\n};\n\nvar dfs = (head, tail) => {\n    if (head === tail) return null;\n    let fast = head;\n    let slow = head;\n    while (fast !== tail && fast.next !== tail) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    let root = new TreeNode(slow.val, dfs(head, slow), dfs(slow.next, tail));\n    return root;\n}\n```\n### 复杂度\n时间复杂度：O(nlogn)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998821762","body":"### 思路\n双指针分别遍历两个链表，遍历到头后，指向另一个链表头部继续遍历。如果两个指针相遇则为相交点，否则两个链表不相交\n### 代码\n```\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n  let i = headA, j = headB;\n  while (i && j) { \n    i = i.next;\n    j = j.next;\n  }\n  if (!i) { \n    i = headB\n  }\n  if (!j) { \n    j = headA\n  }\n  while (i && j) { \n    i = i.next;\n    j = j.next;\n  }\n  if (!i) { \n    i = headB\n  }\n  if (!j) { \n    j = headA\n  }\n  while ((i !==j) && i && j) { \n    i = i.next;\n    j = j.next;\n  }\n  return i\n};\n```\n### 复杂度\n时间复杂度：O(m+n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999663646","body":"### 思路\r\n快慢指针的思想, 快指针每次移动两个节点，慢指针每次移动一个节点。如果存在环则快慢指针必定相遇。则将链表分为三段，从链表头部到环开始节点的长度记为a, 环开始节点到快慢指针相遇点长度记为b，快慢指针相遇点到链表末尾节点长度记为c。那么慢指针所走长度为a+b，快指针所走长度为a+2b+c。又由于快指针所走路径为慢指针的2倍，因此2(a+b) = a + 2b +c。因此a和c的长度相等，所以新指针从链表头部开始移动，慢指针从相遇点继续移动，两者会在环开始节点相遇。\r\n### 代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  if (head === null) {\r\n      return null;\r\n  }\r\n  let slow = head, fast = head;\r\n  while (fast !== null) {\r\n      slow = slow.next;\r\n      if (fast.next !== null) {\r\n          fast = fast.next.next;\r\n      } else {\r\n          return null;\r\n      }\r\n      if (fast === slow) {\r\n          let ptr = head;\r\n          while (ptr !== slow) {\r\n              ptr = ptr.next;\r\n              slow = slow.next;\r\n          }\r\n          return ptr;\r\n      }\r\n  }\r\n  return null;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000334593","body":"### 思路\n通过hashMap和双链表实现，get操作时如果Map中存在则，将节点移动到头部。put操作时，如果节点存在则将节点移动到头部；否则判断是否越界，越界则移除链表末尾节点。将该节点插入到头部\n### 代码\n```\n// 链表节点\nclass Node{\n  constructor(key,val){\n      this.key = key;\n      this.val = val;\n  }\n}\n// 双链表\nclass DoubleList{\n  // 初始化头、尾节点、链表最大容量\n  constructor(){\n      this.head = new Node(0,0);\n      this.tail = new Node(0,0);\n      this.size = 0;\n      this.head.next = this.tail;\n      this.tail.prev = this.head;\n  }\n  // 在链表头部添加节点\n  addFirst(node){\n      node.next = this.head.next;\n      node.prev = this.head;\n      this.head.next.prev = node;\n      this.head.next = node;\n      this.size++;\n  }\n  // 删除链表中存在的node节点\n  remove(node){\n      node.prev.next = node.next;\n      node.next.prev = node.prev;\n      this.size--;\n  }\n  // 删除链表中最后一个节点，并返回该节点\n  removeLast(){\n      // 链表为空\n      if(this.tail.prev == this.head){\n          return null;\n      }\n      let last = this.tail.prev;\n      this.remove(last);\n      return last;\n  }\n}\n/**\n* @param {number} capacity\n*/\nvar LRUCache = function(capacity) {\n  this.cap = capacity;\n  this.map = new Map();\n  this.cache = new DoubleList();\n};\n\n/** \n* @param {number} key\n* @return {number}\n*/\nLRUCache.prototype.get = function(key) {\n  let map = this.map;\n  if(!map.has(key)){\n      return -1;\n  }\n  let val = map.get(key).val;\n  // 最近访问数据置前\n  this.put(key,val);\n  return val;\n};\n\n/** \n* @param {number} key \n* @param {number} value\n* @return {void}\n*/\nLRUCache.prototype.put = function(key, value) {\n  let cache = this.cache;\n  let map = this.map;\n  let node = new Node(key,value);\n  if(map.has(key)){\n      // 删除旧的节点，新的插到头部\n      cache.remove(map.get(key));\n  }else{\n      if(this.cap == cache.size){\n          // 删除最后一个\n          let last = cache.removeLast();\n          map.delete(last.key);\n      }\n  }\n  // 新增头部\n  cache.addFirst(node);\n  // 更新 map 映射\n  map.set(key,node);\n};\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"demo410":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991866798","body":"#### 思路\r\n\r\n* 从后往前遍历num数组，同时通过取余获得K的最后一位数，将两个数相加，注意进位。如果两个数的位数不一致，通过补0来继续相加。\r\n\r\n#### 代码\r\n\r\n```java\r\npublic static List<Integer> addToArrayForm(int[] num, int k) {\r\n        Stack<Integer> result = new Stack<>();\r\n        List<Integer> finalResult = new ArrayList<>();\r\n        int l = num.length;\r\n        boolean carry  = false;\r\n\r\n        while (l != 0 || k != 0){\r\n            int a = 0, b = k % 10;\r\n\r\n            if(l != 0) a = num[--l];\r\n\r\n            k /= 10;\r\n\r\n            int c = a + b;\r\n\r\n            if(carry) {\r\n                c += 1;\r\n                carry = false;\r\n            }\r\n\r\n            if(c >= 10) carry = true;\r\n            result.push(c % 10);\r\n        }\r\n\r\n        if (carry) result.push(1);\r\n        while (!result.empty()) finalResult.add(result.pop());\r\n        return result;\r\n    }\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：时间复杂度主要取决于数组的长度N和K的位数，即O(max(N, len(k)))\r\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992158995","body":"### 思路\n\n* l指向数组中左侧的c的位置，r指向数组中右侧c的位置，计算`Math.min(r - i, i - l)`,注意边界情况\n\n### 代码\n\n```java\n    public static int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int l = 0, r = 0;\n\n        while (r != s.length()) {\n\n            for (r = l + 1; r < s.length(); r++) {\n                if (s.charAt(r) == c) break;\n            }\n\n            for (int i = l; i < r; i++) {\n                if (l == 0 && s.charAt(0) != c) result[i] = r - i;\n\n                else if (r == s.length() && s.charAt(r - 1) != c) result[i] = i - l;\n\n                else {\n                    result[i] = Math.min(r - i, i - l);\n                }\n            }\n\n            l = r;\n        }\n        return result;\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993130891","body":"### 思路\n\n* 维护一个diff数组，diff[min(K, maxSize)] 代表对数组的前多少个元素相加，在pop的时候将diff数组中的值与栈顶的值相加\n\n### 代码\n\n```java\n  private final int[] innerStack;\n    private final int[] diff;\n    private final int maxSize;\n    private int length;\n\n    public CustomStack(int maxSize) {\n        this.innerStack = new int[maxSize];\n        this.diff = new int[maxSize];\n        this.maxSize = maxSize;\n        this.length = 0;\n    }\n\n    public void push(int x) {\n        if (this.length == this.maxSize) return;\n\n        this.innerStack[this.length++] = x;\n\n    }\n\n    public int pop() {\n        if (this.length == 0) return -1;\n        int res = innerStack[this.length - 1] + diff[this.length - 1];\n\n        if (this.length > 1){\n            diff[this.length - 2] += diff[this.length - 1];\n        }\n        diff[--this.length] = 0;\n\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int maxInc = Math.min(k, this.length);\n        if (this.length > 0)\n            diff[maxInc - 1] += val;\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：pop、push、increment都是O(1)\n* 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994565283","body":"### 思路\n\n* 如果遇到 ']'，就一直在栈中找到 '['，将之间的字符连接起来，将 '['前面的数字连接起来作为出现次数再次压栈，遇到数字、字母、'['就直接压栈，最后将栈里的字符串弹出连接起来\n\n### 代码\n\n```java\n public static String decodeString(String s) {\n        LinkedList<String> repeatFrag = new LinkedList<>();\n        LinkedList<String> repeatNumStr = new LinkedList<>();\n        Stack<String> stack = new Stack<>();\n        StringBuilder builder = new StringBuilder();\n\n        int repeat = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == ']') {\n                String c = stack.pop();\n                while (!c.equals(\"[\")) {\n                    repeatFrag.addFirst(c);\n\n                    c = stack.pop();\n                }\n\n                c = stack.peek();\n\n                while (Character.isDigit(c.charAt(0))) {\n                    repeatNumStr.addFirst(String.valueOf(stack.pop()));\n\n                    if (stack.isEmpty()) break;\n                    c = stack.peek();\n                }\n\n                repeat = Integer.parseInt(String.join(\"\", repeatNumStr));\n\n                for (int j = 0; j < repeat; j++) {\n                    stack.addAll(repeatFrag);\n                }\n\n                repeatNumStr.clear();\n                repeatFrag.clear();\n            } else {\n                stack.push(String.valueOf(s.charAt(i)));\n            }\n        }\n\n        return String.join(\"\",stack);\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995374074","body":"### 思路\n\n* 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n* push的时候，如果stackout为空，是则直接push到stackin中。否则，将stackout中的元素全pop到stackin中再将x push到栈中\n* pop的时候，判断stackin是否为空，是则直接pop stackout中的元素、否则，将stackin中的元素全pop到stackout中，然后再将stackout中的栈顶元素pop出来\n\n### 代码\n\n```java\n private Stack<Integer> stackIn;\n    private Stack<Integer> stackOut;\n\n\n    public MyQueue() {\n        stackIn = new Stack<>();\n        stackOut = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stackOut.isEmpty()) {\n            stackIn.push(x);\n        } else{\n          while (!stackOut.isEmpty()){\n              stackIn.push(stackOut.pop());\n          }\n          stackIn.push(x);\n        }\n    }\n\n    public int pop() {\n        \n        if (stackIn.isEmpty()) return stackOut.pop();\n\n        else{\n            while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n            return stackOut.pop();\n        }\n    }\n\n    public int peek() {\n        if (stackIn.isEmpty()) return stackOut.peek();\n\n        else{\n            while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n            return stackOut.peek();\n        }\n    }\n\n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：每个操作均摊时间复杂度为 `O(1)` ，执行 `n` 个操作的总时间复杂度为 `O(n)`\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996826752","body":"### 思路\n\n* 把数组中的元素插到栈里面，{2,1,3,4,4}，这样一个数组，2，入栈，1入栈比2小，它俩就属于同一个块\n* 这样栈中就是{1,2}，3比2大，那么3就得重开一个块\n* 就是{1,2} {3},4大于3，单独开个块，同理就是{1,2}，{3}，{4}，{4}\n* 判断，如果当前块的最后一个元素，比前一个块的最大元素要小，这两个块就要合并\n* 就是，每次新产生一个块的时候，都要判断，当前块的最后一个元素，是不是比前一个块的最大的元素，要大\n\n### 代码（不是自己写的）\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            \n            if (!stack.isEmpty() && num < stack.getLast()) {\n                \n                int cur = stack.removeLast();\n                \n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        \n        return stack.size();\n    }\n```\n\n\n\n### 复杂度\n\n* 时间复杂度O（N）\n* 空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997179449","body":"### 思路\n\n* 快慢指针，找到倒数第k个节点，然后将第k个节点后面的链表拼到前面就行了\n* 如果k > 链表的长度，这里我实现的不好，导致时间复杂度变成了O(k)\n\n### 代码\n\n```java\n    public static ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n\n        ListNode pre = head;\n        ListNode cur = head;\n\n        for (int i = 0; i < k; i++) {\n\n            if(cur == null) cur = head;\n\n            cur = cur.next;\n        }\n\n\n        while (cur.next != null) {\n            pre = pre.next;\n            cur = cur.next;\n        }\n        \n        ListNode tmp = cur;\n        cur = pre.next;\n\n        pre.next = null;\n        tmp.next = head;\n\n        return cur;\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：O(k)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997382857","body":"#### 思路\n* 想的麻烦了，用了四个指针\n#### 代码\n```java\n public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode pre;\n        ListNode cur = head;\n        ListNode tmp;\n        ListNode last = head;\n\n\n        head = head.next;\n        while(cur != null){\n            pre = cur;\n            cur = pre.next;\n\n            if (cur == null){\n                last.next = pre;\n                last = pre;\n                continue;\n            }else{\n                last.next = cur;\n                last = pre;\n            }\n            tmp = cur.next;\n\n            cur.next = pre;\n\n            cur = tmp;\n        }\n\n        last.next = null;\n\n        return head;\n    }\n```\n\n### 复杂度\n* 时间复杂度： O(N)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998031793","body":"### 思路\n* 快慢指针，slow指针走到中间，fast指针走到最后。然后用中间节点当作根节点\n* 递归\n### 代码\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n\n        return dfs(head, null);\n    }\n\n    public TreeNode dfs(ListNode head, ListNode tail){\n        if(head == tail) return null;\n\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        TreeNode n = new TreeNode(slow.val);\n\n        n.left = dfs(head, slow);\n        n.right = dfs(slow.next, tail);\n\n        return n;\n    }\n```\n### 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度: O(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999626362","body":"### 思路\n* 来自官方题解\n### 代码\n```java\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                fast = head;\n                break;\n            }\n        }\n        if(fast == null || fast.next == null) return null;\n        \n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n```\n### 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000390931","body":"```java\n\nclass LRUCache {\n    private class Node{\n        int value;\n        int accessCount;\n\n        Node(int v){\n            value = v;\n            accessCount = 0;\n        }\n    }\n    private final Map<Integer, Node> cache ;\n\n\n    public LRUCache(int capacity) {\n        cache = new LinkedList<>();\n    }\n    \n    public int get(int key) {\n        if(cache.size() == 0)  return -1;\n        Node n = cache.get(key);\n\n        if(n != null){\n            n.accessCount++;\n            return n.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        int minAccessCount;\n        int removeKey;\n\n        if(cache.size() == capacity){\n            Iterator<Integer> iter = cache.keySet().iterator();\n            removeKey = iter.next();\n            minAccessCount = cache.get(removeKey).accessCount;\n            \n            while (iter.hasNext()){\n                Integer cur = iter.next();\n                Node n = cache.get(cur);\n\n                if(n.accessCount == 0){\n                    removeKey = cur;\n                    break;\n                }else if(n.accessCount < minAccessCount){\n                    minAccessCount = n.accessCount;\n                    removeKey = cur;\n                }\n            }\n\n            cache.remove(removeKey);\n        }\n\n        cache.put(key, new Node(value));\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000799227","body":"### 思路\n* 递归\n### 代码\n```java\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return 1;\n\n        int left = 1 + maxDepth(root.left);\n        int right = 1 + maxDepth(root.right);\n\n        return Math.max(left, right);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000987991","body":"### 思路\n* 递归\n\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n\n        else if(p == null || q == null) return false;\n\n        boolean cur = p.val == q.val;\n\n        boolean left = isSameTree(p.left, q.left);\n        boolean right = isSameTree(p.right, q.right);\n\n        return cur && left && right;\n    }\n```\n###复杂度\n* 空间复杂度：O(min(logm, logn))\n* 时间复杂度：O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"didiyang4759":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991867259","body":"思路：\r\nA 的当前位 + B 的当前位 + 进位， 最后判断是否还有进位\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int n = A.length;\r\n        List<Integer> res = new ArrayList<>(); \r\n        int i = n - 1, sum = 0, carry = 0;\r\n        while (i >= 0 || K != 0) {  \r\n            int x = i >= 0 ? A[i]: 0;\r\n            int y = K != 0 ? K % 10 : 0;              \r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n            i--;\r\n            res.add(0, sum % 10);\r\n        }\r\n        if (carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993216884","body":"class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997333171","body":"class Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998493714","body":"## 参考官网解\r\n### 双指针\r\n#### 判断链表 A，B 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回null。\r\n\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n## 复杂度\r\n时间复杂度O（m+n）\r\n空间复杂度O（1）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000087369","body":"#### 参考官方题解\r\n\r\n```\r\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity; \r\n    }\r\n}\r\n```\r\n\r\n#### 时间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000650723","body":"思路：\r\n\r\nDFS搜索最深层，根节点最大深度 = max(左子树深度,右子树深度) + 1\r\n\r\n题解：\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null){\r\n         return 0;   \r\n        }\r\n        else{\r\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n        }\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000988232","body":"参考官方解\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzrebas":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991867485","body":"# Day 1-[989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n## 思路\n遍历数组A，取出每个元素转换为字符串，再拼在一起，然后转为int整形，再与整数K相加，得出的结果再转为字符串，再遍历每一个元素输出到新的数组中。\n\n\n## 代码(python)\n```python\ndef fun(A,K):\n    a=''.join(str(x) for x in A)\n    b=int(a)+K\n    out=[]\n    for i in str(b):\n        out.append(int(i))\n    print(out)\n\nA = [1,2,0,0]\nK = 34\nfun(A,K)    #[1, 2, 3, 4]\nfun(A = [2,7,4], K = 181)   #[4, 5, 5]\nfun(A = [2,1,5], K = 806)   #[1, 0, 2, 1]\nfun(A = [9,9,9,9,9,9,9,9,9,9], K = 1)   #[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\n## 复杂度\n**时间复杂度：** O(n)，n为数组A的长度。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992248450","body":"### 思路\n1. 先找到字符C在字符串S中的所有的索引位置。\n2. 构建一个新的数组，数组长度为len(S)，对应所有C的索引位置设为0，其他元素先设为None。\n3. 再根据C的索引在对应新数组中0的位置进行排序：\n    - 最左边的0，向左排序\n    - 最右边的0，向右排序\n    - 中间位置的0，向两个0的中间排序\n\n### 代码(Python)\n```python\ndef fun(S,C):\n    C_index=[]\n    out_list=[]\n    for n,i in enumerate(S):\n        out_list.append(None)\n        if i ==C:\n            C_index.append(n)\n            out_list[n]=0\n\n    #从第一个字符C向左排序\n    for n,i in enumerate(range(C_index[0]+1)[::-1]):\n        out_list[n]=i\n    # print(out_list)   #[3, 2, 1, 0, None, 0, 0, None, None, None, None, 0, None, None]\n\n    #从最后一个字符C向右排序\n    for n,i in enumerate(out_list[C_index[-1]:]):\n        out_list[C_index[-1]+n]=n\n    # print(out_list)     #[3, 2, 1, 0, None, 0, 0, None, None, None, None, 0, 1, 2]\n\n    #中间的字符C,向两个C的中间排序\n    for i in range(len(C_index)-1):\n        subtract=C_index[i+1]-C_index[i]\n        if subtract%2==0:\n            division=subtract//2\n        else:\n            division=(subtract-1)//2\n        for j in range(1,division+1):\n            out_list[C_index[i]+j]=j\n            out_list[C_index[i+1]-j]=j\n\n    print(out_list)\n\nS = \"loveleetcodedf\"\nC = 'e'\nfun(S,C)    #[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0, 1, 2]\n```\n\n### 复杂度分析\n- 时间复杂度： \n- 空间复杂度：\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993519056","body":"### 思路\n在python代码中，可使用list模拟栈，入栈为``list.append()``，出栈为``list.pop()``，切片可修改栈底元素。\n\n\n### 代码(Python)\n```python\nclass CustomStack():\n    def __init__(self,maxSize:int):     #初始化\n        self.maxSize=maxSize\n        self.customstack=[]\n\n    def push(self,x:int):\n        if len(self.customstack)==self.maxSize:\n            # print('已超出栈中最多能容纳的元素数量，无法再增加')\n            pass\n        else:\n            self.customstack.append(x)  #入栈\n\n    def pop(self):\n        if self.customstack==[]:\n            return -1\n        else:\n            stack_top=self.customstack[-1]\n            self.customstack.pop()  #出栈\n            return stack_top    #返回出栈的元素\n\n    def increment(self,k:int,val:int):\n        if len(self.customstack)>=k:   #注意，这里需要对比k与当前栈实际的长度，而不是与栈的最大长度maxSize对比\n            for i in range(k):\n                self.customstack[i]+=val\n        else:\n            self.customstack=[self.customstack[i]+val for i in range(len(self.customstack))]\n\n\ndef obj_API(A,B):\n    C=[]\n    obj=CustomStack(B[0][0])\n    for i in range(len(A)):     #循环A、B，依次进行对应操作\n        if i==0:\n            C.append(None)\n        else:\n            if A[i]=='push':\n                obj.push(B[i][0])\n                C.append(None)\n            elif A[i]=='pop':\n                C.append(obj.pop())\n            elif A[i]=='increment':\n                obj.increment(B[i][0],B[i][1])\n                C.append(None)\n        # print('i:',i,C,obj.customstack)\n    print(C)\n\n\nA=[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\nB=[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n\nobj_API(A,B)    #[None, None, None, 2, None, None, None, None, None, 103, 202, 201, -1]\n\n\n```\n\n### 复杂度分析\n- 时间复杂度：\n- 空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994328303","body":"### 思路\r\n用栈的方式记录字符串元素，因为左右括号的读取是先进后出的顺序\r\n依次遍历字符串中的元素，不是右括号就添加到栈，是右括号就把离栈顶最近的左括号到栈顶的元素取出来处理\r\n解题方法类似于中缀表达式转波兰表达式\r\n\r\n\r\n### 代码(Python)\r\n```python\r\ndef str_decode(s):\r\n    stack=[]\r\n    for i in range(len(s)): #遍历字符串s\r\n        if s[i] != ']':     #如果不为’]‘就添加到栈stack\r\n            stack.append(s[i])\r\n        else:               #为’]‘，就更新栈：从离栈顶最近的'['到栈顶\r\n            end_bracket_index=len(stack)-1-stack[-1::-1].index('[')   #获取离栈顶最近的'['的索引\r\n            end_num=stack[end_bracket_index-1]    #获取离栈顶最近的'['的前面数字的索引\r\n            stack_tail=stack[end_bracket_index+1:]    #获取离栈顶最近的'['到栈顶内的元素\r\n            for n in stack_tail:    #离栈顶最近的'['到栈顶内的元素不能有数字\r\n                if n.isdigit():\r\n                    return '输入错误'\r\n            if not end_num.isdigit():   #左括号前面一定有数字\r\n                return '输入错误'\r\n            stack=stack[:end_bracket_index-1]+(stack_tail*int(end_num))   #更新栈\r\n    return ''.join(x for x in stack)\r\n\r\ns1 = \"3[a]2[bc]\"\r\ns2 = \"3[a2[c]]\"\r\ns3 = \"2[abc]3[cd]ef\"\r\ns4 = \"abc3[cd]xyz\"\r\nprint(str_decode(s1))   #aaabcbc\r\nprint(str_decode(s2))   #accaccacc\r\nprint(str_decode(s3))   #abcabccdcdcdef\r\nprint(str_decode(s4))   #abccdcdcdxyz\r\n\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N),N为字符串s的长度。\r\n- 空间复杂度：\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995618392","body":"### 思路\r\n在python中，可用list模拟队列。或者用模块collections.deque。\r\n但要用栈的方式实现队列查看队首元素和删除队首元素，需2个栈，一个存栈的输入，一个存栈的输出。\r\n\r\n\r\n### 代码(Python)\r\n```python\r\nclass MyQueue():\r\n    def __init__(self):\r\n        self.queue=[]\r\n        self.out_queue=[]\r\n\r\n    def push(self,x:int):\r\n        self.queue.append(x)    #尾部插入\r\n        print('queue:',self.queue)\r\n\r\n    def stack_exchange(self,x:list,y:list): #输入栈与输出栈交换\r\n        while x != []:    #循环遍历x的栈顶，依次取出存入y栈中\r\n            stack_top=x.pop()      #x删除栈顶，并返回删除的值\r\n            y.append(stack_top)    #y插入x删除的栈顶\r\n\r\n    def empty(self):    #判断队列是否为空\r\n        if self.queue == []:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    def peek(self):\r\n        if self.empty() == True:\r\n            print(f'空栈，{self.__class__.__name__}.peek操作无效')\r\n        else:\r\n            self.stack_exchange(self.queue,self.out_queue)  #交换栈\r\n            print(self.out_queue[-1])   #返回栈顶\r\n            self.stack_exchange(self.out_queue,self.queue)  #再交换回去，还原\r\n            # print('queue:',self.queue)\r\n\r\n    def pop(self):\r\n        if self.empty() == True:\r\n            print(f'空栈，{self.__class__.__name__}.pop操作无效')\r\n        else:\r\n            self.stack_exchange(self.queue,self.out_queue)  #交换栈\r\n            print(self.out_queue.pop())    #删除输出栈的栈顶\r\n            self.stack_exchange(self.out_queue,self.queue)  #再交换回去，还原，此时已删除输入栈的栈顶\r\n            # print('queue:',self.queue)\r\n\r\n\r\nmy_queue=MyQueue()\r\nmy_queue.push(1)    #queue: [1]\r\nmy_queue.push(2)    #queue: [1, 2]\r\nmy_queue.peek()     #1\r\nmy_queue.pop()          #1\r\nprint(my_queue.queue)   #[2]\r\nprint(my_queue.empty()) #False\r\nmy_queue.pop()          #2\r\nprint(my_queue.empty()) #True\r\nprint(my_queue.queue)   #[]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N),N为队列的长度。\r\n- 空间复杂度：\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996779478","body":"### 思路\r\n使用类似计数排序的技巧来完成\r\n\r\n\r\n### 代码(Python)\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： O(n**2)。\r\n- 空间复杂度：\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997208549","body":"### 思路\n在python中，可用字符串当作输入，然后转出list，再循环k遍，即向右旋转k次。\n\n\n### 代码(Python)\n```python\ndef fun(chain,k):\n    linked=chain.replace('->NULL','').split('->')\n    i=0\n    while i<k:\n        linked.insert(0,linked.pop())\n        i+=1\n    print('->'.join(linked)+'->NULL')\n\nchain='1->2->3->4->5->NULL'\nk = 2\nfun(chain,k)    #4->5->1->2->3->NULL\nchain='0->1->2->NULL'\nk = 4\nfun(chain,k)    #2->0->1->NULL\n```\n\n### 复杂度分析\n- 时间复杂度： O(N)，N为旋转的次数k。\n- 空间复杂度：\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997987731","body":"### 思路\n二叉搜索树的任意一个节点，当前节点的值必然大于所有左子树节点的值。同理,当前节点的值必然小于所有右子树节点的值.\n用快慢指针找到链表的中值。以链表中点为根，中点左边的值都小于它,可以构造左子树，同理构造右子树。\n\n\n### 代码(Python)\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n### 复杂度分析\n- 时间复杂度： O(N)，N为链表长度。\n- 空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998850532","body":"### 思路\n双指针\n\n使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\n### 代码(Python)\n```python\nclass ListNode(object):\n    def __init__(self,data,next=None):\n        self.data=data\n        self.next=next\n\nclass LinkedList():\n    def fun(self,a,b):\n        a=a.head\n        b=b.head\n        while a != b:\n            a= a.next if a else b.head\n            b= b.next if b else a.head\n        return a\n\n\n```\n\n### 复杂度分析\n- 时间复杂度： O(N)。\n- 空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999678808","body":"### 思路\r\n双指针\r\n\r\n定义一个 fast 指针,每次前进两步,一个 slow 指针,每次前进一步。\r\n当两个指针相遇时，将 fast 指针重定位到链表头部,同时 fast 指针每次只前进一步；\r\nslow 指针继续前进,每次前进一步；\r\n当两个指针再次相遇时,当前节点就是环的入口\r\n\r\n### 代码(Python)\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        x = None\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                x = fast\r\n                break\r\n        if not x:\r\n            return None\r\n        slow = head\r\n        while slow != x:\r\n            slow = slow.next\r\n            x = x.next\r\n        return slow\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： O(N)。\r\n- 空间复杂度：\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000371959","body":"### 思路\r\npython字典\r\n\r\n### 代码(Python)\r\n```python\r\nclass LRUCache(object):\r\n    def __init__(self,capacity:int):\r\n        self.capacity=capacity\r\n        self.dd={}\r\n    def get(self,key):\r\n        if key in self.dd.keys():\r\n            return self.dd[key]\r\n        else:\r\n            return -1\r\n\r\n    def put(self,key,value):\r\n        if key in self.dd.keys():\r\n            self.dd[key]=value\r\n        else:\r\n            if len(self.dd)==self.capacity:\r\n\r\n                self.dd.pop(key)\r\n            else:\r\n                self.dd[key]=value\r\n\r\n\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： O(N)。\r\n- 空间复杂度：\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000879554","body":"### 思路\r\n递归\r\n\r\n### 代码(Python)\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n\r\ntree= [3,9,20,None,None,15,7]\r\n#假设二叉树是完整的数组，如上，没有子节点就用None补空位，它的长度既是完整的长度，且为奇数。\r\n#设它的层数为n，则求n：\r\nlength=len(tree)\r\ndef fun(n):\r\n    if n==1: return 1\r\n    return 1 + fun((n-1)/2)\r\nprint('二叉树的层数为',fun(length))\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： O(N)，N为节点数。\r\n- 空间复杂度：\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001027920","body":"### 思路\r\n递归\r\n\r\n### 代码(Python)\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： O(N)，N为节点数。\r\n- 空间复杂度：\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991868483","body":"\n思路：\n-\n按位相加，长度先以已知数组为标准处理\n\n\n代码\n-\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       \n  \n       int i = 0;\n       int sum = 0;\n       vector<int> res;\n       if(k == 0)return num;\n       for(i = num.size()-1;(i>=0);--i)\n       {\n           sum = num[i] + k%10;\n           k = k/10;\n           if(sum >= 10 ){\n               k = k + 1;\n               sum = sum - 10;\n           }\n           res.push_back(sum);\n       }\n        for(;k>0;k = k/10) {\n    \n               res.push_back(k%10);\n          \n        }\n        reverse(res.begin(),res.end());\n       return res;\n    }\n};\n\n\n复杂度分析\n-\n\n空间复杂度：O(n)\n\n\n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992577643","body":"### 思路\n\n题目是计算到指定字符的绝对距离，考虑到字符有在左边，有在右边，即从左开始遍历，有从右开始遍历，遍历中取两者最小值即求解\n\n当从左开始遍历，没有找到字符默认距离为字符串长度\n当从右开始遍历，为保持没找到时为最大值，设置为字符串的2倍(确保第一个没找到，值为保持字符串长度)\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        int len = s.size();\n        int i;\n        int p_match = -len;\n        \n        vector<int> res(len,len);\n        for(i = 0;i<len;i++) {\n            if(s[i]==c)p_match = i;\n            res[i] = min(res[i],i-p_match);\n        }\n        int rlen = 2*len;\n        for(i = len-1;i>=0;i--) {\n            if(s[i]==c)rlen = i;\n            res[i] = min(res[i],rlen-i);\n        }\n        cout<<res[0];\n        return res;\n    }\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993590949","body":"### 思路\n\n用数组模拟\n\n### 代码\n\n\n```cpp\nclass CustomStack {\npublic:\n    int top = -1;//初始值的栈底下面即-1（0开始才有数据，再下面为-1）\n    vector<int> v; \npublic:\n    CustomStack(int maxSize) {\n        v.resize(maxSize);\n    }\n    \n    void push(int x) {\n        \n        if(top+2 <= v.size())//必须加上判断，不然会数组越界，初始top==-1,总长度为top+1（top为数据下标，加1为真实长度  这里为2是因为下面还要自加1\n        v[++top] = x;\n    }\n    \n    int pop() {\n        if(top == -1)return -1;\n        return v[top--];\n        \n    }\n    \n    void increment(int k, int val) {\n        int i;\n        for(i = 0;i < min(k,top+1);i++)\n                v[i] = v[i] + val;\n\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994884112","body":"### 思路\n\n[]用栈\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n\n    string decodeString(string s) {\n        int len = s.size();\n        int num = 0;\n        stack<int> numstack;\n        stack<string> strstack;\n        string cur = \"\";\n        string result = \"\";\n        for(int i=0; i<len; ++i)\n        {\n            if(s[i]>='0' && s[i]<='9')\n            {\n                num = 10*num + s[i] - '0';\n            }\n            else if(s[i] == '[')\n            {\n                numstack.push(num);\n                strstack.push(cur);\n                num = 0;\n                cur.clear();\n            }\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\n                cur += s[i];\n            else if(s[i] == ']')\n            {\n                int k = numstack.top();\n                numstack.pop();\n                for(int j=0; j<k; ++j)\n                    strstack.top() += cur;\n                cur = strstack.top();\n                strstack.pop();\n            }\n        }\n        result = result + cur;\n        return result;     \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995884441","body":"### 思路\n\n用采用两个栈，一个栈输入，一个栈输出\n\n### 代码\n\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> sIn;\n    stack<int> sOut;\npublic:\n    MyQueue() {\n        sIn =  stack<int>();\n        sOut =  stack<int>();\n    }\n    \n    void push(int x) {        \n        sIn.push(x);\n        \n    }\n    \n    int pop() {\n        \n        if(sOut.empty()) {//如果输出栈为空，则从输入栈中取数据\n          \n                while(!sIn.empty())\n                {\n                sOut.push(sIn.top());\n                sIn.pop();\n                }\n           \n        }   \n        int result = sOut.top();\n        sOut.pop();\n        return result;\n\n            \n    }\n    \n    int peek() {\n        if(sOut.empty()) {//如果输出栈为空，则从输入栈中取数据\n          \n                while(!sIn.empty())\n                {\n                sOut.push(sIn.top());\n                sIn.pop();\n                }\n           \n        }   \n        int result = sOut.top();\n        \n        return result;\n    }\n    \n    bool empty() {\n        return (sIn.empty()&&(sOut.empty()));//两个为空才为空\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中数据长度。\n- 空间复杂度：O(N) 两个栈的空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996780650","body":"### 思路\n\n不知道思路\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> lMax(n,INT_MIN),rMin(n,INT_MAX);\n        lMax[0] = arr[0];\n        rMin[n-1] = arr[n-1];\n        for(int i=1; i<n; i++){\n            lMax[i] = max(lMax[i-1],arr[i]);\n            rMin[n-i-1] = min(rMin[n-i],arr[n-i-1]);\n        }\n        int ans = 1;        //起始块为1块\n        for(int i=0; i<n-1; i++){\n            if(lMax[i] <= rMin[i+1])  ans ++;\n        }\n        return ans;\n    }\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中数据长度。\n- 空间复杂度：O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997216789","body":"### 思路\n\n让链接变成循环再重新找节点\n\n### 代码\n\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr) return head;\n        ListNode *index = head;\n        int len = 1;\n        while (index->next != nullptr) {\n            index = index->next;\n            len++;\n        }\n        index->next = head;//环状\n        for (int i = 1; i < len - k % len; i++) {\n            head = head->next;\n        }//找到新链表的尾节点\n        ListNode* res = head->next;//首节点\n        head->next = nullptr;\n        return res;\n    }\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中数据长度。\n- 空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997375100","body":"### 思路\n\n更改链表指针方向\n\n策略：\n添加一个虚拟头，并将虚拟头加入指向新链表，它的加入方便遍历\n用临时变量对新链表进行操作\n注意，next变量所指向一直在发生变化,注意最后一次被切断的地方，及当前所代表的地方\n\n\n### 代码\n\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr)return nullptr;\n        if(head->next == nullptr) return head;\n        int len = 1;\n        ListNode* cur = nullptr;\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        cur = dummyHead;\n        \n       \n        while((cur->next!= nullptr) && (cur->next->next != nullptr)) {\n            ListNode* p1 = cur->next;\n            ListNode* p3 = cur->next->next->next;\n            //step 1: point head to ->p2\n            cur->next = cur->next->next;\n            //step 2:point p2 next to p1\n            cur->next->next = p1;\n            //step 3: point p1 next to p3\n            cur->next->next->next = p3;\n\n            //reset cur to new loop head\n            cur = cur->next->next;\n            cout<<\"cur\"<<cur->val;\n        }\n\n        return dummyHead->next;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中数据长度。\n- 空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998012816","body":"### 思路\n\n二分法，递归\n\n策略：\n找到中点，只需要使⽤经典的快慢指针即可。同时为了防⽌环的出现， \n我们需要斩断指向 mid 的 next 指针，\n即将一个链接分成左右两个干净的链表(尾结点指向nullptr)与一个根节点\n因此需要记录⼀下中点前的⼀个节 点，这只需要⽤⼀个变量 记录即可\n\n\n### 代码\n\n\n```cpp\n//**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(!head)return nullptr;\n        // if(!head->next) return new TreeNode(head->val);\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n        ListNode* sLast = slow;\n\n\n        while(fast && fast->next) {\n            sLast  = slow;\n            slow = slow->next;\n            fast = fast->next->next;\n           \n        }\n        \n        if(sLast) sLast->next = nullptr;\n        // cout<<\"head: \"<<head->val<<\"mid \"<<slow->val<<\"right \"<<fast->val<<\"\\n\";\n       \n      \n        TreeNode* node = new TreeNode(slow->val);\n        if(fast == slow) return node;\n   \n        // cout<<\"head:\"<<head->val << \"fast:\"<<fast->val<<\"\\n\";\n        node->left =  sortedListToBST(head);\n        node->right = sortedListToBST(slow->next);\n\n        return node;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中数据长度。\n- 空间复杂度：O(h) h为树的高度，这里为logn\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998760232","body":"### 思路\n\n重复走路会相遇，两路总和相等\n\n\n### 代码\n\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      if(!headA || !headB) return nullptr;\n      ListNode* p1 = headA;\n      ListNode* p2 = headB;\n      while(p1 != p2) {\n          p1 = p1?p1->next:headB;//p1所在路走完了，走p2开始的路\n          p2 = p2?p2->next:headA;//p2所在路走完了，走p1开始的路\n          //计算两个人的总路程是相等了\n          }\n      return p1;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 节点中数据长度m+n+c(公共部分）。\n- 空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999592096","body":"### 思路\n\n快慢指针会相遇\n\n### 代码\n\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode*fast = head;\n        ListNode*slow = head;\n        while((fast != nullptr) &&(fast->next !=nullptr))\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow == fast) {//相遇\n               ListNode* index1 = head;\n               ListNode* index2 = fast;\n               while(index1 != index2) {\n                   index1 = index1->next;\n                   index2 = index2->next;\n                   \n               }\n               return index2;//取出环的入口处\n            }\n        }\n\n        return nullptr;\n\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 节点中链表数据长度\n- 空间复杂度：O(1) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000362399","body":"### 思路\n\nLinkedHashMap\n\n### 代码\n\n\n```class LRUCache {\n    private Map<Integer, Integer> map;\n    private int cap;\n\n    public LRUCache(int capacity) {\n        map = new LinkedHashMap<>();\n        cap = capacity;\n    }\n    \n    public int get(int key) {\n        // key不存在，访问不到\n        if (!map.containsKey(key)) {\n            return-1;\n        }\n\n        // key存在，需要将keyPair放到最后\n        int val = map.remove(key);\n        map.put(key, val);\n        return val;\n    }\n    \n    public void put(int key, int value) {\n        // key存在，将存在的keyPair放到最后，并更新上新value\n        if (map.containsKey(key)) {\n            map.remove(key);\n            map.put(key, value);\n            return;\n        }\n\n        // key不存在，直接放到最后\n        map.put(key, value);\n\n        // 检查缓存容量，超出上限，则移除第一个\n        if (map.size() > cap) {\n            map.remove(map.entrySet().iterator().next().getKey());\n        }\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)，\n- 空间复杂度：O(cap) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000868544","body":"### 思路\n\n动态规划，自底向上，\n\n最简子结构：从叶子节点的情况\n\n逻辑关系：左右子树比较\n\n实现方式：递归（迭代还想不到方法）\n### 代码\n\n\n```/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root )return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return 1+max(left,right);\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logn)，n为节点数，logn相当于树高\n- 空间复杂度：O(n) ,\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000990830","body":"### 思路\n\n动态规划，自底向上，\n\n最简子结构：从叶子节点的情况\n\n逻辑关系：左右子树比较\n\n实现方式：递归（迭代还想不到方法）\n### 代码\n\n\n```\n /**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        //判断根节点的情况\n      if(p == nullptr && q == nullptr)return true;\n      if(p == nullptr || q == nullptr)return false;\n      //子节点的情况\n      if(p->val != q->val)return false;\n      //说明下面是值相等了，直接进行子树的比较\n      //比较左右子树的情况，递归\n      return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，\n- 空间复杂度：O(n) \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alvinzhouoops":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991869153","body":"如果直接在数组A上做加法和进位，如果和的长度大于A，需要在A前面插入元素，在数组中不太好实现，所以还是要用新的数组来存放。\npython\nclass Solution{\n    def AddListAndInt(int[] A, int K):\n        n = len(A)\n        sum = A[0]\n        for i in range(1, n):\n            sum += sum*10 + A[i]\n       sum = sum + K\n       tem = []\n       while(sum > 0):\n           item = sum%10\n           tem.append(item)\n           sum = sum//10\n       return tem[::-1]\n     \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992020789","body":"\r\n```\r\nClass Solution:\r\n    def getDisFromStr(self, String, C):\r\n        n = len(String)\r\n        res = [n for _ in range(n)]\r\n        l = r = 0\r\n        for r in range(n):\r\n            if String[r] == C:\r\n                while l <= r:\r\n                    res[l] = r - l\r\n                    l += 1\r\n       r = n -1\r\n       for l in range(n-1, -1, -1):\r\n           if String[l] == C:\r\n               while r >= l:\r\n                   res[r] = min(res[r], r-l)\r\n                   r -= 1\r\n      return res\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993261850","body":"class CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994314996","body":"```\r\nclass Solutions:\r\n    def DecodeString(s):\r\n        def decode(index):\r\n            res = ''\r\n            count = 0\r\n            while index < len(s):\r\n                if 'a' <= s[index] <= 'z':\r\n                    res += s[index]\r\n                    index += 1\r\n                elif '0' <=  s[index] < '10':\r\n                    count = count*10 + int(s[index])\r\n                    index += 1\r\n                elif s[index] == '[':\r\n                    index += 1\r\n                    res += decode(index)\r\n                 elif s[index] == ']':\r\n                     index += 1\r\n                     return res\r\n            return res\r\n        index = 0\r\n        return decode(index)        \r\n```        \r\n\r\n        时间复杂度：O(n)\r\n        空间复杂度： O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fredxxj":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991869799","body":"# 用python处理起来非常简单，先试试\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for i in num:\n            n = n * 10 + i\n        n += k\n        return [int(ch) for ch in str(n)]\n```\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992549208","body":"### 思路：先得到所有字符的索引列表，然后从头开始遍历，建立下边界和上边界两个变量，如果当前索引小于上边界，则不需要调整边界，否则将上边界改为下边界，上边界取索引当中的下一个值，另外处理好索引两端即可\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        len_s = len(s)\n        dis = [i for i in range(len_s) if s[i] == c]\n        j = 0\n        lower, upper = - 2 * len_s, dis[j]\n        result = []\n        for i in range(len_s):\n            if i > upper:\n                lower = upper\n                if j < len(dis) - 1:\n                    j += 1\n                    upper = dis[j]\n                else:\n                    upper = 2 * len_s\n            result.append(min(upper - i, i - lower))\n        return result\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993510551","body":"### 用一个count记录实际内容的数量即可\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.count = 0\n        self.ls = [None] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.count == self.maxsize:\n            return\n        self.ls[self.count] = x\n        self.count += 1\n\n    def pop(self) -> int:\n        if self.count == 0:\n            return -1\n        self.count -= 1\n        return self.ls[self.count]\n\n    def increment(self, k: int, val: int) -> None:\n        length = self.count if self.count < k else k\n        for i in range(length):\n            self.ls[i] += val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995759559","body":"### Python原生的list可以完美实现栈的功能，用两个列表互相倒腾就可以实现队列了\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.listA = []\n        self.listB = []\n\n    def push(self, x: int) -> None:\n        self.listA.append(x)\n\n    def pop(self) -> int:\n        if self.listB:\n            return self.listB.pop()\n        else:\n            while self.listA:\n                self.listB.append(self.listA.pop())\n            return self.listB.pop()\n\n    def peek(self) -> int:\n        if self.listB:\n            return self.listB[-1]\n        else:\n            while self.listA:\n                self.listB.append(self.listA.pop())\n            return self.listB[-1]\n\n    def empty(self) -> bool:\n        if not self.listA and not self.listB:\n            return True\n        return False\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996778009","body":"### 用前缀和比较简单，就是复杂度要排一次序\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr2 = sorted(arr)\n        s1 = s2 = result = 0\n        for a, b in zip(arr, arr2):\n            s1 += a\n            s2 += b\n            if s1 == s2:\n                result += 1\n        return result\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997396220","body":"### 用递归比较容易理解，不用递归步骤有点费脑子\n```python\ndef swapPairs(self, head: ListNode) -> ListNode: \n    if not head or not head.next: \n        return head \n    newHead = head.next\n    head.next = self.swapPairs(newHead.next)\n    newHead.next = head\n    return newHead\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenyaohn":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991870273","body":"### 思路\n\n从n-1至0开始遍历A数组，将其与K对应位置上的进行累加（通过取余获取K各个位置上的值,K%10,(int)(k/10)），如大于等于10则需进位+1，flag为进位标志。\n当K位数大于A数组长度时，需将K的剩余位置的值也添加至结果集合中，同时也需要判断进位。\n最后当A数据与K全部遍历完毕后，如还有进位，则需于结果集合中再度添加1。\n\n### 代码\n\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        boolean flag = false; // 判断是否需要进位+1\n        for (int i = num.length-1; i >=0 ; i--) {\n                if(k==0){\n                    int curValue = flag ? num[i]+1:num[i];\n                    flag = curValue>=10;\n                    list.add(flag?curValue-10:curValue);//进位则加1\n                }else {\n                    int n = k % 10;//k最后一位\n                    int curValue = flag ? num[i]+n+1:num[i]+n;\n                    flag = curValue>=10;\n                    list.add(flag ?curValue-10:curValue);\n                    k /= 10;\n                }\n            }\n\n        while (k!=0){//num数组已累加完毕，k未累加完毕\n            int n = k%10;//k最后一位\n            int curValue = flag ? n+1:n;\n            flag = curValue>=10;\n            list.add(flag?curValue-10:curValue);\n            k/=10;\n        }\n        //k已累加完毕，仍然需要进位，则结果list add 1（如9+1=10这种情况）\n        if(k==0&&flag){\n            list.add(1);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(A,K))，其中 A 为数组A长度,k为k位数。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992216549","body":"### 思路\n最开始思路是获取s[i]到s中每个c字符位置，取最短的长度。实际上这里增加了很多重复比较，导致时间复杂度变高。\n查看官网题解，O(N)时间复杂度的思路是从左至右找出上一次c字符出现位置，并获取其距离，再从右至左找出上一次c字符出现位置获取其距离，与从左至右的距离比较，最终结果取最短的那个。\n### 代码\n```java\n//O(n^2>)时间复杂度\npublic int[] shortestToChar(String s, char c) {\n        int [] res = new int[s.length()];\n        for (int i = 0; i < res.length; i++) {\n            res[i] = 105;\n            for (int j = 0; j < s.length() && res[i] != 0; j++) {\n                if(s.charAt(j)==c && Math.abs(i-j)<=res[i]){\n                    res[i] = Math.abs(i-j);\n                }\n            }\n\n        }\n        return res;\n    }\n//O(n)时间复杂度\n public int[] shortestToChar2(String s, char c) {\n        int [] res = new int[s.length()];\n        int prev = 105;\n        for (int i = 0; i < res.length; i++) {\n\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            res[i] = Math.abs(i-prev);\n        }\n\n        for (int i = res.length-1; i >=0 ; i--) {\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            res[i] =Math.min(Math.abs(i-prev),res[i]);\n        }\n        return res;\n    }\n```\n### 复杂度\n时间复杂度： O(n <sup>2</sup> )\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993341981","body":"### 思路\n由题可知，长度固定的栈，考虑用数组实现。  \n定义一个maxSize和curSize分别表示栈的最大容量以及当前容量。  \n入栈时判断是否超过最大容量，并将值以逆序下标存入数组中，同时curSize+1；出栈时根据当前容量及最大容量算出栈顶的值在数组中位置，即下标为maxSize-curSize，同时curSize-1。  \n实现increment()方法时，判断curSize是否大于增量k。\n### 代码\n```java\nclass CustomStack {\n    int curSize;\n    int maxSize;\n    int[] elements;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.elements = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(curSize<maxSize){\n            curSize++;\n            elements[maxSize-curSize]=x;\n        }\n    }\n\n    public int pop() {\n        int top = -1;\n        if(curSize!=0){\n            top = elements[maxSize-curSize];\n            elements[maxSize-curSize] = 0;\n            curSize--;\n        }\n        return top;\n    }\n\n    public void increment(int k, int val) {\n        for (int i = maxSize-1; i >= maxSize-(curSize>k?k:curSize)&&k>0&&curSize>0; i--) {\n            elements[i] += val;\n        }\n    }\n\n}\n```\n### 复杂度分析\n时间复杂度： push()==>O(1)；pop==>O(1)；increment()==>O(k)  \n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994686550","body":"### 思路\n因为有嵌套的情况存在，考虑使用递归处理。  \n判断字符串中是否还有[存在，如存在截取[字符截取右边的字符串，通过递归方法找到最里层[]中的字符，根据规则解码完毕后，一层层向外围处理（代码中利用了java中indexOf(str)方法只会取出字符串中首次出现的位置）。  \n需注意k可能有多位\n### 代码\n```java\n public String decodeString(String s) {\n\n        StringBuilder sb = new StringBuilder();\n        if(s.indexOf(\"[\")>-1){\n            sb.append(s.substring(0,kIndex(s,s.indexOf(\"[\")-1)));\n            sb.append(deal(s.substring(s.indexOf(\"[\")+1),Integer.parseInt(s.substring(kIndex(s,s.indexOf(\"[\")-1),s.indexOf(\"[\")))));\n        }else {\n            return s;\n        }\n\n        return sb.toString();\n    }\n//k可能不止一位数，算出k的起始点下标\n    public int kIndex(String s,int index){\n        int i = index-1;\n        for (; i >=0 ; i--) {\n            if(s.charAt(i)<'0' || s.charAt(i)>'9'){\n                break;\n            }\n        }\n        i++;\n        return i;\n    }\n\n    public String deal(String s,int count){\n        while (s.indexOf(\"[\")>-1){\n            s=s.substring(0,kIndex(s,s.indexOf(\"[\")-1))+deal(s.substring(s.indexOf(\"[\")+1),Integer.parseInt(s.substring(kIndex(s,s.indexOf(\"[\")-1),s.indexOf(\"[\"))));\n        }\n        //除最外层[]外，已经全部解码完毕\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < count; i++) {\n            sb.append(s.substring(0,s.indexOf(\"]\")));\n        }\n        sb.append(s.substring(s.indexOf(\"]\")+1));\n\n        return sb.toString();\n    }\n```\n### 复杂度分析\n时间复杂度：O(n),n为k之和  \n空间复杂度：O(n) 大概是吧...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995754280","body":"### 思路\n题目要求使用两个栈实现队列效果。  \n栈的特性为先进后出，队列特性为先进先出。所以入栈时需要将元素放入栈顶。  \n这里先将元素放入栈2中，通过栈2的pop()方法获取栈顶元素放入栈1的栈底位置。从而实现栈1的pop()方法取出的是队列的末尾元素。\n### 代码\n```java\n //栈1 最终存放的栈\nclass MyQueue {\n\n    //栈1 最终存放的栈\n    Stack<Integer> stack1 = new Stack<Integer>();\n    //栈2\n    Stack<Integer> stack2 = new Stack<Integer>();\n\n    public MyQueue() {\n\n    }\n    public void push(int x) {\n        if(stack1.empty()){\n            stack1.push(x);\n            return;\n        }\n        while (!stack1.empty())\n            stack2.push(stack1.pop());\n        \n        stack2.push(x);\n\n        while (!stack2.empty())\n            stack1.push(stack2.pop());\n\n\n    }\n    //删除队顶元素\n    public int pop() {\n        return stack1.pop();\n    }\n\n    public int peek() {\n        return stack1.peek();\n    }\n\n    public boolean empty() {\n        return stack1.empty();\n    }\n}\n```\n### 复杂度分析\n时间复杂度：push()==>O(n);pop()==>O(1);peek()==>O(1);empty()==>O(1)。队列push()方法可能存在多个栈的push()和pop()操作，由于栈的push和pop操作为O(1)，假设栈容量为n，所以队列的push()方法也应该可以近似为O(n);  \n空间复杂度：push()==>O(n);pop()==>O(1);peek()==>O(1);empty()==>O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996787327","body":"### 思路\n题目要求分成的块升序排序，则可知后面的块里的值必然大于等于前面的块的最大值。  \n由此如果遍历到后面的元素如果大于或等于前一块的最大值，则有可能组成一个新块，但如果遍历的元素小于前面块的最大值，则无法组成新块将此值加入到上一个块中。然后则需要判断这个值是否比前面得所有块的最小值小。如小则需要删除块的数量。  \n我自己的代码太过于复杂，查看题解可知可使用滑动窗口处理\n### 代码\n```java\nclass Solution {\n\n \n    \n    class Solution {\n        public int maxChunksToSorted(int[] arr) {\n            int[] cloneArray = arr.clone();\n            Arrays.sort(cloneArray);\n            long arrSum = 0;\n            long cloneSum = 0;\n            int sum = 0;\n            for (int i = 0; i < arr.length; i++) {\n                arrSum += arr[i];\n                cloneSum += cloneArray[i];\n                if(arrSum == cloneSum) sum++;\n            }\n            return sum;\n        }\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997153831","body":"### 思路\n用k与链表长度进行取模运算，算出需要移动多少位用move表示。那么 len-move就是新链表末尾元素的位置，len-move+1就是新链表开头元素。将新末尾的元素的next置为空，将原链表的末尾元素的next设置为原链表的开头元素即可。注意取模时为0则代表不移动。\n### 代码\n```java\nclass Solution {\n\n    public ListNode rotateRight(ListNode head, int k) {\n\n        int len = 0;\n        if(null == head || null==head.next||k==0){//链表长度1或0直接返回不移动\n            return head;\n        }\n        len++ ;\n        ListNode next = head.next;\n        ListNode last = head;\n        while (null!=next){\n            len++;\n            last = next;\n            next = next.next;\n        }\n\n\n        int move = k%len;\n        if(move==0)\n            return head;\n        int lastIndex = len-move;//新链表的最后一位\n        ListNode newLast = head;\n        lastIndex--;\n        while (lastIndex>0){\n            newLast=newLast.next;\n            lastIndex--;\n        }\n        ListNode newHead = newLast.next;\n        newLast.next = null;\n        last.next = head;\n\n\n        return newHead;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(n) n为链表长度  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997406166","body":"### 思路\n由题可知，每两个链表节点为一组进行交换，所以交换位置后，第一组的第二个节点 的下一个节点是第二组的第一个节点，我们每次交换位置时保留上一组的第二个节点，在第二组交换完毕后，将其与第二组的第一个节点连接起来即可完成交换。\n### 代码\n```java\nclass Solution {\n  public ListNode swapPairs(ListNode head) {\n        ListNode curNode = head;\n        ListNode lastNode = null;\n        ListNode tempNode;\n       ListNode newHead = null==head||null==head.next?head:head.next;\n        while (curNode!=null){\n            ListNode nextNode= curNode.next;\n            curNode.next = null;\n\n            if(null!=lastNode){//先将上一组连接起来\n                lastNode.next = null!=nextNode?nextNode:curNode;\n            }\n\n            if(null!=nextNode){\n\n                tempNode = nextNode.next;\n                nextNode.next = curNode;\n                lastNode = curNode;//交换完的上一组的 第二个链表 连接下一个链表\n\n                curNode = tempNode;//下一组为交换之前的第一个节点\n            }else {\n\n                curNode = null;\n            }\n\n        }\n        return newHead;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(n) n为链表长度  \n空间复杂度：O(1) 没有新建对象。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998035318","body":"### 思路\n快慢指针，找出中点即为树的根节点\n### 代码\n```java\npublic class Day9 {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        return build(head,null);\n    }\n    private TreeNode build(ListNode head,ListNode tail){\n        if(head == tail){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = build(head,slow);\n        root.right = build(slow.next,tail);\n        return root;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(nlogN)  \n空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998736865","body":"### 思路\n双指针法，第一个指针遍历a链表，遍历完之后遍历b链表。第二个指针遍历b链表，遍历完后遍历a链表。  \n如果两链表相交，则在两指针第二次遍历时必然会同时遍历到相交的那个节点。如链表分别为 a=[1,2,3,4], b=[5,3,4]。a指针遍历 1->2->3->4->5->3->4->null,b指针遍历5->3->4->1->2->3->4->null。  \n如两链表不相交，则指针会遍历到末尾的null为止。\n### 代码\n```java\npublic class Solution {\n     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = null==a ? headB : a.next;\n            b = null==b ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(m+n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999405754","body":"### 思路\n可通过龟兔赛跑算法。使用快慢指针求解。  \n### 代码\n```java\npublic class Daya11 {\n\n    /**\n     * @param head\n     * @return\n     */\n    public ListNode detectCycle(ListNode head) {\n\n        ListNode slow = head;\n        ListNode fast = head;\n        if(head==null || head.next==null){\n            return null;\n        }\n        do{\n            slow = slow.next;\n            fast = fast.next!=null?fast.next.next:null;\n        }while (slow!=fast && fast != null);//相等时相遇\n        if(fast!=null){//有环\n            ListNode temp = head;\n            while (temp != fast){//再度相遇时即为入环点 (根据数学公式可推导)\n                temp = temp.next;\n                fast = fast.next;\n            }\n        }\n        return fast;\n\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(N) 。  \n空间复杂度：O(1)，未开辟新空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000356145","body":"### 思路\n开始只想到了O(n)的解法。经过官方题解提醒可以使用哈希表+双向链表处理。  \n使用双向链表存入key和value，同时这条双向链表起到一个记录使用顺序的作用。哈希表的key为输入的LRUCache的key，value为包含LRUCache-key及LRUCache-value的双向链表。  \n初始化时记录容量，同时创建出双向链表的头和尾节点。  put时判断key是否已存在，如已存在则修改原value，同时更新其对应的链表位置。如key不存在，则判断是否大于容量，如小于最大容量，则新建链表节点，并将其位置调整至双向链表的头部；如大于最大容量则删除原末尾连接节点，位置调整至原链表头部。\n### 代码\n```java\nclass LRUCache {\n    class DoubleLinnked{\n        int key;\n        int value;\n        DoubleLinnked next;\n        DoubleLinnked prev;\n        public DoubleLinnked(){\n\n        }\n        public DoubleLinnked(int key,int value){\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    HashMap<Integer,DoubleLinnked> values;\n    DoubleLinnked head;\n    DoubleLinnked tail;\n\n    int capacity;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.values = new HashMap<>();\n        this.head = new DoubleLinnked();\n        this.tail = new DoubleLinnked();\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n\n    /**\n     * 添加头部链表\n     * @param node\n     */\n    private void addHead(DoubleLinnked node){\n        DoubleLinnked temp = head.next;//原头部链表\n        head.next = node;\n        node.prev = head;\n        node.next = temp;\n        temp.prev = node;\n    }\n\n    /**\n     * 缓存过期需删除尾部链表\n     * 同时删除哈希表中对应元素\n     * @return\n     */\n    private void removeTail(){\n        DoubleLinnked oldTail = tail.prev;//原尾部链表\n        DoubleLinnked newLastNode = oldTail.prev;//删除尾部后新的尾部链表\n        \n        newLastNode.next = tail;\n        tail.prev = newLastNode;\n        \n        values.remove(oldTail.key);\n    }\n\n    /**\n     * 更新链表位置，放到头部（get方法）\n     * @param node\n     */\n    private void updateLocation(DoubleLinnked node){\n        DoubleLinnked prevNode = node.prev;//上一个链表\n        DoubleLinnked nextNode = node.next;//下一个链表\n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n        addHead(node);\n    }\n    \n   \n    \n    public int get(int key) {\n        DoubleLinnked node = values.get(key) ;\n        if(node==null)\n            return -1;\n        updateLocation(node);//链表位置变更至头部\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DoubleLinnked node = values.get(key) ;\n        if(node==null){//没有这个key值\n            node = new DoubleLinnked(key,value);\n\n            if(capacity>0){\n                capacity--;//添加完新元素后 剩余容量-1\n            }else{\n                removeTail();//删除尾部元素(即删除最久未使用的元素)\n            }\n            values.put(key,node);\n            addHead(node);\n        }else{\n            node.value = value;\n            updateLocation(node);\n        }\n\n    }\n}\n```\n### 复杂度分析\n时间复杂度： O(1)  \n空间复杂度： O(n) n为最大容量capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000861666","body":"### 思路\n递归获取左右子树的深度，直到无子节点的节点出现\n### 代码\n```java\n public int maxDepth(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        int l = maxDepth(root.left);\n        int r = maxDepth(root.right);\n\n        return Math.max(l,r)+1;\n    }\n```\n### 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001040204","body":"### 思路\n使用递归遍历树判断是否相等\n### 代码\n```java\npublic class Day14 {\n\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if(p==null && q==null)\n                return true;\n            else if(p==null || q==null )\n                return false;\n            else if (p.val != q.val) \n                return false;\n            else\n                return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n\n        }\n}\n```\n### 复杂度\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eliassama":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991872005","body":"## 整体思路\n\n整个题可以看作是一个纯粹的数字相加的题，因为不管是数字还是数组，都是有序。\n\n如1024这个数，不管是number类型的1024还是数组类型的 [1,0,2,4]都是一样的，不同的只是展现形式。\n\n所以这道题的关键点在于采用哪种形式进行计算，以及如何转换为最终要的数组形式。其实计算反而不重要。\n\n在解题时需要注意下溢出问题，这个题的测试用例是会有大数的，部分编程语言是不支持大数的 ( 如js的int32只支持18位以内的精确大数 ) ，所以计算要取巧。\n\n\n\n### 解题思路\n\n采用古老而笨拙的按位进制法，即以numArray作为遍历条件，从最低位到最高位依次与k的最低位到最高位进行相加。\n\n在相加的过程中有些东西需要注意：\n\n+ 因为每次相加都是单位数相加，所以最大的值为18 ( 9 + 9 )。而每个元素只能承载单位数，所以会向前进一，所以实际最大值为19 ( 9 + 9 + 1 )。但是这个数不会超过19。所以要考虑两点：\n  + 除了个位数外，如果上次相加的数有进位的，则每次相加时都要加上进位。\n  + 如果每次相加的结构需要进位的，需要记录在下一次相加时加上。\n+ 因为以numArray作为遍历条件，所以可能会出现下列两种情况从而导致溢出问题，需要考虑进去：\n  + k的值的位数可能会比numArray的位数大，比如[2,1]和3600。\n  + 两个数相加，最后要整体向前进一位，比如[9,9,9]和1\n\n\n\n#### 版本一\n\n##### Code\n\n```typescript\nfunction addToArrayForm(numArray: number[], k: number): number[] {\n\n    const KStr: string = String(k)\n    let numArrayIndex: number = numArray.length - 1\n    let KStrIndex: number = KStr.length - 1\n    let lastNum:number = 0\n\n    for(;numArrayIndex > -1; --numArrayIndex, --KStrIndex){\n        numArray[numArrayIndex] += (parseInt(KStr[KStrIndex]) || 0) + lastNum\n        lastNum = 0\n        if(numArray[numArrayIndex] > 9){\n            numArray[numArrayIndex] -= 10\n            lastNum = 1\n        }\n    }\n    \n    if(KStrIndex > -1){\n        let overflowStr: string = String(parseInt(KStr.substring(0, KStrIndex + 1)) + lastNum)\n        KStrIndex = overflowStr.length - 1\n        lastNum = 0\n        const overflowArray: number[] = []\n        for(;KStrIndex > -1; --KStrIndex){\n            overflowArray.push(parseInt(overflowStr[KStrIndex]))\n        }\n        overflowArray.reverse()\n        numArray = [...overflowArray,...numArray]\n    }\n\n    if(lastNum === 1){\n        numArray = [1,...numArray]\n    }\n\n    return numArray\n};\n```\n\n\n\n##### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为 numArray 或 k 的最大长度。\n- 空间复杂度：O(N)，其中 N 为 numArray 加 k 的长度，并有可能会在此基础上 + 1。\n\n\n\n#### 版本二\n\n##### Code\n\n```typescript\nfunction addToArrayForm(numArray: number[], k: number): number[] {\n\n    const kArray: string[] = String(k).split(\"\")\n    let kIndex: number = kArray.length - 1\n    let nIndex: number = numArray.length - 1\n    const resultArray: number[] = []\n\n    let lastNum:number = 0\n    for(;kIndex > -1 || nIndex > -1 ; --kIndex, --nIndex){\n        let result = (parseInt(kArray[kIndex]) || 0) + (numArray[nIndex] || 0) + lastNum\n        lastNum = 0\n        if(result > 9){\n            result -= 10\n            lastNum = 1\n        }\n        resultArray.push(result)\n\n        if(kIndex <= 0 && nIndex <= 0 && lastNum === 1){\n            resultArray.push(1)\n        }\n\n    }\n    \n    return resultArray.reverse()\n};\n```\n\n\n\n##### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为 numArray 或 k 的最大长度。\n- 空间复杂度：O(N)，其中 N 为 numArray 或 k 的最大长度，并有可能会在此基础上 + 1。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994828432","body":"### 整体思路\n\n 这个题有点像是编译时，将代码进行解释的操作。也可以看成是一种压缩的操作。这种一般会采用栈来做比较好一点。\n\n因为这个需要从里到外依次执行，如 `\"3[a2[c]]\"`，会先执行`2[c]`，再执行`3[a2[c]]`。而栈正好符合这个特性，即先进后出。\n\n### 解题思路\n\n整体需要将数字、字符进行压栈，每次压栈以`[`为分界，同时压入`[`之前的数字和`]`之后的字符。\n\n在`]`时代表要出栈，出栈后就紧接着去计算当前栈顶的值，然后依次取栈计算值。\n\n\n\n##### Code\n\n```typescript\nfunction decodeString(s: string): string {\n\n    const stack : string[][] = []\n    let multi : number = 0\n    let resultStr : string = \"\"\n\n    let strIndex : number = 0\n    for (; strIndex < s.length; ++strIndex) {\n        let strSingle = s[strIndex]\n        switch (strSingle) {\n            case \"[\": {\n                stack.push([`${multi}`, resultStr])\n                resultStr = \"\"\n                multi = 0\n                break\n            }\n            case \"]\": {\n                let [_multi, _resultStr] = stack.pop()\n                resultStr = _resultStr + new Array(parseInt(_multi )+1).join(resultStr)\n                break\n            }\n            default:\n                if ( !isNaN(parseInt(strSingle)) ){\n                    multi = multi * 10 + parseInt(strSingle)\n                }else {\n                    resultStr += strSingle\n                }\n        }\n    }\n\n    return resultStr\n\n}\n\n```\n\n\n\n##### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997400153","body":"### 整体思路\n\n 这个题的关键点在于如何准确交换相邻两个链表节点。\n\n### 解题思路\n\n这个题是每两个交换一下顺序。所以可以采用栈的方式每两个进一次栈交换下顺序。\n\n#### 版本一\n\n##### Code\n\n```typescript\nclass Stack {\n    private stack: any[] = [];\n    private stackTop: number = -1\n\n    push (x: any) {\n        this.stackTop += 1\n        this.stack[this.stackTop] = x;\n    }\n    pop () {\n        let popNum = this.stack[this.stackTop];\n        this.stack[this.stackTop] = undefined\n        this.stackTop -= 1\n        return popNum;\n    }\n    isEmpty () {\n        return this.stackTop === -1;\n    }\n    peek () {\n        return this.stack[this.stackTop];\n    }\n}\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if(head==null || head.next==null) {\n        return head;\n    }\n    let stack: Stack  = new Stack();\n    let p: ListNode  = new ListNode(-1);\n    let cur: ListNode = head;\n    head = p;\n    while(cur!=null && cur.next!=null) {\n        stack.push(cur);\n        stack.push(cur.next);\n        cur = cur.next.next;\n        p.next = stack.pop();\n        p = p.next;\n        p.next = stack.pop();\n        p = p.next;\n    }\n    if(cur!=null) {\n        p.next = cur;\n    } else {\n        p.next = null;\n    }\n    return head.next;\n};\n```\n\n\n\n##### 复杂度分析\n\n时间复杂度：O( n )\n\n空间复杂度：O( 1 )","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999669947","body":"### 整体思路\n\n这个题的关键点在于如何判断有环，以及查找出两个一样的next节点。因为环形链表有环，这就代表环的起点有两个父节点，即有两个一摸一样的next指向。\n\n### 解题思路\n\n这个题可以采用两种方法，hash表和快慢指针。\n\n#### 版本一\n\n使用快慢指针。快指针每次走两步，慢指针每次走一步，如果快指针和慢指针相交了，就代表有环。如果一直到最后都没有相交，则代表没环。\n\n如果是有环的情况下，快指针重定位到head。快慢指针同时都每次走一步，当快慢指针相交，就是环的入口。\n\n##### Code\n\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    let slow: ListNode  = head\n    let fast: ListNode  = head\n    let loopStart: ListNode | null = null\n\n    while (fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n        if (fast === slow){\n            loopStart = fast\n            break\n        }\n    }\n\n    if (!loopStart){\n        return loopStart\n    }\n\n    fast = head\n    while (fast != slow){\n        slow = slow.next\n        fast = fast.next\n    }\n    return slow\n};\n\n```\n\n\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return fast;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n##### 复杂度分析\n\n时间复杂度：O( n )\n\n空间复杂度：O( 1 )\n\n\n\n#### 版本二\n\n使用hash方式来判断，遍历整个链表，每次将遍历到的节点放入hash表中。如果遍历过程中在hash表中发现存在此节点，则代表有环，且环起点是当前节点，直接返回即可。否则就是无环。\n\n##### Code\n\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    const data: Set<ListNode> = new Set<ListNode>();\n    while (head) {\n        if (data.has(head)) {\n            return head;\n        } else {\n            data.add(head);\n        }\n        head = head.next;\n    }\n    return null;\n};\n```\n\n\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (head != null) {\n            if (visited.contains(head)) {\n                return head;\n            } else {\n                visited.add(head);\n            }\n            head = head.next;\n        }\n        return null;\n    }\n}\n```\n\n\n\n##### 复杂度分析\n\n时间复杂度：O( n )\n\n空间复杂度：O( n )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000350134","body":"### 整体思路\n\n这个题是一个设计题。主要是三点：\n\n+ 有限的空间。\n+ 可以插入、更新、查看。\n+ 如果空间满了，去除最久未使用的数据。\n\n### 解题思路\n\n这个题可以采用哈希表加双向链表。\n\n哈希表主要是用来存储 key 对应的链表节点引用，这样可以从任意链表开始进行增删改查的操作。\n\n链表主要是存储空间内的基本信息，并且以链表的节点位置来确定最新使用的和最久未使用的数据，在更新、查看、插入数据时，将数据移到头部。\n\n但是链表不能采用单向链表，因为单向链表只能直接获得 next 节点，如果想拿到指向它的节点，必须使用遍历的方式。这样就不是 O( 1 ) 操作了。\n\n所以采用双向链表，任意一个链表节点，既可以知道它的头是谁，也能知道它的尾是谁。\n\n采用数据结构如下， 并分别存储头节点和尾节点：\n\n+ HashMap: 用来存储key和链表的映射关系\n\n+ DoubleLinkedListNode: 用来存储三个数据，分别是头节点、尾节点和值。\n\n\n\n整体逻辑如下：\n\n+ 查：\n  + get: HashMap -> key -> DoubleLinkedListNode -> value \n  + update:\n    + head = dummyHead.next\n    + HashMap -> key -> DoubleLinkedListNode.next = head\n    + head.prev = dummyHead\n    + dummyHead.next = HashMap -> key -> DoubleLinkedListNode\n+ 改：\n  + update: \n    + HashMap -> key -> DoubleLinkedListNode.value = newValue \n    + head = dummyHead.next\n    + HashMap -> key -> DoubleLinkedListNode.next = head\n    + head.prev = dummyHead\n    + dummyHead.next = HashMap -> key -> DoubleLinkedListNode\n\n+ 增：\n\n  + 空间已满: 进行删除，删除具体逻辑见下面\n  + 空间未满:\n    + add: HashMap -> key -> DoubleLinkedListNode-> value\n    +  HashMap -> key -> DoubleLinkedListNode.next = dummyHead\n    + HashMap -> key -> DoubleLinkedListNode.prev  = dummyTail\n    +  dummyHead.prev = HashMap -> key -> DoubleLinkedListNode\n    + dummyTail.next  = HashMap -> key -> DoubleLinkedListNode\n    + dummyHead = HashMap -> key -> DoubleLinkedListNode\n\n+ 删\n\n  + dummyTail.prev.next = dummyTail.next\n\n  + dummyTail.next.prev = dummyTail.prev\n\n  + dummyTail.prev = null\n\n  + dummyTail.next = null\n\n    \n\n##### Code\n\n```typescript\nclass DoubleLinkedListNode {\n    key: number\n    value: number\n    prev: DoubleLinkedListNode\n    next: DoubleLinkedListNode\n    constructor(key: number, value: number) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\n\nclass LRUCache {\n\n    capacity: number\n    usedSpace: number\n    // Mappings of key->node.\n    hashmap: Map<number,DoubleLinkedListNode>\n    dummyHead: DoubleLinkedListNode\n    dummyTail: DoubleLinkedListNode\n    constructor(capacity: number) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = new Map<number, DoubleLinkedListNode>()\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head: DoubleLinkedListNode = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key: number): number {\n        if (key in this.hashmap) {\n            const node: DoubleLinkedListNode = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key: number, value: number): void {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node: DoubleLinkedListNode = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n            // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node: DoubleLinkedListNode = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node: DoubleLinkedListNode = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\n```\n\n\n\n```java\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n\n\n##### 复杂度分析\n\n时间复杂度：O( 1 )\n\n空间复杂度：\n\n+ 双向链表: O( n )\n+ 哈希表: O( n )\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"noperoc":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991873365","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- \n\n## 思路\n- 模拟竖式 逐位相加  \n## 关键点\n\n-  最后一位剩余进位别忘了加\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        ArrayList<Integer> kk = new ArrayList<>();\n        while(k != 0){\n            int tmp = k % 10;\n            k = k / 10;\n            kk.add(0,tmp);\n        }\n        int ml = num.length;\n        int kl = kk.size();    \n        ArrayList<Integer> ans = new ArrayList<>();  \n        int flag = 0;\n        while(ml != 0 && kl != 0){\n            int tmp = num[ml-1] + kk.get(kl-1) + flag;\n            if(tmp >= 10){\n                flag = 1;\n                tmp -= 10;\n            }\n            else\n                flag = 0;\n            ans.add(0, tmp);\n            kl--;\n            ml--;\n        } \n        if(ml != 0){\n            for(int i = ml-1; i>=0 ; i--){\n                int tmp = num[i];\n                if(flag == 1){\n                    tmp++;\n                    flag = 0;\n                }\n                if(tmp == 10){\n                    tmp = 0;\n                    flag = 1;\n                }\n                ans.add(0, tmp);\n            }\n        }else if(kl != 0){\n            for(int i = kl-1; i>=0 ; i--){\n                int tmp = kk.get(i);\n                if(flag == 1){\n                    tmp++;\n                    flag = 0;\n                }\n                if(tmp == 10){\n                    tmp = 0;\n                    flag = 1;\n                }\n                ans.add(0, tmp);\n            }\n        }\n        if(flag == 1){\n            ans.add(0, 1);\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992375175","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n遍历每一个位置与记录字符的所有位置的大小填入ans中，初步写一下，n方有点高 应该有更低的做法\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] cs = s.toCharArray();\n        List<Integer> list = new ArrayList<>();\n        for(int i = 0; i<s.length(); i++){\n            if(cs[i] == c){\n                list.add(i);\n            }\n        }\n        int[] ans = new int[s.length()];\n        for(int i = 0; i<ans.length; i++){\n            ans[i] = 999;\n        }\n        for(int i = 0; i<list.size(); i++){\n            for(int j = 0; j<s.length(); j++){\n                ans[j] = Math.abs(j - list.get(i)) < ans[j] ? Math.abs(j - list.get(i)) : ans[j];\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993610643","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n\n## 思路\n数组模拟栈 基本操作\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n\n    int[] length;\n    int index;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        length = new int[maxSize];\n        index = 0;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if(index < maxSize){\n            length[index++] = x;\n        }\n    }\n    \n    public int pop() {\n        if(index > 0){\n            return length[--index];\n        }else\n            return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if(k > maxSize){\n            for(int i = 0; i<maxSize; i++){\n                length[i] += val;\n            }\n        }else{\n            for(int i = 0; i < k; i++){\n                length[i] += val;\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994793774","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n```\n\n## 前置知识\n\n- 栈\n\n\n## 思路\n双栈模拟，类似计算器实现的括号入栈，看了题解，交完论文慢慢重新写\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n作者：jyd\n链接：https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995783382","body":"## 思路\n\n- 来回倒腾 一个栈负责进，一个负责出\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    public MyQueue() {\n    stack1 = new Stack<>();\n    stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while(!stack2.empty()){\n            int tmp = stack2.pop();\n            stack1.push(tmp);\n        }\n        stack1.push(x);\n\n    }\n    \n    public int pop() {\n        while(!stack1.empty()){\n            int tmp = stack1.pop();\n            stack2.push(tmp);\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        while(!stack1.empty()){\n            int tmp = stack1.pop();\n            stack2.push(tmp);\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.empty()&&stack2.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996772012","body":"## 前置知识\n\n-  单调栈\n\n## 思路\n\n- 看了题解 挺牛逼 没想到 考完试慢慢重新做\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997207782","body":"## 思路\n - 旋转几次就是后面几个节点拿到前面去接起来\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\tif (head == null || head.next == null || k == 0) return head;\n    \n    int count = 1; // 用来统计链表总结点数\n    ListNode tmp = head;\n    while (tmp.next != null) {\n        count++;\n        tmp = tmp.next;\n    }\n    k %= count;\n    // 当k为0时，不需要旋转，\n    if (k == 0) return head;\n    \n    // 不满足上述条件，必将进行旋转，所以先将首尾相连\n    tmp.next = head;\n    // 现在只需要找到倒数第k+1个节点\n    for (int i = 0; i < count - k; i++) {\n        tmp = tmp.next;\n    }\n    ListNode newHead = tmp.next;\n    tmp.next = null;\n    return newHead; \n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997356142","body":"## 思路\r\n - 原地翻转链表哦一样的思想，递归\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null ){\r\n            return head;\r\n        }\r\n        ListNode tmp = head.next;\r\n        head.next = swapPairs(head.next.next);\r\n        tmp.next = head;\r\n        return tmp;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997977843","body":"## 前置知识\n\n- 链表快慢指针找中点，慢指针对的就是中点\n\n## 思路\n\n- 不要被题目给的迷惑，只要是分成重点左右两侧就可以了，题目给的只是一种形式而已，只要是两边链表一样长，肯定可以满足题目条件。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode p = head.next;\n        ListNode q = p.next;\n        while(q!=null && q.next!=null){\n            pre = pre.next;\n            p = pre.next;\n            q = q.next.next;\n        }\n        pre.next = null;\n        TreeNode root = new TreeNode(p.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(p.next);\n        return root;\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998882164","body":"\n## 前置知识\n\n- \n\n## 思路\n\n- a+c+b = b + c + a  \n还有个类似的找环的起点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b){\n            if(a != null) a = a.next;\n            else a = headB;\n            if(b != null) b = b.next;\n            else b = headA;\n        }\n        return a;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999643863","body":"## 思路\n-  快慢指针判环\n 然后看了答案 交完论文再重做一下\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode p = head, p2 = head;\n        boolean hasCycle = false;\n        while (p2.next != null && p2.next.next != null) {\n            p = p.next;\n            p2 = p2.next.next;\n            if (p == p2) {\n                hasCycle = true;\n                break;\n            }\n        }\n        if(hasCycle){\n            ListNode q = head;\n            while(p != q){\n                p = p.next;\n                q = q.next;\n            }\n            return q;\n        }else{\n            return null;\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000286843","body":"## 思路\n\n- 用stl写了，但是怎么才能直接实现一个linklist实现的hash表呢？\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass LRUCache {\n    private int cap;\n    private Map<Integer, Integer> map = new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n    }\n    \n    public int get(int key) {\n        if(map.keySet().contains(key)){\n            int value = map.get(key);\n            map.remove(key);\n            map.put(key, value);\n            return value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if(map.keySet().contains(key)){\n            map.remove(key);\n        }else if(map.size() == cap){\n            Iterator<Map.Entry<Integer, Integer>> iterator = map.entrySet().iterator();\n            iterator.next();\n            iterator.remove();\n        }\n        map.put(key, value);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000832971","body":"## 思路\r\n\r\n- 链表和二叉树的题目几乎都是递归\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        return Math.max(maxDepth(root.right), maxDepth(root.left)) + 1;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001039440","body":"\n## 思路\n\n- 二叉树和链表都是递归\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null) return true;\n        if(p==null || q==null) return false;\n\n        return(p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"honeymeng-hub":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991874119","body":"//leetcode submit region begin(Prohibit modification and deletion)\n//遍历nums[]转化为数值，再遍历返回数组\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //idea1 ： FAILED，java中int最大2^32-1,（10位数）\n//        long tmp = 0;\n//        for (int i = num.length - 1, r = 1; i >= 0; i--) {\n//            tmp += num[i] * r;\n//            r = r * 10;\n//        }\n//        tmp = tmp + k;\n//        //从数值里取出元素放入链表\n//        String s = Long.toString(tmp);\n//        //String s1 = Integer.toString();\n//        ArrayList<Integer> list = new ArrayList<>();\n//        for (int j = 0; j < s.length(); j++) {\n//            int c = (int)s.charAt(j);\n//            list.add(Integer.parseInt(s1.valueOf(s.charAt(j))));\n//        }\n//        return list;\n        //看完答案想法二：位运算，位置对象相加，进位加在上一位\n        //评论区发现：num[]末尾+k ，取末尾添加到链表再抛弃末尾\n        //时间复杂度：O（n）数组长度\n        //空间复杂度：O（n）\n        LinkedList<Integer> list = new LinkedList<>();\n        int len = num.length;\n        int lastNum = k;\n        int i = len -1;\n        while (i >= 0 || lastNum > 0) {\n            if (i >= 0) {\n                lastNum += num[i];\n            }\n            //取余放入链表\n            list.addFirst(lastNum % 10);\n            //看看有没有进位(有就迭代，无就是0还是迭代)\n            lastNum /= 10;\n            i--;\n        }\n        return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992572641","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        //方法1：最小数组=====IDEA：每个字符 距离左 右字符的距离，较小的为答案\n        //从前向后遍历，记录i与左边边c的距离，从后向前遍历记录i与右边c距离，之后比较 num【i】存的数值，取小的\n        int len = s.length();\n        int[] ans = new int[len];\n        //定义迭代变量（c的初始位置）pre=Integer.MIN_VALUE / 2 （这里的数值不要紧，num【i】正反遍历会比较的）\n        int symbolC = Integer.MIN_VALUE / 2;\n        //正向遍历\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) symbolC = i;\n            ans[i] = i - symbolC;\n        }\n\n        //反向遍历\n        symbolC = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) symbolC = i;\n            ans[i] = Math.min(symbolC - i, ans[i]);\n        }\n        return ans;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994906916","body":"//感觉逻辑对了，明天再看看\nclass Solution {\n    public String decodeString(String s) {\n        //新手操蛋题\n        Stack<String> stack = new Stack<String>();\n        int len = s.length();\n        //定义中间的字符为空字符\n        String copyStr = \"\";\n        //定义要重复的次数\n        String copyCount = \"\";\n        for (int i = 0; i < len; i++) {\n            //\"!]\"入栈\n            if (\"]\".equals(s.charAt(i))) {\n                stack.push(s.charAt(i));\n            } else {\n                //弹栈（ \"]\"）\n                //遇见 [ 停止弹栈,取出字符\n                while (\"[\".equals(stack.pop())) {\n                    copyStr += stack.pop();\n                }\n                //继续出栈，非数字为止\n                if (stack.pop() >= 48 && stack.pop() <= 57)\n                    copyCount += stack.pop();\n                //最终字符串 copyCount 遍 copyStr 用字母大A表示\n                String A = \"\";\n                for (int j = 0; j < Integer.parseInt(copyCount); j++) {\n                    A += copyCount;\n                }\n                //整体放入栈中，此次for循环结束\n                stack.push(A);\n            }\n        }\n        return stack.pop();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995616449","body":"`栈` `队列` `经典`\n\n**思路** pop，push堆顶操作 ，队列enque，denque在队列两端操作，利用辅助栈来回倒腾即可\n\n```java\nclass MyQueue {\n//    MyQueue queue = new MyQueue();\n//queue.push(1);\n//queue.push(2);\n//queue.peek(); // 返回 1\n//queue.pop(); // 返回 1\n//queue.empty(); // 返回 false\n    Stack<Integer> pushStack = new Stack<>();\n    Stack<Integer> popStack = new Stack<>();\n\n    public MyQueue() {\n        //初始化不用管\n    }\n    \n    public void push(int x) {\n        //加在到队列末尾 \n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        //从队列开头移除并返回元素 译为 先进先出\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        //从队列开头移除并返回元素 译为 另个栈倒到这个栈，this.peek\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n```\n\n复杂度分析：\n\n时间：O(N) N为栈元素个数\n\n空间：O(N) N为栈中元素个数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997214107","body":"### \n\n`链表` \n\n**思路**:两个指针，间隔k，当left到达最后，说明旋转完成\n\n获取单链表的倒数第k，k+1节点，k.next = null , 原链表最后节点next=head\n\n```properties\n  获取链表的长度\n  k = k % 链表的长度\n  获取倒数第k + 1,倒数第K个节点与链表尾节点\n  倒数第k + 1个节点.next = null\n  链表尾节点.next = head\n  return 倒数第k个节点\n```\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        //拿到链表长度\n        while (now != null) {\n            now = now.next;\n            count++;\n        }\n        //简化旋转步数\n        k = k % count;\n        ListNode slow = head,fast = head;\n        //fast先走k步\n        while (fast.next != null) {\n            if (k-- <= 0) {\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        //首尾相连\n        fast.next = head;\n        //首位相连后的链表赋给 res；\n        ListNode res = slow.next;\n        //断开链表，新的尾巴指向null\n        slow.next = null;\n        return res;\n    }\n}\n```\n\n复杂度分析：\n\n时间：O（N）\n\n空间：O（1）未使用额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997760269","body":"`二叉搜索树` `链表`\n\n**思路**：双指针，找到中间位数，左边小，右边大，递归构建，参考当初手撸的树\n\n快指针速度=2*慢指针速度\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return dfs(head,null);\n    }\n\n    private TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) return null;\n        ListNode fast = head , slow = head;\n        //当前链表中间节点\n        while (fast != tail && fast.next != tail) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        //慢指针为根节点\n        TreeNode root = new TreeNode(slow.val);\n        //递归——条件\n        root.left = dfs(head, slow);\n        root.right = dfs(slow.next, tail);\n        return root;\n    }\n}\n\n```\n\n复杂度分析 n为链表长度\n\n时间：树深n，每层n，o(nlogn)\n\n空间：o(nlogn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999641178","body":"`双指针` `链表`\n\n**思路**：首先想到哈希表，遍历链表放入哈希表，元素已经存在代表环的入口\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        HashSet<ListNode> HS = new HashSet<ListNode>();\n        while (pos != null) {\n            if (HS.contains(pos)) {\n                return pos;\n            } else {\n                HS.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n```\n\n复杂度分析：\n\n时间：O（N）\n\n空间：O（N）\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000865784","body":"DFS` `数`\n\n**思路：** 最大深度用递归\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        //递归终止条件：递归到也自己欸但是返回0\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n\n复杂度分析\n\n时间；O（N），n为节点数\n\n空间：O（h），h为数的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001034692","body":"`递归` `层序遍历` `树`\n\n**思路** 遍历节点，递归比较\n\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n**复杂度分析**\n\n时间：O(N)， N 为节点数\n\n空间：O(h)，h 为高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shu-weiran":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991880602","body":"# 思路\n将K表示为数组，两个数组逐位相加。考虑进位。最后对数组取反。\n\n\n```\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n```\n\n# 时间复杂度O(n)\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996408803","body":"```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = nonzero = 0\n\n        for x, y in zip(arr, sorted(arr))\n            count[x] += 1\n            if count[x] == 0: nonzero -= 1\n            if count[x] == 1: nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1: nonzero += 1\n            if count[y] == 0: nonzero -= 1\n\n            if nonzero == 0: ans += 1\n\n        return ans\n\n```\n## 时间复杂度: O(N log N)O(NlogN)，其中 N 为 arr 的长度。空间复杂度: O(N)。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000350424","body":"创建一个双向链表用于存key和value, 一个map用于存储链表节点\n\n\nget时, 如果key在map中能找到对应的node, 返回node的val并且把node移动到链表头, 否则返回-1\nput时\nkey存在, 找到对应的node, 修改node的val, 并把node移动到链表头\nkey不存在, 创建新的node并移动到链表头, 如果map的size超过了cache的capacity, 需要同时把链尾的节点移除并且把map中的键值对移除\n代码\n\n```\nfunction ListNode(key, val) {\n    this.pre = null\n    this.next = null\n    this.key = key\n    this.val = val\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity\n    this.listNodeMap = new Map()\n    this.guardHead = new ListNode(null, null)\n    this.guardTail = new ListNode(null, null)\n    this.guardHead.next = this.guardTail\n    this.guardTail.prev = this.guardHead\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    const node = this.listNodeMap.get(key)\n    if (node) {\n        // 移动到head\n        this.moveToHead(node)\n        return node.val\n    } else {\n        return -1\n    }\n}; \n\nLRUCache.prototype.moveToHead = function(node) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n    this.guardHead.next.prev = node\n    node.next = this.guardHead.next\n    node.prev = this.guardHead\n    this.guardHead.next = node\n}\n\nLRUCache.prototype.addToHead = function(node) {\n    node.next = this.guardHead.next\n    this.guardHead.next.prev = node\n    node.prev = this.guardHead\n    this.guardHead.next = node\n}\n\nLRUCache.prototype.removeTail = function() {\n    this.guardTail.prev = this.guardTail.prev.prev\n    this.guardTail.prev.next = this.guardTail\n}\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    let node = this.listNodeMap.get(key)\n    if (node) {\n        this.moveToHead(node)\n        node.val = value\n        return \n    }\n    \n    node = new ListNode(key, value)\n    this.addToHead(node)\n    if (this.listNodeMap.size === this.capacity) {\n        this.listNodeMap.delete(this.guardTail.prev.key)\n        this.removeTail()\n    }\n    this.listNodeMap.set(key, node)\n};\n```\n复杂度\n时间复杂度: O(1)\n空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bryanmiracle":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991882687","body":"### 思路\r\n将数组和 k的对应项从右至左以此相加，进位时carry + 1；\r\n### 代码\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length - 1;\r\n\r\n        while (l1 >= 0 || k != 0) {\r\n            int x = l1 < 0 ? 0 : num[l1];\r\n            int y = k == 0 ? 0 : k % 10;\r\n\r\n            int sum = x + y + carry;\r\n            res.add(sum % 10);\r\n            carry = sum / 10;\r\n            l1--;\r\n            k = k / 10;\r\n        }\r\n        if (carry != 0) res.add(carry);\r\n        Collections.reverse(res);\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n**时间复杂度：O(N)**\r\n**空间复杂度：O(1)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992592481","body":"### 思路\r\n进行两次遍历\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997218854","body":"### 思路\r\n先将给定的链表连接成环，然后将指定位置断开\r\n### 代码\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add-- > 0) {\r\n            iter = iter.next;\r\n        }\r\n        ListNode ret = iter.next;\r\n        iter.next = null;\r\n        return ret;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"riuusee":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991883145","body":"### 思路\n\n模拟一位位相加，处理进位，处理被加数、加数为0的情况\n\n### 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        int c = 0;  //进位\n        for (int i = num.length-1; i >= 0; i--) {   //倒着一位位相加\n            int a = num[i] + k%10 + c;\n            if (a > 9){\n                c = 1;\n                a -= 10;\n                if (i == 0 && (k/10 == 0)){ //存在进位且加数为0\n                    result.add(a);\n                    result.add(1);\n                    break;\n                }\n            }else {\n                c = 0;\n            }\n            result.add(a);\n            k /= 10;\n            while (i==0 && k > 0){ //被加数为0加数不为0\n                int b = k%10 + c;\n                if (b > 9){\n                    if(b==10 && (k/10 == 0)){ //进位\n                        result.add(0);\n                        result.add(1);\n                        break;\n                    }\n                    b -= 10;\n                    c =1;\n                }else {\n                    c = 0;\n                }\n                result.add(b);\n                k /= 10;\n            }\n        }\n        Collections.reverse(result);  //反转\n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992538326","body":"### 思路\n\n分别向前后遍历找相同字符\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0; i < n; i++){\n            int t = 10001;\n            for (int j = i; j < n; j++) {\n                if (s.charAt(j) == c){\n                    int a = j - i;\n                    if (a < t){\n                        t = a;\n                    }\n                    break;\n                }\n            }\n            for (int j = i - 1; j >= 0; j--) {\n                if (s.charAt(j) == c){\n                    int a = i - j;\n                    if (a < t){\n                        t = a;\n                    }\n                    break;\n                }\n            }\n            ans[i] = t;\n        }\n\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(N*N)\n- 空间复杂度: O(N)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993597484","body":"### 思路\n\n数组实现栈\n\n### 代码\n\n```java\nclass CustomStack {\n\n    int[] s;\n    int top = -1;\n\n    public CustomStack(int maxSize) {\n        s = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top < s.length-1){\n            s[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top > -1){\n            return s[top--];\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        int t = k-1;\n        if (top < k-1){\n            t = top;\n        }\n        for (int i = 0; i <= t; i++) {\n            s[i] += val;\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: \n- push/pop O(1)\n- increment O(N)\n- 空间复杂度: O(N)\n\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995554997","body":"### 思路\n\n两个栈，一个进，一个出\n\n### 代码\n\n```java\nclass MyQueue {\n\n    private Stack pushStack;\n    private Stack popStack;\n\n    public MyQueue() {\n        popStack = new Stack();\n        pushStack = new Stack();\n    }\n\n    public void push(int x) {\n        pushStack.add(x);\n    }\n\n    public int pop() {\n        if (popStack.empty()){\n            while (!pushStack.empty()){\n                popStack.add(pushStack.pop());\n            }\n        }\n        return (int) popStack.pop();\n    }\n\n    public int peek() {\n        if (popStack.empty()){\n            while (!pushStack.empty()){\n                popStack.add(pushStack.pop());\n            }\n        }\n        return (int) popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(1)\n- 空间复杂度: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997207711","body":"### 思路\n\n1. 先计算总节点数，然后计算交换次数\n2. 用两个指针完成交换\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head; //简单判断\n        int n = 1; //用来计算总结点数\n        ListNode fast = head;\n        ListNode slow = null;\n        while (fast.next != null){\n            n++;\n            fast = fast.next;\n        }\n        k %= n;  //取余减少多余的修改次数\n        fast = head; //重置于首位置\n        for (int i = 0; i < k; i++) {\n            while (fast.next != null){ //找到每次的最末尾两个\n                slow = fast;\n                fast = fast.next;\n            }\n            slow.next = null; //倒数第二个next为null\n            fast.next = head; //最末尾变为首\n            head = fast; //更改首位置\n        }\n\n        return head;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999653942","body":"### 思路\n\n快慢指针，然后再相遇求节点\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        while (head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode index = head;\n        while (fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow){\n                while (slow != index){//从head开始相遇\n                    slow = slow.next;\n                    index = index.next;\n                }\n                return index;\n            }\n        }\n        return null;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kevinworkspace":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991884524","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int x = 0;\n        int add = 0;\n        while (i >= 0 || k > 0 || add == 1) {\n            if (i >= 0) x = num[i];\n            else x = 0;\n            int res = (x + k % 10 + add) % 10;\n            add = (x + k % 10 + add) / 10;\n            list.addFirst(res);\n            i --;\n            k /= 10;\n        }\n        return list;\n    }\n}\n```\n时间复杂度: O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992410373","body":"```java\npublic int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int index = Integer.MIN_VALUE / 2;\n        for (int i=0; i<s.length(); i++) {\n            if (s.charAt(i) == c) {\n                index = i;\n            }\n            else res[i] = i - index;\n        }\n        index = Integer.MAX_VALUE / 2;\n        for (int i=s.length()-1; i>=0; i--) {\n            if (s.charAt(i) == c) {\n                index = i;\n            }\n            else res[i] = Math.min(index - i, res[i]);\n        }\n        return res;\n    }\n```\n\n时间复杂度: O(N)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993457186","body":"```java\r\nclass CustomStack {\r\n\r\n     int[] stack;\r\n    int cnt;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        cnt = 0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (cnt < stack.length) {\r\n            stack[cnt++] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (cnt > 0) {\r\n            cnt --;\r\n            return stack[cnt];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int num = Math.min(k, cnt);\r\n        for (int i=0; i<num; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n时间复杂度: O(1)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994735343","body":"```java\r\npublic String decodeString(String s) {\r\n        int num = 0;\r\n        StringBuffer str = new StringBuffer();\r\n        Stack<Integer> nStack = new Stack<>();\r\n        Stack<StringBuffer> aStack = new Stack<>();\r\n        for (int i=0; i<s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if (c == '[') {\r\n                nStack.add(num);\r\n                aStack.add(str);\r\n                num = 0;\r\n                str = new StringBuffer();\r\n            }\r\n            else if (Character.isLetter(c)) {\r\n                str.append(c);\r\n            }\r\n            else if (c == ']') {\r\n                int n = nStack.pop();\r\n                StringBuffer buffer = aStack.pop();\r\n                for (int j=0; j<n; j++) {\r\n                    buffer.append(str);\r\n                }\r\n                str = buffer;\r\n            }\r\n        }\r\n        return str.toString();\r\n    }\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995766586","body":"```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!s2.isEmpty()) return s2.pop();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()) return s2.peek();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996651069","body":"```java\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int i=0; i<arr.length; i++) {\r\n            if (stack.isEmpty() || stack.peek() <= arr[i]) {\r\n                stack.add(arr[i]);\r\n            }\r\n            else if (stack.peek() > arr[i]) {\r\n                int top = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) stack.pop();\r\n                stack.add(top);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997188847","body":"```java\r\npublic ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        ListNode node = head;\r\n        int cnt = 0;\r\n        while (node != null) {\r\n            node = node.next;\r\n            cnt ++;\r\n        }\r\n        k = k % cnt;\r\n        if (k == 0) return head;\r\n        ListNode h = head;\r\n        node = head;\r\n        ListNode pre = null;\r\n        for (int i=0; i<k-1; i++) {\r\n            node = node.next;\r\n        }\r\n        while (node.next != null) {\r\n            pre = h;\r\n            node = node.next;\r\n            h = h.next;\r\n        }\r\n        pre.next = null;\r\n        node.next = head;\r\n        return h;\r\n    }\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997353234","body":"```java\r\npublic ListNode swapPairs(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return head;\r\n        ListNode dummyHead = new ListNode(0);\r\n        dummyHead.next = head;\r\n        ListNode node = head;\r\n        ListNode pre = dummyHead;\r\n        while (node != null) {\r\n            ListNode next = node.next;\r\n            if (next == null) return dummyHead.next;\r\n            ListNode nnext = next.next;\r\n            next.next = node;\r\n            pre.next = next;\r\n            node.next = nnext;\r\n            pre = node;\r\n            node = nnext;\r\n        }\r\n        return dummyHead.next;\r\n    }\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997849584","body":"```java\r\npublic TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val);\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        ListNode pre = null;\r\n        while (fast != null && fast.next != null) {\r\n            pre = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        pre.next = null;\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        return root;\r\n}\r\n```\r\n时间复杂度: O(NlogN)\r\n空间复杂度: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998707357","body":"```java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode n1 = headA;\r\n        ListNode n2 = headB;\r\n        while (n1 != n2) {\r\n            if (n1 == null) {\r\n                n1 = headB;\r\n            }\r\n            else n1 = n1.next;\r\n            if (n2 == null) {\r\n                n2 = headA;\r\n            }\r\n            else n2 = n2.next;\r\n        }\r\n        return n1;\r\n    }\r\n```\r\n时间复杂度: O(M + N)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999389501","body":"```java\r\npublic ListNode detectCycle(ListNode head) {\r\n        if (head == null) return null;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (slow == fast) break;\r\n        }\r\n        fast = head;\r\n        while (fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000282684","body":"```java\r\nclass LRUCache {\r\n\r\n    HashMap<Integer, Node> map = new HashMap<>();\r\n    Node head = new Node(-1);\r\n    int capacity;\r\n    Node tail = new Node(-1);\r\n    int size = 0;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        head.next = tail;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (map.containsKey(key)) {\r\n            Node node = map.get(key);\r\n            node.pre.next = node.next;\r\n            node.next.pre = node.pre;\r\n            Node hnext = head.next;\r\n            head.next = node;\r\n            node.next = hnext;\r\n            node.pre = head;\r\n            hnext.pre = node;\r\n            return node.value;\r\n        }\r\n        else return -1;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if (map.containsKey(key)) {\r\n            Node node = map.get(key);\r\n            node.value = value;\r\n            node.pre.next = node.next;\r\n            node.next.pre = node.pre;\r\n            Node hnext = head.next;\r\n            head.next = node;\r\n            node.next = hnext;\r\n            node.pre = head;\r\n            hnext.pre = node;\r\n        }\r\n        else {\r\n            Node node = new Node(value);\r\n            node.key = key;\r\n            Node hnext = head.next;\r\n            head.next = node;\r\n            node.next = hnext;\r\n            node.pre = head;\r\n            hnext.pre = node;\r\n            map.put(key, node);\r\n            size ++;\r\n            if (size > capacity) {\r\n                map.remove(tail.pre.key);\r\n                tail.pre.pre.next = tail;\r\n                tail.pre = tail.pre.pre;\r\n                size --;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        LRUCache cache = new LRUCache(2);\r\n        cache.put(2, 1);\r\n        cache.put(1, 1);\r\n        cache.put(2, 3);\r\n        cache.put(4, 1);\r\n        cache.get(1);\r\n        cache.get(2);\r\n    }\r\n}\r\n\r\nclass Node {\r\n    int value;\r\n    int key;\r\n    Node pre;\r\n    Node next;\r\n    public Node(int value) {\r\n        this.value = value;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000626881","body":"```java\r\nclass Solution {\r\n    int max = 0;\r\n\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        depth(root, 1);\r\n        return max;\r\n    }\r\n\r\n    public void depth(TreeNode root, int dep) {\r\n        if (dep > max) max = dep;\r\n        if (root.left != null) depth(root.left, dep + 1);\r\n        if (root.right != null) depth(root.right, dep + 1);\r\n    }\r\n}\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000987343","body":"```java\r\npublic boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n        if (p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luo-frontend":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991887936","body":"JavaScript\r\n思路：\r\n1、遍历数组，从高到低，每项加上K\r\n2、如果res >= 10, 将 k % 10，得到个位保留在num得当前下标，并计算Math.floot(k% 10),得到除个位外的数值res2\r\n例如 num = [1,2,3,4], k= 1234\r\n第一次循环：num[3] === 4, 4 + 1234 = 1238\r\nk% 10 = 8，push到新数组\r\nMath.floot(k% 10) = 123\r\n令k= 123，继续循环\r\n第二次循环：num[2] === 3, 3 + 123 = 126 \r\nk% 10 = 6，push到新数组\r\nMath.floot(k% 10) = 12\r\n令k= 12，继续循环\r\n...\r\n最后得到数组[2,4,6,8]\r\n需要注意的是，这里继续循环的条件不一定循环完整个数组，而是，循环完整个数据或循环完k，即 i >= 0  || k > 0\r\n因为k不一定是和数组的length相同，当满足上面两个条件中的一个即可以继续循环\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n时间复杂度O(max(n,log k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992075508","body":"思路:\r\n1、遍历字符串s, 将字符串中每一项 === c的下标存成数组arr\r\n2、遍历字符串s, 计算字符串中每一项和数组arr每一项的间距,保留最小值,并存在result数组\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    const indexArr = []\r\n    for(let i = 0; i < s.length; i++) {\r\n        if(s[i] === c) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    for(let i = 0; i < s.length; i++) {\r\n        let index = 1000\r\n        let a = 0\r\n        indexArr.forEach((item) => {\r\n            let b = Math.abs(i - item)\r\n            if(b <= index) {\r\n                a = b\r\n                index = b\r\n            } else {\r\n                a = index\r\n            }\r\n        })\r\n        res[i] = a\r\n    }\r\n    return res\r\n};\r\n```\r\n时间复杂度:O(nm) m为数组arr的长度,即c在字符串中下标的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993082455","body":"JavaScript\r\n思路:\r\n1、利用JS的push、pop方法,原理很简单,但是时间复杂度高,因为如果初始化没有给数组每项赋值,然后每次push都会是O(n)的时间,因为每次都需要重新申请地址.\r\n2、修改JS的push、pop方法,每次操作记录当前下标,这样能将push方法、pop方法降低O(1)的时间复杂度\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length > 0 ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0; i < k && i < this.stack.length; i ++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.curIndex = 0\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack[this.curIndex] = x\r\n        this.curIndex++\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.curIndex === 0) {\r\n        return -1\r\n    }\r\n    const res = this.stack[this.curIndex - 1]\r\n    this.stack.length-- \r\n    this.curIndex--\r\n    return res\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0; i < k && i < this.stack.length; i ++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n提交时证明我对于思路1的push、pop的时间复杂度是错误的,可能由于V8的优化,思路1比思路2快.\r\n时间复杂度: \r\npush:O(1)\r\npop:O(1)\r\nincrement:O(min(n, k)), n为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994373816","body":"JavaScript\r\n思路:\r\n首先明确使用栈的数据结构, 其次由于涉及到三种类型的字符串：数字、字母、[]符号,用一个栈肯定不合适,会导致判断出错,所以使用两个栈,分别存储数字和字母,同时还需要使用两个中间变量,用于存储数字变量和字母变量.最后就是遍历字符串:\r\n1、当遇到数字时,通过中间量将数字保存起来,同时要注意多个数字的组合\r\n2、当遇到[时,将数字变量push到数字栈中,重置数字变量;将字母变量push到字母栈中,重置字母变量\r\n3、当遇到]时,取出两个栈顶元素,组合两个栈顶元素的字符串,赋值给字母变量,\r\n4、通过上面三个判断剩下的就是字母了,当遇到字母的时候,追加给字母变量\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [];        // 存倍数的栈\r\n    let strStack = [];        // 存 待拼接的str 的栈\r\n    let num = 0;              // 倍数的“搬运工”\r\n    let result = '';          // 字符串的“搬运工”\r\n    for (const char of s) {   // 逐字符扫描\r\n        if (!isNaN(char)) {   // 遇到数字\r\n            num = num * 10 + Number(char); // 算出倍数\r\n        } else if (char == '[') {  // 遇到 [\r\n            strStack.push(result); // result串入栈\r\n            result = '';           // 入栈后清零\r\n            numStack.push(num);    // 倍数num进入栈等待\r\n            num = 0;               // 入栈后清零\r\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\r\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\r\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\r\n        } else {                   \r\n            result += char;        // 遇到字母，追加给result串\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n时间复杂度O(n*m) m为构建子串中最大的循环数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996665847","body":"JavaScript\r\n思路:\r\n最主要的思路是 当数组里某一项小于之前栈里面的任何一项时,pop,然后继续走\r\n```\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = [arr[0]];\r\n    let max = arr[0];\r\n    for(let i = 1; i < arr.length; i++) {\r\n        if(arr[i] >= max) {\r\n            max = arr[i];\r\n            stack.push(arr[i]);\r\n        } else {\r\n            while(stack && arr[i] < stack[stack.length - 1]) {\r\n                stack.pop();\r\n            }\r\n            stack.push(max);\r\n        }\r\n    }\r\n    return stack.length;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997217682","body":"```\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n\r\n    let add = n - k % n;\r\n    if (add === n) {\r\n        return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999615654","body":"```\r\nvar detectCycle = function(head) {\r\n     if (head === null) {\r\n        return null;\r\n    }\r\n    let slow = head, fast = head;\r\n    while(fast != null) {\r\n        slow = slow.next;\r\n        if(fast.next != null) {\r\n            fast = fast.next.next;\r\n        } else {\r\n            return null\r\n        }\r\n        if(fast == slow) {\r\n            fast = head;\r\n            while(fast != slow) {\r\n                fast = fast.next;\r\n                slow = slow.next;\r\n            }\r\n            return fast\r\n        }\r\n    }\r\n    return null\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jie-zi":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991888153","body":"思路：\r\n转换成两个vector，逐个按位相加，注意k可能比num长，因此要加上k比num长的部分\r\n```\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    int n=num.size();\r\n    for(int i=n-1;i>=0;i--){\r\n        int sum=num[i]+k%10;\r\n        k=k/10;\r\n        if(sum>=10){\r\n            sum=sum-10;\r\n            k++;\r\n        }\r\n        res.push_back(sum);\r\n    }\r\n    while(k){\r\n        res.push_back(k%10);\r\n        k=k/10;\r\n    }\r\n    reverse(res.begin(),res.end());\r\n    return res;\r\n    }\r\n```\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992490541","body":"此题不难求解，难点在于对每一种情况的分类讨论，边界可能只有一个，也可能存在多个\r\n```\r\nint n=s.size();\r\n        vector<int> res(n, 0), index;\r\n        for (int i = 0; i < n; i++) {\r\n\t\t    if (s[i] == c) index.push_back(i);\r\n\t    }\r\n\t    int j = 0;\r\n\t   for (int i = 0; i < n; i++) {\r\n\t        //若果只有一个边界\r\n\t\t    if (index.size() == 1) res[i] = abs(i - index[j]);\r\n\t\t    //若果有多个边界\r\n\t\t    else {\r\n\t\t\t    //小于左边界\r\n\t\t\t    if (i < index[j]) res[i] = abs(i - index[j]);\r\n\t\t\t    //大于右边界\r\n\t\t\t    else if(i > index[j+1]) res[i] = abs(i - index[j+1]);\r\n\t\t\t    //在左右边界中间\r\n\t\t\t    else if (index[j] <= i && i < index[j + 1]) \r\n\t\t\t\t    res[i] = min(abs(i - index[j]), abs(i - index[j + 1]));\t\r\n\t\t\t    //正好等于右边界，j需要＋1，注意j别超出边界\r\n\t\t\t    else if(i==index[j+1]){\r\n\t\t\t\t    res[i] = 0;\r\n\t\t\t\t    if (j < index.size() - 2) j++;\r\n\t\t\t    }\r\n\t\t    }\r\n\t    }\r\n        return res;\r\n```\r\n时间复杂度O(n) \r\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xjhcassy":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991891005","body":"#### 思路\n\n1. 采用LinkedList双向链表\n2. 将k依次加上num的各位，并取出最后一位\n\n代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n\n        int len = num.length;\n        int lastNum = k;\n        LinkedList<Integer> ret= new LinkedList<>();\n\n        int i = len-1;\n        while(i >=0 || lastNum > 0){\n            if(i >= 0){\n                lastNum+=num[i];\n            }\n            ret.addFirst(lastNum%10);\n            lastNum/=10;\n            i--;\n        }\n\n        return ret;\n\n    }\n```\n\n复杂度分析\n\n时间复杂度O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992419299","body":"### 思路\n\n1. 先找出字符c在字符串中的索引；\n2. 再循环找出字符串中每个字符到该字符的最短距离\n\n\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> index = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        int[] answer = new int[s.length()];\n        int shortest = 0;\n        for (int i = 0; i < s.length(); i++) {\n            shortest = Math.abs(i - index.get(0));\n            for (int j = 1; j < index.size(); j++) {\n                if(Math.abs(i - index.get(j)) < shortest){\n                    shortest = Math.abs(i - index.get(j));\n                }\n            }\n            answer[i] = shortest;\n        }\n\n        return answer;\n    }\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(N^2)，当找出的index在2最差情况下为所有的索引都包含时，此时复杂度达到O(N^2);\n\n空间复杂度：在最差情况下，需要开创N大小的ArrayList，所以空间复杂度为O(N); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993324962","body":"### 思路\n\n1. 使用LinkedList实现Stack；\n\n\n\n### 代码\n\n```java\nclass CustomStack {\n    private int maxSize;\n    private LinkedList<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        this.stack = new LinkedList<>();\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size() >= maxSize){\n            return;\n        }\n        stack.addLast(x);\n    }\n\n    public int pop() {\n        if(stack.size() == 0){\n            return -1;\n        }\n        return stack.removeLast();\n    }\n\n    public void increment(int k, int val) {\n        int num = Math.min(k, stack.size());\n        for (int i = 0; i < num; i++) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(min(k, stack.size));\n\n空间复杂度：O(1); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994704508","body":"### 思路\n\n1. 通过栈实现\n\n\n\n### 代码\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(S);\n\n空间复杂度：O(S); \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995687977","body":"### 思路\n\n1. 通过Java的LinkedList实现\n\n\n\n### 代码\n\n```java\nprivate Queue<Integer> queue;\n\n    public MyQueue() {\n        queue = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        queue.offer(x);\n    }\n\n    public int pop() {\n        return queue.poll();\n    }\n\n    public int peek() {\n        return queue.peek();\n    }\n\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(1);\n\n空间复杂度：O(1); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996633553","body":"### 思路\n\n1. 采用滑动窗口\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sortedArray = arr.clone();\n        Arrays.sort(sortedArray);\n        long arrSum = 0;\n        long sortedSum = 0;\n        int chunkCount = 0;\n        for (int i = 0; i < arr.length; i++) {\n            arrSum += arr[i];\n            sortedSum += sortedArray[i];\n            if(arrSum == sortedSum) chunkCount++;\n        }\n        return chunkCount;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(NlogN)，N 为数组长度，数组排序时间认为是 NlogN，滑动窗口遍历数组时间为 N。;\n\n空间复杂度：O(N); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997174919","body":"### 思路\n\n1. 采用快慢指针\n2. 快指针与慢指针都以每步一个节点的速度向后遍历\n3. 快指针比慢指针先走 k 步\n4. 当快指针到达终点时，慢指针正好是倒数第 k 个节点\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while (now != null) {\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while (fast.next != null) {\n            if (k-- <= 0) {\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(N)$，节点最多只遍历两遍\n\n空间复杂度：$O(1)$， 未使用额外的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997353745","body":"### 思路\n\n1. 所有的两两交换逻辑相同，因此仅需关注某一个两两交换即可；\n\n1. 对某一个链表A -> B，为进行交换，需要知道其前置节点preA，及后置节点nextB，即preA -> A -> B -> nextB，则修改的顺序为\n\n   1. A节点next指向nextB\n\n      > preA -> A -> nextB\n      >\n      > B -> nextB\n\n   1. B节点next指向A\n\n      > preA -> A -> nextB\n      >\n      > B -> A\n\n   1. preA节点next指向B\n\n      > preA -> B -> A -> nextB\n\n注：这里可以创建一个空节点preHead，让其指向A，使得我们可以专注算法逻辑，避免判断边界条件；\n\n使用虚拟节点后，对如preHead -> A -> B -> C -> D的链表，\n\n经过一次两两交换后变为 preHead -> B -> A -> C -> D，\n\n接着让preHead指向A，继续上述两两交换，直至整个链表被逆转\n\n\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n       if(head == null || head.next == null) return head;\n       ListNode preNode = new ListNode(-1, head), res;\n       preNode.next = head;\n       res = head.next;\n       ListNode firstNode = head, secondNode, nextNode;\n       while (firstNode != null && firstNode.next != null){\n           secondNode = firstNode.next;\n           nextNode = secondNode.next;\n\n           firstNode.next = nextNode;\n           secondNode.next = firstNode;\n           preNode.next = secondNode;\n\n           preNode = firstNode;\n           firstNode = nextNode;\n       }\n       return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(N)$，所有节点只遍历一遍\n\n空间复杂度：$O(1)$， 未使用额外的空间\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998705990","body":"### 思路\n\n1. 使用双指针\n\n\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = a.next ;\n            b = b.next;\n            if (a == null && b == null) return null;\n            if (a == null) a = headB;\n            if (b == null) b = headA;\n        }\n        return a;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(2(s1+s2+s3))$，$s1$为a距离交点的距离，$s2$为b距离交点的距离，$s3$为交点到链表尾部的距离\n\n空间复杂度：$O(1)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999511710","body":"### 思路\n\n1. 使用快慢指针\n\n\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(fast == slow){\n                ListNode slow2 = head;\n                while(slow2 != slow){\n                    slow = slow.next;\n                    slow2 = slow2.next;\n                }\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(N)$\n\n空间复杂度：$O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000256637","body":"### 思路\n\n1. 参考题解\n\n\n\n### 代码\n\n```java\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：各种操作平均都是 $O(1)$\n\n空间复杂度：链表占用空间 $O(N)$，哈希表占用空间也是 $O(N)$，因此总的空间复杂度为$O(N)$，其中 $N$ 为容量大小\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000830522","body":"### 思路\n\n1. 递归\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度： $O(N)$\n\n空间复杂度： $O(h)$，$h$为树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aladingzl":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991893686","body":"### 思路\n\n从低位开始，将 A 的每一位与 K 的每一位相加，和大于10时，记录进位 “+1”，将和放到数组中，考虑 K 的长度大于 A 的情况，最后将数组翻转，返回结果\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n   const res = [];\n   for(let i = num.length - 1; i >= 0; i--) {\n       let sum = num[i] + k % 10;\n       k = Math.floor(k / 10);\n       if(sum >= 10) {\n           k++;\n           sum -= 10;\n       } \n       res.push(sum);\n   }\n   for(; k > 0; k = Math.floor(k / 10)) {\n       res.push(k % 10);\n   }\n   res.reverse();\n   return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993084427","body":"### 思路\n\n用数组模拟一个栈，根据条件进行出栈跟入栈的操作，判断 k 与 length 的大小，对相应数量的元素进行增加 val 的操作\n\n### 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const ret = this.stack.pop();\n    if(!ret) return -1;\n    return ret; \n    \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < k && i < this.stack.length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：pop 和 push 操作 时间复杂度为 O(1) 增量操作的时间复杂度为 O(k)\n- 空间复杂度：O(maxSize)\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998496303","body":"### 思路\n\n利用哈希 Set 先遍历存储 A 的节点，再遍历 B 寻找 Set 中是否有一样的节点，若有则返回这个节点，否则返回 null\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let set = new Set();\n    let temp = headA;\n    while(temp !== null) {\n        set.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while(temp !== null) {\n        if(set.has(temp)) {\n            return temp;\n        }\n        temp = temp.next;\n    }\n    return null;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(M + N)，M，N 分别为两个链表的长度\n- 空间复杂度：O(M)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999537371","body":"### 思路\n\n之前有见过，有想到用两个指针。但只想到了一半，第一次相遇的时候不一定在入环处，还需要重新改变快指针的指向，等第二次相遇才是入口处，看了题解。\n\n### 代码\n\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let p = head, q = head;\n    while(true) {\n        if(q === null || q.next === null) return null;\n        p = p.next;\n        q = q.next.next;\n        if(p == q) {\n            break;\n        }\n    }\n    q = head;\n    while(p !== q) {\n        p = p.next;\n        q = q.next;\n    }\n    return q;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000837854","body":"### 思路\n\n递归\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) {\n        return 0;\n    } else {\n        const left = maxDepth(root.left);\n        const right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000981466","body":"### 思路\n\n判断终止的条件，利用递归分别比较左右子树，注意 不能写`if(p.val == q.val) return true;` 例如：[1,2] 跟 [1,null,2]\n\n### 代码\n\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n   if(p == null && q == null) return true;\n   if(p == null || q == null) return false;\n   if(p.val !== q.val) return false;\n   return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001101235","body":"### 思路\n\n看到二叉树第一时间想到 DFS、BFS，想到归想到，就是不知道怎么去处理这个过程，本来想记录层数，来处理个十百千位，好像不太行，看了题解，可以这样\n\n### 代码\n\n```javascript\nvar sumNumbers = function(root) {\n    const dfs = (root, preSum) => {\n        if(root === null) return 0;\n        const sum = preSum * 10 + root.val;\n        if(root.left === null && root.right === null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n    return dfs(root, 0);\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangdi-1291":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991893964","body":"-思路：从低位到高位依次计算，逐位将数字加在一起。任何时候，若加法的结果大于等于10，则进位为1。\r\n\r\n\r\n-代码:\r\n###\r\nclass Solution:\r\n\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        n = len(num)\r\n\r\n        ans = list()\r\n\r\n        carry = 0\r\n\r\n        for i in range(n):\r\n\r\n            res = k % 10\r\n\r\n            sum = num[n-i-1] + res + carry\r\n\r\n            carry = 0\r\n\r\n            k //= 10 \r\n\r\n            if sum >= 10:\r\n\r\n                carry = 1\r\n\r\n                sum = sum % 10\r\n\r\n            ans.append(sum)\r\n\r\n        if k % 10 == 0 and k // 10 == 0 and carry == 1:\r\n\r\n            ans.append(1)\r\n\r\n        else:\r\n\r\n            while k % 10 != 0 or k // 10 != 0:\r\n\r\n                sum = k % 10 + carry\r\n\r\n                carry = 0\r\n\r\n                k //= 10\r\n\r\n                if sum >= 10:\r\n\r\n                    carry = 1\r\n\r\n                    sum = sum % 10\r\n\r\n                ans.append(sum)\r\n\r\n            if k % 10 == 0 and k // 10 == 0 and carry == 1:\r\n\r\n                ans.append(1)\r\n\r\n        ans.reverse()\r\n\r\n        return ans\r\n\r\n-时间复杂度：O(max(len(num), num_k)), num_k 是k的位数。\r\n-空间复杂度：O(max(len(num), num_k)), num_k 是k的位数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992108370","body":"### 思路\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n### 代码\n\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> list[int]:\n        \n        n = len(s)\n        ans = list()\n        \n        for i in range(n):\n            l = i - 1\n            r = i\n            ri = li = 10**4\n            while r < n:\n                if s[r] == c:\n                    ri = r-i\n                    break\n                r += 1\n            while l >= 0:\n                if s[l] == c:\n                    li = i-l\n                    break\n                l -= 1\n            ans.append(min(ri, li))\n        return ans\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993568385","body":"### 思路\n用数组的想法处理栈\n\n### 代码\n\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top+1]\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, len(self.stk))\n        for i in range(lim):\n            self.stk += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\n- 空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994904993","body":"### 代码\n\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            string = \"\"\n            count = \"\"\n            if c == \"]\":\n                while stack and stack[-1] != \"[\":\n                    string = stack.pop() + string\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                stack.append(string * int(count))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为字符串长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995918248","body":"### 思路\n用两个栈且用栈的语言进行操作。\n\n### 代码\n\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.helpstack = []\n\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.helpstack.append(self.stack.pop())\n        self.stack.append(x)\n        while self.helpstack:\n            self.stack.append(self.helpstack.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        return not bool(self.stack)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中元素的个数。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996817780","body":"### 思路\n\n在遍历过程中，当遇到更小的元素时，就将之前的稍大的栈中的元素融合为这几个元素的最大值，输入到栈中。\n\n### 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for e in arr:\n            if stack and stack[-1] > e:\n                rec = stack[-1]\n                while stack and stack[-1] > e:\n                    stack.pop()\n                stack.append(rec)\n\n            else:\n                stack.append(e)\n        return len(stack)\n```\n###\n- 时间复杂度：O(N);\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997217638","body":"### 代码\n```\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997412779","body":"### 代码\r\n```\r\nif not head or not head.next: return head\r\n    ans = ListNode()\r\n    ans.next = head.next\r\n    pre = ans\r\n    while head and head.next:\r\n        next = head.next\r\n        n_next = next.next\r\n\r\n        next.next = head\r\n        pre.next = next\r\n        head.next = n_next\r\n        # 更新指针\r\n        pre = head\r\n        head = n_next\r\n    return ans.next\r\n```\r\n###\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998026388","body":"### 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n### \n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998872536","body":"### 代码：\n```\nstruct HashTable {\n    struct ListNode *key;\n    UT_hash_handle hh;\n};\n\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct HashTable *hashTable = NULL;\n    struct ListNode *temp = headA;\n    while (temp != NULL) {\n        struct HashTable *tmp;\n        HASH_FIND(hh, hashTable, &temp, sizeof(struct HashTable *), tmp);\n        if (tmp == NULL) {\n            tmp = malloc(sizeof(struct HashTable));\n            tmp->key = temp;\n            HASH_ADD(hh, hashTable, key, sizeof(struct HashTable *), tmp);\n        }\n        temp = temp->next;\n    }\n    temp = headB;\n    while (temp != NULL) {\n        struct HashTable *tmp;\n        HASH_FIND(hh, hashTable, &temp, sizeof(struct HashTable *), tmp);\n        if (tmp != NULL) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n```\n\n- 时间复杂度：O(m+n)，其中 m 和 n是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。\n- 空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999661745","body":"### 代码\n```py\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n***复杂度***\n- 时间复杂度：\nO(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)。\n- 空间复杂度：\nO(1)。我们只使用了 slow,fast,ptr 三个指针。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000360925","body":"### 代码\n``` py\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```\n***复杂度分析***\n\n- 时间复杂度：对于 put 和 get 都是 O(1)。\n- 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000871480","body":"### 代码\n```\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n```\n\n***复杂度分析***\n\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n- 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001039582","body":"### 代码\n```py\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n***复杂度分析***\n\n- 时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\n- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"offrande":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991894204","body":"第一天，慢慢学。。。复杂的思路想不出来\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return [int(s) for s in str(int(\"\".join(list(map(str,num))))+k)]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992415962","body":"思路：\n从头遍历，每次遇到c，就以c为中心向两边扩散，直到边界或者遇到第二个c停止。扩散时距离+1。距离取min(扩散距离，当前距离）\n\n代码：\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        distance = [float('inf') for _ in range(len(s))]\n        for i in range(len(s)):\n            ch = s[i]\n            if ch == c:\n                distance[i] = 0\n                while -1 < i-1 and distance[i-1] != c:\n                    distance[i-1] = min(distance[i-1], distance[i]+1)\n                    i -= 1\n                while i+1 < len(s) and distance[i+1] != c:\n                    distance[i+1] = min(distance[i+1], distance[i]+1)\n                    i += 1\n        return distance\n\n```\n\n时间：O(n^2)\n空间：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997350284","body":"- 递归\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999664255","body":"### 快慢指针\n### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        if head.next == head:\n            return head\n        \n        p = yummy = head\n        flag = False\n        ndict = {}\n\n        while p.next:\n            print(p.val)\n            if p in ndict.keys():\n                flag = True\n                break\n            else:\n                ndict.update({p:0})\n                p = p.next\n\n        if flag == True:       \n            while yummy.next != p:\n                yummy = yummy.next\n            return yummy.next\n        \n        return None\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kandejiandefeng":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991895510","body":"思路：把整数k裁成数组，两个倒叙 ，数组length大的循环，位数相加\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let kArr = k.toString().split('').map(item => parseInt(item));\n    let maxArr, minArr, a = 0;\n    if(kArr.length > num.length) {\n        maxArr = kArr.reverse();\n        minArr = num.reverse();\n    }else {\n        minArr = kArr.reverse();\n        maxArr = num.reverse();\n    }\n    const minLen = minArr.length\n    return maxArr.reduce((arr, item, index) => {\n        const n = index > minLen - 1 ? 0 : minArr[index];\n        arr.push((item + n + a) % 10);\n        a = Math.floor((item + n + a) / 10)\n        if(index === maxArr.length - 1 && a === 1) {\n            arr.push(1);\n        }\n        return arr;\n    }, []).reverse()\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992310988","body":"思路：找出第一个相同字符的索引，然后当前字符索引到c字符索引的差和当前字符和上一个索引的的差比较\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let resArr = [];\n    let n = 0; \n    let str = s;\n    let i, len = s.length;\n    for(i = 0; i < len; i++) {\n        const indexc = str.indexOf(c);\n        const index = i - n;\n        if(n === 0) {\n            resArr.push(indexc - index);\n        }else if(indexc < 0){\n            resArr.push(index + 1);\n        }else {\n            resArr.push(Math.min(indexc - index, index + 1));\n        }\n        if(indexc - index === 0) {\n            str = str.slice(indexc + 1);\n            n += indexc + 1;\n        }\n    }\n    return resArr;\n};\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993076299","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.value = new Array();\r\n    this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.value.length < this.size) {\r\n        this.value.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.value.length === 0) {\r\n        return -1;\r\n    } else {\r\n        return this.value.pop();\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let i = 0;\r\n    for(i; i < k; i++) {\r\n        if(!this.value[i]) {\r\n            break;\r\n        }\r\n        this.value[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994798695","body":"思路：找到第一个[计数，当找到对应数量的]后，截取循环前面数字次，然后替换掉原字符串，重复上面步骤，知道没有【】为止\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    while (/\\d\\[.*?\\]/g.test(s)) {\r\n        const len = s.length;\r\n        let i = 0;\r\n        let n = 0,\r\n            start = 0,\r\n            end = 0;\r\n        for (i; i < len; i++) {\r\n            if (s[i] === '[') {\r\n                n++;\r\n                if (n === 1) {\r\n                    start = i;\r\n                }\r\n            } else if (s[i] === ']') {\r\n                n--;\r\n                if (n === 0) {\r\n                    end = i;\r\n                    const str = s.slice(start, end + 1);\r\n                    const num = parseInt(s.match(/\\d.*/) &&\r\n                        s.match(/\\d.*/)[0]);\r\n                    s = s.replace(str, (e) => {\r\n                        let strP = ''\r\n                        for (let index = 0; index < num; index++) {\r\n                            strP += str.slice(1, str.length - 1);\r\n                        }\r\n                        return strP;\r\n                    });\r\n                    s = s.slice(0, start - num.toString().length) + s.slice(start);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n};\r\n```\r\n复杂度O(n2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995694652","body":"```\nvar MyQueue = function() {\n    this.list = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.list.shift();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.list[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.list.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001084443","body":"解题思路\n定义一个数组来收集所有的值；\n使用前序遍历\n把所有的值相加\n```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (root == null) return 0;\n    let path = [];\n    const DFS = (root, sum) => {\n        if (root == null) return;\n        if (root.left == null && root.right == null) {\n            sum = sum * 10 + root.val;\n            path.push(sum);\n        }\n        sum = sum * 10 + root.val;\n        DFS(root.left, sum);\n        DFS(root.right, sum);\n    }\n    DFS(root, 0);\n    return path.reduce((prev, next) => {\n        return prev + next;\n    }, 0);\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rmadridxdh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991896853","body":"### 代码\n```Python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,A))) + K)))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992518963","body":"### 思路\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值\n### 代码\n`python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        answer = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            answer.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            answer [i] = min(answer [i], prev - i)\n\n        return answer\n`\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。\n- 空间复杂度：O(N)O(N)，answer 数组的大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993638756","body":"### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994910439","body":"### 代码\n\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995935567","body":"### 代码\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -> None:\n        self.stack_in.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        \n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for i in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -> int:\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n        return not (self.stack_in or self.stack_out)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996783632","body":"### 代码\n\n\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.Counter()\n        counted = []\n        for x in arr:\n            count[x] += 1\n            counted.append((x, count[x]))\n\n        ans, cur = 0, None\n        for X, Y in zip(counted, sorted(counted)):\n            cur = max(cur, X)\n            if cur == Y:\n                ans += 1\n        return ans\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997218041","body":"### 代码\n\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997400202","body":"### 代码\n\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummyHead = ListNode(0)\n        dummyHead.next = head\n        temp = dummyHead\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return dummyHead.next\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998034760","body":"### 代码\n\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getLength(head: ListNode) -> int:\n            ret = 0\n            while head:\n                ret += 1\n                head = head.next\n            return ret\n        \n        def buildTree(left: int, right: int) -> TreeNode:\n            if left > right:\n                return None\n            mid = (left + right + 1) // 2\n            root = TreeNode()\n            root.left = buildTree(left, mid - 1)\n            nonlocal head\n            root.val = head.val\n            head = head.next\n            root.right = buildTree(mid + 1, right)\n            return root\n        \n        length = getLength(head)\n        return buildTree(0, length - 1)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998847228","body":"### 代码\n\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999636268","body":"### 代码\n\n\n```python\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000356973","body":"### 代码\n\n\n```python\nclass LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        super().__init__()\n        self.capacity = capacity\n\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000406913","body":"### 代码\n\n\n```python\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001005018","body":"### 代码\n\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzpppy":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991898319","body":"思路：\r\n使用arraylist做为新数组存最后的值，从后遍历数组中的每一位数，分别与k的个位相加，如果有进位则用一个carry存进位，每一位最后的值就是k的个位+A数组的值+carry，最后当k为0且A遍历完之后，如果carry有进位则要加入新数组，然后因为新数组是从个位加进新数组中的，最后的结果便要把它反过来。\r\n\r\n代码：\r\npublic List<Integer> addToArrayForm(int[] A, int K) {\r\n    List<Integer> res = new ArrayList<>();\r\n    int carry = 0;\r\n    int l1 = A.length - 1;\r\n    while (l1 >= 0 || K != 0) {\r\n        int x = l1 < 0 ? 0 : A[l1];\r\n        int y = K == 0 ? 0 : K % 10;\r\n\r\n        int sum = x + y + carry;\r\n        res.add(sum % 10);\r\n        carry = sum / 10;\r\n\r\n        l1--;\r\n        K = K / 10;\r\n    }\r\n    if (carry != 0) res.add(carry);\r\n    Collections.reverse(res);\r\n    return res;\r\n}\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992485915","body":"**思路**：\r\n两次遍历，首先从左边遍历得到第一次的距离值，然后再从右边遍历得到右边值，两个值比较最小的变小最终结果\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int pre = Integer.MIN_VALUE/2;\r\n        for(int i = 0 ; i < s.length();i++){\r\n            if(s.charAt(i) == c)\r\n            pre = i;\r\n            res[i] = i-pre;\r\n        }\r\n        pre = Integer.MAX_VALUE/2;\r\n        for(int i = s.length()-1; i >=0;i--){\r\n            if(s.charAt(i) == c)\r\n            pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n**复杂度**\r\n时间复杂度 O(N)\r\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993561012","body":"**思路**\r\n使用数组模拟，push操作判断是否为栈顶，不为栈顶top右移赋值。\r\npop操作判断是否为空，为空top==-1；不为空top右移依次减值\r\n批量增判断k与栈顶比较，选较小的作为范围，然后依次赋值\r\n**代码**\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length-1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1)\r\n        return -1;\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = Math.min(k,top+1);\r\n        for(int i = 0; i < k;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度**\r\n时间复杂度：O(1)\r\n空间复杂度:  O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994821056","body":"**思路**\n辅助栈\n今天看的题解，不太会\n**代码**\n```\nclass Solution {\n    \n    public String decodeString(String s) {\n        Queue<Character> q=new LinkedList<>();\n        for(char c:s.toCharArray()){\n            q.offer(c);\n        }\n        return decodeString(q);\n    }\n    \n    public String decodeString(Queue<Character> q){\n        StringBuilder res=new StringBuilder();\n        int num=0;\n        while(!q.isEmpty()){\n            char c=q.poll();\n            if(c>='0'&&c<='9'){\n                num=10*num+(c-'0');\n            }\n            else if(c=='['){\n                String tmp=decodeString(q);\n                while(num>0){\n                    res.append(tmp);\n                    num--;\n                }\n            }\n            else if(c==']'){\n                return res.toString();\n            }\n            else {\n                res.append(c);\n            }\n\n        }\n        return res.toString();\n    }\n}\n```\n**复杂度**\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995856507","body":"**思路**\n队列的特性是先进先出，栈的特性是先进后出，利用两个队列或者两个栈实现都是一样的原理，来回倒腾就可以实现这一功能\n**代码**\n```\nclass MyQueue {\n    Deque<Integer> out;\n    Deque<Integer> in;\n\n    public MyQueue() {\n      in = new ArrayDeque<>();\n      out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        while(!out.isEmpty())\n        in.addLast(out.pollLast());\n        in.addLast(x);\n    }\n    \n    public int pop() {\n        while(!in.isEmpty())\n        out.addLast(in.pollLast());\n        return out.pollLast();\n    }\n    \n    public int peek() {\n        while(!in.isEmpty())\n        out.addLast(in.pollLast());\n        return out.peekLast();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n```\n**复杂度**\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996688641","body":"这个确实不会了，直接看的题解\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997200114","body":"**思路**\n快指针先走k步。\n慢指针和快指针一起走。\n快指针走到链表尾部时，慢指针刚好走到旋转链表（返回的链表）的尾部。把快指针指向的节点连到原链表头部，慢指针指向的节点断开和下一节点的联系。\n返回结束时慢指针指向节点的下一节点。\n**代码**\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0){\n            return head;\n        }\n        ListNode temp = head;\n        ListNode fast = head;\n        ListNode slow = head;\n        int len = 0;\n        while(head != null){\n            head = head.next;\n            len++;\n        }\n        if(k % len == 0){\n            return temp;\n        }\n        while((k % len) > 0){\n            k--;\n            fast = fast.next;\n        }\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode res = slow.next;\n        slow.next = null;\n        fast.next = temp;\n        return res;\n    }\n}\n\n```\n**复杂度**\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997402004","body":"**思路**\n对需要交换的两个节点进行处理，head连接后面完成的子链表，next连接head，子链表进行递归操作就可以完成两两交换\n**代码**\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n\n    }\n}\n```\n**复杂度**\n时间复杂度 O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997979146","body":"**思路**\n使用快慢指针进行递归，首先他是升序排序的序列，只要找到中间节点就是它的根节点，中间节点左边的节点就是左子树的所有节点，中间节点右边的节点就是右子树的所有节点，再依次递归就可以得到最后的结果\n**代码**\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null)\n           return null;\n        if(head.next == null)\n           return new TreeNode(head.val);\n        ListNode slow = head, fast = head , pre = null;\n        while(fast != null && fast. next != null){\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        } \n        pre.next = null;\n        TreeNode node = new TreeNode(slow.val);\n        node.left = sortedListToBST(head);\n        node.right = sortedListToBST(slow.next);\n        return node;\n    }\n}\n```\n**时间复杂度**\n时间复杂度：O(NlogN)\n空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998848757","body":"**思路**\n双指针，一个指针指向a，一个指针指向b，同时遍历两条链表，不相等则后移，若遍历完本链表则指向另外一条链表，相等则返回相等的值\n**代码**\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n        while(p1 != p2){\n            p1 = p1 != null ? p1.next : headB;\n            p2 = p2 != null ? p2.next : headA;\n        }\n        return p1;\n    } \n}\n```\n**复杂度**\n时间复杂度：O(N+M) N 、M两链表长度\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999642545","body":"**思路**\n双指针算法，fast每次走两步，slow每次走一步，只要fast以及fast.next不为空则存在环，fast走的快先进入环，slow后进入环，而他们必定会在环中相遇，假设head到环入口为x，入口到相遇点为y，相遇点到入口为z，fast走的距离就是x+y+n（y+z），slow走的距离则是x+y，而每次fast2步slow1步，则fast走的步数是slow的2倍，也就是可以得到x = z，也就可以理解为从head和相遇节点分别走，每次一步，两点相遇的位置就是环的入口\n**代码**\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null ){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                ListNode r = fast;\n                ListNode l = head;\n                while(l != r){\n                    l = l.next;\n                    r = r.next;\n                }\n                return r;\n            }\n        }\n        return null;  \n    }\n}\n\n```\n**复杂度**\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000388116","body":"太难了，不会\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    // 这个可不写\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000868718","body":"**思路**\nDFS+递归\n**代码**\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null)\n        return 0;\n        else{\n            int left = maxDepth(root.left);\n            int right = maxDepth(root.right);\n            return  Math.max(left,right)+1;\n        }\n    }\n}\n```\n**复杂度**\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001040060","body":"**思路**\n递归依次判断三种情况返回值，递归左右子树\n**代码**\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) \n            return true;\n        if(p == null || q == null) \n            return false;\n        if(p.val != q.val) \n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);  \n    }\n}\n```\n**复杂度**\n时间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uniqlell":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991899440","body":"``` java\n/**\n使用一个字母表示进位情况\n */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer>list = new ArrayList<>();\n        int n = num.length;\n        int f = 0;\n        while(k>0||n>0){\n           int  yu = k%10;\n           int sum = 0;\n           if(n>0)\n             sum = num[n-1]+yu+f;\n            else sum = yu+f;\n            f  =0;\n            list.add(0,sum%10);\n            if(sum>9)\n            f  = 1;\n            n--;\n            k = k/10;\n        }\n        if(f>0)\n        list.add(0,f);\n        return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992543934","body":"### 思路\n#### 思路一：使用双指针\n- 1.以当前字符为中心，向两边展开，先遇到的为最小的，得到abs(minus)\n- 2.遍历所有的字符\n- 时间复杂度o（n2）\n- 空间复杂度o（n）\n``` \nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int l,r;\n        int arr[] = new int[n];\n        for(int i=0;i<n;i++){\n            l = i;\n            r = i;\n           while(l>=0&&s.charAt(l)!=c)l--;\n           while(r<n&&s.charAt(r)!=c)r++;\n           if(l<0)arr[i] = r-i;\n           else if(r>=n)arr[i] = i-l;\n           else arr[i] = Math.min(i-l,r-i);\n        }\n        return arr;\n    }\n}\n```\n\n#### 思路二：两次遍历\n- 1.记录左边最近的或者没有的话记为-999\n- 2.记录右边最近的或者没有的话记为最大值\n- 时间复杂度o（n）\n- 空间复杂度o（n）\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int arr[] = new int[n];\n        int temp = -999;\n        for(int i=0;i<n;i++){\n            if(s.charAt(i)==c){\n                temp = i; \n            }\n            arr[i] = i-temp;\n        }        \n        temp = 20000;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i)==c){\n                temp = i;\n            } \n            arr[i] = Math.min(arr[i],temp-i);\n        }\n        return arr;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993595590","body":"\n### 思路:常规方法\n- push的时候考虑st.size()是否大于max\n- pop()的时候考虑st是否为空\n- 使用一个index记录栈里面的元素的个数，与maxSize进行比较\n    这里的index要与k进行比较,取较小值对每个进行加的操作\n``` java\n    \nclass CustomStack {\n    int[] arr;\n    int index;\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        index = -1;\n\n    }\n    \n    public void push(int x) {\n       if(arr.length-1==index)\n       return;\n       arr[++index] = x;\n    }\n    \n    public int pop() {\n        if(index!=-1){\n            int val = arr[index];\n            arr[index--]=0;\n            return val;\n        }else{\n            return -1;\n        }\n    }\n    public void increment(int k, int val) {\n        int len = Math.min(k,index+1);\n        for(int i=0;i<len;i++){\n            arr[i] += val;\n        }\n    }\n}\n``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994878903","body":"\n### 思路：使用栈的思想\n- 使用双栈的思想，一个栈用于保存倍数数字，另外一个栈用于保存字符串\n遍历所有的字符，每个字符c\n- 当c为数字字符的时候直接将c转化为数字，这里要注意数字字符连续的情况\n- 当c为字符的时候，直接添加到res\n- 当字符c为[时将mul和res分别append到每个栈中,并将两个参数更新为0和\"\"\n- 当字符c为]的时候res=last_res+cur_res*mul\n``` java\nclass Solution {\n    public String decodeString(String s) {\n       Deque<Integer>digit = new LinkedList<>();\n       Deque<String>str = new LinkedList<>();\n       StringBuilder res = new StringBuilder();\n       int mul = 0;\n       for(Character c:s.toCharArray()){\n           if(c>='0'&&c<='9'){\n               mul = mul*10+(c-'0');\n           }else if(c=='['){\n               digit.addLast(mul);\n               str.addLast(res.toString());\n               res = new StringBuilder();\n               mul = 0;\n           }else if(c==']'){\n               StringBuilder temp = new StringBuilder();\n               int n = digit.removeLast();\n               for(int i=0;i<n;i++){\n                   temp.append(res);\n               }\n               res = new StringBuilder(str.removeLast()+temp);\n           }else{\n               res.append(c);\n           }\n       }\n       return res.toString();\n    }\n}   \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995689097","body":"### 思路：\n\n- 使用栈实现队列要使用两个栈，一个入栈，一个出栈\n### 代码\n``` java\nclass MyQueue {\n    Stack<Integer>in;\n    Stack<Integer>out;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n       in = new Stack<>();\n       out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    //必须要判断out是否为空，如果为空才需要将in中的元素搬过来\n    public int pop() {\n       if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }\n       return out.pop();\n    }\n    \n    /** Get the front element. */\n    //必须要判断out是否为空，如果为空才需要将in中的元素搬过来\n    public int peek() {\n         if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }      \n       return out.peek();\n    }\n    ```\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty()&&out.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996778735","body":"## 思路：单调栈\n``` java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n       Deque<Integer>st = new ArrayDeque<>();\n       for(int num:arr){\n           if(!st.isEmpty()&&num<st.peek()){\n               int cur = st.pop();\n               while(!st.isEmpty()&&num<st.peek()){\n                   st.pop();\n               }\n               st.push(cur);\n           }else{\n               st.push(num);\n           }\n       }\n       return st.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997174494","body":"``` java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) {\n            return head;\n        }\n        ListNode p = head;\n        int len = 1;\n        while (p.next != null) {\n            p = p.next;\n            len++;\n        }\n        p.next = head;\n        k %= len;\n        p = head;\n        for (int i = 0; i < len - k - 1; i++) {\n            p = p.next;\n        }\n        ListNode result = p.next;\n        p.next = null;\n        return result;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997387393","body":" ###  思路:递归\n ``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null||head.next==null)return head;\n        ListNode res = head.next;\n        head.next = swapPairs(res.next);\n        res.next = head;\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997940370","body":"```\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * } \n```\n### 思路:递归\n - 找到中间节点作为根节点\n    - 1.使用快慢指针fast,low,当fast到了末尾的时候，中间节点即为根节点\n    - 2.分为两段进行递归\n``` java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null)return null;\n        return dfs(head,null);\n    }\n    public TreeNode dfs(ListNode head,ListNode tail){\n        if(head==tail)return null;\n        ListNode fast=head,slow = head;\n        while(fast!=tail&&fast.next!=tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = dfs(head,slow);\n        root.right = dfs(slow.next,tail);\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998610647","body":"```\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n ```\n\n###  思路：两个链表分别遍历到末尾，然后从另一个链表头部遍历，得到相交的结就返回\n ``` java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode A = headA;\n        ListNode B = headB;\n        while(A!=B){\n            A = A==null?headB:A.next;\n            B = B== null?headA:B.next;\n        }\n        return A;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999322950","body":"``` \n* Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n```\n### 思路一：快慢指针\n - slow走一步，fast走两步，如果不相遇，返回null\n - 如果相遇，将其中一个从head开始，两者一步一步走，相遇即为相交的节点\n\n### 思路二：使用hash来进行存储\n - 重复两次的即为环的节点\n``` java \npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n      ListNode fast = head;\n      ListNode slow = head;\n      while(fast!=null&&fast.next!=null){\n          fast = fast.next.next;\n          slow = slow.next;\n          if(fast==slow){\n              slow = head;\n              while(slow!=fast){\n                  slow = slow.next;\n                  fast = fast.next;\n              }\n              return slow;\n          }\n      }\n      return null;\n    }\n}\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null)return null;\n      Set<ListNode>set = new HashSet<>();\n      ListNode temp = head;\n      while(temp.next!=null){\n          if(set.contains(temp))\n            return temp;;\n            set.add(temp);\n            temp = temp.next;\n      }\n      return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000332026","body":"``` java\nclass LRUCache {\n    Map<Integer,Node>map;\n    DoubleLinkedList cache;\n    int cap;\n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        cache = new DoubleLinkedList();\n        cap = capacity;\n    }\n    public void put(int key, int val) {\n        Node newNode = new Node(key,val);\n        if(map.containsKey(key)){\n            //删除旧的链表节点\n            cache.delete(map.get(key));\n            //增加新的链表节点\n            cache.addFirst(newNode);\n            map.put(key,newNode);\n        }else{\n            if(map.size()==cap){\n                //删除最后的节点，两个数据结构都要删除\n                int k = cache.deletetail();\n                map.remove(k);\n            }\n                //更新节点，两个数据结构都要更新\n                cache.addFirst(newNode);\n                map.put(key,newNode);\n        }\n    }\n    public int get(int key) {\n        if(!map.containsKey(key))return -1;\n        int val = map.get(key).val;\n        put(key,val);\n        return val;\n    }\n    \n}\n\n\n/**\nhead:recent used\ntail:least recent used\n */\nclass DoubleLinkedList{\n    Node head;//这里的head是一直指向第一个节点的，addFirst相当于再head后面添加一个节点\n    Node tail;\n    public DoubleLinkedList(){\n        head = new Node(0,0);\n        tail = new Node(0,0);\n\n        head.next = tail;\n        tail.prev = head;\n    }\n    //插入双向链表头结点\n    public void addFirst(Node node){\n\n        node.next = head.next;\n        node.prev = head;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n    //得到删除节点的key\n    public int delete(Node n){\n        int key = n.key;\n        n.next.prev = n.prev;\n        n.prev.next = n.next;\n        return key;\n    }\n    //得到删除尾节点的key\n    public int deletetail(){\n        if(head.next==tail)return -1;\n        return delete(tail.prev);\n    }\n}\n\nclass Node{\n    public int key;\n    public int val;\n    public Node prev;\n    public Node next;\n    public Node(int key,int val){\n        this.val = val;\n        this.key = key;\n    }\n}\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000749690","body":"``` \n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n```\n### 思路一：使用队列（BFS）\n### 思路二：递归(DFS)\n``` java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null)return 0;\n        Deque<TreeNode>queue = new LinkedList<>();\n        queue.add(root);\n        int deep = 0;\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            deep++;\n            for(int i=0;i<size;i++){\n                TreeNode tempNode = queue.removeFirst();\n                if(tempNode.left!=null)queue.add(tempNode.left);\n                if(tempNode.right!=null)queue.add(tempNode.right);\n            }\n        }\n        return deep;\n    }\n}\n\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        return root==null?0:Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001002282","body":"```\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n ```\n ### 思路：使用递归的思想\n``` java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n           if(p==null&&q==null)return true;\n           else if(p!=null&&q!=null&&p.val==q.val){\n               return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n           }\n           else return false;\n           \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alongchong":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991900063","body":"###思路\r\n从后往前加，然后翻转\r\n###代码\r\n```JAVA\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n    List<Integer> ans = new ArrayList<Integer>();\r\n        int l = num.length ;\r\n        int m = 0;\r\n        for (int i = l-1 ; i >= 0 ; i--){\r\n             m = num[i] + k % 10 ;\r\n             k /= 10;\r\n             if (m >= 10){\r\n                 k++;\r\n                 m -=10;\r\n             }\r\n             ans.add(m);\r\n        }\r\n          for (; k > 0; k /= 10) {\r\n           ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;        \r\n   }\r\n}\r\n```\r\n***复杂度分析***\r\n时间复杂度：$0(N)$\r\n空间复杂度：$0(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992597026","body":"###思路\n这题想了30分钟，想不出。思路来自于题解\n###代码\n```JAVA\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993626874","body":"###思路\r\n先看了一下讲义，大概了解栈。然后按照题目给的要求一步步写出，不过最开始的思路最后不是用的Math.min()。看了题解觉得题解的好，就成我的思路了。\r\n###代码\r\n```JAVA\r\nclass CustomStack {\r\n    int [] stack;\r\n    int top ;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top !=stack.length - 1 ){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == - 1){\r\n            return -1;\r\n        } \r\n        top--;\r\n        return stack[top + 1];\r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int minvalue = Math.min(k, top + 1);\r\n        for(int i = 0; i < minvalue; i++ ){\r\n            stack[i] += val; \r\n        }\r\n\r\n    }\r\n}\r\n\r\n```\r\n***复杂度分析***\r\n看了评论才知道怎么分析\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994836248","body":"###思路\n没有思路，看的题解。这种题目，对于此时的我还是太难了。\n###代码\n```JAVA\n   public String decodeString(String s) {\n\t\tStringBuffer ans=new StringBuffer();\n\t\tStack<Integer> multiStack=new Stack<>();\n\t\tStack<StringBuffer> ansStack=new Stack<>();\n\t\tint multi=0;\n\t\tfor(char c:s.toCharArray()){\n\t\t\tif(Character.isDigit(c))multi=multi*10+c-'0';\n\t\t\telse if(c=='['){\n\t\t\t\tansStack.add(ans);\n\t\t\t\tmultiStack.add(multi);\n\t\t\t\tans=new StringBuffer();\n\t\t\t\tmulti=0;\n\t\t\t}else if(Character.isAlphabetic(c)){\n\t\t\t\tans.append(c);\n\t\t\t}else{\n\t\t\t\tStringBuffer ansTmp=ansStack.pop();\n\t\t\t\tint tmp=multiStack.pop();\n\t\t\t\tfor(int i=0;i<tmp;i++)ansTmp.append(ans);\n\t\t\t\tans=ansTmp;\n\t\t\t}\n\t\t}\n\t\treturn ans.toString();\n\t}\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(N)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995927875","body":"###思路\n从后往前加，然后翻转\n###代码\n```JAVA\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    private int front;\n\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n   public void push(int x) {\n    if (stack1.isEmpty())\n        front = x;\n    stack1.push(x);\n        \n    }\n    \n    public int  pop(){\n        if(stack2.isEmpty()){\n            while(!stack1.isEmpty()){\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(!stack2.isEmpty()){\n            return stack2.peek();\n        }\n        return front;\n\n    }\n    \n  \n    public boolean empty() {\n        return stack1.isEmpty()&&stack2.isEmpty();\n\n    }\n}\n```\n***复杂度分析***\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996567417","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr){\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        } \n        return stack.size();\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997190009","body":"###思路\n慢慢来。\n###代码\n```JAVA\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414339","body":"\n###代码\n```JAVA\nclass Solution {\n   public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997969530","body":"###思路\r\n\r\n###代码\r\n```JAVA\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998817899","body":"###思路\n看的题解，对于双指针了解更深了\n###代码\n```JAVA\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null){\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB){\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next; \n        }\n        return pB;\n    }\n}\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999569272","body":"###思路\n最开始想的是快慢指针，但是后面想不出了，去看的题解。哈希表是第二想法。\n###代码\n```JAVA\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();   //哈希表构建\n        while (pos != null) {\n            if (visited.contains(pos)) {\t\t\t\t\t\t\t\t\t//是否遍历过\n                return pos;\n            } else {\n                visited.add(pos);\t\t\t\t\t\t\t\t\t\t\t\t\t//没有就把当前的加进去\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(N)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000319831","body":"###思路\n只想到用HashMap 后面不知道怎么结合 ，太菜了\n###代码\n```JAVA\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode (int _key, int _value){\n            key =_key; \n            value = _value;\n        }\n    }\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>(){};\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.next = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null){\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null){\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            size++;\n            if(size > capacity){\n                DLinkedNode tail = removeTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        }else{\n            node.value = value;\n            moveToHead(node);\n        }\n\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n***复杂度分析***\n时间复杂度：$0(1)$\n空间复杂度：$0(N)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000846175","body":"###思路\n###代码\n```JAVA\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int leftHeight = maxDepth(root.left);\n            int rightHeight = maxDepth(root.right);\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n    }\n}\n\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(树高度)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001035208","body":"\n###代码\n```JAVA\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n\n\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tesla-1i":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991900400","body":"```\nclass Solution:\n    def addToArrayForm(self, num, k) :\n        res = []\n        for n in num[::-1]:\n            k += n \n            res.insert(0, k%10)\n            k //= 10\n        while k:\n            res.insert(0, k%10)\n            k //= 10\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992300306","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s, c):\r\n        pre = float('-inf')\r\n        res = []\r\n        for i,number in enumerate(s):\r\n            if number == c:\r\n                pre = i\r\n            res.append(i - pre)\r\n        pre = float('inf')\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c:\r\n                pre = j\r\n            res[j] = min(res[j], pre - j)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993414901","body":"```Python 参考\n\nclass CustomStack:\n\ndef __init__(self, size: int):\n    self.st = []\n    self.cnt = 0\n    self.size = size\n\ndef push(self, x: int) -> None:\n    if self.cnt < self.size:\n        self.st.append(x)\n        self.cnt += 1\n\n\ndef pop(self) -> int:\n    if self.cnt == 0: return -1\n    self.cnt -= 1\n    return self.st.pop()\n\n\ndef increment(self, k: int, val: int) -> None:\n    for i in range(0, min(self.cnt, k)):\n        self.st[i] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994369559","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        curs = ''\n        curn = 0\n        for i in s:\n            if i=='[':\n                stack.append((curs,curn))\n                curs = ''\n                curn = 0                \n            elif i.isdigit():\n                curn = curn*10+int(i)\n            elif i == ']':\n                cs,cn = stack.pop()\n                curs = cs+cn*curs\n            else:\n                curs += i\n        return curs\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995541459","body":"```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n        \n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996496296","body":"```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for x in arr:\n            if not stack or stack[-1] <= x:\n                stack.append(x)\n            elif stack[-1] > x:\n                tmp = stack[-1]\n                while stack and stack[-1] > x:\n                    stack.pop()\n                stack.append(tmp)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997161987","body":"```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return head\n        \n        cnt = 1\n        tail = head\n        while tail.next:\n            cnt += 1\n            tail = tail.next\n        \n        # make a circle\n        tail.next = head\n\n        move = cnt - (k % cnt)\n        while move > 0:\n            head = head.next\n            tail = tail.next\n            move -= 1\n        \n        tail.next = None\n        return head\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997337766","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n\n        dummy = ListNode(-1)\n        dummy.next = head.next\n        \n        next_batch = head.next.next\n        head.next.next = head\n        \n        head.next = self.swapPairs(next_batch)\n        \n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997633463","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        slow = head\n        fast = head\n        slow_pre = None\n        while fast and fast.next:\n            fast = fast.next.next\n            slow_pre = slow\n            slow = slow.next\n        if slow_pre:\n            slow_pre.next = None\n        node = TreeNode(slow.val)\n        if fast == slow:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998733905","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # two pointers\n\n        a, b = headA, headB\n\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999316639","body":"```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        return None\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000166820","body":"```\nclass Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        \n        # Two pointers\n        self.prev = self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        \n        # hashmap \n        self.cache = {}   # map key to node\n        \n        # dummy nodes for least used and most used: Left = LRU, right= most recent\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        \n        # nodes should be connected\n        self.left.next, self.right.prev = self.right, self.left\n        \n    # remove node from the list\n    def remove(self, node):\n        prev, next = node.prev, node.next\n        prev.next, next.prev = next, prev\n    \n    # insert node at right\n    def insert(self, node):\n        prev, next = self.right.prev, self.right\n        prev.next = next.prev = node\n        node.next, node.prev = next, prev\n        \n        \n    def get(self, key: int) -> int:\n        if key in self.cache:\n            # update most recent\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return - 1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n        \n        # check if the length exceed the capacity\n        if len(self.cache) > self.cap:\n            # remove from the list and delete the LRU from the hashmap\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000711973","body":"```python\nclass Solution(object):\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        queue = collections.deque([root])\n        depth = 0\n        while queue:\n            size = len(queue)\n            depth +=1\n            for _ in range(size):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return depth\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001000405","body":"```python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p or not q: \n            return p == q\n        if p.val != q.val:\n            return False\n        \n        outside = self.isSameTree(p.left, q.left)\n        inside = self.isSameTree(p.right, q.right)\n        isSame = outside and inside\n        \n        return isSame\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001111432","body":"```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        ans = 0\n        stack = collections.deque()\n        stack.append((root, root.val))\n        while stack:\n            node, val = stack.popleft()\n            if not node.left and not node.right:\n                ans += val\n            if node.left:\n                stack.append((node.left, val * 10 + node.left.val))\n            if node.right:\n                stack.append((node.right, val * 10 + node.right.val))\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"z1ggy-o":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991901442","body":"### 思路\r\n\r\n从末位相加即可。\r\n\r\n---\r\n\r\n实现的很差。放出来当个反例。\r\n\r\n我在实现的时候眼睛紧盯着两个数组进行来进行构建，然后想要把答案存放在已有的两个数组之一。\r\n\r\n但是这样的实现需要许多的边际确认，让代码变得十分复杂。\r\n而且在最后的结果有进位的情况下，还是要对数组进行扩容，然后做 rotation。\r\n得不偿失。\r\n\r\n### 代码\r\n\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K);\r\nprivate:\r\n    vector<int> int_to_arr(int n);\r\n};\r\n\r\nvector<int> Solution::addToArrayForm(vector<int>& A, int K)\r\n{\r\n    int carry;\r\n    int sum;\r\n    int idx_a, idx_b;\r\n    vector<int> a, b;\r\n\r\n    // edge case\r\n    if (K == 0)\r\n        return A;\r\n    \r\n    // 1. convert K to array format.\r\n    vector<int> K_arr = int_to_arr(K);\r\n    \r\n    // K can be greater than A\r\n    if (K_arr.size() > A.size()) {\r\n        a = A;\r\n        b = K_arr;    \r\n    } else {\r\n        a = K_arr;\r\n        b = A;\r\n    }\r\n\r\n    // 2. Add small number to large number from the last digit to the highest digit.\r\n    //    The result can have (A.lenght + 1) digits\r\n    idx_a = a.size() - 1;\r\n    idx_b = b.size() - 1;\r\n    carry = 0;\r\n\r\n    // add all digit \r\n    int len = a.size();\r\n    for (int i = 0; i < len; i++) {\r\n        sum = a[idx_a] + b[idx_b] + carry;\r\n        if (sum <= 9) {\r\n            b[idx_b] = sum;\r\n            carry = 0;\r\n        } else {\r\n            b[idx_b] = sum - 10;\r\n            carry = 1;\r\n        }\r\n        idx_a--;\r\n        idx_b--;\r\n    }\r\n\r\n    if (carry == 0)\r\n        return b;\r\n\r\n    if (idx_a == idx_b) {\r\n        b.insert(b.begin(), carry);\r\n        return b;\r\n    }\r\n\r\n    // add the last carry to b\r\n    while (carry != 0 && idx_b >= 0) {\r\n        sum = b[idx_b] + carry;\r\n        if (sum <= 9) {\r\n            b[idx_b] = sum;\r\n            carry = 0;\r\n        } else {\r\n            b[idx_b] = sum - 10;\r\n            carry = 1;\r\n        }\r\n        idx_b--;\r\n    }\r\n    \r\n    if (carry) {\r\n        b.insert(b.begin(), carry);\r\n    }\r\n    return b;\r\n}\r\n\r\nvector<int> Solution::int_to_arr(int n)\r\n{\r\n    int r;\r\n    vector<int> arr;\r\n\r\n    while (n != 0) {\r\n        r = n % 10;\r\n        n = n / 10;\r\n        arr.push_back(r);\r\n    }\r\n\r\n    reverse(arr.begin(), arr.end());\r\n    return arr;\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为较长数组的长度。\r\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993143487","body":"### 思路\r\n\r\n用 array 实现 stack。没什么特别的。\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        capacity = maxSize;\r\n        top = 0;\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (is_full()) {\r\n            return;\r\n        }\r\n\r\n        arr[top++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (is_empty())\r\n            return -1;\r\n        \r\n        top--;\r\n        return arr[top];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int len = k > top ? top : k;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int capacity;\r\n    int top;\r\n    int *arr;\r\n\r\n    bool is_full() {\r\n        return top == capacity;\r\n    }\r\n\r\n    bool is_empty() {\r\n        return (top - 1) < 0;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 空间：O(M). M is the capacity of the stack\r\n- 时间：O(1) for push, pop. O(k) for increment, k is the number of elements that we need to increase value.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994327015","body":"### 思路\r\n\r\n看到成对的括号本能地就想到了使用 stack。\r\n\r\n假设我们把所有的内容都 push 到 stack 当中，那么不变的永远是：\r\n- 遇到 ’]' 则开始 pop\r\n- pop 到 '[' 为止得到的是重复对象\r\n- stack 中 '[' 的下一个（或几个）值是重复次数\r\n\r\n因为重复次数可能超过 1 位数，需要做特别处理。\r\n\r\n 看到还有像@AlvinZhouOops 同学一样使用 recursive 来解的，很妙。\r\n\r\n### 代码\r\n\r\n```cpp\r\nstring Solution::decodeString(string s)\r\n{\r\n    stack<char> stack;\r\n    char c;\r\n    list<char> decoded;\r\n\r\n    for (int i = 0; i < s.length(); i++) {\r\n        c = s[i];\r\n\r\n        if (c != ']') {\r\n            stack.push(c);\r\n        } else {\r\n            list<char> tmp;\r\n\r\n            while (stack.top() != '[') {\r\n                tmp.push_front(stack.top());\r\n                stack.pop();\r\n            }\r\n            stack.pop();  // drop '['\r\n\r\n            // repeat\r\n              // the number can have more than 1 digit\r\n            int decimal = 1;\r\n            int times = 0;\r\n            while(!stack.empty() && isdigit(stack.top())) {  // must check empty here\r\n                times += (stack.top()-'0') * decimal;\r\n                decimal *= 10;\r\n                stack.pop();\r\n            }\r\n            repeat(stack, tmp, times);  // repeat and push back to stack\r\n        }\r\n    }\r\n\r\n    while (!stack.empty()) {\r\n        decoded.push_front(stack.top());\r\n        stack.pop();\r\n    }\r\n    return to_string(decoded);\r\n}\r\n\r\nvoid Solution::repeat(stack<char>& s, list<char>& l, int times)\r\n{\r\n    int len = l.size();\r\n    \r\n    // repeat\r\n    for (int i = 0; i < times-1; i++) {\r\n        auto ptr = l.begin();\r\n        for (int j = 0; j < len; j++) {\r\n            l.push_back(*ptr);\r\n            ptr++;\r\n        }\r\n    }\r\n    // push back. so they become content again.\r\n    for (auto p = l.begin(); p != l.end(); p++) {\r\n        s.push(*p);\r\n    }\r\n}\r\n\r\nstring Solution::to_string(list<char>& l)\r\n{\r\n    stringstream ss;\r\n    for (auto p = l.begin(); p != l.end(); p++) {\r\n        ss << *p;\r\n    }\r\n    return ss.str();\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为 string 长度。\r\n\r\n- 时间复杂度：$O(n)$， 因为 repeat 和再次 push/pop 会有多余的操作，但还是在常数范围内。\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995504710","body":"### 思路\r\n\r\n经典题目了。大家学数据结构的时候应该老师都有讲过。\r\n\r\n核心就是关注于 container 的功能而非实现。\r\n对于 queue 来说，FIFO 是其功能；而 stack 是 LIFO。\r\n我们只要将 stack 掉一个向，就能实现 FIFO。\r\n\r\n为了降低复杂度，我们可以使用两个 stack。\r\n我将其中一个称为 ”show“，一个称为 ”store“。show 用来为用户提供 FIFO 的机能。store 用来储存。\r\n我们只有当 show 为空的时候才将 store 中的内容转入 show （LIFO -> FIFO)，操作当的近似复杂度就可以为 $O(1)$ 了。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    MyQueue(): size(0){\r\n    }\r\n    \r\n    void push(int x) {\r\n        store.push(x);\r\n        size++;\r\n    }\r\n    \r\n    int pop() {\r\n        int ret;\r\n\r\n        migrate();\r\n        ret = show.top();\r\n        show.pop();\r\n        size --;\r\n\r\n        return ret;\r\n    }\r\n    \r\n    int peek() {\r\n        migrate();\r\n        return show.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return size == 0;\r\n    }\r\nprivate:\r\n    int size;\r\n    stack<int> show, store;\r\n\r\n    void migrate()\r\n    {\r\n        if (!show.empty())\r\n            return;\r\n        \r\n        while (!store.empty()) {\r\n            show.push(store.top());\r\n            store.pop();\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间：amortized O(1) \r\n- 空间：O(N), N is the number of elements in the queue","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996435642","body":"### 思路\r\n\r\nchunk 划分的核心在于，后一个 chunk 中最小的元素要大于等于前一个 chunk 中最大的元素。\r\n这个要求等效于，在遍历 arr 的过程中，每次遇到升序的情况，我们都可以划分一个新的 chunk。\r\n\r\n上面的核心基础思想之下，我们来考虑 arr 的情况，一共有 4 种：\r\n- 一直升序\r\n- 一直降序\r\n- 先降后升\r\n- 先升后降\r\n\r\n核心基础思想下，简单的通过记录一个当前遇到过的最大值即可完成对除了”先升后降“情况的处理。\r\n只记录一个当前最大值无法应对”先升后降“的情况（例，[1,2,3,1,2,3]）因为后面遇到的较小值可能比之前某一个中间 chunk 的最大值还要小。因为我们只记录了最新 chunk 的最大值，就只能将新元素合并至此，但这会使排序失败。\r\n\r\n所以，基于核心基础之上，我们需要记录*每一个 chunk 的最大值*，这样才可以将新的元素进行正确的合并。\r\n继而，问题的最后就转变成了，如何记录每个 chunk 的最大值。这里的选择我觉得是很多的，例如：\r\n- queue：可以方便的把之前错误划分的 chunk 去掉。\r\n- vector (dynamic array）：每个 chunk 的最大值存放在相应的 index\r\n- stack：每个 chunk 的最大值 push 进去即可\r\n\r\n此问题中，使用上面三个 container 的复杂度是相同的，都是从后往前一次确认各个 chunk 的最大值。\r\n因为 stack 的代码最简单，我选择用 stack 来进行实现。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> s;\r\n        int max;\r\n\r\n        s.push(arr[0]);\r\n        for (int i = 1; i < arr.size(); i++) {\r\n            if (arr[i] >= s.top()) {\r\n                s.push(arr[i]);\r\n            } else {\r\n                max = s.top();  // keep the greatest element until now\r\n                s.pop();\r\n\r\n                while (!s.empty() && arr[i] < s.top()) {\r\n                    s.pop();\r\n                }\r\n                s.push(max);\r\n            }\r\n        }\r\n\r\n        return s.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间：O(N). N is the size of the array.\r\n- 空间：O(M). M is # of the chunks","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997140193","body":"### 思路\r\n\r\n问题的核心是确认实际需要移动的量到底是多少。\r\n因为 k 的范围很大，我们可以利用取余的方式获得 list 长度内的实际有效移动量。\r\n\r\n瞟了一眼 91 的题解和官方题解。其中提到的链表连环和快慢指针在本题当中都不是必要的。\r\n算法的复杂度核心还是在遍历过程本身。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode *tail;\r\n        int len;\r\n\r\n        if (!head)  // corner case\r\n            return head;\r\n\r\n        tail = head;\r\n        len = 1;  // there is no dummy head\r\n        while (tail->next) {\r\n            tail = tail->next;\r\n            len++;\r\n        }\r\n\r\n        int distance = k % len;\r\n        if (distance == 0) {\r\n            return head;\r\n        }\r\n\r\n        ListNode *tmp = head;\r\n        // tmp points to the previous node of the new head\r\n        for (int i = 0; i < len - distance - 1; i++) {\r\n            tmp = tmp->next;\r\n        }\r\n        tail->next = head;\r\n        head = tmp->next;\r\n        tmp->next = nullptr;\r\n\r\n        return head;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间：O(N). N is the length of the linked list.\r\n- 空间：O(1). In place, we only move the existed nodes.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997390996","body":"### 思路\r\n\r\n用 iteration 模拟。\r\n\r\n没有使用 dummy head，所以对需要 return 的 head 单独进行了处理，使得代码有些复杂。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode *p, *c, *n;  // c is the first element in a pair, n is hte second\r\n\r\n        if (!head || !head->next) return head;  // corner case\r\n        \r\n        // handle new head first\r\n        c = head;\r\n        head = head->next;\r\n        c->next = head->next;\r\n        head->next = c;\r\n        \r\n        p = head->next;\r\n        c = p->next;  // first pair has been swapped\r\n        while (c) {\r\n            n = c->next;\r\n            if (!n) {  // last pair\r\n                break;\r\n            } else {\r\n                swap_nodes(p, c, n);\r\n                p = c;  // c and n have been swaped, c is the second element in a pair now\r\n                c = c->next;\r\n            }\r\n        }\r\n\r\n        return head;\r\n    }\r\nprivate:\r\n    void swap_nodes(ListNode* p, ListNode *c, ListNode* n)\r\n    {\r\n        p->next = n;\r\n        c->next = n->next;\r\n        n->next = c;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(n)$, 遍历 list。\r\n- 空间复杂度：$O(1)$，inplace 操作，没有多余空间需求。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997642780","body":"### 思路\r\n\r\n题目的核心知识是 binary-search tree 的特性 -- 左小右大。\r\n\r\n加上给定的 list 是一个已经 sorted 后的 list 这一提示，我们可以发现以这个 list 的中间 node 为 root 构造的 tree 正好就是我们想要的答案。当然的，各个 subtree 同样需要生成。因为对所有的 subtree 来说，task 是相同的，自然而然地就会想到使用递归。\r\n\r\n递归函数的构建需要一些巧思，中止条件的确立其实没有那么明确。\r\n这里我参考了题解，将初始 list 的 tail 设为 nullptr，可以避免很多复杂代码。\r\n很值得学习。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n这里还要说一点。看题目的时候一定要把所有内容看完再思考。\r\n比如，初始代码里已经明示，tree 是另外构造的，而不是将原来的 list 重新放置。\r\n我光看了题目描述就开始想，花了许多不需要的时间。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (head == nullptr) return nullptr; // corner case\r\n        return find_mid(head, nullptr);\r\n    }\r\nprivate:\r\n    TreeNode *find_mid(ListNode *head, ListNode *tail)\r\n    {\r\n        ListNode *slow, *fast;\r\n\r\n        if (head == tail) return nullptr;\r\n\r\n        slow = fast = head;\r\n        while (fast != tail && fast->next != tail) {  // must check these two conditions\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n\r\n        TreeNode *root = new TreeNode(slow->val);\r\n        root->left = find_mid(head, slow);\r\n        root->right = find_mid(slow->next, tail);\r\n\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间：O(nlogn). 递归的过程当中，每次进行 2 分，贡献了 logn 的时间。因为每一个层级都需要操作 n 个元素，一共是 nlogn。\r\n- 空间：O(logn) 如上所属，递归深度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998482389","body":"### 思路\r\n\r\n基于找之前出现过的元素的思路，选择了使用 hash 为基础的 set 来帮忙。\r\nset 可以算这类问题的通用解法。但是没有利用到 linked list 本身的特性。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        set<ListNode*> s;\r\n\r\n        if (headA == nullptr || headB == nullptr) return nullptr;\r\n\r\n        while (headA) {\r\n            s.insert(headA);\r\n            headA = headA->next;\r\n        }\r\n\r\n        while (headB) {\r\n            if (s.find(headB) != s.end()) return headB;\r\n            headB = headB->next;\r\n        }\r\n\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间：O(n), n是两个list的长度和\r\n- 空间：O(n), 同上","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999354950","body":"### 思路\r\n\r\n昨天使用了 hash table 来做，今天尝试使用快慢指针。\r\n\r\n画图之后会比较好理解。\r\n在有环的情况下，快指针会在套圈的时候在环内和慢指针碰上。\r\n通过计算，这个相遇点有一个特质，就是 list head 到环开始 node 的距离和相遇点到环开始 node 的距离相同。\r\n所以，我们只要将任何一个 pointer 放到 head 处，然后开始同步前进，两个 pointer 相遇的地方就是环开始的 node。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *s, *f;\r\n\r\n        if (!head || !head->next) return nullptr;\r\n\r\n        s = f = head;\r\n\r\n        while (f && f->next) {\r\n            s = s->next;\r\n            f = f->next->next;\r\n            if (s == f) {  // s and f meet in the cycle\r\n                f = head;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!f || !f->next) return nullptr;  // reach end, no cycle\r\n\r\n        while (s != f) {\r\n            s = s->next;\r\n            f = f->next;\r\n        }\r\n        return s;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间：O(n), n is the length of the list\r\n- 空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000760182","body":"### 思路\r\n\r\n遍历树，BFS 和 DFS 都可以。因为两者都需要把整个棵树遍历完，所以复杂度是相同的。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\n/* BFS */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        \r\n        queue<pair<TreeNode *, int>> q;\r\n        int depth;\r\n        \r\n        q.push({root, 1});\r\n        while (!q.empty()) {\r\n            auto node = q.front().first;\r\n            auto d = q.front().second;\r\n            q.pop();\r\n\r\n            if (node->left)\r\n                q.push({node->left, d+1});\r\n            if (node->right)\r\n                q.push({node->right, d+1});\r\n            depth = d;\r\n        }\r\n\r\n        return depth;\r\n    }\r\n};\r\n\r\n/* DFS */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间：O(n), n is the number of nodes in the tree.\r\n- 空间：DFS - O(n), BFS - O(2^h), h is the height of the tree.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001030648","body":"### 思路\r\n\r\n要求两棵树完全的一致，所以只要简单对每个 node 都进行确认就好了。\r\n因为我们在遍历的过程中指定了遍历顺序，所以结构一并被确认了。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p || !q) // two nullptr, or at least one nullptr\r\n            return !p && !q;\r\n        \r\n        if (p->val == q->val) {\r\n            return isSameTree(p->left, q->left) &&\r\n                   isSameTree(p->right, q->right);\r\n        }\r\n        return false;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间：O(n), the number of nodes\r\n- 空间：O(h), the height of the tree","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orderkk":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991902776","body":"function fn(arr, number) {\n    let a1 = Number(arr.join(''));\n    let result = BigInt(a1) + BigInt(number)\n    return String(result).split('')\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992584465","body":"var shortestToChar = function (s, c) {\n  let length = s.length\n  let arr = new Array(length).fill(length)\n  let array = s.split('');\n\n  for (let i = 0; i < length; i++) {\n    for (let j = i; j < length; j++) {\n      if (array[j] === c) {\n        arr[i] = j - i\n        break\n      }\n    }\n  }\n  for (let i = length - 1; i >= 0; i--) {\n    for (let j = i; j >= 0; j--) {\n      if (array[j] === c && arr[i] > i - j) {\n        arr[i] = i - j\n        break\n      }\n    }\n  }\n  return arr\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994891641","body":"var decodeString = function (s) {\n            let result = '' // 字符串的“搬运工”\n            let strStack = [] // 存 待拼接的str 的栈\n            let numStack = [] // 存倍数的栈\n            let num = 0  // 倍数的“搬运工”\n            for (let i of s) {\n\n                if (!isNaN(i)) {\n                    num = num * 10 + Number(i)\n                } else if (i == '[') {\n                    strStack.push(result)\n                    result = ''\n                    numStack.push(num)\n                    num = 0\n                } else if (i == ']') {\n                    let repeatTimes = numStack.pop(); // 获取拷贝次数\n                    console.log(repeatTimes)\n                    result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n                } else {\n                    result += i;\n                }\n            }\n            return result\n        };","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997893380","body":"const sortedListToBST = (head) => {\n  if (head == null) return null;\n  let slow = head;\n  let fast = head;\n  let preSlow; // 保存slow的前一个节点\n\n  while (fast && fast.next) {\n    preSlow = slow;        // 保存当前slow\n    slow = slow.next;      // slow走一步\n    fast = fast.next.next; // fast走两步\n  }\n  const root = new TreeNode(slow.val);     // 根据slow指向的节点值，构建节点\n\n  if (preSlow != null) {   // 如果preSlow有值，即slow左边有节点，需要构建左子树\n    preSlow.next = null;   // 切断preSlow和中点slow\n    root.left = sortedListToBST(head);     // 递归构建左子树\n  }\n  root.right = sortedListToBST(slow.next); // 递归构建右子树\n  return root;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dudongli":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991903064","body":"思路：,将num和k从个位起逐位相加，最终然后反转res即可。\nfor i in range(len(num)-1,-1, -1):\n            A = num[i] + k % 10\n            k = k // 10\n            if A >= 10:\n                k += 1\n            res.append(A%10)\n        while k >0:\n            res.append(k%10)\n            k = k // 10\n        res.reverse()\n        return(res)\n时间复杂度O（n）","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997218171","body":"解法很直观，一句话说就是形成环，再移动，最后断开\n\n找尾节点，形成环形链表\n尾节点移动 length - k 步，（右移k步 == 左移 length - k 步）\n找到头节点，断开头尾连接\nclass Solution:\ndef rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n               return head\n\n        tail = head\n        length = 1\n        while tail.next:\n            length += 1\n            tail = tail.next\n        tail.next = head\n\n        k = k % length\n        for _ in range(length - k):\n            tail = tail.next\n\n        head = tail.next\n        tail.next = None\n        return head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997402369","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not(head and head.next):\n            return head\n        p = ListNode(-1)\n        cur, head, stack = head, p, []\n        while cur and cur.next:\n            _,_=stack.append(cur), stack.appen(cur.next)\n            cur=cur.next.next\n            p.next=stack.pop()\n            p.next.next = stack.pop()\n            p=p.next.next\n        if cur:\n            p.next=cur\n        else:\n            p.next=None\n        return head.next","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cureforu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991904791","body":"### 思路\n\n模拟竖式计算\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int idx = num.length-1;\n        int carry = 0;\n        while (idx >= 0 || k > 0) {\n            int x = idx >= 0 ? num[idx] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            int sum = x+y+carry;\n            res.add(0, sum%10);\n            carry = sum / 10;\n            idx--;\n            k /= 10;\n        }\n        if (carry == 1) {\n            res.add(0, 1);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992260956","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int slow = 0;\n        int preFast = -1;\n        int[] res = new int[s.length()];\n        for (int fast = 0; fast < s.length(); fast++) {\n            if (s.charAt(fast) != c) {\n                continue;\n            }\n            while (slow <= fast) {\n                if (preFast == -1 || slow-preFast > fast-slow) {\n                    res[slow] = fast - slow;\n                    slow++;\n                }else {\n                    res[slow] = slow - preFast;\n                    slow++;\n                }\n            }\n            preFast = fast;\n        }\n        while (slow < s.length()) {\n            res[slow] = slow-preFast;\n            slow++;\n        }\n        return res;\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993407777","body":"### 思路\n\n辅助栈\n\n### 代码\n\n\n```java\nclass CustomStack {\n    LinkedList<Integer> stack;\n    LinkedList<Integer> helper;\n    int maxSize;\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new LinkedList<>();\n        helper = new LinkedList<>();\n        this.maxSize = maxSize;\n        this.size = 0;\n    }\n    \n    public void push(int x) {\n        if (size < maxSize) {\n            stack.push(x);\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size > 0) {\n            size--;\n            return stack.pop();\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if (k > size) {\n            k = size;\n        }\n        while (!stack.isEmpty()) {\n            helper.push(stack.pop());\n        }\n        while (!helper.isEmpty()) {\n            int temp = helper.pop();\n            if (k-- > 0) {\n                temp += val;\n            }\n            stack.push(temp);\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000614177","body":"### 思路\n\n递归：求二叉树的最大深度，相当于求二叉树根节点的高度。\n\n层序遍历：每遍历一层的同时，将深度+1。\n\n### 代码\n\n\n```java\n//递归\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        return getHeight(root);\n    }\n\n    private int getHeight(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\n    }\n}\n\n//层序遍历\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int depth = 0;\n        while (!queue.isEmpty()) {\n            depth++;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = queue.poll();\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                }\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                }\n            }\n        }\n        return depth;\n    }\n}\n```\n\n**复杂度分析**\n\n递归\n\n- 时间复杂度：O(N)，其中 N 为二叉树的节点数。\n- 空间复杂度：O(H)，其中 H 位二叉树的高度。\n\n层序遍历\n\n- 时间复杂度：O(N)，其中 N 为二叉树的节点数。\n- 空间复杂度：O(N)，其中 N 为二叉树的节点数。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilililisa1998":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991905659","body":"思路：先把数字k转化为数组，然后比较两个数组的长度，用0将较短的数组填充到与长数组等长，然后进行等位相加\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n \r\n        L_k = []\r\n        while (k / 10 != 0):\r\n            L_k.append(k % 10)\r\n            k=int(k / 10)\r\n        num= list(reversed(num))\r\n        ln=len(num)\r\n        lk=len(L_k)\r\n        if lk>ln:\r\n            q=[0]*(lk-ln)\r\n            num.extend(q)\r\n        elif lk==ln:\r\n            num.append(0)\r\n        else:\r\n            q=[0]*(ln-lk)\r\n            L_k.extend(q)\r\n\r\n        for i in range(len(num)-1):\r\n            w=num[i] + L_k[i]\r\n            num[i]=w%10\r\n            num[i+1]=int(w/10)+num[i+1]\r\n        if num[len(num)-1]==0:\r\n            num=num[:-1]\r\n        num = list(reversed(num))\r\n        return num\r\n\r\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992068957","body":"思路：构建关于c的词典，存储c的坐标，然后遍历s，让s中的坐标和c的坐标相减，选择绝对值最小的\r\ndef shortestToChar( s, c):\r\n    \"\"\"\r\n    :type s: str\r\n    :type c: str\r\n    :rtype: List[int]\r\n    \"\"\"\r\n    dc=dict(name=c)\r\n    q=[]\r\n    for i in  range(len(s)): #构建关于c的词典\r\n        if(s[i] == c):\r\n            q.append(i)\r\n            dc['name']=q\r\n    \r\n    b=[]\r\n    for i in range(len(s)):\r\n        a = []\r\n        for j in dc['name']:\r\n            a.append(abs(j-i))\r\n            k=min(a)\r\n        b.append(k)\r\n    return b\r\n\r\n时间复杂度：O（n^3）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993496290","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        self.stack = [0] * maxSize\r\n        self.nums = [0] * maxSize ##num数组记录着inc操作要增加的数\r\n        self.size = maxSize - 1\r\n        self.p = -1\r\n\r\n    def push(self, x):\r\n        if self.p != self.size:\r\n            self.p += 1\r\n            self.stack[self.p] = x\r\n\r\n    def pop(self):\r\n        if self.p == -1:\r\n            return -1\r\n        x, val = self.stack[self.p], self.nums[self.p]\r\n        self.nums[self.p] = 0 \r\n        self.p -= 1\r\n        if self.p != -1:\r\n            self.nums[self.p] += val\r\n        return x + val\r\n\r\n    def increment(self, k, val):\r\n        if self.p >= 0:\r\n            k = min(self.p, k - 1)\r\n            self.nums[k] += val##self.nums[self.p]表示self.p位置以及它前面的位子在经过inc操作后应该加上的数字\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994770850","body":"##思路：把数组为栈，k[encoded_string]为一个可扩张项目，遇到‘]’时找到它负责的项目并扩展\r\ndef decodeString(s):\r\n    \"\"\"\r\n    :type s: str\r\n    :rtype: str\r\n    \"\"\"\r\n    i=0\r\n    while i <len(s):  #与for相比，while可以每回合更新循环范围，避免数组溢出\r\n        if s[i]==']':\r\n            for p in range(i-1,-1,-1):\r\n                if s[p]=='[':\r\n                    q=p-1\r\n                    k=0\r\n                    num=0\r\n                    while s[q].isdigit():  #计算k[encoded_string]中的k，也就是num\r\n                        num = num +int(s[q])*10**k\r\n                        k=k+1\r\n                        q=q-1\r\n                    a=s[p+1:i]*num    ##[encoded_string]*k\r\n                    if i!=len(s)-1:\r\n                        s=s[0:q+1]+a+s[i+1:]\r\n                        i = q+len(a)  #q是a前面一个位置，为了节约遍历时间，i直接从新加入到a的下一个位置开始\r\n                        break\r\n                    else:\r\n                        s = s[0:q+1] + a   ##避免s[i+1]越界\r\n                        break\r\n        i=i+1\r\n    return s\r\n\r\n#时间复杂度O(n^3)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995383226","body":"class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stack=[]\r\n    def push(self, x):\r\n        self.stack.append(x)\r\n    def pop(self):\r\n        a=self.stack[0]\r\n        self.stack=self.stack[1:] ##队头就是stack[0]\r\n        return a\r\n\r\n    def peek(self):\r\n        return self.stack[0]\r\n    def empty(self):\r\n        if len(self.stack)!=0:\r\n            return False\r\n        else:\r\n            return True\r\n时间复杂度O(1)\r\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996570093","body":"def maxChunksToSorted(arr):\r\n    stack = [arr[0]]\r\n    for num in arr[1:]:\r\n\r\n        if num >= stack[-1]:  # 大于栈顶【栈中的最大值】\r\n            stack.append(num)\r\n        else:  # 小于栈顶\r\n            cur_ma = stack.pop()  # 记录下栈顶\r\n            while stack and num < stack[-1]:  # 移除栈中大于当前值num的所有元素\r\n                stack.pop()\r\n            stack.append(cur_ma)  # 栈顶复位\r\n\r\n    return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997131547","body":"#循环链表的截断\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head==None or k==0:\r\n            return head\r\n        p=head\r\n        while head.next!=None:\r\n            head=head.next\r\n        head.next=p #构建循环链表\r\n        i=0\r\n        while i<k:#选择断点\r\n            p=p.next\r\n            q=p.next\r\n            i=i+1\r\n        p.next=None\r\n        return q\r\n时间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997376698","body":"#思路：对前两个数特殊处理，因为要把head当作头节点。往后的每一对数，都把前一个查入到后一个数和后数#下一个数之间\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if head ==None or head.next==None:\r\n            return head\r\n        p=head\r\n        head=head.next\r\n        p.next=head.next\r\n        head.next=p \r\n        while p.next!=None and p.next.next!=None:\r\n            q=p\r\n            w =p.next\r\n            p=p.next.next\r\n            q.next=p \r\n            w.next=p.next\r\n            p.next=w \r\n            p=p.next\r\n        return head\r\n#时间复杂度O（n）\r\n#空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997943339","body":"class Solution(object):\r\n    def __init__(self):\r\n        self.val_list = []\r\n\r\n    def get_tree(self,left,right):\r\n        if(left > right):\r\n            return None\r\n        mid = (left + right+1) //2\r\n        root = TreeNode(self.val_list[mid])\r\n        root.left = self.get_tree(left,mid-1)\r\n        root.right = self.get_tree(mid+1,right)\r\n        return root\r\n\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n\r\n        p = head\r\n        length = 1\r\n        if(p==None):\r\n            return None\r\n        \r\n        val_list = [p.val]\r\n        while(p.next != None):\r\n            p = p.next\r\n            length += 1\r\n            val_list.append(p.val)\r\n        self.val_list = val_list\r\n        root = self.get_tree(0,len(val_list)-1)\r\n        return root","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998791045","body":"class Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        ha=0\r\n        hb=0\r\n        a=ListNode(0)\r\n        b=ListNode(0)\r\n        a.next=headA\r\n        b.next=headB\r\n        headA=a\r\n        headB=b\r\n        p=headA\r\n        while p!=None:\r\n            p=p.next\r\n            ha=ha+1\r\n            \r\n        p=headB\r\n        while p!=None:\r\n            p=p.next\r\n            hb=hb+1\r\n            \r\n        if ha>hb:\r\n            while ha>hb:\r\n                headA=headA.next\r\n                ha=ha-1\r\n            while headA!=None:\r\n                if headA.next==headB.next:\r\n                    return headA.next\r\n                else:\r\n                    headA=headA.next\r\n                    headB=headB.next\r\n            return null\r\n        elif hb>ha:\r\n            while hb>ha:\r\n                headB=headB.next\r\n                hb=hb-1\r\n            while headA!=None:\r\n                if headA.next==headB.next:\r\n                    return headA.next\r\n                else:\r\n                    headA=headA.next\r\n                    headB=headB.next\r\n            return null\r\n        else:\r\n            while headA!=None:\r\n                if headA.next==headB.next:\r\n                    return headA.next\r\n                else:\r\n                    headA=headA.next\r\n                    headB=headB.next\r\n            return null","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000287464","body":"class DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        # 使用伪头部和伪尾部节点    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        # 如果 key 存在，先通过哈希表定位，再移到头部\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000996807","body":"class Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val!=q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"macvh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991905870","body":"class Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        思路：类似于大数相加，先把数字k转化为数组，\r\n        \"\"\"\r\n        L_k = []\r\n        while (k / 10 != 0):\r\n            L_k.append(k % 10)\r\n            k=int(k / 10)\r\n        num= list(reversed(num))\r\n        ln=len(num)\r\n        lk=len(L_k)\r\n        if lk>ln:\r\n            q=[0]*(lk-ln)\r\n            num.extend(q)\r\n        elif lk==ln:\r\n            num.append(0)\r\n        else:\r\n            q=[0]*(ln-lk)\r\n            L_k.extend(q)\r\n\r\n        for i in range(len(num)-1):\r\n            w=num[i] + L_k[i]\r\n            num[i]=w%10\r\n            num[i+1]=int(w/10)+num[i+1]\r\n        if num[len(num)-1]==0:\r\n            num=num[:-1]\r\n        num = list(reversed(num))\r\n        return num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992461416","body":"思路：构建关于c的词典，存储c的坐标，然后遍历s，让s中的坐标和c的坐标相减，选择绝对值最小的\r\n'''\r\n\r\ndef shortestToChar( s, c):\r\n    \"\"\"\r\n    :type s: str\r\n    :type c: str\r\n    :rtype: List[int]\r\n    \"\"\"\r\n    dc=dict(name=c)\r\n    q=[]\r\n    for i in  range(len(s)): #构建关于c的词典\r\n        if(s[i] == c):\r\n            q.append(i)\r\n            dc['name']=q\r\n\r\n    b=[]\r\n    for i in range(len(s)):\r\n        a = []\r\n        for j in dc['name']:\r\n            a.append(abs(j-i))\r\n            k=min(a)\r\n        b.append(k)\r\n    return b","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993566960","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        self.stack = [0] * maxSize\r\n        self.nums = [0] * maxSize ##num数组记录着inc操作要增加的数\r\n        self.size = maxSize - 1\r\n        self.p = -1\r\n\r\n    def push(self, x):\r\n        if self.p != self.size:\r\n            self.p += 1\r\n            self.stack[self.p] = x\r\n\r\n    def pop(self):\r\n        if self.p == -1:\r\n            return -1\r\n        x, val = self.stack[self.p], self.nums[self.p]\r\n        self.nums[self.p] = 0\r\n        self.p -= 1\r\n        if self.p != -1:\r\n            self.nums[self.p] += val\r\n            # 如果只剩一个元素，直接pop\r\n            # 如果多于一个元素，pop出去的同时，未来第一个元素要继承一下加的val\r\n        return x + val\r\n\r\n    def increment(self, k, val):\r\n        if self.p >= 0:\r\n            k = min(self.p, k - 1)\r\n            self.nums[k] += val##self.nums[self.p]表示self.p位置以及它前面的位子在经过inc操作后应该加上的数字","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994796777","body":"##思路：把数组为栈，k[encoded_string]为一个可扩张项目，遇到‘]’时找到它负责的项目并扩展\r\ndef decodeString(s):\r\n    \"\"\"\r\n    :type s: str\r\n    :rtype: str\r\n    \"\"\"\r\n    i=0\r\n    while i <len(s):  #与for相比，while可以每回合更新循环范围，避免数组溢出\r\n        if s[i]==']':\r\n            for p in range(i-1,-1,-1):\r\n                if s[p]=='[':\r\n                    q=p-1\r\n                    k=0\r\n                    num=0\r\n                    while s[q].isdigit():  #计算k[encoded_string]中的k，也就是num\r\n                        num = num +int(s[q])*10**k\r\n                        k=k+1\r\n                        q=q-1\r\n                    a=s[p+1:i]*num    ##[encoded_string]*k\r\n                    if i!=len(s)-1:\r\n                        s=s[0:q+1]+a+s[i+1:]\r\n                        i = q+len(a)  #q是a前面一个位置，为了节约遍历时间，i直接从新加入到a的下一个位置开始\r\n                        break\r\n                    else:\r\n                        s = s[0:q+1] + a   ##避免s[i+1]越界\r\n                        break\r\n        i=i+1\r\n    return s\r\n\r\n#时间复杂度O(n^3)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996715087","body":"class Solution(object):\r\ndef maxChunksToSorted(self, arr):\r\n\"\"\"\r\n:type arr: List[int]\r\n:rtype: int\r\n\"\"\"\r\nmaximum, res = 0, 1\r\nfor i in range(len(arr)):\r\nmaximum = max(arr[i], maximum)\r\nif i == len(arr) - 1:\r\nbreak\r\nelif min(arr[i+1:]) >= maximum:\r\nres += 1\r\nreturn res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997204889","body":"class Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head==None or k==0:\r\n            return head\r\n        p=head\r\n        while head.next!=None:\r\n            head=head.next\r\n        head.next=p #构建循环链表\r\n        i=0\r\n        while i<k:#选择断点\r\n            p=p.next\r\n            q=p.next\r\n            i=i+1\r\n        p.next=None\r\n        return q\r\n时间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997371153","body":"class Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        p = head\r\n        while(p != None and p.next != None):\r\n            a = p.val\r\n            p.val = p.next.val\r\n            p.next.val = a \r\n            p = p.next.next\r\n        return head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997942458","body":"class Solution(object):\r\n    def __init__(self):\r\n        self.val_list = []\r\n\r\n    def get_tree(self,left,right):\r\n        if(left > right):\r\n            return None\r\n        mid = (left + right+1) //2\r\n        root = TreeNode(self.val_list[mid])\r\n        root.left = self.get_tree(left,mid-1)\r\n        root.right = self.get_tree(mid+1,right)\r\n        return root\r\n\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n\r\n        p = head\r\n        length = 1\r\n        if(p==None):\r\n            return None\r\n        \r\n        val_list = [p.val]\r\n        while(p.next != None):\r\n            p = p.next\r\n            length += 1\r\n            val_list.append(p.val)\r\n        self.val_list = val_list\r\n        root = self.get_tree(0,len(val_list)-1)\r\n        return root","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998791306","body":"class Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        ha=0\r\n        hb=0\r\n        a=ListNode(0)\r\n        b=ListNode(0)\r\n        a.next=headA\r\n        b.next=headB\r\n        headA=a\r\n        headB=b\r\n        p=headA\r\n        while p!=None:\r\n            p=p.next\r\n            ha=ha+1\r\n            \r\n        p=headB\r\n        while p!=None:\r\n            p=p.next\r\n            hb=hb+1\r\n            \r\n        if ha>hb:\r\n            while ha>hb:\r\n                headA=headA.next\r\n                ha=ha-1\r\n            while headA!=None:\r\n                if headA.next==headB.next:\r\n                    return headA.next\r\n                else:\r\n                    headA=headA.next\r\n                    headB=headB.next\r\n            return null\r\n        elif hb>ha:\r\n            while hb>ha:\r\n                headB=headB.next\r\n                hb=hb-1\r\n            while headA!=None:\r\n                if headA.next==headB.next:\r\n                    return headA.next\r\n                else:\r\n                    headA=headA.next\r\n                    headB=headB.next\r\n            return null\r\n        else:\r\n            while headA!=None:\r\n                if headA.next==headB.next:\r\n                    return headA.next\r\n                else:\r\n                    headA=headA.next\r\n                    headB=headB.next\r\n            return null","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000279365","body":"class DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        # 使用伪头部和伪尾部节点    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        # 如果 key 存在，先通过哈希表定位，再移到头部\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000996563","body":"\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        return self.check(p,q)\r\n\r\n    def check(self,p,q):\r\n        if(p==None and q==None):\r\n            return True\r\n        if(p!=None and q!=None):\r\n            if(p.val==q.val):\r\n                return self.check(p.left,q.left) and self.check(p.right,q.right)\r\n            else:\r\n                return False\r\n        else:\r\n            return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"callmeeliza":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991907902","body":"## 思路\n新增temp数组存上次计算的进位1，每次取三个数组的末位数进行相加，取余数存进res数组中，直到三个数组都空的时候，计算结束\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let cur = String(k).split('');\n    let res = [];\n    let temp = []\n    while(num.length > 0 || cur.length > 0 || temp.length > 0) {\n        let a = Number(num.pop() || 0);\n        let b = Number(cur.pop() || 0);\n        let c = Number(temp.pop() || 0);\n        if(a + b + c >= 10) {\n            res.unshift((a+ b + c)%10);\n            temp.push(1);\n        } else {\n            res.unshift(a+b+c)\n        }\n    }\n    return res\n};\n```\n## 复杂度分析\n-时间复杂度：O(n)，其中n为num和k的最大长度\n-空间复杂度：O(n)，其中n为num和k的最大长度或最大长度+1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992262098","body":"## 思路\n将字符串S以字符C为界划分成字符串数组，首尾注意特殊处理，中间的字符串以中点为界分别计算距左右两边的距离\n##代码\n```javascript\nvar shortestToChar = function(s, c) {\n  let arr = s.split(c);\n  let res = [];\n  arr.forEach((str, index) => {\n    for (let i = 0; i < str.length; i++) {\n      switch (true) {\n        case index === arr.length - 1:\n        case index !== 0 && i < Math.ceil(str.length / 2):\n          res.push(i + 1);\n          break;\n        case index === 0:\n        case i >= Math.ceil(str.length / 2):\n          res.push(str.length - i);\n          break;\n      }\n    }\n    if (index < arr.length - 1) res.push(0);\n  });\n  return res;\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993324968","body":"## 思路\n没什么复杂思路，主要靠js的数组的push和pop\n## 代码\n```javascript\nvar CustomStack = function(maxSize) {\n    size = maxSize;\n    arr = [];\n};\n\nCustomStack.prototype.push = function(x) {\n    if(arr.length < size) {\n        arr.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(arr.length === 0) {\n        return -1;\n    } else {\n        return arr.pop();\n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<arr.length;i++){\n        arr[i]+=val\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994886262","body":"## 思路\n先用栈定位每个 [ 对应的 ] ，并记录对应数字，然后遍历数组，从中间没有多余括号的一对括号内开始进行替换\n## 代码\n```javascript\nvar decodeString = function(s) {\n    let arr = s.split('');\n    let numArr = []\n    let numObj = {}\n    let bracketObj = {}\n    let left = []\n    let right = []\n    arr.forEach((vv,index)=>{\n        if(/\\d/g.test(vv)) {\n            numArr.push(vv);\n        }\n        if(vv==='['){\n            left.push(index);\n            numObj[index] = numArr.join('');\n            numArr = [];\n            return;\n        }\n        if(vv===']') {\n            bracketObj[left.pop()] = index;\n            right.push(index);\n        }\n    })\n    while(arr.indexOf('[') > 0) {\n        for(let key in bracketObj){\n            let before = Number(key);\n            let after = Number(bracketObj[key]);\n            let target = arr.slice(before + 1,after).join('');\n            if(target.indexOf('[') < 0) {\n                let str = ''\n                for(let i = 0; i< Number(numObj[key]);i++) {\n                    str = str + target;\n                }\n                var start = before - numObj[key].length;\n                var end = after;\n                var amount = end - start + 1;\n                var to = [str];\n                for(let i = 0;i<amount-1;i++){\n                    to.push('')\n                }\n                arr.splice(start, amount, ...to);\n                delete bracketObj[key]\n            }\n        }\n        \n    }\n    return arr.join('');\n};\n```\n## 复杂度\n时间复杂度：O(n+m)，m为括号对的数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995388562","body":"## 思路\n利用js中的数组的shift和push\n## 代码\n```javascript\nvar MyQueue = function() {\n    arr = []\n};\n\nMyQueue.prototype.push = function(x) {\n    arr.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    return arr.shift();\n};\n\nMyQueue.prototype.peek = function() {\n    return arr[0];\n};\n\nMyQueue.prototype.empty = function() {\n    return arr.length === 0\n};\n```\n## 复杂度\n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996375695","body":"## 思路\n条件：前面的块的最大值要小于后面的块的最小值 \n先取数组第一个元素为第一个块，与后面的大块比较，满足条件则抛出，不满足则将第二个元素塞进第一个块，继续比较，直到数组所有的元素都被抛出，循环结束\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let n = 0;\n    while(arr.length > 0) {\n        let pre = [arr.shift()];\n        while(Math.max(...pre) > Math.min(...arr)){\n            pre.push(arr.shift());\n        }\n        n = n + 1;\n    }\n    return n;\n};\n```\n## 复杂度\n时间复杂度：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997153350","body":"## 思路\n先变成双向循环列表，然后从头指针开始往前找k次，返回当前指针\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n    if(head === null || head.next === null) return head;\n    let tail = head;\n    while(tail.next!==null){\n        tail.next.pre = tail;\n        tail = tail.next;\n    }\n    tail.next = head;\n    head.pre = tail;\n    let p = head;\n    for(let i=0;i<k;i++) {\n        p = p.pre;\n    }\n    p.pre.next = null;\n    return p;\n};\n```\n## 复杂度\n时间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997331182","body":"## 思路\n找规律，abcd交换，a的next应该指向b.next.next也就是d，根据这个规律遍历整个链表\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    let p = head;\n    while(p&&p.next) {\n        if(p === head) {\n            head = p.next;\n        }\n        let q = p.next.next;\n        p.next.next = p;\n        if(q&&q.next) {\n            p.next = q.next;\n        } else {\n            p.next = q;\n        }\n        p = q;\n    }\n    return head;\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997947689","body":"## 思路\n找中位数，拉出来当根结点，然后左右分支继续找中位数，依次递归直到每个元素都变成了结点\n## 代码\n```javascript\nfunction getMid(start,end) {\n    let fast = start;\n    let slow = start;\n    while(fast !== end && fast.next !== end) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow;\n}\nfunction buildTree(start,end){\n    if(start === end) return null;\n    let mid = getMid(start, end);\n    let root = new TreeNode(mid.val);\n    root.left = buildTree(start,mid);\n    root.right = buildTree(mid.next, end);\n    return root;\n}\nvar sortedListToBST = function(head) {\n    if(!head) return null;\n    return buildTree(head,null);\n};\n```\n## 复杂度\n时间复杂度：O(nlogn) \n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998537969","body":"## 思路\n遍历lista，把节点都push到数组里存起来，然后遍历listb，判断数组里是否存在相同节点，有的话就说明这个就是重合的起始点\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let p = headA;\n    let arr = [];\n    while(p) {\n        arr.push(p);\n        p = p.next;\n    }\n    let q = headB;\n    while(q){\n        if(arr.includes(q)) {\n            return q;\n        } else {\n            q = q.next;\n        }\n    }\n    return null;\n};\n```\n## 复杂度\n时间复杂度：O(m+n) \n空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999549572","body":"## 思路\n遍历链表，用数组记录访问过的结点，直到出现重复结点或走到尾结点\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    if(!head || !head.next) return null;\n    let arr = [];\n    while(head) {\n        if(arr.includes(head)) return head;\n        arr.push(head);\n        head = head.next;\n    }\n    return null;\n};\n```\n## 复杂度\n时间复杂度：O(n) \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000362318","body":"## 思路\n主要利用双向列表和哈希表，这题没做出来，用官方题解写了一遍\n## 代码\n```javascript\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n            if (this._isFull()) {\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n```\n## 复杂度\n时间复杂度：O(1)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000844533","body":"## 思路\n利用递归，遍历二叉树，计算出树的深度\n## 代码\n```javascript\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    let left = maxDepth(root.left);\n    let right = maxDepth(root.right);\n    return 1 + Math.max(left,right)\n};\n```\n## 复杂度\n时间复杂度：O(n)    \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000966831","body":"## 思路\n利用递归\n## 代码\n```javascript\nvar isSameTree = function(p, q) {\n    if(!p&&!q) return true;\n    if(!p || !q) return false;\n    if(p.val !== q.val) return false;\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n};\n```\n## 复杂度\n时间复杂度：O(n)   \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001074876","body":"## 思路\n利用递归，传下去的数字每次乘10\n## 代码\n```javascript\n var countTree = function(p, num) {\n        if(!p) return 0;\n        if(!p.left&&!p.right) {\n             return num*10 + p.val;\n        }\n        return countTree(p.left,num*10 + p.val) + countTree(p.right,num*10 + p.val) \n    };\nvar sumNumbers = function(root) {\n    return countTree(root,0)\n};\n```\n## 复杂度\n时间复杂度：O(n)    \n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiquiero":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991910240","body":"### 思路\n把数组A从后开始循环，整数K也从个位数开始，把两个相加，\n如果大于10有进位，把进位存carry变量，结果res存数组。\n每次循环把carry一起相加，最后反转res数组。\n\n### 代码\n\n```js\nvar addToArray = function(A, K) {\n    const res = [];\n    let i = A.length - 1, carry = 0;\n    while (i >=0 || K != 0) {\n        const x = i >= 0 ? num[i] : 0;\n        const y = K != 0 ? K % 10 : 0;\n        const sum = x + y + carry;\n\n        res.push(sum % 10);\n        carry = Math.floor(sum / 10);\n        i--;\n        K = Math.floor(K / 10);\n    }\n    if (carry) res.push(carry);\n    return res.reverse();\n}\n```\n\n** 复杂度分析 **\n- 时间复杂度O（n）\n- 空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992580358","body":"***思路\r\n设置左右两个变量，表示从两边开始最近一个和目标字符的距离，然后取他们的最小值存在res中。\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let res = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    // left为i元素距离左边最近的一个C的距离；right为i元素距离右边最近的一个C的距离\r\n    let left = 0, right = 0;\r\n\r\n    while(left >= 0 && right < s.length ) {\r\n      if (s[i - left] === c || s[i + right] === c) {\r\n        res[i] = Math.min(left, right);\r\n        break;\r\n      }\r\n      left++;\r\n      right++;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993315555","body":"*** 思路\n利用JS的数组来实现push和pop，最后一个根据规则相加val。\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.list = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.list.length < this.maxSize) this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  return this.list.length ? this.list.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  let length = Math.min(k, this.list.length);\n  for (let i = 0; i < length; i++) {\n    this.list[i] += val;\n  }\n};\n```\n时间复杂度：push、pop：O(1)， increment：O(k)\n空间复杂度：O(maxSize)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995530989","body":"*** 思路\n利用JS的数组\n\n```js\nvar MyQueue = function() {\n  this.pushStack = [];\n  this.popStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n  this.pushStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n  if (!this.popStack.length) {\n    while (this.pushStack.length) {\n      this.popStack.push(this.pushStack.pop());\n    }\n  }\n  return this.popStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n  if (!this.popStack.length) {\n    while (this.pushStack.length) {\n      this.popStack.push(this.pushStack.pop());\n    }\n  }\n  return this.popStack[this.popStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n  return !this.pushStack.length && !this.popStack.length;\n};\n```\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998531115","body":"```js\nvar getIntersectionNode = function(headA, headB) {\n    if (headA === null || headB === null) return null;\n    let pA = headA, pB = headB;\n    while (pA !== pB) {\n        pA = pA === null ? headB : pA.next; //链表A循环结束就循环链表B\t\n        pB = pB === null ? headA : pB.next; //链表A循环结束就循环链表B\t\n    }\n    return pA; //当pA == pB时就是交点\n};\n```\n\n时间复杂度O(m+n)，m、n分别是两个链表的长度。空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999461550","body":"```js\nvar detectCycle = function(head) {\n    const visited = new Set();\n    while (head !== null) {//终止条件，如果没有环 跳出循环\n        if (visited.has(head)) {//如果存在重复的节点，这个节点就是入环节点\n            return head;\n        }\n        visited.add(head);//将节点加入set中\n        head = head.next;\n    }\n    return null;\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000749014","body":"```js\nvar maxDepth = function(root) {\n  if(!root) return 0;\n  const left = maxDepth(root.left);\n  const right = maxDepth(root.right);\n  return Math.max(left, right) + 1;\n};\n```\n复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lifuquan1208":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991910622","body":"思路：首先循环数组的，取得数组的末位进行相加之后的取余，放进结果数组，然后对相加后的结果除10去掉末位，循环结束后需要把相加的最后结果放进结果的集合中。\n代码：\n  class Solution {\n\n​    public List<Integer> addToArrayForm(int[] num, int k) {\n\n​         List<Integer> result = new ArrayList<Integer>();\n\n​        int len=num.length-1;\n\n​        for (int i=len; i>=0;i--){\n\n​            int temp=num[i]+k;\n\n​            result.add(temp%10);\n\n​             k=temp/10;\n\n​        }\n\n​        while(k!=0){\n\n​            result.add(k%10);\n\n​            k=k/10;\n\n​        }\n\n​        Collections.reverse(result);\n\n​        return result;\n\n​    }\n\n时间复杂度：0（n)\n空间复杂度：0（n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992414881","body":"### 思路：\n首先循环数组获取所有字符C出现的位置放在集合中，然后定义两个变量变量一个为一个的前一次出现的字符C的集合下标，然后根据前后与数组下标的绝对值比较，得出数值放到结果集中。\n\n### 代码：\n``` java \n public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        int j=0;\n        int k=0;\n        int result=0;\n        ArrayList<Integer> cValue = new ArrayList<Integer>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i)==c){\n                cValue.add(i);\n            }\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if(Math.abs(cValue.get(j) -i)<=Math.abs(cValue.get(k) -i)){\n                result=Math.abs(cValue.get(j) -i);\n            }else{\n                result=Math.abs(cValue.get(k) -i);\n            }\n            answer[i]= result;\n            if(result == 0&& cValue.size()>1 && j+1<=cValue.size()-1){\n                k=j;\n                j=j+1;\n            }\n        }\n        return  answer;\n}\n```\n**复杂度分析**\n- 时间复杂度：o(n²）\n- 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993502393","body":"### 思路；直接双栈了\n### 代码：\n``` java \n Stack<Integer> stack;\n    Stack<Integer> stack2=new Stack<Integer>();\n    int s;\n    public CustomStack(int maxSize) {\n        stack=new Stack<Integer>();\n        s=maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size()<s){\n            stack.push(x);\n        }\n    }\n\n    public int pop() {\n        if(stack.isEmpty()){\n            return -1;\n        }\n        return stack.pop();\n    }\n\n    public void increment(int k, int val) {\n        int count=0;\n        if(k>stack.size()){\n            while(stack.size()>0){\n                int z=stack.pop();\n                stack2.push(z);\n            }\n\n            while(stack2.size()>0){\n                int z=stack2.pop();\n                count++;\n                if(count <= k ){\n                    stack.push(z+val);\n                }else{\n                    stack.push(z);\n                }\n            }\n\n\n        }else{\n            while(stack.size()>0){\n                int z=stack.pop();\n                stack2.push(z+val);\n            }\n\n            while(stack2.size()>0){\n                int z=stack2.pop();\n                stack.push(z);\n            }\n        }\n    }\n```\n**复杂度分析**\n- 时间复杂度：\n-空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994815287","body":"###  思路：\n看了题解之后明白了双栈，自己没写出来\n### 代码：\n```  java \nclass Solution {\n    public String decodeString(String s) {\n         Stack<String> str = new Stack<>();\n        Stack<Integer> num = new Stack<>();\n        StringBuilder result = new StringBuilder();\n        int number=0;\n        for(int i=0;i<s.length();i++){\n         if(s.charAt(i)>= '0' && s.charAt(i) <= '9'){\n             number= number * 10+Integer.parseInt(String.valueOf(s.charAt(i)));\n         }else if(s.charAt(i)=='['){\n           num.push(number);\n           str.push(result.toString());\n           number=0;\n           result=new StringBuilder();\n         }else if(s.charAt(i)==']'){\n             int index = num.pop();\n             StringBuilder temp = new StringBuilder();\n             for (int j = 0; j < index; j++) {\n                 temp.append(result);\n             }\n            result = new StringBuilder(str.pop() + temp);\n         }else {\n             result.append(s.charAt(i));\n         }\n      }\n      return  result.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O（n）\n- 空间复杂度：O（n） ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995836821","body":"### 思路：\r\n双栈，在相应的操作后，把数据进行复制\r\n### 代码:\r\n``` java\r\nStack<Integer> stack;\r\n      Stack<Integer> stack1;\r\n    public void MyQueue() {\r\n     stack=new Stack<Integer>();\r\n     stack1=new Stack<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n       stack.push(x);\r\n       stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n       int result=stack.get(0);\r\n       stack=new Stack<Integer>();\r\n       for (int i=1;i<stack1.size();i++){\r\n           stack.push(stack1.get(i));\r\n       }\r\n       stack1=stack;\r\n      return  result;\r\n    }\r\n\r\n    public int peek() {\r\n        int result=stack1.get(0);\r\n        stack.push(result);\r\n        return  stack.pop();\r\n    }\r\n\r\n    public boolean empty() {\r\n      if(stack.isEmpty()){\r\n          return  true;\r\n      }\r\n      return  false;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n    }\r\n```\r\n**复杂度分析**\r\n-时间复杂度：均摊是O(1)\r\n-空间复杂度:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996753143","body":"###  思路:\r\n想了很久没有思路，群里大神说的滑动窗口之后明白了，困难的还是有难度啊\r\n###  代码：\r\n```  java\r\npublic int maxChunksToSorted(int[] arr) {\r\n            int[] sortedArray = arr.clone();\r\n            Arrays.sort(sortedArray);\r\n            long arrSum = 0;\r\n            long sortedSum = 0;\r\n            int chunkCount = 0;\r\n            for (int i = 0; i < arr.length; i++) {\r\n                arrSum += arr[i];\r\n                sortedSum += sortedArray[i];\r\n                if(arrSum == sortedSum) chunkCount++;\r\n            }\r\n            return chunkCount;\r\n    }\r\n```\r\n**复杂度分析**\r\n-时间复杂度：O（N)\r\n-空间复杂度：O（N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997211656","body":"### 思路；新的开始啊。感觉还是不太了解链表的结构问题看了题解emo \n\n### 代码：\n``` java\n public ListNode rotateRight(ListNode head, int k) {\n\tif (head == null || head.next == null || k == 0) return head;\n    \n    int count = 1; // 用来统计链表总结点数\n    ListNode tmp = head;\n    while (tmp.next != null) {\n        count++;\n        tmp = tmp.next;\n    }\n    k %= count;\n    // 当k为0时，不需要旋转，\n    if (k == 0) return head;\n    \n    // 不满足上述条件，必将进行旋转，所以先将首尾相连\n    tmp.next = head;\n    // 现在只需要找到倒数第k+1个节点\n    for (int i = 0; i < count - k; i++) {\n        tmp = tmp.next;\n    }\n    ListNode newHead = tmp.next;\n    tmp.next = null;\n    return newHead; \n    }\n```\n**复杂度分析**\n-时间复杂度： O（n)\n-空间复杂度： O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997342024","body":"### 思路:\n两两转换，这样一个两两转换可以是全部的转换。链表的解决方法感觉就是能定义更多的变量，先定义头=0然后1，2为要转换的，3是指向的下一个，这样的话1先指向3，然后2指向1，0指向2，然后1作为0，3作为一个1 循环\n### 代码：\n``` java\n public ListNode swapPairs(ListNode head) {\n      if(head==null||head.next==null){\n          return  head;\n      }\n        ListNode preNode = new ListNode(-1, head);\n        ListNode res=head.next;\n        preNode.next = head;\n        ListNode firstNode = head;\n        ListNode secondNode=head;\n        ListNode nextNode=head;\n        while(firstNode!=null&&firstNode.next!=null){\n             secondNode=firstNode.next;\n             nextNode=secondNode.next;\n             firstNode.next=nextNode;\n             preNode.next=secondNode;\n             secondNode.next=firstNode;\n\n             preNode=firstNode;\n             firstNode=nextNode;\n        }\n        return res;\n    }\n```\n**复杂度分析**\n-时间复杂度：遍历了整个链表O（n)\n-空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997926512","body":"### 思路：\n转换成数组有了索引就方便定位中间点，然后开始递归\n### 代码：\n``` java \n    public TreeNode sortedListToBST(ListNode head) {\n        List<ListNode> integers = new ArrayList<>();\n        if(head == null){\n            return null;\n        }\n        while (head != null) {\n            integers.add(head);\n            head = head.next;\n        }\n        return  dfs(integers);\n    }\n    public TreeNode dfs(List<ListNode> list) {\n        if(list.isEmpty()) return null;\n        if(list.size() == 1) return new TreeNode(list.get(0).val);\n        int mid=list.size()/2;\n        TreeNode rootNode = new TreeNode(list.get(mid).val);\n        rootNode.left=dfs(list.subList(0,mid));\n        rootNode.right=dfs(list.subList(mid+1,list.size()));\n      return  rootNode;\n    }\n```\n**复杂度分析**\n-时间复杂度：O（n)\n-空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998728868","body":"### 思路:\n转换成数组，然后遍历链表B，当遇到数组中包含着的节点时即为相交节点。 第二种方法想了好久还是做不出来，emo\n### 代码：\n``` java\n List<ListNode> aNode = new ArrayList<>();\n        if(headA==null||headB==null){\n            return null;\n        }\n        while (headA != null) {\n            aNode.add(headA);\n            headA = headA.next;\n        }\n        while (headB != null) {\n           if(aNode.contains(headB)){\n               return headB;\n           }\n           headB=headB.next;\n        }\n      return null;\n```\n**复杂度分析**\n-时间复杂度：O（M+N）\n-空间复杂度:   O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999566191","body":"### 思路：\n哈希法，存进去 遍历比对节点 和昨天的题一毛一样\n### 代码：\n``` java\n public ListNode detectCycle(ListNode head) {\n               HashSet<ListNode> list = new HashSet<>();\n        ListNode a=head;\n        while(a!=null){\n           if(list.contains(a)){\n               return  a;\n           }\n           list.add(a);\n           a=a.next;\n        }\n       return  null;\n    }\n```\n**复杂度分析**\n-时间复杂度：O（N)\n-空间复杂度：O（N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000300244","body":"### 思路：\n数据结构的题总是不明白题的意思，搞不清楚可用的条件之类的代码还是比较好理解的，还是题量太少了\n### 代码：\n``` java\nclass DLinkedNode {\n    int key, value;\n    DLinkedNode prev, next;\n    public DLinkedNode() {}\n    public DLinkedNode(int _key, int _value) {\n        key = _key;\n        value = _value;\n    }\n}\nclass LRUCache {\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int cap;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n    public   LRUCache(int capacity) {\n       size=0;\n       cap=capacity;\n       head=new DLinkedNode();\n       tail=new DLinkedNode();\n       head.next=tail;\n       tail.prev=head;\n    }\n\n    public int get(int key) {\n        DLinkedNode dLinkedNode = cache.get(key);\n        if(dLinkedNode==null){\n            return -1;\n        }\n        moveToHead(dLinkedNode);\n        return  dLinkedNode.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode dLinkedNode = cache.get(key);\n        if(dLinkedNode==null){\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if(size>cap){\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        }else {\n            dLinkedNode.value=value;\n            moveToHead(dLinkedNode);\n        }\n\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private void moveToHead(DLinkedNode dLinkedNode) {\n        removeNode(dLinkedNode);\n        addToHead(dLinkedNode);\n    }\n    private void addToHead(DLinkedNode dLinkedNode) {\n        dLinkedNode.prev = head;\n        dLinkedNode.next = head.next;\n        head.next.prev = dLinkedNode;\n        head.next = dLinkedNode;\n       }\n    private void removeNode(DLinkedNode dLinkedNode) {\n        dLinkedNode.prev.next = dLinkedNode.next;\n        dLinkedNode.next.prev = dLinkedNode.prev;\n    }\n}\n```\n**复杂度分析**\n-时间复杂度：O（1）\n-空间复杂度:  O（N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000842977","body":"###  思路：\n递归每一层的节点进行比较\n### 代码：\n``` java \n    public int maxDepth(TreeNode root) {\n         if(root==null){\n            return 0;\n        }\n       int lefNum=1;\n        int rightNum=1;\n        if(root.right==null&&root.left==null){\n            return 1;\n        }\n        if(root.left!=null){\n            lefNum=lefNum+maxDepth(root.left);\n        }else{\n            lefNum=0;\n        }\n        if(root.right!=null) {\n            rightNum = rightNum + maxDepth(root.right);\n        }else {\n            rightNum=0;\n        }\n        int result = Math.max(lefNum, rightNum);\n        return  result;\n    }\n```\n**复杂度分析**\n-时间复杂度：O（n)\n-空间复杂度：O（logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000976084","body":"### 思路：\n树的问题还是递归，一层层的。 比较每一个节点，感觉还是要想好节点是否为空的判断就好了\n### 代码：\n``` java\n public boolean isSameTree(TreeNode p, TreeNode q) {\n          if (q==null&&p==null){\n            return  true;\n            }else if(q==null||p==null){\n            return  false;\n        }\n             if(p.val==q.val) {\n                 boolean sameTree1 = isSameTree(p.left, q.left);\n                 boolean sameTree = isSameTree(p.right, q.right);\n                 return  sameTree&&sameTree1?true:false;\n             }\n             return  false;\n    }\n```\n**复杂度分析**\n-时间复杂度：O(N)\n-空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991911734","body":"## 思路\n\n模拟真正的加法计算过程\n\n从后往前依次逐位相加，如果 >=10 则进位\n\n\n\n## 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = len - 1;i >= 0;i--){\n            int a = num[i] + k % 10;\n            k /= 10;\n            // 如果和 > 10，需要进位\n            if (a >= 10 ){\n                k++;\n            }\n            result.add(a % 10);\n        }\n\n        // 上面循环做完，只求了结果后len位的值，由于可能进位，所以k可能还有很多位\n        for (; k > 0; k /= 10) {\n            result.add(k % 10);\n        }\n\n        Collections.reverse(result);\n        return result;\n\n    }\n```\n\n\n## 复杂度分析\n\n- 时间复杂度：O(N)，遍历数组的时间\n- 空间复杂度：O(N)，存储 result 的空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992232798","body":"## 思路\n\n中心扩展法\n\n左右双指针往两边走\n\n\n\n## 代码\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        return solution1(s,c);\n    }\n\n    /**\n     *  中心扩展法\n     *  左右双指针往两边走\n     *\n     *  时间复杂度：O(N^2)，N 为 S 的长度，两层循环。\n     *  空间复杂度：O(N)\n     *\n     * @param s\n     * @param c\n     * @return\n     */\n    private int[] solution1(String s, char c) {\n        char [] arr = s.toCharArray();\n        int[] distance = new int[s.length()];\n\n        for (int i = 0; i < s.length(); i++){\n            if (arr[i] == c){\n                continue;\n            }\n\n            int left = i;\n            int right = i;\n            // 这边是或的关系，只要有一头没到顶，就继续走\n            // 在循环内部用 if 来控制指针的加减\n            while (left>=0 || right < s.length()){\n                if(arr[left] == c){\n                    distance[i] = i - left;\n                    // 找到后，别忘了立马跳出循环\n                    break;\n                }\n\n                if(arr[right] == c){\n                    distance[i] = right - i;\n                    break;\n                }\n\n                if (left>0){\n                    left--;\n                }\n\n                if (right<s.length()-1){\n                    right++;\n                }\n            }\n        }\n\n        return distance;\n    }\n```\n\n\n## 复杂度分析\n\n- 时间复杂度：O(N^2)，N 为 S 的长度，两层循环。\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998638358","body":"## 思路\n\n哈希表法\n\n这个题目本质上是要找相同的元素，自然而然的可以想到用哈希表\n\n\n\n## 代码\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        return hashSetSolution(headA,headB);\n    }\n\n    /**\n     *  这个题目本质上是要找相同的元素，自然而然的可以想到用哈希表\n     *\n     *  时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。\n     *  空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。\n     *\n     * @param headA\n     * @param headB\n     * @return\n     */\n    private ListNode hashSetSolution(ListNode headA, ListNode headB){\n        // 题目要求的是 Node 的地址相同，而不是 val 相同，\n        // 所以 Set 里存的应该是 ListNode\n        Set<ListNode> hashSet = new HashSet<>();\n        ListNode tmp = headA;\n        while (tmp != null){\n            hashSet.add(tmp);\n            tmp = tmp.next;\n        }\n        tmp = headB;\n        while (tmp != null){\n            if (hashSet.contains(tmp)){\n                return tmp;\n            }\n            tmp = tmp.next;\n        }\n        return null;\n    }\n```\n\n\n## 复杂度分析\n\n- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。\n- 空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seventeencui":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991915088","body":"### 思路\r\n先反转，然后模拟加法运算。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        reverse(num.begin(), num.end());\r\n\r\n        for (auto& x: num) {\r\n            k += x;\r\n            x = k % 10;\r\n            k /= 10;\r\n        }\r\n        while (k) num.push_back(k % 10), k /= 10;\r\n\r\n        reverse(num.begin(), num.end());\r\n        return num;\r\n    }\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992590965","body":"### 思路\r\n两次遍历\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> res(n, INT_MAX);\r\n        for(int i = 0, j = -1; i < n; i ++) {\r\n            if(s[i] == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = i - j;\r\n            }\r\n        }\r\n        for(int i = n - 1, j = -1; i >= 0; i --) {\r\n            if(s[i] == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = min(res[i], j - i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993683715","body":"### 思路\r\n使用数组去模拟栈\r\n### 代码\r\n```\r\n\r\nclass CustomStack {\r\nprivate:\r\n    int maxSize;\r\n    vector<int> s;\r\npublic:\r\n    CustomStack(int maxSize) : maxSize(maxSize) {\r\n        s.reserve(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (s.size() < maxSize)\r\n        {\r\n            s.push_back(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (!s.empty())\r\n        {\r\n            int res = s.back();\r\n            s.pop_back();\r\n            return res;\r\n        }\r\n        else\r\n        {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = min(k, int(s.size()))-1; i >= 0 ; --i)\r\n        {\r\n            s[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994862757","body":"### 思路\r\n使用栈，利用栈的特性进行模拟。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int num=0;\r\n        string cur;\r\n\r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        for(int i=0;i<s.size();i++){\r\n            if(s[i]=='['){\r\n                nums.push(num);\r\n                strs.push(cur);\r\n                num=0;\r\n                cur=\"\";\r\n            }\r\n            else if(s[i]==']'){\r\n                int x=nums.top();\r\n                nums.pop();\r\n                string tmp=cur;\r\n                cur=strs.top();\r\n                strs.pop();\r\n                while(x--) cur+=tmp;\r\n            }\r\n            else if(s[i]>='0'&&s[i]<='9'){\r\n                num = num*10 + s[i] - '0';\r\n            }\r\n            else{\r\n                cur+=s[i];\r\n            }\r\n        }\r\n        return cur;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995939189","body":"### 思路\r\n借助栈的特性去做。一开始没思路或者考虑不全的话可以模拟一下。\r\n### 代码\r\n```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> s1, s2;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(s2.empty()){\r\n            while(!s1.empty()){\r\n                s2.push(s1.top());\r\n                s1.pop();\r\n            }\r\n\r\n        }\r\n        int t=s2.top();\r\n        s2.pop();\r\n        return t;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(s2.empty()){\r\n            while(!s1.empty()){\r\n                s2.push(s1.top());\r\n                s1.pop();\r\n            }\r\n        }\r\n        return s2.top();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if(s1.empty()&&s2.empty())\r\n            return true;\r\n        else    \r\n            return false;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996379356","body":"### 思路\r\n哈希表 + 贪心\r\n代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& a) {\r\n        auto b = a;\r\n        sort(b.begin(), b.end());\r\n        unordered_map<int, int> cnt;\r\n        int res = 0;\r\n        for (int i = 0, s = 0; i < a.size(); i ++ ) {\r\n            if (cnt[a[i]] == 1) s -- ;\r\n            else if (cnt[a[i]] == 0) s ++ ;\r\n            cnt[a[i]] -- ;\r\n            if (cnt[b[i]] == -1) s -- ;\r\n            else if (cnt[b[i]] == 0) s ++ ;\r\n            cnt[b[i]] ++ ;\r\n            if (!s) res ++ ;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度 O(nlgn)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997208703","body":"### 思路\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL) return head;\r\n        auto dummy = new ListNode;\r\n        dummy->next = head;\r\n        int n=0;\r\n        auto p = dummy;\r\n        while(p->next){\r\n            n++;\r\n            p=p->next;\r\n        } \r\n        k%=n;\r\n        auto tail = p;\r\n        tail->next=dummy->next;\r\n        auto q=dummy;\r\n        int count = n-k;\r\n        while(count){\r\n            q=q->next;\r\n            count--;\r\n        }\r\n        tail->next=dummy->next;\r\n        dummy->next = q->next;\r\n        q->next=NULL;\r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(N)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997356497","body":"### 思路\r\n因为头节点在交换的过程中可能会更换，所以需要设立一个头节点。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode *dummy = new ListNode(-1);\r\n        dummy->next = head;\r\n        for(ListNode *p=dummy; p->next&&p->next->next; ){\r\n            ListNode *a=p->next, *b=p->next->next;\r\n            p->next=b;\r\n            a->next=b->next;\r\n            b->next=a;\r\n            p=a;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997931852","body":"```\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (!head) return NULL;\r\n        int n = 0;\r\n        for (auto p = head; p; p = p->next) n ++ ;\r\n        if (n == 1) return new TreeNode(head->val);\r\n        auto cur = head;\r\n        for (int i = 0; i < n / 2 - 1; i ++ ) cur = cur->next;\r\n        auto root = new TreeNode(cur->next->val);\r\n        root->right = sortedListToBST(cur->next->next);\r\n        cur->next = NULL;\r\n        root->left = sortedListToBST(head);\r\n        return root;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998886176","body":"### 思路\r\n第一次做没做出来，看到了一种比较巧妙的方法。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        auto p = headA, q = headB;\r\n        while (p != q) {\r\n            p = p ? p->next : headB;\r\n            q = q ? q->next : headA;\r\n        }\r\n        return p;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999681009","body":"### 思路\r\n使用快慢指针\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(head==NULL) return head;\r\n        auto first = head, second = head;\r\n        while(first&&second&&second->next){\r\n            first=first->next;\r\n            second=second->next->next;\r\n            if(first==second){\r\n                first=head;\r\n                while(first&&second){\r\n                    if(first==second)\r\n                        return first;\r\n                    first=first->next;\r\n                    second=second->next;\r\n                }\r\n            }\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000385047","body":"### 思路\r\n非常经典的一道题目，哈希表+双向链表。之前尝试使用过哈希表+双端队列，但是采用双端队列的话时间复杂度会高一些，会有两个点不能通过\r\n### 代码\r\n```\r\nclass LRUCache {\r\npublic:\r\n    struct Node {\r\n        int key, val;\r\n        Node *left, *right;\r\n        Node(int _key, int _val): key(_key), val(_val), left(NULL), right(NULL) {}\r\n    }*L, *R;\r\n    unordered_map<int, Node*> hash;\r\n    int n;\r\n\r\n    void remove(Node* p) {\r\n        p->right->left = p->left;\r\n        p->left->right = p->right;\r\n    }\r\n\r\n    void insert(Node* p) {\r\n        p->right = L->right;\r\n        p->left = L;\r\n        L->right->left = p;\r\n        L->right = p;\r\n    }\r\n\r\n    LRUCache(int capacity) {\r\n        n = capacity;\r\n        L = new Node(-1, -1), R = new Node(-1, -1);\r\n        L->right = R, R->left = L;\r\n    }\r\n\r\n    int get(int key) {\r\n        if (hash.count(key) == 0) return -1;\r\n        auto p = hash[key];\r\n        remove(p);\r\n        insert(p);\r\n        return p->val;\r\n    }\r\n\r\n    void put(int key, int value) {\r\n        if (hash.count(key)) {\r\n            auto p = hash[key];\r\n            p->val = value;\r\n            remove(p);\r\n            insert(p);\r\n        } else {\r\n            if (hash.size() == n) {\r\n                auto p = R->left;\r\n                remove(p);\r\n                hash.erase(p->key);\r\n                delete p;\r\n            }\r\n            auto p = new Node(key, value);\r\n            hash[key] = p;\r\n            insert(p);\r\n        }\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000403851","body":"### 思路\r\n递归实现，相当于用了后序遍历的模板。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(root==NULL) return 0;\r\n        return max(maxDepth(root->left),maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(h) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fornobugworld":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991916230","body":"### 思路\n\n参考了题解中两数相加通用模板\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\n    res = []\n    i, carry = len(A) - 1, 0\n    while i >= 0 or K != 0:\n        x = A[i] if i >= 0 else 0\n        y = K % 10 if K != 0 else 0\n\n        sum = x + y + carry\n        res.append(sum % 10)\n        carry = sum // 10\n\n        i -= 1\n        K //= 10\n    if carry != 0: res.append(carry)\n    return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992583548","body":"### 思路\n\n参考标答，从左向右一次，只记录前一个C和自己的距离，再从右向左一次，两次取最小值\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993659602","body":"### 思路\n\n没做出来，直接看题解了：使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\n\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n\n\n```\n\n**复杂度分析**\n\n-时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\n\n-空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994914241","body":"### 思路\n\n看题解了，构建辅助栈 stack， 遍历字符串 s 中每个字符 c\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\n（此处撰写代码）\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995932876","body":"### 思路\n\n只有出队操作的时候需要第二个栈缓存一下数据\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996819631","body":"### 思路\n\n直接看题解了，排序块（单调栈）\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997219730","body":"### 思路\n\n找移动的规律，先做成环然后断开\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        temp = head\n        tail = head\n        length = 1\n        while temp.next:\n            length +=1\n            temp = temp.next\n        tail = temp\n        tail.next = head\n        abk = length-k%length #头指针要移动的距离=链表长度-位移距离\n        for i in range(abk):\n            tail = tail.next\n            head = head.next\n        tail.next = None\n        return head\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414200","body":"### 思路\r\n\r\n链表的基本指针操作，存断开值，断开掉头，指向断开值，指针顺延\r\n\r\n### 代码\r\n\r\n\r\n```py（此处换成你的语言，比如js，py 等）\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head  or not head.next:\r\n            return head\r\n        cur = head\r\n        pre = ListNode()\r\n        pre.next = cur\r\n        head = head.next\r\n        while cur and cur.next:\r\n            temp = cur.next.next\r\n            cur.next.next = cur\r\n            pre.next = cur.next\r\n            cur.next =temp\r\n            pre = cur\r\n            cur = cur.next\r\n        return head\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998039033","body":"有点难，看题解了\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998891782","body":"class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999675836","body":"class Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000392378","body":"看答案了。。\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000872629","body":"递归写起来跟想的完全不一样。。。\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,maxD,dep):\n            if not root:return dep\n            dep +=1\n            maxD = max(dfs(root.left,maxD,dep),dfs(root.right,maxD,dep))\n            return maxD\n            \n            \n        return dfs(root,0,0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001037326","body":"参考了一下答案，递归的逻辑真的难\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p:\n            if q:\n                return False\n        if not q:\n            if p:return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouxsss":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991917000","body":"### 思路\n数组倒叙和加数 K 的个位数相加，K 减掉个位数模10后进位\n\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n### 代码\n\n```js\nfunction addToArrayForm(A, K) {\n  var ALen = A.length\n  if(!ALen) return []\n  // 进位\n  var add = 0\n  var res = []\n  for(let i = ALen - 1; i >= 0; i--) {\n    var basic = K % 10\n    // K % 10 个位数\n    var sum = A[i] + basic + add\n    if(sum >= 10) {\n      sum = sum - 10\n      add = 1\n    } else {\n        add = 0\n    }\n    res.unshift(sum)\n    K = (K - basic)/10\n  }\n  // 如果还有加项或者没加完的K的剩下位数，则直接连接\n  if(K || add) {\n    res = (K + add).toString().split('').concat(res)\n  }\n  return res\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992529575","body":"### 思路\n对于每一个字母来说可能会有离左边最近的字符和离右边最近的字符。\n正向遍历一遍找出左边最近距离，反向遍历一遍右边最近的字符，对比求出最短距离。\n\n### 复杂度\n时间复杂度 O(n)，n为数组长度\n空间复杂度 O(n)，n为数组长度\n\n### 代码\n```js\n  /**\n   * @param {string} S\n   * @param {character} C\n   * @return {number[]}\n   */\n  function shortestToChar(S, C) {\n    var len = S.length\n    var res = new Array(len)\n    var arr = S.split('')\n    var dis = 10001\n    // 正向遍历\n    for(var i = 0; i < len; i++) {\n      if(S[i] === C) {\n        dis = 0\n      } else {\n        dis ++\n      }\n      res[i] = dis\n    }\n    var dis = 10001\n    // 反向遍历\n    for(var i = len - 1; i >= 0; i--) {\n      if(S[i] === C) {\n        dis = 0\n      } else {\n        dis ++\n      }\n      res[i] = Math.min(res[i], dis)\n    }\n    return res\n  }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993599378","body":"/**\n * 复杂度分析：\n * 时间复杂度：push 和 pop 的时间复杂度为O(1),increment 的时间复杂度为O(n)\n * 空间复杂度：O(1)\n */\n\nfunction CustomStack(maxSize) {\n  this.maxSize = maxSize;\n  this.array = [];\n  return this;\n}\n\nCustomStack.prototype.push = function (item) {\n  if (this.array.length < this.maxSize) {\n    this.array.push(item);\n  } else {\n    console.log('超出');\n  }\n  return this.array;\n};\nCustomStack.prototype.pop = function () {\n  if (this.array.length === 0) return -1;\n  return this.array.pop();\n};\n/**\n * @param k<number> 栈底的 k 个元素\n * @param val<number> 加项\n * @summary 栈底的 k 个元素的值都增加 val\n */\nCustomStack.prototype.increment = function (k, val) {\n  var maxLen = k > this.maxSize ? this.maxSize : k;\n  for (var i = 0; i < maxLen; i++) {\n    this.array[i] += val;\n  }\n  return this.array;\n};\n\nconst stack = new CustomStack(3);\nconsole.log(stack.array);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994895691","body":"### 思路\n利用辅助栈，保存重复次数以及前面遍历生成的结果字符串；\n每遇到左括号时压栈，遇到右括号时出栈, res 为当前字符串，和重复次数计算后，和前面的结果字符串拼接\n\n### 复杂度分析\n时间复杂度：O(n), n为数组长度\n空间复杂度：O(n), n为数组长度\n\n### 代码\n```js\n/**\n * @param {string} S\n * @return {string}\n */ \nvar decodeString = function (S) {\n  var stack = []\n  var k = 0\n  var res = ''\n  for(var i = 0; i < S.length; i++) {\n    var cur = S[i]\n    if(cur === '['){\n      // 把括号之前的结果缓存\n      stack.push([k, res])\n      // 重置当前字符串缓存\n      res = ''\n      k = 0\n    } else if(cur === ']') {\n      var [curr_k, last_res] = stack.pop()\n      res = last_res + new Array(curr_k).fill(res).join('')\n    } else if((/^\\d$/).test(cur)) {\n      k = k * 10 + Number(cur)\n    } else {\n      res += cur\n    }\n  }\n  return res\n}\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997415687","body":"### 思路\n\n递归\n\n- 返回值：交换完后的链表\n- 调用单元：两两交换节点\n- 终止条件：curr.next 为 null,即到尾结点时不需要交换\n\n### 复杂度\n\n时间复杂度 O(n),n 为链表的长度\n空间复杂度 O(1)\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  var next = head.next;\n  head.next = swapPairs(next.next);\n  next.next = head;\n  return next;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998877437","body":"### 思路\n双指针：\n指针 a,b 分别指向 A,B 两个链表;\n指针 a 遍历到尾结点时，继续从头开始遍历链表 B；\n指针 b 遍历到尾结点时，继续从头开始遍历链表 A；\n直到指针 a, b 相遇；\n两个指针走的路程是一样的长度，最终会在某个点相遇。\n\n### 复杂度\n时间复杂度：O(n),n为链表A和B中较长的那个的长度；\n空间复杂度：O(1);\n\n### 代码\n```js\nfunction getIntersectionNode(headA, headB) {\n  var a = headA, b = headB;\n  while(a != b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next\n  }\n  return a\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hoye1113":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991917040","body":"思路：\r\n从k的个位和数组的最后元素入手，k先模10拿到个位，与数组最后一位相加后结果放入res数组，\r\n接着k/=10处理除去个位，继续拿十位数，与数组倒数第二个元素相加，如果有进位则返到k值\r\nk还小于0不需要进位且A数组没有值的情况，则环循环结束。\r\n\r\n代码：js语言\r\n\r\nvar addToArrayForm = function(A, K) {\r\n  let i = A.length - 1\r\n  let res = []\r\n  while (i >= 0 || K){\r\n    K += (A[i] || 0)\r\n    res.push( K % 10 )\r\n    K = K / 10 | 0\r\n    i--\r\n    }\r\n    return res.reverse()\r\n};\r\n\r\n\r\n复杂度分析：\r\n时间复杂度O（n）\r\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992606180","body":"语言：js\r\n\r\n思路1:找到C在S中的所有索引，通过对比S[i]在CArray中最小的偏移量得到结果更新res[i]。\r\n\r\n```js\r\nvar shortestToChar = function (S, C) {\r\n    const res = Array(S.length)\r\n    const indexArr = []\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < S.length; i++) {\r\n        res[i] = indexArr.reduce((tmp, item) => {\r\n            return Math.min(tmp, Math.abs(i - item))\r\n        }, 10000)\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n复杂度分析:  (n为S的legth，m为C在S中的数量)\r\n\r\n时间复杂度：O(nm)O(nm)    空间复杂度：O(nm)O(nm)\r\n\r\n\r\n\r\n思路2:中心扩展法，定义一个diff变量，让diff逐渐增加，直到两侧有一侧找到C。将diff值push到res中。\r\n\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    const res = [] // 定义返回的数组\r\n    for (let i = 0; i < S.length; i++) {\r\n        let diff = 0; // 定义指针偏移量\r\n        while ((i - diff >= 0 || i + diff < S.length) && S[i - diff] != C && S[i + diff] != C) {\r\n            diff ++\r\n        }\r\n        res.push(diff)\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n复杂度分析:( n为S的length)\r\n\r\n时间复杂度：O(n^2)  空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993679674","body":"语言：js\n```js\nvar CustomStack = function(maxSize) {\n    this.size = maxSize;\n    this.list = [];\n};\n\n\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.size){\n        this.list.push(x);\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.list.length){\n        return this.list.pop();\n    }else{\n        return -1;\n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    if(this.list.length < k){\n        for(let i = 0; i < this.list.length; i ++){\n            this.list[i] += val\n        }\n    }else{\n        for(let i = 0; i < k; i ++){\n            this.list[i] += val\n        }\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994910316","body":"思路：使用栈的思想，用isNaN(x) 判断当前x是否是数字\n\n语言：js\n\n```js\nvar decodeString = function (s) {\n  let [stack, num, str] = [[], '', ''];\n  for (let i = 0; i < s.length; i++) {\n    //对数字进行类型转换\n    if (!isNaN(s[i])) {\n      num += s[i];\n      //当下一位不是数字的时候直接转换\n      if (isNaN(s[i + 1])) {\n        stack.push(Number(num));\n        num = '';\n      }\n      // 右括号开始计算\n    } else if (s[i] === ']') {\n      str = '';\n      //将需要计算的字符出栈\n      while (stack[stack.length - 1] !== '[') {\n        str = stack.pop() + str;\n      }\n      // 弹出\"[\"\n      stack.pop();\n      //将计算后的字符串入栈，repeat()是复制次数\n      stack.push(str.repeat(stack.pop()));\n      // 其他直接push进入stack\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995627412","body":"语言：js\n\n```js\nvar MyQueue = function () {\n  this.s1 = [];\n  this.s2 = [];\n};\n\nMyQueue.prototype.push = function (x) {\n  //推送到队列尾端\n  this.s1.push(x);\n};\n\nMyQueue.prototype.pop = function () {\n  // 先调用peek，保证s2非空，移除并返回元素\n  this.peek();\n  return this.s2.pop();\n};\n\nMyQueue.prototype.peek = function () {\n  // 如果是空的话\n  if (!this.s2.length) {\n    // 把s1元素全部压入s2中，返回队列开头的元素\n    while (this.s1.length) {\n      this.s2.push(this.s1.pop());\n    }\n  }\n  return this.s2[this.s2.length - 1];\n};\n\nMyQueue.prototype.empty = function () {\n    //返回队列是否为空\n    return !this.s1.length && !this.s2.length;\n};\n \n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996830964","body":"思路：看题解了，用单调栈的方法\n\n语言：js\n\n```js\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)O(N)，其中 N 为数组长度。","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999671451","body":"思路：快慢指针\n\n```js\nvar detectCycle = function(head) {\n  // 快慢指针初始化指向 head\n  let slow = head;\n  let fast = head;\n  // 快指针走到末尾时停止\n  while (fast && fast.next) {\n    // 慢指针走一步，快指针走两步\n    slow = slow.next;\n    fast = fast.next.next;\n    // 快慢指针相遇，说明含有环\n    if (slow == fast) {\n      // 任一一节点指向头节点\n      fast = head;\n      // 同步向前进\n      while (fast != slow) {\n        fast = fast.next;\n        slow = slow.next;\n      }\n      // 返回入口节点\n      return fast;\n    }\n  }\n  // 不包含环\n  return null;   \n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000874488","body":"思路：使用递归的方法，遍历所有节点得到最大深度\r\n\r\nJS Code:\r\n\r\n```js\r\nconst maxDepth = (root) => {\r\n    if (root == null) return 0;\r\n    const leftMaxDepth = maxDepth(root.left);\r\n    const rightMaxDepth = maxDepth(root.right);\r\n    return 1 + Math.max(leftMaxDepth, rightMaxDepth);\r\n};\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)，其中 N 为节点数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaoyi86":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918034","body":"### 思路\n\n从低位到高位计算，注意进位和边界处理。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(1)\n\\- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994761847","body":"思路\n括号匹配问题，栈，递归\n\n代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        num = 0\n        res = \"\"\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c \n            print(stack)\n        return res\n\n\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000850451","body":"思路\n\n递归计算\n代码\n\nvar maxDepth = function(root) {\n    if(!root) return 0;\n    if(!root.left&&!root.right) return 1;\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n};\n\n复杂度分析\n\n    时间复杂度:O(n)\n    空间复杂度:O(h)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivangin":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918630","body":"#### 思路：\r\n从右向左进行加法，记录进位，同时兼容超出num总位数的情况。使用LinkedList，参考链表头插法，减少后续转置操作。\r\n#### 代码\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        LinkedList<Integer> ans = new LinkedList<>();\r\n        while (k > 0 || i >= 0) {\r\n            if (i >= 0){\r\n                k += num[i--];\r\n            }    \r\n            ans.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度  O(max(m,n))，m是数组num的长度，n是k数位的个数\r\n空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993206075","body":"#### 思路：\r\n使用数组和一个栈顶指针，同时注意初始化指针为-1的情况下，出入栈的指针操作。\r\n\r\n#### 代码：\r\n\r\n```java \r\nclass CustomStack {\r\n\r\n    private int[] stack;\r\n    private int top;\r\n    private int maxSize;\r\n    public CustomStack(int maxSize) { // CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize之后则不支持 push 操作。\r\n        this.stack = new int[maxSize];\r\n        this.top = -1;\r\n        this.maxSize = maxSize;\r\n    }\r\n\r\n    public void push(int x) {//如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n        if (top == stack.length - 1){\r\n        return;\r\n        }\r\n        stack[++top] = x;\r\n\r\n    }\r\n\r\n    public int pop() {//弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n        if (top == -1) return -1;\r\n        return stack[top--];\r\n    }\r\n\r\n    public void increment(int k, int val) {//栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n        int num  = Math.min(k - 1, top);\r\n        if (num >= 0){\r\n        for (int i = 0; i <= num; i++) {\r\n            stack[i] += val;\r\n        }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 push\\pop->O(1) ; incr->O(k)\r\n空间复杂度 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994245482","body":"#### 思路\r\n使用两个栈维护中间结果和重复量\r\n\r\n#### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return s;\r\n        String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int index = 0;\r\n        while (index < s.length()){\r\n            if (Character.isDigit(s.charAt(index))){\r\n                int count = 0;\r\n                while(Character.isDigit(s.charAt(index))){\r\n                count = count * 10 + (s.charAt(index) - '0');//char 转成 int 是基础操作\r\n                index++;\r\n                }\r\n                countStack.push(count);\r\n            }else if (s.charAt(index) == '['){\r\n                resStack.push(res);\r\n                res = \"\";\r\n                index++;\r\n            }else if (s.charAt(index) == ']'){\r\n                StringBuffer tmp = new StringBuffer(resStack.pop());\r\n                int times = countStack.pop();\r\n                for (int i = 0; i < times; i++) {\r\n                tmp.append(res);\r\n                }\r\n                res = tmp.toString();\r\n                index++;\r\n            }else {\r\n                res += s.charAt(index);\r\n                index++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995378243","body":"#### 思路\r\n两个栈，一个负责输入，一个负责输出，注意pop和peek的情况分析，2无1有的时候，需要把1里的元素全部压入2。\r\n\r\n#### 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!s2.isEmpty()) return s2.pop();\r\n        else {\r\n            while (!s1.isEmpty()) s2.push(s1.pop());\r\n            return s2.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!s2.isEmpty()) return s2.peek();\r\n        else {\r\n            while (!s1.isEmpty()) s2.push(s1.pop());\r\n            return s2.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997348346","body":"#### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode l1 = dummy;\r\n        ListNode l2 = head;\r\n        while (l2 != null && l2.next != null) {\r\n            ListNode nextStart = l2.next.next;\r\n            l1.next = l2.next;\r\n            l2.next.next = l2;\r\n            l2.next = nextStart;\r\n            l1 = l2;\r\n            l2 = l2.next;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998501680","body":"#### 思路\r\n双指针问题，两个指针ab相同的速度向后移动,当 a 到达链表的尾部时,重定位到链表 B 的头结点当 b 到达链表的尾部时,重定位到链表 A 的头结点。两个指针相遇的点为相交的起始节点，否则没有相交点\r\n#### 代码：\r\n```java \r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        while (a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        return a;\r\n    }\r\n```\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999233278","body":"#### 思路\r\n快慢指针\r\n\r\n#### 代码\r\n```java\r\npublic ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) return null;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (fast == slow) {\r\n                ListNode slow2 = head;\r\n                while (slow != slow2) {\r\n                    slow = slow.next;\r\n                    slow2 = slow2.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999997098","body":"#### 代码\r\n```java\r\n\r\n  class LRUCache {\r\n\r\n    private Map<Integer, Node> map;\r\n    private int capacity;\r\n    private int count;\r\n    private Node head;\r\n    private Node tail;\r\n\r\n    class Node {\r\n      int key;\r\n      int value;\r\n      Node next;\r\n      Node pre;\r\n\r\n      public Node(int key, int value) {\r\n        this.key = key;\r\n        this.value = value;\r\n      }\r\n    }\r\n\r\n    public LRUCache(int capacity) {\r\n      map = new HashMap<>();\r\n      this.capacity = capacity;\r\n      head = null;\r\n      tail = null;\r\n    }\r\n\r\n    public int get(int key) {\r\n      Node node = map.get(key);\r\n      if (node == null) {\r\n        return -1;\r\n      }\r\n      if (node != tail) {\r\n        if (node == head) {\r\n          head = head.next;\r\n        } else {\r\n          node.pre.next = node.next;\r\n          node.next.pre = node.pre;\r\n        }\r\n        tail.next = node;\r\n        node.pre = tail;\r\n        node.next = null;\r\n        tail = node;\r\n      }\r\n      return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n      Node node = map.get(key);\r\n      if (node != null) {\r\n        node.value = value;\r\n        if (node != tail) {\r\n          if (node == head) {\r\n            head = head.next;\r\n          } else {\r\n            node.pre.next = node.next;\r\n            node.next.pre = node.pre;\r\n          }\r\n          tail.next = node;\r\n          node.pre = tail;\r\n          node.next = null;\r\n          tail = node;\r\n        }\r\n      } else {\r\n        Node newNode = new Node(key, value);\r\n        if (capacity == 0) {\r\n          Node temp = head;\r\n          head = head.next;\r\n          if (temp == tail) {\r\n            tail = null;\r\n          }\r\n          map.remove(temp.key);\r\n          capacity++;\r\n        }\r\n        if (head == null && tail == null) {\r\n          head = newNode;\r\n        } else {\r\n          tail.next = newNode;\r\n          newNode.pre = tail;\r\n          newNode.next = null;\r\n        }\r\n        tail = newNode;\r\n        map.put(key, newNode);\r\n        capacity--;\r\n      }\r\n    }\r\n  }\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guoling0019":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918971","body":"## 思路\n从右向左开始，数组的最后一位与k的最后一位相加，如果和小于10，放入新数组，如果大于10，取余，向左进一位\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let sumArr = []\n\n        for(let i=num.length-1;i>=0;--i){\n            let sum = num[i]+k%10\n            k=Math.floor(k/10)\n            if(sum>=10){\n                k++\n                sum-=10\n            }\n            sumArr.push(sum)\n        }\n        for(;k>0;k=Math.floor(k/10)){\n            sumArr.push(k%10)\n        }\n        \n        return sumArr.reverse()\n};\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992172020","body":"## 思路\r\n\r\n-  从当前元素开始分别向左右两边查询与目标元素是否相同，计算距离，取最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let arr = []\r\n        for(let i=0,len=s.length;i<len;i++){\r\n            if(s[i]==c){\r\n                arr[i]=0\r\n            }\r\n            let prev=i,next=i,shorttest=Infinity;\r\n            while(prev>=0){\r\n                if(s[prev]==c){\r\n                    shorttest = Math.min(shorttest,i-prev);\r\n                    break;\r\n                }\r\n                prev--\r\n            }\r\n            while(next<s.length){\r\n                if(s[next]==c){\r\n                    shorttest=Math.min(shorttest,next-i);\r\n                    break\r\n                }\r\n                next++\r\n            }\r\n            arr[i]=shorttest;\r\n        }\r\n        return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n^2)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993224262","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.max=maxSize;\n    this.stk=[]\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stk.length<this.max){\n        this.stk.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.stk.pop()\n    return res==null?-1:res\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<this.stk.length;i++){\n        if(i<k){\n            this.stk[i]+=val\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push和pop为O(1)、increment为O(n)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994449594","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n           for(let i=0;i<s.length;i++){\n               let repeatStr=''\n               let repeatCount=''\n               if(s[i]==']'){\n                    while(stack.length&&stack[stack.length-1]!='['){\n                        repeatStr = stack.pop()+repeatStr\n                    }\n                    stack.pop()\n                    while(stack.length&&!isNaN(stack[stack.length-1])){\n                        repeatCount=stack.pop()+repeatCount\n                    }\n                    stack.push(repeatStr.repeat(Number(repeatCount)))\n               }else{\n                   stack.push(s[i])\n               }\n           }\n           return stack.join('')\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995491130","body":"```javascript\n\nvar MyQueue = function() {\n        this.stack=[]\n        this.stack01=[]\n    };\n\n    /** \n        * @param {number} x\n        * @return {void}\n        */\n    MyQueue.prototype.push = function(x) {\n        let cur = null\n        while((cur=this.stack.pop())){\n            this.stack01.push(cur)\n        }\n        this.stack01.push(x)\n        while((cur=this.stack01.pop())){\n            this.stack.push(cur)\n        }\n    };\n\n    /**\n        * @return {number}\n        */\n    MyQueue.prototype.pop = function() {\n        return this.stack.pop()\n    };\n\n    /**\n        * @return {number}\n        */\n    MyQueue.prototype.peek = function() {\n        return this.stack[this.stack.length-1]\n    };\n\n    /**\n        * @return {boolean}\n        */\n    MyQueue.prototype.empty = function() {\n        return this.stack.length == 0\n    };\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996535435","body":"JavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let stack = [];\n        for(let i=0;i<arr.length;i++){\n            if(stack.length>0&&stack[stack.length-1]>arr[i]){\n                const cur = stack[stack.length-1]\n                while(stack&&stack[stack.length-1]>arr[i]) stack.pop()\n                stack.push(cur)\n            }else{\n                stack.push(arr[i])\n            }\n        }\n        return stack.length\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997169904","body":"JavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997398980","body":"JavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if(head==null||head.next==null){\n        return head\n    }\n    const newhead=head.next\n    head.next=swapPairs(newhead.next)\n    newhead.next=head\n    return newhead\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997708579","body":"```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\n var sortedListToBST = function(head){\n        if(head==null) return null\n        return dfs(head,null)\n        }\n\n        function dfs(head,tail){\n            if(head==tail) return null;\n            let fast = head;\n            let slow = head;\n            while(fast!=tail&&fast.next!=tail){\n                fast=fast.next.next\n                slow=slow.next\n            }\n            let root = new TreeNode(slow.val)\n            root.left = dfs(head,slow)\n            root.right = dfs(slow.next,tail)\n            return root\n        }\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(logn)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998393281","body":"## 思路\n- 双指针\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let nodeA=headA,nodeB=headB\n    if(!nodeA||!nodeB){\n        return null\n    }\n    while(nodeA!=nodeB){\n        nodeA=nodeA?nodeA.next:headB\n        nodeB=nodeB?nodeB.next:headA\n    }\n    return nodeA\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999250790","body":"## 思路\n- 双指针\n1，走a+nb步一定是在环入口，a为head到环入口节点数，b为环的节点数\n2，第一次相遇时慢指针已经走了nb步\n\n \n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head==null){\n        return null\n    }\n    let fast=head,slow=head\n    while(fast!==null){\n        slow=slow.next\n        if(fast.next!==null){\n            fast=fast.next.next\n        }else{\n            return null\n        }\n        if(fast==slow){\n            fast=head\n            while(fast!==slow){\n                fast=fast.next\n                slow=slow.next\n            }\n            return fast\n        }\n    }\n    return null\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000391029","body":"看着不难，写起来完全不会系列……\n\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000699881","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(root==null){\n        return 0\n    }else{\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(depth)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001020631","body":"## 关键点\n\n-  递归\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(!p||!q){\n        return !p&&!q\n    }\n    return (p.val==q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right))\n\n};\n\n```\n\n\n**复杂度分析**\n\n\n- 时间复杂度：$O(n)$ n为树的节点数\n- 空间复杂度：$O(h)$ h为树的高度\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"extra-man":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991920337","body":"### 思路\r\n自己想的贼复杂，还不对，最后看的力扣的答案\r\n### 代码\r\n//自己写不出来，抄的答案，\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n### 复杂度分析\r\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\r\n\r\n空间复杂度：O(1)O(1)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993535221","body":"### 思路\r\n\r\n自己也不知道有没有思路，哎。\r\n看官方题解，正常（算是暴力解法）能看懂，可是自己写不出来。优化的前缀和没看懂，，，好难，\r\n\r\n### 代码\r\n```\r\n\r\nclass CustomStack {\r\n    Stack<Integer> stack;\r\n    int[] incrementals;\r\n    int maxSize = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new Stack<>();\r\n        incrementals = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < maxSize) {\r\n            stack.push(x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if (i < 0) return -1;\r\n        if (i > 0) {\r\n            incrementals[i - 1] += incrementals[i];\r\n        }\r\n        int res = stack.pop() + incrementals[i];\r\n        incrementals[i] = 0;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k, stack.size()) - 1;\r\n        if (i >= 0) {\r\n            incrementals[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度： O(maxSize / N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994791174","body":"### 思路\n\n答案看懂了，但是不会写\n\n### 代码\n\n\n```\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995818631","body":"### 思路\n\n我想的入队直接入栈就行，出的话再用另一个栈倒一遍，应该可以，\n不过代码还是写不出来，参考的力扣\n\n### 代码\n\n\n```\nprivate Stack<Integer> s1 = new Stack<>();\nprivate Stack<Integer> s2 = new Stack<>();\n\npublic void push(int x) {\nif (s1.empty()) front = x;\ns1.push(x);\n}\n\npublic void pop() {\nif (s2.isEmpty()) {\nwhile (!s1.isEmpty())\ns2.push(s1.pop());\n}\ns2.pop();\n}\n\npublic boolean empty() {\nreturn s1.isEmpty() && s2.isEmpty();}\n\n\npublic int peek(){\nif (!s2.isEmpty()) {\nreturn s2.peek();}\nreturn front;}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999645421","body":"### 思路\n\n哈希表\n\n### 代码\n\n\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pos = head;\n        Set<ListNode> visited = new HashSet<ListNode>();\n        while (pos != null) {\n            if (visited.contains(pos)) {\n                return pos;\n            } else {\n                visited.add(pos);\n            }\n            pos = pos.next;\n        }\n        return null;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a1exlism":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991921856","body":"### 思路\r\n\r\n注意范围, 还有两处边界\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        for i in range(len(A)-1, -1, -1):\r\n            K += A[i]\r\n            A[i] = K % 10\r\n            K //= 10\r\n        while(K > 0):\r\n            A.insert(0, K % 10)\r\n            K //= 10\r\n        return A\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N) (包括数组A大小)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992617976","body":"### 思路\n\n- 记忆化解决多个 c 问题, 保存之前的状态;\n- prev 遍历两个方向保证 minimum\n\n### 代码\n\n```python\ndef shortestToCharOfficial(S: str, C: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        # L -> R\n        for i, v in enumerate(S):\n            if v == C:\n                prev = i\n            ans.append(i-prev)\n        # print(ans)\n        # R -> L TIPS: INF\n        prev = float('inf')\n        for i in range(len(S)-1, -1, -1):\n            if S[i] == C:\n                prev = i\n            ans[i] = min(ans[i], prev-i)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(|S|), |S| 为 str 长度\n- 空间复杂度: O(|S|)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922535","body":"\n**思路**\n\n数字小的直接用加法\n\n数字大的，要考虑和k的加法和进位，超过k就只考虑进位\n\n**代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        if len(num) <= len(str(k)):\n            return [int(j) for j in list(str(int(\"\".join([str(i) for i in num])) + k))]\n\n\n        k = [int(i) for i in list(str(k))]\n        c = 0\n        for j in range(len(num)-1,len(num)-len(k)-1,-1):\n            n = num[j] + k[j-len(num)+len(k)] + c\n            num[j] = n % 10\n            c = n // 10\n\n        for j in range(len(num)-len(k)-1,-1,-1):\n            print(j)\n            print(num[j],c)\n\n            if c == 0:\n                return num\n            else:\n                n = num[j] + c\n                num[j] = n % 10\n                c = n // 10\n\n        if c == 1:\n            return [1] + num\n        else:\n            return num\n```\n\n**复杂度分析**\n\n时间 O(n) 加过k之后，如果没有进位会提前结束\n\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992616644","body":"**思路**\r\n\r\n标记最近的位置进行遍历\r\n\r\n**代码**\r\n\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993685282","body":"\r\n**代码**\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(1)\r\n空间 O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994920172","body":"**思路**\r\n\r\n用栈来暂存\r\n\r\n读取数字 如果大于10 则按位乘10倍 来计算数字总值\r\n\r\n读取左右括号 从而找到需要重复的n次的 “内容”\r\n\r\n**代码**\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(N)\r\n\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995927870","body":"**思路**\r\n\r\npush直接往里压\r\n\r\npop要先把s1所有元素压入s2再输出，从而保证先入先出\r\n如果s2有元素 直接输出\r\n\r\n**代码**\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.s2:\r\n            return self.s2.pop()\r\n        else:\r\n            for i in range(len(self.s1)):\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.s2:\r\n            return self.s2[-1]\r\n        else:\r\n            for i in range(len(self.s1)):\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.s1 and not self.s2:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 push O(1) popO(1) or O(n)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996827775","body":"**思路**\r\n找到从左边开始最小的块\r\n\r\n**代码**\r\n\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count = collections.Counter()\r\n        counted = []\r\n        for x in arr:\r\n            count[x] += 1\r\n            counted.append((x, count[x]))\r\n\r\n        ans, cur = 0, None\r\n        for X, Y in zip(counted, sorted(counted)):\r\n            cur = max(cur, X)\r\n            if cur == Y:\r\n                ans += 1\r\n        return ans\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(NlogN)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222586","body":"**思路**\r\n找到第k个位置，断开，再连起来\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n\r\n```\r\n\r\n**复杂度**\r\nO(n)\r\nO(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414141","body":"**思路**\r\n\r\n节点小于2个，直接原样返回\r\n新节点设为第二个节点，\r\n第一个节点 递归接后面的排序号的链表，\r\n新节点的下一个节点连接第一个节点\r\n\r\n**代码**\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        newhead = head.next\r\n        head.next = self.swapPairs(newhead.next)\r\n        newhead.next = head\r\n        return newhead\r\n```\r\n\r\n**复杂度**\r\n\r\n时间O(n)\r\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997426062","body":"**思路**\r\n快慢指针找根节点，然后左链表断开 继续找左子树，右链表继续找右子树\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        \r\n        slow = head\r\n        fast = head\r\n        pre = None\r\n        \r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        root = TreeNode(slow.val)\r\n        print(slow.val)\r\n        if pre:\r\n            pre.next = None\r\n            root.left = self.sortedListToBST(head)\r\n\r\n        root.right = self.sortedListToBST(slow.next)\r\n\r\n        return root\r\n```\r\n\r\n**复杂度**\r\n时间O(nlogn)\r\n空间O(logn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998896492","body":"**思路**\r\nA独有 + 重复 + B独有 + 重复\r\nB独有 + 重复 + A独有 + 重复\r\n\r\n如有重复部分，两个指针同时移动，必会在第三部分后相遇\r\n否则只会同时到达尾部的None\r\n\r\n双指针pa pb从头开始移动，如果有内容则后移一位，否则转换为另一个链表继续移动\r\n找到相同的值 返回\r\n\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        \r\n        pa = headA\r\n        pb = headB\r\n\r\n        while pa != pb:\r\n\r\n            if pa:\r\n                pa = pa.next\r\n            else:\r\n                pa = headB\r\n            \r\n            if pb:\r\n                pb = pb.next\r\n            else:\r\n                pb = headA\r\n\r\n        \r\n        return pa\r\n```\r\n\r\n**复杂度**\r\n\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998904890","body":"**思路**\r\n快慢指针，相遇必有环\r\n相遇后加入p指针从头开始，p和slow同时移动，会在入环点相遇\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow = head\r\n        fast = head\r\n\r\n        while fast:\r\n            slow = slow.next\r\n\r\n            if fast.next:\r\n                fast = fast.next.next\r\n            else:\r\n                return None\r\n\r\n            if slow == fast:\r\n                p = head\r\n                while p != slow:\r\n                    p = p.next\r\n                    slow = slow.next\r\n                return p\r\n\r\n        return None\r\n```\r\n\r\n**复杂度**\r\n空间O(n)\r\n时间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000349830","body":"**思路**\r\n字典存key，node 用来 O(1)的get\r\n双链表结构用来O(1)的put\r\n\r\n**代码**\r\n```python\r\nclass ListNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.cache = dict()\r\n\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        \r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            self.move_node_to_head(node)\r\n            return self.cache[key].value\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        # 在内 只需要更改数值\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.move_node_to_head(node)\r\n            return\r\n\r\n        # 超过容量 需要先删除最后一个\r\n        if len(self.cache) >= self.capacity:\r\n            last_node = self.tail.prev\r\n            self.cache.pop(last_node.key)\r\n            self.disconnect(last_node)\r\n        \r\n        # 添加最新的一个到头部\r\n        new = ListNode(key, value)\r\n        self.cache[key] = new\r\n        self.add_to_head(new)\r\n\r\n    def move_node_to_head(self, node):\r\n        # 找到旧节点，断开连接\r\n        self.disconnect(node)\r\n        # 链接节点\r\n        self.add_to_head(node)\r\n\r\n    def add_to_head(self, node):\r\n        # 链接节点前后\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n\r\n    def disconnect(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n```\r\n\r\n**复杂度**\r\n时间 O(1)\r\n空间 O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000383253","body":"**思路**\r\n递归\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if root:\r\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n        else:\r\n            return 0\r\n```\r\n\r\n**复杂度**\r\n时间 O(n)\r\n空间 O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000892499","body":"**思路**\r\n边界 + 根 + 左子树 + 右子树\r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        return p != None and q != None and q.val == p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n**复杂度**\r\n时间 O(n)\r\n空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackzcai":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922549","body":"//1，不可将A数组遍历得到sumA，与K做加法得到和，原因：A数组的长度可能很长，整数越界；\r\n//2，将K与A倒序的每个元素相加得到和，将和取模得到每个元素，插入到新数组中。\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int len = A.length;\r\n        int lastNum =K;\r\n        LinkedList<Integer> ret= new LinkedList<>();\r\n        int i = len-1;\r\n        while(i >=0 || lastNum > 0){\r\n            int tmp = lastNum % 10 + (i >= 0 ? A[i] : 0);\r\n            ret.addFirst(tmp%10);\r\n            lastNum = lastNum / 10 + tmp / 10;\r\n            i--;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996828897","body":"//采用递归的思想，每一步递归判断能否分块，能分块则加一，然后判断剩下的能否分块，使递归不管逼近整个数组。\r\n\r\n\r\nclass Solution {\r\n    int i =0;\r\n    public int maxChunksToSorted(int[] arr) {\r\n        can(arr,0);\r\n        if(i==0)\r\n        i++;\r\n        return i;\r\n    }\r\n    public boolean can(int[] arr,int num){\r\n        if(num==arr.length){\r\n            return true;\r\n        }else{\r\n            boolean check = true;\r\n            for(int i =0;i<=num;i++){\r\n                for(int k = num;k<arr.length;k++){\r\n                    if(arr[i]>=arr[k])\r\n                    return false;\r\n                }               \r\n            }\r\n            if(check){\r\n                i++;\r\n                if(can(arr , num +1)){\r\n                return true;}\r\n                else{\r\n                    return false;\r\n                }\r\n\r\n            }\r\n            \r\n\r\n        }\r\nreturn false;\r\n    }\r\n}\r\n\r\n//时间复杂度O(n2)\r\n//空间复杂度O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000340956","body":"--py\r\n\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"helloxkw":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922639","body":"思路：\n从k的个位和数组的最后元素入手，k先模10拿到个位，与数组最后一位相加后结果放入res数组，\n接着k/=10处理除去个位，继续拿十位数，与数组倒数第二个元素相加，如果有进位则返到k值\nk还小于0不需要进位且A数组没有值的情况，则环循环结束。\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //用LinkedList不断从头将位数和加入index 0\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            //从末尾往前扫，加和取余的值\n            res.add(0, (num[i] + k) % 10);\n            //更新k存进位carry\n            k = (num[i] + k) / 10;\n        }\n\n        // post-possing: 处理k位数大于num的情况剩下的部分\n        // Time = O(log(k))\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n\n        return res;\n    }\n}\n\n复杂度分析\n时间复杂度 O(max(m,n))，m是数组num的长度，n是k数位的个数\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992615919","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> record;\n        vector<int> ans(len);\n        for (int i = 0; i < len; i++) {\n            if (s[i] == c) record.push_back(i);\n        }\n        \n        for (int i = 0; i < len; i++) {\n            int temp = INT_MAX;\n            for (int k = 0; k < record.size(); k++) {\n                temp = min(temp, abs(i - record[k]));\n            }\n            ans[i] = temp;\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993627993","body":"class CustomStack {\n\n    int[] s;\n    int top = -1;\n\n    public CustomStack(int maxSize) {\n        s = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top < s.length-1){\n            s[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top > -1){\n            return s[top--];\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        int t = k-1;\n        if (top < k-1){\n            t = top;\n        }\n        for (int i = 0; i <= t; i++) {\n            s[i] += val;\n        }\n    }\n}\n复杂度分析\n\n时间复杂度:\npush/pop O(1)\nincrement O(N)\n空间复杂度: O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995922995","body":"思路\n用采用两个栈，一个栈输入，一个栈输出，模拟队列。\n\n代码\nclass MyQueue {\npublic:\n    stack<int> sIn;\n    stack<int> sOut;\npublic:\n    MyQueue() {\n        sIn =  stack<int>();\n        sOut =  stack<int>();\n    }\n    \n    void push(int x) {        \n        sIn.push(x);\n        \n    }\n    \n    int pop() {\n        \n        if(sOut.empty()) {//如果输出栈为空，则从输入栈中取数据\n          \n                while(!sIn.empty())\n                {\n                sOut.push(sIn.top());\n                sIn.pop();\n                }\n           \n        }   \n        int result = sOut.top();\n        sOut.pop();\n        return result;\n\n            \n    }\n    \n    int peek() {\n        if(sOut.empty()) {//如果输出栈为空，则从输入栈中取数据\n          \n                while(!sIn.empty())\n                {\n                sOut.push(sIn.top());\n                sIn.pop();\n                }\n           \n        }   \n        int result = sOut.top();\n        \n        return result;\n    }\n    \n    bool empty() {\n        return (sIn.empty()&&(sOut.empty()));//两个为空才为空\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n复杂度分析\n\n时间复杂度：O(N)，其中 N 为栈中数据长度。\n空间复杂度：O(N) 两个栈的空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997220073","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997415570","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997986714","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head != null) {\n            ListNode fast = head, slow = head, preSlow = null;\n\n            // 快慢指针移动\n            while(fast != null) {\n                fast = fast.next;\n                if(fast != null){\n                    fast = fast.next;\n                    preSlow = slow;\n                    slow = slow.next;\n                }\n            }\n\n            TreeNode treeNode = new TreeNode(slow.val);\n            treeNode.right = sortedListToBST(slow.next);\n            if(preSlow != null) {\n                preSlow.next = null;\n                treeNode.left = sortedListToBST(head);\n            }\n            return treeNode;\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998897162","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode *> visited;\n        ListNode *temp = headA;\n        while (temp != nullptr) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp != nullptr) {\n            if (visited.count(temp)) {\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000384673","body":"思路\npython字典\n\n代码(Python)\nclass LRUCache(object):\n    def __init__(self,capacity:int):\n        self.capacity=capacity\n        self.dd={}\n    def get(self,key):\n        if key in self.dd.keys():\n            return self.dd[key]\n        else:\n            return -1\n\n    def put(self,key,value):\n        if key in self.dd.keys():\n            self.dd[key]=value\n        else:\n            if len(self.dd)==self.capacity:\n\n                self.dd.pop(key)\n            else:\n                self.dd[key]=value\n复杂度分析\n时间复杂度： O(N)。\n空间复杂度：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000882142","body":"思路：\n\n输出深度是当前root的最大深度\n\n深度优先搜索，比较左右节点的深度递归，取左右节点的最大\n\n出口是当前节点为空\n\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        def dfs(root):\n            if not root :\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            depth = max(left,right)\n            return depth +1\n        return dfs(root)\n复杂度分析：\n\n时间复杂度：O(N),其中N为节点个数\n\n空间复杂度: O(h),h为树的深度，最坏时候为N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001038945","body":"class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mongoczk":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991924489","body":"思路：\r\n逐位相加：逐位将数字加在一起，若加法结果大于等于10，则需要进位\r\n代码：**JavaScript**\r\n```javascript \r\n var addToArrayForm = function(num, k) {\r\n  const arr = []\r\n  const len = num.length\r\n  for( let i = len-1; i >= 0; i-- ){\r\n    let sum = num[i] + k % 10;\r\n    k = Math.floor(k / 10);\r\n    if( sum >= 10){\r\n      k++;\r\n      sum -= 10 \r\n    }\r\n    arr.push(sum)\r\n  }\r\n  for(; k > 0; k = Math.floor( k / 10)){\r\n    arr.push(k % 10)\r\n  }\r\n  return arr.reverse();\r\n};\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：O(N)，其中 N为数组的长度。\r\n空间复杂度：O(1), 除了返回值以外，使用了一个常数记录数组的长度。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992616476","body":"### 思路\r\n+ 使用两次遍历，找到每个字符分别离左边和右边最近的的字符c的距离，取最小值\r\n+ 初始化记录距离的数组，每个元素值为数组长度-1，即最大距离\r\n+ 从左向右遍历： 存储数组元素到左边最近的字符c的距离，遇到字符c时更新下标\r\n+ 从右向左遍历： 比该数组元素到右边最近的字符c的距离与记录的距离，取最小值，遇到字符c时更新下标\r\n\r\n### 代码 —   **JavaScript**\r\n```javascript\r\n var shortestToChar = function(s, c) {\r\n  s = s.split('')\r\n  let len = s.length\r\n  let prev = len-1\r\n  let distance = new Array(len).fill(prev)\r\n  for(let i=0; i< len; i++){\r\n    if(s[i] == c){\r\n      distance[i] = 0\r\n      prev = i\r\n    }else{\r\n      distance[i] =  Math.abs(i-prev)\r\n    }\r\n  }\r\n  for(let i=len-1; i>=0; i--){\r\n    if(s[i] == c){\r\n      distance[i] = 0\r\n      prev = i\r\n    }else{\r\n      distance[i] = Math.min(Math.abs(i-prev),distance[i])\r\n    }\r\n  }\r\n  return distance\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n+ 时间复杂度：O(n)：两次循环，n为字符串长度\r\n+ 空间复杂度：O(n): 除返回值外，使用了一个数组，长度为字符串长度，空间为 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993534554","body":"### 思路 模拟优化\r\n\r\n- 使用数组来模拟栈\r\n- pop、push操作可以使用数组的pop、push来完成\r\n- increment操作可以用一个数组incs来维护每次increment操作时增量，pop 的时候，将弹出栈的元素的值加上incs数组中对应下标的增量即可得到 increment操作后的值\r\n- 需要注意的是，incs上的某个增量如incs[ i ]使用之后，需将增量值累加到前一个增量上，同时将这个增量incs[ i ]置为0\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function (maxSize) {\r\n  this.arr = [];\r\n  this.incs = new Array(maxSize).fill(0);\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.arr.length < this.maxSize) {\r\n    this.arr.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.arr.length > 0) {\r\n    let top = this.arr.length - 1;\r\n    if(top > 0) this.incs[top - 1] += this.incs[top];\r\n    let result = this.arr.pop() + this.incs[top];\r\n    this.incs[top] = 0;\r\n    return result\r\n  }\r\n  return -1\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let m = Math.min(k, this.arr.length);\r\n  if( m > 0){\r\n    this.incs[m-1] += val;\r\n  }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)：push、pop、increment 的时间复杂度均为 O(1)\r\n- 空间复杂度：O(n): 除返回值外，使用incs数组存放增量，数组长度n为maxSize大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994916277","body":"### 思路\r\n 使用辅助栈，遍历字符串，对每个字符，有：\r\n  + 如果是字母 --> 添加到 stack 当中\r\n  + 如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n  + 如果是 [ --> 说明重复字符串开始 --> 将数字入栈 --> 并且将数字清零\r\n  + 如果是 ] --> 说明重复字符串结束 --> 将重复字符串重复前一步储存的数字遍\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n**复杂度分析**\r\n+ 时间复杂度：O(N)，其中 N 为解码后的 s 的长度。\r\n+ 空间复杂度：O(N)，其中 N 为解码后的 s 的长度。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995136403","body":"### 思路\r\n+ 构建两个栈stack和reverseStack，reverseStack的栈顶始终是最先入栈的元素，即队头\r\n+ push操作：若reverseStack为空，则入栈reverseStack，否则，入栈stack\r\n+ pop操作：reverseStack弹出栈顶元素，当reverseStack为空时，将stack中的元素依次弹出并入栈reverseStack\r\n+ peek操作：取reverseStack的栈顶元素值\r\n+ empty操作： 判断两个栈是否均为空\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n  this.stack = []\r\n  this.reverseStack = []\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nMyQueue.prototype.push = function(x) {\r\n  if(this.reverseStack.length > 0){\r\n      this.stack.push(x)\r\n  }else{\r\n      this.reverseStack.push(x)\r\n  }\r\n};\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.pop = function() {\r\n  let item = this.reverseStack.pop()\r\n  if(this.reverseStack.length == 0){\r\n      while(this.stack.length > 0){\r\n          this.reverseStack.push(this.stack.pop())\r\n      }\r\n  }\r\n  return item\r\n};\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.peek = function() {\r\n return this.reverseStack[this.reverseStack.length-1]\r\n};\r\n\r\n/**\r\n* @return {boolean}\r\n*/\r\nMyQueue.prototype.empty = function() {\r\n  return this.reverseStack.length == 0 && this.stack.length ==0\r\n};\r\n```\r\n**复杂度分析**\r\n+ 时间复杂度：摊还复杂度 O(1)，最坏情况下的时间复杂度 O(n)\r\n+ 空间复杂度： push和pop操作时需要额外的空间来储存元素，空间复杂度为O(n),其他操作为O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996058650","body":"### 思路\r\n+ 使用滑动窗口同时扫描原数组和排序数组，当窗口中数字的和一样时，就将窗口内的元素分块\r\n### 代码\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  const sorted = [...arr];\r\n  sorted.sort((a, b) => a - b);\r\n\r\n  let count = 0,\r\n    sum1 = 0,\r\n    sum2 = 0;\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum1 += arr[i];\r\n    sum2 += sorted[i];\r\n    sum1 ===  sum2 && count++;\r\n  }\r\n\r\n  return count;\r\n};\r\n```\r\n**复杂度分析**\r\n+ 时间复杂度：O(NlogN)，N 为数组长度，数组排序时间认为是NlogN，滑动窗口遍历数组时间为N\r\n+ 空间复杂度: O(N)，N 为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997212116","body":"### 思路\r\n+ 遍历链表，记录链表长度\r\n+ 将链表头尾相接，形成环链表\r\n+ 计算得出移动k个位置后，新链表最后一个节点的位置 n - k%n\r\n+ 遍历链表，在n - k%n 处断开，形成新链表\r\n\r\n### 代码\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if( k==0 || !head || !head.next) return head\r\n    \r\n    let n = 1\r\n    let cur = head \r\n    while(cur.next){\r\n        cur = cur.next\r\n        n++\r\n    }\r\n    let add = n - k%n\r\n    if( add == n ) return head\r\n\r\n    cur.next = head\r\n    while(add > 0){\r\n        cur = cur.next\r\n        add--\r\n    }\r\n    let res = cur.next\r\n    cur.next = null\r\n    return res\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N) N为链表长度，最坏情况下，需要遍历两次链表\r\n- 空间复杂度: O(1) 只需要常数的空间存储若干变量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997397648","body":"### 思路\r\n\r\n- 构建一个空链表 dummy，链表 dummy 的下一节点所给链表 head 的头部\r\n- 构建 temp 指针指向当前到达的节点，初始时 temp 指向 dummy\r\n- 迭代交换 temp 后面的两个节点，如果 temp 后面存在两个节点，则进行交换，交完完成后更新 temp，指向当前到达的节点\r\n- 迭代完成后返回新链表的头节点，即 dummy.next\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n  if (!head || !head.next) return head;\r\n\r\n  let dummy = new ListNode(0, head);\r\n  let temp = dummy;\r\n  let node1, node2;\r\n  while ((node1 = temp.next) !== null && (node2 = temp.next.next) !== null) {\r\n    temp.next = node2;\r\n    node1.next = node2.next;\r\n    node2.next = node1;\r\n    temp = node1;\r\n  }\r\n  return dummy.next;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N) N 为链表长度\r\n- 空间复杂度: O(1) 只需要常数空间存储变量\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998039438","body":"## 思路\r\n\r\n- 将有序链表转成有序数组，递归分治数组，构建二叉树\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nconst sortedListToBST = (head) => {\r\n  const arr = [];\r\n  while (head) { \r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;        \r\n    const mid = (start + end) >>> 1;     \r\n    const root = new TreeNode(arr[mid]); \r\n    root.left = buildBST(start, mid - 1); \r\n    root.right = buildBST(mid + 1, end);  \r\n    return root;                          \r\n  };\r\n\r\n  return buildBST(0, arr.length - 1);  \r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)   遍历一次数组\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998879391","body":"## 思路\r\n\r\n使用哈希集合存储链表节点，先遍历链表 headA，将链表 headA 中的每个节点加入哈希集合中，然后遍历链表 headB，对于每个遍历到的节点\r\n\r\n- 如果当前节点不在哈希集合中，则继续遍历下一个节点\r\n- 如果当前节点在哈希集合中，则返回该节点\r\n \r\n如果链表 headB 中的所有节点都不在哈希集合，则两个链表不相交，返回 null\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n  const visited = new Set();\r\n  let temp = headA;\r\n  while (temp !== null) {\r\n    visited.add(temp);\r\n    temp = temp.next;\r\n  }\r\n  temp = headB;\r\n  while (temp !== null) {\r\n    if (visited.has(temp)) {\r\n      return temp;\r\n    }\r\n    temp = temp.next;\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 m 为链表 headA 长度，n 为链表 headB 长度。\r\n\r\n- 时间复杂度：O(m+n) 需要遍历两个链表各一次\r\n- 空间复杂度：O(m) 需要使用哈希集合存储链表 headA 的全部节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999675895","body":"## 思路\r\n\r\n使用哈希集合记录访问过的节点，如果已访问过节点，则该节点为开始入环的第一个节点\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  let set = new Set(),\r\n    p = head;\r\n  while (p) {\r\n    if (set.has(p)) {\r\n      return p;\r\n    } else {\r\n      set.add(p);\r\n      p = p.next;\r\n    }\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n) 一次遍历链表\r\n- 空间复杂度：O(n) 需要 n 个空间记录访问过的节点","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000874709","body":"## 思路\r\n\r\n深度优先搜索，递归计算左右子树的最大深度\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(!root) return 0\r\n    return Math.max( maxDepth(root.left), maxDepth(root.right) ) + 1\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为二叉树节点的个数\r\n\r\n- 时间复杂度：O(n)  递归遍历中每个树节点只需遍历一次\r\n- 空间复杂度：O(height)  递归函数需要栈空间，栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001035399","body":"\r\n## 思路\r\n\r\n当两棵树均为 null，两棵树结构相同，当两棵树其中一棵为 null，另一棵不为 null 是，两棵树结构不同，节点值不同时，两棵树结构也不同，使用深度优先搜索分别递归遍历 p、q 树的左右子树\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n  if (p == null || q == null) {\r\n    return p == null && q == null;\r\n  } else if (p.val != q.val) {\r\n    return false;\r\n  }\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 m 为 p 树节点数量，令 n 为 q 树节点数量。\r\n\r\n- 时间复杂度：O(min(m,n)) 递归遍历中，只有两棵树中的对应节点均不为空才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数\r\n- 空间复杂度：O(min(m,n)) 空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shao-nuoya":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991959157","body":"# 思路\r\n正向及反向遍历\r\n注意初始时第一个c的位置的设定\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n =  len(s)\r\n        left = float('-inf')\r\n        ans = [0 for _ in range(n)]\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                left = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = i - left\r\n\r\n        right = float('inf')\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                right = i\r\n            else:\r\n                ans[i] = min(right -i, ans[i])\r\n\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992981152","body":"# 类的用法\n# Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            ans = self.stack[-1]\n            del self.stack[-1]\n            return ans\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994127995","body":"# 栈的使用\n# code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        multi = 0\n        res = ''\n        stack = []\n\n        for ss in s:\n            if ss == '[':\n                stack.append([multi, res])\n                res, multi = '', 0\n            elif ss == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0'<=ss<='9':\n                multi = 10*multi + int(ss)\n            else:\n                res += ss\n\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995267092","body":"# 队列\n# Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        return self.queue.pop(0)\n\n    def peek(self) -> int:\n        return self.queue[0]\n\n    def empty(self) -> bool:\n        if len(self.queue)>0:\n            return False\n        else:\n            return True\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997485670","body":"# Code\n```python\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangziqi1998666":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991978597","body":"- 时间复杂度：O(n*m)\n- 空间复杂度：O(n)   \n /**\n     * 暴力解法\n     * 既然我们需要找到最短距离，那么首先应该获取到该字符在字符串 s 中的所有下标位置。\n     * 使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组location。\n     * 创建 res 数组，长度为s.length()\n     * 再次遍历s的过程中，再遍历location集合\n     * 寻找距离i最近的距离，并存入res中\n     *\n     * @param s\n     * @param c\n     * @return\n     */\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> location = new ArrayList<Integer>();\n        for (int i=0; i < s.length(); i++){\n            if (s.charAt(i) == c)\n                location.add(i);\n        }\n\n        int[] res = new int[s.length()];\n        int min,dis;\n\n        for ( int i=0; i< s.length(); i++){\n            min = Integer.MAX_VALUE/2;\n            for (int j=0; j < location.size(); j++){\n                dis = Math.abs(location.get(j)-i);\n                if (dis<min){\n                    min = dis;\n                    res[i] = min;\n                }\n            }\n        }\n        return res;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992811814","body":"```java\nclass CustomStack {\n    private int maxSize;\n    private int[] stack;\n    private int pointer;\n\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.pointer = -1;\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (pointer != maxSize-1){\n            pointer++;\n            stack[pointer] = x;\n        }\n\n    }\n    \n    public int pop() {\n        if (pointer == -1)\n            return -1;\n        pointer--;\n        return stack[pointer+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i <= pointer && i < k; i++){\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994033719","body":"```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for(char c: s.toCharArray()){\n            if(c!=']')\n                stack.push(c); // 除了], 全部压入栈\n\n            else{\n                // step1. 取出[]内的字符串\n                StringBuilder sb =new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0,stack.pop());\n\n                String sub = sb.toString(); // []内的字符串\n                stack.pop(); //去除 [\n\n                // step2. 获取倍数数字\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\n                    sb.insert(0,stack.pop());\n\n                int count = Integer.valueOf(sb.toString());\n\n                // step3. 根据倍数把字母push回去\n                while(count>0){\n                    for(char ch: sub.toCharArray())\n                        stack.push(ch);\n                        count--;\n                }\n            }\n        }\n\n        //把栈里面所有的字母取出来\n        StringBuilder retv = new StringBuilder();\n        while(!stack.isEmpty())\n            retv.insert(0, stack.pop());\n\n        return retv.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995191908","body":"```java\r\nclass MyQueue {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> temp;\r\n\r\n    public MyQueue() {\r\n        this.stack = new Stack();\r\n        temp = new Stack();\r\n    }\r\n    \r\n    /*\r\n    时间复杂度: O(n)\r\n    空间复杂度: O(n)\r\n     */\r\n    public void push(int x) {\r\n        while(!stack.isEmpty())\r\n            temp.push(stack.pop());\r\n        temp.push(x);\r\n        while(!temp.isEmpty())\r\n            stack.push(temp.pop());\r\n    }\r\n\r\n    /* \r\n    Removes the element from the front of queue.\r\n    时间复杂度: O(1)\r\n    空间复杂度: O(1)\r\n    */\r\n    public int pop() {\r\n        return stack.pop();\r\n    }\r\n    \r\n    /* \r\n    Get the front element.\r\n    时间复杂度: O(1)\r\n    空间复杂度: O(1)\r\n    */\r\n    public int peek() {\r\n        return stack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997066330","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0 || head.next == null)\n            return head;\n        int num = 0;\n        ListNode tail = null;\n        ListNode p = head;\n        // find the length and tail of the list\n        while(p != null){\n            tail = p;\n            p = p.next;\n            num++;\n        }\n        // decide the back length when k is too large\n        k %= num;\n        // find the last node after rotation ( the k+1 th node from the tail)\n        p = head;\n        for(int i = 0; i < num - k - 1; i++)\n            p = p.next;\n        // do the cut and join operation\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n\n        return head;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997280901","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n        ListNode newHead = head.next;\n        head.next = swapPairs(head.next.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blessinglr":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991978913","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = [-float('inf')]\n        for idx, char in enumerate(s):\n            if char == c:\n                pos.append(idx)\n        pos.append(float('inf'))\n        i = 1\n        res = []\n        for idx, char in enumerate(s):\n            if idx == pos[i]:\n                i += 1\n                res.append(0)\n                continue\n            res.append(min(pos[i]-idx, idx-pos[i-1]))\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992696272","body":"```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.lst = []\r\n        self.idx = 0\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.idx < self.maxSize:\r\n            self.idx += 1\r\n            self.lst.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.idx == 0:\r\n            return -1\r\n        self.idx -= 1\r\n        return self.lst.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.lst))):\r\n            self.lst[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994837592","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        res = ''\r\n        stack = []\r\n        for char in s:\r\n            if char == ']':\r\n                strings = ''\r\n                while stack:\r\n                    temp = stack.pop()\r\n                    if temp != '[':\r\n                        strings = temp + strings\r\n                    else:\r\n                        break\r\n                num = ''\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop() + num\r\n                stack.append(int(num) * strings)\r\n            else:\r\n                stack.append(char)\r\n        for item in stack:\r\n            res += item\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991984254","body":"# Idea: \r\nWe can set a left pointer pointing to the left occurrence of the character c and set a right pointer pointing to the right occurrence of the character c. Then we iterate the array, for each element we encountered, we check the distance between itself and the left pointer and also check the distance between itself and the right pointer. The minimum one of those two distances will be the result for the current character. \r\n\r\n# Code: \r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 0)\r\n        res = [0 for _ in range(n)]\r\n        \r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            \r\n            if i == r:\r\n                l = r \r\n                r = s.find(c, l + 1)\r\n                \r\n        \r\n        return res\r\n\r\n```\r\n# Complexity\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992935560","body":"# Idea: \r\nUse the python list to simulate stack. The only feature we need to add is to increase last k elements by val. \r\n\r\n# Code: \r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.array = []\r\n        self.n = maxSize \r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.array) < self.n: \r\n            self.array.append(x)\r\n        \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.array:\r\n            return -1\r\n        return self.array.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = min(k, len(self.array))\r\n        \r\n        for i in range(length):\r\n            self.array[i] += val\r\n        \r\n```\r\n# Complexity\r\nTime:  Push: O(1) Pop: O(1) Increment: O(min(k, n))\r\nSpace: O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994269395","body":"# Idea:\r\n括号匹配。\r\n# Code\r\n```python\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] codepoint = s.toCharArray();\r\n        int number = 0;\r\n        Stack<Object> stack = new Stack<>();\r\n        for (int i = 0; i < codepoint.length; i++) {\r\n            char code = codepoint[i];\r\n            if (Character.isDigit(code)) {\r\n                number = 10 * number + (code - '0');\r\n            } else if (code == '[') {\r\n                stack.push(number);\r\n                number = 0;\r\n            } else if (code == ']') {\r\n                String reversedString = stackReverse(stack);\r\n                int times = (int) stack.pop();\r\n                String repeatReversed = reversedString.repeat(times);\r\n                stack.push(repeatReversed);\r\n            } else {\r\n                stack.push(String.valueOf(code));\r\n            }\r\n        }\r\n        return stackReverse(stack);\r\n    }\r\n    \r\n    public String stackReverse(Stack<Object> stack) {\r\n        Stack<Object> reversedStack = new Stack<>();\r\n        while (!stack.isEmpty() && (stack.peek() instanceof String)) {\r\n            reversedStack.push(stack.pop());\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while (!reversedStack.isEmpty()) {\r\n            res.append(reversedStack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995866804","body":"# Idea:\r\nWe create two stacks. First stack called \"pushStack\" is only used for \"push\" operation of the queue and the second stack called \"popStack\" is used for \"pop\"/\"peek\" operation of the queue. Whenever we need to pop or peek an element from the queue, we pop an element from the \"popStack\" stack if not empty. Otherwise, we push all the elements from \"pushStack\" onto \"popStack\". \r\n\r\n# Code\r\n```python\r\nclass MyQueue(object):\r\n\r\n    \"\"\"\r\n    Queue is fifo stack is lifo\r\n    \r\n    [1, 2, 3]\r\n    [3, 2, 1]\r\n    \r\n    [4] -> push\r\n    [3,2,1] -> peak and pop\r\n    if not queue:\r\n        push elem from first stack to sec\r\n    else:\r\n        pop or peek from the other    \r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.pushStack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        return self.popStack.pop()\r\n            \r\n            \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        print(self.pushStack)\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        print(self.popStack)\r\n        return self.popStack[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.pushStack) == 0 and len(self.popStack) == 0\r\n```\r\n# Complexity\r\nTime: push: O(1) pop: amortized O(1) since the only case that takes O(n) time is when the \"popStack\" is empty, which won't happen quite often. \r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997218989","body":"```python\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n\r\npublic class Solution {\r\n    /**\r\n     * @param head: the List\r\n     * @param k: rotate to the right k places\r\n     * @return: the list after rotation\r\n     */\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // write your code here\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        ListNode tail = null;\r\n        ListNode cur = head;\r\n        int len = 0;\r\n        /** Calculate the length of list and the pointer of tail. */\r\n        while (cur != null) {\r\n            if (cur.next == null) {\r\n                tail = cur;\r\n            }\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n\r\n        int numToRotate = k % len;\r\n        if (numToRotate == 0) {\r\n            return head;\r\n        }\r\n        ListNode iter = head;\r\n        ListNode prev = null;\r\n        int numIterForCur = len - numToRotate;\r\n        int numIterForPrev = numIterForCur - 1;\r\n        for (int i = 0; i < numIterForCur; i++) {\r\n            if (i == numIterForPrev) {\r\n                prev = iter;\r\n            }\r\n            iter = iter.next;\r\n        }\r\n        tail.next = head;\r\n        prev.next = null;\r\n\r\n        return iter;\r\n\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998318452","body":"```python \r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        pA = headA \r\n        pB = headB \r\n        \r\n        while pA != None or pB != None:\r\n            if pA == pB: \r\n                return pA \r\n            \r\n            if pA == None: \r\n                pA = headB \r\n            else: \r\n                pA = pA.next \r\n            \r\n            if pB == None: \r\n                pB = headA \r\n            else: \r\n                pB = pB.next \r\n        \r\n        \r\n            \r\n        return None\r\n            \r\n            \r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001091233","body":"```java\r\npublic class Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return sumNumbers(root, 0);\r\n    }\r\n    \r\n    private int sumNumbers(TreeNode root, int sum){\r\n        if(root == null) return 0;\r\n        if(root.left == null && root.right == null)\r\n            return sum + root.val;\r\n        \r\n        return sumNumbers(root.left, (sum + root.val) * 10) + sumNumbers(root.right, (sum + root.val) * 10);\r\n        \r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moirobinzhang":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991989214","body":"思路：\n从前往后 以及 从后往前两次遍历\n第一次遍历result[i]记录i位置字符与前一个c的距离\n第二次遍历result[i]比较Min(result[i], i位置字符和后一个c的距离）\n\n代码：\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = []\n        \n        flag_index = len(s) - 1        \n        for i in range(len(s)):\n            if (s[i] == c):\n                flag_index = i\n            result.append(abs(flag_index - i))\n                       \n        flag_index = 0\n        for i in range(len(s) -1, -1, -1):\n            if (s[i] == c):\n                flag_index = i\n            result[i] = min(result[i], abs(flag_index - i ))\n        \n        return result\n\n复杂度分析:\n时间复杂度O（N）\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992923831","body":"Idea:\nUse List to simulate Stack\n\nCode:\n\npublic class CustomStack {\n\n    public List<int> cList {get; set;}\n    public int maxCount {get; set;}\n    \n    public CustomStack(int maxSize) {\n        cList = new List<int>();\n        maxCount = maxSize;        \n    }\n    \n    public void Push(int x) {\n        if (cList.Count >= maxCount)\n            return;\n        \n        cList.Add(x);\n    }\n    \n    public int Pop() {\n        if (cList == null || cList.Count == 0)\n            return -1;\n        \n        int popValue = cList[cList.Count - 1];\n        cList.RemoveAt(cList.Count - 1);\n        return popValue;\n    }\n    \n    public void Increment(int k, int val) {\n        if (cList == null || cList.Count == 0)\n            return;\n        \n        int len = cList.Count >= k ? k : cList.Count;\n        \n        for (int i = 0; i < len ; i++)\n            cList[i] += val;\n    }\n}\n\n\nComplexity\nT: Push: O(1), Pop: O(1), Increment: O(N)\nS: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994737531","body":"思路: \n用两个栈分别存放数字和字符串\n\n分析：\n    def decodeString(self, s: str) -> str:\n        numStack = []\n        strStack = []\n        num = 0;\n        result = ''\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                strStack.append(result)\n                result = ''\n                numStack.append(num)\n                num = 0\n            elif c == ']':\n                times = numStack.pop()\n                result = strStack.pop() + result * times\n            else:\n                result += c  \n        \n        return result\n\n复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995347777","body":"class MyQueue:\n\n    def __init__(self):\n        self.stack_input = []\n        self.stack_output = []               \n\n    def push(self, x: int) -> None:\n        self.stack_input.append(x)        \n\n    def pop(self) -> int:\n        if len(self.stack_output) == 0:\n            while self.stack_input:\n                self.stack_output.append(self.stack_input.pop())\n        return self.stack_output.pop()         \n\n    def peek(self) -> int:\n        if not len(self.stack_output) == 0 :\n            return self.stack_output[-1]\n        return self.stack_input[0]\n\n    def empty(self) -> bool:\n        return len(self.stack_input) == 0 and len(self.stack_output) == 0","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996371748","body":"        Stack<int> monoStack = new Stack<int>();\n        \n        for (int i = 0; i < arr.Length; i++)\n        {\n            if (monoStack.Count() > 0 && monoStack.Peek() > arr[i])\n            {\n                int currentVal = monoStack.Pop();\n                \n                while (monoStack.Count() > 0 && monoStack.Peek() > arr[i] )\n                    monoStack.Pop();\n                \n                monoStack.Push(currentVal);\n            }\n            else \n            {\n                monoStack.Push(arr[i]);\n            }\n            \n        }\n        \n        return monoStack.Count(); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997201311","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        \n        fastNode = head\n        slowNode = head\n        len = 0\n        \n        while fastNode:\n            fastNode = fastNode.next \n            len += 1\n        \n        fastNode = head\n        k = k % len\n        \n        while k > 0:\n            fastNode = fastNode.next \n            k -= 1\n            \n        while fastNode.next:\n            fastNode = fastNode.next \n            slowNode = slowNode.next\n            \n        fastNode.next = head\n        newHead = slowNode.next\n        slowNode.next = None\n        \n        return newHead","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997387783","body":"public ListNode SwapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        \n        ListNode newHead = head.next;\n\n        ListNode preNode = new ListNode(0);\n        preNode.next = head;\n        \n        ListNode firstNode = head;\n        ListNode secondNode =  new ListNode(0);\n        \n        ListNode nextNode =  new ListNode(0);\n        \n        while(firstNode != null && firstNode.next != null)\n        {\n            nextNode = firstNode.next.next;\n            secondNode = firstNode.next;\n            \n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n            \n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        \n        return newHead;       \n        \n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997492584","body":"Code:\n\npublic class Solution {\n    public TreeNode SortedListToBST(ListNode head) {\n        if (head == null)\n            return null;\n            \n        return DFS(head, null);\n    }\n    \n    public TreeNode DFS(ListNode head, ListNode tail)\n    {\n        if (head == tail)\n            return null;\n        \n        ListNode fastNode = head;\n        ListNode slowNode = head;\n        \n        while(fastNode != tail && fastNode.next != tail)\n        {\n            fastNode = fastNode.next.next;\n            slowNode = slowNode.next;\n        }\n        \n        TreeNode currentRoot = new TreeNode(slowNode.val);\n        currentRoot.left = DFS(head, slowNode);\n        currentRoot.right = DFS(slowNode.next, tail);\n        \n        return currentRoot;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998732318","body":"思路：\n\n代码：    \ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        node_set = set()\n        while headB:\n            node_set.add(headB)\n            headB = headB.next\n        \n        while headA:\n            if headA in node_set:\n                return headA\n            headA = headA.next\n        \n        return None\n\n复杂度：\n时间复杂度：O（n）\n空间复杂度：O（m）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999203288","body":"Code:\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        visited = set()\n        \n        cursor_node = head\n        while cursor_node is not None:\n            if cursor_node in visited:\n                return cursor_node\n            else:\n                visited.add(cursor_node)\n                cursor_node = cursor_node.next\n        \n        return None\n\nComplexity:\nTime Complexity: O(N)\nSpace Complexity: O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000836196","body":"Idea\nDFS\n\n\nCode\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.right), self.maxDepth(root.left)) + 1\n\n\nComplexity\nTime: O(n);\nSpace: O(height);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000901690","body":"Idea:\nRecursion\n\nCode:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p is None and q is None:\n            return True\n        \n        if p is None or q is None:\n            return False\n        \n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\nComplexity\nSpace: O(n) \nTime: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001081805","body":" \n   def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, cur):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return cur * 10 + root.val\n            \n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n            \n            \n        return dfs(root, 0)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"declan92":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992054950","body":"## 思路\n最短距离->两个值之间较小值\n1. 关键字将数组分成n段子数组,子数组最小索引最大索引均为关键字,且中间无关键字;\n2. 最短距离是距离最小索引和最大索引中的较小值\n3. 从左往右遍历得出距离左边关键字距离,从右往左遍历得出距离右边关键字的距离并比较两者大小\n4. 由于 1 <= s.length <= 10000,左指针初始值可以设置为Integer.MIN_VALUE+10000,不然会超过int范围;\n## java\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int leftPos = Integer.MIN_VALUE + 10000;\n        for(int i = 0;i < s.length(); i++){\n            if(s.charAt(i)==c){\n                leftPos = i;\n            }\n            ans[i] = i - leftPos;\n        }\n        int rightPos = Integer.MAX_VALUE;\n        for(int i = s.length() - 1;i >=0;--i){\n            if(s.charAt(i)==c){\n                rightPos = i;\n            }\n            ans[i] = Math.min(rightPos - i,ans[i]);\n        }\n        return ans;\n    }\n}\n```\n## 复杂度\n时间:O(n),n为数组长度;    \n空间:O(n),ans[]长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993038951","body":"思路\n1. 使用数组实现,第一位的值保存栈顶位置指针,数组尾部为栈顶;\n2. 初始化:数组长度maxSize+1,ans[0] = 0,size = maxSize;\n3. push(val):数组尾部增加值,栈顶指针++;\n4. pop():数组尾部弹出值,栈顶指针--;\njava\n```\nclass CustomStack {\n    private int[] ans;\n    private size;\n\n    public CustomStack(int maxSize) {\n        ans = new int[maxSize+1];\n        size = maxSize;\n        ans[0] = 0;\n    }\n    \n    public void push(int x) {\n        if(ans[0] < size){\n            ans[++ans[0]] = x;\n        }\n    }\n    \n    public int pop() {\n        if(ans[0] > 0){\n            int res = ans[ans[0]];\n            ans[ans[0]--] = 0;\n            return res;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(ans[0],k);\n        for(int i = 1;i <= min; i++){\n            ans[i] = ans[i] + val;\n        }\n    }\n}\n```\n复杂度:      \n时间:Custom(int maxSize): O(1); push(int x):O(1);  pop():O(1); increment(int k, int val):O(n),n为栈深;      \n额外空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994510397","body":"思路:  \n栈\n1. 遍历原始字符串s；\n2. 如果是数字，则将数字拼接然后入栈；\n3. 如果是字符或者[直接入栈;\n4. 如果是],则一直获取到[之间的元素从后向前拼接成字符串,[出栈后,再次出栈一定是数字;\n5. 第4步骤获取到数字和字符串循环拼接成字符串,然后入栈;\n6. 遍历栈,头插法录入元素转换成字符串;  \njava\n```\nclass Solution {\n    private int pointer;\n    public String decodeString(String s) {\n        pointer = 0;\n        Stack<String> ansStack = new Stack<String>();\n        while(pointer<s.length()){\n            char c = s.charAt(pointer);\n            if(Character.isDigit(c)){\n                StringBuffer buffer = new StringBuffer();\n                buffer.append(Character.toString(c));\n                while(Character.isDigit(s.charAt(++pointer))){\n                    buffer.append(Character.toString(s.charAt(pointer)));\n                }\n                ansStack.push(buffer.toString());\n            }else if(Character.isLetter(c) || c == '['){\n                ansStack.push(Character.toString(c));\n                pointer++;\n            }else{\n                Stack<String> subStack = new Stack<String>();\n                while(true){\n                    if(ansStack.peek().equals(\"[\")){\n                        ansStack.pop();\n                        break;\n                    }else{\n                        subStack.push(ansStack.pop());\n                    }\n                }\n                int num = Integer.valueOf(ansStack.pop());\n                StringBuffer buffer = new StringBuffer();\n                while(!subStack.isEmpty()){\n                    buffer.append(subStack.pop());\n                }\n                StringBuffer buffer1 = new StringBuffer();\n                for(int i = 0;i < num;i++){\n                    buffer1.append(buffer.toString());\n                }\n                ansStack.push(buffer1.toString());\n                pointer++;\n            }\n        }\n        List<String> ans = new LinkedList();\n        while(!ansStack.isEmpty()){\n            ans.add(0,ansStack.pop());\n        }\n        return String.join(\"\",ans);\n    }\n}\n```\n时间:O(m+n);m为字符串s长度,n为所有[]长度和;  \n空间:O(m);m为字符串s长度;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995323236","body":"关键字:\n两个栈、实现队列、总操作时间复杂度为O(n);  \n思路:\n1. 队列push操作,全部元素push栈1;\n2. 队列pop操作,如果栈2没有元素,将栈1元素全部pop,然后push至栈2;\n3. 如果栈2有元素,直接pop栈2;\n4. 队列peek操作的实现类似pop;\n5. 队列empty,栈1和栈2同为空则队列空,否则非空;\njava\n```\nclass MyQueue {\n    Stack<Integer> stackIn;\n    Stack<Integer> stackOut;\n    public MyQueue() {\n         stackIn = new Stack();\n         stackOut = new Stack();\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {\n        if(empty()){\n            return -1;\n        }\n        if(!stackOut.empty()){\n            return stackOut.pop();\n        }\n        while(!stackIn.empty()){\n            stackOut.push(stackIn.pop());\n        }\n        return stackOut.pop();\n    }\n    \n    public int peek() {\n        if(empty()){\n            return -1;\n        }\n        if(!stackOut.empty()){\n            return stackOut.peek();\n        }\n        while(!stackIn.empty()){\n            stackOut.push(stackIn.pop());\n        }\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        if(stackIn.empty() && stackOut.empty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n时间:O(n),n为队列长度;队列pop()与peek()获取的元素,全部是从栈1pop,然后push进栈2,一个元素发生一次,n个元素时间复杂度为O(n);  \n额外空间:O(1);\n错误:\npeek()操作没写return","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996801651","body":"思路:\n从左往右同时遍历两个数组时,计数信息一致,则可以分块;\n遍历过程中计数信息一致的次数,为最多可分块数;\njava\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int ans = 0;\n        int count = 0;\n        Map<Integer,Integer> map = new HashMap();\n        int[] arrSort = arr.clone();\n        Array.sort(arrSort);\n        for(int i = 0;i < arr.length;i++){\n            int x = arr[i];\n            int y = arrSort[i];\n            map.put(x,map.getOrDefault(x,0)+1);\n            if(map.get(x) == 0){\n                count--;\n            }\n            if(map.get(x) ==1){\n                count++;\n            }\n            map.put(y,map.getOrDefault(y,0)-1);\n            if(map.get(y) == 0){\n                count--;\n            }\n            if(map.get(y) == -1){\n                count++;\n            }\n            if(count == 0){\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```\n时间:O(nlogn),瓶颈在排序\n空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997214338","body":"思路\n链表长度为n，新链表最后结点的位置（n - 1）-（k % n）;  \n步骤\n1. 遍历链表,求出链表长度,并将尾结点指向头结点形成环;\n2. 遍历到n - 1）-（k % n）结点位置,将环链表断开,得出所求结果;\n3. 链表长度小于等于1和k是n的整数倍数。\njava\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n时间：0（n），n为链表长度；  \n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997974317","body":"思路：\n获取中间结点，左右两颗子树也是升序，分治递归\n1. 使用快慢指针，获取中间结点；\n2. 中间结点赋值根节点；\n3. 左边链表递归，结果赋值左节点，右边链表递归赋值右节点\n4. 当其中一个子链表为null时，赋值然后返回\njava\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}。\n```\n时间：O(nlogn);空间:O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998567875","body":"思路:\n1. 遍历linkedListA，将所有结点保存在hashSet中；\n2. 遍历linkedListB，判断hashSet是否存在，如果存在则为相交点；\njava\n```\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> set = new HashSet();\n        while(headA!=null){\n            set.add(headA);\n            headA = headA.next;\n        }\n        while(headB!=null){\n            if(set.contains(headB)){\n                return headB;\n            }\n            headB = headB.next;\n        }\n        return null;\n    }\n}\n```\n时间: O(m+n);m为链表A长度,n为链表B长度.   \n空间:O(m);m为链表A长度.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999327094","body":"思路:\n1. fast指针从head结点一次移动两步,slow指针一次移动一步;\n2. fast与slow第一次相遇后,fast指针移动到head,然后fast每次向后移动一步;\n3. fast指针与slow第二次相遇点一定是环的起点;  \njava\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null || head.next.next == null){\n            return null;\n        }\n        ListNode fast = head.next.next;\n        ListNode slow = head.next;\n        while(fast!=slow){\n            if(slow == null || fast.next == null || fast.next.next == null){\n                return null;\n            }\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        fast = head;\n        while(fast!=slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n时间:O(n),n为链表结点数  \n空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000188631","body":"思路：  \nLRU，需要频繁增删使用链表  \nget操作O(1)，使用hash结构，value保存链表的节点地址  \n最终使用双向链表+哈希表  \n步骤：\n1. 初始化时，初始化hashMap、链表、capacity、size;\n2. get（int key）\n    1. 如果hashMap中存在key，返回链表结点的值，并且将结点移动到头部位置；\n    2. 如果hashMap不存在key，返回null；\n3. put(int key ,int value)\n    1. 如果hashMap关键字存在key,改变链表节点的值;\n    2. 如果hashMap中不存在key;\n        1. size<capacity,创建新节点赋值value,插入到链表头部位置;\n        2. size>=capacity,删除尾部结点,创建新节点赋值value,插入链表头部位置;\n    3. 将结点插入到头部位置;  \njava\n```\nclass LRUCache {\n    int size;\n    int capacity;\n    ListNode head;\n    ListNode tail;\n    Map<Integer, ListNode> map;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        size = 0;\n        head = null;\n        tail = null;\n        map = new HashMap();\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            ListNode node = map.get(key);\n            deleteNode(node);\n            addFirst(node);\n            return node.val;\n        } else {\n            return -1;\n        }\n    }\n\n    public void put(int key, int value) {\n        ListNode node;\n        if (map.containsKey(key)) {\n            node = map.get(key);\n            node.val = value;\n            deleteNode(node);\n        } else {\n            node = new ListNode(key, value);\n            map.put(key, node);\n            if (size == capacity) {\n                ListNode deleteTail = deleteTail();\n                map.remove(deleteTail.key);\n            }\n        }\n        addFirst(node);\n    }\n\n    protected void deleteNode(ListNode node) {\n        if (node == null || size == 0) {\n            return;\n        }\n        if (size == 1) {\n            head = null;\n            tail = null;\n            size--;\n            return;\n        }\n        if (node.pre == null) {\n            //删除头结点\n            head = node.next;\n            node.next = null;\n            head.pre = null;\n        } else if (node.next == null) {\n            //删除尾结点\n            tail = node.pre;\n            node.pre = null;\n            tail.next = null;\n        } else {\n            //删除中间结点\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n            node.next = null;\n            node.pre = null;\n        }\n        size--;\n    }\n\n    protected void addFirst(ListNode node) {\n        if (node == null) {\n            return;\n        }\n        if (head != null) {\n            node.next = head;\n            head.pre = node;\n        }\n        head = node;\n        if (tail == null) {\n            tail = node;\n        }\n        size++;\n    }\n\n    protected ListNode deleteTail() {\n        ListNode result;\n        if (size == 1) {\n            result = tail;\n            tail = null;\n        } else {\n            result = tail;\n            ListNode temp = tail;\n            tail = temp.pre;\n            temp.pre.next = null;\n            temp.pre = null;\n            temp = null;\n        }\n        size--;\n        return result;\n    }\n\n    class ListNode {\n        int key;\n        int val;\n        ListNode pre;\n        ListNode next;\n\n        ListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n            pre = null;\n            next = null;\n        }\n    }\n}\n```\n时间：O(1);  \n空间:O(n),n为容量;","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001016322","body":"思路：  \n树相同->即根节点相同+左子树相同+右子树相同；  \n步骤：  \n1. 判断p,q结点值是否相同\n2. 不同则返回false;\n3. 相同则将p左子树与q左子树,p右子树与q右子树递归\n4. 两个值都为true,则为TRUE  \njava\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        }else if(p!=null&&q!=null){\n            if(p.val != q.val){\n                return false;\n            }\n            if(isSameTree(p.left,q.left) && isSameTree(p.right,q.right)){\n                return true;\n            }else{\n                return false;\n            }\n        }else{\n            return false;\n        }\n    }\n}\n```\n时间:O(min(m,n)),m,n分别为树的结点数;  \n空间:O(min(m,n)),最坏情况树的高度等于结点数;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiaqiliu37":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992127456","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float(\"-inf\")\n        ans = []\n        for i, char in enumerate(s):\n            if char == c:\n                prev = i\n            ans.append(i - prev)\n        \n        prev = float(\"inf\")\n        for i in range(len(s) -1, -1, -1): \n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev-i)\n            \n        return ans\n```\nTC：O(N)\nSC:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993158786","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else: \n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            self.stack[i] += val\n```\nTime complexity Increment O(n) Others O(1)\nSpace complexity O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994275538","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] != ']':\n                stack.append(s[i])\n            else:\n                repeatstr = \"\"\n                while stack[-1].isalpha():\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                repeatcount = \"\"\n    \n                while stack and stack[-1].isnumeric():\n                    repeatcount = stack.pop() + repeatcount\n                count = int(repeatcount)\n                stack.append(count * repeatstr)\n                \n        return \"\".join(stack)\n```\nTime complexity O(n)\nSpace complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995511833","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n            \n        frontpop = 0\n        frontpop = self.stack2.pop()\n        \n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n            \n        return frontpop\n\n    def peek(self) -> int:\n        while self.stack1 != []:\n            self.stack2.append(self.stack1.pop())\n            \n        frontremove = 0\n        frontremove = self.stack2[-1]\n        \n        while self.stack2 != []:\n            self.stack1.append(self.stack2.pop())\n            \n        return frontremove\n\n    def empty(self) -> bool:\n        if self.stack1 == []:\n            return True\n        else: return False\n```\nTime complexity Push Empty O(1), Pop Peek O(n)\nSpace complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996412300","body":"```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and stack[-1] > num:\n                curr_block_max = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(curr_block_max)\n            else:\n                stack.append(num)\n                \n        return len(stack)\n            \n        \n        '''\n        ans = sum1 = sum2 = 0\n        for a,b in zip(arr, sorted(arr)):\n            sum1 += a\n            sum2 += b\n            ans += (sum1 == sum2)\n        return ans\n        '''\n        \n        '''\n        ans = 0\n        arr_sorted = sorted(arr)\n        for k in range(len(arr)):\n            ans += (sorted(arr[:k]) == arr_sorted[:k])\n        \n        return ans\n        '''\n        \n        '''\n        count_1 = defaultdict(int)\n        count_2 = defaultdict(int)\n        ans = 0\n        for a,b in zip(arr, sorted(arr)):\n            count_1[a] += 1\n            count_2[b] += 1\n            ans += count_1 == count_2\n        \n        return ans\n        '''\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997167469","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n    \n        curr = head\n        length = 0\n        while curr.next:\n            curr = curr.next\n            length += 1\n            \n        length += 1\n        \n        k_real = k % length\n        new_tail = head\n        curr.next = head\n        times = length - k_real -1\n        \n        while times:\n            new_tail = new_tail.next\n            times -= 1\n            \n            \n        new_head = new_tail.next\n        new_tail.next = None\n        \n        return new_head\n        \n       ```\nTime complexity O(n)\nSpace complexity O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998515883","body":"```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        '''\n        hashset = set()\n        pointA = headA\n        while pointA:\n            hashset.add(pointA)\n            pointA = pointA.next\n        \n        pointB = headB\n            \n        while pointB:\n            if pointB in hashset:\n                return pointB\n            else:\n                pointB = pointB.next\n                \n        return None\n        '''\n        pointA, pointB = headA, headB\n        \n        while pointA != pointB:\n            if pointA == pointB == None:\n                return None\n            if pointA == None:\n                pointA = headB\n            else: \n                pointA = pointA.next\n            if pointB == None:\n                pointB = headA\n            else:\n                pointB = pointB.next\n                \n        return pointA\n```\n\nHashset method: \nTime complexity O(n) \nSpace complexity O(n)\nTwo pointers method: \nTime complexity O(n) \nSpace complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999330207","body":"```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        '''\n        hashset = set()\n        point = head\n        while point and point not in hashset:\n            hashset.add(point)\n            point = point.next\n            \n        return point\n        '''\n        if head == None or head.next == None:\n            return None\n        \n        fast = head.next.next\n        slow = head.next\n        \n        while fast != slow:\n            if fast == None or fast.next == None:\n                return None\n            fast = fast.next.next\n            slow = slow.next\n            \n        fast = head\n            \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n            \n        return fast\n```\nHashset method: \nTime complexity O(n)\nSpace complexity O(n)\nTwo pointers method:\nTime complexity O(n)\nSpace complexity O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000111776","body":"```\nclass DLinkedNode:\n    def __init__(self,key=0, value =0):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.capacity = capacity\n        self.size = 0\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        \n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def addtohead(self, node):\n        nxt = self.head.next\n        self.head.next = node\n        nxt.prev = node\n        node.prev = self.head\n        node.next = nxt\n        \n    def removenode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def movetohead(self, node):\n        self.removenode(node)\n        self.addtohead(node)\n    \n    def removetail(self):\n        self.removenode(self.tail.prev)\n    \n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.movetohead(node)\n            return node.value\n        else:\n            return -1\n        \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.movetohead(node)\n        elif self.size < self.capacity:\n            node = DLinkedNode(key, value)\n            self.addtohead(node)\n            self.cache[key] = node\n            self.size +=1\n        else: \n            evict = self.tail.prev\n            self.removetail()\n            del self.cache[evict.key]\n            node = DLinkedNode(key, value)\n            self.addtohead(node)\n            self.cache[key] = node\n            \n            \n        \n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\nTime complexity O(1)\nSpace complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000662506","body":"Method 1\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = []\n        cur_length = max_length = 0\n        \n        if root:\n            stack.append([root, 1])\n            cur_length = 1\n            \n        while stack:\n            node, cur_length = stack.pop()\n            if node.left:\n                stack.append([node.left, cur_length + 1])\n                \n            if node.right:\n                stack.append([node.right, cur_length + 1])\n                \n            max_length = max(max_length, cur_length)\n            \n        return max_length\n        ```\nTime complexity O(n)\nSpace complexity O(n)\n\nMethod 2\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        \n        def dfs(node):\n            if node == None:\n                return 0\n            else: \n                ltreeh = dfs(node.left)\n                rtreeh = dfs(node.right)\n            return max(ltreeh, rtreeh) + 1\n                \n        return dfs(root)\n```\nTime complexity O(n)\nSpace complexity O(h), where h is the height of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000979495","body":"```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        '''\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        '''\n        \n        stack = []\n        stack.append((p,q))\n        \n        while stack:\n            node1, node2 = stack.pop()\n            if not node1 and not node2:\n                continue\n            if node1 and node2 and node1.val == node2.val:\n                stack.append((node1.left, node2.left))\n                stack.append((node1.right, node2.right))\n            else:\n                return False\n        \n        return True\n            \n```\nTime complexity O(n)\nSpace complexity\nMethod I O(h), h是树的高度\nMethod 2 O(Q), Q不会超过相邻两层结点的最大值","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yhccode1999":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992376691","body":"## 思路：\r\n\r\n- 先利用list集合储存 c 字符出现的位置；\r\n- 再判断 s 字符串中每个字符与所有 c 字符的距离，取最小值\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        Arrays.fill(res,10001);\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i=0;i<n;i++) {\r\n            if (s.charAt(i) == c) list.add(i);\r\n        }\r\n        int len = list.size();\r\n        for (int i=0;i<n;i++) {\r\n            for (int j=0;j<len;j++) {\r\n                res[i] = Math.min(res[i], Math.abs(i-list.get(j)));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n- 空间复杂度 O(n)\r\n- 时间复杂度 O(n2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993097849","body":"## 思路：用数组实现\r\n- nowIndex 代表当前元素的位置，-1 为栈空\r\n- maxSize 为栈最大，nowIndex == maxSize - 1 时，栈满\r\n- 每 push 一次，nowIndex 往后移动一位\r\n- 每 pop 一次，nowIndex 往前移动一位\r\n- increment 时，遍历 i 从 0 开始，需要满足 i < k && i <= nowIndex\r\n\r\n## java\r\n```java\r\nclass CustomStack {\r\n    int maxSize = 0;\r\n    int nowIndex = -1;\r\n    int[] arr;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (nowIndex == maxSize-1) {\r\n            return;\r\n        }\r\n        arr[++nowIndex] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (nowIndex == -1) {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i=0;i<k && i<=nowIndex;i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 \r\n- push O(1)\r\n- pop O(1)\r\n-  increment:O(k)最大O(n)\r\n2. 空间复杂度\r\n- O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994415761","body":"## 题目：\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 思路：\r\n> 注意，方括号有可能会嵌套，需要借助栈或者递归完成\r\n- 字符有四种情况\r\n1. 数字：则存起来 num (存在多位数情况)\r\n2. 左方括号：递归执行，并得到方括号内的字符串内容和与之对应的右方括号的位置，拼接 num 次得到字符串内容，并更新 index 位置\r\n3. 右方括号：返回当前的 str 字符串与当前右方括号的位置\r\n4. 字符：拼接到当前 str 的后面\r\n\r\n## Java 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n    public String[] dfs(String s, int index) {\r\n        StringBuilder str = new StringBuilder();\r\n        if (index >= s.length()) {\r\n            return new String[0];\r\n        }\r\n        int num = 0;\r\n        while(index < s.length()) {\r\n            if (s.charAt(index) >= '0' && s.charAt(index) <= '9') {\r\n                num = num * 10 + (int)(s.charAt(index) - '0');\r\n            }\r\n            else if (s.charAt(index) == '[') {\r\n                String[] temp = dfs(s, index+1);\r\n                index = Integer.valueOf(temp[1]);\r\n                while(num > 0) {\r\n                    str.append(temp[0]);\r\n                    num--;\r\n                }\r\n            }\r\n            else if (s.charAt(index) == ']') {\r\n                return new String[]{str.toString(), String.valueOf(index)};\r\n            }\r\n            else {\r\n                str.append(String.valueOf(s.charAt(index)));\r\n            }\r\n            index++;\r\n        }\r\n        return new String[]{str.toString(), \"\"};\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析：\r\n- 时间复杂度：O(n) 一次遍历\r\n- 空间复杂度：O(n) 递归栈\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995382314","body":"## 题目：\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 思路：\r\n- 前提：\r\n1. in 栈只存push的数据\r\n2. out 是 peek 和 pop 的栈\r\n- 做法：\r\n1. push 时，直接存 in 栈\r\n2. pop 和 peek 时需要判断 out 栈是否为空，如果为空，则把 in 栈的数据 pop 后再 push 进 out 栈中(栈是后进先出，经过两次压栈后就变成了先进先出)，在 out 栈中 peek 和 pop\r\n3. isEmpty 需要同时判断 in 和 out 栈是否为空\r\n\r\n## Java 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> in;\r\n    Stack<Integer> out;\r\n    public MyQueue() {\r\n        in = new Stack<>();\r\n        out = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (out.isEmpty()) {\r\n            int n = in.size();\r\n            for (int i=0;i<n;i++) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            int n = in.size();\r\n            for (int i=0;i<n;i++) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## 复杂度分析：\r\n- 时间复杂度：O(n) 一次遍历\r\n- 空间复杂度：O(n) 两个栈辅助存储\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996796929","body":"## 题目：\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 思路：\r\n- 前提：\r\n1. clone 是 arr 已经排好序的数组\r\n2. arr 是原始数组\r\n- 做法：\r\n1. 利用 count 记录当前的数字平衡\r\n2. 把 arr 中的数字往 map 中加，并且 count++;\r\n3. 把 clone 中的数字往 map 中取，并且 count--;\r\n4. 当 count == 0 时，代表平衡，可以构成排序块；\r\n\r\n\r\n## Java 代码\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] clone = arr.clone();\r\n        Arrays.sort(clone);\r\n        Map<Integer,Integer> map = new HashMap<>();\r\n        int count = 0, sum = 0;\r\n        for (int i=0;i<n;i++) \r\n        {\r\n            int ar = arr[i], cl = clone[i];\r\n            map.put(ar, map.getOrDefault(ar,0)+1);\r\n            if (map.get(ar) == 0) count--;\r\n            if (map.get(ar) == 1) count++;\r\n\r\n            map.put(cl, map.getOrDefault(cl,0)-1);\r\n            if (map.get(cl) == -1) count++;\r\n            if (map.get(cl) == 0) count--;\r\n\r\n            if (count == 0) sum++;\r\n        }\r\n        \r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析：\r\n- 时间复杂度：O(n*log(n)) 排序\r\n- 空间复杂度：O(n) 数组+map\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997201523","body":"## 题目：\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 思路：\r\n1. 先对链表进行求长度 n ，k = k % n，避免多余的移动；\r\n2. last 代表当前链表的最后一个节点，pre 代表 last 的前一个；\r\n3. 每次移动之前都需要满足第二点，移动的时候就把 pre.next = null, pre = last, last.next = head, head = last 及时更新头节点\r\n4. 返回 head 即可！\r\n\r\n## Java 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) return head;\r\n        ListNode last = head;\r\n        ListNode pre = null;\r\n        int n = 1;\r\n        while (last.next!=null){\r\n                pre = last;\r\n                last = last.next;\r\n                n++;\r\n        }\r\n        n = k % n ;\r\n        for (int i=0;i<n;i++){\r\n            while (last.next!=null){\r\n                pre = last;\r\n                last = last.next;\r\n            }\r\n            pre.next = null;\r\n            last.next = head;\r\n            head = last;\r\n        }\r\n\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度 O(n^(k%len)) len为链表长度\r\n- 空间复杂度 O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997372345","body":"## 题目\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/\r\n\r\n## 思路\r\n- 找到需要交换的两个节点，pre 代表该两个节点的前节点(head 节点需要构造一个前节点)\r\n- 交换两个节点，并更新两两节点和前节点\r\n- 如果后面没有两两节点则结束\r\n\r\n## Java 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) return head;\r\n        ListNode res = new ListNode(0, head);\r\n        ListNode frist = head, second = head.next, pre = res;\r\n        while (frist != null && second != null) {\r\n            pre.next = second;\r\n            frist.next = second.next;\r\n            second.next = frist;\r\n            \r\n            pre = frist;\r\n            frist = pre.next;\r\n            if (frist == null) break;\r\n            second = frist.next;\r\n        }\r\n        return res.next;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997605832","body":"## 题目\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 思路\r\n- 每次找到中间节点，以中间节点为跟节点，尽最大可能保证左右平衡，然后递归执行左边所有节点为左子节点，递归右边所有节点为右子节点。(需要注意的是，需要及时断中间节点与前一个节点的连接，不然会导致死循环)\r\n\r\n## Java 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val);\r\n        int n = 0;\r\n        ListNode temp = head;\r\n        while (temp != null) {\r\n            temp = temp.next;\r\n            n++;\r\n        }\r\n        n = n >> 1;\r\n        temp = head;\r\n        ListNode pre = head;\r\n        for (int i=0;i<n;i++) {\r\n            pre = temp;\r\n            temp = temp.next;\r\n        }\r\n        pre.next = null;\r\n        TreeNode root = new TreeNode(temp.val);\r\n        root.right = sortedListToBST(temp.next);\r\n        root.left = sortedListToBST(head);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(n log n)\r\n- 空间复杂度：O(log n) 递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998468867","body":"## 题目\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 思路\r\n- 先用一个 list 集合把 A 链表保存起来\r\n- 然后遍历 B 链表的时候同时判断 B 中的节点是否存在list集合中，如果存在直接返回该节点\r\n- 最后 没有交点 返回 null\r\n\r\n## java 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        List<ListNode> list = new ArrayList<>();\r\n        while (headA != null) {\r\n            list.add(headA);\r\n            headA = headA.next;\r\n        }\r\n        while (headB != null) {\r\n            if (list.contains(headB)) {\r\n                return headB;\r\n            }\r\n            headB = headB.next;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 空间复杂度：O(len(A)) A 链表长度\r\n- 时间复杂度：O(len(A)*len(B)) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999296336","body":"## 题目\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 思路\r\n- 用 set 保存每个节点，当有重复时就是交点了\r\n\r\n## Java 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        \r\n        ListNode fast = head, low = head;\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next != null && head.next.next == head) {\r\n            return head;\r\n        }\r\n        while (low != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            low = low.next;\r\n            if (fast == low) {\r\n                return fast.next;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)\r\n\r\n## 进阶\r\n- 快慢指针","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000769719","body":"## 题目\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree\r\n\r\n## 思路\r\n递归实现左右子树，每递归一次就判断当前深度与最大深度是否需要更新\r\n\r\n## Java代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    int max = 0;\r\n    public int maxDepth(TreeNode root) {\r\n        dfs(root, 0);\r\n        return max;\r\n    }\r\n    public void dfs(TreeNode root, int deep) {\r\n        if (root == null) {\r\n            return;\r\n        }\r\n        max = Math.max(max, deep+1);\r\n        dfs(root.left, deep+1);\r\n        dfs(root.right, deep+1);\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aobasyp":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992404415","body":"思路：\r\n先从前往后再从后往前两次遍历\r\ntmp记录c出现的位置\r\n第一次遍历从前往后,temp[i]存放s中i位置字符与前一个c的距离\r\n第二次从后往前遍历比较取较小的\r\n\r\n```\r\n`class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];      \r\n        int i = 0, j = s.length() - 1, tmp = -1;\r\n        while (i < s.length()) {\r\n            if (s.charAt(i) == c) {\r\n                ans[i] = 0;\r\n                tmp = i;\r\n            } \r\n            if (tmp != -1) {\r\n                ans[i] = i - tmp;\r\n            } else {\r\n                ans[i] = s.length() + 1;\r\n            }\r\n            \r\n            i++;\r\n        }\r\n        tmp = -1;\r\n        while (j >= 0) {\r\n            if (s.charAt(j) == c) {\r\n                ans[j] = 0;\r\n                tmp = j;\r\n            }\r\n            if (tmp != -1) ans[j] = Math.min(ans[j], tmp - j);\r\n            \r\n            j--;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}`\r\n```\r\n\r\n时间：O(N)\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993219442","body":"思路\n用一个数组\npush和pop需要注意边界\ninc 从栈底(数组0号)开始遍历，依次加上对应的val，注意 for 循环里的边界条件\n代码\n'''\nclass CustomStack {\n    int[] stack;\n    int maxSize;//数组最大长度\n    int curIndex;//当前数组下标\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        curIndex = -1;\n    }\n\n    public void push(int x) {\n        if (curIndex >= maxSize - 1) {\n            return;\n        }\n        curIndex++;\n        stack[curIndex] = x;\n    }\n\n    public int pop() {\n        if (curIndex < 0) {\n            return -1;\n        }\n        int resultValue = stack[curIndex];\n        curIndex--;\n        return resultValue;\n    }\n\n    public void increment(int k, int val) {\n        //栈底开始遍历\n        for (int index = 0; index < k && index <= curIndex; index++) {\n            stack[index] = stack[index] + val;\n        }\n    }\n}\n'''\n\n复杂度分析\n\npush：时间复杂度O(1) 空间复杂度O(1)\npop：时间复杂度O(1) 空间复杂度O(1)\ninc：时间复杂度O(N) 空间复杂度O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994224390","body":"思路\n\n使用两个栈，一个记录数，一个记录字符，\n当遇到数字是压人数字栈，\n遇到'[' 将'['前的字符串压人字母栈\n遇到']',弹出字符串以及数字，并相乘，接入之前的字符串。\n\n代码\n'''\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> stackInt = new Stack<>();\n        Stack<String> stackStr = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for(Character c : s.toCharArray()){\n            if(c>='0'&&c<='9'){\n                multi = multi*10 + Integer.parseInt(String.valueOf(c));\n            }else if (c=='['){\n                stackInt.push(multi);\n                stackStr.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }else if (c==']'){\n                int index = stackInt.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i = 0; i<index;i++){\n                    temp.append(res);\n                }\n                res = new StringBuilder(stackStr.pop()+temp);\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n\n    }\n}\n'''\n复杂度\n\n空间复杂度：O(N)\n\n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995370988","body":"思路：\n题目要求用栈的原生操作来实现队列，也就是说需要用到 pop 和 push 但是我们知道 pop 和 push 都是在栈顶的操作，\n而队列的 enque 和 deque 则是在队列的两端的操作，这么一看一个 stack 好像不太能完成，\n所以用两个队列\n\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<> ();\n    Stack<Integer> popStack = new Stack<> ();\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n复杂度分析\n时间复杂度：O(N)，\n空间复杂度：O(N)，","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996386018","body":"思路：\n用一个单调递增的栈，返回栈的元素个数即可\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i =0;i<arr.size();i++){\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if(!stack.empty()&&stack.top()>arr[i]){\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.top();\n                // 维持栈的单调递增\n                while(!stack.empty()&&stack.top()>arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }else{\n                stack.push(arr[i]);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n};\n\n时间：O(N)\n空间：O(N)，","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997126436","body":"思路:\n先计算单项链的长度n，并将链尾与链首相连，\n最后根据n和k的大小关系切断链表\n\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next) return head;\n\n        ListNode* p = head;\n        int n = 1;\n        while (p->next) {\n            p = p->next;\n            ++n;\n        }\n\n        int step = n - k % n;\n        // p points to the last node\n        p->next = head;\n\n        while(step--) {\n            head = head->next;\n            p = p->next;\n        }\n\n        p->next = nullptr;\n        return head;\n    }\n};\n\n复杂度分析:\n\n时间复杂度: O(n), \n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997323239","body":"思路\n迭代\n原始链表为 preA -> A -> B -> nextB，我们需要改为 preA -> B -> A -> nextB，\n接下来用同样的逻辑交换 nextB 以及 nextB 的下一个元素。\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head), res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head, secondNode, nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}\n\n时间复杂度：所有节点只遍历一遍，时间复杂度为O(N)O(N)\n空间复杂度：未使用额外的空间，空间复杂度O(1)O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997534158","body":"思路\n使用快慢双指针可定位中间元素\n\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null) return null;\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail) return null;\n      ListNode fast = head, slow = head;\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998511310","body":"思路\n使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    ListNode* pA = headA;\n    ListNode* pB = headB;\n    while (pA != pB) {\n        pA = pA == NULL ? headB : pA->next;\n        pB = pB == NULL ? headA : pB->next;\n    }\n\n    return pA;\n}\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999229381","body":"思路\n使用双指针的技巧来完成。\n\nListNode *detectCycle(ListNode *head) {\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            fast = head;\n            while (slow != fast) {\n                slow = slow->next;\n                fast = fast->next;\n            }\n            return slow;\n        }\n    }\n    return NULL;\n}\n\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000251181","body":"class LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n时间复杂度：O(1)。\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000809836","body":"思路:\n递归\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\n    }\n}\n时间复杂度：O(N)\n空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001004331","body":"思路:\n递归\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n\n时间复杂度：O(N)\n空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caohaha":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992410758","body":"```C++\r\nclass Solution \r\n{\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) \r\n    {\r\n        int n = s.size();\r\n\r\n        vector<int> res(n, n-1);\r\n        // 从左往右开始遍历\r\n        if(s[0] == c)\r\n            res[0] = 0;\r\n        for (int i = 1; i < n; i++)\r\n        {\r\n            if(s[i] != c)\r\n                res[i] = res[i-1]+1;\r\n            else\r\n                res[i] = 0;\r\n        }\r\n\r\n        // 从右往左开始遍历\r\n        if(s[n-1] == c)\r\n            res[n-1] = 0;\r\n        for (int i = n-2; i >= 0; --i)\r\n        {\r\n            res[i] = min(res[i], s[i] != c ? res[i+1] + 1 : 0);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994214499","body":"使用栈\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 一种是使用栈，另一种是使用递归\r\n        \"\"\"\r\n        使用栈，当遇到[时，将数字压入栈，并开始用cur_str记录括号中的字母，如果遇到]，就将之前的数字出栈并与当前\r\n        cur_str相乘\r\n        \"\"\"\r\n        mul,cur_str = 0,''\r\n        stack = []\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append((mul,cur_str))\r\n                mul,cur_str = 0,''\r\n            elif c == ']':\r\n                n,pre = stack.pop()\r\n                cur_str = pre + n*cur_str\r\n            elif '0'<= c <= '9':\r\n                mul = mul*10 + int(c)\r\n            else:\r\n                # 字母\r\n                cur_str += c\r\n        return cur_str\r\n```\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997224123","body":"```c++\r\n\r\nclass Solution \r\n{\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) \r\n    {\r\n        if(head == NULL || k==0)\r\n            return head;\r\n        ListNode * p = head;\r\n        ListNode * r = NULL;//尾指针\r\n        int len = 1;\r\n        while(p->next != NULL)\r\n        {\r\n            p = p->next;\r\n            len ++;\r\n        }\r\n        int dist = len - (k%len);\r\n        r = p;\r\n        p->next = head;\r\n        p = head;\r\n        for(int i=0;i<dist;i++)\r\n        {\r\n            p = p->next;\r\n            r = r->next;\r\n        }\r\n        r->next = NULL;\r\n        return p;\r\n    }\r\n\r\n};\r\n\r\n```\r\n- 时间复杂度O（n）\r\n- 空间复杂度O（1）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997218048","body":"- 递归实现\r\n- 时间复杂度O（n）\r\n- 空间复杂度O（n）\r\n```C++\r\n\r\nclass Solution\r\n {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) \r\n    {\r\n        //递归实现\r\n        if(head==NULL || head->next==NULL)\r\n            return head;\r\n        ListNode* node = head->next;\r\n        head->next = swapPairs(node->next);\r\n        node->next = head;\r\n        return node;\r\n    }\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999401256","body":"- 思路\n快慢指针\n- C++代码\n```C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution \n{\npublic:\n    ListNode *detectCycle(ListNode *head) \n    {\n        ListNode * fast = head;\n        ListNode * slow = head;\n        if(head == NULL || head->next == NULL)\n            return NULL;\n        bool isLoop = false;\n        //判断是否有环\n        while(fast != NULL && fast->next != NULL)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow == fast)\n            {\n                isLoop = true;\n                break;\n            }\n\n        }\n        if(!isLoop)\n            return NULL;\n        //找位置\n        slow = head;\n        while(fast != slow)\n        {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n```\n- 时间复杂度O(n)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000121645","body":"- 使用字典 按照题意即可\n```python\nfrom collections import OrderedDict as OD\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.od = OD()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.od:\n            self.od.move_to_end(key)\n        return self.od.get(key,-1)\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.od:\n            del self.od[key]\n        self.od[key] = value\n        if len(self.od) > self.capacity:\n            self.od.popitem(last = False)\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n- 时间复杂度O(1)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000686195","body":"#### 思路\n1. 深度优先遍历\n2. 宽度有线遍历\n#### Code\n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) \n    {\n        if(root == NULL)\n            return 0;\n        else\n            return max(maxDepth(root->left),maxDepth(root->right)) + 1;\n    }\n};\n```\n- 时间复杂度O(n)\n- 空间复杂度O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000953024","body":"#### 思路\n递归实现，\np q均为空节点，true\np q一空一非空 false\np q的值不相等 false\n递归遍历p的左子树与q的左子树 p的右子树与q的右子树是否相同\n#### C++实现\n```C++\nclass Solution \n{\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) \n    {\n        // base case\n        if(p==nullptr && q==nullptr)\n            return true;\n        else if(p==nullptr || q==nullptr)\n            return false;\n        else if(p->val != q->val)\n            return false;\n        // 递归\n        else\n            return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};\n```\n#### 复杂度分析\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992416737","body":"### 思路\n两边遍历，取当前位置与前一个C字符 prev之间的更新prev,取两次遍历后中较小的那个。\n\n### 代码\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function(S, C) {\n    let res = [];\n    let left = [];\n    let right = []\n    let prev = -Infinity;    \n    for (let i = 0; i < S.length; i++) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        left[i] = i - prev;\n    }\n    prev = Infinity;\n    for (let i = S.length - 1; i >= 0; i--) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        right[i] = prev -i;\n    }\n    for (let i  = 0; i < S.length;i ++) {\n        res[i] = Math.min(left[i],right[i])\n    }\n    return res;\n};\n```\n### 复杂度\n时间复杂度： O(n)  \n空间复杂度： O(n)  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993454527","body":"### 思路\n初始化栈，push,pop,直接使用数组自带的方法。increment中判断数组长度与k的大小，遍历，给对应位置，加上val.\n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.data = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.data.length < this.maxSize) {\n        this.data.push(x)\n    }\n};\n\n\nCustomStack.prototype.pop = function() {\n    if (this.data.length === 0) {\n        return -1   \n    } else {\n        return this.data.pop()\n    }\n\n    \n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k, this.data.length)\n    for(let i = 0;i < len ;i ++) {\n        this.data[i] = this.data[i] + val\n    }\n};\n\n```\n\n### 复杂度分析\n\n时间复杂度： O(N) --> increment()  \n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994716106","body":"\n### 思路：\n两个栈分别保存，数字和字符，遇到 ] 取出栈顶的数字和字符，计算内部子串，直至栈为空。  \n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let len = s.length\n    let stack1 = [] // 数字\n    let stack2 = [] // 字符\n    let num = 0\n    let result = ''\n    for (let i = 0; i < len; i ++) {\n       if (!isNaN(s[i])) {   \n            num = num * 10 + Number(s[i]); \n        } else if (s[i] == '[') {  \n            stack2.push(result); \n            result = '';         \n            stack1.push(num);   \n            num = 0;             \n        } else if (s[i] == ']') {  \n            let Times = stack1.pop(); \n            result = stack2.pop() + result.repeat(Times); \n        } else {                   \n            result += s[i];        \n        }\n    }\n    return result\n};\n```\n\n### 复杂度\n时间复杂度: O(N)  \n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995652519","body":"### 思路\n两个栈模拟队列，一个辅助栈处理pop，将栈中的元素pop出来，获取队头元素。\n\n### 代码\n```js\nvar MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\n\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n    \n};\n\nMyQueue.prototype.peek = function() {\n    return this.stack2[this.stack2.length-1] || this.stack1[0]\n};\n\nMyQueue.prototype.empty = function() {\n    return this.stack1.length === 0 && this.stack2.length === 0\n};\n```\n### 复杂度  \n时间复杂度： O(N) --> pop()  \n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996674709","body":"### 思路\n将原数组排序，对比排序数组和原数组，如果两个数组的前i项和相等，说明可以作为一个块。\n\n### 代码\n```js\nvar maxChunksToSorted = function (arr) {\n    let count = 0;\n    let sum1 = 0; // 存arr的前i项和\n    let sum2 = 0;\n    \n    const arrSort = [...arr].sort((a, b) => a - b);\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += arrSort[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n\n### 复杂度  \n时间复杂度： O(NlogN)  \n空间复杂度： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997197792","body":"### 思路\n快慢指针\n\n### 代码\n```js\nvar rotateRight = function(head, k) {\n    if(head === null ||head.next === null|| k === 0)return head; \n    let len = 0;\n    let head3 = head\n    let head2 = head\n    while(head2) {\n        len++\n        head2 = head2.next\n    }\n    let step = k % len\n    if (step == 0) return\n    let fast = head;\n    let slow = head\n    for(i = 0; i < step ; i ++) {\n        fast = fast.next\n    }\n    while(fast.next !=null) {\n        slow = slow.next\n        fast = fast.next\n    }\n    let res = slow.next\n    fast.next = head3\n    slow.next = null\n    return res\n};\n```\n### 复杂度分析  \n时间复杂度：O(N)  N为链表长度  \n空间复杂度：O(1) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997793652","body":"### 思路\n转成数组，构建BST  \n\n### 代码\n```js\nvar sortedListToBST = function(head) {\n    const arr = []\n    while(head) {\n        arr.push(head.val);\n        head = head.next;\n    }\n\n    function buildBST(start, end) {\n        if (start > end) return null;\n        const mid = (start + end) >>> 1;\n        const root = new TreeNode(arr[mid]); \n        root.left = buildBST(start,mid - 1);\n        root.right = buildBST(mid + 1, end);\n        return root;\n    }\n\n    return buildBST(0, arr.length-1)\n};\n```\n\n### 复杂度  \n时间复杂度：O(N)  \n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998665764","body":"### 思路\n双指针，分别遍历两个链表，到链表末尾的时候，连接到另外一个链表，相当于相同的速度，一样的路程，如果相遇，就是第一个相遇的点\n\n### 代码\n```js\nvar getIntersectionNode = function(headA, headB) {\n    if (headA == null || headB == null) {\n        return null;\n    }\n    let pA = headA;\n    let pB = headB;\n\n    while (pA != pB) {\n        pA = pA == null ? headB : pA.next;\n        pB = pB == null ? headA : pB.next;\n    }\n\n    return pA;\n};\n```\n### 复杂度\n\n时间复杂度：O(m+n) m,n分别为两个链表的长度  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999464394","body":"### 思路\n快慢指针，快块指针移动两步，慢指针移动一步，相遇之后，快指针变成头指针，然后每次快慢指针各走一步直到相遇，相遇的节点就是入环节点。\n\n### 代码\n```js\nvar detectCycle = function(head) {\n    let fast = head\n    let slow = head\n    while(fast&&fast.next) {\n        fast = fast.next.next\n        slow = slow.next\n        if (slow == fast) {\n            fast = head\n            while(slow!=fast) {\n                slow = slow.next\n                fast = fast.next     \n            }\n            return fast\n        }\n    }\n    return null\n}\n```\n\n### 复杂度分析 \n时间复杂度: O(N)  \n空间复杂度: O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000784143","body":"### 思路\n递归\n\n### 代码\n```js\nvar maxDepth = function(root) {\n    return root ? Math.max(maxDepth(root.left),maxDepth(root.right))+1 : 0\n};\n```\n### 复杂度 \n时间复杂度：O(N)   \n空间复杂度：O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001002035","body":"### 思路\nDFS\n\n### 代码\n```js\nvar isSameTree = function(p, q) {\n    if (!p && !q) return true\n    if (!p || !q) return false\n    if (p.val != q.val) return false\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n};\n```\n\n### 复杂度\n时间复杂度： O(N)  \n空间复杂度： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuhzyy":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992418103","body":"思路：\n1. 第一次遍历，从前往后遍历，记录距离列表1;   \n2. 第二次遍历，从后往前遍历，记录距离列表2;   \n3. 比较两个列表，取最小值即为所求答案。    \n\n代码\n\n\tclass Solution(object):\n\t\tdef shortestToChar(self, s, c):\n\t\t\t\"\"\"\n\t\t\t:type s: str\n\t\t\t:type c: str\n\t\t\t:rtype: List[int]\n\t\t\t\"\"\"\n\t\t\tprev = float('-inf')\n\t\t\tans = []\n\t\t\tfor i in range(len(s)):\n\t\t\t\tif s[i] == c:\n\t\t\t\t\tprev = i\n\t\t\t\tans.append(i-prev)\n\n\t\t\tprev = float('inf')\n\t\t\tfor i in range(len(s)-1,-1,-1):\n\t\t\t\tif s[i] == c:\n\t\t\t\t\tprev = i\n\t\t\t\tans[i] = min(ans[i], prev-i)\n\n\t\t\treturn ans\n\n时间复杂度: O(N)  \n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993306334","body":"### 思路\n通过数组来模拟构拟栈的操作\n\n\n### 代码\n\tclass CustomStack(object):\n\n\t\tdef __init__(self, maxSize):\n\t\t\t\"\"\"\n\t\t\t:type maxSize: int\n\t\t\t\"\"\"\n\t\t\tself.stack = []\n\t\t\tself.maxSize = maxSize\n\n\t\tdef push(self, x):\n\t\t\t\"\"\"\n\t\t\t:type x: int\n\t\t\t:rtype: None\n\t\t\t\"\"\"\n\t\t\tif len(self.stack) < self.maxSize:\n\t\t\t\tself.stack.append(x)\n\n\t\tdef pop(self):\n\t\t\t\"\"\"\n\t\t\t:rtype: int\n\t\t\t\"\"\"\n\t\t\tif len(self.stack) == 0:\n\t\t\t\tres = -1\n\t\t\telse: \n\t\t\t\tres = self.stack[-1]\n\t\t\t\tself.stack = self.stack[:-1]\n\t\t\treturn res\n\n\t\tdef increment(self, k, val):\n\t\t\t\"\"\"\n\t\t\t:type k: int\n\t\t\t:type val: int\n\t\t\t:rtype: None\n\t\t\t\"\"\"\n\t\t\tfor i in range(k):\n\t\t\t\tif i + 1 > len(self.stack):\n\t\t\t\t\tbreak\n\t\t\t\tself.stack[i] += val\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994531788","body":"### 思路\n\n借助栈来解决问题，如果不是']'就入栈，反之出栈，解析出str和num后生成字符串，并将生成字符串重新入栈。\n\n### 代码\n\tclass Solution(object):\n\t\tdef decodeString(self, s):\n\t\t\t\"\"\"\n\t\t\t:type s: str\n\t\t\t:rtype: str\n\t\t\t\"\"\"\n\t\t\tstack = []\n\t\t\tfor a in s:\n\t\t\t\tif a != ']':\n\t\t\t\t\tstack.append(a)\n\t\t\t\telse:\n\t\t\t\t\ttemp = ''\n\t\t\t\t\twhile (stack and stack[-1] != '['):\n\t\t\t\t\t\ttemp += stack.pop()\n\t\t\t\t\tstack.pop()\n\t\t\t\t\ttemp = temp[::-1]\n\n\t\t\t\t\tnums = []\n\t\t\t\t\twhile (stack):\n\t\t\t\t\t\tif '0' <= stack[-1] and stack[-1] <= '9':\n\t\t\t\t\t\t\tnums.append(stack.pop())\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tnums = nums[::-1]\n\t\t\t\t\tcounter = 0\n\t\t\t\t\tfor num in nums:\n\t\t\t\t\t\tcounter = counter * 10 + int(num)\n\t\t\t\t\tcounter = max(1,counter)\n\n\t\t\t\t\ttemp *= counter\n\t\t\t\t\tstack += temp\n\n\t\t\treturn ''.join(stack)\n\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995579371","body":"### 思路\n借用两个栈实现，stack1用于push，stack2用于pop和peek。\n\n### 代码\n\n```  \nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while(self.stack1):\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while(self.stack1):\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n```\n\n**复杂度分析**\n- 时间复杂度：push和empt为O(1)，pop和peek均摊O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996793367","body":"### 思路\n排序后的arr的前缀和与arr的前缀和相等时，结果+1\n\n\n### 代码\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        res = 0\n        prea = 0\n        preb = 0\n        for (a,b) in zip(arr, sorted(arr)):\n            prea += a\n            preb += b\n            if prea == preb:\n                res += 1    \n        return res\n```\n\n\n**复杂度分析**\n- 时间复杂度：O(Nlog(N))\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997705351","body":"### 思路\n中位数作为节点，中位数左边为左节点，右边为右节点。链表中位数通过快慢指针查找。\n\n\n### 代码\n```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n\n        def getMedian(left, right):\n            slow = left\n            fast = left\n            while(fast != right and fast.next != right):\n                slow = slow.next\n                fast = fast.next.next\n            return slow\n        \n        def buildTree(left, right):\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n\n        return buildTree(head, None)\n```\n\n\n**复杂度分析**\n- 时间复杂度：O(Nlog(N))\n- 空间复杂度：O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998528955","body":"### 思路\n通过哈系表存储A的节点，然后遍历B，判断nodeA是否等于nodeB\n\n### 代码\n```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        stack = set()\n        while(headA):\n            stack.add(headA)\n            headA = headA.next\n        while(headB):\n            if headB in stack:\n                return headB\n            else:\n                headB = headB.next\n        return None\n```\n\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999384189","body":"### 思路\n\n遍历链表并记录每个node，若new_node在记录表中，则是对应节点\n\n### 代码\n```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        data = set()\n        while(head):\n            if head in data:\n                return head\n            data.add(head)\n            head = head.next\n        return None\n```\n\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000631097","body":"### 思路\n\n树的层次遍历\n\n### 代码\n```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        from collections import deque\n\n        if not root:\n            return 0\n\n        res = 0\n        queue = deque()\n        queue.append(root)\n        while(queue):\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res += 1\n        return res\n```\n\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiao-xiao-meng-xiang-jia":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992455220","body":"int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995595846","body":"把一个栈当作输入栈，用于压入push传入的数据，另外一个当作输出栈，用于pop()和peek()操作。每次调用pop（）或者是peek（）时，如果输出栈不为空则输出顶部数据，如果为空则将输入栈的全部数据依次压入输出栈，这样就输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer>outStack;\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n    private void in2out(){\n        while(! inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n    }\n}\n时间复杂度：O(1);\n空间复杂度：O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996481261","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n时间复杂度: O(N \\log N)O(NlogN)\n空间复杂度: O(N)O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997708598","body":"思路：分治算法不断求出中中间点\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head ,null);\n    }\n    public TreeNode buildTree(ListNode left , ListNode right){\n        if(left == right){\n            return null;\n        }\n         ListNode mid = getMedian(left ,right);\n         TreeNode root = new TreeNode(mid.val);\n         root.left = buildTree(left ,mid);\n         root.right =buildTree(mid.next,right);\n         return root;\n    }\n    public ListNode getMedian(ListNode left , ListNode right){\n        ListNode fast = left;\n        ListNode slow =left;\n        while(fast !=right && fast.next !=right){\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998560282","body":"public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n       if(headA==null || headB==null){\n           return null;\n       }\n       ListNode p1=headA ,p2=headB;\n       while(p1 != p2){\n           p1 = p1==null ? headB : p1.next;\n           p2 = p2==null ? headA : p2.next; \n       }\n       return p1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999393283","body":"public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode pre = head;\n       Set<ListNode> temp = new HashSet<ListNode>();\n       while(pre !=null){\n           if( !temp.contains(pre)){\n               temp.add(pre);\n           }else{\n               return pre;\n           }\n           pre = pre.next;\n       }\n       return null;\n    }\n}\n时间复杂度：O(n);\n空间复杂度：O(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000122360","body":"public class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n时间复杂度O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000730843","body":"深度优先算法\nclass Solution {\n    public int maxDepth(TreeNode root) {\n       if(root == null ){\n           return 0;\n       } else{\n           int leftHeight = maxDepth(root.left);\n           int rightHeight = maxDepth(root.right);\n           return Math.max(leftHeight , rightHeight) +1;\n       }\n    }\n}\n时间复杂度：O（n）；\n空间复杂度：O(height)；","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biaohuazhou":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992513597","body":"###思路\n从前遍历并求出每个下标到目标的距离  再从后遍历\n最后比较两个遍历的最小值  \n###代码\n```JAVA\n    class Solution {\n        public int[] shortestToChar(String s, char c) {\n\n            int[] ans = new int[s.length()];\n            int tmp = -1;\n            //从前往后\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    ans[i] = 0;\n                    tmp = i;\n                }\n                if (tmp != -1) {\n                    ans[i] = i - tmp;\n                } else {\n                    ans[i] = s.length() + 1;\n                }\n            }\n            tmp = -1;\n            for (int j = s.length() - 1; j >= 0; j--) {\n                if (s.charAt(j) == c) {\n                    ans[j] = 0;\n                    tmp = j;\n                }\n                if (tmp != -1) {\n                    ans[j] = Math.min(tmp - j, ans[j]);\n                }\n            }\n            return ans;\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：$0(N)$ ，N是数组S的长度\n空间复杂度：$0(N)$，N是数组ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993088581","body":"###思路\n使用数组实现栈\n###代码\n```JAVA\n    class CustomStack {\n        private int[] stack;\n        private int maxSize;\n        private int curSize;\n\n        public CustomStack(int maxSize) {\n            stack = new int[maxSize];\n            this.maxSize = maxSize;\n            curSize = 0;\n        }\n\n        public void push(int x) {\n            if (curSize < maxSize) {\n                stack[curSize++] = x;\n            }\n        }\n\n        public int pop() {\n            if (curSize == 0) {\n                return -1;\n            }\n            return stack[--curSize];\n        }\n\n        public void increment(int k, int val) {\n            k = Math.min(k, curSize);\n            for (int i = 0; i < k; i++) {\n                stack[i] = stack[i]+val;\n\n            }\n\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：\npush：O(1)\npop:O(1)\nincrement:O(k)\n空间复杂度：$O(k)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997126289","body":"###思路\n找到链表长度和k 之间的关系，k决定了新的链表的表头，由此得到新的表头，然后将新表头的上一个链表的下一个链表置空\n 原链表的最后一个数指向原链表的表头\n###代码\n```JAVA\n        class Solution {\n        public ListNode rotateRight(ListNode head, int k) {\n            if (head == null || head.next == null || k == 0) {\n                return head;\n            }\n            int n = 1;\n            ListNode node = head;\n            while (node.next != null) {\n                node = node.next;\n                n++;\n            }\n            if(k%n==0)  return head;\n            k = n - k % n;\n            ListNode tmp = head;\n            while (k > 1) {\n                tmp = tmp.next;\n                k--;\n            }\n            ListNode finhead = tmp.next;\n            tmp.next = null;\n            node.next = head;\n\n            return finhead;\n\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：\nO(N) N为链表的长度\n空间复杂度：$O(1)$  ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997537586","body":"###思路\n快慢指针  找到中位数\n中位数本身做根节点\n中位数左边做树的左边  中位数右边做树的右边  \n递归寻找整颗树\n###代码\n```JAVA\n          class Solution {\n        public TreeNode sortedListToBST(ListNode head) {\n            if (head == null) {\n                return null;\n            }\n            if (head.next == null) {\n                return new TreeNode(head.val);\n            }\n            //找到中间位\n            ListNode fast =head;\n            ListNode slow =head;\n            ListNode temp=null;\n            //要用且 不能用或  用或就会造成空指针异常\n            while (fast!=null && fast.next!=null){\n                temp=slow;\n                slow=slow.next;\n                fast=fast.next.next;\n            }\n            //把链表从slow中间分开\n            //也就是slow的前一个的下一个为null\n            //slow的左边是树的左部  slow的右边是树的右边\n            temp.next=null;\n            TreeNode root =new TreeNode(slow.val);\n            root.left=sortedListToBST(head);\n            root.right=sortedListToBST(slow.next);\n            return  root;\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：\nO(nlong(n)) n为链表的长度\n空间复杂度：$O(long(n))$  ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999604106","body":"###思路\n快慢指针  快的走两步 慢的走一步\n如果有环 他们一定会相遇\n在相遇时 创建一个新的指针从head开始，慢指针把剩下的走完就会和新的指针在入环点相遇\n###代码\n```JAVA\n              public class Solution {\n        public ListNode detectCycle(ListNode head) {\n            if (head == null) {\n                return null;\n            }\n            ListNode slow=head;\n            ListNode fast=head;\n            while (fast!=null){\n              slow=slow.next;\n              //先确保有环\n              if (fast.next!=null){\n                  fast=fast.next.next;\n              }else {\n                  return null;\n              }\n              //如果快慢指针相遇\n              if(slow==fast){\n                  //构造新的指针 从头开始\n                  ListNode prt =head;\n                  //慢指针把剩下的走完就会和新的指针在入环点相遇\n                  while (prt!=slow){\n                      prt=prt.next;\n                      slow=slow.next;\n                  }\n                  return slow;\n              }\n\n            }\n            return null;\n\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：\nO(n) n为链表的长度\n空间复杂度：O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000324468","body":"###思路\n使用双链表 和哈希表\n哈希表用来存储链表\n双链表用来表述  最近是否使用  链表的头部表示 最近使用了\n###代码\n```JAVA\n    class LRUCache {\n        class DListNode {\n            int key;\n            int value;\n            DListNode pre;\n            DListNode next;\n\n            public DListNode() {\n            }\n\n            public DListNode(int key, int value) {\n                this.key = key;\n                this.value = value;\n            }\n        }\n\n\n        HashMap<Integer, DListNode> cache;\n        int size;\n        int capacity;\n        DListNode head;\n        DListNode tail;\n\n        public LRUCache(int capacity) {\n            this.size = 0;\n            this.capacity = capacity;\n            head = new DListNode();\n            tail = new DListNode();\n            //构造双链表\n            head.next = tail;\n            tail.pre = head;\n            cache = new HashMap<Integer, DListNode>();\n        }\n\n        public int get(int key) {\n            //先判断哈希map中是否包含key\n            //如果哈希表中不包含key 返回-1\n            if (!cache.containsKey(key)) {\n                return -1;\n            } else {\n                //否则不包含\n                DListNode node = cache.get(key);\n                moveToHead(node);\n                return node.value;\n            }\n        }\n\n        public void put(int key, int value) {\n            //如果链表不存在\n            if (!cache.containsKey(key)) {\n                DListNode node = new DListNode(key, value);\n                //放进哈希表\n                cache.put(key, node);\n                //要把新加入的放到链表的头部\n                addToHead(node);\n                ++size;\n                //要判断是否溢出\n                //如果溢出了 需要把末尾的删了 没有溢出则不需要执行任何操作\n                if (size > capacity) {\n                    DListNode last = removeTail();\n                    cache.remove(last.key);\n                    size--;\n                }\n            } else {//原来的链表存在  就把链表移动到头部\n                //找到node\n                DListNode node = cache.get(key);\n                //变更其值\n                node.value = value;\n                //移动到头部\n                moveToHead(node);\n            }\n        }\n\n        //添加到链表的头部\n        // 相当于新put进来的\n        public void addToHead(DListNode node) {\n            node.pre = head;\n            node.next = head.next;\n            head.next.pre = node;\n            head.next = node;\n        }\n\n        private void removeNode(DListNode node) {\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n        }\n\n\n        //本身已经存在的链表 移动到头部  相当于最近被用了\n        public void moveToHead(DListNode node) {\n            //把原来的删掉\n            removeNode(node);\n            //放到头部去\n            addToHead(node);\n        }\n\n        //本身已经存在的链表 由于溢出了要把链表末尾删了  相当于溢出 删除最近不常用的\n        //需要返回值 因为需要定位到哪个节点 需要去哈希表中删除该节点\n        public DListNode removeTail() {\n            DListNode last = tail.pre;\n            removeNode(last);\n            return last;\n        }\n    }\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n***复杂度分析***\n时间复杂度：\nO(1) n为链表的长度\n空间复杂度：O(capacity)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000616739","body":"###思路\n递归\n###代码\n```JAVA\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        //使用递归，因为根节点返回的是个int  直接递归左子树 右子树\n        int leftDepth =maxDepth(root.left);\n        int rightDepth=maxDepth(root.right);\n        //因为当一个节点为叶节点时 其返回为0  因此需要加1\n        return Math.max(leftDepth,rightDepth)+1;\n    }\n}\n```\n***复杂度分析***\n时间复杂度：\nO(n) n为节点数 每个节点都需要运行\n空间复杂度：O(h)h为树的深度  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingpitaya":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992528699","body":"## 题目\n\n[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n## 解题思路\n\n> 先遍历一遍字符串 `s` 找到所有 `c` 字符，并记录 `c` 字符出现的数组下标，然后遍历字符串 `s` 计算所有字符距离的最小值。将结果返回。\n\n## 题解\n\n```js\nvar shortestToChar = function(s, c) {\n    let result = new Array(s.length).fill(0);\n    let locations = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            locations.push(i);\n        }\n    }\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] !== c) {\n            let locate = Infinity;\n            for(let j = 0; j < locations.length; j++) {\n                locate = Math.min(locate, Math.abs(i - locations[j]));\n            }\n            result[i] = locate\n        }\n    }\n    return result;\n};\n```\n\n- 时间复杂度:  O(N*K) `N` 为 字符串 `s` 的长度，`K` 为字符串 `s` 中 `c` 字符出现的次数。\n\n- 空间复杂度:  O(K)   `K` 为存储数组下标的辅助数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993629153","body":"## 题目\n\n[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n## 解题思路\n\n> 用数组模拟栈\n\n## 题解\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let element = this.stack.pop();\n    if(element) return element;\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let length = this.stack.length < k ? this.stack.length : k;\n    let i = 0;\n    while(i < length){\n        this.stack[i] += val;\n        i++;\n    }\n};\n```\n\n- 时间复杂度： push 和 pop 为 O(1)，increment 时间复杂度 O(K)，K 为 题目中的 `k` 和 数组长度两个值中较小的一个。\n\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994878784","body":"## 题目\n\n[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n## 解题思路\n\n> 运用栈的思想解决这道题，将字母逐一入栈，遇到数字则记录数字（防止数字不止一位），遇到 `[` 则将记录的数字入栈，并将 `[` 入栈，遇到 `]` 则循环出栈直到栈顶元素为 `[` 并记录出栈的字符串  `str`，将栈顶 `[` 出栈，再次出栈取出记录的重复次数 `num`，将记录的出栈字符串 `str` 重复 `num` 次。最后将栈中所有字符拼接成一个字符串返回。\n\n## 题解\n\n```js\nvar decodeString = function (s) {\n    let stack = [];\n    let string = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === \"[\") {\n            stack.push(parseInt(string));\n            stack.push(\"[\");\n            string = \"\";\n        }\n        if (s[i] === \"]\") {\n            let res = \"\";\n            while (stack[stack.length - 1] !== \"[\") {\n                res = stack.pop() + res;\n            }\n            stack.pop(); //将 [ 弹出\n            let num = stack.pop();\n            stack.push(res.repeat(num));\n        }\n        if (\n            s[i].charCodeAt() >= \"0\".charCodeAt() &&\n            s[i].charCodeAt() <= \"9\".charCodeAt()\n        ) {\n            string += s[i];\n        }\n        if (\n            (s[i].charCodeAt() >= \"a\".charCodeAt() &&\n                s[i].charCodeAt() <= \"z\".charCodeAt()) ||\n            (s[i].charCodeAt() >= \"A\".charCodeAt() &&\n                s[i].charCodeAt() <= \"Z\".charCodeAt())\n        ) {\n            stack.push(s[i]);\n        }\n    }\n    return stack.join('');\n};\n```\n\n- 时间复杂度：O(N)\n\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995837714","body":"## 题目\n\n#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n## 解题思路\n\n> 关键在于用另一个栈来将入栈的顺序颠倒过来，每次 `push` 数据，先将 `stack` 中存的数据依次出栈存入另一个栈 `list` 中，直到 `stack` 栈空，将 `push` 进入的数字 `x` 入栈 `stack`，再将 `list` 中存的数据依次存入 `stack` 中。\n\n## 题解\n\n```js\nvar MyQueue = function() {\n    this.stack = [];\n    this.list = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    let current = null;\n    while( current = this.stack.pop()) {\n        this.list.push(current)\n    }\n    this.list.push(x);\n    \n    while( current = this.list.pop()) {\n        this.stack.push(current)\n    }\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.stack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.stack[this.stack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack.length === 0\n};\n```\n\n- 时间复杂度：O(N) 每次入栈都要先将栈中元素推出栈存入辅助栈。\n- 空间复杂度：O(N) 辅助栈空间与栈空间相同。\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997212431","body":"## 题目\n\n[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n## 解题思路\n\n> 分析题意，链表每个节点向右移动 `k` 个位置，我们需要找到链表倒数第 `k + 1` 位置，将该位置的指针指为 `null`，保存该位置的下一个节点地址，将原链表的末尾指向 `head`，找到倒数 `k` 的位置可以利用快慢指针技巧，快指针先走 `k` 步，然后两个指针一起走，当 `fast` 指针到链表末尾，则 `slow` 指针就是倒数第 `k` 个位置。\n\n## 题解\n\n```js\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!k || !head || !head.next) return head;\n    let now = head;\n    let count = 0;\n    while(now) {\n        count++;\n        now = now.next;\n    }\n    k = k % count;\n\n    let slow = head, fast = head;\n    // 快指针先走 k 步\n    while(k--){\n        fast = fast.next;\n        if(!fast) {\n            fast = head;\n        }\n    }\n    if(fast == slow) {\n        return head;\n    }\n    //两个指针一起走\n    while(fast.next) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    let res = slow.next;\n    slow.next = null;\n    fast.next = head;\n    return res\n   \n};\n```\n\n- 时间复杂度 O(N）\n- 空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998011772","body":"## 题目\n\n[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n## 题解\n\n```js\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    return buildTree(head, null);\n};\n\nvar buildTree = function (head, tail) {\n    if (!head || head === tail) return null;\n    \n    let fast = head;\n    let slow = head;\n    while (fast !== tail && fast.next !== tail) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    let root = new TreeNode(slow.val);\n\n    root.left = buildTree(head, slow);\n    root.right = buildTree(slow.next, tail);\n\n    return root;\n}\n```\n\n- 时间复杂度 O(nlogn)\n- 空间复杂度 O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998832301","body":"## 题目\n\n[160.相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n## 解题思路\n\n\n> 判断两个链表有没有公共结点，问题关键 **通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`**， 可以让 `p1` 遍历完链表 `A` 后开始遍历 链表 `B` ，让 `p2` 遍历完链表 `B` 后遍历链表 `A`，如果两个链表没有相交点会在终点处同时等于 `null`\n\n## 题解\n\n```js\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let p1 = headA, p2 = headB\n    while(p1 != p2) {\n        if(p1 === null) {\n            p1 = headB;\n        } else {\n            p1 = p1.next;\n        }\n\n        if(p2 === null) {\n            p2 = headA;\n        } else {\n            p2 = p2.next;\n        }\n    } \n\n    return p1;\n};\n```\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999659431","body":"## 解题思路\n\n>需要用到快慢指针，快慢指针相遇时，让其中任意一个指针指向头结点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始位置。\n\n## 题解\n\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n   let fast = head, slow = head;\n   while(fast !== null && fast.next !== null) {\n       slow = slow.next;\n       fast = fast.next.next;\n       if(slow == fast) {\n           break;\n       }\n   }\n\n   if(fast === null || fast.next === null) {\n       return null;\n   }\n   // 将慢指针重新设置为头结点，此时两个指针以同样速度前进，再次相遇时就为环开始节点\n   slow = head;\n   while (slow != fast) {\n       fast = fast.next;\n       slow = slow.next;\n   }\n   return slow;\n};\n```\n\n- 时间复杂度 O(N)\n\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000073480","body":"## 解题思路\n\n> 利用 Map 特性，Map 对象在迭代时会根据元素插入顺序进行。\n\n## 题解\n\n```js\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.cache = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.cache.has(key)) {\n        let value = this.cache.get(key);\n        this.cache.delete(key);\n        this.cache.set(key, value);\n        return value;\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    else if (this.cache.size >= this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, value);\n};\n```\n\n- 时间复杂度 O(1)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000862120","body":"## 解题思路\n\n> 递归，递归结束条件，节点为空，最大深度为左右子树深度较大的值加 1。\n\n## 题解\n\n```js\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(root === null) {\n        return 0;\n    }\n    let leftDeep = maxDepth(root.left);\n    let rightDeep = maxDepth(root.right);\n    let res = 1 + Math.max(leftDeep, rightDeep);\n    return res;\n};\n```\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(N) 树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pwqgithub-cqu":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992579590","body":"暴力解法:\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> a;\n\n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i] == c)\n                a.push_back(i);  \n        }\n\n        vector<int> answer;\n        for(int i=0; i<s.size(); i++)  // 遍历字符串\n        {\n            int num = s.size();\n            for(int j=0; j< a.size(); j++)  \n            {\n                num = min(num, abs(a[j]-i));\n            }\n            answer.push_back(num);\n        }\n        return answer;\n    }\n};\n\n时间复杂度:N*N\n空间复杂度:N","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997338925","body":"递归实现\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        ListNode* newHead = head->next;\r\n        head->next = swapPairs(newHead->next);\r\n        newHead->next = head;\r\n        return newHead;\r\n    }\r\n};\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998829404","body":"思路：使用两个哈希map装载两个链表\n代码\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode *> visited;\n        ListNode *temp = headA;\n        while (temp != nullptr) {\n            visited.insert(temp);\n            temp = temp->next;\n        }\n        temp = headB;\n        while (temp != nullptr) {\n            if (visited.count(temp)) {\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return nullptr;\n    }\n};\n时间复杂度：O(m+n)\n空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999649801","body":"思路：哈希表遍历\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set<ListNode *> visited;\n        while (head != nullptr) {\n            if (visited.count(head)) {\n                return head;\n            }\n            visited.insert(head);\n            head = head->next;\n        }\n        return nullptr;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rex-zh":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992600011","body":"### 思路  \n1. 遍历找到第一个c，并记录位置  \n1. 遍历结果数组至上述位置，为c之前及其自身索引赋距离值  \n1. 从上述位置的下一个开始继续遍历，使用gap计算两个c之间的间距，同时作为当前索引的距离值，若出现c则反向遍历gap/2个索引重新赋更近的距离值  \n1. 遍历完毕返回结果  \n### 代码  \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        int gap = 0;\n        int k = 0;\n        for(; k<s.length() ; k++){\n            if(s.charAt(k) == c) break;\n        }\n        for(int i=0; i<=k; i++){\n            answer[i] = k-i;\n        }\n        for(int i=k+1; i<s.length(); i++){\n            if(s.charAt(i)==c){\n                for(int j=i; j>=i-gap/2; j--){\n                    answer[j]=i-j;\n                }\n                gap=0;\n            }else{\n                gap++;\n                answer[i]=gap;\n            }\n        }\n        return answer;\n    }\n}\n```  \n### 复杂度分析  \n- 时间复杂度：O(N)，N为字符串长度  \n- 空间复杂度：也许O(N)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993642150","body":"#### 思想  \n1. 使用C++的vector及其方法；  \n1. 使用vector.reserve(int)来控制容量；  \n1. 通过比较size和capacity判断是否栈满；  \n1. 通过vector.empty()判断是否栈空；  \n1. 循环迭代k和size较小次处理值变化。  \n#### 代码  \n```c++\nclass CustomStack {\nprivate:\n    vector<int> stack;\npublic:\n    CustomStack(int maxSize) {\n        stack.reserve(maxSize);\n    }\n    \n    void push(int x) {\n        if(stack.size() == stack.capacity()){\n            return;\n        }else{\n            stack.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }else{\n            int top=stack.back();\n            stack.pop_back();\n            return top;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int board = k<stack.size()?k:stack.size();\n        for(int i=0; i<board; i++){\n            stack[i]+=val;\n        }\n    }\n};\n```  \n#### 算法复杂度  \n- 时间复杂度：增量O(N)，N为栈容量，其余为O(1)？  \n- 空间复杂度：O(N)，N为栈容量  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923350","body":"### code\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s[i] == ']'){\r\n                int j=i-1;\r\n                string temp;\r\n                string add;\r\n                int k=0;\r\n                for(; j>-1; j--){\r\n                    if(s[j]=='[') break;\r\n                    temp.insert(0,1,s[j]);\r\n                }\r\n                for(int m=--j; m>-1; m--){\r\n                    if(s[m]>'9' || s[m]<'0'){\r\n                        j=m+1;\r\n                        break;\r\n                    }else{\r\n                        k=k+(s[m]-'0')*pow(10,j-m);\r\n                        if(m==0){\r\n                            j=0;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                add = temp;\r\n                for(int m=1; m<k; m++){\r\n                    add.append(temp);\r\n                }\r\n                s.replace(s.begin()+j,s.begin()+i+1,add);\r\n                i=j+add.length()-1;\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995866693","body":"#### 代码\n```java\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<> ();\n    Stack<Integer> popStack = new Stack<> ();\n\n    public MyQueue() {\n\n    }\n\n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n\n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n\n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997219908","body":"#### 思想  \n快慢指针，学习了\n#### 代码  \n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr\n        || head->next == nullptr\n        || k == 0)\n            return head;\n\n        int len = 1;\n        ListNode* cur = head;\n        while (cur->next != nullptr) {\n            cur = cur->next;\n            len++;\n        }\n\n        k %= len;\n\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while (fast->next != nullptr) {\n            if (k-- <= 0) {\n                slow = slow->next;\n            }\n            fast = fast->next;\n        }\n\n        fast->next = head;\n        ListNode* new_head = slow->next;\n        slow->next = nullptr;\n        return new_head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414621","body":"#### 思想\n虚拟节点，学习了\n#### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n\n        ListNode* dummy = new ListNode(-1, head);\n        ListNode* prev = dummy;\n        ListNode* cur = prev->next;\n\n        while (cur != nullptr && cur->next != nullptr) {\n            ListNode* next = cur->next;\n            cur->next = next->next;\n            next->next = cur;\n            prev->next = next;\n\n            prev = cur;\n            cur = cur->next;\n        }\n        return dummy->next;    \n    }\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000778059","body":"#### 思路\n先打个卡，前面还有很多要补，递归\n#### 代码\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left, right) + 1;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yutong-dai":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992604942","body":"\n# 思路\n\nforward + backward pass\n\nrecord the current char location\n\n# 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        n = len(s)\n        ans = []\n\n        #forward\n        last_seen = -n    \n        for (i, cur_char) in enumerate(s):\n            if cur_char == c:\n                last_seen = i\n            ans.append(i-last_seen)\n\n        #backward\n        last_seen = 2*n   \n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                last_seen = i\n            ans[i] = min(ans[i], last_seen-i)\n        \n        return ans\n```        \n\n# 复杂度分析\n\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993055568","body":"\n# 代码\n\nclass CustomStack:\n\n```python\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.size = 0\n        self.lst = [None] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.lst[self.size] = x\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            item = self.lst[self.size-1]\n            self.size -= 1\n            return item\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.lst[i] += val\n```\n\n# 复杂度:\n\n时间\n\n* push: O(1)\n* pop: O(1)\n* increment: O(n)\n\n空间复杂度：\n\n* push: O(2)            \n* pop: (1)\n* increment: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994264952","body":"# 思路:\nstack 匹配 括号\n\n# 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                item = stack.pop(-1)\n                temp_str = ''\n                while item != '[':\n                    temp_str = item + temp_str\n                    item = stack.pop(-1)\n                # get numerics\n                num_str = ''\n                while stack and stack[-1].isnumeric():\n                    num_str = stack.pop(-1) + num_str\n                stack.append(int(num_str) * temp_str)\n        return \"\".join(stack)\n```\n\n# 复杂度\n\ntime: O(n)\nspace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996218051","body":"# 思路\n单调栈\n\n# 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        monotoneStack = [arr[0]]\n        for i in range(1,len(arr)):\n            element = arr[i]\n            if element >= monotoneStack[-1]:\n                monotoneStack.append(element)\n            else:\n                topMax = monotoneStack[-1]\n                while monotoneStack and element < monotoneStack[-1]:\n                    monotoneStack.pop(-1)\n                monotoneStack.append(topMax)\n        return len(monotoneStack)\n```\n\n# 复杂度\n\n* 时间: O(n)\n* 空间: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997235146","body":"# 思路\n\n两两交换\n\n\n# 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        sentinel = ListNode(val=None, next=head)\n        prev = sentinel\n        curr_node = head\n        # be careful about the edge case\n        while curr_node and curr_node.next:\n            next_node = curr_node.next\n            curr_node.next = next_node.next\n            next_node.next = curr_node\n            prev.next = next_node\n            prev = curr_node\n            curr_node = curr_node.next\n        # head is updated; do not return head\n        return sentinel.next\n```        \n\n# 复杂度\n\n* 时间: O(n)\n* 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997426131","body":"```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        self.num_array = []\n        while head:\n            self.num_array.append(head.val)\n            head = head.next\n        num_elements = len(self.num_array)\n        root = self.helper(0, num_elements-1)\n        return root\n\n    \n    def helper(self, start, end):\n        if start == end:\n            return TreeNode(self.num_array[start], left= None, right=None)\n        if start > end:\n            return None\n        mid_point = (end + start) >> 1\n        root = TreeNode(self.num_array[mid_point], left= None, right=None)\n        root.left = self.helper(start, mid_point-1)\n        root.right = self.helper(mid_point+1, end)\n        return root\n```        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998124421","body":"```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curA = headA\n        curB = headB\n        if not headA or not headB:\n            return None\n        while curA != curB:\n            if not curA:\n                curA = headB\n            else:\n                curA = curA.next\n            if not curB:\n                curB = headA\n            else:\n                curB = curB.next\n        return curA\n```        \n\n时间: O(m+n)\n空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999671590","body":"```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        fast = head\n        slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                fast = head\n                while fast != slow:\n                    fast = fast.next\n                    slow = slow.next\n                return fast\n        return None\n```\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)        ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001092107","body":"```python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        # case 1: p is none and q is none\n        if p is None and q is None: return True\n        # case 2: (p is none and q is not none) or (p is not none and q is none)\n        # one trick here:\n        # when ( p is None or q is None) is true,\n        # it could be  \n        #   p is None and q is None (this is excluded by the previous check)\n        #   p is not None and q is None\n        #   p is None and q is not None\n        # For later two cases, we return false\n        if p is None or q is None: return False\n        # early termination, avoid further recursion\n        if p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992610167","body":"```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> re(s.length(),10000);\n\n        for (int i =0 ;i<s.length();i++){\n\n            if(s[i] == c){\n                re[i] = 0;\n                for (int j =0 ;j<s.length();j++){\n                    if(re[j]>abs(j-i)){\n                        re[j]=abs(j-i);\n                    }\n                }\n            }\n\n\n        }\n\n        return  re;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993618004","body":"````c++\nclass CustomStack {\nprivate:\n    vector<int> * p_data;\n    int pos = -1;\n    int maxSize = -1;\npublic:\n\n    CustomStack(int maxSize) {\n        p_data = new vector<int>(maxSize);\n        pos = 0;\n        this->maxSize = maxSize;\n    }\n\n    void push(int x) {\n        if(pos == maxSize)return;\n        (*p_data)[pos++]=x;\n    }\n\n    int pop() {\n        if(pos == 0) return -1;\n        return p_data->at(--pos);\n    }\n\n    void increment(int k, int val) {\n        if(pos ==0) return ;\n         *new vector<int>(k,val);\n         for(int i =0 ;i<maxSize&&i<k;i++){\n             (*p_data)[i] = (p_data->at(i)+val);\n         }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994920927","body":"```c++\nclass Solution {\npublic:\n      //一开始没有考虑到多个数字100\n    string decodeString(string s) {\n        if(s.empty()){\n            return s;\n        }\n        char c = s.at(0);\n\n        if(isNum(c)){\n\n            //一开始没有考虑到多个数字100\n            string s_copy_num ;\n            int pos = 0;\n            while (isNum(s.at(pos))){\n                s_copy_num.push_back(s.at(pos));\n                pos++;\n            }\n\n            //中括号编码+其余部分 -->c*de(中括号部分)+ de(其余部分)\n\n            //提取中括号中部分\n            int z_num = 1;\n             pos ++; //[ 后开始遍历\n            while(z_num!=0){\n                if(s.at(pos)=='[')z_num++;\n                else if(s.at(pos)==']')z_num--;\n                pos++;\n            }\n            string z_str = s.substr(s_copy_num.length()+1,pos-s_copy_num.length()-2);\n            string o_str = pos<s.length()?s.substr(pos):\"\";\n\n            int copyNum  =  stoi(s_copy_num);\n            string result=\"\";\n            string de_z_str = decodeString(z_str);\n            string de_o_str = decodeString(o_str);\n            for(int i =0;i<copyNum;i++){\n                result.append(de_z_str);\n            }\n           return  result.append(de_o_str);\n\n        }\n        if(s.length()==1){\n\n            //#char 怎么转化为string c+\"\" leedcode无法编译通过\n            string e;\n            return e+c;\n        }\n        return c+ decodeString(s.substr(1));\n    }\n\n    static bool isNum(char c){\n        return (c>='0'&&c<='9');\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995911532","body":"```c++\nclass MyQueue {\n\n\n    stack<int> first;\n    stack<int> second;\n\npublic:\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        first.push(x);\n    }\n\n    int pop() {\n        if(second.empty()){\n            while (!first.empty()){\n                second.push(first.top());\n                first.pop();\n            }\n        }\n        int re = second.top();\n        second.pop();\n        return re;\n    }\n\n    int peek() {\n        if(second.empty()){\n            while (!first.empty()){\n                second.push(first.top());\n                first.pop();\n            }\n        }\n        int re = second.top();\n        return re;\n    }\n\n    bool empty() {\n        return first.empty()&&second.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996822604","body":"```c++\nclass Solution {\npublic:\n   int maxChunksToSorted(vector<int>& arr) {\n\n        int max_c = 1;\n       for(int i =0 ;i<arr.size()-1;i++){\n\n           if(*max_element(arr.begin(),arr.begin()+i+1)<=*(min_element(arr.begin()+i+1,arr.end()))){\n               auto v2  = vector<int>(arr.begin()+i+1,arr.end());\n               max_c= max(1+maxChunksToSorted(v2),max_c);\n               break;\n           }\n\n       }\n        return max_c;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997216005","body":"```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n    if(head == nullptr){\n        return head;\n    }\n//        先把队列练成环\n   ListNode *pos =head;\n\n   int num =1;\n   while(pos->next!= nullptr){\n       pos=pos->next;\n       num++;\n   }\n//   成环状\n   pos->next=head;\n// 然后找到循环过后的头指针(采用补码的形式，去确定环的位置)，然后切断环\n   k = k%num;\n   auto end = pos;\n   int count = num -k;\n   while(count!=0){\n       end = end->next;\n       count--;\n   }\n   auto new_head = end->next;\n   end->next = nullptr;return new_head;\n\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997356056","body":"```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head== nullptr||head->next== nullptr){\n            return head;\n        }\n        ListNode * first;\n        ListNode *second;\n        first = head;\n        second = nullptr;\n        head =head->next;\n\n        do{\n            second = first->next;\n            first->next=second->next;\n            second->next=first;\n\n            first=first->next;\n\n            // 一开始忘了交换会影响前面的指针的指向\n            if(first!= nullptr&&first->next!= nullptr){\n                second->next->next=first->next;\n            }\n\n        } while (first!= nullptr&&first->next!= nullptr);\n\n        return head;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998027492","body":"```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n//        两个数量差1的平衡树，高度的绝对差值不超过1\n\n        if(head== nullptr){\n            return nullptr;\n        }\n        if(head->next== nullptr){\n                return new TreeNode(head->val);\n        }\n    //    怎么找一个链表的中间节点,然后切断呢？\n\n        int num = 0;\n        ListNode* pos = head;\n        while(pos!= nullptr){\n            num++;\n            pos=pos->next;\n        }\n\n         return sortedListToBST2(head,num);\n\n    }\n    TreeNode* sortedListToBST2(ListNode* head,int num){\n\n        if(head== nullptr){\n            return nullptr;\n        }\n        if(head->next== nullptr){\n            return new TreeNode(head->val);\n        }\n        ListNode* pos =head;\n        ListNode* f_pos = nullptr;\n        ListNode* b_pos = nullptr;\n        int i =0;\n        int mid = num/2+1;\n        while(i!=mid-1){\n            f_pos = pos;\n            pos = pos->next;\n            b_pos = pos->next;\n            i++;\n        }\n\n        f_pos->next = nullptr;\n        pos->next = nullptr;\n        TreeNode *t_head = new TreeNode(pos->val);\n        t_head->left=sortedListToBST2(head,mid-1);\n        t_head->right=sortedListToBST2(b_pos,num-mid);\n\n        return  t_head;\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998843692","body":"找到两个链表之间的差距（速度相同先跑一遍，就会知道两者之间的差距），\n找到差距后，让比较远的跑先跑差距部分，然后让他们在同时奔跑，判断相遇就好\n\n```c++\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *posA1= headA;\n        ListNode *posB1 = headB;\n        while(posA1!= nullptr&&posB1!= nullptr){\n            posA1=posA1->next;\n            posB1 = posB1->next;\n        }\n        ListNode *posA= headA;\n        ListNode *posB = headB;\n        if(posB1!= nullptr){\n            while(posB1!= nullptr){\n                posB1 = posB1->next;\n                posB = posB->next;\n            }\n        }\n        if(posA1!= nullptr){\n            while(posA1!= nullptr){\n                posA1 = posA1->next;\n                posA = posA->next;\n            }\n        }\n        ListNode* f_common = nullptr;\n        while (posA!= nullptr&&posB!= nullptr){\n            if(posB==posA){\n                f_common=posA;\n                break;\n            }\n            posB = posB->next;\n            posA = posA->next;\n        }\n        return  f_common;\n\n\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998960307","body":"```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n\n//        利用快满指针的两次相遇计算出环的大小。然后利用双指针（相差环的大小），从头遍历，计算出相交节点\n// 是想操场跑步，如果速度相差两倍的话，他们首次相遇肯定是起点位置，并且是第一次相遇。可以思考成快的要追慢的一圈的距离。\n// 他们相遇必定是整数次数，两圈的偶数 指针每次两个。满指针 每次一个 整数\n          if(head== nullptr){\n              return nullptr;\n          }\n            ListNode* fastPos = head->next;\n          ListNode* slowPos = head;\n        while (fastPos!= nullptr&&fastPos->next!= nullptr &&fastPos!=slowPos){\n\n            fastPos = fastPos->next->next;\n            slowPos = slowPos->next;\n\n        }\n        if(fastPos == nullptr){\n            return nullptr;\n        }\n        if(fastPos->next== nullptr){\n            return nullptr;\n        }\n        int num=0;\n        do{\n            fastPos = fastPos->next->next;\n            slowPos = slowPos->next;\n            num++;\n        } while (fastPos!=slowPos);\n        ListNode* pos1 = head;\n        ListNode* pos2 = head;\n        for(int i=0;i<num;i++){\n            pos2=pos2->next;\n        }\n        while(pos1!=pos2){\n            pos1=pos1->next;\n            pos2 = pos2->next;\n        }\n\n        return pos1;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999763560","body":"```c++\nstruct ListNode2 {\n      int val;\n      ListNode2 *next;\n      ListNode2 *pre;\n      ListNode2() : val(0), next(nullptr),pre(nullptr) {}\n      ListNode2(int x) : val(x), next(nullptr),pre(nullptr) {}\n      ListNode2(int x, ListNode2 *pre,ListNode2 *next) : val(x), next(pre),pre(nullptr) {}\n  };\n\nclass LRUCache {\n\n    map<int,ListNode2*> m;\n    int cap=0;\n    int size=0;\n    ListNode2* head = new ListNode2(-1);\n    ListNode2* tail = new ListNode2(-1);\npublic:\n    LRUCache(int capacity) {\n        head->next=tail;\n        tail->next=head;\n        cap=capacity;\n    }\n\n    int get(int key) {\n        if(m.find(key)==m.end()){\n            return -1;\n        }\n        ListNode2 * node = m.at(key);\n        ListNode2 *pre = node->pre;\n        ListNode2 *next = node->next;\n        pre->next = next;\n        next->pre = pre;\n        //放到头部\n        ListNode2* head_next = head->next;\n        head->next=node;\n        node->pre=head;\n        node->next=head_next;\n        head_next->pre = node;\n        return node->val;\n    }\n\n    void put(int key, int value) {\n        ListNode2 * node = nullptr;\n        ListNode2* head_next = head->next;\n        if(m.find(key)==m.end()){\n            if(size+1>cap){\n                ListNode2 *deleteNode = tail->pre;\n                deleteNode->pre->next=tail;\n                tail->pre=deleteNode->pre;\n                m.erase(deleteNode->val);\n                delete deleteNode;\n                \n            } else{\n                size++;\n            }\n            node =new ListNode2(value);\n            m[key]=node;\n        } else{\n            node = m.at(key);\n            node->val=value;\n            ListNode2 *pre = node->pre;\n            ListNode2 *next = node->next;\n            pre->next = next;\n            next->pre = pre;\n        }\n\n        //放到头部\n        head->next=node;\n        node->pre=head;\n        node->next=head_next;\n        head_next->pre = node;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000861467","body":"```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root== nullptr){\n            return  0;\n        }\n        int max_left_depth = maxDepth(root->left);\n        int max_right_depth= maxDepth(root->right);\n\n        return max(max_right_depth,max_left_depth)+1;\n\n\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rmbdream":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992638943","body":"## Note\nc的位置pre未知时距离为无穷远，即先将距离赋予超大数。左右遍历，右遍历时距离为i-pre，左遍历时为pre-i\n## Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        \n        // /2防止越界\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE;\n        for (int i = n - 1; i > -1; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n## Complexity\n- time: O(n)\n- space: O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fayepei":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993010039","body":"class CustomStack {\r\n    int top;\r\n     public CustomStack(int maxSize){\r\n        int[] stack=new int[maxSize];\r\n        top=-1;\r\n     }\r\n    \r\n     public void Push(int x) { //no need to return, for the void method\r\n         if(top!=stack.length-1){\r\n             top++;\r\n             stack[top]=x;\r\n         }\r\n     }\r\n     public int Pop() {\r\n        if(top=-1){\r\n            return -1;\r\n        }--top;\r\n         return stack[top+1];\r\n         \r\n        \r\n     }\r\n     public void Increment(int k, int val) {\r\n         int limit=Math.min(k,top+1);\r\n        for(int i=0;i<limit;i++){\r\n            stack[i]=stack[i]+val;\r\n        } \r\n         \r\n     }      \r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993114123","body":"### 思路\n没什么特别的，标准的用array 模拟stack\n1. top指针表示 栈顶\n2. bottom 指针表示 栈底\n3. size 表示 当前栈大小：push pop 操作相关\n4. array[maxSize + 1]做内部数据结构：为什么+1，模拟stack full时top指针的位置\n\n### 代码\n```java\nclass CustomStack {\n    private int maxSize;\n    private int size;\n    private int top;\n    private int bot;\n    \n    private int[] stack;\n    \n    public CustomStack(int maxSize) {\n        this.size = 0;\n        this.top = 0;\n        this.bot = 0;\n        \n        this.maxSize = maxSize;\n        this.stack = new int[maxSize+1];\n    }\n    \n    public void push(int x) {\n        if (this.size == this.maxSize) {\n            // do nothing\n        } else {\n            this.stack[this.top++] = x;\n            this.size++;\n        }\n    }\n    \n    public int pop() {\n        if (this.size == 0) {\n            return -1;\n        } else {\n            this.top--;            \n            this.size--;\n            return this.stack[this.top];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if (k > this.maxSize) {\n            k = this.maxSize;\n        }\n        \n        for (int i = this.bot; i < k && i < this.top; i++) {\n            this.stack[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push,pop都是O(1), increment是O(min(K, maxSize))\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994403353","body":"### 解题思路\n1. 一开始想着用俩个stack，一个存num，一个存str，但是实现的时候发现，很难让两方数据对齐。\n    即test case不是全部`num[str \"num[str]\"]`的格式。\n    也有可能是`str num[str]` 或者 `num[num[str]]`的格式。所以这就需要自己填上空，使其满足`num[str \"num[str]\"]`的格式。\n    十分困难\n2. 后来选择，用一个stack，里面存全部数据num + str就方便多了。\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<StringBuilder> stack = new Stack<>();\n        \n        int pnt = 0;\n        while (pnt < s.length()) {\n            if (Character.isDigit(s.charAt(pnt))) {\n                // get all digits and insert as a string number\n                \n                StringBuilder sb = new StringBuilder();\n                while (pnt < s.length() && Character.isDigit(s.charAt(pnt))) {\n                    sb.append(s.charAt(pnt));\n                    pnt++;\n                }\n                // when it comes out, pnt points to \"[\"\n                stack.push(sb);          \n            } else if (Character.isLowerCase(s.charAt(pnt))) {\n                StringBuilder sb = new StringBuilder();\n                while (pnt < s.length() && Character.isLowerCase(s.charAt(pnt))) {\n                    sb.append(s.charAt(pnt));\n                    pnt++;\n                }\n                // when it comes out, pnt points to \"]\"\n                stack.push(sb);\n            } else if (s.charAt(pnt) == '[') {\n                stack.push(new StringBuilder(\"[\"));\n                pnt++;\n            } else {  // \"]\"\n                StringBuilder sb = new StringBuilder();\n                // pop all str until [\n                StringBuilder popStr = stack.pop();\n                while(!popStr.toString().equals(\"[\")) {\n                    sb.insert(0, popStr);\n                    popStr = stack.pop();\n                }\n                // pop [, pop'd already\n                \n                // pop number\n                StringBuilder numStr = stack.pop();\n                \n                // regenerate new string and insert back\n                for (int i = 0; i < Integer.valueOf(numStr.toString()); i++) {\n                    stack.push(sb);\n                }\n                \n                pnt++;\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n### 复杂度\n时间：O(n * m). n 是 string length, m是]的个数\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995516437","body":"### 思路\n两个stack 一个装push 一个装po p\n### 代码\n```java\nclass MyQueue {\n\n    private Stack<Integer> pushStack;\n    private Stack<Integer> popStack;\n    \n    public MyQueue() {\n        pushStack = new Stack<Integer>();\n        popStack = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        if (popStack.isEmpty()) {\n            // move all pushStack to popStack\n            while (!pushStack.isEmpty()) {\n                popStack.push(pushStack.pop());\n            }\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        if (popStack.isEmpty()) {\n            // move all pushStack to popStack\n            while (!pushStack.isEmpty()) {\n                popStack.push(pushStack.pop());\n            }\n            \n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return popStack.isEmpty() && pushStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n### 复杂度分析\n时间：amortized O(1)\n空间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997110008","body":"### 思路\n1. 找到新的tail，做几个转换就可以找到新的head 了\n2. 但需要handle K 特别大的情况\n\n### code\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        \n        // get the list length\n        int listLen = 1;\n        ListNode pnt = head;\n        while (pnt.next != null) {\n            pnt = pnt.next;\n            listLen++;\n        }\n        \n        // to solve k > listLen problem\n        k = k % listLen;\n        \n        \n        // fast slow pointer to target new tail\n        ListNode fast = head;\n        ListNode slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n        \n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        // now fast is the tail and slow is new tail\n        \n        fast.next = head;\n        ListNode newHead = slow.next;\n        slow.next = null;\n            \n        return newHead;\n    }\n```\n\n### 复杂度分析\n\n时间复杂度: O(n),\n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997328471","body":"### 思路\n1. 找到两个node之间相互交换的方法：prev, first, second\n2. 分析奇数和偶数个node的情况\n3. 处理corner case \n\n### code\n```java\npublic ListNode swapPairs(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        \n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        \n        ListNode prev = dummy;\n        ListNode first = head;\n        ListNode second = head.next;\n        \n        while (first != null && second != null) {\n            prev.next = second;\n            first.next = second.next;\n            second.next = first;\n            \n            prev = first;\n            first = first.next;\n            if (first != null) {\n                second = first.next;\n            } else {\n                break;\n            }\n        }\n        \n        return dummy.next;\n    }\n```\n\n### 复杂度分析\n时间O：n\n空间O：1","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998511678","body":"### 思路\n官方答案不错，但比较难想出来。\n### code\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // is A and B intersected?\n        int sizeA = 1;\n        ListNode tempA = headA;\n        int sizeB = 1;\n        ListNode tempB = headB;\n        \n        while (tempA.next != null) {\n            sizeA++;\n            tempA = tempA.next;\n        }\n        while (tempB.next != null) {\n            sizeB++;\n            tempB = tempB.next;\n        }\n        // now, tempA and tempB is the end of each list\n        if (tempA != tempB) {\n            return null;\n        }\n        \n        // if yes, then find the insection point\n         tempA = headA;\n         tempB = headB;\n        if (sizeA > sizeB) {\n            for (int i = 0; i < sizeA - sizeB; i++) {\n                tempA = tempA.next;\n            } \n        } else {\n            for (int i = 0; i < sizeB - sizeA; i++) {\n                tempB = tempB.next;\n            } \n        }\n        \n        while (tempA != tempB) {\n            tempA = tempA.next;\n            tempB = tempB.next;\n        }\n        \n        return tempA;\n    }\n```\n\n### 复杂度\ntime comp: O(M+N)\nspace comp: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999244512","body":"### 思路\n只能说自己画图看吧\n\n### code\n```java\npublic ListNode detectCycle(ListNode head) {\n        // corner case\n        if (head == null) {\n            return null;\n        }\n        \n        // does it have a cycle?\n        ListNode slow = head;\n        ListNode fast = head;\n        boolean meetEachOther = false;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        \n            if (slow == fast) {\n                meetEachOther = true;\n                break;\n            }\n        }\n        \n        if (!meetEachOther) {\n            // while loop exit because fast reaches end\n            return null;\n        }\n        \n        // it has a loop\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        return slow;\n    }\n```\n\n### 复杂度分析\ntime: O(N), N is the number of individual listNodes\nspace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amberma626":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993185619","body":"思路：Use array to record maxSize and simulate stack\r\n代码：\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [] \r\n        self.maxSize = maxSize\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)       \r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) <= 0 :\r\n            return -1\r\n        else:\r\n            return self.stack.pop()        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k <= len(self.stack):\r\n            for i in range(k):\r\n                self.stack[i] += val \r\n            \r\n        else:\r\n            self.stack = [x+val for x in self.stack]\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phybrain":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993251967","body":"### 思路\n\n数组实现\n\n### 代码\n\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994673692","body":"### 思路\n递归\n\n### 代码\n\n\n```python\n    def decodeStringDfs(self, s: str) -> str:\n        def dfs(i):\n            res, multi = \"\", 0\n            #这里不能用for i in range(len(s)),因为递归调用时，新的循环不从0开始从i开始\n            while i < len(s):\n                #遇到数字\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])#考虑数字是2位以上的情况\n                #遇到'['开始将后续的string递归\n                elif s[i] == '[':\n                    i, tmp = dfs(i + 1)\n                    #注意，返回i的含义是更新上层递归指针位置，因为内层递归已经吃掉一串str，若不跟新i，外层仍然从i+1开始，则会重复处理内层处理过的一串str。\n                    res += multi * tmp\n                    multi = 0\n                #遇到']'到达递归边界，结束递归，返回新i和处理好的内层res\n                elif s[i] == ']':\n                    return i, res\n                #遇到其他，则当字母串处理\n                else:\n                    res += s[i]\n                i+=1\n            #考虑结尾是...]abc的情况\n            return res\n        \n        return dfs(0)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995661183","body":"### 思路\n双栈互换\n\n### 代码\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996550907","body":"### 思路\n单调栈\n\n### 代码\n\n\n```python\nclass Solution:\n    def findblock(self, L: list) -> int:\n\n        stack = []\n        for l in L:\n\n            if stack and l<stack[-1]:\n\n                s = stack[-1]\n                while stack and l < stack[-1]:\n                    stack.pop()\n                stack.append(s)\n            else:\n                stack.append(l)\n        return len(stack)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997160976","body":"### 思路\n循环链表\n\n### 代码\n\n\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        add =  n - k % n\n        if add == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997378160","body":"```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        next = head.next\r\n        head.next = self.swapPairs(next.next)\r\n        next.next = head\r\n        return next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997568499","body":"### 思路\n递归\n\n### 代码\n\n\n```python\n\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        link_list = []\n        while head is not None:\n            val = head.val\n            link_list.append(val)\n            head = head.next\n\n\n        def dfs(link_list,l,r):\n            if l>r:\n                return\n            mid = int((r-l)/2)+l\n            node = TreeNode(link_list[mid])\n            right = dfs(link_list,mid+1,r)\n            left = dfs(link_list,l,mid-1)\n            node.left = left\n            node.right = right\n            return node\n        return dfs(link_list,0,len(link_list)-1)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998490371","body":"### 思路\r\n双指针\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a !=b:\r\n            a = a.next if a.next is not None else headB\r\n            b = b.next if b.next is not None else headA\r\n\r\n        return a\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999427948","body":"### 思路\nhashset\n\n### 代码\n\n\n```python\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        s = set()\n        while head:\n            if head not in s:\n                s.add(head)\n                head = head.next\n            else:\n                return head\n        return None\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000189891","body":"### 思路\nhashmap和双向链表\n\n### 代码\n\n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n\n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000821422","body":"思路:\n递归\n\nclass Solution {\npublic int maxDepth(TreeNode root) {\nif(root == null){\nreturn 0;\n}\nreturn Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\n}\n}\n时间复杂度：O(N)\n空间复杂度：O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993270910","body":"## 代码\n```c++\nclass CustomStack {\npublic:\n    int maxS;\n    vector<int> stack;\n    CustomStack(int maxSize) {\n        maxS=maxSize;\n    }\n    \n    void push(int x) {\n        if(stack.size()<maxS)\n            stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int back=stack.back();\n        stack.pop_back();\n        return back;\n    }\n    void increment(int k, int val) {\n        int bottom=k;\n        if(stack.size()<k)\n            bottom=stack.size();\n        for(int i=0;i<bottom;i++)\n        {\n            stack[i]+=val;\n        }\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994567953","body":"# 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n       stack<char> decode;\n        for(int i = 0; i < s.length(); ++i)\n        {\n            if(s[i] == ']')\n            {\n                string decodeS = \"\";\n                while(decode.top() != '[')\n                {\n                    decodeS += decode.top();\n                    decode.pop();\n                }\n                decode.pop();\n                int num = 0;\n                int base = 1;\n                while(!decode.empty() && isdigit(decode.top()))\n                {\n                    num +=  ((int)decode.top()-48) * base;\n                    decode.pop();\n                    base *= 10;\n                }\n                while(num != 0 )\n                {\n                    for(int j = decodeS.length() - 1; j >= 0; --j)\n                    {\n                        decode.push(decodeS[j]);\n                    }\n                    num--;\n                }\n            }\n            else\n            {\n                decode.push(s[i]);\n            }\n        }\n        string finalString;\n        for(int i = decode.size() - 1; i >= 0; i--)\n        {\n            finalString = decode.top() + finalString;\n            decode.pop();\n        }\n        return finalString;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997204250","body":"# 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr)\n        {\n            return nullptr;\n        }\n        if(head->next == nullptr)\n            return head;\n        ListNode *new_tail, *circle, *new_head;\n        circle = head;\n        int len = 1;\n        for(int i = 0; circle->next != nullptr; ++i)\n        {\n            circle = circle->next;\n            len++;\n        }\n        circle->next = head;\n        len = len - k%len;\n        new_tail = head;\n        while(len > 1)\n        {\n            new_tail = new_tail->next;\n            len--;\n        }\n        new_head = new_tail->next;\n        new_tail->next = nullptr;\n        return new_head;\n        \n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997379098","body":"# 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        ListNode *first_node, *second_node;\n        first_node = head;\n        second_node = head->next;\n        first_node->next = swapPairs(second_node->next);\n        second_node->next = first_node;\n        return second_node;\n    }\n};\n```\n# 思路：递归\n# 复杂度\nO(N), O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999244990","body":"# 思路\n快慢指针\n# 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode *getIntersection(ListNode *head)\n    {\n        ListNode *slow, *fast;\n        slow = head;\n        fast = head;\n        while(fast != nullptr && fast->next != nullptr)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(fast == slow)\n                return slow;\n        }\n        return nullptr;\n    }\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == nullptr)\n            return nullptr;\n        ListNode *pre, *last;\n        pre = getIntersection(head);\n        if(pre == nullptr)\n            return nullptr;\n        last = head;\n        while(pre != last)\n        {\n            pre = pre->next;\n            last = last->next;\n        }\n        return pre;\n    }\n};\n```\n# 复杂度\n时间O(n) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000102554","body":"## 思路：\ndouble linked list + hash table(few modification on official answer)\n## 代码：\n```c++\nclass DLinkListNode{\npublic:\n    int key;\n    int value;\n    DLinkListNode *prev;\n    DLinkListNode *next;\n    DLinkListNode() : key(0), value(0), prev(NULL), next(NULL){};\n    DLinkListNode(int k, int val) : key(k), value(val), prev(NULL), next(NULL){};\n};\nclass LRUCache {\nprivate:\n    DLinkListNode *dummy_head, *dummy_tail;\n    int _capacity;\n    unordered_map<int, DLinkListNode*> key_node;\n    \n    void move_to_head(DLinkListNode *node)\n    {\n        remove_node(node);\n        add_to_head(node);\n    }\n    \n    void remove_node(DLinkListNode *node)\n    {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n        node->next = node->prev = NULL;\n    }\n    \n    void add_to_head(DLinkListNode *node)\n    {\n        DLinkListNode *head = dummy_head->next;\n        dummy_head->next = node;\n        node->next = head;\n        head->prev = node;\n        node->prev = dummy_head;\n    }\n    \n    bool keyExists(int key)\n    {\n        return key_node.count(key) > 0;\n    }\npublic:\n    LRUCache(int capacity) : _capacity(capacity){\n        dummy_head = new DLinkListNode();\n        dummy_tail = new DLinkListNode();\n        dummy_head->next = dummy_tail;\n        dummy_tail->prev = dummy_head;\n    }\n    \n    int get(int key) {\n        if(!keyExists(key))\n        {\n            return -1;\n        }\n        DLinkListNode *new_node = key_node[key];\n        move_to_head(new_node);\n        return new_node->value;\n    }\n    \n    void put(int key, int value) {\n        if(keyExists(key))\n        {\n            DLinkListNode *new_node = key_node[key];\n            new_node->value = value;\n            move_to_head(new_node);\n        }\n        else\n        {\n            if(key_node.size() == _capacity)\n            {\n                DLinkListNode *tail = dummy_tail->prev;\n                remove_node(tail);\n                key_node.erase(tail->key);\n            }\n            DLinkListNode *new_node = new DLinkListNode(key, value);\n            add_to_head(new_node);\n            key_node[key] = new_node;\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000624765","body":"# 思路\n常规递归\n# 代码（c++）\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        int depth = 0;\n        if(root == NULL)\n            return depth;\n        depth = max(maxDepth(root->left), maxDepth(root->right));\n        depth++;\n        return depth;    \n    }\n};\n```\n# 复杂度\n时间：O(n) 空间：O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000975019","body":"# 思路\n递归判断\n# 代码\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == NULL && q == NULL)\n            return true;\n        if(p == NULL || q == NULL)\n            return false;\n        if(p->val != q->val)\n            return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littleworker":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993329296","body":"### 思路\n\n使用TypeScript，栈采用数组进行模拟，直接使用数组的push 和 pop方法，在push和pop时进行长度判断\n\n### 代码\n\n\n```typescript\nclass CustomStack {\n    private arr:number[] =[];\n    private maxSize:number=0;\n    constructor(maxSize: number) {\n      this.maxSize = maxSize\n    }\n\n    push(x: number): void {\n      if(this.arr.length < this.maxSize){\n        this.arr.push(x);\n      }\n    }\n\n    pop(): number {\n        return  this.arr.pop() || -1\n    }\n\n    increment(k: number, val: number): void {\n      const maxNum = Math.min(this.arr.length,k)\n      for(let i=0;i<maxNum;i++){\n        this.arr[i] += val;\n      }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：\n  push,pop: O(1)，其中 N 为数组长度。\n  inc: O(Max(K,N))，其中 K 为操作元素长度，N为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994298220","body":"## 思路\n递归，顺序遍历字符串，遇到左括号，则找到对应的右括号，将左右括号的子串作为参数，进行递归调用；难点在于如何找到当前 左侧括号 对应的 右侧括号\n\n## TypeScript 代码\n```typescript\nfunction decodeString(s: string): string {\n  let num = 0\n  const leftStack:number[]=[];\n  let currentStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    \n    if (!isNaN(Number(char))) {\n      num = num*10 + Number(char)\n    } else if (char === \"[\") {\n      leftStack.push(i)\n      for(let j=i+1;j<s.length;j++){\n        if(s[j] === '['){\n          leftStack.push(j)\n        }else if(s[j] ===']'){\n          leftStack.pop()\n          if(leftStack.length === 0){\n            currentStr += decodeString(s.slice(i+1,j)).repeat(num)\n            i = j\n            break\n          }\n        }\n      }\n      num = 0\n    } else {\n      currentStr += char;\n      num = 0\n    }\n  }\n\n  return currentStr;\n}\n```\n\n## 复杂度\n时间：O(N*N)\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995339880","body":"## 思路\n感觉对JS来说，这个题没什么意义，用数组自带的api就可以了\n\n## 代码\n```typescript\nclass MyQueue {\n    private arr:number[]=[];\n    constructor() {\n      this.arr = []\n    }\n\n    push(x: number): void {\n      this.arr.push(x)\n    }\n\n    pop(): number {\n      return this.arr.shift()\n    }\n\n    peek(): number {\n      return this.arr[0]\n    }\n\n    empty(): boolean {\n      return !this.arr.length\n    }\n}\n```\n\n## 复杂度\n时间：O(1) 都是单个操作","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997650921","body":"## 思路\n树类型的题目，一般我会先考虑使用递归；平衡树，则根节点是链表的中间节点；二叉搜索树即是二叉查找树，左侧节点一定小于右侧节点；因此找到根节点后，左侧的递归调用形成左子树，右侧的递归调用形成右子树\n\n## 代码\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    return buildTree(head,null)\n};\n\nfunction buildTree(left:ListNode,right:ListNode){\n    if(left === right){\n        return null\n    }\n    const mid = getMiddle(left, right);\n    const  root = new TreeNode(mid.val);\n    root.left = buildTree(left, mid);\n    root.right = buildTree(mid.next, right);\n    return root;\n}\n\n// 快慢指针找链表中点\nfunction getMiddle(left:ListNode,right:ListNode):ListNode{\n    let slow = left;\n    let fast = left;\n    while(fast != right && fast.next != right){\n        fast = fast.next;\n        fast = fast.next;\n        slow=slow.next;\n    }\n    return slow\n}\n```\n\n## 复杂度\n- 时间复杂度 O(nlogn)，其中 nn 是链表的长度\n- 空间复杂度 O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998421332","body":"## 思路\n先遍历链表A，用map记录每个节点，再遍历链表B，若B的节点在map中，则说明是相交节点\n\n## 代码\n```typescript\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n    // 先遍历一次链表A，用map存储每个节点是否被访问，\n    // 再遍历链表B，如果该节点已经被访问过，则说明是相交节点\n    const visitMap = new Map()\n    while(headA){\n        visitMap.set(headA,true)\n        headA = headA.next\n    }\n    while(headB){\n        if(visitMap.get(headB)){\n            return headB\n        }\n        headB = headB.next\n    }\n    return null\n};\n```\n\n## 复杂度\n时间：O(M+N)\n空间:   O(M)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999203099","body":"## 思路\r\n和昨天的题类似，还是遍历链表，用map记录访问过的节点，当节点再次被访问时，就是环形入口\r\n\r\n## 代码\r\n```typescript\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n    if(head === null){\r\n        return null\r\n    }\r\n    if(head.next === null){\r\n        return null\r\n    }\r\n    const visitMap = new Map()\r\n    let cur = head\r\n    while(cur){\r\n        if(visitMap.get(cur)){\r\n            return cur\r\n        }else{\r\n            visitMap.set(cur,true)\r\n        }\r\n        cur = cur.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间：O(N)\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999990753","body":"## 思路\n数据存储是key-value的形式，因此自然的想到使用Map存储数据；难点在于put的时候，超出容量时需要先删除最久未被访问的数据，我得思路是：每次get访问时，将map中的key先删掉，再set到map的末尾，在超出容量时，将map的第一个元素删除\n\n## 代码\n```typescript\nclass LRUCache {\n  // key {value,visit}\n  private cacheMap = new Map();\n\n  private capacity = 0;\n  constructor(capacity: number) {\n    this.capacity = capacity;\n  }\n\n  get(key: number): number {\n    if (this.cacheMap.has(key)) {\n      const data = this.cacheMap.get(key);\n      this.cacheMap.delete(key);\n      this.cacheMap.set(key, data);\n      return data;\n    } else {\n      return -1;\n    }\n  }\n\n  put(key: number, value: number): void {\n    // 考虑 key已经存在的情况，则只是更新值\n    if (this.cacheMap.get(key)) {\n      this.cacheMap.delete(key);\n    } else {\n      const size = this.cacheMap.size;\n      if (size >= this.capacity) {\n        // 删除map的第一个元素\n        for (let [iterKey] of this.cacheMap) {\n          this.cacheMap.delete(iterKey);\n          break;\n        }\n      }\n    }\n\n    this.cacheMap.set(key, value);\n  }\n}\n```\n\n## 复杂度\n空间: O(N)\n时间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000587083","body":"## 思路\n简单题，树的题目都考虑使用递归，尤其是深度优先遍历，树的最大深度 = 1 + Math.max(左子树最大深度，右子树最大深度)\n\n## 代码\n```typescript\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxDepth(root: TreeNode | null): number {\n    // 深度优先遍历 DFS\n    if(root === null){\n        return 0\n    }\n    const leftDepth = maxDepth(root.left)\n    const rightDepth = maxDepth(root.right)\n    return Math.max(leftDepth,rightDepth) + 1\n};\n```\n\n## 复杂度：\n时间：O（N） 每个节点都会遍历一次\n空间：O（height） height是树的高度，递归需要栈空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kkstudycoding":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993486331","body":"```java\n\nclass CustomStack{\n    int [] stack;\n    int top;\n    public CustomStack (int maxSize){\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x){\n        if(top!= stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop(){\n        if(top == -1){\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val){\n        int limit = Math.min(k, top + 1);\n        for(int i = 0; i<limit; i++){\n            stack[i] += val;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994727441","body":"class Solution {\n    public String decodeString(String s) {\n        String result = \"\";\n        Stack<String> sta = new Stack<>();\n        \n    for (int i = 0; i < s.length(); i++) {\n        String current = s.charAt(i) + \"\";\n        \n        \n        if (!current.equals(\"]\")) {\n            sta.push(current);\n        }\n        \n        else {\n            \n            String cur = \"\";\n            while (!sta.peek().equals(\"[\")) {\n                cur = sta.pop() + cur;\n            }\n            \n            sta.pop();\n            \n            String p = \"\";\n            while (!sta.isEmpty() && \n            sta.peek().compareTo(\"0\") >= 0 && sta.peek().compareTo(\"9\") <= 0) {\n                p = sta.pop() + p;\n            }\n            int flag = Integer.parseInt(p);\n            \n            String l = cur;       \n            for (int j = 1; j < flag; j++) {\n                **cur += l;** \n            }\n            \n            sta.push(cur);\n        }\n    }\n    \n    while (!sta.isEmpty()) {\n        result = sta.pop() + result;\n    }\n    return result;\n }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-998024955","body":"class Solution{\n    ListNode curr;\n    \n    public TreeNode sortedListToBST(ListNode head){\n        int len = 0;\n        for(ListNode i = head; i != null; i = i.next){\n            len = len + 1;\n        }\n        curr = head;\n        return build(0,len - 1);\n    }\n    \n    TreeNode build (int left, int right){\n        if(left == right){\n            root.val = curr.val;\n            curr = curr.next;\n        }else{\n            int mid = (left + right + 1) / 2;\n            root.left = build(left, mid - 1);\n            root.val = curr.val;\n            curr = curr.next;\n            root.right = build(mid + 1, right);\n        }\n        return root;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998866983","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int dif = 0;\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1.next != null){\n            p1 = p1.next;\n            dif ++ ;\n        }\n        while(p2.next != null){\n            p2 = p2.next;\n            dif -- ;\n        }\n        if(p1 != p2){\n            return null;\n        }\n        p1 = headA;\n        p2 = headB;\n        if(dif > 0){\n            while(dif != 0){\n                p1 = p1.next;\n                dif --;\n            }\n        }\n        else{\n            while(dif != 0){\n                p2 = p2.next;\n                dif ++;\n            }\n        }\n        while(p1 != p2){\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999455041","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993552437","body":"\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length === this.maxSize) return\n    this.list[this.list.length] = x\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.list.length) return -1\n    return this.list.splice(this.list.length - 1, 1)[0]\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < (this.list.length < k ? this.list.length : k); i++) {\n         this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(k)$\n- 空间复杂度：$O(maxSize)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"grendelta":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993572332","body":"## 思路\n\n使用list来模拟栈，push判断list是否已满，pop判断list是否为空，increment取k和list size的较小值\n\n## 代码\n\n\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack),k)):\n            self.stack[i] += val\n\n## 复杂度\n\n时间复杂度 O(N)\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993794311","body":"## 思路\n\n使用DFS来构建decode中复制【】内部内容的功能\n\n## 代码\n\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n\n        def decode(s, pin):\n            res = \"\"\n            time = 0\n            while pin < len(s):\n                if s[pin] in '0123456789':\n                    time = time * 10 + int(s[pin])\n                elif s[pin] == '[':\n                    pin += 1\n                    pin, dec = decode(s, pin)\n                    res += time * dec\n                    time = 0\n                elif s[pin] == ']':\n                    return pin, res\n                else:\n                    res += s[pin]\n                pin += 1\n            return res\n        return decode(s, 0)\n\n## 复杂度\n\n时间复杂度 O(N)\n\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994967119","body":"## 思路\n\n建立两个栈，一个负责输入，一个负责peek和输出\n当peek或者输出时，将输入栈的元素放入输出栈\n\n## 代码\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.stack1 and not self.stack2\n\n\n## 复杂度分析\n\n时间复杂度 O(N)\n\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996096622","body":"## 思路\n\n将arr排序，之后对比arr和排序后的arr的前n项和有多少个相等，就可以分多少组\n\n## 代码\n\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        maximum, res = 0, 1\n        for i in range(len(arr)):\n            maximum = max(arr[i], maximum)\n            if i == len(arr) - 1:\n                break\n            elif min(arr[i+1:]) >= maximum:\n                res += 1\n        return res\n\n## 复杂度\n\n时间复杂度 O(NlogN}\n\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996884085","body":"## 思路\n\n先计算单项链的长度n，并将链尾与链首相连，最后根据n和k的大小关系切断链表\n\n## 代码\n\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        time = n - k % n \n        if time == n:\n            return head\n        \n\n        \n        cur.next = head\n        while time :\n            cur = cur.next\n            time -= 1\n        \n        res = cur.next\n        cur.next = None\n        return res\n\n## 复杂度\n\n时间复杂度 O(N)\n\n空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997469755","body":"## 思路\n\n使用快慢指针实现二分，然后进行递归。\n\n## 代码\n\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n\n## 复杂度\n\n时间复杂度O(N)\n\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998077737","body":"## 思路\n\n使用双指针，分别遍历A和B，完成遍历后指针指向另一个链表的表头。当指针相交时便得到链表相交的节点。\n\n## 代码\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a, b = headA, headB\n        while a != b:\n            if a:\n                a = a.next\n            else:\n                a = headB\n            if b:\n                b = b.next\n            else:\n                b = headA\n        return a\n\n## 复杂度\n\n时间复杂度 O(N)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-998938688","body":"## 思路\n\n使用快慢指针，先寻找是否有环，再使用双指针寻找环的起点\n\n## 代码\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n\n        if not head:\n            return None\n\n        p = head\n        q = head\n        while q.next and q.next.next:\n            p = p.next\n            q = q.next.next\n            if p == q:\n                p = head\n                while p != q:\n                    p = p.next\n                    q = q.next\n                return p\n        return None\n\n## 复杂度\n\n时间复杂度 O(N)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999701875","body":"## 思路\n\n建立一个双向哈希链表\n\n## 代码\n\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.size = 0\n        self.cache = dict()\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n\n    def get(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self.moveToHead(node)\n            return node.value\n        else:\n            return -1\n\n    def put(self, key, value):\n        # 若在cache中\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n\n        # 若不在cache中\n        else:\n            node =  DLinkedNode(key, value)\n            # 添加到head.next\n            self.addToHead(node)\n\n            # 更新cache\n            self.cache[key] = node\n\n            # 满了，要删除tial.prev\n            if self.size > self.capacity: \n                self.cache.pop(self.tail.prev.key)\n                self.remove(self.tail.prev)\n                \n\n    def addToHead(self, node):\n        node.next = self.head.next\n        self.head.next.prev = node\n        node.prev = self.head\n        self.head.next = node\n        self.size += 1\n        \n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.size -= 1\n        return \n\n    def moveToHead(self, node):\n        self.remove(node)\n        self.addToHead(node)\n\n\n## 复杂度\n\n时间复杂度 O(1)\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000611019","body":"## 思路\r\n\r\n进行深度递归\r\n\r\n## 代码\r\n\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\r\n\r\n## 复杂度\r\n\r\n时间复杂度 O(N)\r\n\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000893797","body":"## 思路\n\n递归\n\n## 代码\n\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        else:\n            if p.val == q.val:\n                return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n            else:\n                return False\n\n## 复杂度\n\n时间复杂度O(N)\n\n空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"etrurialegend":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993589821","body":"## 思路\r\n- 用数组初始化栈最大长度和栈顶位置\r\n- push：不超过最大长度时才可操作：数组模拟的栈顶加入push的值同时栈顶的索引加一\r\n- pop：栈顶索引大于0时才可操作：栈顶索引-1并返回此时栈顶的值\r\n- increment：遍历栈逐个增加val直至到k\r\n## 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n  this.top = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.top < this.maxSize) {\r\n    this.stack[this.top] = x;\r\n    this.top += 1;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.top <= 0) return -1;\r\n  this.top -= 1;\r\n  return this.stack[this.top];\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  if (!this.stack.length) return;\r\n  for(let i = 0; i < this.maxSize; i++) {\r\n    if (i === k) break;\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n## 复杂度\r\n时间复杂度：O(k) k为increment的长度\r\n空间复杂度：O(maxSize) maxSize是初始化时栈的长度","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000726073","body":"## 思路\r\n- DFS \r\n- BFS\r\n## 代码\r\n\r\n### DFS\r\n```go\r\nfunc maxDepth(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\tleft := maxDepth(root.Left)\r\n\tright := maxDepth(root.Right)\r\n\treturn max(left, right) + 1\r\n}\r\nfunc max(a, b int) int {\r\n\tif a > b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n### BFS\r\n```go\r\nfunc maxDepthBFS(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\tqueue := []*TreeNode{}\r\n\tqueue = append(queue, root)\r\n\tlevel := 0\r\n\tfor len(queue) > 0 {\r\n\t\tsize := len(queue)\r\n\t\tfor size > 0 {\r\n\t\t\thead := queue[0]\r\n\t\t\tqueue = queue[1:]\r\n\t\t\tif head.Left != nil {\r\n\t\t\t\tqueue = append(queue, head.Left)\r\n\t\t\t}\r\n\t\t\tif head.Right != nil {\r\n\t\t\t\tqueue = append(queue, head.Right)\r\n\t\t\t}\r\n\t\t\tsize--\r\n\t\t}\r\n\t\tlevel++\r\n\t}\r\n\treturn level\r\n}\r\n```\r\n## 复杂度\r\n### DFS\r\n时间复杂度：O(N)，N为二叉树节点数\r\n空间复杂度：O(level)，level为二叉树层级数\r\n### BFS\r\n时间复杂度：O(N)，N为二叉树节点数\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay214":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993660594","body":"## 思路：\njs写起来很方便，直接用数组模拟\n\n## 代码：\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.pool = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.pool.length < this.maxSize) {\n        this.pool.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const res = this.pool.pop()\n    return res !== undefined ? res : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let len = this.pool.length\n    for (let i = 0; i < k; i++) {\n        if (i < len) {\n            this.pool[i] += val\n        } else {\n            break\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度\n时间复杂度： push 和 pop 为 O(1)，increment 时间复杂度 O(K)，K 为 题目中的 k 和 数组长度两个值中较小的一个。\n空间复杂度：不算数组存储空间的话其他操作是O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923679","body":"## 思路：\n/**\n * @param {string} s\n * @return {string}\n想半天不会，看了官方思路\n使用栈\n 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n如果当前的字符为字母或者左括号，直接进栈\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\n */\n## 代码：\n```js\nvar decodeString = function(s) {\n    let tmp = []\n    let str = ''\n\n    s = s.split('')\n    for (let i = 0; i < s.length; i++) {\n        if (s[i]=== '[' || (s[i] !== ']'&&isNaN(+s[i]))) {\n            tmp.push(s[i])\n        } else if (s[i] === ']') {\n            let ss = ''\n            while ((str = tmp.pop()) !== '[') {\n                ss = str + ss\n            }\n            const num = tmp.pop()\n            tmp.push(Array(num).fill(ss).join(''))\n\n        } else if (typeof +s[i] === 'number') {\n           let num = s[i]\n           while (i+1 < s.length && !isNaN(+s[i+1])) {\n               num += s[++i]\n           }\n           tmp.push(+num)\n        } \n    }\n\n    return tmp.join('')\n};\n```\n## 复杂度：\n时间 O(S),空间O(S)，其中S为字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995942809","body":"```js\nvar MyQueue = function() {\n    this.queue = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.queue.push(x)\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.queue.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.queue[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.queue.length === 0\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997409137","body":"## 思路:\n主要用到三个临时变量\nret先保存交换后的头结点，即head.next\npre存储交换前的位置，tmp当前要与下一个节点交换的节点，循环判断tmp & tmp.next，没有tmp.next即当前只有一个节点不需要交换\n## 代码：\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) {\n        return head\n    }\n    let tmp = head\n    let pre = null\n    const ret = head.next\n    while (tmp && tmp.next) {\n        const t = tmp.next\n        tmp.next = t.next\n        t.next = tmp\n        if (pre) {\n            pre.next = t\n        }\n        pre = tmp\n        tmp = tmp.next\n    }\n    return ret\n};\n```\n## 复杂度分析：\n时间复杂度：O(n)，n即为链表长度，空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997980705","body":"## 思路：\r\n先转为数组，然后递归取中位数做父节点，\r\n## 代码：\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    let link = []\r\n    while (head) {\r\n        link.push(head.val)\r\n        head=  head.next\r\n    }\r\n    function translateToTree(start, end) {\r\n        if (start > end) {\r\n            return null\r\n        }\r\n\r\n        const middle = Math.floor((start + end)/2)\r\n        const node = new TreeNode(link[middle])\r\n        node.left = translateToTree(start, middle - 1)\r\n        node.right = translateToTree(middle + 1, end)\r\n        return node\r\n    }\r\n\r\n    return translateToTree(0, link.length - 1)\r\n};\r\n```\r\n## 复杂度分析：\r\n时间复杂度O(n)，空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998868054","body":"## 思路：\n先计算两条链表长度差值step，然后较长的链表先走step后两条链表再一起走，若有节点相同即是相交节点。循环结束没有的话就返回null\n## 代码：\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let n = 0\n    let m = 0\n    let a = headA\n    let b = headB\n    while (a || b) {\n        if (a) {\n            n++\n            a = a.next\n        }\n        if (b) {\n            m++\n            b = b.next\n        }\n    }\n    let step = Math.abs(n - m)\n    a = n > m ? headA : headB\n    while (step && a) {\n        a = a.next\n        step--\n    }\n    b = n > m ? headB : headA\n    while (a && b) {\n        if (a === b) {\n            return a\n        }\n        a = a.next\n        b = b.next\n    }\n    return null\n};\n```\n## 复杂度分析：\n时间复杂度O(n + n)，n为较长链表的长度，空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999671993","body":"# 思路\n### 1，用hash存储判断\n## 代码\n```js\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (!head || !head.next) return null\n    if (head.next.next === head) return head  \n\n    const cacheMap = new Map()\n    let node = head\n    while (node) {\n        if (cacheMap.has(node)) {\n            return node\n        }\n        cacheMap.set(node, 1)\n        node = node.next\n    }\n\n    return null\n\n};\n````\n## 复杂度分析：\n时间O(N)，空间(N)\n\n### 2.  快慢指针\n## 代码\n```js\nvar detectCycle = function(head) {\n    if (!head || !head.next) return null\n    if (head.next.next === head) return head  \n\n    let slow = head\n    let fast = head\n    while (fast && fast.next) {\n        slow = slow.next\n        fast = fast.next.next\n         if (slow === fast) {\n            slow = head\n            break\n        }\n    }\n    if (slow !== head) return null\n    while (slow !== fast) {\n        slow = slow.next\n        fast = fast.next\n    }\n    return slow\n\n};\n```\n## 复杂度\n时间O(N)，空间O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000883425","body":"## 代码\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) return 0\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n};\n```\n## 复杂度\n空间log(H)，H为树的高度，时间O(N)，N 为节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001037689","body":"## 思路\n递归\n\n## 代码\n```js\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    \n    if (q === p && p === null) {\n        return true\n    }\n    \n    if (!(q && p)) {\n        return false\n    }\n\n    return p.val === q.val &&  isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n    \n};\n```\n## 复杂度\n时间O(N),N为节点数。空间O(H)，H为树的高度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"goredfish":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993660929","body":"**思路**\n\n用array作为base\n\n**复杂度分析**\n\npop\\push: O(1)\n\ninc: O(k)\n\n**代码**\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n\n    }\n    \n    public void push(int x) {\n        if (top == stack.length - 1) {\n            return;\n        }\n        stack[++top] = x;\n    }\n    \n    public int pop() {\n        if(top == -1) {\n            return -1;\n        }\n        return stack[top--];\n\n    }\n    \n    public void increment(int k, int val) {\n        int l = stack.length<k? stack.length:k;\n        for (int i = 0; i<l; i++) {\n            stack[i] = stack[i] + val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993864633","body":"**代码**\n```\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度O（n）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999274492","body":"**代码**\n\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (true) {\n            if (fast == null || fast.next == null) return null;\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) break;\n        }\n        fast = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return fast;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arteecold":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993801383","body":"#思路\n持续进栈 遇到]开始清 一对[]为一次记录数字的信号\n#代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n#复杂度\nO(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997401553","body":"# 普通递归但是一对一对的换着来？\r\n```py\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        next = head.next\r\n        head.next = self.swapPairs(next.next)\r\n        next.next = head\r\n        return next\r\n```\r\n# 时间复杂度是O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000657553","body":"# 相比于前几天的栈 递归的开始很友好 题解里的产品经理的想法很贴切\r\n\r\n```py\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```\r\n\r\n# O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001100647","body":"# 看评论里有老哥还能画出来二叉树图 真猛\n```py\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root, cur):\n            if not root: \n                return 0\n            if not root.left and not root.right: \n                 return cur * 10 + root.val\n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n        return dfs(root, 0)\n```\n# O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sujit197":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994202560","body":"\n## 思路\n使用两个栈，一个记录数字，一个记录字符串，当遇到数字是压人数字栈，遇到'[' 将'['前的字符串压人字母栈，遇到']',弹出字符串以及数字，并相乘，接入之前的字符串。\n\n## 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> stackInt = new Stack<>();\n        Stack<String> stackStr = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for(Character c : s.toCharArray()){\n            if(c>='0'&&c<='9'){\n                multi = multi*10 + Integer.parseInt(String.valueOf(c));\n            }else if (c=='['){\n                stackInt.push(multi);\n                stackStr.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }else if (c==']'){\n                int index = stackInt.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i = 0; i<index;i++){\n                    temp.append(res);\n                }\n                res = new StringBuilder(stackStr.pop()+temp);\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n\n    }\n}\n```\n\n### 复杂度\n\n空间复杂度：O(N)\n\n时间复杂度：O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-996879129","body":"## 思路\n首先得到链表长度length，将尾节点与头节点相连，在移动length-k%length个节点后将链表断开；\n## 代码（JAVA）\n\n```java \nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return head;\n        }\n        ListNode temp = head;\n        int length = 1;\n        while(temp.next!=null){\n            length++;\n            temp = temp.next;\n        }\n        temp.next = head;\n        \n        for (int i = 0;i<length-k%length;i++){\n            temp = temp.next;\n        }\n        ListNode res = temp.next;\n        temp.next = null;\n        return res;\n\n    }\n}\n```\n\n## 复杂度\n时间复杂度： 需要遍历链表O（N）\n空间复杂度：无需额外空间 O（1）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997321959","body":"## 思路\n递归，将head.next指针指向swap后的节点，head.next.next指向head\n## 代码\n``` java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null || head.next==null){\n            return head;\n        }\n        ListNode newNode = head.next;\n        head.next = swapPairs(newNode.next);\n        newNode.next = head;\n        return newNode;\n\n    }\n}\n```\n## 复杂度\n时间复杂度： O（N）\n\n空间复杂度： O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997865502","body":"## 思路\n由题目得有序链表，可知要得到平衡二叉树，其根节点应在链表中点处，因此构造函数获取链表中点，根节点左侧子树由左半边链表用同样方法构建，因此可用递归的方法。\n## 代码\n``` java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head,null);\n    }\n    public ListNode getMid(ListNode left , ListNode right){\n        ListNode fast = left;\n        ListNode slow = left;\n        while(fast!=right&&fast.next!=right){\n            fast = fast.next.next;\n            slow = slow.next;\n            \n        }\n        return slow;\n    }\n    public TreeNode buildTree(ListNode left,ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMid(left,right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n}\n```\n## 复杂度\n时间复杂度： 递归遍历链表O(logN*N)\n\n空间复杂度：O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998471882","body":"## 思路\n做过好几次，双指针指向两个头结点，指针指向null，换向另一个头结点，当两个指针相遇时，便是交点。\n## 代码\n\n``` java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null|| headB == null){\n            return null;\n        }\n        ListNode tempA = headA;\n        ListNode tempB = headB;\n       while(tempA!=tempB){\n           tempA = tempA==null?headB:tempA.next;\n           tempB = tempB==null?headA:tempB.next;\n       }\n       return tempA;\n        \n    \n}\n}\n```\n## 复杂度\n时间复杂度O（m+n）;\n\n空间复杂度O（1）；\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999397449","body":"## 思路\n快慢指针，画一下图就能感受出来，若有环，两个指针必定相遇，此时设置指针指向头结点，与慢指针同时移动，当两结点相遇时则为交点。\n## 代码\n``` java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        while(head == null|| head.next == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode pre = head;\n        while(fast!=null && fast.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(fast == slow){\n                while(slow!=pre){\n                    slow = slow.next;\n                    pre = pre.next;\n                }\n                return pre;\n            }            \n                    \n        }\n        \n        return null;\n        \n    }\n}\n```\n## 复杂度\n时间复杂度 O(N)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000393660","body":"``` java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000799684","body":"## 思路\n递归\n## 代码\n``` java\nclass Solution {\n    int deep ;\n    public int maxDepth(TreeNode root) {\n        if (root == null){\n            return 0;\n        }        \n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        deep = Math.max(left,right)+1;\n        return deep;              \n    }\n}\n```\n## 复杂度\n时间复杂度   O(N) \n\n空间复杂度   O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000992265","body":"## 思路\n递归，深度优先搜索\n## 代码\n``` java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {   \n        if(p == null && q == null){\n            return true;\n        }else if(p == null || q==null){\n            return false;\n        }else if (p.val != q.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left)&& isSameTree(p.right,q.right);\n    }\n}\n```\n## 复杂度\n时间复杂度O(N);\n\n空间复杂度O(1);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"li65943930":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994335243","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                tmp = ''\n                mul = ''\n                while stack and stack[-1] != '[':\n                    tmp = stack.pop() + tmp\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    mul = stack.pop() + mul    \n                tmp = tmp * int(mul)\n                stack.append(tmp)\n            else:\n                stack.append(c)\n        return ''.join(stack)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997288176","body":"var swapPairs = function (head) {\n  if (!head || !head.next) return head;\n  let nextNode = head.next;\n  head.next = swapPairs(nextNode.next);\n  nextNode.next = head;\n  return nextNode;\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999129589","body":"if (head == null || head.next == null) return null;\nlet fast = (slow = head);\ndo {\n  if (fast != null && fast.next != null) {\n    fast = fast.next.next;\n  } else {\n    fast = null;\n  }\n  slow = slow.next;\n} while (fast != slow);\nif (fast == null) return null;\nfast = head;\nwhile (fast != slow) {\n  fast = fast.next;\n  slow = slow.next;\n}\nreturn fast;","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001058538","body":"function sumNumbers(root) {\n  let sum = 0;\n  let curLevel = [];\n  if (root) {\n    curLevel.push(root);\n  }\n  while (curLevel.length) {\n    let nextLevel = [];\n    for (let i = 0; i < curLevel.length; i++) {\n      let cur = curLevel[i];\n      if (cur.left) {\n        cur.left.val = cur.val * 10 + cur.left.val;\n        nextLevel.push(cur.left);\n      }\n      if (cur.right) {\n        cur.right.val = cur.val * 10 + cur.right.val;\n        nextLevel.push(cur.right);\n      }\n      if (!cur.left && !cur.right) {\n        sum += cur.val;\n      }\n      curLevel = nextLevel;\n    }\n  }\n  return sum;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengyufeng6":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995472136","body":"思路：双栈\n代码：\nclass MyQueue {\npublic:\n    stack<int> s_in,s_out; \n    MyQueue() {}\n    \n    void push(int x) {\n        s_in.push(x);\n    }\n    \n    int pop() {\n        if(s_out.empty())\n        {\n            while(!s_in.empty())\n            {\n                s_out.push(s_in.top());\n                s_in.pop();\n            }\n        }\n        int x = s_out.top();\n        s_out.pop();\n        return x;\n            \n    }\n    \n    int peek() {\n        if(s_out.empty())\n        {\n            while(!s_in.empty())\n            {\n                s_out.push(s_in.top());\n                s_in.pop();\n            }\n        }\n        return s_out.top();\n    }\n    \n    bool empty() {\n       return s_in.empty() && s_out.empty();\n};\n复杂度：\n时间复杂度O(1);\n空间复杂度O(n);","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999497774","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set<ListNode *> visited;\n        while (head != nullptr) {\n            if (visited.count(head)) {\n                return head;\n            }\n            visited.insert(head);\n            head = head->next;\n        }\n        return nullptr;\n    }\n};\n不会，抄题解的","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiruizhang":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995736386","body":"```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    var p = this.outStack.pop();\n    this.outStack.push(p);\n    return p;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.outStack.length && !this.inStack.length;\n};\n```\n复杂度分析\n\n时间复杂度：push/empty操作是O(1)，pop/peek操作平均也是O(1)\n空间复杂度：O(N)，N为队列元素数","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998796827","body":"思路：\r\n1. 基于双指针使用两个参数pA，pB分别指向A、B链表；\r\n2. 假设A链表长为m，B链表长为n;\r\n3. 我们先假设不相交，让两个指针分别遍历A、B链表，即循环m+n次，他们的步数是一致且节点是相同的，为null；\r\n4. 假设相交，则在循环m+n次之前就重合了。\r\n\r\n容易出错的点：需要对指针的遍历边界点进行处理。\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    // 使用双指针\r\n    var pA = headA;\r\n    var pB = headB;\r\n    while(pA != pB) {\r\n        pA = pA == null ? headB : pA.next;\r\n        pB = pB == null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n};\r\n```\r\n复杂度分析：\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000642228","body":"### 思路\n递归左右子树，取较大值，每次深度加1，边界值为null。\n### 代码\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(root == null) return 0;\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bubblefu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995796019","body":"### 思路\r\n栈可以用list来表示，两个list可以实现一个先入先出的队列\r\n设置in_stack表示正序，out_stack表示倒序，在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。\r\n\r\n最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.in_stack = []\r\n        self.out_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.in_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.out_stack:\r\n            while self.in_stack:\r\n                self.out_stack.append(self.in_stack.pop())\r\n        return self.out_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.out_stack.append(ans)\r\n        return ans\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.in_stack) == 0 and len(self.out_stack) == 0\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度     O(n)\r\n空间复杂度 ：O(n) 建立了两个列表充当栈\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coder123xt":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995875223","body":"# 两种做法\n##第一种，借鉴解析，直观形象，入栈出栈\n\n``` javascript\n var MyQueue = function() {\n  this.instack = []\n  this.outstack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.instack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if(!this.outstack.length){\n    this.in2out()\n  }\n  return this.outstack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if(!this.outstack.length){\n    this.in2out()\n  }\n  return this.outstack[this.outstack.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.instack.length === 0 && this.outstack.length === 0\n};\n\nMyQueue.prototype.in2out = function(){\n  while(this.instack.length){\n    this.outstack.push(this.instack.pop())\n  }\n}\n\n## 第二种做法 ， 虽然力扣提交成功，但是没有体现出入栈和出栈的过程\n\n\nvar MyQueue = function() {\n  this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  return this.stack.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack.length === 0\n};\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996793978","body":"```js\nvar maxChunksToSorted = function(arr) {\n  let sortedArr = [...arr]\n  sortedArr.sort((a, b) => a - b)\n  let sum1 = sum2 = count = 0\n\n  for(let i = 0; i < arr.length; i++){\n    sum1 += arr[i]\n    sum2 += sortedArr[i]\n\n    if(sum1 === sum2){\n      count++\n      sum1 = sum2 = 0\n    }\n  }\n  return count\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babyyre":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995877769","body":"双栈\npython：\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = [] #进队列\n        self.stack2 = [] #出队列\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.stack1 and not self.stack2:\n            self.stack2.append(x)\n        else:\n            while self.stack2:\n                self.stack1.append(self.stack2.pop())\n\n            self.stack1.append(x)\n\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n\n\n\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.empty:\n            return \"empty\"\n        return self.stack2.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.empty:\n            return \"empty\"\n        return self.stack2[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.stack2 == []\n\n时间O(1)\n空间O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999599372","body":"快慢双指针，先看是否能相遇，相遇后，一个指针指向head，另一个不变。速度均改为1，继续移动、相遇。相遇点即是入环点。\n\nclass Solution(object):\n    def detectCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow is fast:\n                # 相遇，slow指向head\n                slow = head\n                while slow is not fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow\n        return None\n\nO(N)\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haixiaolu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996461814","body":"## 思路\r\n这题研究了半天也不会， 实在是没辙了， 最后结合单调栈的模版还有官方解答匹配出来的代码\r\n\r\n基本就是结合单调栈的递增的概念，pop出栈中小的元素，保留最大的元素，返回的是栈的长度\r\n\r\n## Code / Python\r\n\r\n```python\r\n  def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \r\n        # Initialize a stack \r\n        stack = []\r\n        \r\n        # loop through all the element in arr \r\n        for element in arr:\r\n            \r\n            # find the largest value in the stack and set to -1\r\n            # because stack is increasing\r\n            \r\n            if stack and stack[-1] > element:\r\n                \r\n                # set the largest value in stack\r\n                larger = stack[-1]\r\n                \r\n                # keep the stack increasing (递增)\r\n                while stack and stack[-1] > element: stack.pop()\r\n                stack.append(larger)\r\n                \r\n            else:\r\n                stack.append(element)\r\n\r\n        return len(stack)\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n)\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997149009","body":"## 思路：\r\n将链表每个节点向右移动k个位置，相当于把链表的后面K % len 个节点移到链表的最前面\r\n-  求链表的长度\r\n-  找出倒数第 K + 1 个节点\r\n-  将链表的倒数第K + 1个节点和倒数第K个节点断开，并把后半部分拼接到链表的头部\r\n\r\n## 代码 / Python\r\n\r\n```Python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next: \r\n            return head\r\n        \r\n        # length of the linked List\r\n        length = 0\r\n        cur = head\r\n        while cur:\r\n            length += 1\r\n            cur = cur.next\r\n            \r\n        # mod of the length\r\n        k %= length\r\n        if k == 0:\r\n            return head \r\n        \r\n        # Two pointers\r\n        fast, slow = head, head\r\n        while k:\r\n            fast = fast.next\r\n            k -= 1\r\n        \r\n        # the distance between fast and slow is K: fast points K + 1 node\r\n        # when fast.next is null, fast points to last node, slow points the K + 1 of last node\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        # new head is the k of last node \r\n        new_head = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        return new_head\r\n```\r\n\r\n## 时空间复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997405132","body":"## 思路\r\n\r\n递归\r\n\r\n## 代码 / Python\r\n\r\n```python\r\ndef swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head \r\n        \r\n        cur = head\r\n        next = cur.next \r\n        cur.next = self.swapPairs(next.next)\r\n        next.next = cur\r\n        return next \r\n```\r\n\r\n## 时空间复杂度分析\r\n\r\n- 时间复杂度： O(N)\r\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997589122","body":"## 思路： 不会， 看官方题解的code， 只会设定双指针\r\n## 代码 / Python\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return head\r\n        \r\n        pre = None\r\n        slow = fast = head\r\n        \r\n        # use two pointer to find the middle point of the linked list\r\n        # fast pointer goes 2 steps each time, slow pointer 1 step each time,\r\n        # the slow pointer is the middle point after fast pointer finish\r\n        \r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow \r\n            slow = slow.next \r\n        if pre:\r\n            pre.next = None\r\n        # current node as the head \r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        \r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        \r\n        return node \r\n```\r\n## 时空间复杂度分析：\r\n- 时间复杂度： O(logn)\r\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998412352","body":"## 思路\r\n\r\n讲义里的双指针思路\r\n-  使用a, b两个指针分别指向A， B这两条链表的头， 两个指针同时向后移动\r\n- 当a到达链表的尾部时， 重定位到链表B的头节点\r\n- 当b到达链表的尾部时，重定位到链表A的头节点\r\n- a， b指针相遇的点位相交的起始点， 否则没有相交点\r\n\r\n## 代码 / Python\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        # two pointers\r\n\r\n        a, b = headA, headB\r\n\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n## 复杂度分析\r\n- Time: O(n + m). n, m are the length of the two Linked List\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999257822","body":"## 思路： 根据链表讲义里的双指针模版\r\n- 判断边界是否为空\r\n- 定义快慢指针\r\n     - 快指针每次走两步\r\n     - 慢指针每次走一步\r\n- 如果快指针和慢指针相遇\r\n     - 重新把快指针定义到链表的头部\r\n- 当快指针和慢指针没相遇的时候\r\n    - 快指针走一步\r\n    - 慢指针走一步\r\n- 返回快指针\r\n\r\n## 代码 / Python\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        \r\n        if not head:\r\n            return None\r\n        \r\n        # Initialize two pointers\r\n        fast = slow = head\r\n        \r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            \r\n            # when two pointers meet\r\n            if fast == slow:\r\n                fast = head\r\n                \r\n                # when two pointers not meet, move one step\r\n                while fast != slow:\r\n                    fast = fast.next \r\n                    slow = slow.next\r\n\r\n                return fast \r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度:  O(n) \r\n- 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-999993744","body":"## 思路\r\n- 用哈希表来存储键和值， 设定哈希表的长度等于capacity\r\n   - 哈希表存储的键和输入的键一样\r\n   - 哈希表的值可以当作一个指针指定node的值\r\n - 用双链表来记录最近最少和最多用的node\r\n   - 可以设定两个dummy node， left = 最近最少用的， right = 最近最多用到的\r\n  \r\n## 代码 / Python\r\n```Python\r\nclass Node:\r\n    def __init__(self, key, val):\r\n        self.key, self.val = key, val\r\n        \r\n        # Two pointers\r\n        self.prev = self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cap = capacity\r\n        \r\n        # hashmap \r\n        self.cache = {}   # map key to node\r\n        \r\n        # dummy nodes for least used and most used: Left = LRU, right= most recent\r\n        self.left, self.right = Node(0, 0), Node(0, 0)\r\n        \r\n        # nodes should be connected\r\n        self.left.next, self.right.prev = self.right, self.left\r\n        \r\n    # remove node from the list\r\n    def remove(self, node):\r\n        prev, next = node.prev, node.next\r\n        prev.next, next.prev = next, prev\r\n    \r\n    # insert node at right\r\n    def insert(self, node):\r\n        prev, next = self.right.prev, self.right\r\n        prev.next = next.prev = node\r\n        node.next, node.prev = next, prev\r\n        \r\n        \r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            # update most recent\r\n            self.remove(self.cache[key])\r\n            self.insert(self.cache[key])\r\n            return self.cache[key].val\r\n        return - 1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.remove(self.cache[key])\r\n        self.cache[key] = Node(key, value)\r\n        self.insert(self.cache[key])\r\n        \r\n        # check if the length exceed the capacity\r\n        if len(self.cache) > self.cap:\r\n            # remove from the list and delete the LRU from the hashmap\r\n            lru = self.left.next\r\n            self.remove(lru)\r\n            del self.cache[lru.key]\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(1)\r\n- 空间复杂度:   O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000604892","body":"## 思路\r\n- 递归\r\n\r\n## 代码 / Python\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n)\r\n- 空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1000950344","body":"## 思路： DFS\r\n- 边界\r\n   - 比较两棵树都为空， 返回True\r\n   - 只有一棵树为空， 返回False\r\n- DFS\r\n  - 如果值不同， 返回False\r\n  - 递归两棵树的左右子树\r\n\r\n## 代码 / Python\r\n```Python\r\n def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False \r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n## 复杂度分析：\r\n- 时间复杂度： O(n) \r\n- 空间复杂度： O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001101855","body":"## 思路\r\n想到了用DFS和BFS， 但是不明白如果头节点 -> 左子树 和 头节点-> 右子树相加的和如果进1怎么处理， 还是太菜！！！\r\n\r\n## 代码 / Python\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        # DFS\r\n        def dfs(root, cur):\r\n            if not root:\r\n                return 0\r\n            if not root.left and not root.right:\r\n                return cur * 10 + root.val\r\n            return dfs(root.left, cur* 10 + root.val) + dfs(root.right, cur * 10 + root.val)\r\n        return dfs(root, 0)\r\n```\r\n\r\n## 复杂度分析： \r\n- 时间复杂度： O(N)\r\n- 空间复杂度： O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingowl0101":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/10#issuecomment-996586963","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] forward = new int[n];\n        int[] backward = new int[n];\n\n        forward[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            forward[i] = Math.max(forward[i-1], arr[i]);\n        }\n\n        backward[n - 1] = arr[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            backward[i] = Math.min(backward[i + 1], arr[i]);\n        }\n\n        int res = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (forward[i] <= backward[i + 1]) res++;\n        }\n\n        return res + 1;\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000845500","body":"class Solution {\n    int max = 0;\n\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        depth(root, 1);\n        return max;\n    }\n\n    public void depth(TreeNode root, int dep) {\n        if (dep > max) max = dep;\n        if (root.left != null) depth(root.left, dep + 1);\n        if (root.right != null) depth(root.right, dep + 1);\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoyuqinlaura":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997138599","body":"思路：\nloop through whole list, then 首尾相连，position = leng - k - 1处，断开连接，res = position.next; then position.next = NULL\nO(N), O(1)\n\n代码：\nclass solution{\n     public static ListNode reverseLink(ListNode head, int k) {\n             ListNode res = NULL;\n             ListNode cur = head;\n            //corner case\n            if (head == NULL || head.next = NULL) return head;\n           \n           int length = 1;\n            while (cur.next != NULL) {\n                   cur = cur.next;\n                  length++;\n               }\n            \n           //here connect head and tail\n           cur.next = head;\n          int pos = length - k - 1;\n          \nListNode tail = head;\nfor (int i = 0; i <= pos; i++) {\n       tail = tail.next;\n}\n\nres = tail.next;\ntail.next = NULL;\n\n\nreturn res;\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alduinleung":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997152444","body":"# JavaScript\r\n---\r\n## 思路 （成环）\r\n1.设置一个指针指向头节点，然后把头节点和尾节点连到一起构成环。\r\n2.然后顺时针移动指针k次，因为k也许会很大并且成环以后是取模操作。\r\n3.移动len - k 个位置，最后断开即可。\r\n关键是要理解为什么要移动到len - k 个位置上。\r\n\r\n**[1,2,3,4,5] and k =2, result = [4,5,1,2,3]。 实际上是在n -k个 位置进行断开的**\r\n---\r\n``` javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    // cornor case\r\n      if(!(head &&  head.next)){\r\n          return head;\r\n      }\r\n      // pointer for head \r\n      // length for calculate the ammount of the nodes\r\n      let p = head; let length=1;\r\n      // move p to the tail \r\n      while(p.next){\r\n          p = p.next;\r\n          length++;      \r\n      }\r\n    // make the linklist to a circle\r\n      p.next = head;\r\n    // actually  moving the nodes;\r\n    let moving = length- (k%length);\r\n     while(moving){\r\n        p = p.next;\r\n        moving--;\r\n     }\r\n     // generate a tmp node splice position\r\n     let tmp = p.next;\r\n     p.next =null;\r\n     return tmp;\r\n};\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000516780","body":"## DFS\r\n\r\n``` javaScript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(!root){\r\n        return 0\r\n    }else{\r\n        return 1+Math.max(maxDepth(root.left),maxDepth(root.right))  // 注意子问题这里要+1\r\n    }\r\n};\r\n\r\nref: https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-yi-dong-shi-6kil/\r\n``` \r\n- 时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yisa2":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997219481","body":"```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head) return nullptr;\n        ListNode *p=head;\n        int count=1;\n        for(; p->next; ++count){\n            p=p->next;\n        }\n        p->next=head;\n        k=k%count;\n        for(int i=0; i<count-k; ++i){\n            p=p->next;\n            head=head->next;\n        }\n        p->next=nullptr;\n        return head;\n    }\n};\n```\n时间复杂度 `O(N)`\n空间复杂度 `O(1)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sherryhanyu":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/12#issuecomment-997222260","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head\n\n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n\n        \n\n        def rotate(head):\n            \n            pin1 = head\n            while pin1.next is not None:\n                pin1 = pin1.next\n\n            pin2 = head\n            while pin2.next.next is not None:\n                pin2 = pin2.next\n\n            pin2.next = None\n\n            pin1.next = head\n\n            return pin1\n\n        k = k%n\n        for i in range(k):\n            head = rotate(head)\n\n        return head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997345241","body":"Python3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        # 设置虚拟节点\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        left = dummy\n        right = dummy.next\n        # 循环停止：偶数节点：right==None;奇数节点：right.next==None\n        while right and right.next:\n            \"\"\"\n            例子：[1,2,3,4] 交换2和3\n            \"\"\"\n            node1 = left.next  # node1 is 2\n            node2 = right.next  # node2 is 3\n            left.next = node2  # 1->3->4\n            node1.next = node2.next  # 2->4  \n            node2.next = node1  # 3->2\n            # 1->3->2->4\n            left = node1  # left is 2\n            right = node1.next  # right is 4\n        return dummy.next\n\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n## 其它解法\n\n递归\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998862980","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 链表，哈希表\n\n## 思路\n- 判断headB的链表的Node是否在headA链表中\n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        first = headA\n        second = headB\n        dicA = {}\n        while first:\n            dicA[first] = 1\n            first = first.next\n\n        while second:\n            if second in dicA:\n                return second\n            second = second.next\n        \n        return None\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"juliashiweihuang":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997270771","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        strNum = \"\"\r\n        for i in range(len(num)):\r\n            strNum += str(num[i])\r\n        numInt = int(strNum) + k\r\n        lst = []\r\n        if (numInt == 0):\r\n            return [0]\r\n        while numInt != 0:\r\n            remainder = numInt % 10\r\n            lst.append(remainder)\r\n            numInt = numInt // 10\r\n        lst_reverse = []\r\n        j = len(lst) - 1\r\n        while (j >= 0):\r\n            lst_reverse.append(lst[j])\r\n            j -= 1\r\n        return lst_reverse\r\n        \r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001108039","body":"```\r\ndef sumNumbers(self, root: TreeNode):\r\n        root_to_leaf = 0\r\n        stack = [(root, 0) ]\r\n        \r\n        while stack:\r\n            root, curr_number = stack.pop()\r\n            if root is not None:\r\n                curr_number = curr_number * 10 + root.val\r\n                # if it's a leaf, update root-to-leaf sum\r\n                if root.left is None and root.right is None:\r\n                    root_to_leaf += curr_number\r\n                else:\r\n                    stack.append((root.right, curr_number))\r\n                    stack.append((root.left, curr_number))\r\n                        \r\n        return root_to_leaf\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davidcaoyh":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997274660","body":"#Add an sentinel before head\r\n#create an dummy point to sentinel\r\n#every iteration point dummy to head.next to link two sets\r\n#every iteration move both dummy and head to the next\r\n#when finishing, getting the expected result\r\n\r\n\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n        sentinel = ListNode(0)\r\n        sentinel.next = head\r\n        dummy = sentinel\r\n        \r\n        while head and head.next:\r\n            dummy.next = head.next\r\n            dummy = head.next\r\n            head.next= head.next.next\r\n            dummy.next = head\r\n            dummy = dummy.next\r\n            head= head.next\r\n            \r\n            \r\n        return sentinel.next\r\n            \r\n        ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"superduduguan":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997343663","body":"class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        prev = dummy\n        dummy.next = head\n        \n        while head and head.next:\n            sec = head.next\n            prev.next = sec\n            head.next = sec.next\n            sec.next = head\n            prev = prev.next.next\n            head = head.next\n            \n        return dummy.next","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001105411","body":"def sumNumbers(self, root: Optional[TreeNode]) -> int:\n  def dfs(root, cur):\n  if not root:\n return 0\n\n        if not root.left and not root.right:\n            return cur * 10 + root.val\n        \n        return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n        \n        \n    return dfs(root, 0)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"readycheng":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997396413","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode preNode = new ListNode(-1, head), res;\n        preNode.next = head;\n        res = head.next;\n        ListNode firstNode = head, secondNode, nextNode;\n        while(firstNode != null && firstNode.next != null){\n            secondNode = firstNode.next;\n            nextNode = secondNode.next;\n\n            firstNode.next = nextNode;\n            secondNode.next = firstNode;\n            preNode.next = secondNode;\n\n            preNode = firstNode;\n            firstNode = nextNode;\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yijunxing":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/13#issuecomment-997414956","body":"1. 寻找递归的结束条件:  当链表只剩一个节点或者没有节点的时候，递归就终止了\n2. 寻找递归的返回值：  已经处理好的链表就是返回值\n3. 明白本级递归的作用\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode p;\n        p = dummy;\n        while(p.next != null && p.next.next != null) {\n            ListNode a=p.next,b=a.next;\n            p.next=b;\n            a.next=b.next;\n            b.next=a;\n            p=a;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lingli10822":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/15#issuecomment-997545121","body":"递归思想，每次只处理当前treenode。\r\nbasecase：当前节点为空或当前节点下一节点为空。\r\n难点，需要找到当前treenode，所以需要快慢指针。\r\n```python\r\ndef sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        pre = None \r\n        slow  = fast = head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            \r\n        new_h = slow.next\r\n        pre.next = None\r\n        node = TreeNode(slow.val)\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(new_h)\r\n        return node\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hulichao":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/16#issuecomment-998120659","body":" ### 思路\r\n\r\ncase 有三种 1 > 2， 1 < 2, 1 != 2\r\n使用双指针，在第三种会都为null然后相对，另外两种会相交，假设A链表单独的部分用A 表示， B链表单独的部分用B表示，共同拥有部分用C表示，因为 A+C+B = B+C+A； 我们可以同时遍历两个链表并且让他们为null时跳到对方头节点, 直到两者都为空或相同，表示他们相交的节点位置或者不相交（一旦都为空一定不相交，如果A B 长度一样那么 在到达C 入口时便会跳出while）\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode h1 = headA, h2 = headB;\r\n        while(h1 != h2) {\r\n            if (h1 == null) \r\n                h1 = headB;\r\n            else \r\n                h1 = h1.next;\r\n            if (h2 == null)\r\n                h2 = headA;\r\n            else h2 = h2.next;\r\n        }\r\n\r\n        return h1;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zwang2244":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/18#issuecomment-999297002","body":"**Idea**\n1. Iterate through the linkedlist and stores all nodes visited in a hashset. If meeting with a node seen before, return that node.\n- space: O(n)\n- time: O(n)\n2. Use hare and tortoise algorithm\n- space: O(1)\n- time: O(n)\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n//     public ListNode detectCycle(ListNode head) {\n//         HashSet<ListNode> visited = new HashSet<>();\n//         // int index = 0;\n//         while(head != null){\n//             if(visited.contains(head)){\n//                 return head;\n//             }\n//             visited.add(head);\n//             head = head.next;\n\n//         }\n//         return null;\n//     }\n    \n    public ListNode detectCycle(ListNode head) {\n        if(head == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode intersect = null;\n        while(fast != null && fast.next != null && slow != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                intersect = slow;\n                break;\n            }\n        }\n        if(intersect == null){\n            return null;\n        }\n        \n        ListNode ptr1 = head;\n        ListNode ptr2 = intersect;\n        while(ptr1 != ptr2){\n            ptr1 = ptr1.next;\n            ptr2 = ptr2.next;\n        }\n        \n        return ptr1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eronul":[null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/19#issuecomment-1000375840","body":"```\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frgthyju":[null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/20#issuecomment-1000729691","body":"1.层序遍历(BFS)：\n\n```func maxDepth(root *TreeNode) int {\nfunc maxDepth(root *TreeNode) int {\n    if root == nil{\n        return 0\n    }\n    q := []*TreeNode{root}\n    res := 0\n    for len(q) != 0{\n        res++\n        tmpQ := q\n        q = []*TreeNode{}\n        for len(tmpQ) != 0{\n            tmp := tmpQ[0]\n            tmpQ = tmpQ[1:]\n            if tmp.Left != nil{\n                q = append(q,tmp.Left)\n            }\n            if tmp.Right != nil{\n                q = append(q,tmp.Right)\n            }\n        }\n    }\n    return res\n}\n```\n\n时间复杂度：O(n)，遍历所有元素\n空间复杂度：O(n),队列中最多能存的数量，即每一层最多能存储的，满二叉树n+1/2，即n/2，为n\n\n2.递归(DFS)\n\n```func maxDepth(root *TreeNode) int {\nfunc maxDepth(root *TreeNode) int {\n    if root == nil{\n        return 0\n    }\n    return max(maxDepth(root.Left),maxDepth(root.Right))+1\n}\n\nfunc max(a,b int)int{\n    if a>b{\n        return a\n    }\n    return b\n}\n```\n\n时间复杂度：O(n)\n空间复杂度：O(height),和递归栈深度有关，为最大高度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001041791","body":"使用DFS，依次对比树的根节点、左子树和右子树\n\n```\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if (p == nil && q == nil) {\n        return true\n    }\n    if p == nil || q == nil{\n        return false\n    }\n    if p.Val == q.Val{\n        return isSameTree(p.Left,q.Left) && isSameTree(p.Right,q.Right)\n    }\n    return false\n}\n```\n\n时间复杂度：O(min(m,n))两棵树最小的节点数\n\n空间复杂度：O(min(heightP,heightQ))两棵树的最小高度，而最差情况下节点数等于高度，即O(min(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunpractice":[null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/21#issuecomment-1001038090","body":"recursion \r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null&&q ==null)\r\n            return true;\r\n        if(p ==null||q==null) return false;\r\n        if(p.val != q.val) return false;\r\n        return isSameTree(p.right,q.right)&&\r\n                isSameTree(p.left,q.left);\r\n    }\r\n}\r\n```\r\nTime complexity: O(n) the node number\r\nSpace complexity: O(h)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thetreesofthebaron":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/22#issuecomment-1001088505","body":"## Problem\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/\n\n## Solution\n1. Add the value of each path together\n2. DFS\n\n## Code\n```java\nclass Solution {\n    int sum = 0;\n    public int sumNumbers(TreeNode root) {\n        if(root == null) return 0;\n        dfs(root, 0);  \n        return sum;\n    }\n    private void dfs(TreeNode node, int parentVal)\n    {\n        int childVal = parentVal*10 + node.val;\n        if(node.left == null && node.right == null){\n            sum += childVal;\n            return;\n        }\n        if(node.left != null) dfs(node.left, childVal);\n        if(node.right != null) dfs(node.right,childVal);\n    }\n}\n```\n\n## Complexity\nTime: O(N) traverse each node\n\nSpace: O(H) height of the tree, best: O(lgN), worse: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}