{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"954545647":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297935552","body":"### 思路\n\n套用加法模版\n\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n\n### 代码\n\n```js\nvar addToArrayForm = function (num, k) {\n    let n = num.length;\n    let i = n - 1;\n    let sum = 0;\n    let carry = 0;\n    let res = [];\n    while (i >= 0 || k !== 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n        sum = x + y + carry;\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10);\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if(carry) res.push(carry)\n    return res.reverse();\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为数组长度。\n+ 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299476563","body":"### 思路\n\nMath.min(s[i]到其左侧最近字符c,s[i]到其右侧最近字符c)\n\n### 代码\n\n```js\nvar shortestToChar = function(s, c) {\n  const n = s.length;\n  const ans = new Array(n).fill(0);\n\n  for (let i = 0, idx = -n; i < n; ++i) {\n      if (s[i] === c) {\n          idx = i;\n      }\n      ans[i] = i - idx;\n  }\n  console.log('ans ==>',ans)\n\n  for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n      if (s[i] == c) {\n          idx = i;\n      }\n      ans[i] = Math.min(ans[i], idx - i);\n  }\n  return ans;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符串长度。\n+ 空间复杂度：O(n)，其中 n 为字符串长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301563740","body":"### 思路\n\n用数组维护一个栈\n\n### 代码\n\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.arr = []\n  this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.arr.length < this.maxSize){\n    this.arr.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function(\n) {\n  if(this.arr.length === 0) return -1;\n  return this.arr.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const len = this.arr.length;\n  if(len < k){\n    this.arr = this.arr.map(item=> item+val)\n    return\n  }\n  for(let i= 0; i<k;i++){\n    this.arr[i] = this.arr[i]+val\n  }\n\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：increment为 O(n)，其中 n 为最大长度。\n+ 空间复杂度：O(n)，其中 n 为最大长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302881831","body":"### 思路\n\n使用栈维护当前【】进出\n\n### 代码\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n  let res = \"\"\n  let stack = [];\n  let multi = 0;\n  for(let  i = 0; i < s.length;i++){\n    const item = s[i];\n    const isNum = !isNaN(Number(item));\n    const isLBrackets = item === \"[\"\n    const isRBrackets = item === \"]\"\n    if(isNum){\n      multi = Number(`${multi}${item}`);\n    }else if(isLBrackets){\n      stack.push([multi,res])\n      res = \"\";\n      multi = 0\n    }else if(isRBrackets){\n      const stackItem = stack.pop();\n      res = stackItem[1] + res.repeat(stackItem[0])\n    }else{\n      res += item\n    }\n  }\n  return res\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符串长度。\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304397247","body":"### 思路\n\n因为要求用栈的原生操作，但又需要能拿到栈头元素，因此需要多使用一个数组来模拟队列\n\n### 代码\n\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stack = [];\n  this.helpStack = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\n// 从队列首部移除元素\nMyQueue.prototype.pop = function () {\n  if (!this.helpStack.length) {\n    while (this.stack.length) {\n      this.helpStack.push(this.stack.pop());\n    }\n  }\n  return this.helpStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\n// 返回队列首部的元素\nMyQueue.prototype.peek = function () {\n  const len = this.helpStack.length;\n  if (!this.helpStack.length) {\n    while (this.stack.length) {\n      this.helpStack.push(this.stack.pop());\n    }\n  }\n  return this.helpStack[len - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  if (this.stack.length || this.helpStack.length) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N 为栈中元素个数\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304700283","body":"### 思路\n\n借鉴单调栈思路 <https://lucifer.ren/blog/2020/11/03/monotone-stack/>\n\n### 代码\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n var maxChunksToSorted = function (arr) {\n  const temp = [];\n  for (let i = 0; i < arr.length; i++) {\n    let a = arr[i];\n    if (temp.length > 0 && temp[temp.length - 1] > a) {\n      const cur = temp[temp.length - 1];  // 保存临时最大值\n      while (temp && temp[temp.length - 1] > a) temp.pop();\n      temp.push(cur);\n    } else {\n      temp.push(a);\n    }\n  }\n  return temp.length;\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为数组长度。\n+ 空间复杂度：O(n)，其中 n 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305003518","body":"### 思路\n\n寻找倒数第N位节点可以采用双指针\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0;\n  let start = head;\n  while (start) {\n    start = start.next;\n    count++\n  }\n  // 减少次数\n  k = k % count;\n  // 快指针先走\n  let fast = head;\n  let slow = head;\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res\n\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306537644","body":"### 思路\n\n化简为两节点的交换\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n var swapPairs = function(head) {\n  if(!head || !head.next) return head\n  let preNode = new ListNode();\n  preNode.next = head;\n  let now = head;\n  let res = head.next;\n  while(now && now.next){\n    let nextNode = now.next;\n    let temp = nextNode.next;\n\n    // 进行反转\n    now.next = temp;\n    nextNode.next = now;\n    preNode.next = nextNode;\n    preNode = now;\n    now = temp;\n  }\n  return res;\n\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1309652528","body":"### 思路\n\n快慢指针\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\n var sortedListToBST = function(head) {\n  if(!head) return head;\n  return dfs(head,null)\n};\n\nfunction dfs(head,tail){\n  if(head === tail) return null\n  let fast = head;\n  let slow = head;\n  while(fast!==tail && fast.next!==tail){\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head,slow);\n  root.right = dfs(slow.next,tail);\n  return root\n}\n```\n\n### 复杂度\n\n+ 时间：o(nlogn)\n+ 空间：o(logn)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309672208","body":"### 思路\n\n双指针 a + c + b = b + c + a\n\n### 代码\n\n```js\n var getIntersectionNode = function(headA, headB) {\n  if(!headA || !headB) return null;\n  let a = headA;\n  let b = headB;\n  while(a !==b){\n    if(a === null){\n      a = headB;\n    }else if(b === null){\n      b = headA\n    }else{\n      a = a.next;\n      b = b.next;\n    }\n  }\n  return a\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311153769","body":"### 思路\n\n双指针 or 哈希\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n var detectCycle = function(head) {\n  if (head === null) {\n      return null;\n  }\n  let slow = head, fast = head;\n  while (fast !== null) {\n      slow = slow.next;\n      if (fast.next !== null) {\n          fast = fast.next.next;\n      } else {\n          return null;\n      }\n      if (fast === slow) {\n          let ptr = head;\n          while (ptr !== slow) {\n              ptr = ptr.next;\n              slow = slow.next;\n          }\n          return ptr;\n      }\n  }\n  return null;\n};\n\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312519174","body":"### 思路\n\n双向链表+hashmap\n\n### 代码\n\n```js\nclass DoubleLinkedListNode {\n  constructor(key,value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\nclass LRUCache {\n  constructor(capacity){\n    this.capacity = capacity;\n    this.hashmap = {}\n    this.useSize = 0;\n    this.dummyHead= new DoubleLinkedListNode(null,null);\n    this.dummyTail= new DoubleLinkedListNode(null,null);\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n  }\n\n  _isFull(){\n    return this.useSize === this.capacity;\n  }\n\n  _removeNode(node){\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n\n  _addToHead(node){\n    const head = this.dummyHead.next;\n    node.next = head;\n    node.prev = this.dummyHead;\n    this.dummyHead.next = node;\n    head.prev = node;\n  }\n\n  get(key){\n    if(this.hashmap[key]){\n      const node = this.hashmap[key];\n      const removeNode = this._removeNode(node);\n      this._addToHead(removeNode);\n      return node.value;\n    }else{\n      return -1;\n    }\n  }\n\n  put(key,val){\n    if(this.hashmap[key]){\n      const node = this.hashmap[key];\n      node.value = val;\n      this._addToHead(this._removeNode(node)) \n    }else{\n      if(this._isFull()){\n        // 先获取最后一个\n        const node = this.dummyTail.prev;\n        this._removeNode(node);\n        delete this.hashmap[node.key];\n        this.useSize--;\n      }\n\n      const node = new DoubleLinkedListNode(key,val);\n      this.hashmap[key] = node;\n      this._addToHead(node)\n      this.useSize++\n    }\n  }\n}\n\n\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(n)\n+ 时间复杂度 O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312525247","body":"### 思路\r\n\r\n递归\r\n\r\n### 代码\r\n\r\n```js\r\n// 递归\r\n var maxDepth = function(root) {\r\n  if(!root) return 0;\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) +1 \r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n+ 时间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312955475","body":"### 思路\n\n1. 递归\n2. 前序和中序遍历结果可以确定一颗树\n\n### 代码\n\n```js\n var isSameTree = function(p, q) {\n    if(p === null && q === null) return true;\n  if(p && !q) return false;\n  if(!p && q) return false;\n  return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right , q.right)\n};\n\n\n// 前序&&中序\n\nvar isSameTree = function(p, q) {\n  const preOrderP = preOrder(p,[])\n  const preOrderQ = preOrder(q,[])\n  const middleOrderP = middleOrder(p,[])\n  const middleOrderQ = middleOrder(q,[])\n  return preOrderP.join(\" \") === preOrderQ.join(\" \") && middleOrderP.join(\" \") === middleOrderQ.join(\" \") \n};\n\nfunction preOrder(root,arr){\n  if(root === null){\n    arr.push(\" \")\n    return arr\n  }\n  arr.push(root.val);\n  preOrder(root.left, arr);\n  preOrder(root.right, arr);\n  return arr\n}\n\nfunction middleOrder(root,arr){\n  if(root === null){\n    arr.push(\" \")\n    return arr\n  }\n  preOrder(root.left, arr);\n  arr.push(root.val);\n  preOrder(root.right, arr);\n  return arr\n}\n```\n\n### 空间复杂度\n\n+ 时间复杂度：O(N)，其中 N 为树的节点数。\n\n+ 空间复杂度：O(h)，其中 h 为树的高度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315549039","body":"### 思路\n\n递归求解\n\n### 代码\n\n```js\nvar sumNumbers = function (root) {\n  const helper = (root, cur) => {\n    if (root === null) return 0;\n    cur = 10 * cur + root.val;\n    if (root.left === null && root.right === null) return cur;\n    return helper(root.left, cur) + helper(root.right, cur);\n  };\n  return helper(root, 0);\n};\n```\n\n### 复杂度\n\n令 n 为节点总数， h 为树的高度。\n\n+ 时间复杂度：O(n)\n\n+ 空间复杂度：O(h)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316200432","body":"### 思路\n\nBFS\n套路：使用 curLevel 和 nextLevel 进行分析\n\n### 代码\n\n```js\nvar findBottomLeftValue = function(root) {\n  if(!root) return root;\n  let curLevel = [root];\n  let res =root.val;\n  while(curLevel.length){\n    let nextLevel = [];\n    for(let i = 0; i< curLevel.length; i++){\n      const item = curLevel[i]\n      item.left && nextLevel.push(item.left);\n      item.right && nextLevel.push(item.right);\n    }\n    res = curLevel[0].val\n        curLevel = nextLevel;\n  }\n  return res;\n};\n```\n\n### 复杂度\n\n令 n 为节点总数\n\n+ 时间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318917549","body":"### 思路\n\n参考的题解，BFS\n\n### 代码\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\n var serialize = function(root) {\n    if(!root) return \"x\";\n    let queue = [root];\n    let res = []\n    while(queue.length){\n      let item = queue.shift();\n      if(item){\n        res.push(item.val);\n        queue.push(item.left);\n        queue.push(item.right)\n      }else{\n        res.push(\"x\")\n      }\n    }\n    return res.join(\",\")\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if(data ===\"x\") return null;\n    const list = data.split(\",\");\n    const root = new TreeNode(list[0]);\n    const queue = [root];\n    let cursor = 1;\n    while(cursor < list.length){\n      const node = queue.shift();\n      const leftVal = list[cursor];\n      const rightVal = list[cursor+1];\n      if(leftVal!==\"x\"){\n        const leftNode = new TreeNode(leftVal);\n        node.left = leftNode;\n        queue.push(leftNode);\n      }\n      if(rightVal!==\"x\"){\n        const rightNode = new TreeNode(rightVal);\n        node.right = rightNode;\n        queue.push(rightNode);\n      }\n      cursor+=2;\n    }\n    return root;\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n\n### 复杂度分析\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1321041396","body":"### 思路\n\n先通过DFS获取树每个节点的坐标，然后再根据要求进行排序\n\n### 代码\n\n```js\nvar verticalTraversal = function(root) {\n  const nodes = [];\n  dfs(root, 0, 0, nodes);\n  nodes.sort((tuple1, tuple2) => {\n      if (tuple1[0] !== tuple2[0]) {\n          return tuple1[0] - tuple2[0];\n      } else if (tuple1[1] !== tuple2[1]) {\n          return tuple1[1] - tuple2[1];\n      } else {\n          return tuple1[2] - tuple2[2];\n      }\n  });\n\n  const ans = [];\n  let lastcol = -Number.MAX_VALUE;\n  for (const tuple of nodes) {\n      let col = tuple[0], row = tuple[1], value = tuple[2];\n      if (col !== lastcol) {\n          lastcol = col;\n          ans.push([]);\n      }\n      ans[ans.length - 1].push(value);\n  }\n  return ans;\n}\n\nconst dfs = (node, row, col, nodes) => {\n  if (node === null) {\n      return;\n  }\n  nodes.push([col, row, node.val]);\n  dfs(node.left, row + 1, col - 1, nodes);\n  dfs(node.right, row + 1, col + 1, nodes);\n}\n\n\n```\n\n### 复杂度分析\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1321042169","body":"### 思路\n\n使用一个map来帮忙\n\n### 代码\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n var twoSum = function(nums, target) {\n  const len = nums.length;\n  const map = new Map();\n  for(let i= 0; i <len; i++){\n    const cut = target-nums[i];\n    if(map.has(cut)){\n      return [map.get(cut),i]\n    }else{\n      map.set(nums[i],i)\n    }\n  }\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1326595680","body":"### 思路\n\n使用hashmap记录次数配合最小堆进行排序\n\n### 代码\n\n```js\nvar topKFrequent = function (nums, k) {\n  let n = nums.length;\n  let map = new Map();\n  for (let i = 0; i < n; i++) {\n    const item = nums[i];\n    const val = map.get(item);\n    if (map.has(item)) {\n      map.set(item, val + 1)\n    } else {\n      map.set(item, 1)\n    }\n  }\n\n  const res = [];\n  let len = 0;\n  map.forEach((value, key) => {\n    // 小于k个直接插入\n    if (len < k) {\n      res.push(key);\n      if (len === k - 1){\n        buildHeap(res, map, k)\n      }\n    } else {\n      // 多的先判断该值和堆顶的大小。\n      if (map.get(res[0]) < value) {\n        res[0] = key;\n        heapify(res,map,0,k);\n      }\n    }\n    len++\n  })\n\n\n  // 构建最大堆\n  function buildHeap(list, map, k) {\n    const last = Math.floor(k / 2);\n    for (let i = last; i >= 0; i--) {\n      heapify(list, map, i, k);\n    }\n  }\n\n  function swap(items, i, j) {\n    let temp = items[i]\n    items[i] = items[j]\n    items[j] = temp\n  }\n\n  // 排序\n  function heapify(list, map, i, heapSize) {\n    // if (i >= heapSize) return\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n    let min = i;\n    if (left < heapSize && map.get(list[left]) < map.get(list[min])) {\n      min = left;\n    }\n    if (right < heapSize && map.get(list[right]) < map.get(list[min])) {\n      min = right\n    }\n    if (min !== i) {\n      swap(list, min, i);\n      heapify(list,map, min, heapSize)\n    }\n\n  }\n\n  return res\n};\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1326684383","body":"### 思路\n\n使用hash表\n\n### 代码\n\n```js\nvar numberOfBoomerangs = function(points) {\n  let ans = 0;\n  for (const p of points) {\n      const cnt = new Map();\n      for (const q of points) {\n          const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n          // console.log('dis,p,q ==>',dis,p,q)\n          cnt.set(dis, (cnt.get(dis) || 0) + 1);\n      }\n      for (const [_, m] of cnt.entries()) {\n          ans += m * (m - 1);\n      }\n  }\n  return ans;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n平方)，其中 n 为数组长度。\n+ 空间复杂度：O(n)，其中 n 为数组长度。\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1327035141","body":"### 思路\n\n双指针\n\n### 代码\n\n```js\nvar lengthOfLongestSubstring = function (s) {\n  if (!s) return s;\n  let start = 0;\n  let end = 0;\n  let max = 0;\n  let map = new Map();\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i];\n    if (map.has(cur)) {\n      const lastIndex = map.get(cur);\n      // 左指针的移动位置需要额外注意：\n      // 先找出重复字符的下一位，但要比当前索引大\n      // 如果 s[r] 曾在 [l, r] 滑动窗口中出现\n      // 就收缩滑动窗口左侧，把 l 指针移动到 s[r] 上次出现的位置 + 1\n      start = Math.max(lastIndex + 1, start);\n    }\n    map.set(cur, i);\n    max = Math.max(end - start + 1, max)\n    end = end + 1;\n  }\n  return max\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符长度。\n+ 空间复杂度：O(n)\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326692327","body":"### 思路\n\n快慢指针\n\n### 代码\n\n```js\n var middleNode = function(head) {\n  if(!head) return head;\n  let newHead = head;\n  let quick = newHead;\n  let slow = newHead;\n  while(quick && quick.next){\n    quick = quick.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为链表长度。\n+ 空间复杂度：O(1)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328446731","body":"### 思路\n\n暴力法 & 双向队列\n\n### 代码\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\n var maxSlidingWindow = function(nums, k) {\n  let res = [];\n  for(let i = 0; i < nums.length - k+1; i++){\n    const curMax = cal(nums,i,i+k);\n    res.push(curMax)\n  }\n  return res\n};\n\nfunction cal(nums,start,end){\n  console.log('start,end ==>',start,end)\n  let max = nums[start];\n  for(let i= start; i < end; i++){\n    max = Math.max(nums[i],max)\n  }\n  return max;\n}\n\n\n\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const dequeue = new Dequeue([]);\n  // 前 k - 1 个数入队\n  for (let i = 0; i < k - 1; i++) {\n    dequeue.push(nums[i]);\n  }\n\n  // 滑动窗口\n  for (let i = k - 1; i < nums.length; i++) {\n    dequeue.push(nums[i]);\n    res.push(dequeue.max());\n    dequeue.shift(nums[i - k + 1]);\n  }\n  return res;\n};\n\nclass Dequeue {\n  constructor(nums) {\n    this.list = nums;\n  }\n\n  push(val) {\n    const nums = this.list;\n    // 保证数据从队头到队尾递减\n    while (nums[nums.length - 1] < val) {\n      nums.pop();\n    }\n    nums.push(val);\n  }\n\n  // 队头出队\n  shift(val) {\n    let nums = this.list;\n    if (nums[0] === val) {\n      nums.shift();\n    }\n  }\n\n  max() {\n    return this.list[0];\n  }\n}\nconsole.log(' ==>',maxSlidingWindow([1,3,-1,-3,5,3,6,7],3))\n```\n\n### 复杂度分析\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297933717","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n\n## 思路\n1、遍历数组，逆序逐位相加(注意相加进位问题)\n2、考虑k的数字长度大于数组长度的问题\n3、逆序输出即可\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        int len = num.length;\n        //1、从后往前逐位相加\n        for (int i = len-1; i >=0 ; i--) {\n            //1.1逐位相加\n            int sum = num[i] + k%10;\n            k /=10;\n            //1.2相加进位\n            if (sum >= 10){\n                k++;\n                sum -=10;\n            }\n            result.add(sum);\n        }\n\n        //2、如果k的长度大于num的数组长度\n        for (;k>0;k /=10){\n            result.add(k %10);\n        }\n\n        //3、将结果反转输出即可\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299506664","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n## 思路\n\n正反遍历方式：\n     *      1、正遍历记录从左侧到字符c的距离\n     *      2、返遍历记录从右侧到字符c的距离\n     *      取两者的最小值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       int n = s.length();\n        int[] res = new int[n];\n        int indexC1 = -n;\n        for (int i = 0; i < n ; ++i) {//正向遍历\n            if (s.charAt(i) == c){\n                indexC1 = i;\n            }\n            res[i] = i - indexC1;\n        }\n\n        int indexC2 = 2*n;//反向遍历初始值使用2n的目地是防止下面取最小值时出现错误数据\n        for (int i = n-1; i >=0 ; --i) {//反向遍历\n            if (s.charAt(i) == c){\n                indexC2 = i;\n            }\n            res[i] = Math.min(res[i],indexC2 - i);//取最小值\n        }\n        return res;\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301558840","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 思路\n使用数组模拟栈,用一个变量 top 记录当前栈顶的位置\n     *      1、对于push操作,首先判断当前元素的个数是否达到上限,如果没有达到上限,则把栈顶top后移一个位置 并添加元素\n     *      2、对于pop操作,首先判断栈是否为空,非空则返回栈顶top对应位置的元素,栈顶top向前移一个位置 否则返回-1\n     *      3、对于inc操作,对栈底的最多k个元素增加val\n\n## 关键点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top;//记录栈顶的位置\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (stack.length > 0 && top >= 0){\n            --top;\n            return stack[top + 1];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k, top + 1);\n        for (int i = 0; i < min; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(1) inc操作的时间复杂为O(k)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303174000","body":"算法流程：\n1、构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n         1.1当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n         1.2当 c 为字母时，在 res 尾部添加 c；\n         1.3当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 \n              1.3.1记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n              1.3.2记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n              1.3.3进入到新 [ 后，res 和 multi 重新记录。\n          1.4当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n               1.4.1last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n               1.4.2cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n2、返回字符串 res。\n\n代码：java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n\n复杂度分析：\n时间复杂度 \nO(N)\n空间复杂度 \nO(N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304540439","body":"思路:\n我们创建两个栈，分别为 out 和 in：\n        in 用作处理输入操作 push()，使用 in 时需确保 out 为空\n        out 用作处理输出操作 pop() 和 peek()，使用 out 时需确保 in 为空\n\n代码:java\n\nclass MyQueue {\n    Deque<Integer> out, in;\n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        while (!out.isEmpty()) in.addLast(out.pollLast());\n        in.addLast(x);\n    }\n    \n    public int pop() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.pollLast();\n    }\n    \n    public int peek() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.peekLast();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n\n复杂度分析:\n       时间复杂度：O(n)O(n)\n       空间复杂度：O(n)O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304788782","body":"思路:\n根据栈的思想，我们在栈中维护每个块的最大值\n1、若当前栈为空或者栈顶元素小于等于当前元素，直接入栈\n2、若栈顶元素大于当前元素，则需要融合到上一个块中去，直到当前元素大于栈顶元素或者栈为空\n\n代码：java\npublic int maxChunksToSorted(int[] arr) {\nDeque<Integer> stack = new LinkedList<>();\n        for (int num : arr) {\n            //若当前栈为空或者栈顶元素小于等于当前元素，直接入栈\n            if (stack.isEmpty() || stack.peek() <= num) {\n                stack.push(num);\n            } else {\n                //融合块，保留当前块的最大元素\n                //比如之前有块[3]、[4],若num = 1，\n                //则融合为[3,4,1],因为排序1会排到前边去，当前块的最大值还是4\n                int max = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(max);\n            }\n        }\n        return stack.size();\n }\n\n复杂度分析:\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305695785","body":"思路:\n1、先把链表全部放进数组里面去。\n2、因为旋转的次数等于链表中元素的值的话，链表旋转后还是相等的。\n3、考虑取模了，取模之后为0的话说明旋转之后不变，直接返回\n4、通过链表的长度得出最后的返回头和返回头的前一个元素\n5、得到返回的元素头的前一个元素，我们把它指向一个空，先断开链表\n\n代码:java\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        List<ListNode> arrayList = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null) {\n            arrayList.add(cur);\n            cur = cur.next;\n        }\n        int size = arrayList.size();\n        int number = k % size;\n        if (number == 0) {\n            return head;\n        }\n        int index = size - number;\n        ListNode lastNode = arrayList.get(index - 1);\n        lastNode.next = null;\n        ListNode node = arrayList.get(index);\n        cur = node;\n        for (int i = 1; i < number; i++) {\n            node = node.next;\n        }\n        node.next = head;\n        return cur;\n    }\n}\n\n复杂度分析:\n时间复杂度O(n)\n空间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307270957","body":"思路:递归处理\n1、返回值：交换完成的子链表\n2、调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换\n3、终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换\n\n\n代码:java\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n\n复杂度分析:\n时间复杂度:O(n) 其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\n空间复杂度:O(n) 其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308841501","body":"思路：\n1、用双指针来找到链表的中点，\n2、用pre来当做中点的前一个点，n2 = pre.next，\n3、让n1比n2多走一步，这样当n1到达最后一个点时n2到了中点。\n4、此时切断n2和左边的联系来将链表一切两半。\n5、接下来可以利用递归的反转性，node.left = sortedListToBST(head); 这样树的最左边节点就是最小值。node.right = sortedListToBST(n2.next);这样树的右边第一个节点就是最大值。\n\n\n代码:java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode n2 = pre.next;\n        ListNode n1 = n2.next;\n        \n        while(n1 != null && n1.next != null) {\n            pre = pre.next;\n            n2 = pre.next;\n            n1 = n1.next.next;\n        }\n        pre.next = null;\n        TreeNode node = new TreeNode(n2.val);\n        node.left = sortedListToBST(head);\n        node.right = sortedListToBST(n2.next);\n        return node;\n    }\n}\n\n复杂度分析:\n时间复杂度:O(nlogn)\n空间复杂度:O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310191339","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n\n\n \n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n\n## 关键点\n\n-  双指针技巧\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while (p1 != p2){\n            if(p1 == null){\n                p1 = headB;\n            }else {\n                p1 = p1.next;\n            }\n\n            if(p2 == null){\n                p2 = headA;\n            }else {\n                p2 = p2.next;\n            }\n\n        }\n        return p1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297828208","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const ret = [];\n  \n  while(num.length || k) {\n    k += num.pop() || 0;\n    ret.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  while(k) {\n    ret.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  \n  return ret;\n};\n\n// Time Complexity O(N)\n// Space Complexity O(N)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299341352","body":"```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const ret = new Array(s.length);\n  \n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ret[i] = 0;\n    } else {\n      if (i === 0) {\n        ret[i] = 10001;\n      } else {\n        ret[i] = ret[i - 1] + 1;\n      }\n    }\n  }\n  \n  for (let j = s.length - 2; j >= 0; j--) {\n    ret[j] = Math.min(ret[j], ret[j + 1] + 1);\n  }\n  \n  return ret;\n};\n```\n- Time Complexity O(N)\n- Space Complexity O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301505213","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.max = maxSize;\n  this.size = 0;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.size < this.max) {\n    this.stack.push(x);\n    this.size++;\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.size > 0) {\n    this.size--;\n    return this.stack.pop();\n  }\n  \n  return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.size) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n- Time Complexity inc O(N) push,pop O(1)\n- Space Complexity O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304551283","body":"```js\n\nvar MyQueue = function() {\n  this.outStack = [];\n  this.inStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (!this.outStack.length) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  \n  return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (!this.outStack.length) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  \n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.outStack.length && !this.inStack.length;\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n- Time Complexity O( N)\n- Space Complexity O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304801302","body":"```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = [arr[0]];\n  \n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] >= stack[stack.length - 1]) {\n      stack.push(arr[i]);\n    }\n    \n    const topNum = stack.pop();\n    while (stack.length && stack[stack.length - 1] > arr[i]) {\n      stack.pop();\n    }\n    stack.push(topNum);\n  }\n  \n  return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305733649","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  let p = head;\n  let len = 1;\n\n  while (p.next) {\n    p = p.next;\n    len++;\n  }\n\n  k = k % len;\n  p.next = head;\n\n  for (let i = 0; i < len - k; i++) {\n    p = p.next;\n  }\n\n  const newLink = p.next;\n  p.next = null;\n\n  return newLink;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308917828","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n  if (!head) {\n    return null;\n  }\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head === tail) {\n    return null;\n  }\n  let fast = head;\n  let slow = head;\n  \n  while (fast !== tail && fast.next !== tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  \n  const node = new TreeNode(slow.val);\n  node.left = dfs(head, slow);\n  node.right = dfs(slow.next, tail);\n  \n  return node;\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312716633","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  if (!root) {\n    return 0;\n  }\n  \n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```\n- Time Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313938862","body":"```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n  if (!p && !q) {\r\n    return true;\r\n  }\r\n  if (!p || !q) {\r\n    return false;\r\n  }\r\n  \r\n  if (p.val !== q.val) {\r\n    return false;\r\n  }\r\n  \r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315494654","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n  const rArr = [];\n  \n  function dfs(node, arr) {\n    arr.push(node.val);\n    if (!node.left && !node.right) {\n      const sum = arr.join('');\n      rArr.push(parseInt(sum));\n      return;\n    }\n    if (node.left) {\n      dfs(node.left, arr);\n      arr.pop();\n    }\n    if (node.right) {\n      dfs(node.right, arr);\n      arr.pop();\n    }\n  }\n  \n  dfs(root, []);\n  const ret = rArr.reduce((pre, cur) => {\n    return pre += cur\n  })\n  \n  return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317169077","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  const arr = [root];\n  let ret = arr[0].val;\n  \n  while (arr.length) {\n    let len = arr.length;\n    for (let i = 0; i < len; i++) {\n      const node = arr.shift();\n      if (i === 0) {\n        ret = node.val;\n      }\n      node.left && arr.push(node.left);\n      node.right && arr.push(node.right);\n    }\n  }\n  \n  return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318776946","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n  if (!root) {\n    return 'x';\n  }\n  \n  return root.val + ',' + serialize(root.left) + ',' + serialize(root.right);\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');\n  \n  function buildTree(arr) {\n    const item = arr.shift();\n    if (item === 'x') {\n      return null;\n    }\n    \n    const node = new TreeNode(item);\n    node.left = buildTree(arr);\n    node.right = buildTree(arr);\n    \n    return node;\n  }\n  \n  return buildTree(list)\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320889824","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n  let map = new Map();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const diff = target - nums[i];\n    \n    if (map.has(diff)) {\n      \n      return [map.get(diff), i];\n    } else {\n      map.set(nums[i], i);\n    }\n  }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325120791","body":"```js\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n  const wordSize = words[0].length;\n  const wordsLen = wordSize * words.length;\n  let map = new Map();\n  let ans = [];\n  for (let i = 0; i< words.length; i++) {\n    map.has(words[i]) ? map.set(words[i], map.get(words[i]) + 1) : map.set(words[i], 1);\n  }\n  for (let i = 0; i < s.length - wordsLen + 1; i++) {\n    const tmap = new Map(map);\n    let count = words.length;\n    for (let p = i; p < i + wordsLen; p += wordSize) {\n      const word = s.slice(p, p + wordSize);\n      if (!tmap.has(word) || tmap.get(word) <= 0) {\n        break;\n      }\n      tmap.set(word, tmap.get(word) - 1);\n      count--;\n    }\n    if (count === 0) {\n      ans.push(i);\n    }\n  }\n  return ans;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297940594","body":"### 将 `num` 转为数字\n\n#### 思路\n\n将 `num` 由列表转为数字，与 `k` 求和后再转为数组输出\n\n#### 代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        t = 10\n        n = len(num)\n        res = 0\n        for i in range(n):\n            res += t ** i * num[n - i - 1]\n        res += k\n        \n        out = []\n        while res:\n            out.append(res % 10)\n            res = res // 10\n        return out[::-1]\n```\n\n#### 复杂度\n\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(n)$\n\n### 逐位相加\n\n#### 思路\n\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\n> * https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\n\n#### 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        if len(num) < len(str(k)):\n            num = [0] * (len(str(k)) - len(num)) + num\n        n = max(len(str(k)), len(num)) - 1\n        while n >= 0 or k:\n            sums = num[n] + k % 10 + carry\n\n            basic = sums % 10\n            carry = sums // 10\n            res.insert(0, basic)\n\n            n -= 1\n            k //= 10\n        if carry:\n            res.insert(0, carry)\n            return res\n        else:\n            return res\n```\n\n#### 复杂度\n\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299391606","body":"### 代码\n\n```python\nclass Solution:\n    def shortestToChar (self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n + 1] * n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx != -1:\n                res[i] = i - idx\n\n        idx = n\n        for i in range(n - 1, -1, -1):  # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx != n:\n                res[i] = min(idx - i, res[i])\n\n        return res\n```\n\n### 复杂度\n\n* 时间复杂度：$O(n)$ 。遍历 s 即可，\n* 空间复杂度： $O(n)$。和 s 等长的结果数组，","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301554047","body":"```python\nclass CustomStack:  \n    def __init__(self, maxSize: int):  \n        self.stack = []  \n        self.size = maxSize  \n  \n    def push(self, x: int) -> None:  \n        if len(self.stack) < self.size:  \n            self.stack.append(x)  \n  \n    def pop(self) -> int:  \n        return self.stack.pop() if len(self.stack) > 0 else -1  \n  \n    def increment(self, k: int, val: int) -> None:  \n        if len(self.stack) < k:  \n            self.stack = [i + val for i in self.stack]  \n        else:  \n            self.stack[:k] = [i + val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302833820","body":"### 思路\n\n将每个字符入栈 ，当遇到 `']'` 时出栈，直至遇到 `'['`，`'['` 前的所有数字出栈，即为 `k`，将出栈得到的括号内所有字符重复 `k` 次，入栈。\n\n### 代码\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        for i in s:\n            if i == \"]\":\n                tmp = stack.pop()\n                ch = \"\"\n                while tmp != \"[\": # \"[\" 之后的字符为当前要处理的子串\n                    ch = tmp + ch\n                    tmp = stack.pop()\n                time = 0\n                c = 0 # 进位，因为数字取值为 [1, 300]，需要考虑 10 以上的重复情况\n                while stack and stack[-1].isdigit(): # \"[\" 之前的数字为当前子串要重复的次数\n                    t1 = stack.pop()\n                    time += int(t1) * 10 ** c\n                    c += 1\n                ch = ch * time\n                stack.append(ch) # 处理完的子串入栈\n            else:\n                stack. append (i)\n        if stack:\n            res = \"\".join(i for i in stack)\n        return res\n```\n\n### 复杂度\n\n* 时间复杂度：$O(n)$，需要遍历一遍字符\n* 空间复杂度：$O(n)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304406391","body":"```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.inqueue = []\r\n        self.outqueue = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.inqueue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outqueue:\r\n            while self.inqueue:\r\n                self.outqueue.append(self.inqueue.pop())\r\n        return self.outqueue.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outqueue:\r\n            while self.inqueue:\r\n                self.outqueue.append(self.inqueue.pop())\r\n        return self.outqueue[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.inqueue and not self.outqueue:  # 两个栈均为空时\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304816175","body":"\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        local_max = -1\r\n        for num in arr:\r\n            while stack and stack[-1] > num:\r\n                stack.pop()\r\n            if num >= local_max:\r\n                stack.append(num)\r\n            else:\r\n                stack.append(local_max)\r\n            local_max = stack[-1]  # 不放在 lm = stack.pop() 是为了防止 num>lm 时最大值记录错误\r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(N)$\r\n- 空间复杂度： $O(N)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304976331","body":"### 思路\r\n\r\n- 将 链表 首尾串联形成循环链表\r\n- 旋转 k 次后的尾结点位置为 $(len(link) - k) \\% len(link)$，从该位置断开，取该位置下个结点为头节点即可。\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        length = 1\r\n        cur = head\r\n\r\n        while cur.next:\r\n            cur = cur.next\r\n            length += 1\r\n\r\n        target = (length - k) % length\r\n        cur.next = head\r\n        for _ in range(target):\r\n            cur = cur.next\r\n\r\n        head = cur.next\r\n        cur.next = None\r\n\r\n        return head\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306835996","body":"\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\n\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        start = pre = ListNode()\r\n        pre.next = head\r\n        while pre.next and pre.next.next:\r\n            slow, fast = pre.next, pre.next.next\r\n            slow.next = fast.next\r\n            fast.next = slow\r\n            pre.next = fast\r\n            pre = slow\r\n        return start.next\r\n````\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度： $O(n)$\r\n* 空间复杂度： $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308036046","body":"```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(head: ListNode) -> int:\r\n            ret = 0\r\n            while head:\r\n                ret += 1\r\n                head = head.next\r\n            return ret\r\n\r\n        def buildTree(left: int, right: int) -> TreeNode:\r\n            if left > right:\r\n                return None\r\n            mid = (left + right ) // 2 # 中间结点\r\n            \r\n            root = TreeNode()\r\n            root.left = buildTree(left, mid - 1)\r\n            \r\n            nonlocal head\r\n            root.val = head.val\r\n            head = head.next\r\n            \r\n            root.right = buildTree(mid + 1, right)\r\n            return root\r\n\r\n        length = getLength(head)\r\n        return buildTree(0, length - 1)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309634405","body":"#### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode (self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n#### 复杂度\r\n\r\n时间复杂度： $O(m+n)$\r\n空间复杂度： $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311454840","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while True:\r\n            if not fast or not fast.next:\r\n                return None\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n        fast = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\n\r\n#### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312468386","body":"```python\r\nfrom collections import OrderedDict\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = OrderedDict()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        else:\r\n            self.cache.move_to_tail(key)\r\n            return self.cache[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        self.cache[key] = value\r\n        self.cache.move_to_tail(key)\r\n        if len(self.cache) > self.capacity:\r\n            self.cache.popitem(last=False)\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312659800","body":"```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312939839","body":"```python\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\n\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:  # 二者均为空\r\n            return True\r\n        if (not p and q) or (p and not q):  # 一个为空，另一个非空\r\n            return False\r\n        if p.val != q.val:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314612513","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        return self.preorderTraversal(root, 0)\r\n\r\n    def preorderTraversal(self, root, pre_sum=0):\r\n        if not root:\r\n            return 0\r\n        \r\n        sum_to_cur = pre_sum * 10 + root.val # 截至到当前结点的路径和\r\n        if not root.left and not root.right:\r\n            return sum_to_cur\r\n\r\n        # 若为非叶子结点，则路径和需继续累加左子结点和右子结点\r\n        return self.preorderTraversal(root.left, sum_to_cur) + self.preorderTraversal(\r\n            root.right, sum_to_cur\r\n        )\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316133998","body":"### 广度优先搜索\r\n\r\n#### 思路\r\n\r\n* 层序遍历 时，每层按 **从右到左** 顺序进行，则该层最后一个结点，则是该层最左结点。\r\n* 从而最左下结点为层序遍历的最后一个结点\r\n\r\n#### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        return self.levelTraversal(root)\r\n\r\n    def levelTraversal(self, root):\r\n        queue = [root]\r\n        tmp = None\r\n\r\n        while queue:\r\n            for _ in range(len(queue)):  # 遍历每一层\r\n                tmp = queue.pop(0)\r\n                if tmp.right:  # 右结点先入队\r\n                    queue.append(tmp.right)\r\n                if tmp.left:\r\n                    queue.append(tmp.left)\r\n        ans = tmp.val  # 最后一个入队的结点即为最左下结点\r\n        return ans\r\n```\r\n\r\n* 从左到右遍历时，每层第一个元素即是该层第一个元素。\r\n\r\n```python\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\n\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        return self.levelTraversal(root)\r\n\r\n    def levelTraversal(self, root):\r\n        queue = [root]\r\n        ans = None\r\n\r\n        while queue:\r\n            ans = queue[0].val  # 每层第一个元素 -> 最后一层第一个元素即为最左下结点\r\n            # 开始遍历每一层\r\n            for _ in range(len(queue)):  # 每一层的处理\r\n                tmp = queue.pop(0)\r\n                if tmp.left:\r\n                    queue.append(tmp.left)\r\n                if tmp.right:\r\n                    queue.append(tmp.right)\r\n        return ans\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。\r\n* 空间复杂度：$O(n)$。如果二叉树是满完全二叉树，那么队列 `queue` 最多保存 $\\big \\lceil \\dfrac{n}{2} \\big \\rceil$ 个节点\r\n\r\n### 深度优先搜索\r\n\r\n#### 思路\r\n\r\n* 采用深度优先搜索，到第一次到达新的一层时，即为当前最左下结点。\r\n* 记录当前结点所在的深度和最大深度，第一次取得最大深度时，即到达新的一层，该结点便是最左下结点。\r\n\r\n#### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        # self.ans,self.max_depth = None,0\r\n        ans = 0\r\n        max_depth = 0\r\n\r\n        def dfs(root, depth=0):\r\n            nonlocal ans, max_depth\r\n            if not root:\r\n                return None\r\n            depth += 1\r\n            if depth > max_depth:\r\n                max_depth = depth\r\n                ans = root.val\r\n            dfs(root.left, depth)\r\n            dfs(root.right, depth)\r\n\r\n        dfs(root, 0)\r\n        return ans\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。需要遍历 $n$ 个节点。\r\n* 空间复杂度：$O(n)$。递归栈需要占用 $O(n)$ 的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317952142","body":"### 广度优先搜索 - 层序遍历\r\n\r\n序列化的结果正好时二叉树的层序遍历结果。注意没有左右孩子结点要输出 `'null'`，而不是跳过。\r\n\r\n#### 代码\r\n\r\n```python\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n\r\nclass Codec:\r\n    from collections import deque\r\n    \r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        queue = self.deque([root])\r\n        res = []\r\n        while queue:\r\n            for _ in range(len(queue)): \r\n            # for _ in range(len(queue)): # 加与不加 for 循环均可\r\n                node = queue.popleft()\r\n                if node:\r\n                    res.append(str(node.val))\r\n                    # if node.left: # 必须取消\r\n                    queue.append(node.left)\r\n                    # if node.right: # 必须取消\r\n                    queue.append(node.right)\r\n                else:\r\n                    res.append(\"null\")\r\n        return \",\".join(res)\r\n    \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data, i = data.split(\",\"), 1\r\n        root = TreeNode(data[0])\r\n        queue = self.deque([root])\r\n        \r\n        while i < len(data):\r\n            for _ in range(len(queue)):\r\n            # for _ in range(len(queue)):# 加与不加 for 循环均可\r\n                node = queue.popleft()\r\n                if data[i] != \"null\":\r\n                    node.left = TreeNode(data[i])\r\n                    queue.append(node.left)\r\n                i += 1\r\n                if data[i] != \"null\":\r\n                    node.right = TreeNode(data[i])\r\n                    queue.append(node.right)\r\n                i += 1\r\n        Return root\r\n```\r\n\r\n#### 复杂度\r\n* 时间复杂度： $O(n)$\r\n* 空间复杂度： $O(n)$\r\n\r\n### 前序遍历\r\n\r\n序列化的结果为前序遍历的输出，注意子节点为空时，需要输出子结点为 `null` 。\r\n\r\n#### 代码\r\n\r\n1. 外部变量 `self.index` 记录每次要处理的元素位置，按顺序依次处理。\r\n\r\n```python\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        return self.dfs(root)\r\n        \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        data = data.split(\",\")\r\n        self.index = 0\r\n        return self.build_dfs(data)\r\n        \r\n    def dfs(self, root):\r\n        if not root:\r\n            return \"null\"\r\n        return str(root.val) + \",\" + self.dfs(root.left) + \",\" + self.dfs(root.right)\r\n        \r\n    def build_dfs(self, data):\r\n        if self.index >= len(data) or data[self.index] == \"null\":\r\n            self.index += 1\r\n            return None\r\n        root = TreeNode(int(data[self.index]))\r\n        self.index += 1\r\n        root.left = self.build_dfs(data)\r\n        root.right = self.build_dfs(data)\r\n        Return root\r\n```\r\n\r\n2. DFS 反序列化每次要处理的字符都是 `data` 的下一个元素，处理完成后直接 `pop` 出队即可。\r\n   * 以 `['1', '2', 'null', 'null', '3', '4', 'null', 'null', '5', 'null', 'null']` 为例，`1` 的右结点是 `3`，将 `1` 的左子树 `[2,'null','null']` 处理完成后正好是 `3`。\r\n\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"null\"\r\n        return (\r\n            str(root.val)\r\n            + \",\"\r\n            + self.serialize(root.left)\r\n            + \",\"\r\n            + self.serialize(root.right)\r\n        )\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        data = collections.deque(data.split(\",\"))\r\n        # data = data.split(',')\r\n        def traversal(data):  # 前序遍历\r\n            val = data.popleft()\r\n            # val = data.pop(0)\r\n            if val == \"null\":\r\n                return None\r\n            root = TreeNode(int(val))\r\n            root.left = traversal(data)\r\n            root.right = traversal(data)\r\n            return root\r\n            \r\n        return traversal(data)\r\n```\r\n\r\n#### 复杂度\r\n* 时间复杂度： $O(n)$\r\n* 空间复杂度： $O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319393365","body":"### 思路\r\n\r\n- 先遍历记录下二叉树中每个元素的行列值，然后再根据（列，行，值）进行排序。\r\n- 由于题中要求按列优先，所以三元组中把列排在第一个元素。\r\n- python 中 `sorted` 函数可以对元组进行排序，按照各元素升序进行排序，先根据第一个元素排序，再根据第二个元素排序，正好满足题中要求。\r\n\r\n### 代码\r\n\r\n#### 深度优先搜索\r\n\r\n```python\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        self.info = []\r\n        self.dfs(root, 0, 0)\r\n\r\n        info = sorted(self.info)\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col, row, val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n\r\n    def dfs(self, root, row, col):\r\n        if not root:\r\n            return None\r\n        self.info.append((col, row, root.val))\r\n        self.dfs(root.left, row + 1, col - 1)\r\n        self.dfs(root.right, row + 1, col + 1)\r\n```\r\n\r\n#### 广度优先搜索\r\n\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        info = sorted(self.bfs(root))\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col, row, val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n\r\n    def bfs(self, root):\r\n        from collections import deque\r\n\r\n        ans = []\r\n        que = deque([(0, 0, root)])\r\n        while que:\r\n            for _ in range(len(que)):\r\n                tmp = que.popleft()\r\n                row, col = tmp[1], tmp[0]\r\n                node = tmp[2]\r\n                ans.append((col, row, node.val))\r\n                if node.left:\r\n                    que.append((col - 1, row + 1, node.left))\r\n                if node.right:\r\n                    que.append((col + 1, row + 1, node.right))\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n\\log(n))$，主要是排序的复杂度。\r\n- 空间复杂度： $O(n)$，需要存储所有结点的 (行, 列, 值) 信息。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298100069","body":"##### 989\n\n数组形式的整数加法\n\n```\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n```\n\n从低位向高位计算，注意边界处理（既然用数组表示数了，肯定可能大数）。\n\n```\nclass Solution\n{\npublic:\n    vector<int> addToArrayForm(vector<int> &num, int k)\n    {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; i--)\n        {\n            int c = num[i] + k % 10;\n            k /= 10;\n            if (c >= 10)\n            {\n                k++; // 进位到k上\n                c -= 10;\n            }\n            res.push_back(c);\n        }\n        while (k)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n* O(N)\n* O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300711980","body":"#### 821\n\n字符的最短距离\n\n两次遍历。\n\n```\nclass Solution\n{\npublic:\n    vector<int> shortestToChar(string s, char c)\n    {\n        int i = 0, j = 0;\n        int n = s.size();\n        vector<int> res(n, 10007);\n        for (; j < n; j++)\n        {\n            if (s[j] == c)\n            {\n                int t = j - i;\n                for (; i <= j; i++)\n                {\n                    res[i] = min(res[i], t);\n                    t--;\n                }\n            }\n        }\n        i = n - 1, j = n - 1;\n        for (; i >= 0; i--)\n        {\n            if (s[i] == c)\n            {\n                int t = j - i;\n                for (; j >= i; j--)\n                {\n                    res[j] = min(res[j], t);\n                    t--;\n                }\n            }\n        }\n        for (int &a : res)\n        {\n            printf(\"%d \", a);\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301571798","body":"空间换时间，采用一个额外的数组increment来记录每次的increment操作。初始化为(maxSize, 0)，值如下。本质是到用时再计算。\nclass CustomStack\n{\npublic:\n    CustomStack(int _maxSize)\n        : maxSize(_maxSize)\n    {\n        stk.resize(_maxSize);\n        add.resize(_maxSize);\n        top = -1;\n    }\n\n    void push(int x)\n    {\n        if (top != maxSize - 1)\n        {\n            top++;\n            stk[top] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (top == -1)\n        {\n            return -1;\n        }\n        int res = stk[top] + add[top];\n        if (top != 0)\n        {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        top--;\n        return res;\n    }\n\n    void increment(int k, int val)\n    {\n        int l = min(k - 1, top);\n        if (l >= 0)\n        {\n            add[l] += val;\n        }\n    }\n\nprivate:\n    vector<int> stk;\n    vector<int> add;\n    int maxSize = -1;\n    int top;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302878649","body":"字符串解码\n\n```\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n括号内嵌套括号，需要从内向外生成与拼接字符串，和栈先入后出的特性对应。\n\n```\nclass Solution\n{\npublic:\n    string decodeString(string s)\n    {\n        vector<string> strstk;\n        vector<int> numstk;\n\n        int num = 0;\n        string str = \"\";\n        for (char c : s)\n        {\n            if (c >= '0' && c <= '9')\n            {\n                num *= 10;\n                num += (c - '0');\n            }\n            else if (c == '[')\n            {\n                numstk.push_back(num);\n                strstk.push_back(str);\n                num = 0;\n                str = \"\";\n            }\n            else if (c == ']')\n            {\n                int numtmp = numstk.back();\n                string strtmp = strstk.back();\n                numstk.pop_back();\n                strstk.pop_back();\n                for (int i = 0; i < numtmp; i++)\n                {\n                    strtmp = strtmp + str;\n                }\n                str = strtmp;\n            }\n            else\n            {\n                str += c;\n            }\n        }\n        return str;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561577","body":"\n\n##### 232\n\n栈实现队列\n\n双栈模拟队列；而非栈+辅助栈模拟队列；**后者push总是O(N)**，pop简单为O(1)。但是在双栈模拟情况下，仍能保证pop为O(1)，进行一次O(N)“倾倒”操作后，后续取这些元素O(1)即可。\n\n```\nclass MyQueue\n{\npublic:\n    // stack in\n    stack<int> s1;\n    // stack out\n    stack<int> s2;\n    MyQueue()\n    {\n    }\n\n    void push(int x)\n    {\n        s1.push(x);\n    }\n\n    int pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int res = s2.top();\n        s2.pop();\n        return res;\n    }\n\n    int peek()\n    {\n        int res = this->pop();\n        s2.push(res);\n        return res;\n    }\n\n    bool empty()\n    {\n        return s1.empty() && s2.empty();\n    }\n};\n```\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829697","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> st{};\n        for (auto & i: arr) {\n            if (st.empty() || i >= st.top()) {\n                st.emplace(i);\n            }else {\n                auto t = st.top();\n                st.pop();\n                while (!st.empty() && st.top() > i) {\n                    st.pop();\n                }\n                st.emplace(t);\n            }\n        }\n        return st.size();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304961272","body":"利用环找到新的头尾节点，因为内部关系没变，只修改\n\n* 尾节点指向头节点\n* 找到新的尾节点后\n  * 设置新头节点（新尾节点的下一个）\n  * 设置新尾节点（next置为nullptr）\n\n```\nclass Solution\n{\n    public:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode *tail = head;\n        ListNode *newtail = head;\n        ListNode *newhead;\n        int n = 1;\n        // 原来的尾结点指向原来的头结点，形成环\n        while (tail->next != nullptr)\n        {\n            tail = tail->next;\n            n++;\n        }\n        tail->next = head;\n        // 找到断开环的位置\n        for (int i = 0; i < (n - k % n - 1); i++)\n        {\n            newtail = newtail->next;\n        }\n        // 新的头结点指向断开环的位置\n        newhead = newtail->next;\n        newtail->next = nullptr;\n\n        return newhead;\n    }\n};\n```\n\n* Time O(N)\n* Space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297925085","body":"Keep adding the last digit of k to the last element of the array, then update k to k divided by ten plus the remainder of the last digit of k plus the last element of the array until the array is empty and k equals 0.\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        stack<int> tempS;\n        vector<int> res;\n        while(!num.empty())\n        {\n            int temp = k%10 + num.back();\n            tempS.push(temp % 10);\n            k  = k/10 + temp/10;\n            num.pop_back();\n        }\n        \n        while(k > 0)\n        {\n            tempS.push(k%10);\n            k /= 10;\n        }\n        \n        while(!tempS.empty())\n        {\n            res.push_back(tempS.top());\n            tempS.pop();\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299563969","body":"Traverse from left to right and set the value to the distance to char c. Traverse from right to left to update if a shorter length is found.\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.size();\n        vector<int> res;\n        int tempPos = INT_MAX;\n        \n        for(int i = 0; i < len; i++)\n        {\n            if(s[i] == c)\n                tempPos = i;\n            res.push_back(abs(i - tempPos));\n        }\n        \n        for(int i = len - 1; i >= 0; i--)\n        {\n            if(s[i] == c)\n                tempPos = i;\n            res[i] = min(res[i], abs(i - tempPos));\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301686760","body":"class CustomStack {\n\npublic:\n    int *s;\n    int size;\n    int index;\n    \n    CustomStack(int maxSize) {\n        s = (int*)malloc(sizeof(int) * (maxSize+1));\n        size = maxSize;\n        index = 0;\n    }\n    \n    void push(int x) {\n        if(index < size)\n        {\n            index++;\n            *(s + index) = x;\n        }\n    }\n    \n    int pop() {\n        if(index > 0)\n        {\n            int res = *(s+index);\n            index--;\n            return res;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 1; i <= k && i <= size; i++)\n            *(s+i) += val;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302894191","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> string_S;\n        stack<int> int_S;\n            \n        int index = 0;\n        string curRes = \"\";\n        while(index < s.size())\n        {\n            if(s[index] >= '0' && s[index] <= '9')\n            {\n                int count = 0;\n                while(s[index] >= '0' && s[index] <= '9')   \n                {\n                    count = 10 * count + (s[index] - '0');\n                    index++;\n                }\n                int_S.push(count);\n            }\n            \n            else if(s[index] == '[')\n            {\n                string_S.push(curRes);\n                curRes = \"\";\n                index++;\n            }\n            \n            else if(s[index] == ']')\n            {\n                string tempStr = string_S.top();\n                int repeatCount = int_S.top();\n                \n                string_S.pop();\n                int_S.pop();\n                    \n                while(repeatCount > 0)\n                {\n                    tempStr.append(curRes);\n                    repeatCount--;\n                }\n                \n                curRes = tempStr;\n                index++;\n            }\n            \n            else\n            {\n                curRes += s[index];\n                index++;\n            }\n        }\n        \n        return curRes;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304438835","body":"class MyQueue {\n    stack<int> pop_stack;\n    stack<int> push_stack;\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        push_stack.push(x);\n    }\n    \n    int pop() {\n        if(!pop_stack.empty())\n        {\n            int temp_top = pop_stack.top();\n            pop_stack.pop();\n            return temp_top;\n        }\n        else{\n            while(!push_stack.empty())\n            {\n                pop_stack.push(push_stack.top());\n                push_stack.pop();\n            }\n            int temp_top = pop_stack.top();\n            pop_stack.pop();\n            return temp_top;\n        }\n    }\n    \n    int peek() {\n        if(!pop_stack.empty())\n            return pop_stack.top();\n        else{\n            while(!push_stack.empty())\n            {\n                pop_stack.push(push_stack.top());\n                push_stack.pop();\n            }\n            return pop_stack.top();\n        }\n    }\n    \n    bool empty() {\n        return pop_stack.empty() && push_stack.empty();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304651899","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> leftMax;\n        vector<int> rightMin;\n        int res = 1;\n        \n        leftMax.push_back(arr[0]);\n        for(int i = 1; i < arr.size(); i++)\n            leftMax.push_back(max(leftMax[i-1], arr[i]));\n        \n        rightMin.push_back(arr[arr.size() - 1]);\n        for(int i = arr.size() - 2; i >= 0; i--)\n            rightMin.insert(rightMin.begin(), 1, min(rightMin[rightMin.size()-(arr.size() - i - 1)], arr[i]));\n        \n        for(int i = 0; i < arr.size() - 1; i++)\n        {\n            if(leftMax[i] <= rightMin[i+1])\n                res++;\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305221514","body":"class Solution {\r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k) {\r\n        int len = 1;\r\n        if (head == NULL || k == 0)\r\n            return head;\r\n        ListNode *p = head;\r\n        while (p->next)\r\n        {\r\n            p = p->next;\r\n            len++;\r\n        }\r\n        if (k > len)\r\n            k %= len;\r\n        p->next = head;\r\n        for (int i = 0; i < len - k; i++)\r\n            p = p->next;\r\n        head = p->next;\r\n        p->next = NULL;\r\n        return head;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306648621","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == NULL || head->next == NULL)\n            return head;\n        \n        ListNode* pre = head;\n        ListNode* cur = head->next;\n        \n        pre->next = cur->next;\n        cur->next = pre;\n        \n        ListNode* next = swapPairs(pre->next);\n        pre->next = next;\n        \n        return cur;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310170075","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *ptr1 = headA;\n        ListNode *ptr2 = headB;\n        \n        while(ptr1 != ptr2){\n            ptr1 = ptr1->next;\n            ptr2 = ptr2->next;\n            \n            if(ptr1 == ptr2) break;\n            \n            if(ptr1 == NULL) ptr1 = headB;\n            if(ptr2 == NULL) ptr2 = headA;\n \n        }\n        return ptr1;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311189710","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while(fast && fast->next)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if(slow == fast)\n            {\n                slow = head;\n                \n                while(slow != fast)\n                {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                \n                return slow;\n            }\n        }\n        return NULL;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312641208","body":"class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root)\n            return 0;\n        int maxLeft = maxDepth(root->left);\n        int maxRight = maxDepth(root->right);\n        \n        return max(maxLeft, maxRight) + 1;\n    }\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313968035","body":"class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q)\n            return true;\n        if(!p || !q)\n            return false;\n        if(p->val != q->val)\n            return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right,q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314773758","body":"class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return addNodes(root, 0);\n    }\n    \n    int addNodes(TreeNode* node, int num)\n    {\n        if(node == NULL)\n            return 0;\n        if(!node->left && !node->right)\n            return num * 10 + node->val;\n        return addNodes(node->left, num * 10 + node->val) + addNodes(node->right, num * 10 + node->val);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316704136","body":"class Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        \n        q.push(root);\n        \n        while(!q.empty()){\n            root = q.front();\n            q.pop();\n            if(root->right)\n                q.push(root->right);\n            if(root->left)\n                q.push(root->left);\n        }\n        \n        return root->val;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320933686","body":"class Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int> &numbers, int target) {\r\n        unordered_map<int, int> numbers_m;\r\n        vector<int> res;\r\n        size_t i;\r\n        \r\n        for(i = 0; i < numbers.size(); i++)\r\n            numbers_m[numbers[i]] = i;\r\n        \r\n        for(i = 0; i < numbers.size(); i++)\r\n        {\r\n            int temp = target - numbers[i];\r\n            \r\n            if(numbers_m.find(temp) != numbers_m.end() && numbers_m[temp] > i)\r\n            {\r\n                res.push_back(i);\r\n                res.push_back(numbers_m[temp]);\r\n                return res;\r\n            }\r\n        }\r\n        \r\n\t\treturn res;\r\n    }\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320938931","body":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> q;\n        map<int, int> m;\n        vector<int> res;\n        \n        for(size_t i = 0; i < nums.size(); i++)\n            m[nums[i]]++;\n        \n        for(map<int,int>::iterator it = m.begin(); it != m.end(); it++)\n            q.push({it->second, it->first});\n        \n        for(int i = 0; i < k; i++)\n        {\n            res.push_back(q.top().second);\n            q.pop();\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321218925","body":"class Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        \n        int res = 0;\n        \n        for(int i = 0; i < points.size(); i++)\n        {\n            unordered_map<long, int> distance_count;\n            \n            for(int j = 0; j < points.size(); j++)\n            {\n                if(i == j)\n                    continue;\n                long distance = pow(points[i][0]-points[j][0],2) + pow(points[i][1]-points[j][1],2);\n                distance_count[distance]++;\n            }\n            \n            for(auto m:distance_count)\n                if(m.second > 1)\n                    res += m.second * (m.second - 1);\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322912478","body":"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int left = 0, right = 1;\n        int res = 0;\n        unordered_map<char, int> m;\n        \n        m[s[left]] = 1;\n        \n        if(s.size() == 0)\n            return 0;\n        \n        if(s.size() == 1)\n            return 1;\n        \n        while(right != s.size())\n        {\n            if(m.find(s[right]) == m.end())\n            {\n                m[s[right]] = 1;\n                res = max(res, right-left+1);\n                right++;\n                \n            }\n            else\n            {\n                while(s[left] != s[right])\n                {\n                    m.erase(s[left]);\n                    left++;\n                }\n                    \n                left++;\n                m.erase(s[right]);\n            }\n        }\n        return res;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327954425","body":"class Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n        \r\n        while(fast && fast->next)\r\n        {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        \r\n        return slow;;\r\n    }\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327953022","body":"class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int index = 0;\n        \n        for(int i = 0; i < nums.size() - 1; i++)\n        {\n            if(nums[i] != nums[i+1])\n            {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        nums[index] = nums[nums.size()-1];\n        return index+1;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328373061","body":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> res;\n        int* left = (int*)malloc(sizeof(int) * nums.size());\n        int* right = (int*)malloc(sizeof(int) * nums.size());\n        \n        *left = nums[0];\n        *(right + nums.size() - 1) = nums[nums.size() - 1];\n        \n        for(int i = 1; i < nums.size(); i++)\n        {\n            left[i] = (i % k == 0) ? nums[i] : max(left[i-1], nums[i]);\n            \n            int j = nums.size() - i - 1;\n            \n            right[j] = (j % k == 0) ? nums[j] : max(right[j+1], nums[j]);\n        }\n                        \n        for(int i = 0; i + k <= nums.size(); i++)\n        {\n            res.push_back(max(right[i], left[i+k-1]));     \n        }\n                        \n        return res;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331758002","body":"class Solution {\nprivate:\n    bool res = true;\n    vector<bool> visited;\n    vector<bool> dislike;\n    \npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \n    {\n        visited.resize(n + 1, false);\n        dislike.resize(n + 1, true);\n        \n        vector<vector<int>> graph = createGraph(n, dislikes);\n        \n        for(int i = 1; i < n + 1; i++)\n        {\n            if(!visited[i])\n            {\n                res = bfs(i, graph);\n                if(!res)\n                    return false;\n            }\n                \n        }\n        \n        return true;\n    }\n    \n    vector<vector<int>> createGraph(int n, vector<vector<int>>& dislikes)\n    {\n        vector<vector<int>> graph;\n        graph.resize(n + 1, vector<int>(0));\n        for(vector<int> vec : dislikes)\n        {\n            int v1 = vec[0];\n            int v2 = vec[1];\n            \n            graph[v1].push_back(v2);\n            graph[v2].push_back(v1);\n        }\n        return graph;\n    }\n    \n    bool bfs(int v, vector<vector<int>> graph)\n    {\n        if(!res)\n            return false;\n        \n        queue<int> q;\n        q.push(v);\n        \n        while(!q.empty() && res)\n        {\n            int vertex = q.front();\n            q.pop();\n            visited[vertex] = true;\n            \n            for(int neighbor : graph[vertex])\n            {\n                if(!visited[neighbor])\n                {\n                    dislike[neighbor] = !dislike[vertex];\n                    q.push(neighbor);\n                }\n                else\n                {\n                    if(dislike[neighbor] == dislike[vertex])\n                    {\n                        res = false;\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334700302","body":"class Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int RC = 0, LC = 0, UC = 0, DC = 0;\n        for(auto c:moves)\n        {\n            if(c == 'L')\n                LC++;\n            else if(c == 'R')\n                RC++;\n            else if(c == 'U')\n                UC++;\n            else if(c == 'D')\n                DC++;\n        }\n        \n        return LC == RC && DC == UC;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298345996","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        strings = ''\n        for i in num:\n            strings += str(i)\n        res = int(strings) + k\n        output = []\n        for i in str(res):\n            output.append(int(i))\n        return output","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304703297","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for index in arr:\n            if stack and stack[-1] > index:\n                current = stack[-1]\n                while stack and stack[-1] > index:\n                    stack.pop()\n                stack.append(current)\n            else:\n                stack.append(index)\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305486823","body":"class Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313542940","body":"public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n\n        if (q.val != p.val) return false;\n\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298416612","body":"### 思路\n\n直接还原num数组的数字加和再放入list——>有数值太大的情况，不行\n\n既然还原数字存在问题那就不还原\n\n-   遍历数组，从后往前的从num中拿出数字 `idxNum = num[length - 1 - i]`，令`k += idxNum`\n\n-   在遍历数组时，不断地对 k 取 10 的余数，然后 add 到 list，但是需要分情况讨论\n\n    -   遍历结束前 k == 0\n\n        在遍历的过程中，不断地对 k 取 10 的余数添加到list，直到 k == 0\n\n    -   遍历结束前 k != 0\n\n        对于这种情况需要进行判断`if (i == length - 1 && k != 0)`，如果满足，就进入循环中，直到 k 为 0\n\n-   最后，使用Collections工具类，将list翻转返回\n\n### 代码\n\n```java\nclass Solution {\n    public ArrayList addToArrayForm(int[] num, int k) {\n        int idxNum, length = num.length;\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxNum = num[length - 1 - i];\n            k += idxNum;\n            if (k != 0) {\n                list.add(k % 10);\n                k = k / 10;\n            } else {\n                list.add(k);\n            }\n            if (i == length - 1 && k != 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N + max(0, K - N))，N为数组的长度，K为k对应数字的长度\n- 空间复杂度：O(N) (不确定)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300132201","body":"### 思路\n\n对数组进行正反两次遍历\n\n-   先正序遍历，尽可能地写入到 answer 数组中\n-   再反序遍历，对于 answer 不为0的位置进行比较更新，对于 answer 为 0 且不是 c 的位置重新赋值\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int currentCharIdx = -1, length = s.length();\n        int[] answer = new int[length];\n\n        // 正序遍历\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                currentCharIdx = i;\n                answer[i] = 0;\n            } else if (currentCharIdx < 0) {\n                answer[i] = 0;\n            } else {\n                answer[i] = Math.abs(i - currentCharIdx);\n            }\n        }\n        // 反序遍历\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentCharIdx = i;\n            } else if (answer[i] != 0) {\n                answer[i] = Math.min(answer[i], Math.abs(i - currentCharIdx));\n            } else {\n                answer[i] = Math.abs(i - currentCharIdx);\n            }\n        }\n        return answer;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302000318","body":"### 思路\n\n根据栈的定义，在类中定义一个数组用于存储元素，定义current指针指向栈顶，定义maxSize记录栈的容量\n\n### 代码\n\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int current, maxSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.current = -1;\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if (current + 1 < maxSize) {\n            current++;\n            stack[current] = x;\n        }\n    }\n\n    public int pop() {\n        if (current > -1) return stack[current--];\n        else return -1;\n    }\n\n    public void increment(int k, int val) {\n        if (current + 1 > k)\n            for (int i = 0; i < k; i++) stack[i] += val;\n        else\n            for (int i = 0; i <= current; i++) stack[i] += val;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：\n\n    - `CustomStack()`O(1)\n\n    - `push()`O(1)\n\n    - `pop()`O(1)\n\n    - `increment()`O(max(k, currentNums)) \n\n        >   `currentNums`是当前栈的大小\n\n- 空间复杂度：O(N) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303514136","body":"### 思路\n\n最后写的脑袋晕晕沉沉，总算是ac了\n\n维护两个stack，一个是数字栈，一个是字符串栈，遍历给定的字符串`char c = s.charAt(i)`：\n\n-   c 是数字\n\n    题目中数字没有限定是个位数，因此需要保留并计算\n\n-   `c == '['`\n\n    此时记录数字完成，开始记录区间内的字符串，因此需要完成：\n\n    -   将记录的数字入栈，数字归零\n    -   将记录的字符串入栈，字符串内容清空\n\n-   c 是字母\n\n    将字母`append`到当前记录的字符串中\n\n-   `c == ']'`\n\n    此时，小区间的字符串记录完成，需要进行解码操作：\n\n    -   获取当前区间对应的重复次数num——数字栈出栈\n    -   获取上一次记录的字符串temp——字符串栈出栈（没有的话是`\"\"`）\n    -   将记录的当前小区间字符串在temp后面添加num次，保留temp\n\n直到遍历完成\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        Stack<Integer> numStack = new Stack<>();\n        Stack<StringBuffer> stringStack = new Stack<>();\n\n        StringBuffer result = new StringBuffer();\n        int multi = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                multi = 10 * multi + c - '0';\n            } else if (c == '[') {\n                stringStack.push(result);\n                numStack.add(multi);\n                result = new StringBuffer();\n                multi = 0;\n            } else if (Character.isAlphabetic(c)) {\n                //记录当前小段的 string\n                result.append(c);\n            } else if (c == ']') {\n                // decode\n                StringBuffer temp = stringStack.pop();\n                multi = numStack.pop();\n                for (int j = 0; j < multi; j++) temp.append(result);\n                multi = 0;\n                result = temp;\n            }\n        }\n        return result.toString();\n    }\n}\n\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1308563165","body":"### 思路\n\n两个栈，一个栈用于中转数据，一个栈用于存储数据。\n\n需要注意的是，在`push()`时调整栈中元素顺序比较方便，否则需要在`pop()`和`peek()`方法中都调整元素顺序\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> storeStack;\n    Stack<Integer> tempStack;\n\n\n    public MyQueue() {\n        this.storeStack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!storeStack.empty()) {\n            tempStack.push(storeStack.pop());\n        }\n        tempStack.push(x);\n        while (!tempStack.empty()) {\n            storeStack.push(tempStack.pop());\n        }\n    }\n\n    public int pop() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.pop();\n    }\n\n    public int peek() {\n        return storeStack.peek();\n    }\n\n    public boolean empty() {\n        return storeStack.empty();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1333792993","body":"### 思路\n\n计数法\n\n当前数组`arr`、排好序的数组`excepted`\n\n如果两个数组从0~n截取的子数组排序后是一样的，那么这两个数组内各个元素的个数都是相等的；反之，则是两个数组则不同\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();\n        int ans = 0, nonZero = 0;\n        int[] excepted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(excepted);\n\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i];\n            int y = excepted[i];\n\n            hashMap.put(x, hashMap.getOrDefault(x, 0) + 1);\n\n            if (hashMap.get(x) == 0) nonZero--;\n\n            if (hashMap.get(x) == 1) nonZero++;\n\n            hashMap.put(y, hashMap.getOrDefault(y, 0) - 1);\n\n            if (hashMap.get(y) == -1) nonZero++;\n\n            if (hashMap.get(y) == 0) nonZero--;\n\n            if (nonZero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1313762132","body":"### 思路\n\n将链表首尾相接，构成环形链表。\n\n节点向右移动k个长度→head向右移动`size - k % size`个长度\n\n将头节点移动后，将其前一个节点与他的连接断开，返回新的头节点即可\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null) return head;\n        ListNode temp = head, tail;\n        int length = 1;\n        while (temp.next != null) {\n            temp = temp.next;\n            length++;\n        }\n        tail = temp;\n        tail.next = head;\n        k = length - k % length;\n        if (k == 0) return head;\n        temp = head;\n        for (int i = 0; i < k; i++) {\n            temp = temp.next;\n        }\n        head = temp;\n        while (temp.next != head) {\n            temp = temp.next;\n            if (temp.next == head) break;\n        }\n        temp.next = null;\n        return head;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307327084","body":"``` JAVA\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode pre = null;\n        ListNode current = head;\n        ListNode next = head.next;\n        ListNode tmp;\n        head = next;\n\n        while (true) {\n            tmp = next.next;\n            current.next = tmp;\n            next.next = current;\n            if (pre != null) {\n                pre.next = next;\n            }\n\n            pre = current;\n            if (pre.next == null) {\n                return head;\n            }\n            current = pre.next;\n            if (pre.next.next == null) {\n                return head;\n            }\n            next = pre.next.next;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308691179","body":"先打卡，明天补全\n``` java\nclass Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return dfs(head, null);\n    }\n\n    private TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        }\n\n        ListNode slowNode = head, fastNode = head;\n\n        while (fastNode != tail && fastNode.next != tail) {\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n        TreeNode root = new TreeNode();\n        root.val = slowNode.val;\n        root.left = dfs(head, slowNode);\n        root.right = dfs(slowNode.next, tail);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310228548","body":"``` java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311648965","body":"``` java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n\n        if (head == null) {\n            return null;\n        }\n        ListNode fast = head, slow = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                // fast or slow\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312727615","body":"``` java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313649595","body":"### 思路\n\n层序遍历，递归比较每层的节点是否相等\n\n### 代码\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        }\n\n        if (p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(min(M,N))（M、N分别是两棵树的高度）\n- 空间复杂度：O(min(M,N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314829173","body":"### 思路\n\n深度优先，记忆递归\n\n递归回调条件：`root.left == null && root.right == null`\n\n### 代码\n\n```java\nclass Solution {\n    // 记录结果\n    int sum = 0;\n\n    public int sumNumbers(TreeNode root) {\n        // 从根节点开始遍历，传入节点和当前值\n        dfs(root, 0);\n        return sum;\n    }\n\n    private void dfs(TreeNode root, int currentNum) {、\n        // 终止条件\n        if (root.left == null && root.right == null) {\n            sum = currentNum * 10 + root.val + sum;\n            return;\n        }\n        currentNum = currentNum * 10 + root.val;\n        // 递归调用\n        if (root.left != null) dfs(root.left, currentNum);\n        if (root.right != null) dfs(root.right, currentNum);\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n\n- 空间复杂度：O(H)\n\n    >N为节点数，H为树高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316947217","body":"### 思路\n\n要找左下角的元素，第一想到了层序遍历，记录每层第一个节点的值。\n\n### 代码\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        return bfs(root);\n    }\n\n    private int bfs(TreeNode node) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(node);\n        int res = 0;\n        while (queue.size() > 0) {\n            Queue<TreeNode> currentLayer = queue;\n            queue = new LinkedList<>();\n            int size = currentLayer.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode currentNode = currentLayer.poll();\n                // 记录每层第一个节点值\n                if (i == 0) res = currentNode.val;\n                if (currentNode.left != null) queue.add(currentNode.left);\n                if (currentNode.right != null) queue.add(currentNode.right);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318648645","body":"``` java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n\n        if (root == null) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                sb.append(node.val + \",\");\n                queue.add(node.left);\n                queue.add(node.right);\n            } else {\n                sb.append(\"X,\");\n            }\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data == \"\" || data == null) {\n            return null;\n        }\n        Queue<String> queueString = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        TreeNode root = new TreeNode(Integer.parseInt(queueString.poll()));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queueString.isEmpty()) {\n\n            TreeNode node = queue.poll();\n            String left = queueString.poll();\n            String right = queueString.poll();\n\n            if (!Objects.equals(left, \"X\")) {\n                assert node != null;\n                node.left = new TreeNode(Integer.parseInt(left));\n                queue.add(node.left);\n            }\n            if (!Objects.equals(right, \"X\")) {\n                assert node != null;\n                node.right = new TreeNode(Integer.parseInt(right));\n                queue.add(node.right);\n            }\n        }\n\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319953182","body":"``` java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    // 列\n    int col = 0;\n    // 排\n    int row = 0;\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n\n        List<int[]> list = new ArrayList<>();\n        dfs(root, col, row, list);\n\n        if (list == null) {\n            return null;\n        }\n        list.sort(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if (o1[0] == o2[0] && o1[1] == o2[1]) {\n                    return o1[2] - o2[2];\n                }\n                if (o1[0] == o2[0]) {\n                    return o1[1] - o2[1];\n                }\n                return o1[0] - o2[0];\n            }\n        });\n        List<List<Integer>> resList = new ArrayList<>();\n\n        int currentCol = Integer.MIN_VALUE;\n        for (int i = 0; i < list.size(); i++) {\n            int col = list.get(i)[0];\n            if (currentCol == col) {\n                resList.get(resList.size() - 1).add(list.get(i)[2]);\n                continue;\n            }\n            currentCol = col;\n            List<Integer> tempList = new ArrayList<>();\n            tempList.add(list.get(i)[2]);\n            resList.add(tempList);\n        }\n\n\n        return resList;\n    }\n\n    private void dfs(TreeNode node, int col, int row, List<int[]> nodeList) {\n        if (node == null) {\n            return;\n        }\n        nodeList.add(new int[]{col, row, node.val});\n        // 深度优先\n        dfs(node.left, col - 1, row + 1, nodeList);\n        dfs(node.right, col + 1, row + 1, nodeList);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1322064052","body":"### 思路\n\n暴力解法，将所有的数放到HashSet中，然后依次遍历\n\n### 代码\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) set.add(num);\n        Integer remain;\n        int[] res = new int[]{};\n        for (int i = 0; i < nums.length; i++) {\n            remain = target - nums[i];\n            if (set.contains(remain)) {\n                for (int j = 0; j < nums.length; j++) {\n                    if (i != j && nums[j] == remain) {\n                        res = new int[]{i, j};\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O($$N^2$$)\n- 空间复杂度：O(N)\n\n\n\n\n\n\n\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322065007","body":"``` java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n\n    \n        if (points.length < 3) {\n            return 0;\n        }\n        int ans = 0;\n        int length = points.length;\n\n        for (int i = 0; i < points.length; i++) {\n            HashMap<Integer, Integer> hashMap = new HashMap<>();\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) {\n                    continue;\n                }\n                int distance =\n                        (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n                                (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]); \n                hashMap.put(distance, hashMap.containsKey(distance) ? hashMap.get(distance) + 1 : 1);\n            }\n            for (Integer value : hashMap.values()) {\n                if (value >= 2) {\n                    ans += value * (value - 1);\n                }\n            }\n\n        }\n\n\n        return ans;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323750152","body":"``` java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n           HashMap<Character,Integer> window=new HashMap<>();\n        int left=0,right=0;\n        int res=0;\n        while(right<s.length()){\n            char c=s.charAt(right);\n            right++;\n            window.put(c,window.getOrDefault(c,0)+1);\n            while (window.get(c)>1){\n                char d=s.charAt(left);\n                left++;\n                window.put(d,window.get(d)-1);\n            }\n            res=Math.max(res,right-left);\n        }\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326509065","body":"``` java\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> record = {{0, 1}};\n        int sum = 0, ans = 0;\n        for (int elem: nums) {\n            sum += elem;\n            int modulus = (sum % k + k) % k;\n            if (record.count(modulus)) {\n                ans += record[modulus];\n            }\n            ++record[modulus];\n        }\n        return ans;\n    }\n};\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327379660","body":"### 思路\n\n快慢指针，快指针到了尾端，慢指针正好在中间\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328944245","body":"``` java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int j = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328945011","body":"``` java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329316437","body":"```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        priority_queue<pair<int, int>> q;\n        for (int i = 0; i < k; ++i) {\n            q.emplace(nums[i], i);\n        }\n        vector<int> ans = {q.top().first};\n        for (int i = k; i < n; ++i) {\n            q.emplace(nums[i], i);\n            while (q.top().second <= i - k) {\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330763943","body":"``` java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[][] trustGraph = new int[n][2];\n\n        for (int i = 0; i < trust.length; i++) {\n            int person = trust[i][0];\n            int trustPerson = trust[i][1];\n            trustGraph[person - 1][0]++;\n            trustGraph[trustPerson - 1][1]++;\n        }\n\n        for (int i = 0; i < trustGraph.length; i++) {\n            if (trustGraph[i][0] == 0 && trustGraph[i][1] == n - 1) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332071892","body":"``` java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        graph = new ArrayList[n + 1];\n        for (int i = 1; i <= n; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge : dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= n; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0)) return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node)) return color.get(node) == c;\n        color.put(node, c);\n\n        for (int nei : graph[node])\n            if (!dfs(nei, c ^ 1)) return false;\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333795065","body":"so hard\n``` java\npublic class Solution {\n\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 第 2 步：实例化组和项目的邻接表\n        List<Integer>[] groupAdj = new ArrayList[m];\n        List<Integer>[] itemAdj = new ArrayList[n];\n        for (int i = 0; i < m; i++) {\n            groupAdj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemAdj[i] = new ArrayList<>();\n        }\n\n        // 第 3 步：建图和统计入度数组\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        int len = group.length;\n        for (int i = 0; i < len; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj[beforeGroup].add(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (Integer item : beforeItems.get(i)) {\n                itemAdj[item].add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        // 第 4 步：得到组和项目的拓扑排序结果\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupsList.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemsList.size() == 0) {\n            return new int[0];\n        }\n\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (Integer item : itemsList) {\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        List<Integer> res = new ArrayList<>();\n        for (Integer groupId : groupsList) {\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Integer front = queue.poll();\n            res.add(front);\n            for (int successor : adj[front]) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0) {\n                    queue.offer(successor);\n                }\n            }\n        }\n\n        if (res.size() == n) {\n            return res;\n        }\n        return new ArrayList<>();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335430720","body":"``` java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n\n        if (moves == null || moves.length() == 0) {\n            return true;\n        }\n\n        //int[] position = new int[]{0, 0};\n        int x = 0, y = 0;\n\n        for (char c : moves.toCharArray()) {\n\n            switch (c) {\n                case 'R' -> x++;\n                case 'L' -> x--;\n                case 'U' -> y++;\n                case 'D' -> y--;\n            }\n\n        }\n        return (x == 0 && y == 0);\n    }\n    \n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297919309","body":"## 思路\r\n\r\n\r\n把num从list转化成str，再转化成int与k相加，最后返回list形式。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''.join(map(str, num))\r\n        sum = int(x) + k\r\n        return list(map(int, str(sum)))\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299640797","body":"## 思路\r\n\r\n\r\n首先从左往右遍历求距离，再从右往左遍历求距离，计算两边距离的最小值。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [n for i in range(n)]\r\n        dist = n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                dist = 0\r\n            else:\r\n                dist += 1 \r\n            ans[i] = dist\r\n        for j in range(n-1, -1, -1):\r\n            if s[j] == c:\r\n                dist = 0\r\n            else:\r\n                dist += 1\r\n            ans[j] = min(dist, ans[j])\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302069633","body":"## 思路\r\n\r\n\r\n用数组模拟栈操作\r\n\r\n## 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n            \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.size)):\r\n            self.stack[i] += val\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time: push：****$O(1)$， ****pop：****$O(1)$， ****increment：****$O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303062796","body":"## 思路\r\n\r\n---\r\n\r\n双栈，一个栈存放数字，一个栈存放字母\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                tmpstr = \"\"\r\n                numstr = \"\"\r\n                while stack and stack[-1] != \"[\":\r\n                    char = stack.pop()\r\n                    tmpstr = char + tmpstr\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop()\r\n                    numstr = num + numstr\r\n                stack.append(int(numstr) * tmpstr)\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304427028","body":"## 思路\r\n\r\n\r\n使用两个栈（先进后出）实现队列（先进先出），一个栈用来存储元素\r\n\r\n## 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack1.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.stack1.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.stack1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.stack1:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time: push:**** $O(N)$ ****pop:**** $O(1)$ ****peek:**** $O(1)$  ****empty:**** $O(1)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304997160","body":"## 思路\r\n\r\n\r\n从左向右遍历数组，下一分块的最小值应该大于上一分块的最大值，每一分块用块中最大值表示\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        n = len(arr)\r\n        for i in range(n):\r\n            m = arr[i]\r\n            while stack and stack[-1] > arr[i]:\r\n                m = max(stack.pop(), m)\r\n            stack.append(m)\r\n        return len(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305617402","body":"## 思路\r\n\r\n\r\n遍历链表得到链表长度，连接链表首尾形成环形链表，然后根据移动的距离断开链表。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next or k==0: return head\r\n        n_nodes = 1\r\n        tail = p = head\r\n        while tail.next:\r\n            n_nodes += 1\r\n            tail = tail.next\r\n        tail.next = head\r\n\r\n        for _ in range(n_nodes - k%n_nodes - 1):\r\n            p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n\r\n        return new_head\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307173696","body":"## 思路\r\n\r\n---\r\n\r\n迭代的方法，由preA -> A -> B ->nextB 修改为 preA ->B ->A ->nextB，交换两个节点位置，经过3次操作A.next = B.next; B.next = A; preA.next = B. \r\n\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n\r\n        new_head = ListNode(next = head)\r\n        prev = new_head\r\n        cur = head\r\n        while cur and cur.next:\r\n            n_node = cur.next\r\n            cur.next = n_node.next\r\n            n_node.next = cur\r\n\r\n            prev.next = n_node\r\n            prev = cur\r\n            cur = cur.next\r\n        return new_head.next\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308610220","body":"## 思路\r\n\r\n\r\n使用快慢指针找到二叉树的根节点，中点左边的值构造左子树，右边的值构造右子树；最后递归链表生成二叉树。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        return self.buildTree(head, None)\r\n        \r\n    def buildTree(self, head, tail):\r\n        if head == tail: return\r\n        slow = head\r\n        fast = head\r\n        while fast != tail and fast.next != tail:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        root = TreeNode(slow.val)\r\n        root.left = self.buildTree(head, slow)\r\n        root.right = self.buildTree(slow.next, tail)\r\n        return root\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(nlogn)$\r\n- **Space:** $O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309717348","body":"## 思路\r\n\r\n\r\n使用两个指针分别指向两条链表的头节点。当a到达链表A的尾部，将它重定位到链表B的头节点；b同理。在此过程中a、b指针相遇，相遇节点则为两链表相交的起始节点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1312734521","body":"## 思路\r\n\r\n\r\n快慢两个指针，从head结点走到入环点需要走a + nb， 而slow已经走了nb，那么slow再走a步即为入环点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312982036","body":"## 思路\r\n\r\n\r\n哈希表加双向链表\r\n\r\n## 代码\r\n\r\n```python\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def move_node_to_tail(self, key):\r\n        node = self.hashmap[key]\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev.next = node\r\n        self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            self.hashmap[key].value = value\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                self.hashmap.pop(self.head.next.key)\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(1)$\r\n- **Space:** $O(N)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1313049274","body":"## 思路\r\n\r\n\r\nDFS；递归很好用\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if root == None:\r\n            return 0\r\n        left_depth = self.maxDepth(root.left)\r\n        right_depth = self.maxDepth(root.right)\r\n        return max(left_depth, right_depth) + 1\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- ***Space:*** $O(h)$ ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313160627","body":"## 思路\r\n\r\n\r\n深度优先搜索，递归的判断是否相同\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(min(m,n))$, m和n分别为两个二叉树的节点数\r\n- **Space:** $O(min(m,n))$, m和n分别为两个二叉树的节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315265470","body":"## 思路\r\n\r\n\r\n深度优先搜索，遍历每个节点然后分别对左右子节点进行递归。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(root, prevTotal):\r\n            if not root: \r\n                return 0\r\n            total = prevTotal * 10 + root.val\r\n            if not root.left and not root.right:\r\n                return total\r\n            else:\r\n                return dfs(root.left, total) + dfs(root.right, total)\r\n        return dfs(root, 0)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$, n是二叉树节点个数\r\n- **Space:** $O(n)$, n是二叉树节点个数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318189889","body":"## 思路\r\n\r\n\r\nDFS前序遍历\r\n\r\n## 代码\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        def preorder(root):\r\n            if not root:\r\n                return \"null,\"\r\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\r\n\r\n        return preorder(root)[:-1]\r\n\r\n    def deserialize(self, data: str):\r\n        nodes = data.split(\",\")\r\n\r\n        def preorder(i):\r\n            if i >= len(nodes) or nodes[i] == \"null\":\r\n                return i, None\r\n            root = TreeNode(nodes[i])\r\n            j, root.left = preorder(i + 1)\r\n            k, root.right = preorder(j + 1)\r\n            return k, root\r\n\r\n        return preorder(0)[1]\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$, N是二叉树节点个数\r\n- **Space:** $O(h)$, h是树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319782307","body":"## 思路\r\n\r\n\r\n遍历一遍二叉树的节点，保存节点的横纵坐标和节点的值，根据纵坐标，横坐标，节点的值依次排序，再遍历一遍将每一列的节点的值取出。\r\n\r\n## 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = []\r\n        def dfs(root, row, col):\r\n            if not root: return None\r\n            nodes.append((col, row, root.val))\r\n            dfs(root.left, row+1, col-1)\r\n            dfs(root.right, row+1, col+1)\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans = []\r\n        i = j = 0\r\n        while i < len(nodes):\r\n            col_ans = []\r\n            while j< len(nodes) and nodes[j][0] == nodes[i][0]:\r\n                col_ans.append(nodes[j][2])\r\n                j += 1\r\n            ans.append(col_ans)\r\n            i = j\r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n\r\n- 时间复杂度：O(NlogN),N是节点的数量\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320825254","body":"## 思路\r\n\r\n\r\n使用哈希表\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        n = len(nums)\r\n        for i in range(1, n):\r\n            temp = nums[:i]\r\n            if (target - nums[i]) in temp:\r\n                j = temp.index(target - nums[i])\r\n                break\r\n        return [i,j]\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321148820","body":"## 思路\r\n\r\n\r\n使用哈希表+堆排序\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count = list(collections.Counter(nums).items())\r\n        count = list(map(lambda x: (-x[1], x[0]), count))\r\n        heapq.heapify(count)\r\n        res = []\r\n        for _ in range(k):\r\n            res.append(heapq.heappop(count)[1])\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(klogM)$\r\n- **Space:** $O(M),M是不同元素个数$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322186038","body":"## 思路\r\n\r\n\r\n枚举每个距离相等的点，从其中选出两个端点。考虑顺序，将每个点作为原点遍历之后累加。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for p in points:\r\n\t      cnt = defaultdict(int)\r\n\t      for q in points:\r\n\t\t    dis = (p[0]-q[0]) * (p[0]-q[0]) + (p[1]-q[1]) * (p[1]-q[1])\r\n\t\t    cnt[dis] += 1\r\n\t      for m in cnt.values():\r\n\t\t    ans += m * (m-1)\r\n\t return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n2)$，n为数组长度\r\n- **Space:** $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323852561","body":"## 思路\r\n\r\n\r\n判断元素是否在滑动窗口内\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        a = []\r\n        res = 0\r\n        for i in s:\r\n            if i in a:\r\n                a = a[a.index(i) + 1:]\r\n            a.append(i)\r\n            res = max(res, len(a))\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325290958","body":"## 思路\r\n\r\n\r\n前缀和：子数组 A[i:j] 的和就是 pres[j] - pres[i-1]，其中 pres 为 A 的前缀和。\r\n同余：两个模k余数相同的数字相减，得到的值定可以被k整除。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        total = sum(nums)\r\n        mod = total % k\r\n\r\n        ans = len(nums)\r\n        total = 0\r\n        dic = {0: -1}\r\n        for j in range(len(nums)):\r\n            total += nums[j]\r\n            cur = total % k\r\n            target = (cur - mod + k) % k\r\n            if target in dic:\r\n                ans = min(ans, j - dic[target])\r\n            dic[cur] = j\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- **Space:** $O(min(n,k))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326617633","body":"## 思路\r\n\r\n\r\n使用快慢指针，当快指针走到链表尾部，慢指针刚好走到中间\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if head is None:\r\n            return None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为链表长度\r\n- ***Space:***","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327997903","body":"## 思路\r\n\r\n\r\n使用双指针，快指针遍历每个位置，当元素不同时，将此值赋给慢指针位置\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        fast = slow = 1\r\n        while fast < len(nums):\r\n            if nums[fast] != nums[fast - 1]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        return slow\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328272559","body":"## 思路\r\n\r\n---\r\n\r\n二分法\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left, right = 0, len(nums) - 1\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n\r\n            if nums[middle] < target:\r\n                left = middle + 1\r\n            elif nums[middle] > target:\r\n                right = middle - 1\r\n            else:\r\n                return middle\r\n        return right + 1\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(logn)$，n为数组长度\r\n- ***Space:*** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329313914","body":"## 思路\r\n\r\n\r\n用双端队列保存滑动窗口最大值，移除失效元素\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        q, res = [], []\r\n        for i, num in enumerate(nums):\r\n            while q and q[-1][1] < num:\r\n                q.pop()\r\n            q.append((i, num))\r\n            while i - q[0][0] >= k:\r\n                q.pop(0)\r\n            if i >= k-1:\r\n                res.append(q[0][1])\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- ***Space:*** $O(k)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330826217","body":"## 思路\r\n\r\n---\r\n\r\n求图的入度和出度，找到入度为n-1，出度为0的点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n     def findJudge(self, N, trust):\r\n        count = [0] * (N + 1)\r\n        for i, j in trust:\r\n            count[i] -= 1\r\n            count[j] += 1\r\n        for i in range(1, N + 1):\r\n            if count[i] == N - 1:\r\n                return i\r\n        return -1\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- ***Space:*** $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332362931","body":"## 思路\r\n\r\n---\r\n\r\n建立并遍历图，使用染色法给图中的点进行分组。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def dfs(self, graph, colors, i, color, N):\r\n        colors[i] = color\r\n        for j in range(N):\r\n            # dislike eachother\r\n            if graph[i][j] == 1:\r\n                if colors[j] == color:\r\n                    return False\r\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\r\n                    return False\r\n        return True\r\n\r\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\r\n        graph = [[0] * N for i in range(N)]\r\n        colors = [0] * N\r\n        for a, b in dislikes:\r\n            graph[a - 1][b - 1] = 1\r\n            graph[b - 1][a - 1] = 1\r\n        for i in range(N):\r\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\r\n                return False\r\n        return True\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(m+n)$，m和n分别为图中点和边的数目\r\n- ***Space:*** $O(m^2)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314813262","body":"- Time: $O(N)$, N 为节点数\r\n- Space: $O(H)$, H 为树的高度\r\n\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        int ans = 0;\r\n        dfs(root, 0, ans);\r\n        return ans;\r\n    }\r\nprivate:\r\n    void dfs(TreeNode* root, int path, int& ans) {\r\n        if (!root) return;\r\n\r\n        path = path * 10 + root->val;\r\n\r\n        if (!root->left && !root->right) {\r\n            ans += path;\r\n            return;\r\n        }\r\n\r\n        dfs(root->left, path, ans);\r\n        dfs(root->right, path, ans);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316234676","body":"```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        // return dfs(root);\r\n        return bfs(root);\r\n    }\r\nprivate:\r\n    int dfs(TreeNode* root) {\r\n        int ans = -1, max_level = -1;\r\n        dfs(root, 0, max_level, ans);\r\n        return ans;\r\n    }\r\n\r\n    void dfs(TreeNode* root, int level, int& max_level, int& ans) {\r\n        if (!root) return;\r\n\r\n        if (max_level < level) {\r\n            max_level = level;\r\n            ans = root->val;\r\n        }\r\n\r\n        dfs(root->left, level + 1, max_level, ans);\r\n        dfs(root->right, level + 1, max_level, ans);\r\n    }\r\n\r\n    int bfs(TreeNode* root) {\r\n        if (!root) return -1;\r\n\r\n        int ans = -1;\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            ans = q.front()->val;\r\n\r\n            int size = q.size();\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                if (node->left) q.push(node->left);\r\n                if (node->right) q.push(node->right);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318185720","body":"```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n    string empty_node = \"#\";\r\n    string delimeter = \",\";\r\n    string end_of_level = \";\";\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        if (!root) return string();\r\n\r\n        string serialized_string;\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            int size = q.size();\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                if (node) {\r\n                    serialized_string += to_string(node->val);\r\n                    q.push(node->left);\r\n                    q.push(node->right);\r\n                } else {\r\n                    serialized_string += empty_node;\r\n                }\r\n                serialized_string += delimeter;\r\n            }\r\n        }\r\n\r\n        return serialized_string;\r\n    }\r\n\r\n    TreeNode* makeTreeNode(const string& data, int& pos) {\r\n        string::size_type delim = data.find(delimeter, pos);\r\n        string val = data.substr(pos, delim - pos);\r\n        pos = delim + 1;\r\n\r\n        if (val.compare(empty_node) == 0)\r\n            return nullptr;\r\n\r\n        return new TreeNode(stoi(val));\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        if (data.empty()) return nullptr;\r\n\r\n        int i = 0;\r\n        TreeNode* root = makeTreeNode(data, i);\r\n\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            int size = q.size();\r\n\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                node->left = makeTreeNode(data, i);\r\n                node->right = makeTreeNode(data, i);\r\n\r\n                if (node->left)\r\n                    q.push(node->left);\r\n                if (node->right)\r\n                    q.push(node->right);\r\n            }\r\n        }\r\n\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321376511","body":"- Time: $O(N^2)$\r\n- Space: $O(N)$\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int ans = 0;\r\n\r\n        for (int i = 0; i < points.size(); i++) {\r\n            unordered_map<int, int> dist_counts;\r\n\r\n            for (int j = 0; j < points.size(); j++) {\r\n                int x1 = points[i][0], y1 = points[i][1];\r\n                int x2 = points[j][0], y2 = points[j][1];\r\n                int dist = pow(x1 - x2, 2) + pow(y1 - y2, 2);\r\n                dist_counts[dist]++; \r\n            }\r\n\r\n            for (auto it : dist_counts)\r\n                ans += it.second * (it.second - 1);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324686639","body":"- Time: $O(n*(n-m))$, n is the length of `s`, m is the total length of all the words in `words`\r\n- Space: $O(m)$, m is the size of `words`\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        int word_len = words[0].size();\r\n        int substr_len = word_len * words.size();\r\n        vector<int> res;\r\n\r\n        if (s.size() < substr_len) return res;\r\n    \r\n        unordered_map<string, int> available_words;\r\n        for (auto& word : words)\r\n            available_words[word]++;\r\n\r\n        for (int i = 0; i <= s.size() - substr_len; i++) {\r\n            unordered_map<string, int> words_count;\r\n\r\n            for (int j = i; j <= i + substr_len - word_len; j += word_len)\r\n                words_count[s.substr(j, word_len)]++;\r\n\r\n            if (available_words == words_count) res.emplace_back(i);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304830763","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        cnt = Counter()\r\n        res = 0\r\n        for x, y in zip(arr, sorted(arr)):\r\n            cnt[x] += 1\r\n            if cnt[x] == 0:\r\n                del cnt[x]\r\n            cnt[y] -= 1\r\n            if cnt[y] == 0:\r\n                del cnt[y]\r\n            if len(cnt) == 0:\r\n                res += 1\r\n        return res\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304810452","body":"class Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312750422","body":"class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298382347","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tmp = []\n        n = 0\n        for i in range(len(num)-1,-1,-1):\n            k, m = k//10, k%10\n            n, t = (num[i]+m+n)//10, (num[i]+m+n)%10\n            tmp.append(t)\n        k = k+n\n        while k!=0:\n            k,m = k//10,k%10\n            tmp.append(m)\n        return tmp[::-1]\n```\n### 复杂度分析\n- 时间复杂度：O（n）\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299439197","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if s[0]==c:\n            beg = 0\n        else:\n            beg = len(s)\n        end = s.find(c,1)\n        res = []\n        for i in range(len(s)):\n            res.append(min(abs(i-beg),abs(i-end)))\n            if i == end:\n                beg = end\n                end = s.find(c,beg+1)\n        return res\n```\n### 复杂度分析\n- 时间复杂度：O（n） \n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1306683100","body":"### 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.size = maxSize\r\n        self.stk = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk)<self.size:\r\n            self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk)==0:\r\n            return -1\r\n        return self.stk.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(len(self.stk)):\r\n            if i<k:\r\n                self.stk[i]+=val\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303088901","body":"### 思路\n使用栈，遍历字符串，将字符数字和‘【’入栈，直到碰到‘】’，开始出栈，将‘【’之前的字符出栈存在restr里面，然后将‘【’之后的数字出栈存在num中，然后将num倍的restr入栈，直到遍历结束\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stk = []\n        for x in s:\n            if x==']':\n                restr = ''\n                num = ''\n                while stk and stk[-1]!='[':\n                    restr = stk.pop()+restr\n                stk.pop()\n                while stk and stk[-1].isnumeric():\n                    num = stk.pop()+num\n                stk.extend(restr*int(num))\n            else:\n                stk.append(x)\n        return ''.join(stk)\n```\n### 复杂度分析\n- 时间复杂度：O（n） \n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1306681084","body":"### 思路\r\n用两个栈实现队列\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stk = []\r\n        self.stk2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.stk:\r\n            self.stk2.append(self.stk.pop())\r\n        x = self.stk2.pop()\r\n        while self.stk2:\r\n            self.stk.append(self.stk2.pop())\r\n        return x\r\n\r\n    def peek(self) -> int:\r\n        while self.stk:\r\n            self.stk2.append(self.stk.pop())\r\n        x = self.stk2.pop()\r\n        self.stk2.append(x)\r\n        while self.stk2:\r\n            self.stk.append(self.stk2.pop())\r\n        return x\r\n\r\n    def empty(self) -> bool:\r\n        if not (self.stk or self.stk2):\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O（n） \r\n- 空间复杂度：O（n）","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310419817","body":"### 代码\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if not p1:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if not p2:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315011350","body":"### 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = 0\n        q = deque()\n        q.append((root,0))\n        while q:\n            node,value = q.popleft()\n            if node.left:\n                q.append((node.left,value*10+node.val))\n            if node.right:\n                q.append((node.right,value*10+node.val))\n            if not node.left and not node.right:\n                res += value*10+node.val\n        return res\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322138601","body":"### 思路\n哈希\n### 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) < 3:\n            return 0\n        from collections import defaultdict\n        n = len(points)\n        res = 0\n        for i in range(n):\n            m = defaultdict(int)\n            for j in range(n):\n                if i!=j:\n                    dis = (points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2\n                    m[dis]+=1\n            for v in m.values():\n                res += v*(v-1)\n        return res\n```\n### 复杂度分析\n- 时间：O（n^2） \n- 空间：O（n）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329005909","body":"### 代码\n```python\nclass MyQueue(object):\n    def __init__(self):\n        self.queue = []\n    \n    def pop(self, value):\n        if self.queue and value == self.queue[0]:\n            self.queue.pop(0)\n    \n    def push(self, value):\n        while self.queue and value>self.queue[-1]:\n            self.queue.pop()\n        self.queue.append(value)\n    \n    def front(self):\n        return self.queue[0]\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        que = MyQueue()\n        res = []\n        for i in range(k):\n            que.push(nums[i])\n        res.append(que.front())\n        for i in range(k, len(nums)):\n            que.pop(nums[i-k])\n            que.push(nums[i])\n            res.append(que.front())\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305655564","body":"## 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next:\n            cut += 1\n            if cut == cnt - k:\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n            \n        return res if res else head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298145845","body":"### **思路：加法问题**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n，所以要考虑遍历完还有k或者carry的情况\n    \n    \n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1: # while a没完 or b没完\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304457480","body":"## **思路：两个栈倒腾**\n\n之前写过O(n)的，以下是O(1)的思路\n\nO(n)也是两个栈互相倒，但是复杂度较高。两个栈stackin和stackout一个只用来进新的元素一个只用来出结果。用一个**辅助的self.front变量，记录stackin最前面元素**。\n\npop的时候，rather than倒进去又倒出来，可以在stackout空的时候才倒，不空的时候直接出栈顶即可。peak的时候，如果stackout非空的话，肯定就是栈顶元素，否则，就是self.front\n\n### **代码**\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.stackin:\n            self.front = x\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if not self.stackout:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n        if self.empty():\n            return \n        return self.stackout.pop()\n\n    def peek(self) -> int:\n        return self.stackout[-1] if self.stackout else self.front\n\n    def empty(self) -> bool:\n        return not self.stackin and not self.stackout\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304787936","body":"用栈保存单调递增的片段的最大的值，中间小的不重要；所以可以用单调栈，如果碰到更小的就弹出来，直到小的能够放进去为止，该数字之前的片段才能保证排序之后递增，并且能和后面的连上。如果碰到更大的直接放进栈即可\n\n\n### **代码**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] # 用单调栈存储一个块的最大值，单调栈是递增的\n        for i, n in enumerate(arr):\n            if stack and n < stack[-1]: # 碰到更小的值，就得把前面的一个个拿出来，知道形成新的块能够合并掉这个最小值\n                cur_val = stack[-1]\n                while stack and n < stack[-1]:\n                    stack.pop()\n                stack.append(cur_val) # 要记录当前块的最大值并且放回去\n            else: # 碰到更大的值，可以无脑作为一个新的块\n                stack.append(n)\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312510932","body":"### **思路：双向链表+哈希**\n\n\n由于要求的是O1的复杂度，要求删除、添加、换位置都是O1能够用的是链表和哈希，这题的关键就说用**双向链表+哈希，双向链表存储节点的顺序，哈希存储key对应的node**。这里要注意的是：\n\n（1）双向链表用**两个哨兵做头尾**会比较方便边界计算，用一个dummy头和一个curnode指针也可以，但是要每次改curnode的位置，容易错\n\n（2）put和get值的时候虽然不把node取出，但是都算访问了node，需要把node放到最后\n\n（3）双向链表直接存储key和val，不能只存val，因为key和val可能不一样\n\n### **代码**\n\n```python\nclass ListNode:\n    def __init__(self, key=None, val=None):\n        self.prev = None\n        self.next = None\n        self.val = val\n        self.key = key\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        # 初始化哈希表 {key: ListNode}\n        self.hashmap = dict()\n        # 初始化双向链表\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        # 如果在hash中，返回该值。放到双向链表最后\n        if key in self.hashmap:\n            self.move_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        return -1 if res == -1 else res.val\n            \n    def move_to_tail(self, key) -> None:\n        node = self.hashmap[key]\n\t\t\t\t# 拆出\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\t\t\t\t# 插入\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 若该key已经在双向链表中，把该key放到最后，并且改变值\n            self.hashmap[key].val = value\n            self.move_to_tail(key)\n            return\n        if len(self.hashmap) == self.capacity:\n            # 删除头节点\n            del_node = self.head.next\n            self.head.next = del_node.next\n            del_node.next.prev = self.head\n            self.hashmap.pop(del_node.key)\n\n        new_node = ListNode(key, value)\n        self.hashmap[key] = new_node\n        self.tail.prev.next = new_node\n        new_node.prev = self.tail.prev\n        new_node.next = self.tail\n        self.tail.prev = new_node\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300665583","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303685599","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304491666","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304766445","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305402662","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306724203","body":"### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311457389","body":"### 解题思路\n\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // 定义快慢两个指针、只想链表头部\n    let fast = head;\n    let slow = head;\n    // 快指针走两步，满指针走一步\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // 相遇后将快指针指向链表头部\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312507692","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312751748","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\n- 空间复杂度 $(K)$, k为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313816269","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n  if(!p && !q) return true\n  if(!p || !q) return false;\n  if(p.val != q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315499549","body":"### 解题思路\n> DFS\n\n### 代码实现\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return dfs(root, 0)\n};\nvar dfs = function(root, sum) {\n    if (root === null) {\n        return 0;\n    }\n    const curSum = sum * 10 + root.val;\n    // 遍历到根节点\n    if (root.left === null && root.right === null) {\n        return curSum;\n    } else {\n        return dfs(root.left, curSum) + dfs(root.right, curSum);\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度 $O(n)$ n为二叉树的节点个数\n- 空间复杂度 $O(n)$ n为二叉树的节点个数\n\n\n### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (root === null) {\n        return 0;\n    }\n    const queue = [[root, root.val]];\n    let sum = 0;\n    while(queue.length > 0) {\n        const [node, curSum] = queue.shift();\n        if(node.left === null && node.right === null) {\n            sum += curSum;\n        } else {\n          node.left && queue.push([node.left, curSum * 10 + node.left.val]);  \n          node.right && queue.push([node.right, curSum * 10 + node.right.val]);  \n        }\n    }\n    return sum;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(n)$ n为二叉树的节点个数\n- 空间复杂度 $O(n)$ n为二叉树的节点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317077026","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  if(!root) return null;\n  const queue = [root]\n  let mostLeft = null;\n  while(queue.length > 0){\n    let curLevelSize = queue.length\n    mostLeft = queue[0]\n    for(let i = 0; i < curLevelSize; i++){\n      const curNode = queue.shift();\n      curNode.left && queue.push(curNode.left)\n      curNode.right&& queue.push(curNode.right)\n    }\n  }\n  return mostLeft.val\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树的节点\n- 空间复杂度 $O(N)$ N为二叉树的节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318195377","body":"### 解题思路\n> DFS（递归）\n\n### 代码实现\n> javaScript\n\n```\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  } \n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list);\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320079106","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n  if(!root) return root\n  const result = []\n  const obj = new Map();\n  // [node, rowVal, colVal]\n  const queue = [[root,0, 0]]\n\n  while(queue.length){\n    const [node, row, col] = queue.shift()\n    obj.set(col, (obj.get(col) || []).concat([[node.val, row]]))\n    node.left && queue.push([node.left, row + 1, col - 1 ])\n    node.right && queue.push([node.right, row + 1 , col + 1 ])\n  }\n\n  // sort\n  let sortedKeys = [...obj.keys()].sort((a,b) => a - b)\n\n  for(const key of sortedKeys){\n    let temp = obj.get(key)\n    temp = temp.sort((a,b) => {\n      if(a[1] != b[1]){\n        return a[1] - b[1]\n      }\n      return a[0] - b[0]\n    })\n    result.push(temp.map((item) => item[0]))\n  }\n  return result;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(NlogN)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320883050","body":"### 解题思路\n> 哈希表\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const hashMap = new Map();\n    for(let i = 0; i < nums.length; i++){\n      if (hashMap.has(target - nums[i])) {\n        return [hashMap.get(target - nums[i]), i]\n      } else {\n        hashMap.set(nums[i], i)\n      }\n    }\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ \n- 空间复杂度 $O(N)$ ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321128169","body":"### 代码实现\n> javaScript\n\n```\nlet topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    // 如果元素数量小于等于 k\n    if(map.size <= k) {\n        return [...map.keys()]\n    }\n    \n    return bucketSort(map, k)\n};\n\n// 桶排序\nlet bucketSort = (map, k) => {\n    let arr = [], res = []\n    map.forEach((value, key) => {\n        // 利用出现频率作为下标，将数据分配到各个桶中\n        if(!arr[value]) {\n            arr[value] = [key]\n        } else {\n            arr[value].push(key)\n        }\n    })\n    // 倒序遍历获取出现频率最大的前k个数\n    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){\n        if(arr[i]) {\n            res.push(...arr[i])\n        }\n\t}\n\treturn res\n}\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322122689","body":"### 解题思路\n> 哈希表\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    const maps = Array(points.length)\n        .fill(0)\n        .map(() => ({}));\n    let count = 0;\n\n    points.forEach((a, i) => {\n        const map = maps[i];\n        points.forEach((b, j) => {\n            if (a !== b) {\n                const dist = calcDistOf2Points(a, b);\n                map[dist] = (map[dist] || 0) + 1;\n            }\n        });\n        for (const dist in map) {\n            const num = map[dist];\n            if (num > 1) count += num * (num - 1);\n        }\n    });\n    return count;\n    function calcDistOf2Points([x1, y1], [x2, y2]) {\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(Nˆ2)$ N 是数组长度\n- 空间复杂度 $O(Nˆ2)$ 需要 N 个哈希表来记录 N 个点到其他 N-1 个点的距离，最坏的情况是每个点到其他点的距离都不一样，那每个哈希表的大小就是 N-1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323709316","body":"### 解题思路\n>  哈希表+滑动窗口\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    const hashMap = new Set()\n    let longestSubstring = 0;\n    let slow = 0;\n    for(let fast = 0; fast < s.length; fast++){\n        let char = s[fast]  \n        while(hashMap.has(char) && slow < s.length){\n            hashMap.delete(s[slow])\n            slow++\n        }\n        longestSubstring = Math.max(longestSubstring, fast - slow + 1)\n        hashMap.add(char)\n    }\n    return longestSubstring\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327088522","body":"#### 解题思路\n> 双指针\n\n#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = (fast = head);\n  while (slow && fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n\n- 空间复杂度: $O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328262561","body":"### 解题思路\n> 二分法\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while(left <= right) {\n    const mid = Math.floor(left + (right - left) / 2);\n    if(target === nums[mid]) {\n        right = mid - 1;\n    } else if(target > nums[mid]){\n        left = mid + 1\n    } else {\n        right = mid - 1\n    }\n  }\n  return left;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(logN)$\n- 空间复杂度 $O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329293905","body":"### 代码实现\n\nvar maxSlidingWindow = function(nums, k) {\n    const n = nums.length;\n    const q = [];\n    for (let i = 0; i < k; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n    }\n\n    const ans = [nums[q[0]]];\n    for (let i = k; i < n; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n        while (q[0] <= i - k) {\n            q.shift();\n        }\n        ans.push(nums[q[0]]);\n    }\n    return ans;\n};\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$\n\n- 空间复杂度 $O(N)$，即为存储 prefixMax和suffixMax 需要的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330617911","body":"### 解题思路\n> 图\n\n### 解题思路\n1.  根据题意可知，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名法官。因此法官这个节点的入度是 n-1, 出度是 0；\n\n2. 遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，可以直接返回结果；如果不存在符合条件的点，则返回 -1\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const inDegrees = new Array(n + 1).fill(0);\n    const outDegrees = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0], y = edge[1];\n        ++inDegrees[y];\n        ++outDegrees[x];\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n            return i;\n        }\n    }\n    return -1;\n};\n```\n### 复杂度分析\n- 时间复杂度：$O(n+m)$\n- 空间复杂度：$O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332223440","body":"### 解题思路\n> DFS\n\n### 代码实现\n> JavaScript\n\n```\nvar possibleBipartition = function(n, dislikes) {\n    const dfs = (curnode, nowcolor, color, g) => {\n        color[curnode] = nowcolor;\n        for (const nextnode of g[curnode]) {\n            if (color[nextnode] !== 0 && color[nextnode] === color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] === 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const color = new Array(n + 1).fill(0);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0 && !dfs(i, 1, color, g)) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n### 复杂度分析\n- 时间复杂$:$O(n+m)$\n\n- 空间复杂度: $O(n+m)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298752942","body":"# Thoughts:\r\n\r\nTake K as a carry, add it to the lowest digit, Update Carry K and keep going to higher digit.\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; --i){\r\n            res.add(0, (num[i] + k) % 10);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n# Time Complexicity:\r\nO(N)\r\n\r\n# Space Complexicity:\r\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298753644","body":"## 思路\n从末尾开始遍历数组元素，与k相加，并维护k值，及进位，\n然后将末位的值加入集合\n遍历完毕数组后，若k仍然有值，将其各位加入数组\n最后返回\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        for(int i=len-1;i>=0;i--){\n            int t=num[i]+k;\n            //这样就不用反转\n            res.add(0,t%10);\n            k=t/10;\n        }\n      //遍历完毕数组后，若k仍然有值，将其各位加入数组\n     //即k位数比数组长度大的情况\n        while(k>0){\n            res.add(0,k%10);\n            k /=10;\n        }\n        return res;\n    }\n}\n```\nTime:O(n)\nSpace:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300799149","body":"##思路\n1、从当前元素开始，左、右分别寻找字符c\n2、若找到了则计算长度距离，若两个方向都找到，则并维护一个最小距离值\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       int n = s.length();\n        int[] res = new int[n];\n        int index = -n;\n//正向查找\n        for (int i = 0; i < n ; ++i) {\n            if (s.charAt(i) == c){\n                index = i;\n            }\n            res[i] = i - index1;\n        }\n        int index2 = 2*n;\n//反向查找\n        for (int i = n-1; i >=0 ; --i) {\n            if (s.charAt(i) == c){\n                index2 = i;\n               }\n    //维护最小距离\n            res[i] = Math.min(res[i],index2 - i);\n        }\n        return res;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302327842","body":"## 思路\r\n使用数组模拟\r\n\r\n1. 定义一个数组和一个指针\r\n2. 初始化数组为定义的大小，并为指针赋值初始值\r\n3. 弹出方法\r\n   -若到达初始化值-1下标的元素——即最后一个元素就返回\r\n   -不然就先向右移动指针，指针+1先\r\n   -然后给指针指向下标赋值\r\n\r\n4. pop 弹出：直接返回指针指向元素，然后左移一位 -1\r\n    -若指针与初始值相同，则返回-1\r\n5. 指定元素 加上对应值\r\n   - 比较k 和 指针+1 哪个小，\r\n   - 遍历这个较小值的所有元素，\r\n   - 并每个元素加上要加的值val\r\n\r\n\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    int st[];\r\n    int p;\r\n    public CustomStack(int maxSize) {\r\n        st=new int[maxSize];\r\n        p=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        //限制功能为初始化长度内使用\r\n        if(p==(st.length-1)){\r\n            return;\r\n        }\r\n        st[++p]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        //弹出全部时返回\r\n        if(p == -1){\r\n            return -1;\r\n        }\r\n\r\n        return st[p--];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int l=Math.min(k,p+1);\r\n        for(int i=0;i<l;i++){\r\n            st[i]+=val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\nTime:O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303803971","body":"## 思路\r\n用列表模拟栈\r\n先入栈，碰到 】 再出栈\r\n先循环到[ 拼接字符\r\n碰到 【，出栈\r\n再拼接数字\r\n循环字符串 数字值 遍\r\n返回\r\n## 代码\r\n```python\r\n class Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        # 定义列表\r\n        stack=[]\r\n\r\n        # 遍历字符串\r\n        for c in s:\r\n            # 出栈\r\n            if c == ']':\r\n                strT= ''\r\n                count=''\r\n                # 没碰到 [ 不停止循环\r\n                while stack and stack[-1] !='[':\r\n                    # 栈顶，即列表末尾元素弹出并返回值\r\n                    strT =stack.pop() +strT \r\n                \r\n                # 弹出 [\r\n                stack.pop()\r\n                # 碰到非数字再跳出循环\r\n                while stack and stack[-1].isnumeric():\r\n                    count =stack.pop() +count;\r\n                stack.append(strT * int(count))\r\n             # 入栈\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\nTime：O(N)\r\nSpace:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304572910","body":"## 思路\r\n使用两个栈来辅助实现队列的功能\r\n\r\n## 代码\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n         self.inStack = []\r\n         self.outStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n       # 移动到另外一个栈先\r\n        self.moveOut()\r\n        # 出栈队头元素\r\n        return self.outStack.pop()\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        # 移动到另外一个栈先\r\n        self.moveOut()\r\n        # 返回最后的元素\r\n        return self.outStack[-1]\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n    # 移动到另外一个栈\r\n    def moveOut(self):\r\n          if not self.outStack:\r\n           # 若不在out列表内就加入这个列表\r\n            while self.inStack:\r\n                 self.outStack.append(self.inStack.pop())\r\n\r\n\r\n\r\n# # Your MyQueue object will be instantiated and called as such:\r\n# # obj = MyQueue()\r\n# # obj.push(x)\r\n# # param_2 = obj.pop()\r\n# # param_3 = obj.peek()\r\n# # param_4 = obj.empty()\r\n\r\n\r\n# # Your MyQueue object will be instantiated and called as such:\r\n# # obj = MyQueue()\r\n# # obj.push(x)\r\n# # param_2 = obj.pop()\r\n# # param_3 = obj.peek()\r\n# # param_4 = obj.empty()\r\n\r\n## 算法复杂度\r\nTIME：O(N)\r\nSPACE:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304832356","body":"## 思路\n单调栈\n## 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        st = []\n        for a in arr:\n            if st and st[-1] > a:\n                cur = st[-1]\n                while st and st[-1] > a: st.pop()\n                st.append(cur)\n            else:\n                st.append(a)\n        return len(st)\n```\n## 复杂度分析\n\nTIME：O(N)\n\nSPACE：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305822674","body":"## 思路\n快慢指针\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){ return head;}\n        int c = 0;\n        ListNode cur = head;\n        while(cur != null){\n            cur = cur.next;\n            c++;\n        }\n        k = k % c;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n## 算法复杂度\nTIME:O(N)\nSPACE:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307444095","body":"\n\n\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n if(head == null || head.next == null) return head;\n        ListNode pre = new ListNode(-1, head), res;\n        pre.next = head;\n        res = head.next;\n        ListNode fNode = head, sNode, nextNode;\n        while(fNode != null && fNode.next != null){\n            sNode = fNode.next;\n            nextNode = sNode.next;\n\n            fNode.next = nextNode;\n            sNode.next = fNode;\n            pre.next = sNode;\n\n            pre = fNode;\n            fNode = nextNode;\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308979133","body":"\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null){\n          return null;\n      }\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail){\n           return null;\n      }\n      ListNode fast = head, slow = head;\n      //找到中点 slow\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      //中点左右开始递归dfs\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310515458","body":"## 思路\r\n双指针，两个指针同时移动，一个移动到末尾，之后移动到另一条链表开头，两个都这么干\r\n1：A+C+B\r\n2: B=C+A  \r\n若二者相交就会出现相交节点\r\n## 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        a,b=headA,headB\r\n        while a != b:\r\n            a=a.next if a else headB\r\n            b=b.next if b else headA\r\n        return a\r\n    \r\n```\r\n## 复杂度分析\r\n\r\nTIME：O(N)\r\n\r\nSPACE：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311871905","body":"## 思路\n快慢指针，经过推断，得出相交后，再置一个指针到开始位置，以慢指针的速度走，两者相交位置寄环开始处\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null){\n            return null;\n        }\n        ListNode fast=head,slow=head;\n        while(fast!=null){\n            slow=slow.next;\n            if(fast.next!=null){\n                fast=fast.next.next;\n            }else{\n                return null;\n            }\n\n            if(fast==slow){\n                ListNode ft=head;\n\n                while(ft!=slow){\n                    ft=ft.next;\n                    slow=slow.next;\n                }\n                return ft;\n            }\n\n        }\n        return null;\n    }\n}\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312515225","body":"```\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312762345","body":"## 思路\r\n递归，比较大小\r\n## 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root==null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n    }\r\n}\r\n```\r\n## 算法复杂度\r\nTIME:O(N)\r\nSPACE:O(H)，H为最大深度，最坏情况H=N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313980871","body":"## 思路\n递归\n## 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        //判断有空节点的情况下是否相同\n        if(p==null && q==null){\n            return true;\n        }\n         if(p==null || q==null){\n            return false;\n        }\n\n        //判断节点是否相同，不同则返回false\n         if(p.val != q.val){\n            return false;\n        }\n\n        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n\n        isSameTree(p.right);\n    }\n}\n```\n## 算法复杂度\nTIME:O(N)\nSPACE:O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315518337","body":"## 思路\r\nBFS 加栈来一层一层遍历，\r\n\r\n- 若无子节点，直接加当前节点值\r\n- 若存在左\\右子节点\r\n- 加上值\r\n\r\n## 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n         Queue<TreeNode> qu = new LinkedList<>();\r\n        qu.offer(root);\r\n        int sum = 0;\r\n        //bfs 栈\r\n        while(!qu.isEmpty()){\r\n          int size = qu.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = qu.poll();\r\n                \r\n                if (cur.left == null && cur.right == null) {\r\n                    sum = sum + cur.val;\r\n                }\r\n\r\n                if (cur.left != null) {\r\n                    cur.left.val = cur.val * 10 + cur.left.val;\r\n                    qu.offer(cur.left);\r\n                }\r\n\r\n                if (cur.right != null) {\r\n                    cur.right.val = cur.val * 10 + cur.right.val;\r\n                    qu.offer(cur.right);\r\n                }\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n```\r\n## 算法复杂度\r\nTIME:O(N)\r\nSPACE:O(b)，最坏情况b为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317222978","body":"## 思路\nbfs层序遍历，最后一层的第一个点返回\n## 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        LinkedList<TreeNode> qu=new LinkedList<>();\n        qu.offer(root);\n        int res=0;\n        while(!qu.isEmpty()){\n            int size=qu.size();\n            for(int i=0;i<size;i++){\n                TreeNode node=qu.poll();\n                if(i==0){\n                    res=node.val;\n                }\n                if(node.left!=null){\n                    qu.addLast(node.left);\n                }\n                if(node.right !=null){\n                    qu.addLast(node.right);\n                }\n\n            }\n            \n        }\n        return res;     \n    }\n}\n\n```\n## 算法复杂度\nTIME:O(N)\nSPACE:O(Q)，最坏情况Q与N同阶\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318850496","body":"## 思路\r\n序列化：bfs\r\n反序列化：bfs +3指针\r\n## 代码\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        ans = ''\r\n        queue = [root]\r\n        while queue:\r\n            node = queue.pop(0)\r\n            if node:\r\n                ans += str(node.val) + ','\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                ans += '#,'\r\n        print(ans[:-1])\r\n        return ans[:-1]\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data == '#': return None\r\n        nodes = data.split(',')\r\n        if not nodes: return None\r\n        root = TreeNode(nodes[0])\r\n        queue = [root]\r\n        # 有 root了，从 1 开始\r\n        i = 1\r\n\r\n        while i < len(nodes) - 1:\r\n            node = queue.pop(0)\r\n            lv = nodes[i]\r\n            rv = nodes[i + 1]\r\n            i += 2\r\n            if lv != '#':\r\n                l = TreeNode(lv)\r\n                node.left = l\r\n                queue.append(l)\r\n\r\n            if rv != '#':\r\n                r = TreeNode(rv)\r\n                node.right = r\r\n                queue.append(r)\r\n        return root\r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n\r\n```\r\n## 算法复杂度\r\nTIME:O(N)\r\nSPACE:O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320216302","body":"## 思路\r\nDFS\r\n## 代码\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def verticalTraversal(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: List[List[int]]\r\n        \"\"\"\r\n        se = collections.defaultdict(\r\n            lambda: collections.defaultdict(list))\r\n        def dfs(root, x=0, y=0):\r\n            if not root:\r\n                return\r\n            se[x][y].append(root.val)\r\n            dfs(root.left, x-1, y+1)\r\n            dfs(root.right, x+1, y+1)\r\n        dfs(root)\r\n        ans = []\r\n       \r\n        for x in sorted(se):\r\n            level = []\r\n            for y in sorted(se[x]):\r\n                level += sorted(v for v in se[x][y])\r\n            ans.append(level)\r\n        return ans\r\n\r\n\r\n```\r\n## 算法复杂度\r\nTIME:O(nlogn)\r\nSPACE:O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320912101","body":"## 思路\n\n## 代码\n```java\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]),i};\n            }\n            map.put(target-nums[i],i);\n        }\n         return new int[]{};\n    }\n    \n}\n\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321165259","body":"## 思路\nmap存数字及次数，\n构建一个大小为k的小顶堆，\n遍历map，与堆顶元素比较，大的赋值为堆顶\n\n## 代码\n```java\n\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        //计数\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        // 数组第1个元素值，第2个元素次数\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                //比较次数，构建小顶堆\n                return a[1] - b[1];\n            }\n        });\n        //遍历map，拿出来与堆封顶部比较\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int num = entry.getKey()；\n            int c = entry.getValue();\n            //堆维护为k大小\n            if (queue.size() == k) {\n                //比较堆顶数据，哪个大哪个加入堆顶\n                if (queue.peek()[1] < c) {\n                    queue.poll();\n                    queue.offer(new int[]{num, c});\n                }\n            } else {\n                queue.offer(new int[]{num, c});\n            }\n        }\n        //最后取出值\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n\n```\n## 算法复杂度\nTIME:O(nlogk)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322265773","body":"## 思路\n哈希表处理结果，再遍历计算\n## 代码\n```java\n\n\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if(points==null||points.length<=2){\n            return 0;\n        }\n        int res=0;\n        Map<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<points.length;i++){\n            for(int j=0;j<points.length;j++){\n                int len=getLen(points[i],points[j]);\n                map.put(len, map.getOrDefault(len, 0) + 1);\n            }\n             for (int count : map.values()){\n                 res += count * (count - 1);\n             }\n            \n        map.clear();\n        }\n        return res;\n    }\n   int getLen(int[] a,int[] b){\n        int x=b[0]-a[0];\n        int y=b[1]-a[1];\n        return x*x+y*y;\n    }\n}\n```\n## 算法复杂度\nTIME:O(n*n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323894545","body":"## 思路\nset判断重复，滑动窗口\n## 代码\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int l = 0;\n        int maxLen = 0;\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (!set.add(s.charAt(i))) {\n                maxLen = Math.max(maxLen, set.size());\n                while (s.charAt(l) != s.charAt(i)) {\n                    set.remove(s.charAt(l));\n                    l++;\n                }\n                l += 1;\n            }\n        }\n        return Math.max(maxLen, set.size());\n    }\n}\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325301819","body":"## 思路\nset判断重复，滑动窗口\n## 代码\n```java\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n          List<Integer> res = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n        if (words == null || words.length == 0)\n            return res;\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n        int match = 0;\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n            for (; j < cur.length(); j += wordLen) {\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n            if (j == cur.length())\n                res.add(i);\n        }\n        return res;\n    }\n}\n```\n## 算法复杂度\nTIME:O(m*n*k)\nSPACE:O(m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326625022","body":"## 思路\n同余定理+前缀和\n## 代码\n```java\n\nimport java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int t = 0;\n      //前缀和\n        for (int n : nums){\n\t\t t += n;\n\t\t}\n          \n       t= Math.floorMod(t, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - t, k)))\n                res = Math.min(res, i -map.get(Math.floorMod(prefix - t, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327632732","body":"## 思路\n双指针，快慢指针\n## 代码\n```python\n\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328070958","body":"## 思路\n双指针，读写指针\n\t• 一样的值，读指针前进，\n\t• 不同值，写指针移动并写入\n## 代码\n```python\n\n\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return 0\n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328274205","body":"## 思路\n二分\n## 代码\n```java\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n        int l = 0,r = nums.length - 1\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (target > nums[mid]) {\n                l = mid + 1;\n            } else if (target < nums[mid]) {\n                r = mid - 1;\n            } else if (target == nums[mid]){\n                return mid;\n            }\n        }\n        return l;\n    }\n}\n```\n## 算法复杂度\nTIME:O(nlogn)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329404129","body":"## 思路\r\n双端队列\r\n\r\n-  维护队列大小\r\n\r\n- \t索引大于 i - k + 1,出队\r\n\r\n- \t 小于当前元素，出队\r\n\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int len=nums.length;\r\n        int[] res = new int[len - k + 1];\r\n        Deque<Integer> dq = new ArrayDeque<>();\r\n        for (int i = 0; i < len; i++){\r\n            //索引大于 i - k + 1,出队\r\n            if (!dq.isEmpty() && dq.peekFirst() + k <= i) {\r\n                dq.pollFirst();\r\n            }\r\n            //小于当前元素，出队\r\n            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]){\r\n                dq.pollLast();\r\n            }\r\n            dq.offerLast(i);\r\n            if (i - k + 1 >= 0) {\r\n                res[i - k + 1] = nums[dq.peekFirst()];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## 算法复杂度\r\nTIME:O(n)\r\nSPACE:O(k)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330871820","body":"## 思路\n## 代码\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] count = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0];\n            int y = edge[1];\n            ++count[y];\n            --count[x];\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (count[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1333970472","body":"\r\n## 思路\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n    ArrayList<Integer>[] g;\r\n    Map<Integer, Integer> color;\r\n    public boolean possibleBipartition(int N, int[][] dislikes) {\r\n        g = new ArrayList[N+1];\r\n        for (int i = 1; i <= N; ++i){\r\n            g[i] = new ArrayList();\r\n        }\r\n        for (int[] edge: dislikes) {\r\n            g[edge[0]].add(edge[1]);\r\n            g[edge[1]].add(edge[0]);\r\n        }\r\n        color = new HashMap();\r\n        for (int o = 1; o <= N; ++o){\r\n            if (!color.containsKey(o) && !dfs(o, 0))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    public boolean dfs(int o, int c) {\r\n        if (color.containsKey(o)){\r\n             return color.get(o) == c;\r\n        }\r\n        color.put(o, c);\r\n        for (int t: g[o]){\r\n            if (!dfs(t, c ^ 1))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n## 算法复杂度\r\nTIME:O(v+e)\r\nSPACE:O(v+e)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333997574","body":"\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n   public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n        List<Integer>[] gAdj = new ArrayList[m];\r\n        List<Integer>[] iAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            gAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            iAdj[i] = new ArrayList<>();\r\n        }\r\n        int[] gInde = new int[m];\r\n        int[] iInde = new int[n];\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    gAdj[beforeGroup].add(currentGroup);\r\n                    gInde[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                iAdj[item].add(i);\r\n                iInde[i]++;\r\n            }\r\n        }\r\n        //得到结果\r\n        List<Integer> groupsList = topologicalSort(gAdj, gInde, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(iAdj, iInde, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        // 据结果，多对一,一对多\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335472323","body":"## 思路\r\n模拟\r\n\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0, y = 0;\r\n        for(char move: moves.toCharArray()) {\r\n            if(move == 'R') {\r\n                x++;\r\n            } else if(move == 'L') {\r\n                x--;\r\n            } else if(move == 'U') {\r\n                y++;\r\n            } else if(move == 'D') {\r\n                y--;\r\n            }\r\n        }\r\nboolean r=x == 0 && y == 0;\r\n        return r;\r\n    }\r\n}\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298431856","body":"### 代码\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = 0\r\n        carry = k\r\n        for i in range(len(num)-1,-1,-1):\r\n            tem = num[i] + carry\r\n            print(tem)\r\n            if tem // 10 > 0 :\r\n                carry = tem // 10\r\n                num[i] = tem % 10\r\n                print(carry)\r\n            else:\r\n                num[i] = tem % 10\r\n                carry = 0\r\n                break\r\n        if carry < 10 and carry > 0:\r\n             return [carry] + num\r\n        else:\r\n            while(carry):\r\n                print(carry)\r\n                num = [carry % 10] + num\r\n                carry = carry // 10\r\n                print(num)\r\n        return num\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305503158","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        if not head or not head.next:\r\n            return head\r\n        count = 1\r\n\r\n        while(tail.next):\r\n            tail = tail.next\r\n            count += 1\r\n    \r\n        if k % count == 0:\r\n            return head\r\n\r\n        #首尾相连\r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298538203","body":"## 思路\n\n> + 思路描述 \n\n## 代码\n\n```python\n# 代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp = temp + str(i)\n        return [int(i) for i in str(int(temp)+k)]\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300753664","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), None\n        for i, ch in enumerate(s):\n            if ch == c:\n                if last is not None:\n                    for j in range(i, (i - 1 + last) // 2 - 1, -1):\n                        ans[j] = min(ans[j], i - j)\n                else:\n                    for j in range(i, -1, -1):\n                        ans[j] = min(ans[j], i - j)\n                last = i\n            elif last is not None:\n                ans[i] = min(ans[i], i - last)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302258679","body":"class CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307019179","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        start = pre = ListNode()\n        pre.next = head\n        while pre.next and pre.next.next:\n            slow, fast = pre.next, pre.next.next\n            slow.next = fast.next\n            fast.next = slow\n            pre.next = fast\n            pre = slow\n        return start.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308536551","body":"class Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head,null);\n    }\n\n    public TreeNode buildTree(ListNode left,ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMid(left,right);\n        TreeNode root = new TreeNode();\n        root.val = mid.val;\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    public ListNode getMid(ListNode left,ListNode right){\n        ListNode slow = left;\n        ListNode fast = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311883070","body":"    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast !=null && fast.next !=null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(slow == fast){\n                break;\n            }\n        }\n        if(fast == null || fast.next==null){\n            return null;\n        }\n        \n        fast = head;\n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317194064","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318816329","body":"public class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320911248","body":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            auto iter = mp.find(target - nums[i]);\n            if (iter != mp.end()) {\n                return {iter->second, i};\n            }\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325893200","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> modulo_count = {{0, 1}};\n        int sum = 0;\n        int count = 0;\n        for (auto& num : nums) {\n            sum += num;\n            int modulo = (sum % k + k) % k;\n            count += modulo_count[modulo];\n            modulo_count[modulo]++;\n        }\n        return count;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328068040","body":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        // 读p写p1指针\n        int p = 0, p1 = 0;\n        while(p1 < nums.length){\n            if(nums[p] != nums[p1]){\n                p++;\n                nums[p] = nums[p1];\n            }\n            p1++;\n        }\n        return p + 1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328272331","body":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left<=right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n                ans = mid;\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329254304","body":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        deque<int> q;\n        for (int i = 0; i < k; ++i) {\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n\n        vector<int> ans = {nums[q.front()]};\n        for (int i = k; i < n; ++i) {\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\n                q.pop_back();\n            }\n            q.push_back(i);\n            while (q.front() <= i - k) {\n                q.pop_front();\n            }\n            ans.push_back(nums[q.front()]);\n        }\n        return ans;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332315578","body":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3-c):\n                    return False\n            return True\n        \n        g = defaultdict(list)\n        color = [0]*n\n        for a,b in dislikes:\n            a, b = a-1, b-1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i,1) for i,c in enumerate(color))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336056340","body":"class Solution {\n    public int[] getOrder(int[][] _tasks) {\n        int n = _tasks.length;\n        // 编号，进入时间，耗时\n        int[][] tasks = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            tasks[i] = new int[]{i, _tasks[i][0], _tasks[i][1]};\n        }\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\n        // 耗时，编号\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n        int[] ans = new int[n];\n        for (int i = 0, cnt = 0, time = 1; cnt < n;) {\n            while (i < n && tasks[i][1] <= time) {\n                sortTasks.offer(new int[]{tasks[i][2], tasks[i][0]});\n                i++;\n            }\n            if (sortTasks.isEmpty()) {\n                time = tasks[i][1];\n                continue;\n            }\n            int[] cur = sortTasks.poll();\n            ans[cnt++] = cur[1];\n            time += cur[0];\n        }\n        return ans;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304714739","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\r\n        int res = 0;\r\n        int[] sortedArr = new int[arr.length];\r\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\r\n        Arrays.sort(sortedArr);\r\n        for (int i = 0; i < sortedArr.length; i++) {\r\n            int x = arr[i], y = sortedArr[i];\r\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\r\n            if (cnt.get(x) == 0) {\r\n                cnt.remove(x);\r\n            }\r\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\r\n            if (cnt.get(y) == 0) {\r\n                cnt.remove(y);\r\n            }\r\n            if (cnt.isEmpty()) {\r\n                res++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312631240","body":"**Idea**\r\n\r\n```\r\n二叉树的最大深度一题，可用二叉树遍历法和动态规划法：\r\n二叉树遍历法：\r\n先遍历左节点，然后遍历右节点，在遍历过程中需要储存比较二叉树各分支的深度大小然后取最大值\r\n动态规划法：\r\n从整体出发，求出左右子树最大二叉树深度，最后再比较。\r\n```\r\n\r\n**code**\r\n\r\n```java\r\n\r\npublic class day13 {\r\n    public class TreeNode {\r\n      int val;\r\n      TreeNode left;\r\n      TreeNode right;\r\n      TreeNode() {}\r\n      TreeNode(int val) { this.val = val; }\r\n      TreeNode(int val, TreeNode left, TreeNode right) {\r\n          this.val = val;\r\n          this.left = left;\r\n          this.right = right;\r\n      }\r\n    }\r\n    //二叉树遍历法\r\n    int depth=0;//储存历史二叉树深度\r\n    int res=0;//储存临时二叉树深度\r\n    public int maxDepth(TreeNode root) {\r\n        traverse(root);\r\n        return res;\r\n        }\r\n        void traverse(TreeNode root){\r\n        if (root==null){\r\n            return ;\r\n        }\r\n        depth++;//深度加加\r\n            res=Math.max(res,depth);//当前深度与历史深度比较，取最大值\r\n        traverse(root.left);\r\n        traverse(root.right);\r\n        depth--;//遍历完后需要减去左结点那边加的1\r\n    }\r\n    //动态规划法\r\n    public int maxDepth1(TreeNode root) {\r\n        if(root==null)\r\n            return 0;\r\n        int leftMax=maxDepth1(root.left);//左子树最大深度\r\n        int rightMax=maxDepth1(root.right);//右子树最大深度\r\n        return 1+Math.max(leftMax,rightMax);//比较两子树深度，取最大值；深度节点累加\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319621774","body":"Idea\r\n\r\n```\r\n题目要求设计一个计算二叉树的垂序遍历序列。\r\n主要要求如下，\r\n结点为(row，col),则其左孩子为(row+1,col-1),右孩子为(row+1,col+1)\r\n二叉树的垂序遍历从最左边的列开始直到最右边的列结束，\r\n按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。\r\n若同行同列上有多个结点，按结点值大小进行排序。\r\n上述要求可转化为如下言语：\r\n1·首先使用dfs把二叉树的结点转化为坐标形式（坐标轴可自定义）\r\n2·然后按x坐标从小到大排序（此时x为列）\r\n3·同x坐标，按y坐标从大到小排序（此时y为行）\r\n4·同x、y坐标，按值从小到达排序\r\n5·将同x坐标的结点储存在一个ArrayList中\r\n```\r\n\r\nCode\r\n\r\n```java\r\npublic class day18 {\r\n   List<int[]> totalList=new ArrayList<>();\r\n   public List<List<Integer>>verticalTraversal(TreeNode root){\r\n       dfs(root,0,0);\r\n\r\n       //按x、y、val比较\r\n       Collections.sort(totalList,(a,b)->{\r\n           if(a[0]!=b[0]){//列从小到大\r\n               return a[0]-b[0];//结果从小到大返回\r\n           }\r\n           if(a[1]==b[1]){//列行相等，按值大小\r\n               return a[2]-b[2];//结果从小到大返回\r\n           }\r\n           //列相等，行从大到小\r\n           return b[1]-a[1];//结果从大到小返回\r\n       });\r\n       //经过比较器的比较后，\r\n       //totalList里面的元素根据x、y、val从小到大排列\r\n       List<List<Integer>>res=new ArrayList<>();\r\n       if(totalList.size()==0)return res;\r\n       res.add(new ArrayList<>());\r\n       //取最小列的序号\r\n       int pre=totalList.get(0)[0];\r\n       for(int[] sub:totalList){\r\n           //如果上一列已经全部添加完毕，执行if语句块，新建一个ArrayList()储存下一列\r\n           if(pre!=sub[0]){\r\n               pre=sub[0];\r\n               res.add(new ArrayList<>());\r\n           }\r\n           res.get(res.size()-1).add(sub[2]);//把相应的值添加到相应的列中\r\n\r\n       }\r\n       return res;\r\n\r\n    }\r\n    //把给定二叉树的结点转化为坐标存在，储存在totalList列表中\r\n    void dfs(TreeNode node,int x,int y){\r\n       if(node==null)return ;\r\n        //代码坐标轴：\r\n        //从左到右为正（小到大排序）\r\n        //从下到上为正（大到小排序）\r\n        //(纵坐标，横坐标)\r\n       dfs(node.left,x-1,y-1);\r\n       dfs(node.right,x+1,y-1);\r\n       totalList.add(new int[]{x,y,node.val});\r\n    }\r\n}\r\n\r\n```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323630582","body":"Idea\r\n\r\n```\r\n主要是使用滑动窗口。右窗口先向前移动，然后用HashMap对字符计数，若有字符个数超过1，则左窗口+1，直至字符个数重新等于1，然后右窗口再向前移动，由此循环往复。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n           HashMap<Character,Integer> window=new HashMap<>();\r\n        int left=0,right=0;\r\n        int res=0;\r\n        while(right<s.length()){\r\n            char c=s.charAt(right);\r\n            right++;\r\n            window.put(c,window.getOrDefault(c,0)+1);\r\n            while (window.get(c)>1){\r\n                char d=s.charAt(left);\r\n                left++;\r\n                window.put(d,window.get(d)-1);\r\n            }\r\n            res=Math.max(res,right-left);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327974445","body":"**Idea**\r\n\r\n```\r\n使用双指针，定义两个同起点的读写指针，然后用fast(读指针)找不同元素，slow(写指针)写入元素。\r\n该题主要解题思路：从一个数组中，剔除重复元素，按顺序只保留不重复的元素。\r\n开始时，不知道那些元素是不重复的，然后用读指针去试探，找出不同的元素；找到不同元素后，写指针向前移动一步，以写入这个元素。\r\n```\r\n\r\n**Code**\r\n\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int slow=0,fast=1;\r\n            if(nums[slow]==nums[fast]) {\r\n                while (nums[slow] == nums[fast]) {\r\n                    fast++;\r\n                }\r\n                slow++;\r\n                int temp=slow;\r\n                while(temp<=fast) {\r\n                    nums[temp] = nums[fast];\r\n                }\r\n            }\r\n            if(nums[slow]!=nums[fast]&&fast<nums.length){\r\n                slow++;\r\n                fast++;\r\n            }\r\n            return slow+1; \r\n    }\r\n}\r\n```\r\n\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1332761344","body":"Idea\r\n\r\n\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        // 第 2 步：实例化组和项目的邻接表\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        // 第 3 步：建图和统计入度数组\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        // 第 4 步：得到组和项目的拓扑排序结果\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\r\n        // key：组，value：在同一组的项目列表\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335150379","body":"Idea\r\n\r\n```\r\n定义res_x,res_y两个变量\r\n分别根据字母对这两个变量进行操作，根据判断它们是否等于0来返回相应得boolean值\r\n```\r\n\r\nCode\r\n\r\n```java\r\npublic class day32 {\r\n    public boolean judgeCircle(String moves) {\r\n        int res_x=0,res_y=0;\r\n        for(int i=0;i<moves.length();i++){\r\n            if(moves.charAt(i)=='R'){\r\n                res_x+=1;\r\n            }else if(moves.charAt(i)=='L'){\r\n                res_x-=1;\r\n            }else if(moves.charAt(i)=='U'){\r\n                res_y-=1;\r\n            }else if(moves.charAt(i)=='D'){\r\n                res_y+=1;\r\n            }\r\n        }\r\n        if(res_x==0&&res_y==0)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\nComplex\r\n\r\n```\r\nTime:O(n)\r\nSpace:O(1)\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298745122","body":"思路\r\n遍历两个数组\r\n代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kNum = new ArrayList<>();\r\n        while(k!=0) {\r\n            kNum.add(k%10);\r\n            k/=10;\r\n        }\r\n        List<Integer> arrayNum = new ArrayList<>();\r\n        for(int i = num.length-1; i >= 0; i--) {\r\n            arrayNum.add(num[i]);\r\n        }\r\n        int i = 0, add = 0, j = Math.min(kNum.size(), arrayNum.size());\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i < j) {\r\n            ans.add((kNum.get(i)+arrayNum.get(i)+ add)%10 );\r\n            add = (kNum.get(i)+arrayNum.get(i)+ add)/10;\r\n            i++;\r\n        }\r\n        if(j == kNum.size()) {\r\n            while (i<arrayNum.size()) {\r\n                ans.add((arrayNum.get(i)+add)%10);\r\n                add = (arrayNum.get(i)+add)/10;\r\n                i++;\r\n            }\r\n        } else {\r\n            while (i<kNum.size()) {\r\n                ans.add((kNum.get(i)+ add)%10 );\r\n                add = (kNum.get(i)+ add)/10;\r\n                i++;\r\n            }\r\n        }\r\n        if(add!=0) ans.add(add);\r\n        List<Integer> realAns = new ArrayList<>();\r\n        for(int n = ans.size()-1;n>=0; n--) {\r\n            realAns.add(ans.get(n));\r\n        }\r\n        return realAns;\r\n    }\r\n}\r\n```\r\n复杂度\r\nO(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304568664","body":"```java\nimport java.util.Stack;\n\nclass MyQueue {\n    Stack<Integer> stack;\n    Stack<Integer> tempStack;\n\n    public MyQueue() {\n        this.stack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        if(stack.isEmpty()) {\n            stack.push(x);\n        } else {\n          while(!stack.isEmpty()) {\n              tempStack.push(stack.pop());\n          }\n          stack.push(x);\n          while(!tempStack.empty()) {\n              stack.push(tempStack.pop());\n          }\n        }\n    }\n    \n    public int pop() {\n        return stack.pop();\n    }\n    \n    public int peek() {\n        return stack.peek();\n    }\n    \n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304824953","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304848410","body":"```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0)\n            return head;\n        ListNode pointer = head;\n        int count = 0;\n        while(pointer.next != null) {\n            pointer = pointer.next;\n            count++;\n        }\n        pointer.next = head;\n        count++;\n        int times = k/count+1;\n        for(int i = 0; i < count - (k%count); i++) {\n            head = head.next;\n            pointer = pointer.next;\n        }\n        ListNode ans = head;\n        pointer.next = null;\n        return ans;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298531682","body":"### 代码优化：\r\n从右到左，通过不断除以10来取对应位的数字\r\n如num = [1, 2] k=999。 \r\n第一次循环：k = 999 + 2 = 1001, res[0] = k % 10 = 1\r\n第二次循环：\r\n        k = Math.floor(k / 10) = 100 \r\n        k = k + 1 = 101\r\n        res[1] = k % 10 = 1\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299438780","body":"### 代码优化：\r\n问题可以转换成，对 s 的每个下标 i，求\r\n\r\ns[i] 到其左侧最近的字符 c 的距离\r\ns[i] 到其右侧最近的字符 c 的距离\r\n这两者的最小值。\r\n\r\n代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    // 两次遍历\r\n    var len = s.length;\r\n    var ans = new Array(len).fill(0);\r\n    var idl = -len;\r\n    var idr = 2 * len;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            idl = i;\r\n        }\r\n        ans[i] = i - idl;\r\n    }\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            idr = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], idr - i);\r\n    }\r\n    return ans;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1303543816","body":"### 思路：\r\n    按照规则实现\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度: push和pop为O（1），increment为O（min（k，top））\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303544379","body":"### 思路：\r\n遍历数组，\r\n1. 如果是'[',直接入栈\r\n2. 如果是'数字'，将连续数字字符识别出来，统一放入栈中\r\n3. 如果是']',进行处理\r\n-  ① 连续获取字符串，直到遇到”[“\r\n- ② 取出数字\r\n- ③ 计算出字符串后再入栈\r\n4. 如果是'普通字符'，正常入栈\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let len = s.length;\r\n    let i = 0;\r\n    while(i < len) {\r\n        let char = s[i];\r\n        if (char === '[') {\r\n            stack.push('[');\r\n            i++;\r\n        }\r\n        else if (/[0-9]/.test(+s[i])) {\r\n            let strNum = s[i];\r\n            i++;\r\n            while(/[0-9]/.test(+s[i])) {\r\n                strNum += s[i];\r\n                i++;\r\n            }\r\n            stack.push(strNum)\r\n        }\r\n        else if (char === ']') {\r\n            let str = stack.pop();\r\n            let cur = stack.pop();\r\n            while(true) {\r\n                if (cur === '[') break;\r\n                str = cur + str;\r\n                cur = stack.pop();\r\n            }\r\n            \r\n            const num = +stack.pop();\r\n            const strList = Array(num).fill().map(() => str).join('');\r\n            stack.push(strList);\r\n            i++;\r\n        }\r\n        else {\r\n            stack.push(s[i]);\r\n            i++;\r\n        }\r\n        \r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304811807","body":"### 思路：\r\n两个栈\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304811620","body":"### 思路：\r\n单调栈（递增）\r\n- 当前值大于等于栈顶，可以成块\r\n- 当前值小于栈顶，去掉之前比他大的值，只保留栈顶用于成块\r\n\r\n### 代码\r\n```js\r\n// 获取栈顶元素\r\nvar stackTop = (stack) => {\r\n    return stack[stack.length - 1];\r\n}\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n            // 小于的时候，只保留栈顶用于成块\r\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\r\n                ascStack.pop();\r\n            }\r\n            ascStack.push(top);\r\n        }\r\n        else {\r\n            // >= 可以独立成块\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1308083057","body":"### 思路：\r\n取余数 + 快慢指针\r\n\r\n### 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    function ListNode(val, next) {\r\n        this.val = (val===undefined ? 0 : val)\r\n        this.next = (next===undefined ? null : next)\r\n    }\r\n    if (!head) {\r\n        return head;\r\n    }\r\n    let dummyNode = new ListNode();\r\n    dummyNode.next = head;\r\n    let cur = head;\r\n    // 计算链表的长度\r\n    let length = 1;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        length ++;\r\n    }\r\n    // 快慢指针的间距\r\n    k = k % length;\r\n    let slowNode = head;\r\n    let fastNode = head;\r\n    for (let i = 1; i <= k; i++) {\r\n        fastNode = fastNode.next;\r\n    }\r\n\r\n    // 快慢指针同时前进\r\n    while(fastNode.next) {\r\n        slowNode && (slowNode = slowNode.next);\r\n        fastNode = fastNode.next;\r\n    }\r\n    // 调整节点\r\n    fastNode.next = head;\r\n    dummyNode.next = slowNode.next;\r\n    slowNode.next = null;\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1308083819","body":"### 思路：\r\n记录前中后节点\r\n待优化，减少pre节点的记录改用xx.next\r\n\r\n### 代码\r\n```js\r\nfunction ListNode(val, next) {\r\n    this.val = (val===undefined ? 0 : val)\r\n    this.next = (next===undefined ? null : next)\r\n}\r\n\r\nvar swapPairs = function(head) {\r\n    if (!head) return head;\r\n    if (head && !head.next) return head;\r\n    // 创建dumy节点\r\n    let dummyNode = new ListNode();\r\n\r\n    let pre = dummyNode;\r\n    let cur = head;\r\n    let next = head.next;\r\n    while (true) {\r\n        pre.next = cur.next;\r\n        cur.next = next.next;\r\n        tmp = next.next;\r\n        next.next = cur;\r\n        \r\n        pre = cur;\r\n        if (tmp && tmp.next) {\r\n            cur = tmp;\r\n            next = tmp.next;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308084315","body":"### 思路：\r\n1、将有序链表转成有序数组, 分治\r\n[-10,-3,0,5,9] 输出为[0,-10,5,null,-3,null,9]\r\n2、快慢指针\r\n为了断开，我们需要保存慢指针的前一个节点，因为单向链表的结点没有前驱指针。\r\n### 代码\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n    const arr = [];\r\n    while (head) {\r\n        // 将链表节点的值逐个推入数组arr\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // 根据索引start到end的子数组构建子树\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null; // 指针交错，形成不了子序列，返回null节点\r\n        // >>> 无符号右移动。math.floor\r\n        const mid = (start + end) >>> 1; // 求中间索引 中间元素是根节点的值\r\n        const root = new TreeNode(arr[mid]); // 创建根节点\r\n        root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n        root.right = buildBST(mid + 1, end); // 递归构建右子树\r\n        return root; // 返回当前子树\r\n    };\r\n    const root = buildBST(0, arr.length - 1); // 根据整个arr数组构建\r\n    return root;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1312734738","body":"### 思路：\r\n分别与另外一个链表’连接‘，第二轮时相遇\r\n没有修改next，只是不断改变当前指针而已，所以不会出环\r\n\r\n\r\n### 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA,\r\n        b = headB;\r\n    while (a != b) {\r\n        a = a === null ? headB : a.next;\r\n        b = b === null ? headA : b.next;\r\n    }\r\n    return a;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1312734536","body":"### 思路：\r\n- 看官方题解总结的思路：定义 链表头部到链表入口有a个节点（不计链表入口节点），链表环有b个节点\r\n- 用快(fast)慢(low)指针第一次相遇。①fast = slow + nb； ② fast = 2low; ①-② 推导出slow = nb\r\n- 如果让指针从链表头部一直向前走并统计步数k，那么所有走到链表入口节点时的步数 是：k=a+nb，slow指针走过的步数为nb步。因此，我们只要想办法让slow再走a步停下来，就可以到环的入口。\r\n\r\n=> slow指针位置不变，将fast指针重新指向链表头部节点，slow和fast同时每轮向前走a步在链表入口相遇；\r\n\r\n### 代码\r\n```js\r\n var detectCycle = function(head) {\r\n    if (head === null) return null;\r\n    var slow = head;\r\n    var quick = head;\r\n    // 直到第一次相遇\r\n    while (true) {\r\n        // 慢指针每次前进一步\r\n        slow = slow.next;\r\n        // 快指针每次前进两步\r\n        quick = quick.next && quick.next.next || null;\r\n        // 无环\r\n        if (quick === null || slow === null) return null;\r\n        if (slow === quick) break;\r\n    }\r\n    // quick从头节点开始走，slow保持不变\r\n    if (slow === quick) {\r\n        quick = head;\r\n    }\r\n    // 快慢指针没次走一步\r\n    while (slow !== quick) {\r\n        slow = slow.next;\r\n        quick = quick.next;\r\n    }\r\n    return slow;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312734318","body":"### 思路：\r\n求左右子树深度的最大值\r\n\r\n### 代码\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root === null) {\r\n        return 0;\r\n    }\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298650820","body":"### 思路\r\n先得到整数num与k相加和的结果，然后从个位数开始每次往前一位取出加入list，在每一次取数位结果的同时将和的结果除以10，直至k的结果小于等于0停止加入list。比如 123 + 912，实现3+912, 2+91, 1+9, 0+1。\r\n\r\n自我复述视频： https://www.bilibili.com/video/BV14W4y1771Z/\r\n\r\n### 代码\r\n```js\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let i = num.length - 1 \r\n    let res = []\r\n\r\n    while(i>=0 || k>0){\r\n        if(i>=0){\r\n            k += num[i]\r\n            i --\r\n        }\r\n        res.push(k % 10)\r\n        k = parseInt(k /10)\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)，其中 n 为数组长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300481747","body":"**代码**\r\n```\r\nclass Solution:\r\n    def shortestToChar (self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [n + 1] * n\r\n        idx = -1\r\n        for i in range(n):  # 左侧 c 位置\r\n            if s[i] == c:\r\n                idx = i\r\n            if idx != -1:\r\n                res[i] = i - idx\r\n\r\n        idx = n\r\n        for i in range(n - 1, -1, -1):  # 右侧 c 位置\r\n            if s[i] == c:\r\n                idx = i\r\n            if idx != n:\r\n                res[i] = min(idx - i, res[i])\r\n\r\n        return res\r\n```\r\n**复杂度**\r\n时间复杂度：$O(n)$ 。遍历 s 即可，\r\n空间复杂度： 。和 s 等长的结果数组，","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303481781","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stk = []\n        for x in s:\n            if x==']':\n                restr = ''\n                num = ''\n                while stk and stk[-1]!='[':\n                    restr = stk.pop()+restr\n                stk.pop()\n                while stk and stk[-1].isnumeric():\n                    num = stk.pop()+num\n                stk.extend(restr*int(num))\n            else:\n                stk.append(x)\n        return ''.join(stk)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305679863","body":"class Solution(object):\n\n        def rotateRight(self, head, k):\n            \"\"\"\n            :type head: ListNode\n            :type k: int\n            :rtype: ListNode\n            \"\"\"\n            #首先考虑边界，特殊情况\n            if k == 0 or not head or not head.next:\n                return head\n            \n            n = 1\n            cur = head\n\n            while cur.next:\n                cur = cur.next # 这里cur更新后，head不会更新，因为cur被重新赋值了，如果cur.next=xxx，那么head.next也会变化\n                n += 1\n            \n            add = n - k % n # 断开的位置\n            if add == n:\n                return head\n            \n            cur.next = head # 连接闭环\n            while add:\n                print(add)\n                cur = cur.next\n                add -= 1\n            \n            ret = cur.next\n            cur.next = None\n            return ret","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331579660","body":"深度优先搜索\n\n```python\nclass Solution:\ndef possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\ng = [[] for _ in range(n)]\nfor x, y in dislikes:\ng[x - 1].append(y - 1)\ng[y - 1].append(x - 1)\ncolor = [0] * n # color[x] = 0 表示未访问节点 x\ndef dfs(x: int, c: int) -> bool:\ncolor[x] = c\nreturn all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\nreturn all(c or dfs(i, 1) for i, c in enumerate(color))\n```\n复杂度分析\n-时间复杂度 O(m+n)\n-空间复杂度O(m+n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302315589","body":"```ts\r\nclass CustomStack {\r\n  maxSize: number\r\n  stack: number[]\r\n\r\n  constructor(maxSize: number) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.stack.length >= this.maxSize) return\r\n    this.stack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.stack.length === 0) return -1\r\n    return this.stack.pop()\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    for (let i = 0; i < k && i < this.stack.length; i++) this.stack[i] += val\r\n  }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307419612","body":"```ts\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  let dummyHead = new ListNode()\r\n  dummyHead.next = head\r\n  let cur = dummyHead\r\n  while (cur.next && cur.next.next) {\r\n    let next1 = cur.next,\r\n      next2 = next1.next.next\r\n    cur.next = next1.next\r\n    next1.next.next = next1\r\n    next1.next = next2\r\n    cur = next1\r\n  }\r\n  return dummyHead.next\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313916646","body":"```ts\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n  if (p === null && q === null) return true\r\n  if (p === null || q === null) return false\r\n  if (p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315505829","body":"```ts\r\nfunction sumNumbers(root: TreeNode | null): number {\r\n  return dfs(root, 0)\r\n};\r\n\r\nfunction dfs(root: TreeNode | null, preSum: number): number {\r\n  if (!root) return 0\r\n  const sum = preSum * 10 + root.val\r\n  if (!root.left && !root.right) return sum\r\n  return dfs(root.left, sum) + dfs(root.right, sum)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317121716","body":"```ts\r\nfunction findBottomLeftValue(root: TreeNode | null): number {\r\n  if (!root) return 0\r\n  let ret = 0\r\n  let queue = [root]\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    ret = node.val\r\n    node.right && queue.push(node.right)\r\n    node.left && queue.push(node.left)\r\n  }\r\n  return ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318572975","body":"```ts\r\nfunction serialize(root: TreeNode | null): string {\r\n  if (!root) return ''\r\n  const ret = []\r\n  const queue = [root]\r\n\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    if (node) {\r\n      ret.push(node.val)\r\n      queue.push(node.left)\r\n      queue.push(node.right)\r\n    } else {\r\n      ret.push('#')\r\n    }\r\n  }\r\n  return ret.join(',')\r\n}\r\n\r\nfunction deserialize(data: string): TreeNode | null {\r\n  if (!data) return null\r\n  const list = data.split(',')\r\n  const root = new TreeNode(+list.shift())\r\n  const queue = [root]\r\n  \r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    // 第一个是左节点，节点为空，直接跳过\r\n    const leftVal = list.shift()\r\n    if (leftVal !== \"#\") {\r\n      node.left = new TreeNode(+leftVal)\r\n      queue.push(node.left)\r\n    }\r\n    // 第二个是右节点，节点为空，直接跳过\r\n    const rightVal = list.shift()\r\n    if (rightVal !== \"#\") {\r\n      node.right = new TreeNode(+rightVal)\r\n      queue.push(node.right)\r\n    }\r\n  }\r\n  return root\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320912306","body":"```ts\r\nfunction twoSum(nums: number[], target: number): number[] {\r\n  const hash = new Map<number, number>()\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const num = nums[i],\r\n      s = target - num\r\n    if (hash.has(s)) return [hash.get(s), i]\r\n    else hash.set(num, i)\r\n  }\r\n  return []\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321151630","body":"```ts\r\nfunction topKFrequent(nums: number[], k: number): number[] {\r\n  const statistic: { [k: number]: number } = nums.reduce((acc, cur) => (acc[cur] = (acc[cur] || 0) + 1, acc), {})\r\n  const queue = new MinPriorityQueue({ priority: (item: [number, number]) => item[1] })\r\n  for (const item of Object.entries(statistic)) {\r\n    queue.enqueue(item)\r\n    if (queue.size() > k) queue.dequeue()\r\n  }\r\n  const res: number[] = []\r\n  while (queue.size()) res.push(queue.dequeue().element[0])\r\n  return res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321930710","body":"### Algorithm: HashMap\r\n### Code(TypeScript):\r\n```ts\r\nfunction numberOfBoomerangs(points: number[][]): number {\r\n  let ret = 0\r\n  points.forEach((p) => {\r\n    const map = new Map<number, number>()\r\n    points.forEach((q) => {\r\n      const dis = distance(p ,q)\r\n      map.set(dis, (map.get(dis) || 0) + 1)\r\n    })\r\n    for (const v of map.values()) ret += v * (v - 1)\r\n  })\r\n  return ret\r\n};\r\n\r\nfunction distance(a: number[], b: number[]): number {\r\n  return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2)\r\n}\r\n```\r\n### Time Complexity: $O(n^2)$\r\n### Space Complexity: $O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298166132","body":"# LeetCode Link\n\n[Add to Array-Form of Integer - LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/description/)\n\n# Idea\n\nAdd from last of the array `num`.\n\nUse `linkedList.addFist()` method to collect the reversed result.\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        LinkedList<Integer> lst = new LinkedList<>();\n        int carry = 0;\n        while (k != 0 || i >= 0 || carry != 0) {\n            int a = i >= 0 ? num[i] : 0;\n            int sum = a + k % 10 + carry;\n            lst.addFirst(sum % 10);\n\n            i--;\n            k /= 10;\n            carry = sum / 10;\n        }\n        return (List<Integer>) lst;\n    }\n}\n```\n\n# Complexity Analysis\n\n**Time Complexity**\n\n`O(N+L)`, where `N` is the length of `num`, `L` is number of digits of `k`.\n\n**Space Complexity**\n\n`O(1)` no extra space required.\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1305664270","body":"# LeetCode Link\r\n\r\n[[Implement Queue using Stacks - LeetCode](https://leetcode.com/problems/implement-queue-using-stacks/)](https://leetcode.com/problems/implement-queue-using-stacks/)\r\n\r\n# Idea\r\n\r\n- Use Singly linked list to implement stack\r\n- Use two stacks as a queue.\r\n\r\n# Code\r\n\r\n```java\r\nclass MyQueue {\r\n    private class Stack {\r\n        private class ListNode {\r\n            int val;\r\n            ListNode next;\r\n            public ListNode(int val, ListNode next) {\r\n                this.val = val;\r\n                this.next = next;\r\n            }\r\n            \r\n            public ListNode(int val) {\r\n                this(val, null);\r\n            }\r\n        }\r\n        // Use SLL as a stack\r\n        \r\n        ListNode head;\r\n        \r\n        public Stack() {\r\n            head = new ListNode(0);\r\n        }\r\n        \r\n        public boolean isEmpty() {\r\n            return head.next == null;\r\n        }\r\n        \r\n        public int pop() {\r\n            int val = head.next.val;\r\n            head.next = head.next.next;\r\n            return val;\r\n        }\r\n        \r\n        public void push(int x) {\r\n            ListNode p = new ListNode(x, head.next);\r\n            head.next = p;\r\n        }\r\n        public int peek() {\r\n            return head.next.val;\r\n        }\r\n    }\r\n    \r\n    Stack in;\r\n    Stack out;\r\n    public MyQueue() {\r\n        in = new Stack();\r\n        out = new Stack();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        peek();\r\n        return out.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n# Complexity Analysis\r\n\r\nTime Complexity: \r\n\r\n- Push Stack: O(1)\r\n- Pop Stack: O(1)\r\n\r\nSpace Complexity: O(N)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305662724","body":"# LeetCode Link\r\n\r\n[[Rotate List - LeetCode](https://leetcode.com/problems/rotate-list/)](https://leetcode.com/problems/rotate-list/)\r\n\r\n# Idea\r\n\r\n1. Get the length k of linkedlist.\r\n2. k = n % k. Find the (n - k)th listNode. Cut into 2 lists, swap position, and contatenate.\r\n\r\n# Code\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) return head;\r\n        if (k == 0) return head;\r\n        // get length\r\n        int size = getSize(head);\r\n        k = k % size;\r\n        if (k == 0) return head;\r\n        k = size - k;\r\n        //System.out.printf(\"k = %d\",k);\r\n        ListNode p = head;\r\n        while (k > 1) {\r\n            p = p.next;\r\n            k--;\r\n        }\r\n        // k ==0, p is the kth node\r\n        ListNode newHead = p.next;\r\n        p.next = null;\r\n        p = newHead;\r\n        while (p.next != null) {\r\n            p = p.next;\r\n        }\r\n        // p is the last node\r\n        p.next = head;\r\n        return newHead;\r\n    }\r\n\r\n    public int getSize(ListNode head) {\r\n        ListNode p = head;\r\n        int cnt = 0;\r\n        while (p != null) {\r\n            cnt++;\r\n            p = p.next;\r\n        }\r\n        return cnt;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity Analysis\r\n\r\nTime Complexity: O(N)\r\n\r\nSpace Complexity: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312374794","body":"# LeetCode Link\r\n\r\n[[LRU Cache - LeetCode](https://leetcode.com/problems/lru-cache/)](https://leetcode.com/problems/lru-cache/)\r\n\r\n# Idea\r\n\r\nDoublyLinkedList + HashMap.\r\n\r\n# Code\r\n\r\n```java\r\nclass LRUCache {\r\n    private class Node {\r\n        int key;\r\n        int val;\r\n        Node prev;\r\n        Node next;\r\n        public Node(int key, int val, Node prev, Node next) {\r\n            this.key = key;\r\n            this.val = val;\r\n            this.prev = prev;\r\n            this.next = next;\r\n        }\r\n        public Node(int key, int val) {\r\n            this(key, val, null, null);\r\n        }\r\n    }\r\n\r\n    private class DDL {\r\n        // doubly linked list\r\n        private Node head;\r\n        private Node tail;\r\n        public DDL() {\r\n            head = new Node(0, 0);\r\n            tail = new Node(0,0);\r\n            head.next = tail;\r\n            tail.prev = head;\r\n        }\r\n\r\n        public Node pollFirst() {\r\n            Node evict = head.next;\r\n            removeNode(evict);\r\n            return evict;\r\n        }\r\n\r\n        public void removeNode(Node node) {\r\n            node.next.prev = node.prev;\r\n            node.prev.next = node.next;\r\n            node.next = null;\r\n            node.prev = null;\r\n        }\r\n\r\n        public void offerLast(Node node) {\r\n            node.next = tail;\r\n            node.prev = tail.prev;\r\n            tail.prev.next = node;\r\n            tail.prev = node;\r\n        }\r\n    }\r\n\r\n    private DDL ddl = new DDL();\r\n    private int cap;\r\n    private Map<Integer, Node> memo = new HashMap<>();\r\n\r\n    public LRUCache(int capacity) {\r\n        cap = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (!memo.containsKey(key)) return -1;\r\n        Node node = memo.get(key);\r\n        ddl.removeNode(node);\r\n        ddl.offerLast(node);\r\n        return node.val;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if (memo.containsKey(key)) {\r\n            Node node = memo.get(key);\r\n            node.val = value;\r\n            ddl.removeNode(node);\r\n            ddl.offerLast(node);\r\n        }\r\n        else {\r\n            Node node = new Node(key, value);\r\n            if (memo.size() >= cap) {\r\n                // should evict\r\n                Node evict = ddl.pollFirst();\r\n                memo.remove(evict.key);\r\n            }\r\n            ddl.offerLast(node);\r\n            memo.put(key, node);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n# Complexity Analysis\r\n\r\nTime Complexity\r\n\r\nO(1)\r\n\r\nSpace Complexity\r\n\r\nO(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298358969","body":"```\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    swapArr(num)\r\n    kArr := convertToArray(k)\r\n    var res []int\r\n    var carry int\r\n    var bitSum int\r\n    for i, j := 0, 0; i < len(num) || j < len(kArr); {\r\n        if i >= len(num) {\r\n            bitSum = kArr[j] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            j++\r\n        } else if j >= len(kArr) {\r\n            bitSum = num[i] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            i++\r\n        } else {\r\n            bitSum = num[i] + kArr[j] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            i++\r\n            j++\r\n        }\r\n    }\r\n    if carry > 0 {\r\n        res = append(res, carry)\r\n    }\r\n    swapArr(res)\r\n    return res\r\n}\r\n\r\nfunc swapArr(arr []int) {\r\n    for i, j := 0, len(arr) - 1; i < j; i, j = i+1, j-1 {\r\n        arr[i], arr[j] = arr[j], arr[i]\r\n    }\r\n}\r\n\r\nfunc convertToArray(k int) []int {\r\n    var res []int\r\n    for k > 0 {\r\n        mod := k % 10\r\n        k = k / 10\r\n        res = append(res, mod)\r\n    }\r\n    return res\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301587875","body":"```\r\ntype CustomStack struct {\r\n    arr []int\r\n    sp int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{ arr: make([]int, maxSize), sp: -1 }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.sp >= len(this.arr) - 1 {\r\n        return\r\n    }\r\n    this.sp += 1\r\n    this.arr[this.sp] = x\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.sp < 0 {\r\n        return -1\r\n    }\r\n    res := this.arr[this.sp]\r\n    this.sp -= 1\r\n    return res\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    for i := 0; i <= this.sp && i < k; i++ {\r\n        this.arr[i] += val\r\n    }\r\n}\r\n```\r\nTime: O(k)\r\nSpace: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306538978","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\ntype LinkedList struct{\r\n    Head *ListNode\r\n    Tail *ListNode\r\n}\r\n\r\nfunc (l *LinkedList) Push(node *ListNode) {\r\n    if l.Head == nil {\r\n        l.Head = node\r\n        l.Tail = node\r\n    } else {\r\n        l.Tail.Next = node\r\n        l.Tail = node\r\n    }\r\n    node.Next = nil\r\n}\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil {\r\n        return nil\r\n    }\r\n    firstList := LinkedList{}\r\n    secondList := LinkedList{}\r\n    resultList := LinkedList{}\r\n    count := 0\r\n    for curNode := head; curNode != nil; {\r\n        if count % 2 == 0 { // put input firstList\r\n            next := curNode.Next\r\n            firstList.Push(curNode)\r\n            curNode = next\r\n        } else { // put input secondList\r\n            next := curNode.Next\r\n            secondList.Push(curNode)\r\n            curNode = next\r\n        }\r\n        count++\r\n    }\r\n    for nodeFirst, nodeSecond := firstList.Head, secondList.Head; nodeFirst != nil || nodeSecond != nil; {\r\n        if nodeFirst == nil { // firstList at the tail\r\n            nextNodeSecond := nodeSecond.Next\r\n            resultList.Push(nodeSecond)\r\n            nodeSecond = nextNodeSecond\r\n        } else if nodeSecond == nil { // secondList at the tail\r\n            nextNodeFirst := nodeFirst.Next\r\n            resultList.Push(nodeFirst)\r\n            nodeFirst = nextNodeFirst\r\n        } else { // both list is not at tail\r\n            nextNodeSecond := nodeSecond.Next\r\n            resultList.Push(nodeSecond)\r\n            nodeSecond = nextNodeSecond\r\n            nextNodeFirst := nodeFirst.Next\r\n            resultList.Push(nodeFirst)\r\n            nodeFirst = nextNodeFirst\r\n        }\r\n    }\r\n    return resultList.Head\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312491196","body":"```\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * obj := Constructor(capacity);\r\n * param_1 := obj.Get(key);\r\n * obj.Put(key,value);\r\n */\r\n\r\ntype Node struct {\r\n    Key int\r\n    Value int\r\n    Next *Node\r\n    Prev *Node\r\n}\r\n\r\ntype LRUCache struct {\r\n    Head *Node\r\n    Tail *Node\r\n    M map[int]*Node\r\n    Count int\r\n    Capacity int\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    head := &Node{}\r\n    tail := &Node{}\r\n    head.Next = tail\r\n    tail.Prev = head\r\n    return LRUCache{ Head: head, Tail: tail, M: make(map[int]*Node), Count: 0, Capacity: capacity }\r\n}\r\n\r\nfunc (this *LRUCache) removeNode(node *Node) {\r\n    node.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n    node.Prev, node.Next = nil, nil\r\n}\r\n\r\nfunc (this *LRUCache) insertToHead(node *Node) {\r\n    node.Next, node.Prev = this.Head.Next, this.Head\r\n    node.Prev.Next, node.Next.Prev = node, node\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    node, ok := this.M[key]\r\n    if !ok {\r\n        return -1\r\n    }\r\n    value := node.Value\r\n    // move node to head\r\n    this.removeNode(node)\r\n    this.insertToHead(node)\r\n    return value\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n    node, ok := this.M[key]\r\n    if ok { // if key exist, update node and move to head\r\n        node.Value = value\r\n        this.removeNode(node)\r\n        this.insertToHead(node)\r\n    } else { // if key not exist, create a new node and insert to head\r\n        newNode := &Node{ Value: value, Key: key }\r\n        if this.Count >= this.Capacity {\r\n            lastNode := this.Tail.Prev\r\n            this.removeNode(lastNode)\r\n            delete(this.M, lastNode.Key)\r\n            this.Count -= 1\r\n        }\r\n        this.insertToHead(newNode)\r\n        this.M[key] = newNode\r\n        this.Count += 1\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314641386","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc sumNumbers(root *TreeNode) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    var dfs func(node *TreeNode)\r\n    var path []int\r\n    var res int\r\n    dfs = func(node *TreeNode) {\r\n        defer func(){\r\n            path = path[:len(path) - 1]\r\n        }()\r\n        path = append(path, node.Val)\r\n        leftNode := node.Left\r\n        RightNode := node.Right\r\n        if leftNode == nil && RightNode == nil {\r\n            res += arrayToNum(path)\r\n        }\r\n        if leftNode != nil {\r\n            dfs(leftNode)\r\n        }\r\n        if RightNode != nil {\r\n            dfs(RightNode)\r\n        }\r\n    }\r\n    dfs(root)\r\n    return res\r\n}\r\n\r\nfunc arrayToNum(arr []int) int {\r\n    var res int\r\n    for i := len(arr) - 1; i >= 0; i-- {\r\n        res += arr[i] * int(math.Pow(10, float64(len(arr) - 1 - i)))\r\n    }\r\n    return res\r\n}\r\n\r\n```\r\nTime: O(n)\r\nSpace: O(logn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316223679","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\n\r\ntype QueueNode struct {\r\n    treeNode *TreeNode\r\n    level int\r\n}\r\n\r\nfunc findBottomLeftValue(root *TreeNode) int {\r\n    var q []QueueNode\r\n    // init q\r\n    curDeepestLevel := 1\r\n    firstNodeOfLevel := root\r\n    rootQueueNode := QueueNode{treeNode: root, level: 1}\r\n    q = append(q, rootQueueNode)\r\n    var node *TreeNode\r\n    var level int\r\n    for len(q) > 0 {\r\n        node = q[0].treeNode\r\n        level = q[0].level\r\n        if level > curDeepestLevel {\r\n            curDeepestLevel = level\r\n            firstNodeOfLevel = node\r\n        }\r\n        q = q[1:] // pop from head\r\n        if node.Left != nil { // push left node\r\n            q = append(q, QueueNode{ treeNode: node.Left, level: level + 1 })\r\n        }\r\n        if node.Right != nil { // push right node\r\n            q = append(q, QueueNode{ treeNode: node.Right, level: level + 1 })\r\n        }\r\n    }\r\n    return firstNodeOfLevel.Val\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321432308","body":"```\r\nfunc numberOfBoomerangs(points [][]int) int {\r\n    distance := make([][]float64, len(points))\r\n    var totalNumber int\r\n    for i := 0; i < len(distance); i++ {\r\n        distance[i] = make([]float64, len(points))\r\n    }\r\n    for i, row := range distance {\r\n        for j := 0; j < len(row); j++ {\r\n            distance[i][j] = getDistance(points, i, j)\r\n        }\r\n    }\r\n    for i, row := range distance {\r\n        var number int // Boomerange number per row\r\n        distMap := make(map[float64]int) // distMap: { distance: number }\r\n        for j := 0; j < len(row); j++ {\r\n            distMap[distance[i][j]] += 1\r\n        }\r\n        for _, value := range distMap {\r\n            if value > 1 {\r\n                number += value * (value - 1)\r\n            }\r\n        }\r\n        totalNumber += number\r\n    }\r\n    return totalNumber\r\n}\r\n\r\nfunc getDistance(points [][]int, i, j int) float64 {\r\n    x := points[i]\r\n    y := points[j]\r\n    return math.Sqrt((math.Pow(float64(x[0] - y[0]), 2) + math.Pow(float64(x[1] - y[1]), 2)))\r\n}\r\n```\r\nTime: O(n^2)\r\nSpace: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322956717","body":"```\r\nfunc lengthOfLongestSubstring(s string) int {\r\n\tm := make(map[byte]bool)\r\n\ti := 0\r\n\tvar longestLength int \r\n\tfor j := 0; j < len(s); j++ {\r\n\t\tfor i < j {\r\n\t\t\t_, ok := m[s[j]]\r\n\t\t\tif !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tdelete(m, s[i])\r\n\t\t\ti++\r\n\t\t}\r\n\t\tm[s[j]] = true\r\n\t\tif j - i + 1 > longestLength {\r\n\t\t\tlongestLength = j - i + 1\r\n\t\t}\r\n\t}\r\n\treturn longestLength\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326986507","body":"```\r\nfunc middleNode(head *ListNode) *ListNode {\r\n    slow, fast := head, head\r\n    for fast != nil && fast.Next != nil {\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    return slow\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328608530","body":"```\r\nfunc maxSlidingWindow(nums []int, k int) []int {\r\n    if len(nums) < k {\r\n        return []int{}\r\n    }\r\n    var descDeque []Item\r\n    res := make([]int, len(nums))\r\n    for i := 0; i < len(nums); i++ {\r\n        left := i - k + 1\r\n        // remove item out of window\r\n        for len(descDeque) > 0 {\r\n            if descDeque[0].Idx < left {\r\n                descDeque = descDeque[1:]\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n        // remove item in descDeque which smaller than inserted item\r\n        for len(descDeque) > 0 && descDeque[len(descDeque) - 1].Value < nums[i] {\r\n            descDeque = descDeque[:len(descDeque) - 1]\r\n        }\r\n        // insert item\r\n        descDeque = append(descDeque, Item{ Value: nums[i], Idx: i })\r\n        res[i] = descDeque[0].Value\r\n    }\r\n    return res[k-1:]\r\n}\r\n\r\ntype Item struct {\r\n    Value int\r\n    Idx int\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331695645","body":"```\r\nfunc possibleBipartition(n int, dislikes [][]int) bool {\r\n    if len(dislikes) == 0 {\r\n        return true\r\n    }\r\n    color := make([]int, n + 1)\r\n    // initiate adjacent table\r\n    adjTable := make([][]int, n + 1)\r\n    for idx, _ := range adjTable {\r\n        adjTable[idx] = []int{}\r\n    }\r\n    // build adjacent table\r\n    for _, edge := range dislikes {\r\n        adjTable[edge[0]] = append(adjTable[edge[0]], edge[1])\r\n        adjTable[edge[1]] = append(adjTable[edge[1]], edge[0])\r\n    }\r\n    // travers graph and paint, 1: red; 0: no color; -1: blue\r\n    for v, _ := range adjTable {\r\n        if color[v] != 0 {\r\n            continue\r\n        }\r\n        var queue []int\r\n        color[v] = 1\r\n        queue = append(queue, v)\r\n        for len(queue) > 0 {\r\n            v := queue[0]\r\n            queue = queue[1:]\r\n            edge := adjTable[v]\r\n            for _, outV := range edge {\r\n                if color[outV] == color[v] {\r\n                    return false\r\n                }\r\n                if color[outV] == 0 {\r\n                    color[outV] = -color[v]\r\n                    queue = append(queue, outV)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333560332","body":"```\r\nfunc sortItems(n int, m int, group []int, beforeItems [][]int) []int {\r\n\tvar res []int\r\n\tcurGroup := m\r\n\tfor idx, value := range group { // reassign each -1 group\r\n\t\tif value == -1 {\r\n\t\t\tgroup[idx] = curGroup\r\n\t\t\tcurGroup++\r\n\t\t}\r\n\t}\r\n\r\n\titemIndegree := make([]int, n)\r\n\tgroupIndegree := make([]int, curGroup)\r\n\tgroupItem := make([][]int, curGroup)\r\n\tfor item, groupIdx := range group { // build groupIndegree, itemIndegree and groupItem\r\n\t\tbefore := beforeItems[item]\r\n\t\titemIndegree[item] = len(before)\r\n\t\tgroupItem[groupIdx] = append(groupItem[groupIdx], item)\r\n\t\tfor _, beforeItem := range before {\r\n\t\t\tif group[beforeItem] != groupIdx {\r\n\t\t\t\tgroupIndegree[groupIdx] += 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgraph := make([][]int, n)\r\n\tfor curItem, before := range beforeItems { // build graph by beforeItems\r\n\t\tfor _, item := range before {\r\n\t\t\tgraph[item] = append(graph[item], curItem)\r\n\t\t}\r\n\t}\r\n\tvar groupQueue []int\r\n\tvar sortedGroup []int\r\n\tfor groupIdx, inDegree := range groupIndegree {\r\n\t\tif inDegree == 0 {\r\n\t\t\tgroupQueue = append(groupQueue, groupIdx)\r\n\t\t}\r\n\t}\r\n\r\n\tsortGroup := func(groupIdx int) bool { // true - success, false - has cycle\r\n\t\tvar itemQueue []int\r\n\t\tvar sortedItem []int\r\n\t\tfor _, item := range groupItem[groupIdx] {\r\n\t\t\tif itemIndegree[item] == 0 {\r\n\t\t\t\titemQueue = append(itemQueue, item)\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor len(itemQueue) > 0 {\r\n\t\t\titemIdx := itemQueue[0]\r\n\t\t\titemQueue = itemQueue[1:]\r\n\t\t\tsortedItem = append(sortedItem, itemIdx)\r\n\t\t\tfor _, toVertex := range graph[itemIdx] {\r\n\t\t\t\titemGroup := group[toVertex]\r\n\t\t\t\tif itemGroup == groupIdx { // two item in same group\r\n\t\t\t\t\tif itemIndegree[toVertex] -= 1; itemIndegree[toVertex] == 0 {\r\n\t\t\t\t\t\titemQueue = append(itemQueue, toVertex)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // toVertex in other group\r\n\t\t\t\t\titemIndegree[toVertex] -= 1\r\n\t\t\t\t\tif groupIndegree[itemGroup] -= 1; groupIndegree[itemGroup] == 0 { // add group with indegree == 0 into groupQueue\r\n\t\t\t\t\t\tgroupQueue = append(groupQueue, itemGroup)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\tif len(sortedItem) != len(groupItem[groupIdx]) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tres = append(res, sortedItem...)\r\n\t\treturn true\r\n\t}\r\n\r\n\tfor len(groupQueue) > 0 {\r\n\t\tgroupIdx := groupQueue[0]\r\n\t\tgroupQueue = groupQueue[1:]\r\n\t\tsortedGroup = append(sortedGroup, groupIdx)\r\n\t\tif !sortGroup(groupIdx) {\r\n\t\t\treturn []int{}\r\n\t\t}\r\n\t}\r\n\r\n\tif len(sortedGroup) != len(groupItem) {\r\n\t\treturn []int{}\r\n\t}\r\n\r\n\treturn res\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335057498","body":"```\r\nfunc judgeCircle(moves string) bool {\r\n    x := 0\r\n    y := 0\r\n    for i := 0; i < len(moves); i++ {\r\n        switch string(moves[i]) {\r\n            case \"U\":\r\n                y += 1\r\n            case \"D\":\r\n                y -= 1\r\n            case \"L\":\r\n                x -= 1\r\n            case \"R\":\r\n                x += 1\r\n        }\r\n    }\r\n    if x == 0 && y == 0 {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n```\r\nTIme: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298065318","body":"```java\n/*\nPlan: perform addition from backwards, edge case: k has more digits, carry\n\nTime: O(max(log_10(num), log_10(k))), number of digits\nSpace: O(max(log_10(num), log_10(k)))\n*/\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int curSum = 0, carry = 0;\n        LinkedList<Integer> sum = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            curSum = num[i] + k % 10 + carry;\n            k /= 10;\n            sum.addFirst(curSum % 10);\n            carry = curSum / 10;\n        }\n        // if k has more digits\n        while (k > 0) {\n            curSum = k % 10 + carry;\n            k /= 10;\n            sum.addFirst(curSum % 10);\n            carry = curSum / 10;\n        }\n        if (carry == 1) {\n            sum.addFirst(1);\n        }\n        return sum;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304725572","body":"```java\n/*\nstore a representative in the stack for each chunk (max value in that chunk)\nIf the current num == prev max, add to stack\nIf current num > prev max, add to stack\nIf current num < prev max, pop until find the right chunk to merge:\ninsert 3, e.g. 1, 4, pop 4, insert 3\n\n[4,2,2,1,1]\n-> 1\n\nstack:bottom ---> increasing\nTime: O(arr.length)\nSpace: O(arr.length)\n\n\n\n*/\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            }\n            else {\n                int curmax = stack.peek();\n                while (!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(curmax); // merge num into the chunk represented by curmax\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298605508","body":"### 思路 从数组最后一个元素开始加，用一个队列记录答案，用一个变量记录是否要进一位。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        Deque<Integer> res = new ArrayDeque<>();\n        int plusOne = 0;\n        for(int i = num.length - 1 ; i >= 0 ; i--){\n            int n = num[i] + k%10 + plusOne;\n            k = k/10;\n            if(n >= 10){\n                plusOne = 1;\n            }else{\n                plusOne = 0;\n            }\n            res.addFirst(n%10);\n        }\n        //结束后，k可能还有剩余，或者还要进位\n        while(k != 0){\n            int n = k % 10 + plusOne;\n            k /= 10;\n            if(n >= 10){\n                plusOne = 1;\n            }else{\n                plusOne = 0;\n            }\n            res.addFirst(n%10);\n        }\n        if(plusOne == 1){\n            res.addFirst(1);\n        }\n        return new ArrayList<Integer>(res);\n\n    }\n}\n```\n### 复杂度  \n时间O(n),n是数组长度  \n空间O(n),记录答案所消耗的开销\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1298895541","body":"\n### Method 1:\n双指针，对于每一个元素，定义两个指针从自身背向出发，定义变量distance记录距离，当遇到字符c时，返回distance.\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        for(int i = 0 ; i < s.length() ;i++){\n            res[i] = getShortestChar(s , i , c);\n        }\n        return res;\n    }\n    //双指针\n    public int getShortestChar(String s , int i , char c){\n        if(s.charAt(i) - c == 0)return 0;\n        int left = i , right = i;\n        int distance = 0;\n        while(left >= 0 || right <= s.length() - 1 ){\n            \n            if(s.charAt(left) - c ==0 || s.charAt(right) - c == 0){\n                return distance;\n            }\n            if(left > 0){\n                left--;\n            }\n            if(right < s.length() - 1){\n                right++;\n            }\n            distance++;\n\n        }\n        return distance;\n\n    }\n}\n```\n### 复杂度\n时间O(n^2)  \n空间O(n)  \n### method 2:\n两遍遍历，同时记录到c的距离。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] res = new int[N];\n        int idx = -N;\n        for(int i = 0 ; i < N ; i++){\n            if(s.charAt(i) - c == 0){\n                idx = i;\n            }\n            res[i] = Math.abs(i - idx);\n        }\n        \n        for(int i = N - 1 ; i >= 0 ;i--){\n            if( s.charAt(i) - c ==0){\n                idx = i;\n            }\n            res[i] = Math.min(res[i] , Math.abs(i - idx));\n        }\n        return res;\n    }\n}\n```\n### 复杂度\nTime O(n)  \nSpace O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301009155","body":"### 思路：数组模拟栈，定义变量idx表示当前栈的容量。\n```java\nclass CustomStack {\n    int[] stack;\n    int idx;\n    int maxSize;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        idx = -1;\n    }\n    \n    public void push(int x) {\n        \n        if(idx < maxSize - 1 && idx >= -1){\n            ++idx;\n            stack[idx] = x;\n        }\n    }\n    \n    public int pop() {\n        if(idx >= 0){\n            return stack[idx--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k , idx + 1);\n        for(int i = 0 ; i < min ; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度\npop() : time O(1), space O(1)  \npush() : time O(1),space O(1)  \nincrement(): time O(k),space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302697660","body":"### 思路：遍历字符串，当字符不是” ]“右括号时压入栈，遇到右括号时，栈弹出，在遇到 \" [ \"左括号前，把所有字符组成repeatString , 然后当还是数字时弹出，组成num，对repeatString 重复num次，再把新的字符串压入栈中。\n```java\nclass Solution {\n    public String decodeString(String s) {\n        int N = s.length();\n        Stack<String> stack = new Stack<>();\n        for(int i = 0 ; i < N ; i ++){\n            String repeatStr = \"\";\n            String num = \"\";\n            String newString = \"\";\n            String cur = s.substring(i , i + 1);\n            if(!cur.equals(\"]\") ){\n                stack.push(s.substring(i , i+1));\n            }else{\n                while(!stack.isEmpty() && !stack.peek().equals(\"[\")){\n                    repeatStr = stack.pop() + repeatStr;\n                }\n                stack.pop();// pop :[\n                while(!stack.isEmpty() && stack.peek().matches(\"[0-9]\")){\n                    num = stack.pop() + num;\n                }\n                for(int j = 0 ; j < Integer.valueOf(num) ; j++){\n                    newString += repeatStr;\n                }\n                //把新字符串压回栈中\n                for(int j = 0 ; j < newString.length() ; j++){\n                    stack.push(newString.substring(j , j + 1));\n                }\n            }\n            \n            \n        }\n        String res = \"\";\n        while(!stack.isEmpty()){\n            res = stack.pop() + res;\n        }\n        return res;\n    }\n}\n```\ntime O(n)  \nspace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561045","body":"\n```java\nclass MyQueue {\n    Stack<Integer> in;\n    Stack<Integer> out;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    public int peek() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        if(in.isEmpty() && out.isEmpty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304790996","body":"\n先抄个答案·\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        int res = 0;\n        int[] sortedArr = new int[arr.length];\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\n        Arrays.sort(sortedArr);\n        for (int i = 0; i < sortedArr.length; i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n            if (cnt.get(x) == 0) {\n                cnt.remove(x);\n            }\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\n            if (cnt.get(y) == 0) {\n                cnt.remove(y);\n            }\n            if (cnt.isEmpty()) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n\n```\ntime O(nlogn)\nspace O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308860428","body":"### 思路：每次找到链表的中点，将该点作为树的根节点，然后用递归继续寻找链表左边的中点以及右边的中点\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return bfs(head ,null);\n        \n    }\n    public TreeNode bfs(ListNode start , ListNode end){\n        if(start == end) return null;\n\n        \n        ListNode fast = start,slow = start;\n        while(fast != end && fast.next != end){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        TreeNode root = new TreeNode(slow.val);\n        root.left = bfs(start , slow);\n        root.right = bfs(slow.next , end);\n\n        return root;\n    }\n}\n```\ntime O(n)\nspace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309185190","body":"### 思路：定义两个指针指向headA和headB,当A指针走到null则从B链开始走,当B指针走到null则从A链开始走，两指针再次相遇时则是相交点，不相遇则会返回null\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        ListNode A =  headA, B = headB;\n        while(A != B){\n            if(A == null){\n                A = headB;\n            }else{\n                A = A.next;\n            }\n            if(B == null){\n                B = headA;\n            }else{\n                B = B.next;\n            }\n            \n        }\n        return A;\n    }\n}\n```\ntime O(n + m)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311857299","body":"### 思路：快慢指针，当快慢指针相遇时，快指针再从头开始走，再次相遇则是环入口点\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null)return null;\n        ListNode fast = head,slow=head;\n        \n        while(true){\n            if(fast==null||fast.next==null)return null;\n            fast=fast.next.next;\n            slow = slow.next;\n            if(fast==slow)break;\n        }\n        fast=head;\n        while(fast!=slow){\n            fast=fast.next;\n            slow=slow.next;\n        }\n        return fast;\n    }\n}\n```\ntime o(n)\nspace O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320051310","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n\n```\ntime O(nlogn)\nspaceO(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326782228","body":"### 思路：快慢指针，快指针一次走两步，慢指针一次走一步，快指针走到结尾时，此时慢指针即为中点\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head , fast = head;\n        while(fast != null && fast.next !=null ){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\ntime O(n),n为链表节点数量\nspace O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334465309","body":"### 思路：简单模拟。\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0,y=0;\n        char[] c = moves.toCharArray();\n        for(char each:c){\n            if(each-'U' == 0){\n                y--;\n            }else if(each - 'D' == 0){\n                y++;\n            }else if(each - 'L' == 0){\n                x--;\n            }else if(each - 'R' == 0){\n                x++;\n            }\n        }\n\n        if(x == 0 && y ==0){\n            return true;\n        }\n        return false;\n    }\n}\n```\ntime O(n),n字符串长度\nspace O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317132508","body":"### 思路\nBFS\n### code\n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        if(!root){\n            return -1;\n        }\n        q.push(root);\n         int left = root->val;\n        while(!q.empty()){\n            int qSize = q.size();\n            TreeNode* curr = q.front();\n            left = curr->val;\n            while(qSize--){\n                curr = q.front();\n                q.pop();\n                if(curr->left)\n                q.push(curr->left);\n                if(curr->right)\n                q.push(curr->right);\n            }\n\n        }\n        return left;\n    }\n\n};\n```\n### 复杂度\n时间: O(n) \n空间: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321178084","body":"### 思路\r\n用hashmap存起来\r\n再放进最大堆里\r\n\r\n### code\r\n```C++\r\nstruct cmp {\r\n    bool operator()(pair<int,int> const& p1, pair<int,int> const& p2)\r\n    {\r\n    \r\n        return p1.second < p2.second;\r\n    }\r\n};\r\n \r\n\r\nclass Solution {\r\npublic:\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int,int> hashMap;\r\n        for(auto i: nums){\r\n            ++hashMap[i];\r\n        }\r\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> heap;\r\n        for(auto i: hashMap){\r\n            heap.push(make_pair(i.first,i.second));\r\n        }\r\n        vector<int>ret;\r\n        for(int i = 0; i < k; ++i){\r\n            \r\n            ret.push_back(heap.top().first);\r\n            heap.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间: 插入hashmap 为O(n), n是整个vector长度, 插入heap是logN, n是vector里unique的数字的长度, 删除是logN\r\n空间: O(N) n是vector里unique的数字的个数","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323781155","body":"### 思路\n哈希表和滑动窗口结合.\n当一个元素能在哈希表里被找到说明有元素重复, 需要把当前窗口从左往右一直erase元素直到找到那个重复元素为止.\n然后比较新的窗口的大小和之前的size大小, 并插入当前元素\n\n### code\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int i = 0; \n        int j = 0;\n        int ret = 0;\n        unordered_set<char>hashTable;\n        while(j<s.size()){\n            while(hashTable.find(s[j]) != hashTable.end()){\n                hashTable.erase(s[i]);\n                ++i;\n            }\n            ret = max(ret, j-i+1);\n            hashTable.insert(s[j]);\n            ++j;\n        }\n        return ret;\n    }\n};\n```\n\n###  复杂度\n时间: O(n) \n空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297848071","body":"python one line\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [int(i) for i in list(str(int(''.join(map(str,num)))+k))]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299744757","body":"```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        dis = []\n        idx = s.index(c)\n        for i in range(len(s)):\n            if abs(idx-i)>abs(s.find(c,i)-i):\n                idx = s.index(c,i)\n            if s[i]!=c:\n                dis.append(abs(idx-i))\n            else:\n                dis.append(0)\n        return dis\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301701899","body":"```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize = maxSize\n        self.stack = []\n        self.inc = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n\n        return self.stack.pop()+self.inc.pop()\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.inc:\n            self.inc[min(k, len(self.inc))-1] += val\n```\n- Time:O(n)\n- Space:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302812702","body":"```python\nclass Solution(object):\n    def decodeString(self, s):\n        # 两个栈，一个进数字，一个进字母，反括号出栈\n        stack = [];curNum=0;curString=''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString\n```\n- Time: O(n)\n- Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304395500","body":"```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.in_stk = []\n        self.out_stk = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.in_stk.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek()\n        return self.out_stk.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.out_stk:\n            while self.in_stk:\n                self.out_stk.append(self.in_stk.pop())\n        return self.out_stk[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.in_stk and not self.out_stk\n```\n- Time:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304729549","body":"```python \nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        count = 0\n        for i in arr:\n            if len(stack)==0 or stack[-1]<=i:\n                stack.append(i)\n            else:\n                ma = stack[-1]\n                # 如果遇到更大的值，则一直往前比较（每次比较都会删去栈顶一个元素）\n                while stack and stack[-1]>i:\n                    ma = max(ma,stack.pop())\n                stack.append(ma)\n        return len(stack)\n```\n- Time:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304941600","body":"```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 返回链表倒数第k个元素，当k大于链表长度时，返回倒数K/len的元素，然后最后一位拼接一下\n        # 先获取数组长度\n        if not head:\n            return None\n        lastElement = head\n        length = 1\n        while(lastElement.next):\n            lastElement = lastElement.next\n            length += 1\n        # 先拼成环\n        lastElement.next = head\n        # 找出倒数第k个元素，进行切割\n        k = k%length\n        p = head\n        for i in range(length - k - 1):\n            p = p.next\n\n        head2 = p.next\n        p.next=None\n        return head2\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306422586","body":"```python\nclass Solution(object):\n    def swapPairs(self, head):\n        if not head or not head.next:\n            return head\n        # 创建一个prev节点指向A，可以避免判断边界条件\n        ans = prev = ListNode()\n        prev.next = head\n        # prev-a-b-c-d-e\n        # prev-b-a-c\n        while head and head.next:\n            a = head\n            b = a.next\n            c = b.next\n\n            prev.next = b\n            b.next = a\n            a.next = c\n\n            prev = a\n            head = c\n\n        return ans.next\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307987276","body":"```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        # 定义快慢指针，找到中点，为二叉搜索树的根节点\n        if not head:\n            return head\n        pre,slow,fast = None,head,head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n\n        if pre:\n            pre.next = None\n        \n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n- Time:O(nlogn)\n- Space:O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309696587","body":"```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # 两列表加起来一样长\n        # A+B=B+A,然后最后两者将重合在一起\n        a,b = headA,headB\n        while(a!=b):\n            a = headB if not a else a.next\n            b = headA if not b else b.next\n        return a\n```\n- Time：O(n)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311342879","body":"```python\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # 设定快慢指针，有环的链表最终会相遇\n        slow = fast = head\n        while fast and fast.next:\n            slow  = slow .next\n            fast = fast.next.next\n            if slow==fast:\n                break\n        else: return None\n        while head != slow:\n            head,slow = head.next,slow.next\n        return head\n```\n- Time: O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312405826","body":"```python\nclass ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        self.dic = dict() \n        self.capacity = capacity\n        self.head = ListNode(0, 0)\n        self.tail = ListNode(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self,key):\n        if key in self.dic:\n            node = self.dic[key]\n            self.removeFromList(node)\n            self.insertIntoHead(node)\n            return node.value\n        else:\n            return -1\n\n    def put(self, key, value):\n        if key in self.dic:               \n            node = self.dic[key]\n            self.removeFromList(node)\n            self.insertIntoHead(node)\n            node.value = value        \n        else: \n            if len(self.dic) >= self.capacity:\n                self.removeFromTail()\n            node = ListNode(key,value)\n            self.dic[key] = node\n            self.insertIntoHead(node)\n\n    def removeFromList(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def insertIntoHead(self, node):\n        headNext = self.head.next \n        self.head.next = node \n        node.prev = self.head \n        node.next = headNext \n        headNext.prev = node\n    \n    def removeFromTail(self):\n        if len(self.dic) == 0: return\n        tail_node = self.tail.prev\n        del self.dic[tail_node.key]\n        self.removeFromList(tail_node)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312642638","body":"```python\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # 使用DFS\n        if not root: return 0\n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312862826","body":"```python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val==q.val and self.isSameTree(p.left,p.left) and self.isSameTree(q.right,q.right)\n```\n- Time:O(N)，其中 N 为树的节点数。\n- Space: O(h)，其中 h 为树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314920392","body":"```python\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.res = 0\n        self.dfs(root,0)\n        return self.res\n\n    def dfs(self,root,path):\n        if root:\n            if not root.left and not root.right:\n                path = path*10+root.val\n                self.res += path\n            self.dfs(root.left,path*10+root.val)\n            self.dfs(root.right,path*10+root.val)\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316122994","body":"```python\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.last_left,self.last_row = 0,-1\n        def dfs(cur_node,cur_row):\n            if not cur_node:\n                return\n            \n            if cur_row>self.last_row:\n                self.last_row = cur_row\n                self.last_left = cur_node.val\n\n            dfs(cur_node.left,cur_row + 1)\n            dfs(cur_node.right,cur_row+1)\n        \n        dfs(root,0)\n\n        return self.last_left\n```\n- Time:O(N)，其中 N 为树的节点总数。\n- Space:O(h)，其中 h 为树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317848629","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        # 考虑最基本的情况，当一个节点为空节点的时候用什么字符代替\n        if not root:\n            return 'x'\n        # 对树进行先序遍历\n        return ','.join([str(root.val),self.serialize(root.left),self.serialize(root.right)])\n\n    def deserialize(self, data):\n        # 遇到x则置为null\n        self.data = data\n        if self.data[0] == 'x':\n            return None\n        node = TreeNode(self.data[:self.data.find(',')])\n        node.left = self.deserialize(self.data[self.data.find(',')+1:])\n        node.right = self.deserialize(self.data[self.data.find(',')+1:])\n        return node\n```\n- Time:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319720394","body":"```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        queue = [(root, 0)]\n        hashmap = collections.defaultdict(list);\n        level = 0\n        while (len(queue)):\n            levelSize = len(queue)\n            while (levelSize > 0):\n                curElem, pos = queue.pop(0)\n                hashmap[pos].append((level, curElem.val));\n                \n                if (curElem.left):\n                    queue.append((curElem.left, pos-1))\n                \n                if (curElem.right):\n                    queue.append((curElem.right, pos+1));\n                    \n                levelSize-=1;\n            level+=1;\n        keys = sorted(hashmap.keys());\n        result = []\n            \n        for key in keys:\n            curLevelElems = hashmap[key];\n            curLevelElems = sorted(hashmap[key])\n            result.append(list(map(lambda x: x[1],curLevelElems)));\n        return result\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320861209","body":"```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        seen = {}\n        for i, num in enumerate(nums):\n            if target - num in seen:\n                return [seen[target - num], i]\n            seen[num] = i\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321053046","body":"```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        hs = {}\n        frq = {}\n        for i in range(0,len(nums)):\n            if nums[i] not in hs:\n                hs[nums[i]] = 1\n            else:\n                hs[nums[i]] += 1\n        \n        for z,v in hs.iteritems():\n            if v not in frq:\n                frq[v] = [z]\n            else:\n                frq[v].append(z)\n        arr = []\n\n        for x in range(len(nums),0,-1):\n            if x in frq:\n                for i in frq[x]:\n                    arr.append(i)\n        return [arr[x] for x in range(0, k)]\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321299162","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for a,b in points:\n            counter = {}\n            for x,y in points:\n                dis = (x-a)**2 + (y-b)**2\n                if dis in counter:\n                    n += 2*counter[dis]\n                    counter[dis] += 1\n                else:\n                    counter[dis] = 1\n        return n\n```\n- Time:O(n^2)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322854831","body":"```python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # 设置一个栈,无重复的就入栈,有重复就出栈,直至没有重复的再入栈\n        stack = []\n        n=0\n        for i in s:\n            while i in stack:\n                stack = stack[1:]\n            stack.append(i)\n            if n<len(stack):\n                n = len(stack)\n        return n\n```\n- Time:O(n^2)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324671646","body":"```python\nfrom collections import deque, defaultdict\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        # 使用哈系表加滑动窗口,滑动窗口的总长度不变\n        word_len = len(words[0])\n        ori_word_dict = defaultdict(int)\n        # 创建关于words的字典\n        for word in words:\n            ori_word_dict[word] += 1\n        # 这里是滑动窗口的长度,正好对应了单词组合的总长度\n        all_word_len = len(words)*word_len\n        result = []\n        for i in range(word_len):\n            # 初始化滑动窗口\n            queue = deque()\n            word_dict = ori_word_dict.copy()\n            for j in range(i,len(s)-word_len+1,word_len):\n                word = s[j:j+word_len]\n                if word_dict.get(word, 0) != 0:\n                    word_dict[word] -= 1\n                    queue.append(word)\n                    if sum(word_dict.values()) == 0:\n                        result.append(j - all_word_len + word_len)\n                        last_element = queue.popleft()\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                else:\n                    while len(queue):\n                        last_element = queue.popleft()\n                        if last_element == word:\n                            queue.append(word)\n                            break\n                        else:\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                            if word_dict[last_element] > ori_word_dict[last_element]:\n                                word_dict = ori_word_dict.copy()\n        return result\n```\n- Time:O(n*m)\n- Space:O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325799363","body":"```python\nclass Solution:\n    def minSubarray(self, nums, k):\n        target = sum(nums) % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for i in range(len(nums)):\n            total += nums[i]\n            cur = total % k\n            curtarget = (cur - target + k) % k\n            if curtarget in dic:\n                ans = min(ans,i-dic[curtarget])\n            dic[cur] = i\n        \n        if ans == len(nums):\n            return -1\n        return ans\n```\n- Time:O(n)\n- Space:O(min(n,k))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326928990","body":"```python\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327985688","body":"```python\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        x = 1\n\n        for i in range(len(nums)-1):\n            if(nums[i] != nums[i+1]):\n                nums[x] = nums[i+1]\n                x += 1\n        return(x)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328161925","body":"```python\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        l,r = 0,len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n- Time: O(logn)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328995556","body":"```python\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        from collections import deque\n        q = deque()\n        res = []\n        for i,cur in enumerate(nums):\n            while q and nums[q[-1]]<cur:\n                q.pop()\n            q.append(i)\n            if q[0] == i-k:\n                q.popleft()\n            if i>=k-1:\n                res.append(nums[q[0]])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329920221","body":"```python\nclass Solution(object):\n    def findJudge(self, n, trust):\n        trusted = [0]*(n+1)\n        for (a,b) in trust:\n            trusted[a] -= 1\n            trusted[b] += 1\n        for i in  range(1,n+1):\n            if trusted[i] == n-1:\n                return i\n        return -1\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331500382","body":"```python\nimport collections\n\n\nclass Solution(object):\n    def possibleBipartition(self, n, dislikes):\n        Not_COLORED,BLUE,GREEN = 0,1,-1\n        def helper(person_id,color):\n            color_table[person_id] = color\n            for the_other in dislike_table[person_id]:\n                if color_table[the_other] == color:\n                    return False\n                if color_table[the_other] == Not_COLORED and not helper(the_other,-color):\n                    return False\n            return True\n        if n==1 or not dislikes:\n            return True\n        dislike_table = collections.defaultdict(list)\n        color_table = collections.defaultdict(int)\n        for p1,p2 in dislikes:\n            dislike_table[p1].append(p2)\n            dislike_table[p2].append(p1)\n        for person_id in range(1,n+1):\n            if color_table[person_id] == Not_COLORED and not helper(person_id,BLUE):\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333246361","body":"```python\nimport collections\nclass Solution:\n    def has_cycle(self,graph,cur_node,visited,result):\n        if visited[cur_node]==1:\n            return False\n        if visited[cur_node]==2:\n            return True\n        visited[cur_node]=2\n        for next_node in graph[cur_node]:\n            if self.has_cycle(graph,next_node,visited,result):\n                return True\n        visited[cur_node] = 1\n        result.append(cur_node)\n        return False\n    def sortItems(self, n, m, group, beforeItems):\n        # Map between group_id and item_ids\n        group_items_map = defaultdict(list)\n        # Visited for items in each group. Will be used later\n        visited_item = defaultdict(dict)\n        for i in range(n):\n            # Assign no-group items to a new group\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n            group_items_map[group[i]].append(i)\n            visited_item[group[i]][i] = 0\n\n        # key - group_id : value - next_groups\n        graph_group = defaultdict(set)\n        # key - group_id : value - {key - item_id : value: next_items}\n        graph_item = {i: defaultdict(list) for i in range(m)}\n\n        # Create graph for items and groups\n        for item_after, before_items in enumerate(beforeItems):\n            for item_before in before_items:\n                group_before = group[item_before]\n                group_after = group[item_after]\n\n                # If two items belong to different groups,\n                #   add a dependency between groups\n                # Otherwise, add a dependency between items in the same group\n                if group_before != group_after:\n                    graph_group[group_before].add(group_after)\n                else:\n                    graph_item[group_before][item_before].append(item_after)\n\n        # Use DFS to find group order\n        visited_group = [0] * m\n        group_order = []\n        for group_id in range(m):\n            if self.has_cycle(graph_group, group_id,\n                              visited_group, group_order):\n                return []\n\n        # Use DFS to find item order in each group\n        full_item_order = []\n        for group_id in group_order:\n            for item_id in group_items_map[group_id]:\n                if self.has_cycle(graph_item[group_id], item_id,\n                                  visited_item[group_id], full_item_order):\n                    return []\n        return full_item_order[::-1]\n   ```\n- Time:O(m+n)\n- Space:O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334590680","body":"```python\nclass Solution(object):\n    def judgeCircle(self, moves):\n        return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304546268","body":"### 思路: 用一个栈负责进入,然后将这个栈中的元素倒置放在另一个栈中,每次push取栈1,pop和peek取栈2的栈顶\n\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = []\n};\n\n\nMyQueue.prototype.push = function(x) {\n    console.info(x)\n    this.stack1.push(x)\n    \n};\n\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length==0){\n        for(let i=0;i<this.stack1.length;i++){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\n\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length==0){\n        for(let i=0;i<this.stack1.length;i++){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length-1] \n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack1.length ==0 && this.stack2.length == 0\n};\n\nvar obj = new MyQueue()\nobj.push(1)\nvar param_2 = obj.pop()\n\n### 复杂度分析:\n时间: pop,peek O(n), empty O(1)\n空间: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312425909","body":"### 思路\n根据题意，插入和查询都必须满足O(1)的平均时间复杂度，我们可以分别用双向链表实现插入删除，hash表实现查询，具体思路：\n\n查询时：未查到，返回-1；查到了，除了返回值，我们还要将对应的node更新至头部\n插入时：未存在，将节点插在头部，若插入后超过容量，直接删除尾部节点；若存在，就变更对应的值，并将节点移到头部\n\n<pre>\n<code>\nclass Node{\n    int key;\n    int value;\n    Node pre;\n    Node next;\n}\n\n/**\n     * 0. hash表维护查O(1): {{1: {1, 1}}, {2: {2, 2}}}\n     * 1. 双向链表实现插入删除O(1)\n     */\n    class LRUCache {\n        private HashMap<Integer, Node> dict;\n        private int capacity;\n        private Node head;\n        private Node tail;\n\n        public LRUCache(int capacity) {\n            this.capacity = capacity;\n            dict = new HashMap<>();\n            head = new Node();\n            tail = new Node();\n            head.next = tail;\n            tail.pre = head;\n        }\n\n        public int get(int key) {\n            if(!dict.containsKey(key)) return -1;\n            //存在，节点更新至头部\n            Node node = dict.get(key);\n            remove(node);\n            insert(head, node);\n            return node.value;\n        }\n\n        public void put(int key, int value) {\n            if(!dict.containsKey(key)){\n                //不存在，将节点放在头节点后面\n                Node node = new Node();\n                node.key = key;\n                node.value = value;\n                dict.put(key, node);\n                insert(head, node);\n                //超过容量，更新hash表，并移除末尾节点\n                if(dict.size() > capacity){\n                    dict.remove(tail.pre.key);\n                    remove(tail.pre);\n                }\n            }else{\n                //存在，则将该节点移到头部\n                Node node = dict.get(key);\n                node.value = value;\n                remove(node);\n                insert(head, node);\n            }\n\n        }\n\n        //双向链表的插入删除模板\n        void insert(Node head, Node node){\n            head.next.pre = node;\n            node.next = head.next;\n            head.next = node;\n            node.pre = head;\n        }\n\n        void remove(Node node){\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n        }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n<code>\n<pre>\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318746952","body":"## 代码\n<pre>\n<code>\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n</code>\n</pre>\n\n## 复杂度\n时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)O(n)，其中 nn 是节点数，即树的大小。 \n\n空间复杂度：在序列化和反序列化函数中，我们递归会使用栈空间，故渐进空间复杂度为 O(n)O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325971232","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& A, int K) {\n    \tint res = 0, sum = 0;\n        unordered_map<int, int> m{{0, 1}};\n        for (int num : A) {\n        \tsum = (sum + num % K + K) % K;\n        \tres += m[sum];\n        \t++m[sum];\n        }\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297621667","body":"**Thoughts**\n\nAdding k with the last digit of num, the mod result will be the digit of result, and carry-on can be calculated as well\n\n**Complexity**\n\nO(N)\n\n**Code**\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list  = new LinkedList<>();\n        int n = num.length;\n\n        // each time we add k with last digit of num, add the mod value to the list \n        for (int i = n - 1; i >= 0; i--) {\n            list.add(0, (num[i] + k) % 10);\n            // carry on value\n            k = (num[i] + k) / 10;\n        }\n        //for the rest of k\n        while (k > 0) {\n            list.add(0, k % 10);\n            k /= 10;\n        }\n        return list;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299508660","body":"**Thoughts**\n\nSweep string s from left and right side, if we locate c, record the index, then compare the absolute value of i and index\n\n**Complexity**\n\nTime: O(n)\nSpace: O(1) no other space except the result\n\n**Code**\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n\n        for (int i = 0, idx = -len; i < len; i++) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n        for (int i = len - 1, idx = 2 * len; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = Math.min(idx - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302272872","body":"**Thoughts**\n\nJust simple manipulation \n\n**Time Complexity**\n\nTime: O(1)\nSpace: O(1)\n\n**Code**\n\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top; // to record the index of top element\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303802706","body":"**Thoughts**\n\nUse Stack to push characters of s, stop when it hits ], and then gather the characters, read the multiplier, finally push all characters into the stack and pop out\n\n**Complexity**\n\nTime: O(N), N is the length of s\nSpace: O(N) the use of stack\n\n**Code**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c);\n            } else {\n                StringBuilder sb = new StringBuilder();\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n                String sub = sb.toString();\n                stack.pop(); // remove [\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n                int count = Integer.valueOf(sb.toString());\n\n                while (count > 0) {\n                    for (char su: sub.toCharArray()) {\n                        stack.push(su);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304389055","body":"***Thoughts***\n\nUsing two stacks, one is to save input, another one is used to save data in reverse direction\n\n***Complexity***\n\nTime: O(1) no traversing\nSpace: O(N). use another stack\n\n***Code***\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() { \n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304815563","body":"***Thoughts***\n\n1. If current number is greater the peek of stack, it can be an individual chunk\n2. If current number is less than the peek of stack, we remove the values greater than it\n\n**Complexity**\n\nTime: O(N)\nSpace: O(N)\n\n**Code**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n\n        for (int num: arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307365421","body":"**Thoughts**\n\nRecursive way to sway a pair of nodes, each time move to the next pair\n\n**Complexity**\n\nTime: O(N)\n\nSpace: O(N) stack been used\n\n**Code**\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode tmp = head.next;\n        head.next = swapPairs(tmp.next);\n        tmp.next = head;\n        return tmp;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308168028","body":"**Thoughts**\n\nDivide and conquer \n\n**Complexity**\n\nTime: O(NlogN)\nSpace: O(logN) max depth of stack \n\n**Code**\n\n```java\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) return null;\n\n        ListNode mid = findMid(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode findMid(ListNode left, ListNode right) {\n        ListNode slow = left;\n        ListNode fast = left;\n\n        while (fast != right && fast.next != right) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310455614","body":"**Thoughts**\n\nTwo pointers, once pointer A meet the tail of headA, connect it to headB, A and B will finally meet at the intersection if there's one\n\n**Complexity**\n\nTime: O(n) , n is the total length of two lists\nSpace: O(1)\n\n**Code**\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode pA = headA, pB = headB;\n\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311783416","body":"**Thoughts**\r\n\r\nIf no loop, fast will hit the tail of list; if loop. exists, fast will catch slow eventually. \r\nOnce fast caught slow, we use another pointer to find the node cycle begins\r\n\r\n**Complexity**\r\n\r\nTime: O(n)\r\nSpace: O(1)\r\n\r\n**Code**\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;// no loop\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (fast == slow) break; // fast caught slow in the loop\r\n        }\r\n        fast = head;\r\n        while (slow != fast) {\r\n            // once slow == fast, loop ends\r\n            // fast will be at the point cycle begins\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return fast;\r\n\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312515659","body":"***Code***\n\n```java\nclass LRUCache { \n\n    class DoublyLinkedNde {\n        int key;\n        int val;\n        DoublyLinkedNde prev;\n        DoublyLinkedNde next;\n        public DoublyLinkedNde() {}\n        public DoublyLinkedNde (int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private Map<Integer, DoublyLinkedNde> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DoublyLinkedNde head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        head = new DoublyLinkedNde();\n        tail = new DoublyLinkedNde();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DoublyLinkedNde tmp = cache.get(key);\n        if (tmp == null) {\n            return -1;\n        }\n        moveToHead(tmp);\n        return tmp.val;\n    }\n    \n    public void put(int key, int value) {\n        DoublyLinkedNde tmp = cache.get(key);\n        if (tmp != null) {\n            tmp.val = value;\n            moveToHead(tmp);\n        } else {\n            DoublyLinkedNde node = new DoublyLinkedNde(key, value);\n            cache.put(key, node);\n            addNode(node);\n            size++;\n            if (size > capacity) {\n                DoublyLinkedNde res = removeTail();\n                cache.remove(res.key);\n                size--;\n            }\n        }\n\n    }\n \n    private void moveToHead(DoublyLinkedNde node) {\n        remove(node);\n        addNode(node);\n    }\n\n    private void remove(DoublyLinkedNde node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addNode(DoublyLinkedNde node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private DoublyLinkedNde removeTail() {\n        DoublyLinkedNde res = tail.prev;\n        remove(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312518111","body":"***Thoughts***\n\nRecursive solution\n\n**Complexity**\n\nTime: O(N), each node being visited once\nSpace: O(height), the height of tree\n\n**Code**\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n    }\n}\n\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316280920","body":"***Thoughts***\n\nBFS, each time visit right subnode, and then left subnode. so the last node we visit must be the very left subnode of the last level\n\n***Complexity***\n\nTime: O(n), visit all nodes\nSpace: O(n) extra space used\n\n***Code***\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res = 0;\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode p = queue.poll();\n            if (p.right != null) {\n                queue.offer(p.right);\n            }\n            if (p.left != null) {\n                queue.offer(p.left);\n            }\n            res = p.val;\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297787339","body":"### 思路\r\n\r\n先得到整数num与k相加和的结果，然后从个位数开始每次往前一位取出加入list，在每一次取数位结果的同时将和的结果除以10，直至k的结果小于等于0停止加入list。比如 123 + 912，实现3+2, 2+1, 1+9。当对应位的加和结果超过10，我们将先将0加入list，再加入1，最后结果是1035。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n    for (int i = num.length - 1; i >= 0; i--) {\r\n            res.add((num[i] + k) % 10);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while(k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299341332","body":"### 思路\r\n两次遍历，第一次找到每个i左边最近的 c，第二次找到每个i右边最近的 c。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, n);\r\n        \r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) j = i;\r\n            if(j != -1) ans[i] = i - j;\r\n        }\r\n        \r\n        for(int i = n-1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) j = i;\r\n            if(j != -1) ans[i] = Math.min(ans[i], j - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301328092","body":"### 思路\r\n新建一个数组来进行模拟栈的操作\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top = -1;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) return -1;\r\n        top--;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < (Math.min(k, stack.length)); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：increment的操作是O(n)，其他操作是O(1)。\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303048165","body":"## Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n## Time Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304413581","body":"## Thoughts\r\n- 使用两个栈，一个输入栈，一个输出栈\r\n- push时pop到输入栈；pop或peek时需要将数据从输入栈pop出,push到输出栈，然后再将数据pop或peek\r\n- empty方法需要判断两个栈都为空\r\n\r\n## Code\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        peek();\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s2.isEmpty()) {\r\n          while(!s1.isEmpty()) s2.push(s1.pop());  \r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n## TC\r\nTime: O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304649141","body":"## Thoughts\r\n前缀和方法：\r\narr: [2,1,3,4,4]\r\ncopy:[1,2,3,4,4]\r\n## Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] copy = arr.clone();\r\n        Arrays.sort(copy);\r\n        int count = 0;\r\n        int sum1 = 0, sum2 = 0;\r\n        for(int i = 0; i < arr.length; i++) {\r\n            sum1 += arr[i];\r\n            sum2 += copy[i];\r\n            if(sum1 == sum2) {\r\n                count++;\r\n                sum1 = 0;\r\n                sum2 = 0;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```\r\n## TC\r\n- Time: O(nlogn)\r\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304922454","body":"## Code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null || k == 0) return head;\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode p = head;\r\n        int count = 1;\r\n        while(p.next != null) {\r\n            p = p.next;\r\n            count += 1;\r\n        }\r\n        if((k % count) == 0) return head;\r\n        ListNode slow = head, fast = head;\r\n        for(int i = 0; i < (k % count); i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        ListNode node = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n    return node;\r\n    }\r\n}\r\n/*\r\n[1,2,3,4,5]\r\n[4,5,1,2,3]\r\n*/\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1305969136","body":"## Code\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head.next;\r\n        ListNode others = head.next.next;\r\n        //swap the first two nodes\r\n        fast.next = slow;\r\n        //recursive\r\n        slow.next = swapPairs(others);\r\n        \r\n        return fast;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308007109","body":"## Thoughts\r\n和leetcode 108很像，也可以直接将list转化为array然后套用108的解法。\r\n## Code\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return build(head, null);\r\n    }\r\n    public TreeNode build(ListNode head, ListNode tail){\r\n        if(head == tail) return null;\r\n        ListNode slow = head, fast = head;\r\n        while(fast != tail && fast.next != tail){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = build(head, slow);\r\n        root.right = build(slow.next, tail);\r\n        \r\n        return root;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309196539","body":"## Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA;\r\n        ListNode b  = headB;\r\n        \r\n        while( a != b){\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        \r\n        return a;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310690399","body":"## Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n        while(fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(fast == slow) break;\r\n        }\r\n        slow = head;\r\n        if(fast == null || fast.next == null){\r\n            return null;\r\n        }\r\n        while(slow != fast) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312369145","body":"```java\r\nclass LRUCache {\r\n    int cap;\r\n    Map<Integer, Integer> cache;\r\n    public LRUCache(int capacity) {\r\n        cap = capacity;\r\n        cache = new LinkedHashMap<>();\r\n    }\r\n    \r\n    public int get(int key) {\r\n    /*\r\n    if key 存在:\r\n        返回节点值\r\n        把节点移到链表头部\r\n    else:\r\n        返回 -1\r\n    */ \r\n        if(cache.containsKey(key)){\r\n            makeRecently(key);\r\n            return cache.get(key);\r\n        }else return -1;\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n    /*\r\n    if key 存在:\r\n        更新节点值\r\n        把节点移到链表头部\r\n\r\n    else:\r\n        if 缓存满了:\r\n            移除最后一个节点\r\n            删除它在哈希表中的映射\r\n\r\n        新建一个节点\r\n        把节点加到链表头部\r\n        在哈希表中增加映射\r\n    */\r\n        if(cache.containsKey(key)){\r\n            cache.put(key, value);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        else {\r\n            if(cache.size() >= cap){\r\n                int recentKey = cache.keySet().iterator().next();\r\n                cache.remove(recentKey);\r\n            }\r\n            cache.put(key, value);\r\n        }\r\n    }\r\n    \r\n    public void makeRecently(int key) {\r\n        int val = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key, val);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312760528","body":"#Code\r\n```java\r\nclass Solution {\r\n    int curDepth = 0;\r\n    int maxDepth = 0;\r\n    \r\n    public int maxDepth(TreeNode root) {\r\n        traverse(root);\r\n        return maxDepth;\r\n    }\r\n    \r\n    private void traverse(TreeNode root) {\r\n        if (root == null) return;\r\n        curDepth++;\r\n        maxDepth = Math.max(maxDepth, curDepth);\r\n        traverse(root.left);\r\n        traverse(root.right);\r\n        curDepth--;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313218209","body":"## Code\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        else if (p == null || q == null) return false;\r\n        else if (p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314804536","body":"```java\r\nclass Solution {\r\n    private int ans;\r\n    public int sumNumbers(TreeNode root) {\r\n        dfs(root, 0);\r\n        return ans;\r\n    }\r\n    \r\n    public int dfs(TreeNode root, int n) {\r\n        if(root.left == null && root.right == null) {\r\n            ans += n * 10 + root.val;\r\n            return ans;\r\n        }\r\n        dfs(root.left, n * 10 + root.val);\r\n        dfs(root.right, n * 10 + root.val);\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316513626","body":"```java\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int res = 0;\r\n        Deque<TreeNode> queue = new ArrayDeque<>();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            res = queue.peek().val;\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = queue.poll();\r\n                if (cur.left != null) {\r\n                    queue.offer(cur.left);\r\n                }\r\n                if (cur.right != null) {\r\n                    queue.offer(cur.right);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318107182","body":"```java\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        StringBuilder sb = new StringBuilder();\r\n        serialize(root, sb);\r\n        return sb.toString();\r\n    }\r\n    \r\n    void serialize(TreeNode root, StringBuilder sb) {\r\n        if(root == null) {\r\n            sb.append(\"null\").append(\",\");\r\n            return;\r\n        }\r\n        sb.append(root.val).append(\",\");\r\n        serialize(root.left, sb);\r\n        serialize(root.right, sb);\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        LinkedList<String> nodes = new LinkedList<>();\r\n        for(String s : data.split(\",\")) {\r\n            nodes.add(s);\r\n        }\r\n        return deserialize(nodes);\r\n    }\r\n    \r\n    TreeNode deserialize(LinkedList<String> nodes) {\r\n        if(nodes.isEmpty()) return null;\r\n        String first = nodes.remove();\r\n        if(first.equals(\"null\")) return null;\r\n        TreeNode root = new TreeNode(Integer.parseInt(first));\r\n        root.left = deserialize(nodes);\r\n        root.right = deserialize(nodes);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319428379","body":"```java\r\nclass Solution {\r\n    class Node {\r\n        int row, col;\r\n        TreeNode node;\r\n        public Node(TreeNode node, int row, int col) {\r\n            this.node = node;\r\n            this.row = row;\r\n            this.col = col;\r\n        }\r\n    }\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        traverse(root, 0, 0);\r\n        Collections.sort(nodes, (Node a, Node b) -> {\r\n            if(a.col == b.col && a.row == b.row) return a.node.val - b.node.val;\r\n            if(a.col == b.col) return a.row - b.row;\r\n            return a.col - b.col;\r\n        });\r\n        \r\n        LinkedList<List<Integer>> ans = new LinkedList<>();\r\n        int preCol = Integer.MIN_VALUE;\r\n        for(int i = 0; i < nodes.size(); i++){\r\n            Node curNode = nodes.get(i);\r\n            if(curNode.col != preCol) {\r\n                ans.add(new LinkedList<>());\r\n                preCol = curNode.col;\r\n            }\r\n            ans.getLast().add(curNode.node.val);\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    ArrayList<Node> nodes = new ArrayList<>();\r\n    public void traverse(TreeNode root, int row, int col){\r\n        if(root == null) return;\r\n        nodes.add(new Node(root, row, col));\r\n        traverse(root.left, row+1, col-1);\r\n        traverse(root.right, row+1, col+1);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320811040","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for(int i = 0; i < nums.length; i++){\r\n            if(map.containsKey(target - nums[i])) return new int[]{ map.get(target - nums[i]), i};\r\n            map.put(nums[i], i);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321021930","body":"```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for(int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0)+1);\r\n        }\r\n        //build max heap\r\n        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o2.getValue() - o1.getValue());\r\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            queue.offer(entry);\r\n        }\r\n        int[] ans = new int[k];\r\n        int index = 0;\r\n        while(!queue.isEmpty() && index < k){\r\n            ans[index++] = queue.poll().getKey();\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321613154","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int ans = 0;\r\n        for (int[] p : points) {\r\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\r\n            for (int[] q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\r\n            }\r\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\r\n                int m = entry.getValue();\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323110155","body":"```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int[] map = new int[256];\r\n        Arrays.fill(map, -1);\r\n        int ans = 0;\r\n        int pre = 0;\r\n        for(int i = 0; i < s.length(); i++){\r\n            char c = s.charAt(i);\r\n            pre = Math.min(pre + 1, i - map[c]);\r\n            ans = Math.max(ans, pre);\r\n            map[c] = i;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324206879","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int totalLen = s.length();\r\n        int len = words[0].length();\r\n        int n = words.length;\r\n        if (n*totalLen == 0){\r\n            return result;\r\n        }\r\n        HashMap<String,Integer> wordMap = new HashMap<>();\r\n        for (String word:words) {\r\n            int value = wordMap.getOrDefault(word, 0);\r\n            wordMap.put(word,value+1);\r\n        }\r\n        \r\n        for (int i = 0; i <totalLen-n*len+1; i++) {\r\n          \r\n            Map<String,Integer> hasWords = new HashMap<>();\r\n            int num = 0;\r\n            while (num < n){\r\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\r\n                if (wordMap.containsKey(currWord)){\r\n                    int value = hasWords.getOrDefault(currWord,0);\r\n                    hasWords.put(currWord,value+1);\r\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n                num++;\r\n            }\r\n            if (num == n){\r\n                result.add(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326029332","body":"```java\r\n\r\nclass Solution {\r\n    public int subarraysDivByK(int[] nums, int k) {\r\n        int n = nums.length;\r\n        int[] s = new int[n + 1];\r\n        for(int i = 1; i <= n; i++){\r\n            s[i] = s[i - 1] + nums[i - 1];\r\n        }\r\n        Map<Integer, Integer> cnt = new HashMap<>();\r\n        cnt.put(0, 1);\r\n        int res = 0;\r\n        for(int i = 1; i <= n; i++){\r\n            int r = (s[i] % k  + k) % k;\r\n            res += cnt.getOrDefault(r, 0);\r\n            cnt.put(r, cnt.getOrDefault(r, 0) + 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327175561","body":"```java\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        return slow;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327736088","body":"```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        int j = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (nums[i] != nums[j]) {\r\n                nums[++j] = nums[i];\r\n            }\r\n        }\r\n        return j + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328211738","body":"```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int left = 0;\r\n        int right = nums.length - 1;\r\n        while (left < right - 1) {\r\n            int mid = left + (right - left) / 2;\r\n            if (nums[mid] == target) {\r\n                return mid;\r\n            } else if (nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid;\r\n            }\r\n        }\r\n        if (nums[left] >= target) {\r\n            return left;\r\n        }\r\n        if (nums[right] >= target) {\r\n            return right;\r\n        }\r\n        return nums.length;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328693590","body":"```java\r\n\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        if(nums == null || k < 1 || nums.length < k){\r\n            return null;\r\n        }\r\n\r\n        LinkedList<Integer> qmax = new LinkedList<>();\r\n        int[] result = new int[nums.length - k + 1];\r\n\r\n        int index = 0;\r\n\r\n        for(int R = 0; R < nums.length; R++){\r\n            while (!qmax.isEmpty() && nums[qmax.peekLast()] <= nums[R]){\r\n                qmax.pollLast();\r\n            }\r\n            qmax.addLast(R);\r\n            if(qmax.peekFirst() == R - k){\r\n                qmax.pollFirst();\r\n            }\r\n            if(R >= k - 1){\r\n                result[index++] = nums[qmax.peekFirst()];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329829345","body":"```java\r\nclass Solution {\r\n    public int findJudge(int N, int[][] trust) {\r\n        if (trust.length < N - 1) \r\n            return -1;\r\n        \r\n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\r\n        \r\n        for (int[] t : trust) {\r\n            trustScores[t[1]]++;\r\n            trustScores[t[0]]--;\r\n        }\r\n        \r\n        for (int i = 1; i <= N; i++) {\r\n            if (trustScores[i] == N - 1)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1330914681","body":"```java\r\nclass Solution {\r\n\r\n    private boolean ok = true;\r\n    private boolean[] color;\r\n    private boolean[] visited;\r\n\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        // 图节点编号从 1 开始\r\n        color = new boolean[n + 1];\r\n        visited = new boolean[n + 1];\r\n        // 转化成邻接表表示图结构\r\n        List<Integer>[] graph = buildGraph(n, dislikes);\r\n\r\n        for (int v = 1; v <= n; v++) {\r\n            if (!visited[v]) {\r\n                traverse(graph, v);\r\n            }\r\n        }\r\n        return ok;\r\n    }\r\n\r\n    // 建图函数\r\n    private List<Integer>[] buildGraph(int n, int[][] dislikes) {\r\n        // 图节点编号为 1...n\r\n        List<Integer>[] graph = new LinkedList[n + 1];\r\n        for (int i = 1; i <= n; i++) {\r\n            graph[i] = new LinkedList<>();\r\n        }\r\n        for (int[] edge : dislikes) {\r\n            int v = edge[1];\r\n            int w = edge[0];\r\n            // 「无向图」相当于「双向图」\r\n            // v -> w\r\n            graph[v].add(w);\r\n            // w -> v\r\n            graph[w].add(v);\r\n        }\r\n        return graph;\r\n    }\r\n\r\n    // 和之前判定二分图的 traverse 函数完全相同\r\n    private void traverse(List<Integer>[] graph, int v) {\r\n        if (!ok) return;\r\n        visited[v] = true;\r\n        for (int w : graph[v]) {\r\n            if (!visited[w]) {\r\n                color[w] = !color[v];\r\n                traverse(graph, w);\r\n            } else {\r\n                if (color[w] == color[v]) {\r\n                    ok = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333067339","body":"## Code\r\n```java\r\npublic int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        List<List<Integer>> groupItem = new ArrayList<>();//项目分组\r\n        for(int i = 0;i < n + m;i++){//初始化小组\r\n            groupItem.add(new ArrayList<>());\r\n        }\r\n  \t\t\tint gId = m;//新的组号从m开始\r\n        for(int i = 0;i < group.length;i++){\r\n            if(group[i] == -1)group[i] = gId++;//没有id的加上组id\r\n            groupItem.get(group[i]).add(i);//同一组的放在一起\r\n        }\r\n        List<List<Integer>> graphInGroup = new ArrayList<>();//组内拓扑关系\r\n        List<List<Integer>> graphOutGroup = new ArrayList<>();//组间拓扑关系\r\n        for(int i = 0;i < n + m;i++){//初始化拓扑关系\r\n            graphOutGroup.add(new ArrayList<>());\r\n            if(i >= n)continue;\r\n            graphInGroup.add(new ArrayList<>());\r\n        }\r\n        List<Integer> groupId = new ArrayList<>();//所有组id\r\n        for(int i = 0;i < n + m;i++){\r\n            groupId.add(i);\r\n        }\r\n  \t\t\t// 需要拓扑排序 所以结点的入度必不可少 两个数组分别维护不同结点的入度\r\n        int[] degInGroup = new int[n];//组内 结点入度 （组内项目入度）\r\n        int[] degOutGroup = new int[n + m];//组间 结点入度（小组入度）\r\n\r\n        for(int i = 0;i < beforeItems.size();i++){//遍历关系\r\n            int curGroupId = group[i];//当前项目i所属的小组id\r\n            List<Integer> beforeItem = beforeItems.get(i);\r\n            for(Integer item : beforeItem){\r\n                if(group[item] == curGroupId){//同一组 修改组内拓扑\r\n                    degInGroup[i]++;// 组内结点的入度+1\r\n                    graphInGroup.get(item).add(i);//item 在 i之前\r\n                }else{\r\n                    degOutGroup[curGroupId]++;// 小组间的结点入度 + 1\r\n                    graphOutGroup.get(group[item]).add(curGroupId);// group[item] 小组 在 curGroupId 之前\r\n                }\r\n            }\r\n        }\r\n  \t\t\t//组间拓扑排序，也就是小组之间的拓扑排序，需要的参数 小组结点的入度degOutGroup，所有的小组groupId，组间的拓扑关系图graphOutGroup\r\n        List<Integer> outGroupTopSort = topSort(degOutGroup,groupId,graphOutGroup);\r\n        if(outGroupTopSort.size() == 0)return new int[0];//无法拓扑排序 返回\r\n\r\n        int[] res = new int[n];\r\n        int index = 0;\r\n        for(Integer gid : outGroupTopSort){//遍历排序后的小组id\r\n            List<Integer> items = groupItem.get(gid);//根据小组id 拿到这一小组中的所有成员\r\n            if(items.size() == 0)continue;\r\n          \t//组内拓扑排序，需要的参数 组内结点的入度degInGroup，组内的所有的结点groupItem.get(gid)，组内的拓扑关系图graphInGroup\r\n            List<Integer> inGourpTopSort = topSort(degInGroup,groupItem.get(gid),graphInGroup);\r\n            if(inGourpTopSort.size() == 0)return new int[0];//无法拓扑排序 返回\r\n            for(int item : inGourpTopSort){//排序后，依次的放入答案集合当中\r\n                res[index++] = item;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public List<Integer> topSort(int[] deg, List<Integer> items,List<List<Integer>> graph){\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for(Integer item:items){\r\n            if(deg[item] == 0)queue.offer(item);\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        while(!queue.isEmpty()){\r\n            int cur = queue.poll();\r\n            res.add(cur);\r\n            for(int neighbor: graph.get(cur)){\r\n                if(--deg[neighbor] == 0){\r\n                    queue.offer(neighbor);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : new ArrayList<>();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334868235","body":"```java\r\n\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0,y=0;\r\n        char[] c = moves.toCharArray();\r\n        for(char each:c){\r\n            if(each-'U' == 0){\r\n                y--;\r\n            }else if(each - 'D' == 0){\r\n                y++;\r\n            }else if(each - 'L' == 0){\r\n                x--;\r\n            }else if(each - 'R' == 0){\r\n                x++;\r\n            }\r\n        }\r\n\r\n        if(x == 0 && y ==0){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336039582","body":"```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] _tasks) {\r\n        int n = _tasks.length;\r\n        // 编号，进入时间，耗时\r\n        int[][] tasks = new int[n][3];\r\n        for (int i = 0; i < n; i++) {\r\n            tasks[i] = new int[]{i, _tasks[i][0], _tasks[i][1]};\r\n        }\r\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\r\n        // 耗时，编号\r\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\r\n            if (a[0] != b[0]) return a[0] - b[0];\r\n            return a[1] - b[1];\r\n        });\r\n        int[] ans = new int[n];\r\n        for (int i = 0, cnt = 0, time = 1; cnt < n;) {\r\n            while (i < n && tasks[i][1] <= time) {\r\n                sortTasks.offer(new int[]{tasks[i][2], tasks[i][0]});\r\n                i++;\r\n            }\r\n            if (sortTasks.isEmpty()) {\r\n                time = tasks[i][1];\r\n                continue;\r\n            }\r\n            int[] cur = sortTasks.poll();\r\n            ans[cnt++] = cur[1];\r\n            time += cur[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297858805","body":"### 思路\n&ensp;&ensp;&ensp;&ensp;模拟竖式的加法, 得到每个数组的最低位, 从最低位开始加\n### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> a, b;\n        for (int i = num.size() - 1; i >= 0; i--) a.push_back(num[i]);\n        while (k != 0) {\n            b.push_back(k % 10);\n            k /= 10;\n        }\n        vector<int> temp;\n        int t = 0;\n        for (int i = 0; i < a.size() || i < b.size(); i++) {\n            if (i < a.size()) t += a[i];\n            if (i < b.size()) t += b[i];\n            temp.push_back(t % 10);\n            t /= 10;\n        }\n        if (t) temp.push_back(1);\n        vector<int> ans;\n        for (int i = temp.size() - 1; i >= 0; i--) ans.push_back(temp[i]);\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299666978","body":"### [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n### 思路 1 两次遍历\r\n\r\n* 第一次遍历记录满足条件字符下标 `k` : \r\n  - 1.  满足条件, 更新左边界 `k`\r\n  - 2.  不满足条件 , 直接填入 `k` (左边满足条件的下标 or 左边不存在满足的下标)  \r\n\r\n  此时 `k` 停留在最后一个满足条件的位置 (题目数据保证 `c` 在 `s` 中至少出现一次)\r\n\r\n* 第二次遍历时记录右边满足条件的下标 :\r\n  - 1. 满足条件, 更新右边界 `k`\r\n  - 2. 不满足条件, 填入 ___当前下标 `i` 和左边界的距离 `i - ans[i]`___  和  ___右边界 `k` 的距离 `i - k`___ 的最小值\r\n    - 当 `k` 被更新后, `i`继续向左移动 , 会造成 `i - k` 为负值, 所以需要加上绝对值\r\n    - 若使用 `k - i` , 当 `k` 没有停留在 `s.size() - 1` , 依旧有可能 `k - i < 0`, 故仍需要绝对值\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n, -1);\r\n        int k = -n;\r\n        // get the left distance\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) k = i;\r\n            ans[i] = k;\r\n        }\r\n        // get the right distance then compare with left distance \r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) k = i;\r\n            ans[i] = min(i - ans[i], abs(i - k));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(2N) -> O(N)\r\n- 空间复杂度：O(N)\r\n\r\n-------\r\n\r\n### 思路 2 一次遍历\r\n\r\n* 对思路 1 的优化\r\n  - `l` 为左边界 , `r` 为右边界\r\n  - `i` 从头遍历数组 , `j` 从尾遍历数组\r\n  - 遇到满足条件的情况分别更新 `l` , `r` \r\n  - 若 `i >= l` 说明当前下标左边有符合条件的 `c` ; 同理 , `j <= r` 则右边有\r\n  - 取最小值min\r\n  - 由于 `i` , `j` 指针相遇后仍继续移动 , 可以做到不遗漏\r\n\r\n\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(), INT_MAX);\r\n        int l = s.size(), r = -1, n = s.size();\r\n        for (int i = 0; i < s.size(); i++) {\r\n            int j = n - 1 - i;\r\n            if (s[i] == c) l = i;\r\n            if (s[j] == c) r = j;\r\n            if (i >= l) ans[i] = min(ans[i], i - l);\r\n            if (j <= r) ans[j] = min(ans[j], r - j);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301572039","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\n### 思路\n模拟题, 用 vector 模拟栈, `size` 表示当前栈大小  \n需要注意的是, `increment(int k, int val)` 的 `k` 可能超过 `size`\n### 代码 (cpp)\n```cpp\nclass CustomStack {\n\npublic:\n    int size = 0, max = 0;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (size < max) {\n            stack.push_back(x);\n            size++;\n        }\n    }\n    \n    int pop() {\n        if (size == 0) return -1;\n        size = size - 1;\n        int ret = stack[size];\n        stack.pop_back();\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; i++) {\n            stack[i] += val;\n        }\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302928618","body":"### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)\n### 思路 1: 双栈\n* 使用 `num` 栈记录重复次数 ; `str` 栈记录要重复的字符 ; \n* `n` 为当前数字, `ans` 为解码后的字符\n  - 当 `c >= '0' && c <= '9'` 时 , 更新数字 `n`\n  - 当 `c == 'a' && c <= 'z'` 时, 更新 `ans`\n  - 当 `c == '['` 时, 为了保留当前信息, 处理`[`后信息, 故将 `num` 压入当前数字, `n` 置为 0 ; `str` 压入当前字符, `ans = \"\"`\n  - 当 `c == ']'` 时, `ans` 已经为最近的`[`和当前`]`内的字符, 得到重复次数 `t = num.top()`, \n  将当前字符按照 `t` 添加到外层字符 `str.top()` 后, 完成了部分解码, 更新 `ans`, 将栈内元素弹出\n  \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> num;\n        int n = 0;\n        stack<string> str;\n        string ans = \"\";\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                num.push(n);\n                n = 0;\n                str.push(ans);\n                ans = \"\";\n            } else if (c == ']') {\n                int t = num.top();\n                num.pop();\n                for (int i = 0; i < t; i++) {\n                    str.top() += ans;\n                }\n                ans = str.top();\n                str.pop();\n            } else {\n                ans += c;\n            }\n        }\n        return ans;\n    }\n\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n---\n\n### 思路 2: 栈 + 递归\n\n* 仅遇到`[`和`]`时和思路 1 不同  \n    - 当 `c == '['` 时, 递归处理后续字符, 得到返回值 `sub`, 按次数添加`sub`, `n`置为0\n    - 当 `c == ']'` 时, 说明此级别的 `'[]'`内字符已处理完\n\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string helper(stack<char> &stack) {\n        int n = 0;\n        string ret = \"\";\n        while (!stack.empty()) {\n            char c = stack.top();\n            stack.pop();\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                string sub = helper(stack);\n                for (int i = 0; i < n; i++) {\n                    ret += sub;\n                }\n                n = 0;\n            } else if (c == ']'){\n                break;\n            } else {\n                ret += c;\n            }\n        }\n        return ret;\n    }\n    \n    string decodeString(string s) {\n        stack<char> stack;\n        for (int i = s.size() - 1; i >= 0; i--)\n            stack.push(s[i]);\n        string ret = helper(stack);\n        return ret;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304377408","body":"### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/submissions/)\n### 思路\n使用两个栈模拟队列\n### 代码 (cpp)\n```cpp\nclass MyQueue {\npublic:\n    stack<int> input;\n    stack<int> output;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        input.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n            output.pop();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n            output.pop();\n        }\n        return ret;\n    }\n    \n    int peek() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n        }\n        return ret;\n    }\n    \n    bool empty() {\n        return input.empty() && output.empty();\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304734017","body":"### [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n### 思路\n先将原数组复制且排序得到`clone`, 比较`arr`和`clone`, 如果在`[0,i]`范围内, 出现的数字频率一致, 那么就有1种分法\n* 使用哈希表对`arr[i]`进行计数:   \n    - 处理`arr[i]`时, 对`map[arr[i]]`进行计数加一\n    - 处理`clone[i]`时, 对`map[clone[i]]`进行计数减一\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // 已经排序的数组\n        vector<int> clone = arr;\n        sort(clone.begin(), clone.end());\n        \n        int ans = 0, window = 0;\n        // 使用哈希表进行计数\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < arr.size(); i++) {\n            map[arr[i]]++;\n            if (map[arr[i]] == 0) window--;\n            else if (map[arr[i]] == 1) window++;\n\n            map[clone[i]]--;\n            if (map[clone[i]] == 0) window--;\n            else if (map[clone[i]] == -1) window++;\n\n            if (window == 0) ans++;\n        }\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304996119","body":"### [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\n### 思路\n* 遍历两次\n  - 第一次遍历得到链表长度`size`并构成环形链表\n  - 第二次得到`size - k - 1`个结点, 在此处将链表断开即可\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == NULL || head->next == NULL) {\n            return head;\n        }\n        \n        int size = 1;\n        ListNode* cur = head;\n        while (cur->next != NULL) {\n            cur = cur->next;\n            size++;\n        }\n        cur->next = head;\n\n        k %= size;\n        for (int i = size - k - 1; i > 0; i--) {\n            head = head->next;\n        }\n\n        cur = head->next;\n        head->next = NULL;\n\n        return cur;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306710782","body":"### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n### 思路 1: 迭代\n#### 添加傀儡节点`dummy`后不用考虑边界问题\n* 两两反转节点需要四个指针在手里\n  1. a : 局部头节点 (用于连接反转后的头)\n  2. b : 反转的第一个节点\n  3. c : 反转的第二个节点\n  4. d : 局部尾节点 (被反转后的尾连接)\n* 步骤 :\n  1. a 指向 c ( c 为反转后的头) \n  2. c 指向 b (反转)\n  3. b 指向 d ( b 为反转后的尾)\n  4. 更新 a 为 b ( 下一步的局部头节点) ; 更新 b 为 `a->next`\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        ListNode *a = dummy, *b = head;\n        while (b != nullptr && b->next != nullptr) {\n            ListNode* c = b->next;\n            ListNode* d = c->next;\n            a->next = c;\n            c->next = b;\n            b->next = d;\n            a = b;\n            b = a->next;\n        }\n\n        return dummy->next;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n-----\n### 思路 2: 递归\n* 递归三部曲:\n  1. 终止条件 : 当前节点或下一节点为空\n  2. 返回值 : 反转后的部分头节点\n  3. 本层处理问题 : 两两反转节点\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        \n        return next;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308969710","body":"### [109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\n### 思路 双指针\n由于链表有序, 只要找到了中间节点, 就得到了二叉搜索树的根节点, 如此再递归处理左右的链表  \n* 递归三部曲:\n    1. 终止条件 : 当前节点或下一节点为空\n    2. 返回值 : 构造出的树的根节点\n    3. 本层处理问题 : 找到当前要处理的链表的中间节点, 链表左边为树的左分支, 右边为右分支  \n\n**注意事项 :** 一定要记得将找到的中间节点和原链表断开\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        TreeNode *root;\n        if (head == nullptr) return nullptr;\n        else if (head->next == nullptr) {\n            root = new TreeNode(head->val);\n            return root;\n        }\n\n        ListNode *fast = head, *slow = head, *pre = head;\n        // 让 slow 指向中间节点\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        while (pre->next != slow) pre = pre->next;\n        root = new TreeNode(slow->val);\n        pre->next = nullptr; // 从中间断开链表, 防止递归时链表长度不变\n        // 递归处理\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309019670","body":"### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n### 思路 双指针\n每次移动步长为 1, 只要当一条链表走到尾就从另一条的链表头开始走  \n如此, 两指针行走的路程相同, 在速度相同的情况下, 两指针一定会相遇\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) return nullptr;\n        ListNode *a = headA, *b = headB;\n        while (a != b) {\n            a = a == nullptr ? headB : a->next;\n            b = b == nullptr ? headA : b->next;\n        }\n        return a;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311242253","body":"### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n### 思路 快慢指针\n令快指针`fast`步长为2, 慢指针`slow`步长为1  \n假设链表有环, 记链表头到开始入环的第一个节点之前的节点路程为`x`, 整个环路长度为`cycle`, 快慢指针相遇点 到 入环的第一个节点的路程为`y`  \n由于`fast`速度是`slow`两倍, 就有式子`2 * (x + cycle -y) = x + n * cycle - y`  \n化简得`x = (n - 2) * cycle + y` 由于`cycle`是环路长度, 可以忽略, 得到`x = y`  \n即相遇后慢指针`slow`从头出发, 快指针`fast`在相遇点出发, 步长都为1, 会再次在入环点相遇\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n            if (fast == slow) break;\n        }\n\n        if (fast == nullptr || fast->next == nullptr) return nullptr;\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312353230","body":"### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/description/)\n### 思路\n用`list`来维护关键字的新旧, `map`来记录关键字的键值对  \n#### 小技巧: 由于put时也会对元素新旧产生影响, 可以在put时调用get\n### 代码 (Java)  \n```java\nclass LRUCache {\n\n    private HashMap<Integer, Integer> map;\n    private ArrayList<Integer> list;\n    private int max;\n\n    public LRUCache(int capacity) {\n        max = capacity;\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            for (int i = 0; i < list.size(); i++) {\n                if (list.get(i) == key) {\n                    list.remove(i);\n                    list.add(key);\n                    break;\n                }\n            }\n            return map.get(key);\n        }\n        else return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (this.get(key) == -1) {\n            if (list.size() == max) {\n                int rm = list.get(0);\n                list.remove(0);\n                map.remove(rm);\n            }\n            list.add(key);\n        }\n        \n        map.put(key, value);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312634905","body":"### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n### 思路\nDFS\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313638573","body":"### [100. 相同的树](https://leetcode.cn/problems/same-tree/)\n### 思路\nDFS\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        else if (p == nullptr || q == nullptr) return false;\n        else if (p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(min(m,n)) (m, n为树的节点数)\n- 空间复杂度：O(min(m,n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314032294","body":"### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\n### 思路 DFS\n* 递归三部曲:\n    1. 终止条件 : 已经到达叶子节点 (左右子树为空)\n    2. 返回值 : 本题不用返回, 全局变量`ans`加上当前`cur`即可\n    3. 本层处理问题 : 更新`cur`(cur * 10 + 左/右子树的值)\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int ans;\n    void help(TreeNode *root, int cur) {\n        if (root->left == nullptr && root->right == nullptr) {\n            ans += cur;\n        } else {\n            if (root->left != nullptr)\n                help(root->left, cur * 10 + root->left->val);\n            if (root->right != nullptr)\n                help(root->right, cur * 10 + root->right->val);\n        }\n\n    }\n    int sumNumbers(TreeNode* root) {\n        if (root == nullptr) return 0;\n\n        help(root, root->val);\n\n        return ans;\n    }\n        \n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316281368","body":"### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n### 思路\n层序遍历, 返回最后一层的第一个元素即可\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> queue;\n        vector<int> list;\n        queue.push(root);\n        while (!queue.empty()) {\n            list.clear();\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                auto cur = queue.front();\n                queue.pop();\n                list.push_back(cur->val);\n                if (cur->left) queue.push(cur->left);\n                if (cur->right) queue.push(cur->right);\n            }\n        }\n        return list[0];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318540980","body":"### [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)\n### 思路 DFS\n* 序列化: 通过前序遍历构造字符串  \n    - 节点为空, 追加 `\"null,\"`\n    - 节点不为空, 追加 `to_string(root->val) + \",\"` // (`\",\"`别忘)  \n* 反序列化: 由于序列化是前序遍历, 反序列化也要前序遍历  \n通过`stringstream`来过滤序列化的分隔符, 使用队列`queue`来存取值  \n#### 本次增长的知识:\n- 熟悉cpp中`stringstream`的使用\n- 字符串和整型之间的转化通过方法`to_string()`和`stoi()`\n### 代码 (cpp)\n```cpp\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (!root) return \"null,\";\n        string ret = to_string(root->val) + \",\";\n        ret += serialize(root->left);\n        ret += serialize(root->right);\n        return ret;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        stringstream ss(data);\n        string temp;\n        queue<string> queue;\n        while (getline(ss, temp, ',')) {\n            queue.push(temp);\n        }\n        return pre(queue);\n    }\n\n    TreeNode* pre(queue<string> &queue) {\n        string val = queue.front();\n        queue.pop();\n        if (val == \"null\") return nullptr;\n\n        auto root = new TreeNode(stoi(val));\n        root->left = pre(queue);\n        root->right = pre(queue);\n        return root;\n    }\n\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320208785","body":"### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\n### 思路 \nDFS\n#### 本次增长的知识:  \n`multiset`的使用, `pair`的使用\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    typedef map<int, multiset<pair<int, int>>> MAP;\n\n    void dfs(TreeNode* root, int x, int y, MAP &mp) {\n        if (!root) return ;\n        mp[y].insert({x, root->val});\n        dfs(root->left, x + 1, y - 1, mp);\n        dfs(root->right, x + 1, y + 1, mp);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        MAP mp;\n        dfs(root, 0, 0, mp);\n        vector<vector<int>> ans;\n        for (auto &[a, b] : mp) {\n            vector<int> temp;\n            for (auto &e : b) {\n                temp.push_back(e.second);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320910037","body":"### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n### 思路\nhash表, 键值对中键为`nums[i]`, 值为`i`, 如果`target - nums[i]`存在就返回 \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            auto iter = mp.find(target - nums[i]);\n            if (iter != mp.end()) {\n                return {iter->second, i};\n            }\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321162148","body":"### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n### 思路\n1. 用hashmap记录每个数出现的次数  \n2. 创建大小为k的小根堆, 遍历hashmap, 如果`mp[key]` 大于堆顶元素, 则弹出\n#### 需要的知识:\n小根堆 + 哈希表\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        for (int elem : nums) mp[elem]++;\n\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        for (auto &[a, b] : mp) {\n            if (q.size() < k) {\n                q.push(make_pair(b, a));\n            } else {\n                if (b > q.top().first) {\n                    q.pop();\n                    q.push(make_pair(b, a));\n                }\n            }\n        }\n\n        vector<int> ans;\n        while (q.size()) {\n            ans.push_back(q.top().second);\n            q.pop();\n        }\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlongk)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322250501","body":"### [447. 回旋镖的数量](https://leetcode.cn/problems/number-of-boomerangs/)\n### 思路\n题目只要求回旋镖的数量, 其实就是求三元组`(i, j, k)`中, 与`i`距离相等的`(j, k)`组合个数为多少  \n通过hashmap, 求出其他点和当前点的距离, 以`{distance, count}`存储  \n因为排列个数为 A(n, 2) ,所以`ans += cnt * (cnt - 1);`\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        for (int i = 0; i < points.size(); i++) {\n            unordered_map<int, int> mp;\n            for (int j = 0; j < points.size(); j++) {\n                if (j == i) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                mp[dist]++;\n            }\n            for (auto [dist, cnt] : mp) {\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323863438","body":"### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n### 思路 滑动窗口\n用hashmap记录字符出现的次数  \n右指针不断移动, 如果右指针出现重复字符, 左指针移动, 减小窗口并减少对应字符出现次数\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        unordered_map<char, int> mp;\n        for (int l = 0, r = 0; r < s.size(); r++) {\n            char right = s[r];\n            mp[right]++;\n            char left = s[l];\n            while (mp[right] > 1) {\n                mp[left]--;\n                left = s[++l];\n            }\n            ans = max(ans, r - l + 1);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325298086","body":"### [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)\n### 思路\n滑动窗口 + 哈希表\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        unordered_map<string, int> search;\n        for (auto &word : words) ++search[word];\n        int n = s.size(), m = words.size(), len = words[0].size();\n        for (int i = 0, j = 0; i < n - m * len + 1; ++i) {\n            unordered_map<string, int> sub; \n            for (j = 0; j < m; ++j) {\n                auto word = s.substr(i + j * len, len);\n                if (!search.count(word)) break; \n                if (++sub[word] > search[word]) break;\n            }\n            if (j == m) res.push_back(i);\n        }\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326628158","body":"### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)\n### 思路\n这一题使用前缀和暴力会超时, 故考虑更好的方法: 前缀和 + 同余定理\n同余定理 : 如果两个数的差能被K整除，就说明这两个数 mod K得到的结果相同\n如果有n个数 mod K 的余数相同, 那么有C(n, 2)个数可以被 K 整除\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int ans = 0, sum = 0, n = nums.size();\n        unordered_map<int, int> mp;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            int mod = sum >= 0 ? sum % k : (k - (-sum) % k) % k;\n            mp[mod]++;\n        }\n        \n        for (auto &[k, v] : mp) \n            if (!k) ans += v;\n            else ans += v * (v - 1) / 2;\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327612231","body":"### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)\n### 思路\n快慢指针\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        auto fast = head, slow = head;\n        int step = 0;\n        while (fast) {\n            if (step % 2 == 1) slow = slow->next;\n            fast = fast->next;\n            step++;\n        }\n        return slow;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328049704","body":"### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)\n### 思路\n双指针  \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        if (nums.size() == 1) return 1;\n        int len = nums.size();\n        int i = 0, j = 1, n = nums.size();\n        while (j < n) {\n            if (nums[i] == nums[j]) {\n                while (j < n && nums[j] == nums[i]) j++;\n                len = len - j + i + 1;\n            }\n            if (j < n) nums[++i] = nums[j++];\n        }\n        return i + 1;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328237383","body":"### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)\n### 思路\n二分\n### 代码 (cpp)\n模板1\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= target) r = mid;\n            else l = mid + 1;\n        }\n        return nums[l] >= target ? l : l + 1;\n    }\n};\n```\n模板2\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r + 1) >> 1;\n            if (nums[mid] <= target) l = mid;\n            else r = mid - 1;\n        }\n        return nums[l] >= target ? l : l + 1;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329331895","body":"### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n### 思路\n维护一个单调队列, 每次滑动窗口时添加队头元素\n### 代码 (cpp)\n```cpp\nclass Solution {\nprivate:\n    class MyQueue {\n    public:\n        deque<int> q; \n        void pop(int value) {\n            if (!q.empty() && value == q.front()) {\n                q.pop_front();\n            }\n        }\n       \n        void push(int value) {\n            while (!q.empty() && value > q.back()) {\n                q.pop_back();\n            }\n            q.push_back(value);\n\n        }\n        \n        int front() {\n            return q.front();\n        }\n    };\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        MyQueue q;\n        vector<int> result;\n        for (int i = 0; i < k; i++) {\n            q.push(nums[i]);\n        }\n        result.push_back(q.front()); \n        for (int i = k; i < nums.size(); i++) {\n            q.pop(nums[i - k]); \n            q.push(nums[i]); \n            result.push_back(q.front());\n        }\n        return result;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330467524","body":"### [997. 找到小镇的法官](https://leetcode.cn/problems/find-the-town-judge/description/)\n### 思路\n考点为图, 成员为出度, 被相信的人为入度, 寻找入度为`n - 1`的人, 即为法官\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int a[1001];\n    int findJudge(int n, vector<vector<int>>& trust) {\n        for (vector<int> t : trust) {\n            a[t[0]]--;\n            a[t[1]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (a[i] == n - 1) return i;\n        }\n        return -1;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332386307","body":"### [886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/description/)\r\n### 思路\r\n#### 方法1 : 反向点 + 并查集  \r\n- 反向点的建立: 对于集合`A`中每个点`x`, 建立反向点`x + n`, 如此反向点在另一集合`B`中\r\n- 每次取`dislikes[i]`中点`(a,b)`,将`(a, b + n)`和`(b, a + n)`联通\r\n- 如果`A`中的点`(a,b)`联通, 必然是通过反向点的连接,无法将所有点分为两类\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int p[4010];\r\n    int find(int x) {\r\n        if (p[x] != x) p[x] = find(p[x]);\r\n        return p[x];\r\n    }\r\n\r\n    void union_(int i, int j) {\r\n        p[find(i)] = p[find(j)];\r\n    }\r\n\r\n    bool connected(int i, int j) {\r\n        return find(i) == find(j);\r\n    }\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        for (int i = 1; i <= 2 * n; i++) p[i] = i;\r\n        for (vector<int> dis : dislikes) {\r\n            int a = dis[0], b = dis[1];\r\n            if (connected(a, b)) return false;\r\n            union_(a, b + n);\r\n            union_(b, a + n);\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(n + m) (m为dislikes的长度)\r\n- 空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333969295","body":"### [1203. 项目管理](https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/)\n#### 思路\n拓扑排序\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> topSort(vector<int> &deg, vector<vector<int>> &graph, vector<int> &items) {\n        queue<int> q;\n        for (auto item : items) {\n            if (deg[item] == 0) q.push(item);\n        }\n        vector<int> ret;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            ret.push_back(u);\n            for (auto &v : graph[u]) {\n                if (--deg[v] == 0) q.push(v);\n            }\n        }\n        return ret.size() == items.size() ? ret : vector<int> {};\n    }\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n\n        vector<int> id;\n        for (int i = 0; i < n + m; i++) {\n            id.push_back(i);\n        }\n\n        int leftId = m;\n        for (int i = 0; i < n; i++) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].push_back(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].push_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].push_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            //按组的topo序逐个进行内部排序\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.push_back(item);\n            }\n        }\n        return ans;\n\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(m + n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335408682","body":"### [657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/description/)\n#### 思路\n模拟题\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (char c : moves) {\n            if (c == 'U') y += 1;\n            else if (c == 'D') y -= 1;\n            else if (c == 'L') x -= 1;\n            else if (c == 'R') x += 1;\n        }\n        return x == 0 && y == 0;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297896968","body":"### 思路\n第一眼感觉跟第二题很像，从最后一位开始加，记录进位状态，数组先结束，检查k是否有值；k结束，检查数组是否还有值；\n后来发现进位状态可以合并回 k，详见代码。\n\n### 代码\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int x = num[i] + k % 10;\n            ans.add(x % 10);\n            k /= 10;\n            k += x / 10;\n        }\n        for (; k > 0; k /= 10) {\n            ans.add(k % 10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299396343","body":"### 思路\r\n\r\n根据题意，两次遍历；第一次从左往右，找到每个位置左侧最近的；第二次从右往左，找到右侧最近的；\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] cs = s.toCharArray();\r\n        int[] ans = new int[cs.length];\r\n        Arrays.fill(ans, cs.length + 1);\r\n        int j = -1;\r\n        for(int i = 0; i < cs.length; i++){\r\n            if(cs[i] == c){\r\n                j = i;\r\n            }\r\n            if(j != -1){\r\n                ans[i] = i - j;\r\n            }\r\n        }\r\n        j = -1;\r\n        for(int i = cs.length - 1; i >= 0; i--){\r\n            if(cs[i] == c){\r\n                j = i;\r\n            }\r\n            if(j != -1){\r\n                ans[i] = Math.min(ans[i], j - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 时空分析\r\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301801372","body":"### 思路\n直接模拟 \n\n### 代码\n\n```java\nclass CustomStack {\n    private int[] stack;\n    private int size;\n    private int cur;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = maxSize;\n        cur = -1;\n    }\n   \n    public void push(int x) {\n        if(cur + 1 == size){\n            return;\n        }\n        stack[++cur] = x;\n    }\n    \n    public int pop() {\n        if(cur < 0){\n            return -1;\n        }\n        return stack[cur--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= cur; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度\n时间复杂度：O(1) inc O(k)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303446549","body":"## 思路\n递归，返回内部字符串 和 计算到了哪个位置；每次遇到[ 就进入下层，遇到 ] 就发返回；\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        char[] str = s.toCharArray();\n        return process(str, 0).res;\n    }\n\n    private Info process(char[] str, int index){\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        while(index < str.length){\n            char c = str[index];\n            if(c >= '0' && c <= '9'){\n                count = count * 10 + (c - '0');\n            }else if(c == '['){\n                Info info = process(str, index + 1);\n                while(count > 0){\n                    sb.append(info.res);\n                    count--;\n                }\n                index = info.index;\n            }else if(c == ']'){\n                return new Info(sb.toString(), index);\n            }else {\n                sb.append(c);\n            }\n            index++;\n        }\n        return new Info(sb.toString(), index);\n    }\n}\n\nclass Info{\n    String res;\n    Integer index;\n\n    Info(String res, Integer index){\n        this.res = res;\n        this.index = index;\n    }\n}\n\n```\n\n### 时空分析\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304371003","body":"## 思路\n\n## 代码\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> data = new Stack<>();\n    private Stack<Integer> help = new Stack<>();\n    public MyQueue() {\n\n    }\n    public void push(int x) {\n        data.push(x);\n    }\n    \n    public int pop() {\n        if(empty()){\n            return -1;\n        }\n        return help.pop();\n    }\n    \n    public int peek() {\n        if(empty()){\n            return -1;\n        }\n        return help.peek();\n    }\n    \n    public boolean empty() {\n        pushToHelp();\n        return help.isEmpty();\n    }\n\n    private void pushToHelp(){\n        if(help.isEmpty()){\n            while(!data.isEmpty()){\n                help.push(data.pop());\n            }\n        }\n    }\n}\n```\n\n## 复杂度分析\nO(1), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304780145","body":"### 思路\n用栈保存所有段的最大值；\n逐个比较数组中每个数组，如果比当前栈顶元素小，那么肯定属于之前顶段，然后取栈顶和当前数的最大值再次放入栈；\n最后返回栈的长度即为分段的个数；\n\n### 代码\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int n : arr){\n            int t = n;\n            while(!stack.isEmpty() && stack.peek() > n){\n                t = Math.max(t, stack.pop());\n            }\n            stack.push(t);\n        }\n        return stack.size();\n    }\n}\n\n\n```\n\n### 时空分析\nO(n), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305415816","body":"## 思路\n1,先数出总长度（同时将将首尾链接），确定需要断开的位置；\n2,走到需要断开的位置，断开即可；\n\n## 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        int n = 1;\n        ListNode cur = head;\n        while(cur.next != null){\n            cur = cur.next;\n            n++;\n        }\n\n        k = k % n;\n        if(k == 0){\n            return head;\n        }\n\n        cur.next = head;\n\n        for(int i = 0; i < n - k; i++){\n            cur = cur.next;\n        }\n        ListNode ret = cur.next;\n        cur.next = null;\n        return ret;\n    }\n}\n```\n\n## 时空分析\n\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306462524","body":"### 代码\n```java\nclass Solution {\n    ///  a b c\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode a = head;\n        ListNode b = a.next;\n        a.next = swapPairs(a.next.next);\n        b.next = a;\n        return b;\n    }\n}\n\n```\n\n\n### 时空分析\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308050143","body":"### 思路\r\n\r\n利用快慢指针查找中点，递归构建左右树即可。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        return build(head, null);\r\n    }\r\n\r\n    private TreeNode build(ListNode head, ListNode tail){\r\n        if(head == tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast != tail && fast.next != tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode node = new TreeNode(slow.val);\r\n        node.left = build(head, slow);\r\n        node.right = build(slow.next, tail);\r\n        return node;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 时空分析\r\nO(n * logn) , O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310265726","body":"### 思路\n从两个链表分别走，一个到头，就换到另一条；直到两个相等为止，相等有两种情况，第一种，两个都到null相等，则没有交点，第二种，两个相交相等，则相等点就是交点；\n\n### 代码\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1 != p2){\n            p1 = p1 == null ? headB : p1.next;\n            p2 = p2 == null ? headA : p2.next;\n        }\n        return p1;\n    }\n```\n\n### 时空\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311278007","body":"## 思路\n查找入环点标准解法\n## 代码\n\n```java\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head.next.next;\n        ListNode slow = head.next;\n\n        while(fast != null && fast.next != null && fast != slow){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        if(fast == null || fast.next == null){\n            return null;\n        }\n\n        fast = head;\n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312477550","body":"### 代码\n```java\nclass LRUCache {\n\n    class Node{\n        int k;\n        int v;\n        Node pre;\n        Node next;\n        Node(int _k, int _v){\n            k = _k;\n            v = _v;\n        }\n    }\n\n    int n;\n    Node head;\n    Node tail;\n    Map<Integer, Node> map;\n\n    public LRUCache(int capacity) {\n        n = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if(map.containsKey(key)){\n            Node node = map.get(key);\n            refresh(node);\n            return node.v;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        Node node = null;\n        if(map.containsKey(key)){\n            node = map.get(key);\n            node.v = value;\n        }else{\n            if(map.size() == n){\n                Node del = tail.pre;\n                map.nextemove(del.k);\n                delete(del);\n            }\n            node = new Node(key, value);\n            map.put(key, node);\n        }\n        refresh(node);\n    }\n\n    void refresh(Node node){\n        delete(node);\n        node.next = head.next;\n        node.pre = head;\n        head.next.pre = node;\n        head.next = node;\n    }\n\n    void delete(Node node){\n        if(node.pre != null){\n            Node left = node.pre;\n            left.next = node.next;\n            node.next.pre = left;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312727922","body":"## 代码\n```java\n\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        if(root.left == null && root.right == null){\n            return 1;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313245169","body":"```java\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null ^ q == null){\n            return false;\n        }\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314947084","body":"```java\n    private int res = 0;\n\n    public int sumNumbers(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        process(root, sb);\n        return res;\n    }\n\n    private void process(TreeNode root, StringBuilder sb){\n        if(root.left == null && root.right == null){\n            sb.append(root.val);\n            res += Integer.parseInt(sb.toString());\n            sb.deleteCharAt(sb.length() - 1);\n            return;\n        }\n\n        if(root.left != null){\n            sb.append(root.val);\n            process(root.left, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n\n        if(root.right != null){\n            sb.append(root.val);\n            process(root.right, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316217197","body":"### 思路\n按层遍历，更新每一层的第一个值（最左值）；\n\n```java\n    public int findBottomLeftValue(TreeNode root) {\n        if(root == null){\n            return -1;\n        }\n        int res = root.val;\n        Deque<TreeNode> deque = new ArrayDeque<>();\n        deque.add(root);\n        while(!deque.isEmpty()){\n            int size = deque.size();\n            for(int i = 0; i < size; i++){\n                TreeNode node = deque.poll();\n                if(i == 0){\n                    res = node.val;\n                }\n                if(node.left != null){\n                    deque.add(node.left);\n                }\n                if(node.right != null){\n                    deque.add(node.right);\n                }\n            }\n        }\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318557828","body":"```java\n\npublic class Codec {\n    StringBuilder builder = new StringBuilder();\n    public String serialize(TreeNode root) {\n        toString(root);\n        return builder.toString();\n    }\n    private void toString(TreeNode root) {\n        if (root == null) {\n            builder.append(',');\n        } else {\n            builder.append(root.val).append(',');\n            toString(root.left);\n            toString(root.right);\n        }\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) {\n            return null;\n        }\n        String[] str = data.split(\",\");\n        return dfs(str);\n    }\n    private int idx = 0;\n    private TreeNode dfs(String[] str) {\n        if (idx > str.length - 1 || str[idx].length() == 0) {\n            idx++;\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(str[idx++]));\n        root.left = dfs(str);\n        root.right = dfs(str);\n        return root;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319887952","body":"## 思路\n构造数据结构，map；key是节点，value是一个 x，y ，val 的数组；深度遍历将所有节点存入map；\n根据题意，先按列/再按行/再按值排序；\n最后取出结果；\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    private Map<TreeNode, int[]> map = new HashMap<>();\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b) -> {\n            if(a[0] != b[0]){\n                return a[0] - b[0];\n            }else if(a[1] != b[1]){\n                return a[1] - b[1];\n            }else{\n                return a[2] - b[2];\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = list.size();\n        for(int i = 0; i < n;){\n            List<Integer> col = new ArrayList<>();\n            int j = i;\n            while(j < n && list.get(i)[0] == list.get(j)[0]){\n                col.add(list.get(j++)[2]);\n            }\n            ans.add(col);\n            i = j;\n        }\n        return ans;\n    }\n\n    private void dfs(TreeNode root){\n        if(root == null){\n            return;\n        }\n        int[] xyz = map.get(root);\n        int col = xyz[0];\n        int row = xyz[1];\n        int val = xyz[2];\n        if(root.left != null){\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if(root.right != null){\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n\n```\n\n### 时空分析\n\n深度遍历 O(n), 排序 O(logn)，整体 O(nlogn);\nO(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320857729","body":"梦开始的地方\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                return new int[]{i, map.get(target - nums[i])};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321031470","body":"## 思路\n\n小根堆维护k个最大值；\nmap记录值对应的次数；\n\n```java\n\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int n :  nums){\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\n            return map.get(a) - map.get(b);\n        });\n        for(Integer key : map.keySet()){\n            if(queue.size() < k){\n                queue.add(key);\n            }else if(map.get(key) > map.get(queue.peek())){\n                queue.add(key);\n                queue.remove();\n            }\n        }\n        int[] res = new int[k];\n        int i = 0;\n        while(!queue.isEmpty()){\n            res[i++] = queue.poll();\n        }\n        return res;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321509371","body":"## 分别计算每个点中，其他所有点跟他的距离，然后取距离相同的点算总数；\n\n```java\n\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for(int i = 0; i < points.length; i++){\n            Map<Integer, Integer> map = new HashMap<>();\n            for(int j = 0; j < points.length; j++){\n                if(i != j){\n                    int dx = points[i][0] - points[j][0];\n                    int dy = points[i][1] - points[j][1];\n                    int dist = dx * dx + dy * dy;\n                    map.put(dist, map.getOrDefault(dist, 0) + 1);\n                }\n            }\n            for(Integer dist : map.keySet()){\n                res += map.get(dist) * (map.get(dist) - 1);\n            }\n        }\n        return res;\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323107635","body":"```java\n \nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[256];\n        Arrays.fill(map, -1);\n        int ans = 0;\n        int pre = 0;\n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            pre = Math.min(pre + 1, i - map[c]);\n            ans = Math.max(ans, pre);\n            map[c] = i;\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325105566","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList();\n        if (s == null || s.length() == 0 || words == null || words.length == 0){\n             return res;\n        }\n        int n = s.length();\n        int m = words.length;\n        int w = words[0].length();\n\n        //预处理，统计 words 中每个单词的数量\n        Map<String, Integer> total = new HashMap();\n        for (String word : words) {\n            total.put(word, total.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i < w; ++i) {\n            HashMap<String, Integer> wd = new HashMap<>();\n            // 统计窗口内单词在 words 中出现的次数\n            int cnt = 0; \n            for (int j = i; j + w <= n; j += w) {\n                //窗口已经满，需要去掉窗口最左边的单词，才能在窗口中添加新的单词\n                if (j >= i + w * m) {\n                    //获取窗口最左边的单词\n                    String word = s.substring(j - m * w, w + j - m * w); \n                    //去除窗口最左边的单词\n                    wd.put(word, wd.get(word) - 1); \n                    if (total.get(word) != null && wd.get(word) < total.get(word))\n                        cnt--;\n                }\n                String word = s.substring(j, j + w); \n                wd.put(word, wd.getOrDefault(word, 0) + 1); //在窗口最右边添加新的单词\n                if (total.get(word) != null && wd.get(word) <= total.get(word)){\n                    cnt++;\n                }\n                if (cnt == m){\n                    res.add(j - (m - 1) * w);\n                }\n            }\n        }\n        return res; \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325853659","body":"```java\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int n = nums.length;\n        int[] s = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            s[i] = s[i - 1] + nums[i - 1];\n        }\n        Map<Integer, Integer> cnt = new HashMap<>();\n        cnt.put(0, 1);\n        int res = 0;\n        for(int i = 1; i <= n; i++){\n            int r = (s[i] % k  + k) % k;\n            res += cnt.getOrDefault(r, 0);\n            cnt.put(r, cnt.getOrDefault(r, 0) + 1);\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327144079","body":"```java\n\n\n    public ListNode middleNode(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode fast = head.next;\n        ListNode slow = head;\n        while(fast.next != null && fast.next.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow.next;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328032537","body":"```java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int slow = 0;\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] != nums[slow]){\n                nums[++slow] = nums[i];\n            }\n        }\n        return slow + 1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328150819","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(target < nums[mid]){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328597638","body":"```java\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums == null || k < 1 || nums.length < k){\n            return null;\n        }\n\n        LinkedList<Integer> qmax = new LinkedList<>();\n        int[] result = new int[nums.length - k + 1];\n\n        int index = 0;\n\n        for(int R = 0; R < nums.length; R++){\n            while (!qmax.isEmpty() && nums[qmax.peekLast()] <= nums[R]){\n                qmax.pollLast();\n            }\n            qmax.addLast(R);\n            if(qmax.peekFirst() == R - k){\n                qmax.pollFirst();\n            }\n            if(R >= k - 1){\n                result[index++] = nums[qmax.peekFirst()];\n            }\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330319740","body":"```java\n\n    public int findJudge(int n, int[][] trust) {\n        int[] map = new int[n + 1];\n        int[] out = new int[n + 1];\n        for(int[] t : trust){\n            map[t[1]]++;\n            out[t[0]]++;\n        }\n        for(int i = 1; i <= n; i++){\n            if(map[i] == n - 1 && out[i] == 0){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332084838","body":"```java\nclass Solution {\n    int N = 2010, M = 2 * 10010;\n    int[] he = new int[N], e = new int[M], ne = new int[M], color = new int[N];\n    int idx;\n    void add(int a, int b) {\n        e[idx] = b;\n        ne[idx] = he[a];\n        he[a] = idx++;\n    }\n    boolean dfs(int u, int cur) {\n        color[u] = cur;\n        for (int i = he[u]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (color[j] == cur) return false;\n            if (color[j] == 0 && !dfs(j, 3 - cur)) return false;\n        }\n        return true;\n    }\n    public boolean possibleBipartition(int n, int[][] ds) {\n        Arrays.fill(he, -1);\n        for (int[] info : ds) {\n            int a = info[0], b = info[1];\n            add(a, b); add(b, a);\n        }\n        for (int i = 1; i <= n; i++) {\n            if (color[i] != 0) continue;\n            if (!dfs(i, 1)) return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333712936","body":"```java\n\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        Map<Integer, Integer> groupCnt = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int v = group[i];\n            if (v == -1) {\n                groupCnt.put(m, 1);\n                group[i] = m++;\n            } else {\n                groupCnt.put(v, groupCnt.getOrDefault(v, 0) + 1);\n            }\n        }\n        int[] d1 = new int[m];\n        int[] d2 = new int[n];\n        Map<Integer, List<Integer>> g1 = new HashMap<>();\n        Map<Integer, List<Integer>> g2 = new HashMap<>();\n        for (int i = 0; i < beforeItems.size(); i++) {\n            List<Integer> be = beforeItems.get(i);\n            for (int j : be) {\n                d2[i]++;\n                g2.computeIfAbsent(j, l -> new ArrayList<>()).add(i);\n                int a = group[i];\n                int b = group[j];\n                if (a != b) {\n                    d1[a]++;\n                    g1.computeIfAbsent(b, l -> new ArrayList<>()).add(a);\n                }\n            }\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            if (d1[i] == 0) {\n                q.add(i);\n            }\n        }\n        int cnt = 0;\n        int cur = 0;\n        Map<Integer, Integer> pos = new HashMap<>();\n        while (q.size() > 0) {\n            int t = q.poll();\n            pos.put(t, cur);\n            System.out.println(t);\n            cur += groupCnt.getOrDefault(t, 0);\n            for (int j : g1.getOrDefault(t, Collections.emptyList())) {\n                d1[j]--;\n                if (d1[j] == 0) {\n                    q.add(j);\n                }\n            }\n            cnt++;\n        }\n        if (cnt != m) {\n            return new int[]{};\n        }\n        cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (d2[i] == 0) {\n                q.add(i);\n            }\n        }\n        int[] res = new int[n];\n        while (q.size() > 0) {\n            int t = q.poll();\n            cnt++;\n            int k = group[t];\n            res[pos.get(k)] = t;\n            pos.put(k, pos.get(k) + 1);\n            for (int j : g2.getOrDefault(t, Collections.emptyList())) {\n                d2[j]--;\n                if (d2[j] == 0) {\n                    q.add(j);\n                }\n            }\n        }\n        if (cnt != n) {\n            return new int[]{};\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335188447","body":"```java\n    public boolean judgeCircle(String moves) {\n        int x = 0;\n        int y = 0;\n        for(int i = 0; i < moves.length(); i++){\n            char c = moves.charAt(i);\n            if(c == 'U'){\n                x--;\n            }else if(c == 'D'){\n                x++;\n            }else if(c == 'L'){\n                y--;\n            }else if(c == 'R'){\n                y++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297908504","body":"更喜欢这种一个循环的写法，虽然多了一个判断\n\n**Code**\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n\n        int i = num.length - 1;\n        while (k > 0 || i >= 0) {\n            if (i >= 0)\n                k += num[i];\n\n            ans.add(0, k % 10);\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299444396","body":"**Code**\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n\n        int i = 0;\n        for (int t = 0; t < s.length(); t++) {\n            while (s.charAt(t) == c && i < t) {\n                ans[i] = t - i;\n                i++;\n            }\n        }\n\n        i = s.length() - 1;\n        for (int t = s.length() - 1; t >= 0; t--) {\n            while (s.charAt(t) == c && i > t) {\n                ans[i] = ans[i] == 0 ? i - t : Math.min(ans[i], i - t);\n                i--;\n            }\n        }\n\n        for (i = 0; i < s.length(); i++)\n            if (s.charAt(i) == c) ans[i] = 0;\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301777110","body":"**code**\n\n```java\nclass CustomStack {\n    private final int[] stack;\n    private int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top == stack.length - 1) return;\n        \n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top == -1) return -1;\n        \n        return stack[top--];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++)\n            stack[i] += val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302899706","body":"**code**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Character> deque = new ArrayDeque<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c != ']') deque.addFirst(c);\n            else {\n                StringBuilder sb = new StringBuilder();\n                while (!deque.isEmpty() && Character.isLetter(deque.getFirst()))\n                    sb.insert(0, deque.removeFirst());\n\n                String sub = sb.toString();\n                deque.removeFirst(); // remove '['\n\n               sb = new StringBuilder();\n               while (!deque.isEmpty() && Character.isDigit(deque.getFirst()))\n                   sb.insert(0, deque.removeFirst());\n\n               int count = Integer.parseInt(sb.toString());\n\n                for (char ch : sub.repeat(count).toCharArray())\n                    deque.addFirst(ch);\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (!deque.isEmpty())\n            sb.append(deque.removeLast());\n\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304501376","body":"**code**\n\n```java\nclass MyQueue {\n    Deque<Integer> stackA;\n    Deque<Integer> stackB;\n\n    public MyQueue() {\n        stackA = new ArrayDeque<>();\n        stackB = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        stackA.push(x);\n    }\n\n    public int pop() {\n        transfer();\n        return stackB.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return stackB.peek();\n    }\n\n    public boolean empty() {\n        return stackA.isEmpty() && stackB.isEmpty();\n    }\n    \n    private void transfer() {\n        if (!stackB.isEmpty()) return;\n        \n        while (!stackA.isEmpty())\n            stackB.push(stackA.pop());\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304707450","body":"**thought**\n\nSplit the array into blocks as many as possible and the largest number in the left block should be less than the largest number in the right one.\n\n---\n\n**code**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            int largest = num;\n            while (!stack.isEmpty() && stack.getFirst() > num)\n                largest = Math.max(largest, stack.removeFirst());\n            \n            stack.addFirst(largest);\n        }\n        \n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305153752","body":"**code**\n\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        \n        Deque<ListNode> stack = new ArrayDeque<>();\n        ListNode cur = head;\n        while (cur != null) {\n            stack.addFirst(cur);\n            cur = cur.next;\n        }\n\n        k %= stack.size();\n\n        while (k > 0) {\n            cur = stack.removeFirst();\n            cur.next = head;\n            head = cur;\n            stack.getFirst().next = null;\n            k--;\n        }\n        \n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307265697","body":"**code**\n\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308150895","body":"**code**\n\n\n```java\n    private ListNode cur;\n\n    public TreeNode sortedListToBST(ListNode head) {\n        int length = 0;\n        for (ListNode p = head; p != null; p = p.next) length++;\n\n        cur = head;\n        return buildTree(0, length - 1);\n    }\n\n    private TreeNode buildTree(int left, int right) {\n        if (left > right) return null;\n\n        int mid = (left + right) >>> 1;\n\n        TreeNode leftTree = buildTree(left, mid - 1);\n\n        TreeNode root = new TreeNode(cur.val);\n        cur = cur.next;\n\n        TreeNode rightTree = buildTree(mid + 1, right);\n        root.left = leftTree;\n        root.right = rightTree;\n\n        return root;\n    }\n    \n//    approach 2\n//    public TreeNode sortedListToBST(ListNode head) {\n//        List<Integer> list = new ArrayList<>();\n//        for (ListNode cur = head; cur != null; cur = cur.next)\n//            list.add(cur.val);\n//\n//        return buildTree(list, 0, list.size() - 1);\n//    }\n//\n//    private TreeNode buildTree(List<Integer> list, int left, int right) {\n//        if (left > right) return null;\n//\n//        int mid = left + (right - left) / 2;\n//        TreeNode root = new TreeNode(list.get(mid));\n//        root.left = buildTree(list, left, mid - 1);\n//        root.right = buildTree(list, mid + 1, right);\n//\n//        return root;\n//    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309675840","body":"**code**\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n\n        while (nodeA != nodeB) {\n            nodeA = nodeA == null ? headB : nodeA.next;\n            nodeB = nodeB == null ? headA : nodeB.next;\n        }\n\n        return nodeA;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311135510","body":"**thought**\n\n      a     b \n    -----------| <- They will meet at here   \n        |      |\n        -------| c    Thanks to @FlipN9\n\n    2 * slow pointer travel distance = fast pointer travel distance\n    => 2 * (a + b) = a + (b + c) + b (if the circle is big enough)\n    => a = c\n    otherwise \n    => 2 * (a + b) = a + N * (b + c) + b\n    => a + b = N * (b + c)\n    => a = (N - 1) * b + N * c\n    => claim K = N - 1\n    => a = K * b + (K + 1) * c\n    => a = K * (b + c) + c\n\n**code**\n\n```java\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        do {\n            if (fast == null || fast.next == null) return null;\n            slow = slow.next;\n            fast = fast.next.next;\n        } while (slow != fast);\n\n        slow = head;\n        while (slow != fast) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312400703","body":"**thought**\n\nDoubly Linked List with Map\n\n**code**\n\n```java\nclass LRUCache {\n    private final Map<Integer, DLinkedNode> cache;\n    private final DLinkedList list;\n    private final int capacity;\n\n    public LRUCache(int capacity) {\n        cache = new HashMap<>();\n        list = new DLinkedList();\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) return -1;\n\n        DLinkedNode node = cache.get(key);\n        list.moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            DLinkedNode node = cache.get(key);\n            node.value = value;\n            list.moveToHead(node);\n        } else {\n            if (capacity == cache.size())\n                cache.remove(list.removeTail().key);\n\n            DLinkedNode node = new DLinkedNode(key, value);\n            cache.put(key, node);\n            list.addToHead(node);\n        }\n    }\n}\n\nclass DLinkedList {\n    private final DLinkedNode dummyHead;\n    private final DLinkedNode dummyTail;\n\n    public DLinkedList() {\n        this.dummyHead = new DLinkedNode();\n        this.dummyTail = new DLinkedNode();\n        dummyHead.next = dummyTail;\n        dummyTail.prev = dummyHead;\n    }\n\n    public void addToHead(DLinkedNode node) {\n        node.prev = dummyHead;\n        node.next = dummyHead.next;\n        dummyHead.next.prev = node;\n        dummyHead.next = node;\n    }\n\n    public void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    public DLinkedNode removeTail() {\n        DLinkedNode tail = dummyTail.prev;\n        removeNode(tail);\n        return tail;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n}\n\nclass DLinkedNode {\n    int key;\n    int value;\n    DLinkedNode next;\n    DLinkedNode prev;\n\n    public DLinkedNode() {}\n\n    public DLinkedNode(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312665996","body":"**code**\n\n```java\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313385232","body":"**code**\n\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n\n        if (q.val != p.val) return false;\n\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315216589","body":"**code**\n\n```java\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int path) {\n        if (root == null) return 0;\n\n        path = path * 10 + root.val;\n        if (root.left == null && root.right == null) return path;\n\n        return dfs(root.left, path) + dfs(root.right, path);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316501662","body":"**code**\n\n```java\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.add(root);\n        int leftMost = root.val;\n        \n        while (!queue.isEmpty()) {\n            leftMost = queue.element().val;\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode cur = queue.remove();\n                \n                if (cur.left != null) queue.add(cur.left);\n                if (cur.right != null) queue.add(cur.right);\n            }\n        }\n        \n        return leftMost;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318218683","body":"**code**\n\n```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        buildString(root, sb);\n        return sb.toString();\n    }\n\n    private void buildString(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append('X').append(',');\n            return;\n        }\n\n        sb.append(root.val).append(',');\n        buildString(root.left, sb);\n        buildString(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Deque<String> nodes = Arrays.stream(data.split(\",\")).collect(Collectors.toCollection(ArrayDeque::new));\n        return buildTree(nodes);\n    }\n\n    private TreeNode buildTree(Deque<String> nodes) {\n        String s = nodes.removeFirst();\n        if (s.equals(\"X\")) return null;\n\n        TreeNode node = new TreeNode(Integer.parseInt(s));\n        node.left = buildTree(nodes);\n        node.right = buildTree(nodes);\n\n        return node;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319481473","body":"**code**\n\n```java\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        Map<Integer, List<int[]>> map = new TreeMap<>();\n\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        Queue<Integer> queueOfCol = new ArrayDeque<>();\n        queue.add(root);\n        queueOfCol.add(0);\n\n        int y = 0;\n        while (!queue.isEmpty()) {\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode cur = queue.remove();\n                int x = queueOfCol.remove();\n\n                map.computeIfAbsent(x, e -> new ArrayList<>()).add(new int[] {y, cur.val});\n\n                if (cur.left != null) {\n                    queue.add(cur.left);\n                    queueOfCol.add(x - 1);\n                }\n\n                if (cur.right != null) {\n                    queue.add(cur.right);\n                    queueOfCol.add(x + 1);\n                }\n            }\n            y++;\n        }\n\n        List<List<Integer>> ans = new ArrayList<>(map.size());\n        for (var list : map.values()) {\n            list.sort((a, b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\n\n            List<Integer> cur = new ArrayList<>();\n            for (var val : list) cur.add(val[1]);\n\n            ans.add(cur);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320817041","body":"**code**\n\n```java\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i]))\n                return new int[] {map.get(target - nums[i]), i};\n\n            map.put(nums[i], i);\n        }\n        \n        return new int[0];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321119925","body":"**code**\n\n```java\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (var num : nums)\n            count.put(num, count.getOrDefault(num, 0) + 1);\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n\n        for (var e : count.entrySet()) {\n            int[] p = {e.getKey(), e.getValue()};\n            if (k > minHeap.size())\n                minHeap.add(p);\n            else if (p[1] > minHeap.element()[1]) {\n                minHeap.remove();\n                minHeap.add(p);\n            }\n        }\n        \n        return minHeap.stream().mapToInt(e -> e[0]).toArray();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321300991","body":"**code**\n\n```java\n    public int numberOfBoomerangs(int[][] points) {\n        if (points.length < 3) return 0;\n\n        int n = points.length;\n        int res = 0;\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.clear();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n\n            for (int cnt : map.values())\n                res += cnt * (cnt - 1);\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322959802","body":"**code**\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[128];\n        Arrays.fill(map, -1);\n        int maxLen = 0;\n\n        for (int right = 0, left = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            if (map[c] != -1)\n                left = Math.max(left, map[c]);\n\n            maxLen = Math.max(maxLen, right - left + 1);\n            map[c] = right + 1;\n        }\n\n        return maxLen;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324587340","body":"**code**\n\n```java\n    public List<Integer> findSubstring(String s, String[] words) {\n        int sLen = s.length();\n        int n = words.length;\n        int wLen = words[0].length();\n\n        if (sLen < n * wLen) return List.of();\n\n        Map<String, Integer> counts = new HashMap<>();\n        for (String word : words)\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\n\n        List<Integer> ans = new ArrayList<>();\n\n        for (int i = 0; i <= sLen - n * wLen; i++) {\n            String sub = s.substring(i, i + n * wLen);\n            if (isConcat(sub, counts, wLen))\n                ans.add(i);\n        }\n\n        return ans;\n    }\n\n    private boolean isConcat(String sub, Map<String, Integer> counts, int wordLen) {\n        Map<String, Integer> seen = new HashMap<>();\n        for (int i = 0; i < sub.length(); i += wordLen) {\n            String sWord = sub.substring(i, i + wordLen);\n            if (!counts.containsKey(sWord)) return false;\n            \n            seen.put(sWord, seen.getOrDefault(sWord, 0) + 1);\n            if (seen.get(sWord) > counts.get(sWord)) return false;\n        }\n\n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326929374","body":"**code**\n\n```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        long sum = 0L;\n        for (var num : nums) sum += num;\n        int mod = (int) ((sum % p + p) % p);\n        \n        if (mod == 0) return 0;\n        \n        int n = nums.length;\n        int ans = n;\n        sum = 0L;\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0 , -1);\n\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            int curM = (int) ((sum % p + p) % p);\n            map.put(curM, i);\n            \n            int targetM = curM - mod + (curM >= mod ? 0 : p);\n            if (map.containsKey(targetM))\n                ans = Math.min(ans, i - map.get(targetM));\n        }\n        \n        return ans == n ? -1 : ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326934765","body":"**code**\n\n```java\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327979446","body":"**code**\n\n```java\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        int j = 0;\n        while (i < nums.length) {\n            if (nums[i] == nums[j]) i++;\n            else {\n                j++;\n                nums[j] = nums[i];\n            }\n        }\n\n        return j + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328161843","body":"**code**\n\n```java\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target)\n                left = mid + 1;\n            else \n                right = mid;\n        }\n        \n        return left;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328411531","body":"**code**\n\n```java\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] res = new int[n - k + 1];\n        Deque<Integer> queue = new ArrayDeque<>(k);\n\n        for (int i = 0; i < n; i++) {\n            if (!queue.isEmpty() && queue.getFirst() <= i - k)\n                queue.removeFirst();\n\n            while (!queue.isEmpty() && nums[queue.getLast()] < nums[i])\n                queue.removeLast();\n\n            queue.addLast(i);\n\n            if (i >= k - 1) res[i - k + 1] = nums[queue.getFirst()];\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330308452","body":"**thought**\n\nstar graph\n\n**code**\n\n```java\n    public int findJudge(int n, int[][] trust) {\n        int[] degrees = new int[n + 1];\n\n        for (int[] t : trust) {\n            degrees[t[0]]--;\n            degrees[t[1]]++;\n        }\n\n        for (int i = 1; i <= n; i++)\n            if (degrees[i] == n - 1) return i;\n        \n        return -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331469161","body":"**code**\n\n```java\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] colors = new int[n]; // 0: hasn't to be visited yet\n        var graph = buildGraph(dislikes, n);\n\n        for (int i = 0; i < n; i++)\n            if (colors[i] == 0 && !setColor(graph, colors, i, 1))\n                return false;\n        \n        return true;\n    }\n\n    private List<List<Integer>> buildGraph(int[][] dislikes, int n) {\n        List<List<Integer>> graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++)\n            graph.add(new ArrayList<>());\n        \n        for (var edge : dislikes) {\n            int v = edge[0] - 1;\n            int w = edge[1] - 1;\n            graph.get(v).add(w);\n            graph.get(w).add(v);\n        }\n        \n        return graph;\n    }\n\n    private boolean setColor(List<List<Integer>> graph, int[] colors, int node, int color) {\n        if (colors[node] != 0) return colors[node] == color;\n        \n        colors[node] = color;\n        for (var neighbor : graph.get(node))\n            if (!setColor(graph, colors, neighbor, -color)) return false;\n        \n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333771130","body":"**code**\n\n```java\npublic int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n        \n        List<List<Integer>> groupAdj = new ArrayList<>(m);\n        List<List<Integer>> itemAdj = new ArrayList<>(n);\n\n        for (int i = 0; i < m; i++)\n            groupAdj.add(new ArrayList<>());\n\n        for (int i = 0; i < n; i++)\n            itemAdj.add(new ArrayList<>());\n\n        int[] groupsInDegree = new int[m];\n        int[] itemsInDegree = new int[n];\n\n        for (int i = 0; i < group.length; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj.get(beforeGroup).add(currentGroup);\n                    groupsInDegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int item : beforeItems.get(i)) {\n                itemAdj.get(item).add(i);\n                itemsInDegree[i]++;\n            }\n        }\n\n        var groupsList = topologicalSort(groupAdj, groupsInDegree, m);\n        if (groupsList.isEmpty()) return new int[0];\n\n        var itemsList = topologicalSort(itemAdj, itemsInDegree, n);\n        if (itemsList.isEmpty()) return new int[0];\n\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (int item : itemsList)\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n\n        List<Integer> res = new ArrayList<>();\n        for (int groupId : groupsList) {\n            if (!groups2Items.containsKey(groupId)) continue;\n            res.addAll(groups2Items.get(groupId));\n        }\n\n        return res.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<List<Integer>> adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>(n);\n        Queue<Integer> queue = new ArrayDeque<>(n);\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0)\n                queue.offer(i);\n        }\n\n        while (!queue.isEmpty()) {\n            int front = queue.poll();\n            res.add(front);\n            for (int successor : adj.get(front)) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0)\n                    queue.offer(successor);\n            }\n        }\n\n        return res.size() == n ? res : List.of();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334786168","body":"**code**\n\n```java\n    public boolean judgeCircle(String moves) {\n        int[] coordinate = new int[2];\n        for (int i = 0; i < moves.length(); i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') coordinate[0]++;\n            else if (move == 'D') coordinate[0]--;\n            else if (move == 'L') coordinate[1]++;\n            else if (move == 'R') coordinate[1]--;\n        }\n        \n        return coordinate[0] == 0 && coordinate[1] == 0;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297909848","body":"## 思路\n从最后一位开始模拟加法运算，低位数字在数组原地保存，超出数组长度的先存到一个栈里，最后先从栈里弹出高位，最后遍历数组得到低位\n\n## 代码\n``` Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        int n = nums.length;\n        int add = 0;\n        List<Integer> ans = new ArrayList<>();\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0 || k > 0; i--, k /= 10) {\n            int sum = (i >= 0 ? nums[i] : 0) + k % 10 + add;\n            int cur = sum % 10;\n            add = sum / 10;\n            if (i >= 0) nums[i] = cur;\n            else stack.push(cur);\n        }\n        if (add != 0) stack.push(add);\n        while (!stack.isEmpty()) ans.add(stack.poll());\n        for (int num : nums) ans.add(num);\n        return ans;\n    }\n} \n```\n## 复杂度\n* 时间：O(n)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299437009","body":"## 思路\n两次遍历：从头到尾扫描，标记前面最近的c的位置lc，用当前id减去lc作为答案；从尾到头扫描，标记后面最近的c的位置rc，用当前rc减去当前id，取第一次扫描和当前计算结果的最小值\n\n## 代码\n``` Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int lc = -n;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) lc = i;\n            ans[i] = i - lc;\n        }\n        int rc = 2 * n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) rc = i;\n            ans[i] = Math.min(ans[i], rc - i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301743466","body":"## 思路 \n1. 基本思路：用数组模拟栈，栈底增量操作可以通过遍历实现\n2. 优化：用一个同样规模的数组保存从此位置到栈底的增量，当pop栈顶元素时，将此增量向栈底增量传递，不要忘记同时需要清零此位置的增量，类似差分数组的思想。\n\n## 代码\n```  Java\nclass CustomStack {\n    int[] stack;\n    int top = -1;\n    int[] topAdd;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        topAdd = new int[maxSize];\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top + 1 < maxSize) stack[++top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) return -1;\n        if (top - 1 >= 0) topAdd[top-1] += topAdd[top];\n        int res = topAdd[top] + stack[top];\n        topAdd[top] = 0;\n        top--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int pos = Math.min(k - 1, top);\n        if (pos == -1) return;\n        topAdd[pos] += val;\n    }\n}\n\n```\n\n## 复杂度\n* 时间复杂度：O(1)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303030423","body":"## 思路\n当遇到左括号时，需要用栈保存前面的解码结果，即用到一个字符串栈，同时需要保存前面的次数，即用到一个数量栈；遇到右括号时，数量栈顶为当前字符串的重复次数。\n\n## 代码\n``` Java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> cStack = new ArrayDeque<>();\n        Deque<Integer> numStack = new ArrayDeque<>();\n        int num = 0;\n        String ans = \"\";\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } \n            else if (Character.isLetter(c)) {\n                ans += c;\n            }\n            else if (c == '[') {\n                numStack.push(num);\n                num = 0;\n                cStack.push(ans);\n                ans = \"\";\n            }\n            else if (c == ']') {\n                int cnt = numStack.pop();\n                String str = cStack.pop();\n                for (int i = 1; i <= cnt; i++) {\n                    str += ans;\n                }\n                ans = str;\n            }\n        }\n        return ans;\n    }\n}\n\n```\n## 复杂度\n* 时间：O(n)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304392085","body":"## 思路\n一个栈模拟队列尾部，负责进入元素；一个栈模拟队列头部，负责出元素；头栈没有元素时，将尾栈的元素全部弹入头栈\n## 代码\n``` Java\nclass MyQueue {\n    Deque<Integer> tail;\n    Deque<Integer> head;\n\n    public MyQueue() {\n        tail = new ArrayDeque<>();\n        head = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        tail.push(x);\n    }\n    \n    public int pop() {\n        tailToHead();\n        return head.pop();\n    }\n    \n    public int peek() {\n        tailToHead();\n        return head.peek();\n    }\n\n    public void tailToHead() {\n        if (!head.isEmpty()) return; \n        while (!tail.isEmpty()) {\n            head.push(tail.pop());\n        }\n    }\n    \n    public boolean empty() {\n        return tail.isEmpty() && head.isEmpty();\n    }\n}\n```\n## 复杂度\n* 时间：O(1)\n* 空间：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309905733","body":"## 思路\n双指针，将两个链表拼起来走，当两个指针相等时停止。当有相交点时，在首个相交点停止；当没有相交点时，会在最后的空指针位置停止\n## 代码\n``` Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p = headA, q = headB;\n        while (p != q) {\n            if (p == null) p = headB;\n            else p = p.next;\n            if (q == null) q = headA;\n            else q = q.next;\n        }\n        return p;\n    }\n}\n```\n## 复杂度\n* 时间：o(n)\n* 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311162575","body":"## 思路\r\n快慢指针，设起始点到环入口的距离，环入口点到快慢指针相遇点的距离，快慢指针相遇点到环入口点的距离分别为为a、b、c，则有a + b + n * (b + c) = 2 * (a + b), 由此可以推出 a = c + (n - 1) * (b + c), 即从起始点出发，和慢指针相遇点即为环的入口点\r\n## 代码\r\n``` Java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return head;\r\n        ListNode slow = head, fast = head.next;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            if (fast != null) fast = fast.next;\r\n            if (fast != null) fast = fast.next;\r\n        }\r\n        if (slow == null) return null;\r\n        ListNode ans = head;\r\n        slow = slow.next; // 注意需要踏上这一步，长度才开始生效。\r\n        while (ans != slow) {\r\n            ans = ans.next;\r\n            slow = slow.next;\r\n        }\r\n        return ans;\r\n    }\r\n} \r\n```\r\n## 复杂度\r\n* 时间：O(n)\r\n* 空间：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312406696","body":"## 思路\n1. 根据key值得到value，需要一个map\n2. 模拟一个队列，头部是最久未访问的，尾部是刚刚访问的，需要O(1)来移动元素，因此需要一个双向链表\n\n## 代码\n``` Java\nclass LRUCache {\n    class Node {\n        Node pre, next;\n        int val;\n        int key;\n        Node (int key, int value) {\n            this.val = value;\n            this.key = key;\n        }\n    }\n\n    int capacity;\n    Map<Integer, Node> map = new HashMap<>();\n    Node head = new Node(-1, -1);\n    Node tail = head;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public void delete(int key) {\n        Node cur = map.get(key);\n        Node pre = cur.pre;\n        if (cur == tail) {\n            tail = pre;\n            return;\n        }\n        Node next = cur.next;\n        next.pre = pre;\n        pre.next = next;\n    }\n\n    public void addLast(Node cur) {\n        cur.next = tail.next;\n        tail.next = cur;\n        cur.pre = tail;\n        tail = tail.next;\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node cur = map.get(key);\n            delete(key);\n            addLast(cur);\n            return cur.val;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            map.get(key).val = value;\n            Node cur = map.get(key);\n            delete(key);\n            addLast(cur);\n            return;\n        }\n        if (map.size() >= capacity) {\n            Node cur = head.next;\n            delete(cur.key);\n            map.remove(cur.key);\n        }\n        Node cur = new Node(key, value);\n        addLast(cur);\n        map.put(key, cur);\n    }\n}\n```\n\n\n## 复杂度\n* 时间：O(n)\n* 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312608854","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n``` java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n* 时间：O(n)\r\n* 空间：递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312875542","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n``` java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null || q == null) return p == q;\r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n* 时间：O(n)\r\n* 空间：O(h)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320705484","body":"``` java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                return new int[]{i, map.get(target - nums[i])};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320997172","body":"``` java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        for (int key : map.keySet()) {\n            if (minHeap.size() < k) {\n                minHeap.offer(new int[]{key, map.get(key)});\n            } else {\n                if (map.get(key) > minHeap.peek()[1]) {\n                    minHeap.poll();\n                    minHeap.offer(new int[]{key, map.get(key)});\n                }\n            }\n        }\n        int[] ans = new int[k];\n        int cnt = 0;\n        while (!minHeap.isEmpty()) {\n            ans[cnt++] = minHeap.poll()[0];\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323625071","body":"``` Java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] letters = new int[128];\n        for (int i = 0, j = 0; j < n; j++) {\n            letters[s.charAt(j)]++;\n            while (!check(letters)) {\n                letters[s.charAt(i++)]--;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return ans;\n\n    }\n    public boolean check(int[] letters) {\n        for (int i = 0; i < letters.length; i++) {\n            if (letters[i] > 1) return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328007007","body":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length, k = 0;\n        for (int j = 0; j < n; j++) {\n            if (j > 0 && nums[j] == nums[j - 1]) continue;\n            nums[k++] = nums[j];\n        }\n        return k;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328176708","body":"``` Java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        // 找到第一个大于等于它的位置\n        int left = 0, right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329947319","body":"``` Java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int edgNum = trust.length;\n        int[] believed = new int[n + 1];\n        int[] believe = new int[n + 1];\n        for (int[] e : trust) {\n            int u = e[0], v = e[1];\n            believed[v]++;\n            believe[u]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (believe[i] == 0 && believed[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n} \n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336022018","body":"``` Java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        // 模拟获得顺序，或者说排序\n        int n = tasks.length;\n        // 进入的时间，耗时，编号\n        PriorityQueue<int[]> waitTasks = new PriorityQueue<>( (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            else if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        // 耗时，编号\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n        for (int i = 0; i < n; i++) {\n            waitTasks.offer(new int[]{tasks[i][0], tasks[i][1], i});\n        }\n        int[] ans = new int[n];\n        int cnt = 0, time = 1;\n        while (!waitTasks.isEmpty()) {\n            boolean allNotInTime = true;\n            while (!waitTasks.isEmpty() && waitTasks.peek()[0] <= time) {\n                allNotInTime = false;\n                int[] cur = waitTasks.poll();\n                sortTasks.add(new int[]{cur[1], cur[2]});\n            }\n            if (allNotInTime && sortTasks.isEmpty()) {\n                int[] cur = waitTasks.poll();\n                sortTasks.add(new int[]{cur[1], cur[2]});\n            }\n            int[] cur = sortTasks.poll();\n            ans[cnt++] = cur[1];\n            time = Math.max(time, tasks[cur[1]][0]) + cur[0];\n        }\n        while (!sortTasks.isEmpty()) {\n            ans[cnt++] = sortTasks.poll()[1];\n        }\n        return ans;\n    }\n} \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297912515","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        ###思路：类似于两数之和，将num和k从后面开始竖式相加，然后反转最后得到的数组即可\n\n        ###代码：\n        res=[]\n        n1=len(num)-1\n        carry=0\n        while n1>=0 or k !=0 or carry!=0:\n            x=num[n1] if n1>=0 else 0\n            y=k%10 if k!=0 else 0\n            \n            sum = x+y+carry\n            res.append(sum%10)\n            carry=int(sum/10)\n\n            n1-=1\n            k=int(k/10)\n\n        return res[::-1]\n\n        ###复杂度：时间复杂度O(n);空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299465487","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        ###思路，左右指针分别计算c的两侧的距离\n\n        ###代码\n        n=len(s)\n        res=[n+1]*n\n        idx=-1\n        for i in range(0,n,1):\n            if s[i]==c:\n                idx=i\n            if idx!=-1:\n                res[i]=i-idx\n        idx=n\n        for i in range(n-1,-1,-1):\n            if s[i]==c:\n                idx=i\n            if idx!=n:\n                res[i]=min(res[i],idx-i)\n\n        return res\n\n        ###复杂度：时间复杂度是O(N),遍历两次，空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301559873","body":"###用栈的思想\n###规定出长度\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[0]*maxSize\n        self.top=-1\n\n    def push(self, x: int) -> None:\n        if self.top!=len(self.stack)-1:\n            self.top+=1\n            self.stack[self.top]=(x)\n\n\n\n    def pop(self) -> int:\n        if self.top==-1:\n            return -1\n        self.top-=1\n        return self.stack[self.top+1]\n\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim=min(k,self.top+1)\n        for i in range(lim):\n            self.stack[i]+=val\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302870700","body":"        # ###思想：想法是栈，如果每次一个新的[，就入栈之前的字符串，当遇到]，便进行计算\n\n        ###代码：\n        stack=[]\n        res=\"\"\n        multi=0\n        for c in s:\n            if c==\"[\":\n                stack.append([multi,res])\n                multi,res=0,\"\"\n\n            elif c==\"]\":\n                cur_multi,last_res=stack.pop()\n                res=last_res+cur_multi*res\n            \n            elif '0'<=c<='9':\n                multi=multi*10+int(c)\n            \n            else:\n                res+=c\n            \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304382862","body":"###思路：利用双栈，当队列出元素时，队列头后面的元素放进辅助栈里面\nclass MyQueue:\n\n    def __init__(self):\n        self.stack=[]\n        self.asstack=[]\n\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if not self.asstack:\n            while self.stack:\n                self.asstack.append(self.stack.pop())\n            return self.asstack.pop()\n        else:\n            return self.asstack.pop()\n\n    def peek(self) -> int:\n        ans=self.pop()\n        self.asstack.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n    \n        if not self.stack and not self.asstack:\n            return True\n        else:\n            return False","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304730315","body":"        ###单调栈\n        ###如果是非递增的，只能分成1块\n        ###如果是非递减的，可以分为n块，n为长度\n        ###因此用单调栈依次存储最大的\n\n        ###代码\n        stack=[]\n        for cur in arr:\n\n            if stack and stack[-1]>cur:\n                cmp=stack[-1]\n                while stack and stack[-1]>cur:\n                    stack.pop()\n                stack.append(cmp)\n            else:\n                stack.append(cur)\n        \n        return len(stack)\n\n        ###复杂度：时间复杂度O(N),空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305498634","body":"        ###思路：双指针，第一个指针先走k步，第二个指针开始出发，然后第一个指针走到最后，第二个指针正好到倒数n-k处\n        ###代码\n        if not head:\n            return None        \n        n=1\n        p=head\n        while p and p.next:\n            p=p.next\n            n+=1\n        fast,slow= head,head\n        k %=n\n        if k==0: return head\n        for i in range(0,k):\n            fast=fast.next\n        \n        while fast.next:\n            fast=fast.next\n            slow=slow.next\n        \n        res=None\n        res=slow.next\n        slow.next=None\n        fast.next=head\n    \n        return res\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306529162","body":"class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ###本题有点像k个一组翻转链表\n        if not head or not head.next:\n            return head         \n        pre=None\n        tail=head\n        for i in range(2):\n            if not tail:\n                return head\n            tail=tail.next\n        \n        cur=head\n        while cur!=tail:\n            temp=cur.next\n            cur.next=pre\n            pre=cur\n            cur=temp\n        head.next=self.swapPairs(tail)\n    \n        return pre\n\n        # #\n        if not head or not head.next:\n            return head     \n        next=head.next\n        head.next=self.swapPairs(next.next)\n        next.next=head\n        return next  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308166964","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        ###参照LC108将有序数组转换为二叉搜索树\n        ###首先是递归的思想，\n        pre=head\n        nums=[]\n        while pre:\n            nums.append(pre.val)\n            pre=pre.next \n        def craet(left,right):\n            if left>right:\n                return None\n            mid=(left+right)//2\n            root=TreeNode(nums[mid])\n\n            root.left=craet(left,mid-1)\n            root.right=craet(mid+1,right)\n\n            return root\n           \n        return craet(0,len(nums)-1) \n        ###这种写法需要数组存储，需要额外的空间\n\n        ###因此考虑链表的写法\n        ###用快慢指针找到中点，然后递归左右\n        def medium(left,right):\n            fast,slow=left,left\n            while fast!=right and fast.next!=right:\n                fast=fast.next.next\n                slow=slow.next\n            return slow\n        \n        def creat(left,right):\n            if left==right:\n                return None\n            mid=medium(left,right)\n            root=TreeNode(mid.val)\n            root.left=creat(left,mid)\n            root.right=creat(mid.next,right)\n            return root\n        \n        return creat(head,None)\n\n        ###如果i想要节省时间，可以一次遍历得到长度\n        pre=head\n        self.head=head\n        num=0\n        while pre:\n            num+=1\n            pre=pre.next\n        \n        def creat(left,right):\n            if left>right:\n                return None\n            mid=(left+right)//2\n            root=TreeNode()\n            root.left=creat(left,mid-1)\n            root.val=self.head.val\n            self.head=self.head.next\n            root.right=creat(mid+1,right)\n\n            return root\n        return creat(0,num-1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309652267","body":"class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        ###双指针想法，两个指针分别从两个链表的头遍历，当前链表遍历完后遍历下一个，如果两个相遇，则意味着存在相交节点\n        \n        pre1=headA\n        pre2=headB\n        while pre1 != pre2:\n            pre1=pre1.next if pre1 else headB\n            pre2=pre2.next if pre2 else headA\n        return pre1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311146812","body":"\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        ###思路，快慢指针，相遇则说明有环,然后fast再从头走，再次相遇即是环的第一个节点\n        if not head:\n            return None\n        slow,fast=head,head\n        while slow and fast:\n            slow=slow.next\n            if fast.next:\n                fast=fast.next.next\n            else:return None\n        \n            if slow==fast:\n                break\n        fast=head\n        while slow and slow!=fast:\n            slow=slow.next\n            fast=fast.next\n        return slow\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312403113","body":"#构建双向链表\nclass Node:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.pre = None\n        self.next = None\n        \nclass LRUCache:\n    def __init__(self, capacity: int):\n        #双向链表头尾\n        self.size = 0\n        self.head = None\n        self.tail = None\n\n        self.size = capacity \n\n        #哈希表记录key值\n        self.mp = dict()\n\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.pre = self.head   \n    #将节点插入表头函数\n    def insertFirst(self, node: Node):\n        node.pre = self.head\n        node.next = self.head.next\n        self.head.next.pre = node\n        self.head.next = node\n    \n    #移到表头函数\n    def moveToHead(self, node: Node):\n        #已经到了表头\n        if node.pre == self.head:  \n            return\n        #将节点断开，取出来\n        node.pre.next = node.next\n        node.next.pre = node.pre\n        #插入第一个前面\n        self.insertFirst(node)\n    \n    #删去表尾函数，最近最少使用\n    def removeLast(self):\n        #哈希表去掉key\n        self.mp.pop(self.tail.pre.key)\n        #断连该节点\n        self.tail.pre.pre.next = self.tail; \n        self.tail.pre = self.tail.pre.pre\n    \n    #插入函数\n    def put(self, key: int, val: int):\n        #没有见过这个key，新值加入\n        if key not in self.mp:\n            node = Node(key, val)\n            self.mp[key] = node\n            #超出大小，移除最后一个\n            if self.size <= 0:\n                self.removeLast()\n            #大小还有剩余\n            else:\n                #大小减1\n                self.size -= 1 \n            #加到链表头\n            self.insertFirst(node); \n        #哈希表中已经有了，即链表里也已经有了\n        else:\n            self.mp[key].val = val\n            #访问过后，移到表头\n            self.moveToHead(self.mp[key])\n    \n    #获取数据函数\n    def get(self, key: int) -> int:\n        #找不到返回-1\n        res = -1\n        #哈希表中找到\n        if key in self.mp:\n            #获取\n            res = self.mp[key].val\n            #访问过后移到表头\n            self.moveToHead(self.mp[key])\n        return res\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312636790","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n\n        ###思路：层序遍历的思路，然后返回长度\n\n        ###长度：\n        if not root:\n            return 0\n        \n        now=[root]\n        res=[]\n        while now:\n            temp=[]\n            next=[]\n            for cur in now:\n                temp.append(cur.val)\n                if cur.left:\n                    next.append(cur.left)\n                if cur.right:\n                    next.append(cur.right)\n\n            res.append(temp)\n            now=next\n\n        return len(res)\n\n        ###递归法\n        if not root:\n            return 0\n        \n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313249187","body":"class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        ###思路：两个树按同一遍历顺序遍历，然后比较节点值，或者结构\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val!=q.val:\n            return False\n\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314669384","body":"class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,cur):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return cur*10+root.val\n\n            cur=cur*10+root.val\n            \n            return dfs(root.left,cur)+dfs(root.right,cur)\n        \n        return dfs(root,0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316145196","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        ###思路：层序遍历，最后一层最左边的节点\n\n        ###代码\n        \n        stack=[root]\n        result=0\n        while stack:\n            next=[]\n            # cur=stack.pop()\n            for i in range(len(stack)):\n                if i==0:\n                    result=stack[i].val\n                cur=stack[i]\n                if cur.left:\n                    next.append(cur.left)\n                if cur.right:\n                    next.append(cur.right)\n            stack=next\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317978532","body":"class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ans=''              \n        stack=[root]\n        while stack:\n            next=[]\n            for cur in stack:\n                if cur:\n                    ans+=str(cur.val)+','\n                    next.append(cur.left)\n                    next.append(cur.right)  \n                else:\n                    ans+='#,'\n            stack=next\n        print('ans',ans,ans[:-1])\n        return ans[:-1]           \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        # 已经有 root 了，因此从 1 开始\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n                \n            i+=2\n        return root    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319472167","body":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ###定义一个哈希表，\n        seen=collections.defaultdict(\n            lambda:collections.defaultdict(list)\n        )\n\n        def dfs(root,y=0,x=0):\n            if not root:\n                return\n            seen[y][x].append(root.val)\n            dfs(root.left,y-1,x+1)\n            dfs(root.right,y+1,x+1)\n    \n        dfs(root)\n        res=[]\n        for y in sorted(seen):\n            temp=[]\n            for x in sorted(seen[y]):\n                temp+= sorted(v for v in seen[y][x])\n            \n            res.append(temp)\n        \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320816673","body":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        ###哈希表\n        ###\n        record=dict()\n\n        for idc,value in enumerate(nums):\n            if target-value in record:\n                return [record[target-value],idc]\n            record[value]=idc\n        \n        return []","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321071340","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\n        # count = collections.Counter(nums)\n        # return [item[0] for item in count.most_common(k)]\n\n        import random\n        count = collections.Counter(nums)\n        new_num=list(count.items())\n        l=0\n        r=len(new_num)-1\n        def partion(new_num,k,l,r):\n            idc=random.randint(l,r)\n            new_num[idc],new_num[r]=new_num[r],new_num[idc]\n            less=l-1\n            pivot=new_num[r][1]\n            i=l\n            while i<=r:\n                if new_num[i][1]>=pivot:\n                    new_num[i],new_num[less+1]=new_num[less+1],new_num[i]\n                    less+=1\n                i+=1\n\n            if less==k-1:\n                return new_num[:k]\n            \n            elif less>k-1:\n                return partion(new_num,k,l,less-1)\n            else:\n                return partion(new_num,k,less+1,r)\n        \n        topk=partion(new_num,k,l,r)\n        return [item[0] for item in topk]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321340951","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ###本题的重点是计算数量，对于某个确定的距离，计算有多少个符合，当抽出两个时有多少种情况\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            print('m',m)\n            for count in m.values():\n                ans += count * (count-1)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322902008","body":"        n=len(s)\n        left=0\n        lookup=set()\n        max_len=0\n        cur_len=0\n        for i in range(n):\n            cur_len+=1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                \n                left+=1\n                cur_len-=1\n            if cur_len>max_len:\n                max_len=cur_len\n\n            lookup.add(s[i])\n        return max_len","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325879690","body":"class Solution1:\n    def subarraysDivByK(self, nums, k) :\n        record={0:1}\n        total=0     \n        ans=0\n\n        for num in nums:\n            total+=num\n            mod=total%k\n            if mod not in record:\n                record[mod]=0\n            ans+=record[mod]\n            record[mod]+=1\n        \n        # for num,num_f in record.items():\n        #     ans+=num_f*(num_f-1)//2\n            \n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326942234","body":"class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow,fast=head,head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327992322","body":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ##双指针\n        if not nums:\n            return 0\n        n=len(nums)\n        slow,fast=1,1\n        while fast<n:\n            if nums[fast]!=nums[fast-1]:\n                nums[slow]=nums[fast]\n                slow+=1\n            fast+=1\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328148994","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ###二分查找\n\n        left,right=0,len(nums)-1\n        while left<=right:\n            mid=(left+right)//2\n            if nums[mid]>target:\n                right=mid-1\n            elif nums[mid]<target:\n                left=mid+1\n            else:\n                return mid\n        return right+1\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328440727","body":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        # ###暴力法\n        if k==0: return []\n        res=[]\n        for r in range(k-1,len(nums)):\n            res.append(max(nums[r-k+1:r+1]))\n        return  res\n\n        ###双向队列解法，由于暴力法超时\n        if k==0: return nums\n        res=[]\n        from collections import deque\n        queue=deque()\n        #第一个窗口\n        for i in range(k):\n            while len(queue)!=0 and nums[i]>nums[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        \n        for i in range(k,len(nums)):\n            res.append(nums[queue[0]])\n            #已经不是当前窗口了\n            while len(queue)!=0 and queue[0]<i-k+1:\n                queue.popleft()\n            #对于当前窗口保存最大值\n            while len(queue)!=0 and nums[queue[-1]]<nums[i]:\n                queue.pop()\n            queue.append(i)\n        \n        res.append(nums[queue[0]])\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329964127","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = [0] * (n + 1)\n        out_degree = [0] * (n + 1)\n        for a, b in trust:\n            in_degree[b] += 1\n            out_degree[a] += 1\n        for i in range(1, n + 1):\n            if in_degree[i] == n - 1 and out_degree[i] == 0:\n                return i\n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331530571","body":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n\n        graph = [[0] * N for i in range(N)]\n        colors = [0] * N\n        for a, b in dislikes:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n\n        def dfs(graph, colors, i, color, N):\n            colors[i] = color\n            for j in range(N):\n                # dislike eachother\n                if graph[i][j] == 1:\n                    if colors[j] == color:\n                        return False\n                    if colors[j] == 0 and not dfs(graph, colors, j, -1 * color, N):\n                        return False\n            return True\n\n\n        for i in range(N):\n            if colors[i] == 0 and not dfs(graph, colors, i, 1, N):\n                return False\n        return True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333021012","body":"class Solution:\n    # def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n            # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297927660","body":"## 思路\n\n模拟\n\n## 代码\n\n```python3\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        def getDigit(i):\n            if i < 0:\n                return 0\n            return num[i]\n        overflow = 0\n        i = len(num) - 1\n        res = []\n        while i >= 0 or k > 0 or overflow:\n            n = getDigit(i) + k % 10 + overflow\n            k //= 10\n            overflow = n // 10\n            i -= 1\n            res.append(n % 10)\n        res.reverse()\n        return res\n\n ```\n\n## 复杂度分析\n\nn = len(num), m = log10(k)\n\n- 时间: O(max(m, n))\n- 空间: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299550536","body":"## 思路\r\n\r\n正反遍历  \r\n以正向遍历为例, dp[i]表示s[i]距离上一个c的距离，如果s[i] == c 那么, dp[i] = 0, 否则 dp[i] = dp[i - 1] + 1  \r\n反向遍历同理, 由于dp[i]已经存储了正向遍历的结果, 在s[i] != c时还需要取下最小值  \r\n\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        dp = [float('inf')] * n\r\n\r\n        def getDp(i):\r\n            if i < 0 or i >= n:\r\n                return float('inf')\r\n            return dp[i]\r\n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                dp[i] = 0\r\n            else:\r\n                dp[i] = getDp(i - 1) + 1\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0\r\n            else:\r\n                dp[i] = min(dp[i], getDp(i + 1) + 1)\r\n        return dp\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nn = len(s)\r\n\r\n时间: O(n)\r\n空间: O(1) 除了返回值\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305497430","body":"## 思路\n\n1. 先遍历一遍，获取链表长度和tail节点。  \n2. 把头结点循环移动到尾结点。  \n\n\n## 代码\n\n```python3\n\nclass Solution:\n    def getLenAndTail(self, head: Optional[ListNode]) -> int:\n        n = 0\n        node = head\n        tail = head\n        while node:\n            n += 1\n            tail = node\n            node = node.next\n        return n, tail\n\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        n, tail = self.getLenAndTail(head)\n        if n <= 1:\n            return head\n        k = n - (k % n)\n        for i in range(k):\n            next = head.next\n            head.next = None\n            tail.next = head\n            tail = tail.next\n            head = next\n        return head\n\n```\n\n## 复杂度分析\n\nn = 链表长度  \n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306722644","body":"## 思路\n\n画图\n\n## 代码\n\n```python3\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummyHead = ListNode(next=head)\n        node0, node1, node2 = dummyHead, head, head.next\n        while node0 and node1 and node2:\n            node1.next = node2.next\n            node2.next = node1\n            node0.next = node2\n            node0 = node1\n            node1 = node1.next\n            node2 = node1.next if node1 is not None else None\n        return dummyHead.next\n\n```\n\n\n## 复杂度分析\n\nn = 链表长度\n\n- Time: O(n)\n- Time: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308100237","body":"## Idea\n\ndivide and conquer\n\n\n## Code\n\n```python3\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode], dummy_head=ListNode()) -> Optional[TreeNode]:\n        if not head:\n            return None\n        dummy_head.next = head\n        prev, slow, fast = dummy_head, head, head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        prev.next = None\n        root = TreeNode(val=slow.val)\n        root.left = self.sortedListToBST(dummy_head.next)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n\n ```\n\n ## Complexity\n\n n = 链表长度  \n\n - Time: O(nlogn) 递归logn层，每层都需要遍历链表节点  \n - Space: O(logn) 递归栈空间  \n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312932584","body":"## 思路\r\n\r\n分治，根节点相等，且左右子树相等  \r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if p is None or q is None:\r\n            return p is None and q is None\r\n        return p.val == q.val \\\r\n               and self.isSameTree(p.left, q.left) \\\r\n               and self.isSameTree(p.right, q.right)\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nn = min(p.size, q.size)\r\n\r\n- Time: O(n) 遍历每个节点\r\n- Space: O(n) 树的高度\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321789318","body":"## 思路  \n\n遍历，利用dict统计  \n\n## 代码  \n\n```python3\n\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def dist(self, pointA: List[int], pointB: List[int]) -> int:\n        xa, ya = pointA\n        xb, yb = pointB\n        return (xa - xb) ** 2 + (ya - yb) ** 2\n\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 3:\n            return 0\n        ans = 0\n        for i in range(n):\n            distCounter = defaultdict(lambda : 0)\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = self.dist(points[i], points[j])\n                distCounter[dist] += 1\n            for dist, count in distCounter.items():\n                if count > 1:\n                    ans += count * (count - 1)\n        return ans\n\n```\n\n## 复杂度分析\n\nn = points.length\n\n- Time: O(n^2) 双层循环遍历所有点\n- Space: O(n) dict占用空间\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328161091","body":"## 思路\n\n二分\n\n## 代码\n\n```python3\n\nfrom typing import List\n\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        if nums[0] > target:\n            return 0\n        if nums[n - 1] < target:\n            return n\n        l, r = 0, n - 1\n        while l + 1 < r:\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m\n            else:\n                r = m\n        if nums[l] == target:\n            return l\n        else:\n\n```\n\n## 复杂度分析\n\n- Time: O(logn)\n- Space: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330039845","body":"## 思路\n\n出度为0，入度为n - 1\n\n\n## 代码\n\n```java\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] outDegrees = new int[n + 1];\n        int[] inDegrees = new int[n + 1];\n        for (int[] ab : trust) {\n            outDegrees[ab[0]] += 1;\n            inDegrees[ab[1]] += 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n## 复杂度分析\n\nm = trust.length\n\n- Time: O(m + n)\n- Space: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297956718","body":"思路\r\n在数组中从后往前遍历，一边遍历一边将k的个位数加进去并判断是否有进位，然后将k的个位数移除掉，循环往复。\r\n最后判断k或者进位是否有值，如有就进行相加并判断是否有进位，循环往复。没有则直接返回\r\n\r\n代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int index = num.size() - 1;\r\n        int agg = 0;\r\n        for (; index >= 0; index--) {\r\n            num[index] = num[index] + (k%10) + agg;\r\n            k = k / 10;\r\n            if (num[index] >= 10) {\r\n                agg = 1;\r\n                num[index] -= 10;\r\n            }else {\r\n                agg = 0;\r\n            }\r\n        }\r\n        if (agg == 0 && k == 0) {\r\n            return num;\r\n        }else {\r\n            while (k > 9 || agg > 0) {\r\n                auto sum = (k%10) + agg;\r\n                k = k / 10;\r\n                if (sum > 9) {\r\n                    sum = sum - 10;\r\n                    agg = 1;\r\n                }else {\r\n                    agg = 0;\r\n                }\r\n                num.insert(num.begin(), sum);    \r\n            }\r\n            if (k > 0) {\r\n                num.insert(num.begin(), k);\r\n            }\r\n            return num;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：O(n)，其中 n 为数组长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299510329","body":"思路\n遍历每个值，分别寻找左边和右边最近的给定字符，再取最小值即可。\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result{};\n        const char* p = s.data();\n        auto max_index = s.length() - 1;\n        if (max_index == 0) {\n            result.push_back(0);\n            return result;\n        }\n        for (auto i = 0; i <= max_index; i++) {\n            if (p[i] == c) {\n                result.push_back(0);\n                continue;\n            }\n            for (auto j = i + 1; ; j++) {\n                if (j > max_index) {\n                    result.push_back(max_index + 1);\n                    break;\n                }\n                 if (p[j] == c) {\n                     result.push_back(j - i);\n                     break;\n                 }\n                 \n            }\n            for (auto z = i - 1; z >= 0; z --) {\n                if (p[z] == c && result.back() > (i - z)) {\n                    result.pop_back();\n                    result.push_back(i - z);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n时间空间均为 O(N), O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301726919","body":"思路\r\n新建一个vector来进行模拟栈的操作；\r\n因为push进去的每个值不大于1000，可以利用多出来的位数进行存放increment的值，pop当前值时发现这个值携带increment的值，就向下传递下去，可以把increment操作优化到O1；\r\n\r\n代码\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int> base{} ;\r\n    int value_limit = 1000;\r\n    int flag = 0b10000000000;\r\n    int size_limit = 0;\r\n    int top = -1;\r\n    int mask = 0b1111111111;\r\n    CustomStack(int maxSize) {\r\n        size_limit = maxSize - 1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top >= size_limit) {\r\n            return;\r\n        }\r\n        top++;\r\n        base.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (top < 0) return -1;\r\n        int value = base.back();\r\n        base.pop_back();\r\n        top--;\r\n        if ((value & flag) == flag) {\r\n            int add_val = value >> 11;\r\n            value = (value & mask) + add_val;\r\n            if (top >= 0) {\r\n                if ((base[top] & flag) == flag) {\r\n                    base[top] = base[top] + (add_val << 11);\r\n                }else {\r\n                    base[top] = base[top] | flag;\r\n                    base[top] = base[top] + (add_val << 11);\r\n                }\r\n            }\r\n        }\r\n\r\n        \r\n        return value;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int index = min(k - 1, top);\r\n        if (index < 0) return;\r\n        int top_value = base[index];\r\n        if (top_value & flag == 1) {\r\n            base[index] = top_value + (val << 11);\r\n        }else {\r\n            top_value = top_value | flag;\r\n            base[index] = top_value + (val << 11);\r\n        }\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */rement(int k, int val) {\r\n        for(int i = 0; i < (Math.min(k, stack.length)); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：increment的操作是O(1)，其他操作是O(1)。\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303794752","body":"思路\n将每个字符压入栈，如果遇到']'时弹出栈中内容到temp中，直到遇到'['才结束；如果遇到的是数字，则用add栈记录下来，与遇到'['出现时进行处理即可。\n\n代码\n```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<char> stack{};\n        vector<char> temp{};\n        vector<int> add{};\n        int sum = 0;\n        for (size_t i = 0; i < s.size(); i++) {\n            if (std::isdigit(s[i])) {\n                sum *= 10;\n                int n = s[i] - '0';\n                sum += n;\n                continue;\n            }else if (sum > 0) {\n                add.push_back(sum);\n                sum = 0;\n            }\n            \n            if (s[i] == ']') {\n                while(!stack.empty()) {\n                    auto c = stack.back();\n                    stack.pop_back();\n                    if (c != '[') {\n                        temp.push_back(c);\n                    }else {\n                        int times = add.back();\n                        for (size_t i = 0; i < times; i++) {\n                            stack.insert(stack.end(), temp.rbegin(), temp.rend());\n                        }\n                        add.pop_back();\n                        temp.clear();\n                        break;\n                    }\n                }\n            }else {\n                stack.push_back(s[i]);\n            }\n        }\n        string result{};\n        result.assign(stack.begin(), stack.end());\n        return result;\n    }\n};\n```\n复杂度\n时间复杂度：$O(n)$，需要遍历一遍字符\n空间复杂度：$O(3n)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304555068","body":"思路\r\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\r\n\r\n代码\r\n```\r\nclass MyQueue {\r\npublic:\r\n    vector<int> s1{};\r\n    vector<int> s2{};\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        s1.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (s2.empty()) {\r\n            while(!s1.empty()) {\r\n                int a = s1.back();\r\n                s1.pop_back();\r\n                s2.push_back(a);\r\n            }\r\n        }\r\n        int result = s2.back();\r\n        s2.pop_back();\r\n        return result;\r\n    }\r\n    \r\n    int peek() {\r\n        if (s2.empty()) {\r\n            while(!s1.empty()) {\r\n                int a = s1.back();\r\n                s1.pop_back();\r\n                s2.push_back(a);\r\n            }\r\n        }\r\n        return s2.back();\r\n    }\r\n    \r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304793302","body":"用栈存放每一个分块的最大值，最后栈的数量即为分块的数量。\r\n当给出的数比最后一个块的最大值大，表示这个数可以自己当一个块；\r\n当给出的数比最后一个块的最大值小，表示这个数要融入它们；\r\n在上一条的基础上，如果这个数比倒数第二个块的最大值小，继续融合，直到遇到某个块的最大值比这个数小才停止。\r\n\r\n代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st{};\r\n        for (auto & i: arr) {\r\n            if (st.empty() || i >= st.top()) {\r\n                st.emplace(i);\r\n            }else {\r\n                auto t = st.top();\r\n                st.pop();\r\n                while (!st.empty() && st.top() > i) {\r\n                    st.pop();\r\n                }\r\n                st.emplace(t);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305721073","body":"思路\r\n把问题转换为找倒数第几个的问题；需要解决移动次数比链表长度长的问题；\r\n\r\n代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0) return head;\r\n        ListNode* result = new ListNode();\r\n        ListNode* pre_node = head;\r\n        ListNode* key_node = head;\r\n        int times = 0;\r\n        int size = 0;\r\n        for (int i = 0; i < k; i++) {\r\n            if (key_node == nullptr) {\r\n                size = i;\r\n                break;\r\n            }\r\n            key_node = key_node->next;\r\n        }\r\n        if (size == 0 && key_node == nullptr) return head;\r\n        if (size != 0) {\r\n            // 需要取模\r\n            k = k % size;\r\n            key_node = head;\r\n            for (int i = 0; i < k; i++) {\r\n                key_node = key_node->next;\r\n            }\r\n        }\r\n        \r\n\r\n        while (key_node->next != nullptr) {\r\n            key_node = key_node->next;\r\n            pre_node = pre_node->next;\r\n        }\r\n        key_node->next = head;\r\n        result->next = pre_node->next;\r\n        pre_node->next = nullptr;\r\n        return result->next;\r\n    }\r\n};\r\n```\r\n};\r\n复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307043818","body":"思路\r\n哨兵+两两交换+处理边界情况\r\n代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) return head;\r\n        ListNode* result = new ListNode();\r\n        result->next = head;\r\n        auto soilder = result;\r\n        ListNode* post_node;\r\n        ListNode* after_node;\r\n\r\n        do{\r\n            post_node = soilder;\r\n            after_node = soilder->next->next;\r\n            \r\n\r\n            post_node->next->next  = after_node->next;\r\n            after_node->next = post_node->next;\r\n            post_node->next = after_node;\r\n\r\n            soilder = after_node->next;\r\n            \r\n        }while(soilder->next != nullptr && soilder->next->next != nullptr);\r\n\r\n        return result->next;\r\n    }\r\n};\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308641542","body":"思路\n使用快慢指针找到二叉树的根节点，中点左边的值构造左子树，右边的值构造右子树；最后递归链表生成二叉树。\n\n代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr)  return nullptr;\n        if (head->next == nullptr) {\n            TreeNode* t = new TreeNode(head->val);\n            return t;\n        }\n        auto root = build(head, nullptr);\n        return root;\n    }\n\nprivate:\n    ListNode* getMin(ListNode* head, ListNode* end) {\n        if (head == end || head->next == end) return head;\n        auto slow = head;\n        auto fast = head;\n        while (fast != end && fast->next != end) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n\n    TreeNode* build(ListNode* begin, ListNode* end) {\n        if (begin == end) return nullptr;\n        auto list_node = getMin(begin, end);\n        if (list_node == end) return nullptr;\n        TreeNode* t = new TreeNode(list_node->val);\n        t->left = build(begin, list_node);\n        t->right = build(list_node->next, end);\n        return t;\n    }\n};\n```\n复杂度\n时间: O(nlogn)\n空间: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309918133","body":"思路\n走a链表+b链表 = 走b链表+a链表\n判断某个节点便利a、b链表后遇到几次结尾，如果超过2次说明没有节点\n代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        auto a = headA;\n        auto b = headB;\n        int times = 0;\n        while (times <= 2) {\n            if (a == nullptr) {\n                times++;\n                a = headB;\n            }\n            if (b == nullptr) {\n                times++;\n                b = headA;\n            }\n            if (a == b) {\n                return a;\n            }\n            a = a->next;\n            b = b->next;\n        }\n        return nullptr;\n    }\n};\n```\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311556759","body":"解题思路\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n代码实现\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr) return nullptr;\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (true) {\n            if (fast == nullptr || fast->next == nullptr) return nullptr;\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) break;\n        }\n        fast = head;\n        while (fast != slow) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return fast;\n    }\n};\n```\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312653275","body":"思路\r\n递归\r\n\r\n代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n复杂度\r\n时间：O(n)\r\n空间：递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313124725","body":"思路\n递归\n\n代码\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        if (p == nullptr || q == nullptr || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n复杂度\n时间：o(n)\n空间：o(n) n为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315301734","body":"思路\r\n深度优先搜索，当前值 * 2 加上 左子树的值 加上 右子树的值，递归当前操作，最后返回即可。\r\n\r\n代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int dfs(TreeNode* root, int prevSum) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root->val;\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root->left, sum) + dfs(root->right, sum);\r\n        }\r\n    }\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n\r\n```\r\n复杂度\r\nTime: $O(n)$, n是二叉树节点个数\r\nSpace: $O(n)$, n是二叉树节点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316935701","body":"思路\nBFS，记录每层最左元素，遍历结束，记录的为最后一层最左元素值\n\n代码\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int ret;\n        queue<TreeNode *> q;\n        q.push(root);\n        while (!q.empty()) {\n            auto p = q.front();\n            q.pop();\n            if (p->right) {\n                q.push(p->right);\n            }\n            if (p->left) {\n                q.push(p->left);\n            }\n            ret = p->val;\n        }\n        return ret;\n    }\n};\n```\n复杂度分析\n\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321822469","body":"思路\n遍历，利用dict统计\n\n代码\n```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n\n```\n复杂度分析\n\nTime: O(n^2) 双层循环遍历所有点\nSpace: O(n) dict占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323641414","body":"思路\r\n队列+滑动窗口（队列维护不同元素的组成，取最长时的数字）\r\n\r\n代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_map<char, int>hashMap;\r\n        int maxSub = 0, l = 0, r = 0;\r\n        while(r < s.size()){\r\n            if(hashMap.count(s[r])>0){\r\n                int last_pos = hashMap[s[r]];\r\n                if(last_pos >= l && last_pos <= r)\r\n                    l = last_pos + 1;\r\n            }            \r\n            maxSub = max(maxSub, r-l+1);\r\n            hashMap[s[r]] = r;\r\n            r++;\r\n        }\r\n        return maxSub;\r\n    }\r\n};\r\n复杂度分析\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(S)$\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326206364","body":"```\r\nclass Solution {\r\n    public int subarraysDivByK(int[] nums, int k) {\r\n        int n = nums.length;\r\n        int[] s = new int[n + 1];\r\n        for(int i = 1; i <= n; i++){\r\n            s[i] = s[i - 1] + nums[i - 1];\r\n        }\r\n        Map<Integer, Integer> cnt = new HashMap<>();\r\n        cnt.put(0, 1);\r\n        int res = 0;\r\n        for(int i = 1; i <= n; i++){\r\n            int r = (s[i] % k  + k) % k;\r\n            res += cnt.getOrDefault(r, 0);\r\n            cnt.put(r, cnt.getOrDefault(r, 0) + 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327403137","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        if (head->next == nullptr) return head;\r\n        auto slow = head;\r\n        auto fast = head;\r\n        while (fast != nullptr && fast->next != nullptr) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328255956","body":"```\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int n = nums.size();\r\n        int left = 0, right = n - 1, ans = n;\r\n        while (left <= right) {\r\n            int mid = ((right - left) >> 1) + left;\r\n            if (target <= nums[mid]) {\r\n                ans = mid;\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329252990","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        deque<int> q;\r\n        for (int i = 0; i < k; ++i) {\r\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n        }\r\n\r\n        vector<int> ans = {nums[q.front()]};\r\n        for (int i = k; i < n; ++i) {\r\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n            while (q.front() <= i - k) {\r\n                q.pop_front();\r\n            }\r\n            ans.push_back(nums[q.front()]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330467959","body":"```\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332028927","body":"```\nclass Solution {\npublic:\n    int parent[4010];\n    int find(int x) {\n        return x == parent[x] ? x : parent[x] = find(parent[x]);\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        for (int i = 0; i <= n*2; i++) {\n            parent[i] = i;\n        }\n        for( auto & i: dislikes) {\n            int x = find(i[0]), y = find(i[1]);\n            if (x == y) return false;\n            parent[find(x + n)] = y;\n            parent[find(y + n)] = x;\n        }\n        return true;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335040796","body":"```\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (const auto& move: moves) {\n            if (move == 'U') {\n                y--;\n            }\n            else if (move == 'D') {\n                y++;\n            }\n            else if (move == 'L') {\n                x--;\n            }\n            else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297965292","body":"```\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const reversed = num.reverse()\n    for(let i=0;i<reversed.length;i++){\n        const x = reversed[i]\n        k += x\n        reversed[i] = k % 10\n        k = (k/10) >> 0\n    }\n    while(k){\n        reversed.push(k%10)\n        k = (k/10) >> 0\n    }\n    return reversed.reverse()\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299502222","body":"function shortestToChar(s: string, c: string): number[] {\n    const n=s.length\n    let res=new Array(n).fill(Infinity)\n    for(let i=0,j=-1;i<n;i++){\n        if(s[i]===c) j=i\n        if(j !== -1) res[i] = i -j\n    }\n    for(let i=n-1,j=-1;i>=0;i--){\n        if(s[i] === c) j=i\n        if(j!=-1) res[i]=Math.min(res[i],j-i)\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301595767","body":"```\nclass CustomStack {\n  protected stack: number[] = []\n  protected max: number = Infinity\n\n  constructor(maxSize: number) {\n    this.max = maxSize\n  }\n\n  push(x: number): void {\n    if (this.stack.length === this.max) return\n    this.stack.push(x)\n  }\n\n  pop(): number {\n    if (this.stack.length === 0) return -1\n    return this.stack.pop()!\n  }\n\n  increment(k: number, val: number): void {\n    const n = this.stack.length\n    if (k > n) k = n\n    for (let i = 0; i < k; i++) {\n      this.stack[i] += val\n    }\n  }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302885382","body":"```\nfunction decodeString(s: string): string {\n  let res = ''\n  let count = 0\n  let stack: [string, number][] = []\n\n  const sArr = s.split('')\n  for (const c of sArr) {\n    if (c === '[') {\n      stack.push([res, count])\n      count = 0\n      res = ''\n    } else if (c === ']') {\n      const ans = stack.pop()!\n      const chars = ans[0]\n      const times = ans[1]\n      let temp = ''\n      for (let i = 0; i < times; i++) {\n        temp += res\n      }\n      res = chars + temp\n    } else if (c <= '9' && c >= '0') {\n      count = count * 10 + parseInt(c)\n    } else {\n      res += c\n    }\n  }\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304420330","body":"```\nclass MyQueue {\n    q: number[];\n  s: number[];\n  constructor() {\n    this.q = [];\n    this.s = [];\n  }\n\n  push(x: number): void {\n    this.q.push(x);\n  }\n\n  pop(): number {\n    while (this.q.length > 1) {\n      this.s.push(this.q.pop()!);\n    }\n    const res = this.q.pop();\n    while (this.s.length) {\n      this.q.push(this.s.pop()!);\n    }\n    return res!;\n  }\n\n  peek(): number {\n    return this.q[0];\n  }\n\n  empty(): boolean {\n    return this.q.length === 0;\n  }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304712804","body":"```\nfunction maxChunksToSorted(arr: number[]): number {\n  let stack = []\n  for (const c of arr) {\n    let t = c\n    while (stack.length && stack[stack.length - 1] > c) {\n      t = Math.max(t, stack[stack.length - 1])\n      stack.pop()\n    }\n    stack.push(t)\n  }\n  return stack.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304978809","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if(!head) return null\n    let h = head, length = 0\n    while(h){\n        length++\n        h=h.next\n    }\n    k = k % length\n    if(length === 1 || k===length || k === 0 ) return head \n    \n    let newH = head\n    let count = 0\n    while(count !== length - k){\n        newH=newH.next\n        count ++\n    }\n    let newTail = head\n    count = 0\n    while(count !== length-k-1){\n        newTail=newTail.next\n        count ++\n    }\n    if (newTail.next) newTail.next=null\n    \n    let h2 = newH\n    while(h2&&h2.next){\n        h2=h2.next\n    }\n    \n    h2.next=head\n    return newH\n    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306482795","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if(!head) return null\n    const dummy = new ListNode(-1, head)\n    let h = dummy\n    while(h.next && h.next.next){\n        const a = h.next,b=h.next.next\n        h.next=b\n        a.next=b.next\n        b.next=a\n        h=a\n    }\n    return dummy.next\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308188377","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if(!head) return null\n    const arr = []\n    let h=head\n    while(h){\n        arr.push(h.val)\n        h=h.next\n    }\n    const build = (nums,l,r) =>{\n        if(l>r) return null\n        const mid = parseInt(String((l+r) / 2))\n        let root = new TreeNode(nums[mid])\n        root.left=build(nums,l,mid-1)\n        root.right=build(nums,mid+1,r)\n        return root\n        \n    }\n    return build(arr,0,arr.length-1)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309929801","body":"```\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n  let p1: ListNode | null = headA;\n  let p2: ListNode | null = headB;\n  while (p1 !== p2) {\n    p1 = (p1 === null) ? headB : p1.next;\n    p2 = (p2 === null) ? headA : p2.next;\n  }\n  return p1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311135165","body":"```\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    if(!head || !head.next) return null\n    let quick=head.next, slow=head\n    while(quick){\n        quick=quick.next\n        slow=slow.next\n        \n        if(!quick) return null\n        \n        quick=quick.next\n        \n        if(quick===slow) {\n            slow = head\n            quick = quick.next\n            while(quick !== slow){\n                slow=slow.next\n                quick=quick.next\n            }\n            return slow\n        }\n      \n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312316338","body":"```\nclass LinkNode {\n  key: number;\n  val: number;\n  left: LinkNode | null;\n  right: LinkNode | null;\n  constructor(\n    key: number,\n    val: number,\n    left?: LinkNode | null,\n    right?: LinkNode | null\n  ) {\n    this.key = key;\n    this.val = val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nclass LRUCache {\n  // 容量\n  n: number;\n  // 当前容量\n  curN: number;\n  // 哈希表\n  hash: { [key: number]: LinkNode } = {};\n  // 虚拟左节点\n  L: LinkNode;\n  // 虚拟右节点\n  R: LinkNode;\n\n  // 删除节点\n  remove(p: LinkNode) {\n    if (p.right) p.right.left = p.left;\n    if (p.left) p.left.right = p.right;\n    this.curN -= 1;\n  }\n\n  // 增加节点\n  insert(p: LinkNode) {\n    p.right = this.L.right;\n    p.left = this.L;\n    if (this.L.right) {\n      this.L.right.left = p;\n      this.L.right = p;\n    }\n    this.curN += 1;\n  }\n\n  constructor(capacity: number) {\n    this.n = capacity;\n    this.curN = 0;\n    this.L = new LinkNode(-1, -1);\n    this.R = new LinkNode(-1, -1);\n    this.L.right = this.R;\n    this.R.left = this.L;\n  }\n\n  get(key: number): number {\n    const p = this.hash[key];\n    if (!p) return -1;\n    this.remove(p);\n    this.insert(p);\n    return p.val;\n  }\n\n  put(key: number, value: number): void {\n    const p = this.hash[key];\n    if (p) {\n      p.val = value;\n      this.remove(p);\n      this.insert(p);\n    } else {\n      //满载\n      if (this.curN === this.n) {\n        let rN = this.R.left!;\n        this.remove(rN);\n        delete this.hash[rN.key];\n      }\n      let newP = new LinkNode(key, value);\n      this.hash[key] = newP;\n      this.insert(newP);\n    }\n  }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312735403","body":"```\nfunction maxDepth(root: TreeNode | null): number {\n    if(!root) return 0\n    const l=maxDepth(root.left)\n    const r=maxDepth(root.right)\n    return Math.max(l,r)+1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313106267","body":"```\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if(!p&&!q) return true\n    if ((p&&!q) || (q&&!p) || (p.val!==q.val)) return false\n    return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314825253","body":"```\nfunction sumNumbers(root: TreeNode | null): number {\n    let ans=0\n    const dfs=(r:TreeNode, num:number)=>{\n        num=num*10+r.val\n        if(!r.left && !r.right) ans += num\n        if(r.left) dfs(r.left,num)\n        if(r.right) dfs(r.right,num)\n    }\n    dfs(root,0)\n    return ans\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316203628","body":"```\nfunction findBottomLeftValue(root: TreeNode | null): number {\n    let depth=0,ans=0\n    const dfs=(r: TreeNode | null, d: number)=>{\n       if(d>depth) {\n            depth=d\n            ans=r.val\n        }\n        if(r.left) dfs(r.left,d+1)\n        if(r.right) dfs(r.right,d+1)\n    }\n    dfs(root,1)\n    return ans\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317926165","body":"```\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n    let path =''\n    const dfs = (r: TreeNode | null)=>{\n        if(!r) {\n            path += '#,'\n            return\n        } \n        path += `${r.val},`\n        dfs(r.left)\n        dfs(r.right)\n    }\n    dfs(root)\n    return path\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n    let u = 0;\n  const dfs = (d: string): TreeNode | null => {\n    if (d[u] === \"#\") {\n      u += 2;\n      return null;\n    } else {\n      let k = u;\n      while (d[u] !== \",\") u += 1;\n      const root = new TreeNode(Number(d.substring(k, u)));\n      u += 1;\n      root.left = dfs(d);\n      root.right = dfs(d);\n      return root;\n    }\n  };\n  return dfs(data);\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319447742","body":"```\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n    const m = new Map()\n    const dfs=(r,x,y)=>{\n        if(!r) return\n        if(m.has(y)){\n            let temp = m.get(y)\n            m.set(y,[...temp, [x,r.val]])\n        }else{\n            m.set(y,[[x,r.val]])\n        }\n        dfs(r.left,x+1,y-1)\n        dfs(r.right,x+1,y+1)\n    }\n    dfs(root,0,0)\n    const mapAsc = new Map([...m].sort((a,b)=>a[0]-b[0]))\n    let res = []\n    mapAsc.forEach((value,key) => {\n       const valAsc = value.sort((a,b)=>a[0]!==b[0] ?a[0]-b[0]:a[1]-b[1])\n       let temp = valAsc.map(item=>item[1])\n       res.push(temp)\n    });\n    \n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320902329","body":"```\nfunction twoSum(nums: number[], target: number): number[] {\n    const m = new Map<number,number>()\n    for(let i=0;i<nums.length;i++){\n        const num = nums[i]\n        if(m.has(num)) return [m.get(num),i]\n        else  m.set(target-num,i)\n    }\n    return [-1,-1]\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321021378","body":"```\nfunction topKFrequent(nums: number[], k: number): number[] {\n    const m = new Map<number,number>()\n    for(const num of nums){\n        m.set(num, 1+(m.has(num)?m.get(num)+1:0))   \n    }\n    const arr = Array.from(m)\n    const arrSorted = arr.sort((a,b)=>b[1]-a[1])\n    const kArr =arrSorted.slice(0,k)\n    return kArr.map(item=>item[0])\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322854011","body":"```\nfunction lengthOfLongestSubstring(s: string): number {\n    const l=s.length\n    if(l<2) return l\n    let max = 0\n    let sub = ''\n    for(let i=0;i<l;i++){\n        const c=s[i]\n        if(!sub.includes(c)) sub+=c\n        else{\n            max=Math.max(sub.length, max)\n            const j=sub.indexOf(c)\n            sub=sub.slice(j+1)\n            sub+=c\n        }\n    }\n    return Math.max(sub.length,max)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324722242","body":"```\nfunction findSubstring(s: string, words: string[]): number[] {\n    let res=[]\n    const n=s.length,m=words.length,w=words[0].length\n    let tot=new Map<string,number>()\n    for(const word of words){\n        tot.set(word,1+(tot.has(word)?tot.get(word)!:0))\n    }\n    for(let i=0;i<w;i++){\n        let wd = new Map<string,number>()\n        let cnt=0\n        for(let j=i;j+w<=n;j+=w){\n            if(j>=i+m*w){\n                let word=s.substring(j-m*w,j-m*w+w)\n                wd.set(word,(wd.has(word)?wd.get(word)!:1)-1)\n                if(tot.has(word) && wd.get(word) < tot.get(word)) cnt--\n            }\n            let word=s.substring(j,j+w)\n            wd.set(word,1+(wd.has(word)?wd.get(word)!:0))\n           if(tot.has(word) && wd.get(word) <= tot.get(word)) cnt++\n            if(cnt === m) res.push(j-(m-1)*w)\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325870457","body":"```\nfunction subarraysDivByK(nums: number[], k: number): number {\n    const n = nums.length\n    let s=new Array(n+1).fill(0)\n    for(let i=1;i<=n;i++) s[i]=s[i-1]+nums[i-1]\n    let m=new Map<number,number>()\n    m.set(0,1)\n    let res=0\n    for(let i=1;i<=n;i++){\n        const r = ((s[i] % k + k) % k) >> 0\n        if(m.has(r)) res+=m.get(r)\n        m.set(r, (m.has(r)?m.get(r):0)+1)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326922813","body":"```\nfunction middleNode(head: ListNode | null): ListNode | null {\n    if(!head || !head.next) return head\n    let s=head, q=head.next\n    while(q){\n        s=s.next\n        if(!q.next) return s\n        q=q.next.next\n    }\n    return s  \n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328184536","body":"```\nfunction searchInsert(nums: number[], target: number): number {\n    if (target < nums[0]) return 0\n    let l=0,r=nums.length-1\n    while(l<r){\n        const mid=(l+r+1) >> 1\n        if(nums[mid] ===  target) return mid\n        else{\n            if(nums[mid]<target) l=mid\n            else r=mid-1\n        }\n    }\n    return nums[l] === target ? l : l + 1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328513491","body":"```\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\n    let res=[],q=[]\n    for(let i=0;i<nums.length;i++){\n        if(q.length&&i-k+1>q[0]) q.shift()\n        while(q.length && nums[i] > nums[q[q.length - 1]]) q.pop()\n        q.push(i)\n        if(i>=k-1) res.push(nums[q[0]])\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330448621","body":"```\nfunction findJudge(n: number, trust: number[][]): number {\n    let din=new Array(n+1).fill(0), dout=new Array(n+1).fill(0)\n    for(const p of trust){\n        let a=p[0],b=p[1]\n        din[b]++\n        dout[a]++\n    }\n    let res = -1\n    for(let i=1;i<=n;i++){\n        if(!dout[i] && din[i]===n-1){\n            if(res!==-1) return -1\n            res=i\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332045874","body":"```\nfunction possibleBipartition(n: number, dislikes: number[][]): boolean {\n    let g=new Array(n), color=new Array(n).fill(0)\n    for(let i=0;i<n;i++){\n        g[i]=[]\n    }\n    \n    for(const e of dislikes){\n        let a=e[0]-1,b=e[1]-1\n        g[a].push(b)\n        g[b].push(a)\n    }\n    \n    const dfs=(u:number,c:number)=>{\n        color[u]=c\n        for (const v of g[u]){\n            if(color[v]){\n                if(color[v] === c) return false\n            }else if(!dfs(v,3-c)){\n                return false\n            }\n        }\n        return true\n    }\n    \n    for(let i=0;i<n;i++){\n        if(!color[i] && !dfs(i,1)) return false\n    }\n    return true\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333133829","body":"```\nfunction sortItems(\n  n: number,\n  m: number,\n  group: number[],\n  beforeItems: number[][]\n): number[] {\n  //  n 个项目和  m 个小组\n  // 预处理\n  for (let i = 0; i < group.length; i++) {\n    if (group[i] == -1) {\n      group[i] = m;\n      m++;\n    }\n  }\n\n  const groupAdj: number[][] = Array(m)\n    .fill(undefined)\n    .map(() => Array());\n  const itemAdj: number[][] = Array(n)\n    .fill(undefined)\n    .map(() => Array());\n\n  let groupInDegree: number[] = Array(m).fill(0);\n  let itemInDegree: number[] = Array(n).fill(0);\n\n  for (let i = 0; i < group.length; i++) {\n    let curGroup = group[i];\n    for (let beforeItem of beforeItems[i]) {\n      let beforeGroup = group[beforeItem];\n      if (beforeGroup != curGroup) {\n        groupAdj[beforeGroup].push(curGroup);\n        groupInDegree[curGroup]++;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let item of beforeItems[i]) {\n      itemAdj[item].push(i);\n      itemInDegree[i]++;\n    }\n  }\n  // 得到组和项目的拓扑排序结果\n  let groupResult: number[] = topoLogicalSort(groupAdj, groupInDegree, m);\n  if (groupResult.length == 0) {\n    return [];\n  }\n  let itemResult = topoLogicalSort(itemAdj, itemInDegree, n);\n  if (itemResult.length == 0) {\n    return [];\n  }\n  let group2Items: Map<number, number[]> = new Map();\n  for (let item of itemResult) {\n    let key = group[item];\n    if (group2Items.has(key)) {\n      group2Items.get(group[item]).push(item);\n    } else {\n      group2Items.set(key, [item]);\n    }\n  }\n\n  let result: number[] = Array();\n  for (let group of groupResult) {\n    let items = group2Items.get(group) ?? [];\n    result = result.concat(items);\n  }\n  return result;\n}\n\nfunction topoLogicalSort(\n  adj: number[][],\n  inDegree: number[],\n  n: number\n): number[] {\n  let result: number[] = [];\n  let queue: number[] = [];\n  for (let i = 0; i < n; i++) {\n    if (inDegree[i] == 0) {\n      queue.push(i);\n    }\n  }\n  while (queue.length != 0) {\n    let front = queue.shift();\n    result.push(front);\n    for (let successor of adj[front]) {\n      inDegree[successor]--;\n      if (inDegree[successor] == 0) {\n        queue.push(successor);\n      }\n    }\n  }\n  if (result.length == n) {\n    return result;\n  }\n  return [];\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334717409","body":"```\nfunction judgeCircle(moves: string): boolean {\n    let x=0,y=0\n    for(let i=0;i<moves.length;i++){\n        const c=moves[i]\n        if(c==='L'){\n            x++\n        }else if(c==='R'){\n            x--\n        }else if(c==='U'){\n            y++\n        }else if(c==='D'){\n            y--\n        }\n    }\n    return !x&&!y\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336022555","body":"```\nvar getOrder = function(tasks) {\n    const res=[];\n    const queue = new MinPriorityQueue(); \n    tasks = tasks.map((task, index) => ({\n        index,\n        start: task[0],\n        time: task[1]\n    }))\n    tasks.sort((a, b) => b.start - a.start);\n    let time = 0;\n    while(tasks.length || !queue.isEmpty()){\n        if (queue.isEmpty() && tasks[tasks.length - 1].start > time) {\n            time = tasks[tasks.length - 1].start\n        }\n        while (tasks.length > 0 && tasks[tasks.length - 1].start <= time) {\n            const task = tasks.pop();\n            queue.enqueue(task, task.time * 100000 + task.index)\n        }\n        const { element } = queue.dequeue()\n        time += element.time;\n        res.push(element.index);\n    }\n    return res;\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297971841","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 解题思路\n模拟加法运算规则，从低位往高位每个数位依次运算。\\\n从数组中获取数位信息，直接`num[index]`\\\n从数字`k`中获得数位信息，每次进行`k % 10`\\\n运算时注意进位，每次将数位计算结果存入链表前端。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int carry = 0;\n        int n = num.length;\n        int index = n - 1; // record the index of array num that currently used in calculation\n        int dk = 0; // record the digit from k\n        int dn = 0; // record the digit from num\n\n        while (k > 0) {\n            dk = k % 10; // get the next digit from k\n            dn = 0;\n            if (index >= 0) {\n                dn = num[index--];\n            }\n            res.add(0, (carry + dk + dn) % 10); // insert the result digit to the front of the linked list\n            carry = (carry + dk + dn) / 10; // calculate carry digit\n            k /= 10; // move left to one digit\n        }\n        // when all the digits in k are used in calculation, while there are still digits in num that are not used\n        // continue to record the digits in num to res\n        while (index >= 0) {\n            res.add(0, (carry + num[index]) % 10);\n            carry = (carry + num[index]) / 10;\n            index--;\n        }\n        // if there is a carry not equal to 0, need to add one more digit for the carry\n        if (carry != 0) {\n            res.add(0, carry);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(max(n, logk)), 创建链表储存结果，链表长度为两个长度最大值","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299441621","body":"### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 解题思路\n字符串遍历问题\\\n遍历两次字符串：\\\n第一次正向遍历从左至右，计算每个字符和左边出现的特殊字符的最近距离；\\\n第二次反向遍历从右至左，计算每个字符和右边出现的特殊字符的最近距离，并把最短距离写入整数数组中。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        Arrays.fill(res, n); // fill initial values, distance cannot be longer than n\n        // traverse from the left, calculate the distance between current letter and the nearest c on its left\n        int left = -1;\n        for (int i = 0; i < n; i++) {\n            char cur = s.charAt(i);\n            if (cur == c) {\n                res[i] = 0;\n                left = i;\n            } else {\n                if (left == -1) {\n                    continue;\n                } else {\n                    res[i] = i - left;\n                }\n            }\n        }\n        // traverse from the right, calculate the distance between current letter and the nearest c on its right\n        int right = n;\n        for (int j = n - 1; j >= 0; j--) {\n            char cur = s.charAt(j);\n            if (cur == c) {\n                res[j] = 0;\n                right = j;\n            } else {\n                if (right == n) {\n                    continue;\n                } else {\n                    res[j] = Math.min(res[j], right - j);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n令n为字符串长度\n- 时间复杂度：O(n)，循环运行次数为2倍字符串长度\n- 空间复杂度：O(1)，没有额外开空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301694371","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 解题思路\n用数组来实现栈，设置变量`size`记录数组当前长度，用来快速判断栈是否已满，并且快速查找栈顶元素。\\\n用模拟实现`Increment`，更新数组中符合条件（下标在`0`到`min(k, size) - 1`)的所有元素\n\n### 代码（方法1）\n\n```java\nclass CustomStack {\n    int[] stack;  // record the elements in the stack\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = 0;\n    }\n\n    public void push(int x) {\n        if (size < stack.length) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        } else {\n            return stack[--size];\n        }\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, size);\n        // update the elements in the stack by incrementing val\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：push和pop操作O(1)，increment操作O(k)\n- 空间复杂度：O(maxSize)\n\n### 代码（方法2）\n`Increment`操作时间复杂度高，可优化。没有必要在`Increment`操作中更新所有的元素。\\\n可以用另一个数组`inc`记录每次`Increment`操作时的增加值，增加值只记录到从栈底开始最后一个被增加的位置。因为出栈操作在栈顶，每次我们可以求出栈顶元素被增加的值，并且顺势更新出栈后下一个栈顶元素的增加值，这样时间复杂度就可以降到O(1)\n\n```java\nclass CustomStack {\n    int[] stack;  // record the elements in the stack\n    int[] inc;  // record the increment value\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n        size = 0;\n    }\n\n    public void push(int x) {\n        if (size < stack.length) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        } else {\n            size--;\n            int res = stack[size] + inc[size];\n            // calculate the increment value for the element on the top of the stack after pop\n            if (size > 0) {\n                inc[size - 1] += inc[size];\n            }\n            // reset the increment value, cannot put inside if condition\n            inc[size] = 0;\n            return res;\n        }\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, size);\n        if (k > 0) {\n            // record the increment value at the position k - 1, all the elements with index 0 to k - 1 were incremented\n            inc[k - 1] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：push和pop操作O(1)，increment操作O(1)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303792321","body":"### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n### [官方题解](https://leetcode-cn.com/problems/decode-string/solution/zi-fu-chuan-jie-ma-by-leetcode-solution/)\n\n### 解题思路\n用栈来解决。重复的部分满足格式`k[encoded_string]`，先将除`]`外的字符入栈，遇到`]`说明重复的部分出现，先出栈字母，再出栈`[`，最后出栈数字。根据数字将重复部分重新入栈。最后出栈所有字符获得字符串即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c); // push characters into stack if it is not ']'\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n\t\t\t\t// get the repeated characters\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                String sub = sb.toString();\n\t\t\t\t// pop '[' from stack\n                stack.pop();\n\n                sb = new StringBuilder();\n\t\t\t\t// get the repeated times\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                int count = Integer.parseInt(sb.toString());\n\t\t\t\t// push the repeated characters back into stack\n                while (count > 0) {\n                    for (char element: sub.toCharArray()) {\n                        stack.push(element);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n令字符串长度为n\n- 时间复杂度：O(n)，需要遍历字符串\n- 空间复杂度：O(n)，创建栈储存字符","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304423074","body":"### 解题思路\n创建两个栈`in`和`out`分别储存input和output，`in`栈元素出栈然后入栈得到`out`栈，顺序相反，可以实现FIFO。当有元素入列时，push进`in`栈。当有元素出列时，先看`out`栈是否非空，如果为空将`in`栈中元素导入到`out`栈中，然后出列。\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> in;\n    Stack<Integer> out;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty为O(1)，pop和peek平均O(1)，最坏O(n)\n- 空间复杂度：O(n)，使用了两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304725202","body":"### 解题思路\n使用单调栈。令`currentMax`为对应排序块中最大元素，我们在栈中只存`currentMax`，则所存的`currentMax`单调递增。如果新元素小于前面块的`currentMax`，新元素需要和前面的块合并，我们需要更新栈中保留的`currentMax`。最后返回栈的长度即为最多块数。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (!stack.isEmpty() && stack.peek() > arr[i]){\n                int currentMax = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                        stack.pop();\n                }\n                stack.push(currentMax);\n            }\n            else {\n                stack.push(arr[i]);\n            }    \n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n\n令n为数组长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305106769","body":"### 解题思路\n先将链表链接成环，之后再找到旋转之后的head，在head的前一个node和head之间断开\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode current = head;\n        ListNode previous = head;\n\n        if (head == null) return head;\n\n        int length = 1;\n\n        // find current tail and connect it to head\n        while (current.next != null) {\n            current = current.next;\n            length++;\n        }\n        current.next = head;\n\n        current = head;\n        // find the new head\n        for (int i = 0; i < length - k % length; i++) {\n            previous = current;\n            current = current.next;\n        }\n        // set the previous node as tail\n        previous.next = null;\n        return current;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306574844","body":"### 解题思路\n用`node1`和`node2`记录两个相邻的需要交换的nodes，同时记录`node1`之前node和`node2`之后node，按照交换后的顺序连接起来这4个nodes即可。注意最后要检查null pointer。\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode node1 = head;\n        ListNode node2 = head.next;\n        ListNode pre = null;\n        head = node2;\n\n        while (node1 != null && node2 != null) {\n            ListNode temp = node2.next;\n            node2.next = node1;\n            node1.next = temp;\n            if (pre != null) pre.next = node2;\n            pre = node1;\n            if (temp == null) break;\n            else {\n                node1 = temp;\n                node2 = temp.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308285918","body":"### 解题思路\n因为要转化为高度平衡的二叉搜索树，所以在链表中选择根节点时要保证左右两边的链表长度差距不大于1。根据此条件，问题转化为链表找中点问题。递归即可求出二叉搜索树。\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n\n        ListNode left = head;\n        ListNode pre = null;\n        ListNode right = null;\n\n        ListNode fast = head;\n        ListNode slow = head;\n\n        // find midpoint\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        // slow is the midpoint, set as subtree's root\n        right = slow != null ? slow.next : null;\n        pre.next = null;\n\n        return new TreeNode(slow.val, sortedListToBST(left), sortedListToBST(right));\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309799635","body":"### 解题思路\n从两个链表的头headA和headB同时出发遍历链表，当链表A遍历结束后从headB出发继续遍历，当链表B遍历结束后从headA出发继续遍历。\\\n假设两个链表有交点，链表A从headA到交点的长度为A，链表B从headB到交点的长度为B，交点之后的长度为C。当两者相遇时，都走过了(A + B + C)的长度，相遇点即为交点。\\\n如果两个链表没有交点，则遍历完两个链表都走过了(A + B)的长度，此时返回null，表示无交点。\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode cur1 = headA;\n        ListNode cur2 = headB;\n        while (cur1 != cur2) {\n            cur1 = cur1 == null ? headB: cur1.next;\n            cur2 = cur2 == null ? headA: cur2.next;\n        }\n        return cur1;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311204590","body":"### 解题思路\n\n快慢指针。`fast`每次前进两格，`slow`每次前进一格。如果无环则`fast`率先到达尾部null。如果有环，则在相遇时重置`fast`为`head`，每次前进一格，再次相遇节点即为开始入环的第一个节点。\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n\n        do {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == null || fast.next == null) return null;\n        } while (fast != slow);\n\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }       \n        return fast;\n    }\n}\n```\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312379906","body":"### 解题思路\n使用哈希表和双向链表，哈希表可以在O(1)时间快速查找对应节点，双向链表可以在知道节点位置的情况下在O(1)时间移动和删除节点\n\n### 代码\n\n```java\nclass LRUCache {\n\n    class DListNode {\n        int key;\n        int val;\n        DListNode pre;\n        DListNode next;\n        DListNode() {}\n        DListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private int size;\n    private int cap;\n    private DListNode head;\n    private DListNode tail;\n    private Map<Integer, DListNode> cache = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) return -1;\n        DListNode node = cache.get(key);\n        moveToHead(node);\n        return node.val;\n    }\n    \n    public void put(int key, int value) {       \n        if (cache.containsKey(key)) {\n            DListNode node = cache.get(key);\n            node.val = value;\n            moveToHead(node);\n        }    \n        else {\n            DListNode newNode = new DListNode(key, value);\n            size++;\n            cache.put(key, newNode);\n            if (size > cap) {\n                cache.remove(tail.pre.key);\n                removeNode(tail.pre);\n                size--;           \n            }           \n            addToHead(newNode);\n        }          \n    }\n\n    private void addToHead(DListNode node) {\n        node.pre = head; \n        node.next = head.next;\n        head.next.pre = node;\n        head.next = node;              \n    }\n\n    private void removeNode(DListNode node) {\n        if (node.pre == null || node.next == null) return;\n        node.pre.next = node.next;\n        node.next.pre = node.pre;      \n    }\n\n    private void moveToHead(DListNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n**复杂度分析**\n\n令n为容量capacity\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)，使用哈希表和双向链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312656486","body":"### 解题思路\n递归，base case是`root == null`，此时最大深度为0。其余条件下比较左右子树的最大深度，取较大者+1。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n**复杂度分析**\n令n为二叉树节点数\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312843030","body":"### 解题思路\n递归，每个节点分别判断节点是否都为空，是否节点值相等，两个左子树是否相等，两个右子树是否分别相等。\n\n### 代码\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        else if (p == null || q == null) return false;\n        else if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为树的节点数\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314805948","body":"### 解题思路\nDFS, 每走完一条路径到叶子节点则将此路径代表的数字加到`res`中。\n\n### 代码\n\n```java\nclass Solution {\n    private int res;\n\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return res;\n    }\n\n    private void dfs(TreeNode root, int last) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) {\n            res += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left, last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为树的节点数\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316348309","body":"### 解题思路\nBFS，返回最后一层的第一个节点的值即为树左下角的值。\n\n### 代码\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res = 0;\n        Deque<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            res = queue.peek().val;\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = queue.poll();\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                }\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为树的节点数\n- 空间复杂度：O(q)，q为队列长度，最坏情况是满二叉树（full binary tree），底层节点数约为n/2，空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1319284761","body":"### 解题思路\r\nBFS\r\n- 序列化：用BFS遍历树，不管node的左右子节点是否存在，都加到队列中；在节点出队时，如果节点不存在，在返回的String中加入\"null\"，如果节点存在，加入节点值的字符串形式。现在末尾处的多余的null还出现在字符串中，有待优化。\r\n- 反序列化：同样使用BFS，利用队列新建二叉树。将data转化字符串数组，然后遍历，只要不为null则将节点按顺序加入二叉树中，同时将节点入队，队列为空时遍历完毕，返回根节点。\r\n\r\n### 代码\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if (root == null) return \"\";\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"[\");\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if (node != null) {\r\n                sb.append(\"\" + node.val); // convert to string\r\n                sb.append(\",\");\r\n                queue.offer(node.left);\r\n                queue.offer(node.right);\r\n            }\r\n            else {\r\n                sb.append(\"null,\");\r\n            }\r\n        }\r\n        sb.deleteCharAt(sb.length() - 1);\r\n        sb.append(\"]\");      \r\n        return sb.toString();  \r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if (\"\".equals(data)) return null;\r\n\r\n        String[] datalist = data.substring(1, data.length() - 1).split(\",\");\r\n        TreeNode root = new TreeNode(Integer.parseInt(datalist[0]));\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int i = 1;\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if (!\"null\".equals(datalist[i])) {\r\n                node.left = new TreeNode(Integer.parseInt(datalist[i]));\r\n                queue.offer(node.left);\r\n            }\r\n            i++;\r\n            if (!\"null\".equals(datalist[i])) {\r\n                node.right = new TreeNode(Integer.parseInt(datalist[i]));\r\n                queue.offer(node.right);\r\n            }\r\n            i++;\r\n        }        \r\n        return root;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，n为树的节点数\r\n- 空间复杂度：O(q)，q为队列长度，最坏情况是满二叉树，O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319531997","body":"### 解题思路\nBFS + 哈希表 + 排序。用一个哈希表储存整个树在不同列的节点值的数组。用BFS对树逐层进行遍历，每一层用另一个哈希表储存该层出现的在不同列的节点值的数组，将数组中的节点值按从小到大排好序后，合并到整棵树的哈希表中。最后将哈希表转换格式输出结果。\n\n### 代码\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n\n        Map<Integer, List<Integer>> map = new TreeMap<>(); // treemap will sort the keys\n        Deque<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0));\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            Map<Integer, List<Integer>> levelMap = new HashMap<>(); // use a map to track node values from the same row and same column\n            List<Integer> values;\n            List<Integer> levelVals;\n            // traverse nodes at each level\n            for (int i = 0; i < size; i++) {\n                Pair<TreeNode, Integer> nodePair = queue.poll();                \n                TreeNode node = nodePair.getKey();\n                int col = nodePair.getValue();\n                // add node values from the same column to the list of the map\n                if (!levelMap.containsKey(col)) {\n                    levelVals = new ArrayList<>();\n                }\n                else {\n                    levelVals = levelMap.get(col);\n                }\n                levelVals.add(node.val);\n                levelMap.put(col, levelVals);\n\n                if (node.left != null) {\n                    queue.offer(new Pair<>(node.left, col - 1));\n                }\n                if (node.right != null) {\n                    queue.offer(new Pair<>(node.right, col + 1));\n                }\n            }\n            // add results obtained from this row to the result map\n            for (int col: levelMap.keySet()) {\n                if (!map.containsKey(col)) {\n                    values = new ArrayList<>();\n                }\n                else {\n                    values = map.get(col);\n                }\n                \n                levelVals = levelMap.get(col);\n                Collections.sort(levelVals); // sort the node values from the same column and same row\n                values.addAll(levelVals); // combine values from the same column\n                map.put(col, values);\n            }   \n        }\n        \n        for (int col: map.keySet()) {\n            res.add(map.get(col));\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320829334","body":"### 解题思路\n哈希表。建立哈希表储存数字和其对应的索引，对数组进行一次遍历，每次先查哈希表看表中有无`target - nums[i]`，如果有则返回结果，如果没有在将当先数字和其索引存入哈希表。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i])) {\n                res[0] = map.get(target - nums[i]);\n                res[1] = i;\n                break;\n            }\n            else {\n                map.put(nums[i], i);\n            }\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320955789","body":"### 解题思路\n方法一：哈希表+桶排序。哈希表储存数字和对应出现次数。从最后一个桶开始往前遍历取k个元素。\n\n方法二：哈希表+堆排序。哈希表储存数字和对应出现次数。建立一个容量为k的最小堆。遍历哈希表，将表中元素存入最小堆中。当堆的容量超过k时，去除堆顶出现次数最少的元素。最后返回堆中对应的k个数字即可。\n\n### 代码\n方法一：\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer>[] bucket = new List[nums.length + 1]; // from 0 to nums.length\n        LinkedList<Integer> res = new LinkedList<>(); // specify to use linked list instead of general list\n\n        for (int num: map.keySet()) {\n            int count = map.get(num);\n            if (bucket[count] == null) {\n                bucket[count] = new LinkedList<Integer>();\n            }\n            bucket[count].add(num);\n        }\n\n        for (int i = nums.length; i >= 0; i--) {\n            if (bucket[i] != null) {\n                for (int num: bucket[i]) {\n                    res.add(num);\n                }\n            }\n        }\n\n        int[] ans = new int[k];\n        for (int i = 0; i < k; i++) {\n            ans[i] = res.removeFirst();\n        }\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(n)，n为数组长度\n\n方法二：\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for (int n: nums) {\n            counts.put(n, counts.getOrDefault(n, 0) + 1);\n        }\n        int[] res = new int[k];\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(\n            (a, b) -> counts.get(a) - counts.get(b)\n        );\n        for (int key: counts.keySet()) {\n            minHeap.offer(key);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            res[i] = minHeap.poll();\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogk)，n为数组长度，k为堆的容量\n- 空间复杂度：O(n)，n为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321489200","body":"### 解题思路\n确定中心点，然后用哈希表记录不同距离对应的点的个数，用排列组合公式求出回旋镖个数，最后加总求得总数。\n\n### 代码\n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int num = 0;\n        Map<Double, Integer> map = new HashMap<>();\n        for (int i = 0; i < points.length; i++) {\n            int[] base = points[i];\n            for (int j = 0; j < points.length; j++) {\n                int[] cur = points[j];\n                double d = Math.pow(cur[0] - base[0], 2.0) + Math.pow(cur[1] - base[1], 2.0);\n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n            for (double d: map.keySet()) {\n                int count = map.get(d);\n                num += count * (count - 1);\n            }\n            map.clear();\n        }\n        return num;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323149925","body":"### 解题思路\n滑动窗口，哈希表。建立哈希表储存字符。使用变量`start`记录无重复字符串的起始点，用变量`end`记录当前遍历的位置，用`max`记录当前最长无重复字符串的长度。遍历字符串，每次找到左边第一个满足条件的`start`的位置，如果遇到重复字符，向右移动`start`直到重复字符从哈希表里删除，每次更新`max`。遍历结束返回`max`即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int start = 0;\n        int max = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char cur = s.charAt(end);\n            while (set.contains(cur)) {\n                char prev = s.charAt(start);\n                set.remove(prev);\n                start++;\n            }\n            max = Math.max(max, end - start + 1);\n            set.add(cur);\n        }\n        return max;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为字符串长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324549480","body":"### 解题思路\n哈希表。建立初始哈希表储存串联所有单词的子串的单词和对应出现次数。遍历字符串`s`确定子串起始点。每次先复制初始的哈希表，然后从起始点开始截取长度为`words[i].length`的子字符串，看该子字符串是否出现在哈希表中。如果没出现，则将起始点后移一位。如果出现，更新哈希表，出现次数减1，次数为0时则将Key从哈希表中删除。重复次循环继续截取长度为`words[i].length`的子字符串，直到哈希表为空。如果循环结束哈希表为空，表示子串中所有单词全部找到，将起始点存放到结果数组中，将起始点后移继续遍历。最后返回结果数组。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        int slen = s.length();\n        int num = words.length;\n        int wlen = words[0].length();\n        if (slen < num * wlen) return res;\n\n        Map<String, Integer> wordMap = new HashMap<>();\n        for (String word: words) {\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\n        }\n\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i <= slen - num * wlen; i++) {\n            String sub = \"\";\n            int start = i;         \n            map.putAll(wordMap);\n            do {\n                sub = s.substring(start, start + wlen);\n                if (!map.containsKey(sub)) break;\n                int count = map.get(sub) - 1;\n                if (count == 0) map.remove(sub);\n                else map.put(sub, count);\n                start += wlen;\n            } while (!map.isEmpty());\n\n            if (map.isEmpty()) res.add(i);\n            map.clear();\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：令n为字符串`s`的长度，m为`words`的长度，l为每个单词的长度。如果将`substring()`函数操作数定为1，则为O(mn)。如果将`substring()`函数操作数定为l，则为O(mnl)\n- 空间复杂度：O(m)，每次需要用到一个长度为m的哈希表。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325944885","body":"### 解题思路\n计算数组`nums`的前缀和，然后求除k的余数（注意负数的特殊情况），用哈希表记录相同余数的前缀和的数目，根据同余定理，相同余数的前缀和相减即可得到整除k的subarray，每次求出以当前元素为最后元素的满足条件的subarray的数量，加总求和即为最终结果。\n\n### 代码\n```java\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int res = 0;\n        Map<Integer, Integer> counts = new HashMap<>();\n        counts.put(0, 1);\n        int sum = 0;\n        for (int n: nums) {\n            sum += n;\n            int residue = sum % k >= 0 ? sum % k : k + sum % k;\n            int cur = counts.getOrDefault(residue, 0);\n            res += cur;\n            counts.put(residue, cur + 1);\n        }\n        return res;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326841401","body":"### 解题思路\n双指针。设置快慢双指针，初始值都设为head，慢指针每次移动1，快指针每次移动2，直到快指针到达尾部`fast == null || fast.next == null`，返回慢指针即为中点。\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为链表长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327954564","body":"### 解题思路\n双指针。读写指针。指针`i`用来做读操作，遍历整个数组。指针`j`用来做写操作，记录前一个无重复的元素的位置。每次遇到不重复的元素则更新`nums[++j]`。最后返回`j+1`即为删除后数组的新长度。\n\n### 代码\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int j = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328098273","body":"### 解题思路\n二分查找。找左边第一个大于等于`target`的元素的下标，即为结果。如果没有这样的元素，则`target`应该插入到数组最后，返回`nums.length`。\n\n### 代码\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left < right - 1) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        if (nums[left] >= target) {\n            return left;\n        }\n        if (nums[right] >= target) {\n            return right;\n        }\n        return nums.length;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(log n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328395029","body":"### 解题思路\n单调队列。不需要储存窗口内所有的元素。如果新进入的元素比前面的大，可以直接将前面的元素移除。这样每一时刻我们都会得到一个单调递减队列，队首元素为最大值。\n具体做法：入队列。然后移除失效元素，包括(1) 超出窗口范围的元素，(2) 队列尾部小于当前值的元素。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < k; i++) {\n            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.offerLast(i);\n        }\n        int n = nums.length;\n        int[] res = new int[n - k + 1];\n        res[0] = nums[queue.peekFirst()];\n        for (int i = k; i < n; i++) {\n            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.offerLast(i);\n            if (queue.peekFirst() < i - k + 1) {\n                queue.pollFirst();\n            }\n            res[i - k + 1] = nums[queue.peekFirst()];\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(k)，需要队列，队列中不超过k元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330106634","body":"### 解题思路\n信任关系可以用图来表示。每个顶点表示不同的人，每条有向边表示信任关系，从表示信任的人到被信任的人。因为法官不相信任何人，而每个人都信任法官，所以法官的入度为`n-1`，出度为`0`。找到这样条件的顶点即可。\n\n### 代码\n\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        if (trust.length == 0 && n == 1) return 1;\n        int[] deg = new int[n + 1]; // use array to store the difference of indegree and outdegree\n        for (int i = 0; i < trust.length; i++) {\n            deg[trust[i][0]]--; // outdegree\n            deg[trust[i][1]]++; // indegree\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (deg[i] == n - 1) return i;\n        }\n        return -1;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为人数\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331634291","body":"### 解题思路\nDFS, 染色法。根据题目信息建立邻接表来表示图。然后进行DFS，看每条边相邻两个点是否都能够染上不同颜色（颜色表示：0表示为染色，1表示染红色，-1表示染蓝色，变到相反颜色乘-1即可）。\n\n### 代码\n\n```java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    int[] colors;\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        graph = new ArrayList[n + 1];\n        for (int i = 0; i <= n; i++) {\n            graph[i] = new ArrayList<Integer>();\n        }\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        colors = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            if (colors[i] == 0 && !dfs(i, 1)) return false;\n        }\n        return true;        \n    }\n\n    private boolean dfs(int node, int color) {\n        if (colors[node] != 0) return colors[node] == color;\n        colors[node] = color;\n        for (int next: graph[node]) {\n            if (colors[next] == 0 && !dfs(next, -color)) return false;\n            if (colors[next] == color) return false;\n        }\n        return true;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n + m)，n为顶点数，m为边数\n- 空间复杂度：O(n + m)，使用邻接表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333067025","body":"### 解题思路\n拓扑排序，BFS。分别对组和项目进行拓扑排序。然后根据组和项目的一对多对应关系，合并成最终的拓扑排序结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 1. label the unassigned projects, group = -1\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 2. initiate adjacent list for group and project\n        List<Integer>[] groupGraph = new ArrayList[m];\n        List<Integer>[] itemGraph = new ArrayList[n];\n        for (int i = 0; i < m; i++) groupGraph[i] = new ArrayList<>();\n        for (int i = 0; i < n; i++) itemGraph[i] = new ArrayList<>();\n\n        // 3. build graphs and get indegree information\n        int[] groupIndegree = new int[m];\n        int[] itemIndegree = new int[n];\n\n        int len = group.length; // m changed\n        for (int i = 0; i < len; i++) {\n            int curGroup = group[i];\n            for (int beforeItem: beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != curGroup) {\n                    groupGraph[beforeGroup].add(curGroup);\n                    groupIndegree[curGroup]++;\n                }\n            }\n        } \n\n        for (int i = 0; i < n; i++) {\n            for (int item: beforeItems.get(i)) {\n                itemGraph[item].add(i);\n                itemIndegree[i]++;\n            }\n        }\n\n        // 4. Get topo sort results\n        List<Integer> groupList = tpsort(groupGraph, groupIndegree, m);\n        if (groupList.size() == 0) return new int[0];\n        List<Integer> itemList = tpsort(itemGraph, itemIndegree, n);\n        if (itemList.size() == 0) return new int[0];\n\n        // 5. create map from group to project\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int item: itemList) {\n            map.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 6. get the final project topo sort result\n        List<Integer> res = new ArrayList<>();\n        for (int groupId: groupList) {\n            List<Integer> items = map.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n \n    }\n\n    private List<Integer> tpsort(List<Integer>[] graph, int[]indegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Deque<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == 0) queue.offer(i);\n        }\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            res.add(node);\n            for (int next: graph[node]) {\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        if (res.size() == n) return res;\n        return new ArrayList<>();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(m + n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334747154","body":"### 解题思路\n模拟。最后看返回的坐标是否为(0, 0)。\n\n### 代码\n\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为字符串长度\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297979089","body":"### 思路：\n从后往前遍历数组，与k的末位进行逐位相加，若和大于10，则进1(通过提前加到除以10的k上实现)，最后再将剩余的k加到答案上。\n\n### 代码：\n```java\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>(); // 每次在头部插入，用链表\n        int add = 0;\n        for (int i = num.length - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k += 1 ; // 完成了进1的操作\n                sum -= 10;\n            }\n            ans.addFirst(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ans.addFirst(k % 10);\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度：\n- 时间复杂度：O(n)，遍历一遍数组\n- 空间复杂度：O(1)，除了答案的数组外没用额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301813145","body":"### 思路：\n用数组实现栈。top指示栈顶元素所在位置，初始值为-1。\n### 代码：\n```java\nclass CustomStack {\n    int max;\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        max = maxSize;\n        top = -1;\n        stack = new int[max];\n    }\n\n    public void push(int x) {\n        if (top < max - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top != -1) {\n            return stack[top--];\n        } else return -1;\n    }\n\n    public void increment(int k, int val) {\n        int increment = Math.min(k - 1, top);\n        for (int i = 0; i <= increment; i++) stack[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n### 复杂度：\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的时间复杂度为 O(1)，inc 操作的时间复杂度为 O(k)。\n- 空间复杂度：使用了一个辅助数组，O(maxSize）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304388460","body":"### 思路：\n使用两个栈，一个进行入队操作，一个进行出队操作。\n### 代码：\n```java\nimport java.util.*;\n\nclass MyQueue {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stack1.addLast(x);\n    }\n\n    public int pop() {\n        if (stack2.size() != 0) return stack2.removeLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.removeLast();\n        }\n        return -1;\n    }\n\n    public int peek() {\n        if (stack2.size() != 0) return stack2.getLast();\n        else if (stack1.size() != 0) {\n            return stack1.getFirst();\n        }\n        return -1;\n    }\n\n    public boolean empty() {\n        return stack1.size() == 0 && stack2.size() == 0;\n    }\n}\n\n/*\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n### 复杂度：\n- 时间复杂度：push 和empty 为 O(1)，pop 和peek 为均摊O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304749708","body":"### 思路：\n右边块的数字均大于或等于左边块的所有数字，如果新添加的数字小于原数组的最后一个块的最大值，则它必须融入最后一个块。用单调增栈来存储每个排序块的最大值，这样栈的长度就是最终排序块的数量。\n### 代码：\n```java\nimport java.util.*;\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        // 右边块的数字均大于或等于左边块的所有数字，如果新添加的数字小于原数组的最后一个块的最大值，则它必须融入最后一个块。\n        // 用单调增栈来存储每个排序块的最大值，这样栈的长度就是最终排序块的数量\n        for (int num : arr) {\n            if (!stack.isEmpty()&&num<stack.getLast()){\n            // 当前数小于栈顶数，说明会打乱前面已有的排序块\n                Integer head = stack.removeLast();\n                // 此时的出栈元素是新排序块的最大值，用head记录\n                while(!stack.isEmpty()&&num< stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n### 复杂度：\n- 时间复杂度：O(n)，其中 nn 是输入数组 arr 的长度。需要遍历一遍数组，入栈的操作最多为 n 次。\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305448019","body":"### 思路：\n数组存储节点，重新建链\n### 代码：\n```java\nimport java.util.LinkedList;\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null) return null;\n        LinkedList<Integer> stack = new LinkedList<>();\n        ListNode res = null;\n        ListNode tail = null;\n        ListNode cur = head;\n        int n = 0;\n        while (cur != null) {\n            n++;\n            stack.addLast(cur.val);\n            cur = cur.next;\n        }\n        int rotateNum = k % n;\n        int oriNum = n - rotateNum;\n        cur = head;\n        while (oriNum-- > 0) {\n            if (res == null) {\n                res = new ListNode(cur.val);\n                tail = res;\n            } else {\n                tail.next = new ListNode(cur.val);\n                tail = tail.next;\n            }\n            cur = cur.next;\n        }\n        while (rotateNum-- > 0) {\n            if (res == null) {\n                res = new ListNode(stack.removeLast());\n            } else {\n                ListNode temp = new ListNode(stack.removeLast());\n                temp.next = res;\n                res = temp;\n            }\n        }\n        return res;\n    }\n}\n```\n### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297988060","body":"#### 思路\r\n以 [2,1,5], k = 806 为例。 末尾开始遍历 806 + 5 = 811， 811 % 10 = 1， 1 留在当前位， 将k 更新为 811 / 10 进入下一位，重复计算得到结果.\r\n#### code\r\n```js\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let res = []\r\n\r\n    for (let i = num.length -  1; i >= 0; i--) {\r\n        res.unshift((num[i] + k) % 10)\r\n\r\n        k = Math.floor((num[i] + k) / 10)\r\n    }\r\n\r\n    while (k > 0) {\r\n         res.unshift( k % 10)\r\n         k = Math.floor(k / 10)\r\n    }\r\n\r\n\r\n    return res\r\n};\r\n```\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299768042","body":"#### 思路\n滑动窗口\n\n#### code\n```js\nvar shortestToChar = function(S, C) {\n    let l  = S[0] === C ? 0 : Infinity\n    let r = S.indexOf(C)\n    let res = []\n\n    for (let i = 0; i < S.length; i++) {\n        // 计算字符到当前窗口左右边界的最小距离\n        res[i] = Math.min(Math.abs(i - l), Math.abs(r - i))\n\n        // 遍历完了当前窗口后，将窗口右移\n        if (i === r) {\n            l = r\n            r = S.indexOf(C, l + 1)\n        }\n    }\n    return res\n};\n````\n\n#### 复杂度分析\n- 时间复杂度：O(n)，其中 n 为字符串长度。\n- 空间复杂度：O(n)，其中 n 为字符串长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301883798","body":"> ### 解题思路\r\n> 模拟，构造函数需要两个属性，一个数组stack一个maxSize；\r\n> \r\n> ### 代码\r\n> \r\n> ```javascript\r\n> /**\r\n>  * @param {number} maxSize\r\n>  */\r\n> var CustomStack = function(maxSize) {\r\n>   this.stack = new Array();   // [empty, ...]\r\n>   this.maxSize = maxSize;\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} x\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.push = function(x) {\r\n>   // 最大长度限制\r\n>   if(this.stack.length<this.maxSize){\r\n>     this.stack.push(x);\r\n>   }\r\n> };\r\n> \r\n> /**\r\n>  * @return {number}\r\n>  */\r\n> CustomStack.prototype.pop = function() {\r\n>   // 栈顶为空的 =》 -1\r\n>   if(this.stack.length===0){\r\n>     return -1;\r\n>   }\r\n>   let val = this.stack.pop();\r\n>   return val;\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} k \r\n>  * @param {number} val\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.increment = function(k, val) {\r\n>   let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n>   for(let i=0;i<n;i++){\r\n>     this.stack[i] += val;\r\n>   }\r\n> };\r\n> \r\n> /**\r\n>  * Your CustomStack object will be instantiated and called as such:\r\n>  * var obj = new CustomStack(maxSize)\r\n>  * obj.push(x)\r\n>  * var param_2 = obj.pop()\r\n>  * obj.increment(k,val)\r\n>  */\r\n> ```\r\n> \r\n> ### 复杂度\r\n> 时间: push/pop 都为O(1), increment需要O(k)\r\n> 空间: O(N) 一个栈的长度\r\n\r\n\r\n> @A-pricity\r\n> ```\r\n> /**\r\n>     利用数组来模拟栈\r\n>     注意：\r\n>         1.当栈元素个数等于 maxSize 时不允许继续入栈；\r\n>         2.当栈为空时，出栈操作返回 -1；\r\n>         3.当栈非空，出栈操作发返回栈顶值\r\n>         4.增量操作时，当栈元素多于 k 个，将栈底的 k 个元素都加 val，栈元素少于 k 个时将所有元素都加上 val。\r\n> \r\n>  */\r\n> /**\r\n>  * @param {number} maxSize\r\n>  */\r\n> var CustomStack = function(maxSize) {\r\n>     this.list = []\r\n>     this.maxSize = maxSize\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} x\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.push = function(x) {\r\n>     if(this.list.length < this.maxSize){\r\n>         this.list.push(x)\r\n>     }\r\n> };\r\n> \r\n> /**\r\n>  * @return {number}\r\n>  */\r\n> CustomStack.prototype.pop = function() {\r\n>     const item = this.list.pop()\r\n>     return item === void 0 ? -1 : item\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} k \r\n>  * @param {number} val\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.increment = function(k, val) {\r\n>     for (let i = 0; i < k && i < this.list.length; i++) {\r\n>         this.list[i] += val\r\n>     }\r\n> };\r\n> \r\n> /**\r\n>  * Your CustomStack object will be instantiated and called as such:\r\n>  * var obj = new CustomStack(maxSize)\r\n>  * obj.push(x)\r\n>  * var param_2 = obj.pop()\r\n>  * obj.increment(k,val)\r\n>  */\r\n> ```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304972654","body":"## 思路\n\n1. 获取单链表的倒数第N + 1 与倒数第N个节点\n2. 将倒数第N + 1个节点的next指向null\n3. 将链表尾节点的next指向head\n4. 返回倒数第N个节点\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head\n    let count = 0, now = head\n    while(now){\n        now = now.next\n        count++\n    }\n    k = k % count\n    let fast = head, slow = head;\n    while (fast.next) {\n        if (k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```\n\n## 复杂度分析\n\n时间复杂度：$O(N)$\n空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306517484","body":"\r\n### 代码\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n    const dummy = new ListNode(null, head);\r\n    let prev = dummy;\r\n    let cur = prev.next;\r\n\r\n    while (cur && cur.next) {\r\n        const next = cur.next;\r\n        cur.next = next.next;\r\n        next.next = cur;\r\n        prev.next = next;\r\n\r\n        prev = cur;\r\n        cur = cur.next;\r\n    }\r\n    return dummy.next;\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308356933","body":"\n ### 思路\n\n \n ### 代码\n ```javascript\n var sortedListToBST = function(head) {\n     var makeTree = function(head, tail){\n         if(head === tail) return null;\n         const middleNode = getMiddleNode(head, tail);\n         const node = new TreeNode(middleNode.val);\n         node.left = makeTree(head, middleNode);\n         node.right = makeTree(middleNode.next, tail);\n         return node;\n     }\n \n     return makeTree(head, null);\n };\n \n var getMiddleNode = function(head, tail) {\n     if (!head) return null;\n     let fast = head;\n     let slow = head;\n     while (fast !== tail) {\n         fast = fast.next\n         if(fast!== tail){\n             fast = fast.next\n             slow = slow.next;\n         }\n     }\n     return slow;\n }; \n ```\n ### 复杂度\n 时间：O(nlogn) 递归logn次，每次遍历链表\n 空间：O(logn)  递归栈空间\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311429658","body":"## 思路\n- 遍历整个链表,同时将每个节点都插入哈希表,\n- 如果当前节点在哈希表中不存在,继续遍历,\n- 如果存在,那么当前节点就是环的入口节点\n\n```js\nlet data = new Set();\nwhile (head) {\n  if (data.has(head)) {\n    return head;\n  } else {\n    data.add(head);\n  }\n  head = head.next;\n}\nreturn null;\n```\n\n## 复杂度分析\n\n时间复杂度：$O(N)$\n空间复杂度：$O(N)$\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313352395","body":"\n\n## 思路\n比较两棵树的结构，可以对两棵树同时进行层级遍历，在遍历中比较节点，如果有不同的节点就提前退出。\n\n需要注意的是遍历过程中空节点也要入列。\n\n## 代码\nJavaScript Code\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    const queueP = [p];\n    const queueQ = [q];\n\n    while (queueP.length && queueQ.length) {\n        let lenP = queueP.length;\n        let lenQ = queueQ.length;\n\n        // 如果两棵树同一层的节点数都不同，肯定不是同一棵树\n        if (lenP !== lenQ) return false;\n\n        while (lenP-- && lenQ--) {\n            const nodeP = queueP.shift();\n            const nodeQ = queueQ.shift();\n\n            // 两个节点都是 null, 直接继续比较下一个节点\n            if (!nodeP && !nodeQ) continue;\n            // 遇到不同的节点，说明不是同一棵树，提前返回\n            if (!nodeP || !nodeQ || nodeP.val !== nodeQ.val) return false;\n\n            // 将下一层的节点入列，空节点也要入列\n            queueP.push(nodeP.left, nodeP.right);\n            queueQ.push(nodeQ.left, nodeQ.right);\n        }\n    }\n    return true;\n};\n```\n\n## 复杂度分析\n时间复杂度：$O(N)$，N 为二叉树的节点数。\n空间复杂度：$O(logN)$，N 为二叉树的节点数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298004206","body":"### 思路\n\n1、先转成数字再相加，遇到大数直接溢出了\n2、逐位相加\n\n### 代码\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int,0)\n    // 逐位相加\n    for i := len(num) - 1; i>=0; i--{\n        sum := num[i] + k % 10\n        k /= 10\n        if sum >= 10 {\n            k++ // 进位\n            sum -= 10 // 减掉 10\n        }\n        res = append(res, sum)\n    }\n    for k != 0 { // 如果有剩余的接着加\n        res = append(res, k % 10)\n        k /= 10\n    }\n\n    // reverse\n    for i:=0; i<len(res) /2; i++ {\n        res[i], res[len(res)-i-1] = res[len(res) - i -1], res[i]\n    }\n\n    return res\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1303783495","body":"### 思路\r\n\r\n遍历记录\r\n\r\n### 代码\r\n\r\n```go\r\n\r\nimport \"math\"\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tcslice := make([]int, 0)\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == c {\r\n\t\t\t// 记录 index\r\n\t\t\tcslice = append(cslice, i)\r\n\t\t}\r\n\t}\r\n\r\n\tvar getMin func(index int) int\r\n\tgetMin = func(index int) int {\r\n\t\tans := math.MaxInt64\r\n\t\tfor i := 0; i < len(cslice); i++ {\r\n\t\t\tans = getMinValue(getAbs(cslice[i], index), ans)\r\n\t\t}\r\n\r\n\t\treturn ans\r\n\t}\r\n\r\n\tres := make([]int, 0)\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tres = append(res, getMin(i))\r\n\t}\r\n\r\n\treturn res\r\n}\r\n\r\nfunc getMinValue(a, b int) int {\r\n\tif a > b {\r\n\t\treturn b\r\n\t}\r\n\treturn a\r\n}\r\n\r\nfunc getAbs(a, b int) int {\r\n\tif a-b > 0 {\r\n\t\treturn a - b\r\n\t}\r\n\treturn b - a\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302260513","body":"### 思路\n\n数组实现\n\n### 代码\n\n```go\n// 使用数组实现即可\n\ntype CustomStack struct {\n\tnums []int\n\tsize int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tnums: make([]int, 0),\n\t\tsize: maxSize,\n\t}\n}\n\nfunc (c *CustomStack) Push(x int) {\n\tif len(c.nums) >= c.size {\n\t\tlog.Println(\"size overflow\")\n\t\treturn\n\t}\n\n\tc.nums = append(c.nums, x)\n\treturn\n}\n\nfunc (c *CustomStack) Pop() int {\n\tif len(c.nums) <= 0 {\n\t\treturn -1\n\t}\n\tlength := len(c.nums)\n\tvalue := c.nums[length-1]\n\tc.nums = c.nums[:length-1]\n\treturn value\n}\n\nfunc (c *CustomStack) Increment(k int, val int) {\n\tif k > len(c.nums) {\n\t\tk = len(c.nums)\n\t}\n\tfor i := 0; i < k; i++ {\n\t\tc.nums[i] += val\n\t}\n\treturn\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n\n```\n\n\n### 复杂度分析\n\n- 时间复杂度：push: O(1), pop: O(1), inc: O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303610428","body":"### 思路\r\n\r\n用栈实现\r\n\r\n### 代码\r\n\r\n```go\r\npackage issue9\r\n\r\nimport (\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\nfunc decodeString(s string) string {\r\n\tptr := 0\r\n\tvar stk []string\r\n\r\n\tvar getDigits func() string\r\n\tgetDigits = func() string {\r\n\t\t// 获取数字\r\n\t\tret := \"\"\r\n\t\tfor ; s[ptr] >= '0' && s[ptr] <= '9' && ptr < len(s); ptr++ {\r\n\t\t\tret += string(s[ptr])\r\n\t\t}\r\n\t\treturn ret\r\n\t}\r\n\r\n\tvar getString func(v []string) string\r\n\tgetString = func(v []string) string {\r\n\t\treturn strings.Join(v, \"\")\r\n\t}\r\n\r\n\tfor ptr < len(s) {\r\n\t\tcur := s[ptr]\r\n\t\tif cur >= '0' && cur <= '9' { // 获取数字\r\n\t\t\tdigits := getDigits()\r\n\t\t\tstk = append(stk, digits)\r\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n\t\t\tstk = append(stk, string(cur))\r\n\t\t\tptr++\r\n\t\t} else { // 右花括号\r\n\t\t\tvar sub []string\r\n\t\t\tfor stk[len(stk)-1] != \"[\" {\r\n\t\t\t\tsub = append(sub, stk[len(stk)-1])\r\n\t\t\t\tstk = stk[:len(stk)-1] // 出栈\r\n\t\t\t}\r\n\t\t\tstk = stk[:len(stk)-1] // 将 \"[\" pop 出栈\r\n\t\t\t// 逆序\r\n\t\t\tfor i := 0; i < len(sub)/2; i++ {\r\n\t\t\t\tsub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\trepTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n\t\t\tstk = stk[:len(stk)-1] // 将数字 pop 出栈\r\n\t\t\tt := strings.Repeat(getString(sub), repTime)\r\n\t\t\tstk = append(stk, t) // 重新入栈\r\n\t\t\tptr++\r\n\t\t}\r\n\t}\r\n\r\n\treturn getString(stk)\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298039156","body":"思路\r\n1. 把array转成数字，然后加k，stackoverflow\r\n2. 从后往前加，用tenth表示进位。Edge case如果K的digit数比array大，剩下的要加入进去。Tenth又变成edgecase，如果K剩下的加进去还要在check一遍if tenth==1.\r\n3. 在变k的时候把进位加上去，即 k/10 + tenth\r\n\r\n代码\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<Integer>();\r\n        int tenth =0;\r\n        for(int i=num.length-1; i>=0; i--){\r\n            int curr = k%10 + num[i];\r\n            tenth =  curr/10;\r\n            k=k/10 + tenth;\r\n            result.add(0, curr %10);\r\n        }\r\n        while(k !=0){\r\n            int curr = k%10;\r\n            tenth =  curr/10;\r\n            k=k/10 + tenth;\r\n            result.add(0, curr %10);\r\n        }\r\n\r\n        return result; }\r\n```\r\n复杂度分析\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299363320","body":"思路\r\n1. 用一个list继续 index of c，然后用双指针。Time O(N), Space O(n)\r\n2. 左边遍历一边，右边便利一遍，取min\r\n3. 初试min只设置一个就好了，不用左右都设置，数字可以取10001，因为prompt说s.length最大是10^4\r\n\r\n代码\r\n```\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int prev = 10001;\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = Math.abs(i- prev);\r\n            \r\n        }\r\n        prev = 10001;\r\n        //System.out.println(Arrays.toString(answer));\r\n        for(int i=s.length()-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //System.out.println(right);\r\n            answer[i] = Math.min(answer[i], Math.abs(i - prev));\r\n        }\r\n        return answer;\r\n    }\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)， N  = 字符串的长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302316149","body":"思路\r\n1. 最开始使用arraylist，后来发现array才是最简便的\r\n2. 用一个tail variable keep track stack size\r\n3. stack bottom是array的0，top是最后，别搞反了\r\n代码\r\n```\r\nclass CustomStack {\r\n    int tail;\r\n    int[] arr;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        tail =-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail >= arr.length-1){\r\n            return;\r\n        }\r\n        tail++;\r\n        arr[tail] = x;        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail<0){\r\n            return -1;\r\n        }\r\n        int val = arr[tail];\r\n        tail--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        //System.out.println(arr);\r\n        int threshold = Math.min(arr.length, k);\r\n\r\n        for(int i=0; i<threshold; i++){\r\n            arr[i]+=val;\r\n        }\r\n        //System.out.println(arr);\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n时间：push 和pop是O(1)，inc是O(K)\r\n空间：O(N) N代表maxsize\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303000815","body":"思路\r\n1. 用了一种非常离谱非常麻烦的方法，一个栈记录数字，一个栈记录letter，遇到 \"]\"时pop出repeat string，再pop一个数字做repeat, 有很多edge case，比如如何check是数字，check两个栈的size\r\n2. java 好像对双引号or单引号很敏感，单引号的时候做character比较会有error\r\n代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        String str = \"\";\r\n        Stack<String> letter = new Stack<>();\r\n        Stack<Integer> nums = new Stack<>();\r\n        String num = \"\";\r\n        for(int i=0; i<s.length(); i++){\r\n            \r\n            \r\n            if(Character.isDigit(s.charAt(i))){\r\n                num= num + s.charAt(i);\r\n                System.out.println(\"[get num \" + num);\r\n            }else if(s.charAt(i) == '['){\r\n                if(num.length()>0){\r\n                    nums.push(Integer.parseInt(num));\r\n                    System.out.println(\"[[nums push \"+ Integer.parseInt(num));\r\n                    num = \"\";\r\n                }\r\n                \r\n                letter.push(\" \");\r\n            }else if(s.charAt(i) == ']'){\r\n                String sub = \"\";\r\n                while(letter.peek() != \" \"){\r\n                    sub = letter.pop() + sub;\r\n                }\r\n                letter.pop();\r\n                if(nums.size() >0){\r\n                    letter.push(sub.repeat(nums.pop()));\r\n                    System.out.println(\"repeat \"+ sub);\r\n                }else{\r\n                    letter.push(sub);\r\n                    System.out.println(\"purer push \"+ sub);\r\n                }\r\n                \r\n            }else{\r\n                letter.push(String.valueOf(s.charAt(i)));\r\n                System.out.println(\"final else\"+ s.charAt(i));\r\n            }\r\n        }\r\n        while(!letter.isEmpty()){\r\n            str=  letter.pop() + str;\r\n        }\r\n        return str;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304422600","body":"思路\r\n1.用两个stack，一个是正常的stack用来加push的东西，一个是reverseStack，pop的顺序会和queue一样\r\n2.如果reverse stack里面有东西，优先peek or pop reverse stack里的东西。\r\n3.如果reverse stack里没有东西了，先把stack里面的element放进去，再peek or push\r\n\r\n代码\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> reverseStack;\r\n    public MyQueue() {\r\n        stack = new Stack<>();\r\n        reverseStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!reverseStack.isEmpty()){\r\n            return reverseStack.pop();\r\n        }\r\n        while(stack.size() >1){\r\n            reverseStack.push(stack.pop());\r\n        }\r\n        return stack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(!reverseStack.isEmpty()){\r\n            return reverseStack.peek();\r\n        }\r\n        while(!stack.isEmpty()){\r\n            reverseStack.push(stack.pop());\r\n        }\r\n        return reverseStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return reverseStack.isEmpty() && stack.isEmpty();\r\n    }\r\n}\r\n```\r\n复杂度\r\n时间： push O(1), pop和peek不确定，我感觉average也是O(1）？\r\n空间： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304831846","body":"思路\r\n1. sort array，如果他能单独分块，那么在这之前的element是和sorted一样\r\n\r\n代码\r\n```\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // deep copy\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int result = 0;\r\n        int nonZero =0;\r\n        for(int i=0; i<arr.length; i++){\r\n            int x = arr[i];\r\n            int y = sorted[i];\r\n            \r\n            map.put(x, map.getOrDefault(x,0)+1);\r\n            if(map.get(x) ==0){\r\n                nonZero--;\r\n            }\r\n            if(map.get(x)==1){\r\n                nonZero++;\r\n            }\r\n            map.put(y, map.getOrDefault(y,0)-1);\r\n            if(map.get(y) ==0){\r\n                nonZero--;\r\n            }\r\n            if(map.get(y)==-1){\r\n                nonZero++;\r\n            }\r\n            \r\n            if(nonZero ==0){\r\n                result++;\r\n            }\r\n            \r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\nO（N）\r\nO（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305222973","body":"思路\r\n1. 和求单链表的倒数第 N 个节点很像\r\n2. loop一遍找到list的length和tail node\r\n3. 除了k遍以后list不变，其他的case都是tail node连接到head node，所以我们唯一需要找的就是那一个node.next变成null了\r\n4. 返回的时候除了list不变的情况，返回的是prev.next的值，记得先存一下\r\n代码\r\n```\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head ==null) return head;\r\n        ListNode curr = head;\r\n        ListNode prev = null;\r\n        ListNode tail =null;\r\n        ListNode result = null;\r\n        int count = 0;\r\n        while(curr !=null){\r\n            tail = curr;\r\n            curr=curr.next;\r\n            count++;\r\n        }\r\n        int rotate = count - k % count;\r\n        curr = head;\r\n        for(int i=0; i<rotate; i++){\r\n            prev = curr;\r\n            curr = curr.next;\r\n        }\r\n        result = head;\r\n        if(prev != null){\r\n            tail.next= head;\r\n            result = prev.next;\r\n            prev.next = null;\r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\n时间 O(N)\r\n空间O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308324575","body":"思路\r\n1.用slow,fast pointer找到linkedlist最中间的数字作为root\r\n2.recursive on left right\r\n3. 区间为[head,tail), tail 不算在里面\r\n4. base case为head==tail，tail初始为null\r\n代码\r\n```\r\npublic TreeNode helper(ListNode head, ListNode tail){\r\n        if(head ==tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast.next != tail && fast.next.next !=tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(head, slow);\r\n        root.right = helper(slow.next, tail);\r\n        \r\n        return root;\r\n            \r\n    }\r\n```\r\n复杂度分析\r\n时间O（NlogN）一共logN level，树的高度 每一个level traverse 的node加起来traverse N次，所以是nlogn\r\n空间O（logn）因为是height-balanced ，树的高度为logn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310000166","body":"思路\r\n1. l1->l2, l2->l1 如果有重合说明又intersect，否则没有\r\n代码\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        \r\n        while(p1 != p2){\r\n            if(p1 ==null){\r\n                p1 = headB;  \r\n            }else{\r\n                p1 = p1.next;\r\n            }\r\n            if(p2 ==null){\r\n                p2 = headA;\r\n                \r\n            }else{\r\n                p2 = p2.next;\r\n            }\r\n            \r\n            \r\n        }\r\n        return p1;\r\n    }\r\n}\r\n复杂度分析\r\n时间 O(M+N) 两个list长度\r\n空间 O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311873459","body":"思路\r\n1.hashset存，check之前有没有\r\n2. two pointers，需要一点点数学prove\r\n代码\r\n```\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast !=null && fast.next !=null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(slow == fast){\r\n                break;\r\n            }\r\n        }\r\n        if(fast == null || fast.next==null){\r\n            return null;\r\n        }\r\n        \r\n        fast = head;\r\n        while(fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n```\r\n复杂度分析\r\n时间 O（N）\r\n空间 O（1）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312658813","body":"思路\r\n1. base case： root是null， height为0\r\n2. recursive case： 找到left 和right的height， root height = Math.max(left, right)+1\r\n代码\r\n```\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        int left = maxDepth(root.left)+1;\r\n        int right = maxDepth(root.right)+1;\r\n        \r\n        return Math.max(left, right);\r\n    }\r\n```\r\n复杂度分析\r\n时间O(N)，iterate through 每一个node\r\n空间O(N)，recurive worst case，tree look like a single linkedlist，stack上压了n个node","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298054211","body":"# 思路\n从后往前逐个相加\n# 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n - 1;i >= 0;i--){\n            int a = num[i] + k % 10; // 得到k的个位\n            k /= 10; //去掉k的个位\n            if(a >= 10){\n                k++; // k的十位  + 1\n                a -= 10; // 进位之后a得-10\n            }\n            res.add(a);\n        }\n        for(;k > 0;k /= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300463292","body":"# 思路\n数组的两次遍历，s[i]到c左右两侧的最近距离 左-右\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] arr = new int[n];\n        int index = -n;   // 给一个较大的值，用于辅助标记 c 的位置\n        for(int i = 0 ; i < n;i++){\n            if(s.charAt(i) == c) // s当前下标的数字== c\n                index = i;\n            arr[i] = Math.abs(i - index); // 数组中存的为 相对与index（-n）的位置\n        }\n        for(int i = n - 1; i >= 0;i--){\n            if(s.charAt(i) == c)\n                index = i;\n            arr[i] = Math.min(arr[i], Math.abs(i - index)); // 矫正位置信息\n        }\n        return arr;\n    }\n}\n```\n# 复杂度\n- 时间：o(n)  遍历字符串s\n- 空间：o(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302017173","body":"# 思路\n  让栈中元素可见：设置栈顶top\n# 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303750267","body":"# 思路\n字符串 + 栈\n# 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        // 遍历字符串（转char字符串）\n        for(char c : s.toCharArray()){\n            if(c != ']'){ // 没到最后就一直向栈中压\n                stack.push(c);\n            }else{\n                // 数组中的数已经全部进栈，取出字符串\n                StringBuilder sb = new  StringBuilder();\n                // 看栈中是不是字母\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0,stack.pop());\n                \n                String s1 = sb.toString();\n                stack.pop(); // 此时栈中就剩下一个‘[’,弹出\n\n                // 获取倍数\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                     sb.insert(0,stack.pop());\n                }\n                   \n\n               int count = Integer.valueOf(sb.toString());  // 倍数\n\n                // 将倍数 x 字符\n                while(count  > 0 ){\n                    for(char c1 : s1.toCharArray()){\n                        stack.push(c1);\n                    }\n                    count--;\n                    }\n                }\n        }\n        // 将栈中数据取出\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty())\n            res.insert(0,stack.pop());\n        return res.toString();\n    }\n}\n    \n```\n# 复杂度\n- 时间 o(n)\n- 空间 o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561267","body":"#### 思路\n> 理解栈先进后出的特性\n#### 代码\n```java\nclass MyQueue {\n\n    Stack<Integer> stackIn;\n    Stack<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new Stack<>(); // 负责进栈\n        stackOut = new Stack<>(); // 负责出栈\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {    \n        dumpstackIn();\n        return stackOut.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        dumpstackIn();\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n\n    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中\n    private void dumpstackIn(){\n        if (!stackOut.isEmpty()) return; \n        while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n        }\n    }\n}\n\n```\n#### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304825468","body":"#### 思路\n> 单调栈\n#### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr){\n            if(!stack.isEmpty() && num < stack.getLast()){\n                int cur = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            }else{\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}  \n```\n#### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305743764","body":"# 思路\n>  快慢指针\n>  关键点：k = k % 链表长度\n# 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode ct = head;\n        while(ct != null){ // 对head中的元素计数\n            ct = ct.next;\n            count++;\n        }\n        k = k % count;\n        ListNode low = head;\n        ListNode fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                low = low.next;   \n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = low.next;\n        low.next = null;\n\n        return res;\n    }\n \n}\n```\n# 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307407059","body":"### 思路\n>  关注最小子结构 递归\n### 代码\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        // 递归调用\n       ListNode cur = head.next;\n       head.next = swapPairs(cur.next); // 1-->(4-->3)\n       cur.next = head; // 2-->1\n       return cur;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308977409","body":"### 思路\n> 快慢指针找中点（根），中点左侧为左子树，右侧为右子树；递归调用\n### 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        //判断链表是否为空\n        if(head == null) return null;\n        return dfs(head,null);\n    }\n    private TreeNode dfs(ListNode head,ListNode tail){\n        // 终止条件\n        if(head == tail) return null;\n        // 定义快慢指针\n        ListNode fast = head;\n        ListNode low = head;\n        // 快指针一次跳2下 慢指针跳一下\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            low = low.next;\n        }\n        TreeNode root = new TreeNode(low.val);\n        root.left = dfs(head,low);\n        root.right = dfs(low.next,tail);\n        return root;\n    }\n}\n\n```\n### 复杂度\n- 时间：o(nlogn)\n- 空间：o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309992882","body":"### 思路\n> 双指针 \n指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：\na+(b−c) \n指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：\nb+(a−c) \n如下式所示，此时指针 A , B 重合，并有两种情况：\n a + (b - c) = b + (a - c)\n若两链表 有 公共尾部 (即 c>0 ) ：指针 A , B 同时指向「第一个公共节点」node 。\n若两链表 无 公共尾部 (即 c=0 ) ：指针 A , B 同时指向 null\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n      // 双指针\n      ListNode A = headA,B = headB;\n      while( A != B){\n          A = A != null ? A.next : headB;\n          B = B != null ? B.next : headA;\n      }\n      return A;\n    }\n}\n\n\n```\n### 复杂度\n- 时间：o(n)   o(a+ b)\n- 空间：o(1)   常数空间的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311722014","body":"### 思路\n> 快慢指针，找到交点之后，将快指针放回head，步长变1\n### 代码\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode fast = head;\n        ListNode low = head;\n        while(fast != null){\n            low = low.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }else{\n                return null;\n            }\n            if(fast == low){\n                ListNode fast1 = head;\n                while(fast1 != low){\n                    fast1 =fast1.next;\n                    low = low.next;\n                }\n                return fast1;\n            }\n        }\n        return null;\n      \n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312473582","body":"### 思路\n>  哈希表，双向链表\n### 代码\n```java\n class LRUCache {\n    class DLinkedNode{\n        int key,value;\n        DLinkedNode prev,next;\n        public DLinkedNode(){}\n        public DLinkedNode(int key1,int value1){\n            key = key1;\n            value = value1;\n        }\n    }\n    private Map<Integer,DLinkedNode> cache = new HashMap<Integer,DLinkedNode>();\n    private int size,cap;\n    private DLinkedNode head,tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n         DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n       \n        moveToHead(node);\n        return node.value;\n\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n\n    }\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;                       \n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n   \n```\n### 复杂度\n- 时间：o(1)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312727466","body":"### 思路\n> 递归\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        return Math.max(maxDepth(root.right),maxDepth(root.left)) + 1;\n    }\n}\n```\n### 复杂度\n- 时间:o(n) n为节点数\n- 空间:o(n) n为节点数，此时树退化为链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313116393","body":"### 思路\n> 递归 \n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }else if(p == null || q == null){\n            return false;\n        }\n        if(q.val != p.val){\n            return false;\n        }\n        return isSameTree(q.left,p.left) && isSameTree(p.right,q.right);\n\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(n)   n为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315265421","body":"### 思路\n> 递归，dfs\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int ans;\n    public int sumNumbers(TreeNode root) {\n        dfs(root,0);\n        return ans;       \n    }\n    public void dfs(TreeNode root,int last){\n        \n        if(root == null) return;\n        if(root.left == null && root.right == null){\n            ans += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left,last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n\n```\n### 复杂度\n- 空间：o(n)其中 n 是二叉树的节点个数。对每个节点访问一次。\n- 时间：o(n)其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317113630","body":"### 思路\n> dfs 用一个数去接收最后的值\n### 代码\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int curheight = 0;\n    int val = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        int curheight = 0;\n        dfs(root,0);\n        return val;\n    }\n    public void dfs(TreeNode root,int height){\n        if(root == null) return;\n        height++;\n        dfs(root.left,height);\n        dfs(root.right,height);\n        if(height > curheight){\n            curheight = height;\n           val =  root.val;\n        }\n    }\n}\n```\n\n### 复杂度\n- 空间：O(n)\n- 时间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318811406","body":"### 思路\n> 序列化：将空节点当做普通节点入队即可\n> 反序列化：使用三个指针指向数组（bfs）的1 2 3 p1指针每次移动1步，p2、p3每次移动2位\n    p1.left = p2 ; p1.right = p3\n### 代码\n```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n\n   \n```\n### 复杂度\n- 时间：o(N) n为节点数\n- 空间：o(n) n为树的节点总数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319884753","body":"### 思路\n> dfs + 哈希表 + 排序\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n      // x {y : [val,val,...]}\n    Map<TreeNode,int[]> map = new  HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n    map.put(root, new int[]{0,0,root.val}); // root的位置为（0,0,val）\n       // 坐标集合以 x 坐标分组\n     // dfs 遍历节点并记录每个节点的坐标\n    dfs(root);\n    List<int[]> list = new ArrayList<>(map.values());\n  // 得到所有节点坐标后，先按 x 坐标升序排序\n    // 再给 x 坐标相同的每组节点坐标分别排序\n    // y 坐标相同的，按节点值升序排\n      // 否则，按 y 坐标降序排\n    Collections.sort(list,(a,b)->{  // lamda表达式定义排序规则\n        if(a[0] != b[0]) return a[0] - b[0];\n        if(a[1] != b[1]) return a[1] - b[1];\n        return a[2] - b[2];\n    });\n    int n = list.size();\n    List<List<Integer>> ans = new ArrayList<>();\n    // 将list中的值放到ans中\n     for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) \n                tmp.add(list.get(j++)[2]);\n            ans.add(tmp);\n            i = j;\n        }\n    return ans;\n    }\n    public void dfs(TreeNode root){\n        if(root == null) return;\n        int[] arr = map.get(root);\n        //初始化 x ，y\n        int x = arr[0];\n        int y =  arr[1];\n        int val = arr[2];\n        if(root.left != null){\n            // 坐标迭代\n            map.put(root.left,new  int[]{x - 1,y + 1,root.left.val});\n            dfs(root.left);\n        }\n         if(root.right != null){\n            map.put(root.right,new int[]{x + 1,y + 1,root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n    \n```\n### 复杂度\n- 时间：o(NlogN)   \n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320882414","body":"### 思路\n> 哈希表   target-num\n### 代码\n```java\n class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // 哈希表\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0;i < nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]),i};\n            }\n            map.put(target - nums[i],i);\n        }\n        return new int[]{};\n    }\n}   \n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321160057","body":"### 思路\n> 哈希表 + 堆排序\n### 代码\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n// 哈希表  + 将每个数及其对应的个数放进去\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int  num : nums){\n            map.put(num,map.getOrDefault(num,0) + 1);// 有相同的数就+ 1\n        }\n        // 堆\n        PriorityQueue<int[]> queue =  new PriorityQueue<int[]>(new Comparator<int[]>(){\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];  // 定义比较器规则：出现次数多的在前面\n            }\n        });\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){ // 将map中的值对应起来放在set中\n            int num = entry.getKey(), count = entry.getValue();\n            if(queue.size() == k){ //有k个\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            }else{\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        //将堆中的数组的num放在ret中\n        for(int i = 0;i < k; i++){\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n```\n### 复杂度\n- 时间：o(nlogn)  n为数组长度\n- 空间：o(n)  n为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322222948","body":"### 思路\n> 哈希表 \n\t两点间距离计算方法\n\t排列组合 \n### 代码\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n            for (int[] q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int m = entry.getValue();\n                ans += m * (m - 1); \n            }\n        }\n        return ans;\n    }\n}\n\n```\n### 复杂度\n- 时间：o(n²)  n为数组长度\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323705850","body":"### 思路\n> 哈希表 + 滑动窗口\n### 代码\n```java\nclass Solution {\n    \n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<Character>();\n        int n = s.length();\n        // 右指针  -1 \n        int rightK = -1, ans = 0;\n        // i 为左指针\n        for(int i = 0; i < n; ++i){\n            if(i != 0){\n                set.remove(s.charAt(i - 1));\n            }\n            while(rightK + 1 < n && !set.contains(s.charAt(rightK + 1))){\n                set.add(s.charAt(rightK + 1));\n                ++rightK;\n            }\n            ans = Math.max(ans,rightK - i + 1);\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)   n为字符串长度\n- 空间：o(n)   n为字符集元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325284921","body":"### 思路\n> 哈希表 + 双指针 \n### 代码\n```java\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n \n```\n### 复杂度\n- 时间：o(n*m*k)\n- 空间：o(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326609020","body":"### 思路\n> 同余定理  +  前缀和\n### 代码\n```java\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> m;\n        m[0] = 1;\n        int sum = 0, ans = 0;\n        for(int i : nums) {\n            sum += i;\n            int mod = (sum % k + k) % k;   // 非负\n            if(m.count(mod)) {\n                ans += m[mod];\n            }\n            m[mod]++;\n        }\n        return ans;\n    }\n};\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327622332","body":"```java\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new IllegalArgumentException(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        ListNode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new ListNode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        ListNode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"NULL\");\n        return s.toString();\n    }\n}\n\npublic class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        ListNode head = new ListNode(arr);\n        Solution solution = new Solution();\n        ListNode res = solution.middleNode(head);\n        System.out.println(res);\n    }\n}\n```\n- 时间复杂度：o(n)\n- 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328065918","body":"### 思路\n> 读写双指针\n### 代码\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        // 读p写p1指针\n        int p = 0, p1 = 0;\n        while(p1 < nums.length){\n            if(nums[p] != nums[p1]){\n                p++;\n                nums[p] = nums[p1];\n            }\n            p1++;\n        }\n        return p + 1;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328269644","body":"### 思路\n> 二分\n### 代码\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        // 二分\n        if(nums.length == 0) return -1;\n        int left = 0,right = nums.length -1; // 指针指向下标\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(target < nums[mid]){\n                right = mid - 1;\n            }else if(target > nums[mid]){\n                left = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return left;\n    }\n}\n```\n### 复杂度\n- 时间：o(logn)   n为数组长度\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329106318","body":"### 思路\n> 数组--->双端队列（移除 超出窗口范围的数索引`大于 i - k + 1的元素` + `如果小于当前元素就出队列`）\n### 代码\n```java\n    class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        //创建滑动窗口个数的数组\n        int[] ans = new int[nums.length - k + 1];\n        //创建双端队列\n        Deque<Integer> deque = new ArrayDeque<>();\n\n        for(int i = 0;i < nums.length;i++){\n\n            if(!deque.isEmpty() && deque.peekFirst() + k <= i) deque.pollFirst();\n            while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            deque.offerLast(i);//队列尾部添加元素\n            if(i - k + 1 >= 0) ans[i-k+1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330669911","body":"### 思路\n> 找到入度为 n-1 出度为0的点\n易错点： 从1到n编号\n### 代码\n```java\n class Solution {\n    public int findJudge(int n, int[][] trust) {\n       int[] arr =  new int[n + 1];\n       for(int[] eg : trust){\n           int x = eg[0];\n           int y = eg[1];\n           arr[y]++;\n           arr[x]--;\n       }\n       for(int i = 1;i < n+1;i++){\n           if(arr[i] == n - 1){\n               return i;\n           }\n       }\n       return -1;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)  n为数组长度\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332315403","body":"```java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int N, int[][] dislikes) {\n        graph = new ArrayList[N+1];\n        for (int i = 1; i <= N; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0))\n                return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node))\n            return color.get(node) == c;\n        color.put(node, c);\n\n        for (int nei: graph[node])\n            if (!dfs(nei, c ^ 1))\n                return false;\n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333949739","body":"```java\nclass Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335383632","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for(char m : moves.toCharArray()){\n            if(m == 'R'){\n                x++;\n            }else if(m == 'L'){\n                x--;\n            }else if(m == 'U'){\n                y++;\n            }else if(m == 'D'){\n                y--;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298075373","body":"> # 思路\n> 从后往前逐位将数字加在一起,若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中.\n> # 代码\n> ```c++\n>class Solution {\n>public:\n>    vector<int> addToArrayForm(vector<int>& num, int k) {\n>       vector<int> res;\n>\n>      int n = num.size();\n>       for (int i = n - 1; i >= 0; --i) {\n>            int sum = num[i] + k % 10;\n>            k /= 10;\n>           if (sum >= 10) {\n>                k++;\n>               sum -= 10;\n>            }\n>           res.push_back(sum);\n>        }\n>        for (; k > 0; k /= 10) {\n>            res.push_back(k % 10);\n>       }\n>       reverse(res.begin(), res.end());\n>       return res;\n>      }\n>   }\n\n> ```\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299513514","body":"\n> \n> ## 思路\n> 1、从当前下标出发，分别向左、右两个方向去寻找目标字符c  \n> 2、只在一个方向找到的话，直接计算字符距离  \n> 3、两个方向都找到的话，取两个距离的最小值  \n> \n> ## 代码\n> ```c++\n> \n>class Solution {  \n>public:    \n>    vector<int> shortestToChar(string S, char C) {  \n>        vector<int> res(S.length());  \n>\n>        for (int i = 0; i < S.length(); i++) {  \n>            if (S[i] == C) continue;  \n>\n>            int left = i;  \n>           int right = i;  \n>            int dist = 0;  \n>\n>            while (left >= 0 || right <= S.length() - 1) {  \n>                if (S[left] == C) {   \n>                  dist = i - left;    \n>                    break;  \n>                }  \n>                if (S[right] == C) {  \n>                    dist = right - i;  \n>                   break;  \n>                }  \n>\n>              if (left > 0) left--;  \n>                if (right < S.length() - 1) right++;  \n>            }  \n>\n>            res[i] = dist;  \n>        }  \n>\n>        return res;  \n>    }  \n>};  \n> \n> ```\n> \n> ## 复杂度分析\n> n*n，n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301691388","body":"> ### 思路\n> 用 vector 模拟栈，使用一个数组去保存数字  \n> push和pop都要注意为空的边缘情况，并且k大小可能超过size  \n> ### 代码 (cpp)\n>```cpp  \n>class CustomStack {  \n>public:  \n>    int max;  \n>    vector<int>stack;  \n>    CustomStack(int maxSize) {  \n>       max=maxSize;  \n>    }  \n>    \n>    void push(int x) {  \n>        if(stack.size()<max){  \n>            stack.push_back(x);  \n >           return ;  \n>        }\n>    }\n>    \n >   int pop() {  \n>        if(stack.empty()){  \n>            return -1;  \n>        }  \n>        int val=stack.back();  \n>        stack.pop_back();  \n>        return val;  \n>    }\n>    \n>    void increment(int k, int val) {  \n>        for(int i=0;i<k&&i<stack.size();i++){  \n>            stack[i]+=val;  \n>        }  \n>        return ;  \n>    }  \n>  };     \n>```  \n> **复杂度分析**  \n> - 时间复杂度：O(N)  \n> - 空间复杂度：O(N)  \n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303528403","body":"> ### 思路\n> \n>  利用一个数字栈与一个符号栈来处理，首先遍历整个字符串，如果当前的字符为数字，字母或者左括号，直接进栈，如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，取出栈顶的数字，根据字符串构造出新的字符串并进栈\n> ### 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    string decodeString(string s) {     \n>        stack<int> st_num;   //数字栈  \n>        string symbol;    \n>        int num=0;   \n>        for(int i=0;i<s.size();i++)\n>        {\n>            if(s[i]>='0'&&s[i]<='9'){   \n>                num=s[i]-'0'+num*10;  \n>            }else if(s[i]=='['){      \n>                st_num.push(num);  \n >               num=0;  \n>                symbol+=s[i];  \n>            }else if(s[i]==']'){     \n>               int j=symbol.size()-1;  \n>                string tmp_string;  \n>                while(symbol[j]!='[')  \n>                {  \n>                    tmp_string+=symbol[j];  \n >                   symbol.pop_back();  \n>                    j--;  \n>                }  \n >               symbol.pop_back();  \n>                int tmp_num=st_num.top();  \n>                st_num.pop();  \n>                reverse(tmp_string.begin(),tmp_string.end());  \n>                for(int k=0;k<tmp_num;k++)  \n>                {  \n>                    symbol+=tmp_string;  \n>                }  \n>            }else{   \n>                symbol+=s[i];  \n>            }  \n>        }  \n>        return symbol;  \n>    }  \n> };   \n> ```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304518091","body":"> # 思路\n> \n> 将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n> \n> # 代码\n> ```C++\n>class MyQueue {  \n>public:  \n>    stack<int>stIn;  \n>    stack<int>stOut;  \n>    MyQueue() {  \n>\n>    }  \n>    \n>    void push(int x) {  \n>        stIn.push(x);  \n>    }  \n>    \n>    int pop() {  \n>      if(stOut.empty()){  \n>            while(!stIn.empty()){  \n>                stOut.push(stIn.top());  \n>               stIn.pop();  \n>            }  \n>        }  \n>        int result = stOut.top();  \n>        stOut.pop();  \n>        return result;  \n>    }  \n>    \n>    int peek() {  \n>        int res=this->pop();  \n>        stOut.push(res);  \n>        return res;  \n>\n>    }  \n>    \n>    bool empty() {  \n>       return  stOut.empty()&&stIn.empty();  \n>\n>    }  \n>};  \n> ```\n> # 复杂度分析\n> \n>- 时间复杂度：O(1)  \n>- 空间复杂度：O(n)   \n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304734667","body":"> ### 思路\n> 使用单调栈。我们可以用一个栈来存储这些分块的最大值。最后得到的栈的大小，也就是最多能完成排序的块。\n> \n> ### 代码\n> \n> ```c++  \n>class Solution {  \n>public:  \n>    int maxChunksToSorted(vector<int>& arr) {  \n>        stack<int> stk;  \n>        for (int& v : arr) {  \n>            if (stk.empty() || stk.top() <= v)  \n>                stk.push(v);  \n>            else {  \n>                int mx = stk.top();  \n>              stk.pop();  \n>                while (!stk.empty() && stk.top() > v) stk.pop();  \n>                stk.push(mx);  \n>            }  \n>        }  \n>        return stk.size();  \n>    } \n> };   \n> ```\n> \n> **复杂度分析**\n> \n> - 时间复杂度：O(n)\n> - 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305353026","body":"> # 思路\n>  首先遍历整个链表，求出链表的长度n，并找出链表的尾节点tail。  \n> 令 k = k % n，然后再次从头节点head开始遍历，找到第n - k个节点p，那么1 ~ p是链表的前 n - k个节点，p+1 ~ n是链表的后k个节点。    \n>  将链表的后k个节点和前 n - k个节点拼接到一块，并让head指向新的头节点(p->next)，新的尾节点即p节点的next指针指向null。    \n> 最后返回链表的新的头节点head  \n>```c++\n>\n>class Solution {\n>public:  \n>    ListNode* rotateRight(ListNode* head, int k) {  \n>        if(!head || !k)  return head;  \n>        int n = 0;       \n>        ListNode* tail;   \n>        for(ListNode* p = head; p ; p = p->next){  \n>            tail = p;  \n>            n++;  \n>        }  \n>        k %= n;    \n>        ListNode* p = head;  \n>        for(int i = 0; i < n - k - 1; i++)   p = p->next;   \n>        tail->next = head;  \n>        head = p->next;  \n>        p->next = nullptr;  \n>        return head;  \n>    }\n> };   \n>```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306653224","body":"> # 思路\n>1、建立一个虚拟头结点 dummy  \n>2、定义p = dummy，a = p->next，b = a->next  \n>3、遍历整个链表,将p的next指针指向b,将a的next指向b->next,将b的next指向a.  \n> \n> # 代码\n> ```c++\n>class Solution {  \n>public:  \n>    ListNode* swapPairs(ListNode* head) {  \n>        ListNode*  dummy = new ListNode(-1);   \n>        dummy->next = head; \n>        for(auto p = dummy; p->next && p->next->next; )  \n>        {  \n>            auto a = p->next, b = a->next;  \n>           p->next = b;  \n>            a->next = b->next;   \n>            b->next = a;  \n>            p = a;  \n>        }  \n>        return dummy->next;  \n>    }  \n>  };  \n> ```\n> # 复杂度分析\n>- 时间复杂度O(n)  \n>- 空间复杂度O(n)   \n>\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308455876","body":"> ### 思路\n> 用两个指针，一块一慢，快的每次走两步，慢的每次走一步.这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的结点的值作为二叉搜索树当前结点的值.  \n>用pre指针指向慢指针指向的前一个位置，当每次使用完慢指针时，以便断开链表.  \n>\n> ### 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    TreeNode* sortedListToBST(ListNode* head) {  \n>       TreeNode* root;  \n>        if(!head) return NULL;   \n>        if(!head->next){   \n>            root = new TreeNode(head->val);  \n>            return root;  \n>        }   \n>        ListNode *slow = head;     \n>        ListNode *fast = head;     \n>        ListNode *prev = head;   \n>        while(fast != NULL && fast->next != NULL){   \n>            fast = fast->next->next;  \n>            slow = slow->next;  \n>       }  \n>        while(prev->next!=slow){   \n>            prev = prev->next;  \n>        }  \n>        root = new TreeNode(slow->val);  \n>        ListNode * right_head = slow->next;  \n>        prev->next = NULL;   \n>        root->left = sortedListToBST(head);  \n>        root->right = sortedListToBST(right_head);  \n>\n>        return root;  \n>    }  \n> };  \n> ```\n> \n> **复杂度分析**\n> - 时间复杂度：O(nlogn)\n> - 空间复杂度：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310043771","body":"> ### 思路\n>首先判断链表headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null  \n>当链表headA 和 headB 都不为空时，创建两个指针A 和 B，初始时分别指向两个链表的头节点headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。  \n>\n> \n> ```c++  \n> public class Solution {\n>      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {  \n>      if (headA == nullptr || headB == nullptr) {  \n>           return nullptr;  \n>        }  \n>      ListNode *A = headA, *B = headB;  \n>       while( A != B){  \n>          A = A != nullptr ? A->next : headB;  \n>          B = B != nullptr ? B->next : headA;  \n>       }  \n>       return A;  \n>     }  \n> };  \n> \n> \n> ```\n> ### 复杂度\n> - 时间复杂度:o(a+ b)  \n> - 空间复杂度:o(1)    \n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312304737","body":"> ## 基本思路：\n>双向链表加哈希  \n> \n>\n> ## 步骤：  \n> \n> 1. put：若key存在，则修改对应的value，同时将key对应的节点放到双链表的最左侧。若key不存在，那么在双链表的最左侧插入一个节点。如果超过容量，那么就删除双链表最右侧的节点。\n> 2. get：用哈希表判断key是否存在,若key存在，则返回对应的value，同时将key对应的节点放到双链表的最左侧，否则返回-1\n> \n> \n> \n> ## 代码：\n> \n> ```c++\n> class LRUCache {  \n>public:  \n>    struct Node{  \n>        int key,value;  \n>        Node* left ,*right;  \n>        Node(int _key,int _value): key(_key),value(_value),left(NULL),right(NULL){}  \n>    }*L,*R;  \n>    int n;  \n>    unordered_map<int,Node*>hash;  \n>    void remove(Node* p)  \n>    {  \n>        p->right->left = p->left;  \n>        p->left->right = p->right;  \n>    }  \n>    void insert(Node *p)  \n>    {  \n>        p->right = L->right;  \n>        p->left = L;   \n>       L->right->left = p;  \n>        L->right = p;   \n>    }  \n>   LRUCache(int capacity) {  \n>        n = capacity;  \n>        L = new Node(-1,-1),R = new Node(-1,-1);  \n>        L->right = R;  \n>        R->left = L;      \n>    }  \n>    \n>    int get(int key) {  \n>        if(hash.count(key) == 0) return -1;  \n>        auto p = hash[key];  \n>        remove(p);  \n>        insert(p);  \n>        return p->value;  \n>    }  \n>    \n>    void put(int key, int value) {  \n>        if(hash.count(key))   \n>        {  \n>            auto p = hash[key];  \n>            p->value = value;  \n>            remove(p);  \n>            insert(p);  \n>        }  \n>        else   \n>        {  \n>            if(hash.size() == n)  \n>            {  \n>                auto  p = R->left;  \n>                remove(p);  \n>                hash.erase(p->key);   \n>                delete p;       \n>            auto p = new Node(key,value);    \n>            hash[key] = p;  \n>            insert(p);  \n>        }  \n>    }  \n>  };  \n> ```\n> \n> \n> \n> ## 复杂度分析：\n> \n> - 时间复杂度：O(1)    \n> - 空间复杂度：O(1)   \n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313184437","body":"> ## 思路\n> \n> \n> 递归  \n> \n> ## 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    bool background(TreeNode* left, TreeNode* right) {  \n>        if (left == NULL && right != NULL) return false;  \n>        else if (left != NULL && right == NULL) return false;  \n>        else if (left == NULL && right == NULL) return true;  \n>        else if (left->val != right->val) return false;  \n>        else return background(left->left, right->left) && background(left->right, right->right);  \n>  \n>    }  \n>    bool isSameTree(TreeNode* p, TreeNode* q) {  \n>        return background(p, q);  \n>    }  \n>  };  \n> ```\n> \n> ## 复杂度\n> \n> \n> - 时间复杂度：O(min(m,n))\n> - 空间复杂度：O(min(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314920606","body":"> ## 思路\n> \n>DFS 从根节点递归遍历整棵树，当遍历到叶节点时，将路径表示的数累加。  \n> \n> ## 代码\n> \n> \n> ```c++\n>class Solution {  \n>public:  \n>    int res = 0;  \n>    int sumNumbers(TreeNode* root) {  \n>        dfs(root, 0);  \n>        return res;  \n>    }  \n>    void dfs(TreeNode* root, int number)  \n>    {    \n>        number = number * 10 + root->val;  \n>        if(!root->left && !root->right)  res += number;    \n>        if(root->left)  dfs(root->left,number);\t  \t\t\n>        if(root->right) dfs(root->right,number);\t     \n>    }  \n> };  \n> \n> ```\n> \n> **复杂度分析**\n> \n> - 时间复杂度：O(n)\n> - 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318753064","body":"> ### 思路\n> \n> DFS\n> \n> ### 代码\n> \n> ```c++\n> class Codec {    \n>public:  \n>    void rserialize(TreeNode* root, string& str) {  \n>\n>        if (root == NULL) str += \"None,\";  \n>        else {  \n>            str += to_string(root->val) + \",\";  \n>            rserialize(root->left, str);  \n>            rserialize(root->right, str);  \n>        }        \n>    }  \n>    string serialize(TreeNode* root) {  \n>        string ret;  \n>        rserialize(root, ret);  \n>        return ret;  \n>    }  \n>\n>    TreeNode* rdeserialize(list<string>& dataArray) {  \n>        if(dataArray.front() == \"None\") {  \n>            dataArray.erase(dataArray.begin());  \n>            return NULL;  \n>        }  \n>\n>        TreeNode* root = new TreeNode(stoi(dataArray.front()));  \n>        dataArray.erase(dataArray.begin());  \n>        root->left = rdeserialize(dataArray);  \n>        root->right = rdeserialize(dataArray);  \n>        return root;  \n>    }  \n>\n>    TreeNode* deserialize(string data) {  \n>        list<string> dataArray;  \n>        string str;  \n>       for (auto& c : data) {    \n>            if (c == ',') {  \n>                dataArray.push_back(str);  \n>                str.clear();  \n>            } else {    \n>               str.push_back(c);  \n>            }  \n>        }   \n>        if (!str.empty()) {  \n>            dataArray.push_back(str);  \n>            str.clear();  \n>        }  \n>        return rdeserialize(dataArray);  \n>    }  \n>   };  \n> ```\n> \n> ### 复杂度分析\n> \n> 时间复杂度：O(N)  \n> 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319727379","body":"> ### 思路\n>通过 DFS 求出每个点的坐标，之后我们只需对坐标进行排序即可  \n>   \n> ### 代码\n> ```c++\n>class Solution {  \n>public:  \n>    struct Node {  \n>        int x, y, val;  \n>        Node() {}  \n>        Node(int a, int b, int c) : x(a), y(b), val(c) {}  \n>        bool operator < (Node node) const {  \n>            if(y != node.y) return y > node.y;  \n>           else if(x != node.x) return x > node.x;    \n>            return val > node.val;  \n>        }    \n>    };  \n>    map <int, priority_queue <Node> > ss;  \n>    vector <vector<int>> ans;  \n>\n>    void dfs(int x, int y, TreeNode *root) {  \n>        if(!root) return ;  \n>        ss[y].push({x, y, root->val});  \n>       dfs(x + 1, y - 1, root->left);  \n>        dfs(x + 1, y + 1, root->right);  \n>        return ;  \n>    }  \n>    vector<vector<int>> verticalTraversal(TreeNode* root) {  \n>        if(!root) return ans;  \n>        dfs(0, 0, root);  \n>        for(auto &[x, y] : ss) {  \n>            ans.push_back(vector<int>());  \n>            while(!y.empty()) {  \n>                ans.back().push_back(y.top().val);  \n>                y.pop();  \n>            }  \n>        }  \n>        return ans;  \n>    }  \n>   };   \n> ```\n> \n> ### 复杂度\n> 时间复杂度：O(nlog(n))  \n> 空间复杂度 ：O(n）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298076219","body":"思路\r\n1.  num转成数字，与k相加，再转成数组，空间复杂度O（n），时间复杂度O（n）\r\n2.  k每次取最后一位数字，直接与num数组从后向前相加，注意进位，空间负责度减小到O（n）\r\n\r\n代码\r\n```javascript```\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let kleft = k;\r\n    let i = num.length-1;\r\n    while(kleft || i>=0) {\r\n        const lastNum = kleft%10;\r\n        if (i<0) {\r\n        // k位数较多，依次取出，加到数组头部\r\n            num.unshift(lastNum);\r\n            kleft = Math.floor(kleft/10);\r\n            continue;\r\n        }\r\n        // 数组位数更多时\r\n        num[i] += lastNum;\r\n        if (num[i] >= 10 ){         // 进位\r\n            num[i] = num[i]%10;\r\n            const up = 1;\r\n        //  数组位置不够\r\n            if (i == 0) {\r\n                num.unshift(up);\r\n                i++;// 长度变长了\r\n            } else {\r\n                num[i-1] += up;\r\n            }\r\n        }\r\n        kleft = Math.floor(kleft/10);\r\n        i--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n复杂度：K的次数为常数级别\r\nTime: O（n）\r\nSpace:  O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300395771","body":"思路\r\n1.  暴力解法，遍历s每个字符，每次遍历，再遍历一次最近的c\r\n2. 用空间换时间，左右各遍历一次s，从左遍历时，当前存储左边最近一个c的index，右边同理。最后比较左右哪个小。\r\n\r\n\r\n代码\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n    let leftIdex = -1;\r\n    const leftArr = [];\r\n    for(let i=0;i< s.length;i++) {\r\n        if (s[i] === c) {\r\n            leftIdex = i;\r\n        } \r\n        leftArr[i] = leftIdex;\r\n    }\r\n    const rightArr = [];\r\n    let rightIndex = -1;\r\n    for(let i=s.length-1;i>=0;i--) {\r\n        if (s[i] === c) {\r\n            rightIndex = i;\r\n        } \r\n        rightArr[i] = rightIndex;\r\n    }\r\n    const res = [];\r\n    for(let i=0;i< s.length;i++) {\r\n        const left = Math.abs(leftArr[i] - i);\r\n        const right = Math.abs(rightArr[i] - i);\r\n        if (leftArr[i] === -1) {\r\n            res[i] = right;\r\n        } else if (rightArr[i] === -1) {\r\n            res[i] = left;\r\n        } else {\r\n            res[i] =  Math.min(left, right);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n复杂度分析：三次存储是常数级别，省略\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\np.s. 应该可以优化成只存一次，不用三次，第二次遍历的时候直接相加。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302054753","body":"### 思路\r\n1. 用数组模拟栈\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.total = 0;\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length === this.maxSize) return this.stack;\r\n    return this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.pop() || -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(var i = 0; i<k; i++ ){\r\n        if(this.stack[i]) this.stack[i] += val;\r\n    }\r\n    return this.stack;\r\n};\r\n\r\n\r\n ```\r\n### 复杂度： \r\n时间复杂度：\r\npush：O(1)\r\npop：O(1)\r\nincrement：O(k)\r\n\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303709487","body":"### 思路\r\n把字符压到栈里，遇到 ] 出栈到 [  组成字符，继续出栈到非数字，组成数字，拼接字符串，当作一个完整字符，压栈，继续遍历\r\n### 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  \r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n        continue;\r\n    }\r\n    let temStr = '';\r\n    while (stack[stack.length - 1] !== '[') {\r\n         temStr = stack.pop() + temStr;\r\n    }\r\n\r\n    stack.pop();\r\n\r\n    let numStr = '';\r\n    while (stack.length && isNumber(stack[stack.length - 1])) {\r\n        numStr =  stack.pop() + numStr;\r\n    }\r\n    const res = temStr.repeat(Number(numStr));\r\n    stack.push(res);\r\n  }\r\n  return stack.join('')\r\n};\r\n\r\nconst isNumber = (chr) => {\r\n  const num = Number(chr);\r\n  return num >=0 && num <=9;\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n),\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304564384","body":"### 思路\r\n1. 入队的时候，push到数字开头（用两个栈来回装元素），反过来的队列，这样pop和peek可以直接用出栈操作\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    const tempStack = [];\r\n    while(this.stack.length) {\r\n        tempStack.push(this.stack.pop());\r\n    }\r\n    tempStack.push(x);\r\n    while(tempStack.length) {\r\n        this.stack.push(tempStack.pop());\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length-1]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度\r\n时间 push O(N), pop/peak/empty O(1)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304732911","body":"### 思路\r\n因为需要按块生序，所以用单调栈。单调栈存块最大值，比最大值小，则变成一个块。\r\n块最多是每个值一个块。\r\n\r\n### 代码\r\n```javascript\r\nvar maxChunksToSorted = function(arr) {\r\n    const stack = [arr[0]];\r\n    for(let i = 1;i < arr.length;i++) {\r\n        if (arr[i] - stack[stack.length-1] >= 0) {\r\n            stack.push(arr[i]);\r\n        }\r\n\r\n        const max = stack.pop();\r\n        while(stack.length && stack[stack.length-1] > arr[i]) {\r\n            stack.pop()\r\n        }\r\n        stack.push(max);\r\n    }\r\n\r\n    return stack.length;\r\n\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305687396","body":"### 思路\r\n先找到旋转点，如果 k 小于链表长度，则旋转点是第 length-k，如果 大于链表长度是 length - k%length。通过快慢指针找到这个点。\r\n然后翻转：左边指针为null，尾部指针指向head，head指针指向旋转点.next.\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next || !k) return head;\r\n    let headNode = head;\r\n    let len = 1;\r\n    while (headNode.next) {\r\n        headNode = headNode.next;\r\n        len++;\r\n    }\r\n    let point = len - k % len;\r\n    if (point === len) {\r\n        return head;\r\n    }\r\n\r\n    // 尾指向头\r\n    headNode.next = head;\r\n    // 遍历相距距离\r\n    while (point) {\r\n        headNode = headNode.next;\r\n        point--;\r\n    }\r\n\r\n    const ret = headNode.next;\r\n    headNode.next = null;// 断掉\r\n    return ret;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306669500","body":"### 思路\r\n准备一个返回链表。遍历原链表，每遍历2个节点，断开，内部交换两个节点，再链接上返回链表。\r\n\r\n### 代码\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    let resNode = new ListNode();\r\n    let resTail = resNode;\r\n    let resHead = resNode;\r\n    let moveHead = head;\r\n    let moveTail = head;\r\n\r\n    while(moveTail) {\r\n        // 遍历两个节点\r\n        moveTail = moveTail.next;\r\n        if (!moveTail) {\r\n            resTail.next = moveHead;\r\n            return resHead.next;\r\n        }\r\n        // 断开\r\n        const temp = moveTail.next;\r\n        moveTail.next = null;\r\n       // 内部交换\r\n        reverse = swap(moveHead);\r\n        // 加入返回链表尾部\r\n        resTail.next = reverse;\r\n        // 尾指针移动到最后，即第二个节点。\r\n        resTail = reverse.next;\r\n        // 继续遍历后两个节点\r\n        moveHead = temp;\r\n        moveTail = temp;\r\n    }\r\n\r\n    return resHead.next;\r\n\r\n};\r\n\r\nvar swap = function(head) {\r\n    if (!head) return null;\r\n    if (!head.next) return\r\n    let resHead = head;\r\n    const temp = resHead.next;\r\n    resHead.next = null;\r\n    temp.next = resHead;\r\n    resHead = temp;\r\n    return resHead;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308102322","body":"### 思路\r\n因为左右平衡，所以链表的中间的节点是搜索二叉树的根节点，左右各自又为搜索二叉树，递归得出\r\n\r\n### 代码\r\n```javascript\r\nvar sortedListToBST = function(head) {\r\n    var makeTree = function(head, tail){\r\n        if(head === tail) return null;\r\n        const middleNode = getMiddleNode(head, tail);\r\n        const node = new TreeNode(middleNode.val);\r\n        node.left = makeTree(head, middleNode);\r\n        node.right = makeTree(middleNode.next, tail);\r\n        return node;\r\n    }\r\n\r\n    return makeTree(head, null);\r\n};\r\n\r\nvar getMiddleNode = function(head, tail) {\r\n    if (!head) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while (fast !== tail) {\r\n        fast = fast.next\r\n        if(fast!== tail){\r\n            fast = fast.next\r\n            slow = slow.next;\r\n        }\r\n    }\r\n    return slow;\r\n}; \r\n```\r\n### 复杂度\r\n时间：O(nlogn) 递归logn次，每次遍历链表\r\n空间：O(logn)  递归栈空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309084594","body":"### 思路\r\n求两个链表的长度，计算出差值k。两个链表遍历，长的先走k补，补齐差距，之后同步向后走，遇到相等的则是交点\r\n\r\n### 代码\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let lenA = 0;\r\n    let getLenAHead = headA;\r\n    while(getLenAHead) {\r\n        lenA++;\r\n        getLenAHead = getLenAHead.next;\r\n    }\r\n\r\n    let lenB = 0;\r\n    let getLenBHead = headB;\r\n    while(getLenBHead) {\r\n        lenB++;\r\n        getLenBHead = getLenBHead.next;\r\n    }\r\n\r\n    let fastLen = Math.abs(lenA - lenB);\r\n    let resHeadFast = lenA > lenB ? headA : headB;\r\n    let resHeadSlow = lenA > lenB ? headB : headA;\r\n\r\n    while(fastLen) {\r\n        resHeadFast = resHeadFast.next;\r\n        fastLen--;\r\n    }\r\n\r\n    while(resHeadFast) {\r\n        if (resHeadFast === resHeadSlow) {\r\n            return resHeadFast;\r\n        }\r\n        resHeadFast = resHeadFast.next;\r\n        resHeadSlow = resHeadSlow.next;\r\n    }\r\n\r\n    return null;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n) \r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310649876","body":"### 思路\r\n1. 通过哈希表存储节点，遍历链表，如果遇到相同的node，即为入口。空间和时间复杂度O(n)\r\n2. 快慢指针遍历链表，快指针是慢指针走过节点的2倍，当相遇时，经过推导，相遇节点到入环的距离和 head到入环的距离相等。所以从head和相遇节点各自移动到相等，则是入环节点\r\n\r\n### 代码\r\n```javascript\r\nvar detectCycle = function(head) {\r\n    let fast = hasCycle(head);\r\n    if (!fast) return null;\r\n\r\n    let slow = head;\r\n    while(slow) {\r\n        if (slow === fast) return slow;\r\n        slow = slow.next;\r\n        fast = fast.next;\r\n    }\r\n    return null;\r\n};\r\n\r\nvar hasCycle = function(head) {\r\n    if (!head) return false;\r\n\r\n    let slow = head;\r\n    let fast = head;\r\n    while(fast && fast.next) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n        if (fast === slow) return fast;\r\n    }\r\n    return null;\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312494007","body":"### 思路\r\n哈希存储节点，使得get为O(1)，双向链表按最近访问关联节点，使得快速添加/更新/删除。\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar DLinkedNode = function(key, value) {\r\n    this.key = key\r\n    this.value = value\r\n    this.prev = null\r\n    this.next = null\r\n}\r\nvar LRUCache = function(capacity) {\r\n    this.map = {};\r\n    this.size = 0;\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n\r\n    this.head = new DLinkedNode(-1, -1)\r\n    this.tail = new DLinkedNode(-1, -1)\r\n    this.head.prev = null\r\n    this.head.next = this.tail\r\n    this.tail.prev = this.head\r\n    this.tail.next = null\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    if (this.size == 0) {\r\n        return -1 \r\n    }\r\n    const node = this.map.get(key);\r\n    if (!node) {\r\n        return -1;\r\n    } \r\n    this.removeNode(node);\r\n    this.addNodeAtHead(node);\r\n    return node.value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    const node = this.map.get(key);\r\n    if  (node != null) {\r\n        node.value = value\r\n        this.removeNode(node)\r\n        this.addNodeAtHead(node)\r\n        return\r\n    }\r\n   \r\n    if (this.size === this.capacity) {\r\n        this.map.delete(this.tail.prev.key)\r\n        this.removeNode(this.tail.prev)\r\n        this.size--;\r\n    }\r\n    const newNode = new DLinkedNode(key, value);\r\n    this.map.set(key,newNode);\r\n    this.addNodeAtHead(newNode);\r\n    this.size++;\r\n};\r\nLRUCache.prototype.addNodeAtHead = function(node) {\r\n    this.head.next.prev = node;\r\n    node.next = this.head.next;\r\n    this.head.next = node;\r\n    node.prev = this.head;\r\n};\r\n\r\nLRUCache.prototype.removeNode = function(node) {\r\n    node.prev.next = node.next;\r\n    node.next.prev = node.prev;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：get O(1), put:O(1)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312532567","body":"### 思路\r\nroot节点深度为1，广度优先遍历树的节点，每次遍历当前节点和最大深度比较，然后把子节点压入队列，子节点深度=当前节点深度+1，\r\n\r\n### 代码\r\n```javascript\r\nvar maxDepth = function(root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        depth: 1\r\n    });\r\n    let max = -Infinity\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        const depth = temp.depth;\r\n        max = Math.max(depth, max);\r\n\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n    }\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n) 每个节点访问一次\r\n空间：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312933517","body":"### 思路\r\ndfs ，递归比较，结束条件：都为空是相等，一个为空不相等，都不为空值不同为不想等。\r\n\r\n### 代码\r\n```javascript\r\nvar isSameTree = function(p, q) {\r\n    if (!q && !p) return true;\r\n    if (!q || !p) return false;\r\n    if (q.val !== p.val) return false;\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(min(n,m)) 遍历\r\n空间：O(min(m,n)) 递归栈空间最差是节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314086377","body":"### 思路\r\n深度优先或者广度优先遍历，遍历到子节点时，把父节点信息到带到子节点，遍历到叶节点时，即可收集到从根节点到叶节点的路径，记录数组。最后加总\r\n\r\n### 代码\r\ndfs\r\n```javascript\r\nvar sumNumbers = function(root) {\r\n   let result = []\r\n    if (root == null) {\r\n        return result\r\n    }\r\n    let dfs = (node, path) => {\r\n        path.push(node.val)\r\n        if (node.left == null && node.right == null) {\r\n            result.push([...path].join(''))\r\n            path.pop()\r\n            return\r\n        }\r\n        if (node.left != null) {\r\n            dfs(node.left, path)\r\n        }\r\n        if (node.right != null) {\r\n            dfs(node.right, path)\r\n        }\r\n        path.pop()\r\n    }\r\n    dfs(root, [], 0);\r\n\r\n    let sum = 0;\r\n    for(let i=0;i<result.length;i++) {\r\n        sum += parseInt(result[i]);\r\n    }\r\n\r\n    return sum;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n) 每个节点访问一次\r\n空间：O(h) 递归栈的深度即树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1315597848","body":"### 思路\r\n广度优先遍历，每个节点记录深度，记录最大深度，当出现新的最大深度时，同时记录值。因为左边是第一个入队的值，所以只记这一次就可以。\r\n\r\n### 代码\r\n```javascript\r\nvar findBottomLeftValue = function(root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        depth: 0// 层级遍历的同时，根据返回要求，用相同depth去把同层收集起来\r\n    });\r\n    let res;\r\n    let maxDepth = -1;\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        const depth = temp.depth;\r\n        if (depth > maxDepth) {\r\n            res = temp.node.val;\r\n            maxDepth = depth;\r\n        }\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317932792","body":"### 思路\r\n使用dfs 前序遍历\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\n\r\nvar serialize = function(root) {\r\n    return dfsSerialize(root, '');\r\n};\r\n\r\nfunction dfsSerialize(root, str) {\r\n    if (root === null) {\r\n        str += \"null,\";\r\n    } else {\r\n        str += root.val + \",\";\r\n        str = dfsSerialize(root.left, str);\r\n        str = dfsSerialize(root.right, str);\r\n    }\r\n    return str;\r\n}\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    const arr = data.split(',')\r\n    return dfsDeserialize(arr);\r\n};\r\n\r\nfunction dfsDeserialize(arr) {\r\n    const node = arr.shift();\r\n    if (node === 'null') {\r\n        return null;\r\n    }\r\n\r\n    const root = new TreeNode(parseInt(node));\r\n    root.left = dfsDeserialize(arr);\r\n    root.right = dfsDeserialize(arr);\r\n    return root;\r\n}\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319573646","body":"### 思路\r\n遍历节点，拿到坐标值，按横坐标排序，再按纵坐标排序，最后按值排序，然后遍历数组，按横坐标分组输出\r\n\r\n### 代码\r\n```javascript\r\nvar verticalTraversal = function(root) {\r\n    if (!root) return[];\r\n    const orderNode = preorderTraversal(root);\r\n    orderNode.sort((a,b) => {\r\n        if (a.x !== b.x) {\r\n            return a.x > b.x ? 1:-1 ;\r\n        }\r\n        if (a.y !== b.y) {\r\n            return a.y > b.y ? 1:-1 \r\n        }\r\n        return a.val > b.val ? 1:-1\r\n    });\r\n    if (orderNode.length === 1) return [orderNode[0].val]\r\n\r\n    let res = [];\r\n    let left = 0;\r\n    let right = 1;\r\n    orderNode.push({\r\n        val: -Infinity,\r\n        x: Infinity,\r\n        y: Infinity,\r\n    })\r\n    while(right < orderNode.length) {\r\n        if (orderNode[left].x !== orderNode[right].x) {\r\n            const arr = orderNode.slice(left, right).map(item => item.val);\r\n            res.push(arr);\r\n            left = right;\r\n            continue\r\n        }\r\n        right++;\r\n    }\r\n    return res;\r\n};\r\n\r\nvar preorderTraversal = function (root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        x:0,\r\n        y:0,\r\n    });\r\n    const res = [];\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        res.push({\r\n            val: temp.node.val,\r\n            x: temp.x,\r\n            y: temp.y,\r\n        });\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                x: temp.x-1,\r\n                y: temp.y+1,\r\n            });\r\n        }\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                x: temp.x+1,\r\n                y: temp.y+1,\r\n            });\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间 O(nlog(n))，排序需要O(nlogn)\r\n空间 O(n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320231602","body":"### 思路\r\n遍历数组，用hash存储遇到的值，如果遇到target-当前值，在hash中有，说明找到了\r\n\r\n```javascript\r\nvar twoSum = function(nums, target) {\r\n    const map = {};\r\n    for(let i=0;i<nums.length;i++) {\r\n        if (map[target-nums[i]] !== undefined) return [i, map[target-nums[i]]]\r\n        map[nums[i]] = i;\r\n    }\r\n    return []\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320920014","body":"### 思路\r\n记录每个元素出现的频率，用小顶堆选出topk，大于堆顶可入选\r\n### 代码\r\n```javascript\r\nvar topKFrequent = function(nums, k) {\r\n    // value -> count\r\n    const counts = {};\r\n    for(let i=0;i<nums.length;i++) {\r\n        if (counts[nums[i]] !== undefined) {\r\n            counts[nums[i]] += 1;\r\n        } else {\r\n            counts[nums[i]] = 1;\r\n        }\r\n    }\r\n\r\n    let queue = new MinPriorityQueue({priority: node => node.count})\r\n    for (let num in counts) {\r\n        const count = counts[num];\r\n        if (queue.size() < k) {\r\n            queue.enqueue(QElement(num, count))\r\n        } else {\r\n            if (queue.front().element.count < count) {\r\n                queue.dequeue();\r\n                queue.enqueue(QElement(num, count))\r\n            }\r\n        } \r\n    }\r\n\r\n    let result = [];\r\n    for (let i=0; i < k; ++i) {\r\n        result.push(queue.dequeue().element.val)\r\n    }\r\n    return result\r\n};\r\n\r\nfunction QElement (num, count) {\r\n    return {\r\n        val: num === undefined ? 0 : num, \r\n        count: count === undefined ? 0 : count, \r\n    }\r\n}\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：0(nlogn) n为哈希遍历，logn为堆排序\r\n空间：O(n+k)  哈希+堆","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321485975","body":"### 思路\r\n暴力解法，枚举所有点到点的距离。每个点，到其它点的距离，如果有重复的，那么这几个线段求排列组合An2的个数，最后加总\r\n\r\n### 代码\r\n```javascript\r\nvar numberOfBoomerangs = function(points) {\r\n    let res = 0;\r\n    for(let i=0;i<points.length;i++) {\r\n        const curPoint = points[i];\r\n        const disMap = {};\r\n        for(let j=0;j<points.length;j++) {\r\n            const secondPoint = points[j];\r\n            // 计算所有点的距离\r\n            const dis = (curPoint[0] - secondPoint[0]) * (curPoint[0] - secondPoint[0]) + (curPoint[1] - secondPoint[1]) * (curPoint[1] - secondPoint[1]);\r\n            // 记录距离都有什么值\r\n            disMap[dis] = disMap[dis] === undefined ? 1 : disMap[dis]+1;\r\n        }\r\n        let count = 0;\r\n        Object.values(disMap).forEach((disCount) => {\r\n            count += disCount * (disCount-1);// 值为1也可以满足\r\n        });\r\n        res += count;\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n^2) ,两层遍历\r\n空间：O(n) hash ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322937155","body":"### 思路\r\n用双指针遍历，指针之间是不重复元素，记录最长长度。hash存储遇到的值，可以判断right最新的值是否重复，如果重复，则当前字符串的判断结束，左指针向前移动并删除hash存储，直到指针间无重复，进入下一个无重复字符串区间。\r\n\r\n### 代码\r\n```javascript\r\nvar lengthOfLongestSubstring = function(s) {\r\n    if (s.length<=1) return s.length;\r\n    let left = 0;\r\n    let right = 1;\r\n    const map = new Map();\r\n    map.set(s[0], 1);\r\n    let max= 0;\r\n    while(right < s.length) {\r\n        if(map.get(s[right])) {\r\n            map.delete(s[left]);\r\n            left++;\r\n            continue;\r\n        }\r\n        map.set(s[right], 1);\r\n        right++;\r\n        max = Math.max(max, right-left);\r\n    }\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间: O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324478042","body":"### 思路\r\n把word存一个map，记录出现次数，遍历s，每次遍历，当作以当前字符为开头的，是否满足条件：每隔一个word长度判断是否存在map中且数量符合。\r\n\r\n```javascript\r\nvar findSubstring = function(s, words) {\r\n     if(!s || !words.length) return [];\r\n    const wordsCount = words.length;\r\n    const oneLen = words[0].length\r\n    const len = wordsCount * oneLen;\r\n    if (len> s.length) return [];\r\n\r\n\r\n    const wordMap = {};\r\n    for(let i=0;i<words.length;i++) {\r\n       if(wordMap[words[i]] === undefined) {\r\n            wordMap[words[i]] = 1\r\n        } else {\r\n            wordMap[words[i]] +=1;\r\n        }\r\n    }\r\n    \r\n    const res = []\r\n    for(let i=0;i<s.length;i++) {\r\n        let tempNum = 0;\r\n        const tempMap = { ...wordMap };\r\n        let j = i;\r\n        while(tempNum < wordsCount){\r\n            const str = s.substring(j, j + oneLen);\r\n            if (!tempMap[str]) break;\r\n            tempMap[str] -=1;\r\n            tempNum++;\r\n            j = j + oneLen;\r\n        }\r\n       \r\n        if (tempNum === wordsCount){\r\n            res.push(i)\r\n        }\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间 O(s.length*k) k=s长度/word长度遍历一次\r\n空间 O(m×n) 单词长度*单词个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325881095","body":"### 思路\r\nhash 记录取模结果，如果加和遇到相同的取模结果，则认为中间这段是符合预期的，个数取决于结果相同的个数。\r\n注意负数取模的纠正\r\n### 代码\r\n\r\n```javascript\r\nvar subarraysDivByK = function(nums, k) {\r\n    let count = 0, sum = 0;\r\n    let map = {} ;\r\n    map[0] = 1;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        sum += nums[i];\r\n        const mod = (sum % k + k) % k\r\n        if (map[mod])\r\n            count += map[mod];\r\n        map[mod] = (map[mod]|| 0) + 1;\r\n    }\r\n    return count;\r\n};\r\n```\r\n### 复杂度\r\n时间 0（n）\r\n空间O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327038791","body":"### 思路\r\n快慢双指针，快指针走两步，慢指针走一步，走到头，慢指针指向中间节点\r\n\r\n### 代码\r\n```javascript\r\nvar middleNode = function(head) {\r\n    if (!head) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while (fast && fast.next) {\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n    }\r\n    return slow;\r\n};     \r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327998044","body":"### 思路\r\n快慢双指针，快指针找不重复数字，覆盖到慢指针前面，慢指针移动一位。最后不重复的都移动到了慢指针前面了。\r\n\r\n### 代码\r\n```javascript\r\nvar removeDuplicates = function(nums) {\r\n    for(var slow = 0, fast= 1; fast<nums.length; fast++){\r\n        if (nums[fast] !== nums[slow]) {\r\n            nums[++slow] = nums[fast];\r\n        }\r\n    }\r\n    return slow+1;\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间 O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328073524","body":"### 思路\r\n二分查找\r\n\r\n### 代码\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let low = 0;\r\n    let high = nums.length - 1;\r\n     while (low <= high) {\r\n        let mid = Math.floor((low + high) / 2);\r\n        if (nums[mid] == target) {\r\n            return mid\r\n        } else if (nums[mid] < target) {\r\n            low = mid + 1\r\n        } else {\r\n            high = mid - 1\r\n        }\r\n    }\r\n    return low;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O（logn）\r\n空间O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328563992","body":"### 思路\r\n单调队列\r\n\r\n### 代码\r\n```javascript\r\nvar maxSlidingWindow = function(nums, k) {\r\n    const n = nums.length;\r\n    // 当前窗口最大值的index\r\n    const q = [];\r\n    // 先进入k个数字\r\n    for (let i = 0; i < k; i++) {\r\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\r\n            q.pop();\r\n        }\r\n        q.push(i);\r\n    }\r\n\r\n    const ans = [nums[q[0]]];\r\n    for (let i = k; i < n; i++) {\r\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\r\n            q.pop();\r\n        }\r\n        q.push(i);\r\n        while (q[0] <= i - k) {\r\n            // 过了窗口界限\r\n            q.shift();\r\n        }\r\n        ans.push(nums[q[0]]);\r\n    }\r\n    return ans;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329980967","body":"### 思路\r\n统计每个节点入度出度，满足条件的即为法官\r\n\r\n### 代码\r\n```javascript\r\nvar findJudge = function(n, trust) {\r\n    const giveTrust = Array(n+1).fill(0);\r\n    const gotTrust =  Array(n+1).fill(0);\r\n\r\n    for(let i=0;i<trust.length;i++) {\r\n        const one = trust[i];\r\n        gotTrust[one[1]]++;\r\n        giveTrust[one[0]]++;\r\n    }\r\n\r\n    for(let i=1;i<=n;i++) {\r\n        if (giveTrust[i] === 0 && gotTrust[i] === n-1) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331582633","body":"### 思路\r\n邻接矩阵记录不喜欢，深度遍历看是否有冲突\r\n\r\n### 代码\r\n```javascript\r\nvar possibleBipartition = function(n, dislikes) {\r\n    // 建立访问表和邻接矩阵\r\n    const color = new Array(n + 1).fill(0);\r\n    const gragh = new Array(n + 1).fill(0);\r\n    for (let i = 0; i <= n; ++i) {\r\n        gragh[i] = [];\r\n    }\r\n    for (const dislike of dislikes) {\r\n        gragh[dislike[0]].push(dislike[1]);\r\n        gragh[dislike[1]].push(dislike[0]);\r\n    }\r\n\r\n    for (let i = 1; i <= n; ++i) {\r\n        if (color[i] === 0 && hasconflictDfs(i, 1, color, gragh)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nconst hasconflictDfs = (curnode, nowcolor, colors, gragh) => {\r\n    colors[curnode] = nowcolor;\r\n    for (const nextnode of gragh[curnode]) {\r\n        // 不喜欢被分在同一组，冲突\r\n        if (colors[nextnode] !== 0 && colors[nextnode] === colors[curnode]) {\r\n            return true;\r\n        }\r\n        if (colors[nextnode] === 0 && hasconflictDfs(nextnode, 3 ^ nowcolor, colors, gragh)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n```\r\n### 复杂度\r\n时间 O(m+n)\r\n空间O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333266085","body":"### 代码\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @param {number} m\r\n * @param {number[]} group\r\n * @param {number[][]} beforeItems\r\n * @return {number[]}\r\n */\r\nvar sortItems = function(n, m, group, beforeItems) {\r\n    const grahG = [], degG = new Uint16Array(n + m), idsG = [], \r\n          grahI = [], degI = new Uint16Array(n), idsI = [], r = []\r\n    for (let i = 0; i < n; i++) {\r\n        if (group[i] === -1) {\r\n            idsG[m] = m // 从组数起分配，避免重复\r\n            group[i] = m++\r\n        } else idsG[group[i]] = group[i]\r\n        if (!idsI[group[i]]) idsI[group[i]] = [] // 同组项目，放入到一起\r\n        idsI[group[i]].push(i)\r\n    }\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < beforeItems[i].length; j++) {\r\n            const itemI = beforeItems[i][j]\r\n            if (group[i] === group[itemI]) {// 同组，收集 项目 依赖\r\n                degI[i]++\r\n                if (!grahI[itemI]) grahI[itemI] = []\r\n                grahI[itemI].push(i)\r\n            } else {// 不同组，收集 组 依赖\r\n                degG[group[i]]++\r\n                if (!grahG[group[itemI]]) grahG[group[itemI]] = []\r\n                grahG[group[itemI]].push(group[i])\r\n            }\r\n        }\r\n    }\r\n    const idsGS = tp_sort(idsG.filter(v => v !== void 0), grahG, degG) // 组排序\r\n    if (idsGS.length === 0) return []\r\n    for (let i = 0; i < idsGS.length; i++) {// 组有序，组内项目排序\r\n        if (!idsI[idsGS[i]]) continue\r\n        const idsIS = tp_sort(idsI[idsGS[i]], grahI, degI)\r\n        if (idsIS.length === 0) return []\r\n        r.push(...idsIS)\r\n    }\r\n    return r\r\n};\r\n\r\n\r\nfunction tp_sort(ids, grah, deg) {// 拓扑排序：id列表，图，入度\r\n    const q = [], r = []\r\n    for (let i = 0; i < ids.length; i++) {\r\n        if (deg[ids[i]] === 0) {\r\n            q.push(ids[i])\r\n        }\r\n    }\r\n\r\n    let start = 0\r\n    while (start < q.length) {\r\n        const n = q[start++]\r\n        r.push(n)\r\n        if (!grah[n]) continue\r\n        for (let i = 0; i < grah[n].length; i++) {\r\n            if (--deg[grah[n][i]] === 0) {\r\n                q.push(grah[n][i])\r\n            }\r\n        }\r\n    }\r\n    return r.length === ids.length ? r : []\r\n}\r\n```\r\n### 复杂度\r\n时间:O(m+n)\r\n空间:O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334904978","body":"### 思路 \r\n统计走动的方向的值，相反方向相等则回回到原点\r\n\r\n### 代码\r\n```javascript\r\nvar judgeCircle = function(moves) {\r\n    let up = 0;\r\n    let down = 0;\r\n    let left = 0;\r\n    let right = 0;\r\n    for(let i=0;i<moves.length;i++) {\r\n        const move = moves[i];\r\n        switch(move) {\r\n            case 'U':\r\n                up++;\r\n                break;\r\n            case 'D':\r\n                down++;\r\n                break;\r\n            case 'L':\r\n                left++;\r\n                break;\r\n            case 'R':\r\n                right++;\r\n                break;\r\n        }\r\n    }\r\n\r\n    return up === down && left === right;\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298085446","body":"## 思路\n\n- 将k对应位数加到num上，并对大于10的位数继续进位\n- 出现num.length<k.length情况，对num进行扩充相加，直到k=0\n\n## 代码\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int flag = 0;\n        for(int i = 0; i < num.size() ; i++){\n            num[i] += (k % 10);\n            k /= 10;\n            if(num[i] >= 10){\n                num[i] -= 10;\n                if(i != (num.size()-1)){\n                    num[i+1]++;\n                }else{\n                    flag = 1;\n                    num.push_back(1);\n                    break;\n                }\n            }\n        }\n\n        while(k){\n            if(flag){\n                flag = 0;\n                num[num.size()-1] += (k % 10);\n                if(num[num.size()-1] >= 10){\n                    num[num.size()-1] -= 10;\n                    flag = 1;\n                    num.push_back(1);\n                }\n            }else{\n                num.push_back(k % 10);\n            }\n            k /= 10;\n        } \n        \n        reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299515911","body":"## 思路\n\n-  找出string中c出现的索引，存入book\n-  遍历s和book，计算所有可能的距离，将最小距离存入answer\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size(), 0), book;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == c)\n                book.push_back(i);\n        }\n        for(int i = 0; i < s.size(); i++){\n            int min = 10000;\n            for(int j = 0; j < book.size(); j++){\n                int dis = abs(i - book[j]);\n                if(min > dis)\n                    min = dis;\n            }\n            answer[i] = min;\n        }\n        return answer;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301911303","body":"## 思路\n\n将栈看作数组，对数组进行增加、删除、遍历\n\n## 代码\n\nC++ Code:\n\n```c++\nclass CustomStack {\nprivate:\n    int maxSize;\n    vector<int>st;\n\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;        \n    }\n    \n    void push(int x) {\n        if(st.size() < maxSize)\n            st.push_back(x);\n    }\n    \n    int pop() {\n        if(!st.empty()){\n            int tp = st[st.size()-1];\n            st.pop_back();\n            return tp;\n        }else\n            return -1;\n    }\n    \n    void increment(int k, int val) {\n        if (st.size() < k){\n            for(vector<int>::iterator it = st.begin(); it != st.end(); it++)\n                (*it) += val; \n        }else{\n            for(vector<int>::iterator it = st.begin(); it < (st.begin() + k); it++)\n                (*it) += val; \n        }\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k)$\n- 空间复杂度：$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303248570","body":"## 思路\n\n1. 使用栈st存储pair( ]前字母，]前数字 )\n2. 遍历s，如果是字母，存入nowStr；如果是数字，存入nowNum；如果是'['，将(nowStr, nowNum)入栈，并清空nowStr和nowNum；如果是']'，说明已经找到一个完整的子串可以用来表示总长度，此时nowStr存储的是[]里字符串，此时栈顶元素出栈，atoi(st.back().second.c_str())是nowStr出现次数，st.back().first是这个出现多次的字符串前的字符串，将展开后的子串存入nowStr即为当前已经展开一次的串。\n3. 遍历结束，返回结果nowStr\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<pair<string, string>>st;\n        string nowStr, nowNum;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] >= 'a' && s[i] <= 'z'){\n                nowStr += s[i];\n            }else if(s[i] >= '0' && s[i] <= '9'){\n                nowNum += s[i];\n            }else if(s[i] == '['){\n                st.push_back(make_pair(nowStr, nowNum));\n                nowStr.clear();\n                nowNum.clear();\n            }else{\n                string tmp;\n                for(int j = 0; j < atoi(st.back().second.c_str()); j++)\n                    tmp += nowStr;\n                nowStr =  st.back().first + tmp;\n                st.pop_back();     \n            }\n        }\n        return nowStr;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304448576","body":"**思路**\n\n用两个栈st1, st2记录，st1记录队列push后正序，st2记录pop和peek时队列逆序用来找到队列首部元素，每次pop和peek后要将st1恢复到当前队列情况，st2清空\n\n**代码**\n\nC++ Code:\n\n```c++\nclass MyQueue {\nprivate:\n    stack<int> st1, st2; //st1正序 st2逆序\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {        \n        st1.push(x);       \n    }\n    \n    int pop() {\n        while(!st1.empty()){\n            st2.push(st1.top());\n            st1.pop();\n        }\n        int top = st2.top();\n        st2.pop();\n        while(!st2.empty()){\n            st1.push(st2.top());\n            st2.pop();\n        }        \n        return top;\n    }\n    \n    int peek() {\n        while(!st1.empty()){\n            st2.push(st1.top());\n            st1.pop();\n        }\n        int top = st2.top();\n        while(!st2.empty()){\n            st1.push(st2.top());\n            st2.pop();\n        }        \n        return top;\n    }\n    \n    bool empty() {\n        if(st1.empty())\n            return true;\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为栈长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304782127","body":"## 思路\n\n1. 排序前每个子块和排序后中对应位置的子块中数的出现次数是一样的，用哈希表diff来记录排序前后对应子块出现频次的差值\n2. 遍历数组，当差值为0时，说明该数字在这个子块中出现频率相同，从哈希表中删除这个key，直到diff为空时，说明两个子块出现的数字是一样的，可以分块，res++\n3. 遍历结束，返回res\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int res;\n        unordered_map<int, int>diff;\n        vector<int>arr_sort = arr;\n        sort(arr_sort.begin(), arr_sort.end());\n        for(int i = 0; i < arr_sort.size(); i++){\n            int x = arr[i], y = arr_sort[i];\n            diff[x]++;\n            if(diff[x] == 0)\n                diff.erase(x);\n            diff[y]--;\n            if(diff[y] == 0)\n                diff.erase(y);\n            if(diff.empty())\n                res++;           \n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305425538","body":"## 思路\n\n1. 遍历链表，得到结点总数count（这时要注意当只有一个节点或者链表为空或者k为0时，直接返回头结点）\n2. 遍历链表，找到断开的位置count-k % count\n3. 更新头结点和尾节点，返回头结点\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(k == 0 || head == nullptr || head->next == nullptr)\n            return head;   \n        \n        int count = 1;\n        ListNode* cur = head;\n        while(cur->next != nullptr){\n            cur = cur->next;\n            count++;\n        }\n        int nodeNum = k % count;\n        \n        if(nodeNum == 0)\n            return head;\n        \n        cur->next = head;\n        for(int i = 0; i < (count - nodeNum); i++){\n            cur = cur->next;\n        }\n        head = cur->next;\n        cur->next = nullptr;\n        return head;\n\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点个数。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307325316","body":"## 思路\n\n1. 链表为空或者只有一个节点，返回head\n2. 每两个节点为一组，first为第一个节点，second为第二个节点，两个节点交换，交换后两个节点顺序为second和first，当first->next != nullptr && first->next->next != nullptr时，循环继续。(要注意的是链表存在奇数节点和偶数节点，交换次数是一样的，因此循环结束条件为是否还存在两个节点)\n3. 循环结束，返回head\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        \n        ListNode* first = head;\n        ListNode* second = head->next;\n        ListNode* cur = first;\n        int k = 1;             \n  \n        do{\n            if(k < 1){\n                first = first->next;\n                second = first->next;\n                cur->next = second;\n                cur = first;         \n            }\n            first->next = second->next;\n            second->next = cur;\n            if (k-- > 0)\n                head = second;\n        }while(first->next != nullptr && first->next->next != nullptr);\n        return head;\n\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点数。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308642286","body":"## 思路\n\n获取当前链表的中点，以链表中点为根，中点左边的值都小于它,可以构造左子树，同理构造右子树，递归上述过程\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n    \n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if(head == tail) return nullptr;\n        \n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != tail && fast->next != tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n\n        return root;\n    }\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309806671","body":"## 思路\n\n当A和B相交时，从链表A和链表B头结点出发走过路径一样长。当A走到尾结点，则从headB开始；当B走到尾结点，则从headA开始。当A和B均为空时，说明不相交。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *A = headA;\n        ListNode *B = headB;\n\n        while(A != B){\n            A = A->next;\n            B = B->next;\n            if(A == nullptr && B == nullptr)\n                return nullptr;\n            if(A == nullptr)\n                A = headB;\n            if(B == nullptr)\n                B = headA;            \n        }\n        return A;\n\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311391413","body":"## 思路\n\n创建哈希表，依次遍历每个结点加入哈希表中，当发现哈希表中存在该结点，则该结点为环的入口，否则遍历结束返回null\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n       ListNode *cur = head;\n        set<ListNode*>st;\n        while(cur != nullptr){\n            if(st.find(cur) != st.end())\n                return cur;\n            st.insert(cur);\n            cur = cur->next;           \n        }\n        return nullptr;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312414670","body":"## 思路\n\n- 使用双向链表+哈希表\n- 每次在链表尾部加入新的结点，将最新访问的结点移到链表头部，哈希表中存key和结点\n- 构造函数\n  - 初始化虚拟头尾结点\n  - 链表最大容量\n  - 构造一个空哈希表\n- get\n  - 如果key在哈希表中存在，则返回该结点value，并将该结点移到链表头部\n  - key不存在，则返回-1\n- put\n  - 如果key在哈希表中存在，则更新该结点的value，并将该结点移到链表头部\n  - key不存在\n    - 如果结点数为最大容量，则删除尾结点，并删除尾结点在哈希表中值\n    - 将key和value存入新结点，将该结点移到链表头部，并存入哈希表中\n\n## 代码\n\nC++ Code:\n\n```c++\nclass DListNode {\npublic:\n    int key;\n    int value;\n    DListNode* pre;\n    DListNode* next;\n    DListNode() : key(-1), value(-1), pre(nullptr), next(nullptr) {};\n    DListNode(int k, int v) : key(k), value(v), pre(nullptr), next(nullptr) {};\n};\n\n\nclass LRUCache {\nprivate:\n    int capacity;\n    DListNode* dummy_head;\n    DListNode* dummy_tail;\n    unordered_map<int, DListNode*>mp;\n\npublic:\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n        this->dummy_head = new DListNode();\n        this->dummy_tail = new DListNode();\n        this->dummy_head->next = this->dummy_tail;\n        this->dummy_tail->pre = this->dummy_head;\n    }\n\n    int get(int key) {\n        if (mp.count(key) > 0) {\n            DListNode* cur = mp[key];\n             //移除当前结点\n             cur->pre->next = cur->next;\n             cur->next->pre = cur->pre;\n             //将结点移到头部\n             DListNode* head = dummy_head->next;\n             dummy_head->next = cur;\n             cur->pre = dummy_head;\n             head->pre = cur;\n             cur->next = head;            \n            return (mp[key])->value;\n        }\n        else\n            return -1;\n    }\n\n    void put(int key, int value) {\n        if (mp.count(key) > 0) {\n            DListNode* cur = mp[key];\n            cur->value = value;\n            //移除当前结点\n            cur->pre->next = cur->next;\n            cur->next->pre = cur->pre;\n            //将结点移到头部\n            DListNode* head = dummy_head->next;\n            dummy_head->next = cur;\n            cur->pre = dummy_head;\n            head->pre = cur;\n            cur->next = head;\n        }\n        else {\n            if (mp.size() == capacity) {\n                //移除尾结点\n                DListNode* tail = dummy_tail->pre;\n                dummy_tail->pre = tail->pre;\n                tail->pre->next = dummy_tail;\n                tail->pre = tail->next = nullptr;\n                //删掉哈希表中key\n                mp.erase(tail->key);\n            }\n            DListNode* head = dummy_head->next;\n            DListNode* new_node = new DListNode(key, value);\n            //加到头部\n            dummy_head->next = new_node;\n            new_node->pre = dummy_head;\n            head->pre = new_node;\n            new_node->next = head;\n            //加入哈希表\n            mp.insert(make_pair(key, new_node));\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312678570","body":"## 思路\n\n-  用标记层的BFS\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        queue<TreeNode*> dq;\n        int depth = 0;\n        dq.push(root);\n        while(dq.size()){\n            int length = dq.size();\n            for(int i = 0; i < length; i++){\n                TreeNode* curNode = dq.front();\n                dq.pop();\n                if(curNode->left != nullptr)\n                    dq.push(curNode->left);\n                if(curNode->right != nullptr)\n                    dq.push(curNode->right);\n            }\n            depth++;\n        }\n        \n        return depth;\n    }\n};\n\n```\n\n**复杂度分析**\n\nn为结点个数\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313111628","body":"## 思路\n\n对两棵树同时做先序遍历，对每个p、q进行判断，当p、p均为空时，返回true；当p或者q有个一个为空时，返回false；当p->val != q->val时，返回false；当p->val == q->val时，对其左右结点重复上述过程。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        return preorder(p, q);\n    }\n\n    bool preorder(TreeNode* p, TreeNode* q){\n        if(p == nullptr && q == nullptr)\n            return true;\n        if(!p)\n            return false;\n        if(!q)\n            return false;\n\n        if(p->val != q->val)\n            return false;\n        else{\n            bool l = preorder(p->left, q->left);\n            bool r = preorder(p->right, q->right);\n            return l && r;\n        }        \n    }\n};\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314812049","body":"## 思路\n\ndfs，用stack记录搜索的当前路径，当为叶子结点时，计算当前路径长度，\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        stack<TreeNode*> path; \n        return dfs(root, path);\n    }\n    \n    int dfs(TreeNode* root, stack<TreeNode*> &path){        \n        if(!root) return 0;     \n        path.push(root);\n        if(!root->left && !root->right){\n            stack<TreeNode*> cur = path;\n            path.pop();\n            int sum = 0;\n            int size = cur.size();\n            for(int i = 0; i < size; i++){\n                sum += (cur.top()->val * pow(10, i));\n                cur.pop();\n            }\n            return sum;   \n        }\n\n        int l = dfs(root->left, path);\n        int r = dfs(root->right, path);\n        path.pop();\n\n        return l + r;\n        \n    }\n\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，n为结点数\n- 空间复杂度：$O(h)$，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316407509","body":"## 思路\n\nBFS，记录每层最左元素，遍历结束，记录的为最后一层最左元素值\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        return BFS(root);\n    }\n\n    int BFS(TreeNode* root){\n        int value = 0;\n        queue<TreeNode*>qe;\n        qe.push(root);\n        while(!qe.empty()){\n            int length = qe.size();\n            value = qe.front()->val;\n            for(int i = 0; i < length; i++){\n                TreeNode*cur = qe.front();\n                qe.pop();     \n                if(cur->left)\n                    qe.push(cur->left);\n                if(cur->right)\n                    qe.push(cur->right);                           \n            }\n        }\n        return value;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318269547","body":"## 思路\n\n-  BFS\n-  serialize()是注意将null加入string，结点用.分割\n-  deserialize()分为两部分\n   -  从序列化后的string中得到结点数组Nodes\n   -  分别找到父节点和其左右结点，判断是子结点是否为空，不为空则构建父节点和子节点关系，并将子节点入队列（每次父节点移动+1，子节点移动+2）\n   -  重复2，直到父节点走到末尾\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string res;\n        queue<TreeNode*>qe;\n        qe.push(root);\n        while(!qe.empty()){\n            TreeNode*cur = qe.front();\n            qe.pop();\n            if(cur){\n                res += (to_string(cur->val) + \",\");\n                qe.push(cur->left);\n                qe.push(cur->right);\n            }else\n                res += \"#,\";\n        }\n        return res.substr(0, res.size()-1);\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if(data == \"#\") return nullptr;\n        \n        vector<string>nodes;\n        while(data.find(\",\") != string::npos){\n            int pos = data.find(\",\");\n            int remainSize = data.size() - pos - 1;\n            nodes.push_back(data.substr(0, pos));\n            data = data.substr(pos + 1, remainSize);\n        }\n        nodes.push_back(data);\n        \n        TreeNode* root = new TreeNode(atoi(nodes[0].c_str()));\n        queue<TreeNode*>q; \n        q.push(root);\n        int index = 1;\n        while(index < nodes.size()){\n            TreeNode*cur = q.front(); //父节点指针移动+1\n            q.pop();\n            string leftval = nodes[index];\n            string rightval = nodes[index+1];\n\n            if(leftval != \"#\"){\n                TreeNode*leftNode = new TreeNode(atoi(leftval.c_str()));\n                cur->left = leftNode;\n                q.push(leftNode);\n            }\n            \n            if(rightval != \"#\"){\n                TreeNode*rightNode = new TreeNode(atoi(rightval.c_str()));\n                cur->right = rightNode;\n                q.push(rightNode);\n            }\n            index += 2; //子节点指针移动+2\n        }\n\n        return root;\n    }\n};\n\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，n为结点个数\n- 空间复杂度：$O(Q)$，Q为序列化后结点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1321725145","body":"## 思路\n\n1. 对树做搜索，记录每个结点的(col, row, root->val)\n2. 对结点进行排序\n3. 遍历结点，按照列，存入vector<vector<int>> res\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    \n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n        dfs(root, nodes, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> res;\n        int last_col = 2000;\n        for(const auto& [col, row, val]: nodes){\n            if(last_col != col){\n                last_col = col;\n                res.emplace_back();\n            }\n            res.back().emplace_back(val);\n        }\n        return res;\n    }\n\n    void dfs(TreeNode* root, vector<tuple<int, int, int>>& nodes, int row, int col){\n        if(!root) return;\n        nodes.push_back(make_tuple(col, row, root->val));\n        dfs(root->left, nodes, row+1, col-1);\n        dfs(root->right, nodes, row+1, col+1);\n    }\n\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1321045836","body":"## 思路\n\n遍历\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int>res;\n        for(int i = 0; i < (nums.size() - 1); i++){\n            for(int j = i + 1; j < nums.size(); j++){\n                if(target == (nums[i] + nums[j])){\n                    res.push_back(i);\n                    res.push_back(j);\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n^2)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321068678","body":"## 思路\n\n哈希表+小顶堆\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    class mycomparison {\n    public:\n        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n            return lhs.second > rhs.second;\n        }\n    };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> map; \n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {\n            pri_que.push(*it);\n            if (pri_que.size() > k) { \n                pri_que.pop();\n            }\n        }\n\n        vector<int> result(k);\n        for (int i = k - 1; i >= 0; i--) {\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n        return result;\n\n    }\n};\n\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(nlogk)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321551058","body":"## 思路\n\n-  对于每一个点i，到i距离相等的点是有一定的。对每一个点，用哈希表存储到该点相同距离点的个数，(key, value)=(距离, 点的个数)。之后对每个i，相同距离做排列，之后求和。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res = 0;\n        for (const auto& point: points){\n            unordered_map<int, int>dist_num;            \n            for(const auto& p: points){\n                int dist = (point[0] - p[0]) * (point[0] - p[0]) + (point[1] - p[1]) * (point[1] - p[1]);\n                dist_num[dist]++;\n            }\n            for(const auto& count: dist_num){\n                res += (count.second) * (count.second - 1);\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323257064","body":"## 思路\n\n哈希表+滑动窗口（哈希表记录每个字母最近一次出现的位置）\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int>hashMap;\n        int maxSub = 0, l = 0, r = 0;\n        while(r < s.size()){\n            if(hashMap.count(s[r])>0){\n                int last_pos = hashMap[s[r]];\n                if(last_pos >= l && last_pos <= r)\n                    l = last_pos + 1;\n            }            \n            maxSub = max(maxSub, r-l+1);\n            hashMap[s[r]] = r;\n            r++;\n        }\n        return maxSub;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(S)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324707923","body":"## 思路\n\n-  哈希表hashMap存储words中字符串出现次数\n-  遍历s，取长度为word_num * word_length的子串，遍历该子串，取长度为word_length的串，将其出现次数存入哈希表temp。如果该串是串联子串，temp和hashMap的值相同，否则进入下一循环。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int>hashMap;\n        int word_num = words.size(), word_length = words[0].size(), s_length = s.size();\n        vector<int>res;\n        \n        for(const auto& word: words)\n            hashMap[word]++;\n        \n        for(int i = 0; i < (s_length-word_num*word_length+1); i++){\n            unordered_map<string, int>temp;\n            string cur = s.substr(i,  word_num * word_length);\n\n            int j = 0;\n            for(; j < cur.size(); j += word_length){\n                string str = cur.substr(j, word_length);\n                if(!hashMap.count(str)) break;\n                temp[str]++;\n                if(temp[str] > hashMap[str]) break;\n            }\n\n            if(j == cur.size())\n                res.push_back(i);\n        }\n\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\n\n- 时间复杂度：$O(n*m*k)$\n- 空间复杂度：$O(m)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326159967","body":"## 思路\n\n-  前缀和+哈希表\n-  遍历数组，计算数组的前缀和，将前缀和 mod k的值做为key，统计出现次数做为value\n-  遍历哈希表，对每一个key的值，排列组合\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int>predSumModK = {{0, 1}};\n        int sum = 0;\n        int res = 0;\n        for(const auto& x: nums){\n            sum += x;\n            int modK = (sum % k + k) % k; //负数取模为负数\n            predSumModK[modK]++;\n        }\n\n        for(const auto& [modK, count]: predSumModK){\n            res += (count * (count - 1) / 2);\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(min(n, k))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327018666","body":"## 思路\n\n- 快慢指针\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast && fast->next){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328000921","body":"```\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int read = 0, write = 0;\n        while(read < nums.size()){\n            if(nums[read] != nums[write]){ \n                write++;\n                nums[write] = nums[read];\n            }\n            read++;\n        }\n        return write + 1;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328192247","body":"## 思路\n\n- 双指针+二分查找\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size()-1;\n        while(l <= r){\n            int mid = (l + r) / 2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328643484","body":"## 思路\n\n-  单调递减队列q.front()为当前窗口最大值\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int>res;\n        deque<int>q; //存储nums索引,单调递减队列\n        for(int i = 0; i < nums.size(); i++){\n            //队列非空，且q.front()不在滑动窗口内\n            if(!q.empty() && (i - k + 1) > q.front()){\n                q.pop_front();\n            }\n\t\t\t//队列非空，且nums[i] > nums[q.back()]，删除队列中小于当前元素的值，保证队列递减\n            while(!q.empty() && nums[i] > nums[q.back()]){\n                q.pop_back();\n            }\n            //索引入队\n            q.push_back(i);\n\t\t\t//保存每个窗口最大值\n            if((i - k + 1) >= 0){\n                res.push_back(nums[q.front()]);\n            }\n\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(k)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330485481","body":"## 思路\n\n-  找出度为0，入度为n-1的结点\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int>in_degree(n+1, 0);\n        vector<int>out_degree(n+1, 0);\n        \n        for(const auto& tr: trust){\n            in_degree[tr[1]]++;\n            out_degree[tr[0]]++;\n        }\n\n        for(int i = 1; i <= n; i++){\n            if(in_degree[i] == (n - 1) && out_degree[i] == 0)\n                return i;\n        }\n        return -1;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332192246","body":"## 思路\n\n-  图+染色法+DFS\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>>Graph(n);\n        vector<int>colors(n, 0); //0:未分组; 1:group1; -1:group2\n        \n        //构建邻接表\n        for(const auto& dis: dislikes){\n            Graph[dis[0]-1].push_back(dis[1]-1);\n            Graph[dis[1]-1].push_back(dis[0]-1);\n        }\n\n        //遍历每个人尝试分组\n        for(int i = 0; i < n; i++){\n            if(colors[i] == 0 && DFS(i, 1, Graph, colors))\n                return false;\n        }\n        return true;\n    }\n\n    //判断每个人是否和不喜欢的人分为一组\n    bool DFS(int cur, int color, vector<vector<int>>& G, vector<int>& C){\n        C[cur] = color;\n\n        //遍历cur不喜欢的人尝试分为另一组\n        for(const auto& dislike: G[cur]){\n            if(C[dislike] == 0 && DFS(dislike, -color, G, C))\n                return true;\n            if(C[dislike] == color)\n                return true;\n        }\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(V+E)$，V为图的顶点，E为图的边\n- 空间复杂度：$O(V+E)$，V为图的顶点，E为图的边","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334954653","body":"## 思路\n\n-  模拟\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for(const auto& str: moves){\n            if(str == 'R')  x++;\n            if(str == 'L')  x--;\n            if(str == 'U')  y++;\n            if(str == 'D')  y--;\n        }\n        return (x==0)&&(y==0) ;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298094032","body":"# Leetcode 989\r\n\r\n## 思路\r\n- 数组和k从LSB开始计算，直到其中数组和k有一个到头；计算携带carry进位，当计算超过10时取余，carry取1传给下次计算；\r\n- 计算出来的值通过vec的insert函数进行头插；\r\n- 当有一个到头时，对另一个数据继续进行上述处理，直到它也到头；\r\n- 单独处理最后到头的情况。\r\n\r\n\r\n## 代码\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res_vec;\r\n        int length = num.size();\r\n        int i(1);\r\n        int carry = 0;\r\n        //第一步，计算\r\n        while((k/10 || k%10) && i<=length){\r\n            int tmp = num[length-i] + k%10 + carry;\r\n            if(tmp/10) {tmp %= 10; carry = 1;}\r\n            else carry = 0;\r\n            \r\n            res_vec.insert(res_vec.begin(), tmp);\r\n            \r\n            ++i;\r\n            k /= 10;\r\n        }\r\n        \r\n        //第二步；对剩余元素处理\r\n        if(i<=length)\r\n            while(i<=length){\r\n                int tmp = num[length-i] + carry;\r\n                if(tmp/10) {tmp %= 10; carry = 1;}\r\n                else carry = 0;\r\n                \r\n                res_vec.insert(res_vec.begin(), tmp);\r\n                \r\n                ++i;\r\n            }\r\n        else if(k/10 || k%10)\r\n            while(k/10 || k%10){\r\n                int tmp = k%10 + carry;\r\n                if(tmp/10) {tmp %= 10; carry = 1;}\r\n                else carry = 0;\r\n                \r\n                res_vec.insert(res_vec.begin(), tmp);\r\n                \r\n                k /= 10;\r\n            }\r\n        \r\n        \r\n        if(carry)\r\n            res_vec.insert(res_vec.begin(), 1);\r\n        \r\n        return res_vec;\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\nn，n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299482657","body":"# Leetcode 821\r\n\r\n## 思路\r\n基于多中心点的病毒扩散模型：将给定字符所在位置作为中心点，以此扩散边界元素，保留最小值，遇到另一个中心立刻停止扩散。也即一维的图遍历过程。\r\n\r\n## 代码\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res_vec(s.length(),10000);\r\n        vector<int> vec_slf;\r\n        //记录该字符的位置\r\n        for(int i(0); i < s.length(); ++i){\r\n            if(s[i] == c) res_vec[i] = 0;\r\n            vec_slf.insert(vec_slf.end(), i);\r\n        }\r\n        \r\n        for(auto slf: vec_slf){\r\n            int i(slf-1);\r\n            while(i >= 0) {\r\n                if(res_vec[i] == 0) break;\r\n                \r\n                int tmp = res_vec[i+1] + 1;\r\n                if(res_vec[i] > tmp) res_vec[i] = tmp;\r\n                else break;\r\n                \r\n                i--;\r\n            }\r\n            i = slf+1;\r\n            while(i < res_vec.size()){\r\n                if(res_vec[i] == 0) break;\r\n                \r\n                int tmp = res_vec[i-1] + 1;\r\n                if(res_vec[i] > tmp) res_vec[i] = tmp;\r\n                else break;\r\n                \r\n                ++i;\r\n            }\r\n        }\r\n        \r\n        return res_vec;            \r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\nn，n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301651250","body":"# 1381\r\n\r\n## 思路\r\n偷懒用vector实现，用arr配合index指示栈顶也可以做\r\n\r\n## 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        _maxSize = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(_vec_stk.size() < _maxSize)\r\n            _vec_stk.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(!_vec_stk.size()) return -1;\r\n        else {\r\n            int tmp = _vec_stk[_vec_stk.size() -1];\r\n            _vec_stk.pop_back();\r\n            return tmp;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(_vec_stk.size()){\r\n            int i(0);\r\n            for(auto &n: _vec_stk){\r\n                n += val;\r\n                i++;\r\n                if(i == k) break;\r\n            }\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> _vec_stk;\r\n    int _maxSize;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303164435","body":"# 394 \r\n暂时没做出来，C++的string用得不是很习惯\r\n\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res_str;\r\n        string tmp_str;\r\n        stack <int> stk;\r\n        int i(0);\r\n        int n(0);\r\n        //int k(0), count(0);\r\n        while(i < s.length()){\r\n            if((s[i]-'0' >= 0) && (s[i]-'0' <= 9)) stk.push(s[i++]);\r\n            else if(s[i] == '[') {\r\n                stk.push(s[i++]);\r\n                n++;\r\n            }\r\n            else if(s[i] == ']') {\r\n                string tmp;\r\n                while(stk.top() != '['){\r\n                    //tmp \r\n                    string tmp3;\r\n                    tmp3 += stk.top();\r\n                    tmp.insert(0, tmp3);\r\n                    stk.pop();\r\n                }\r\n                tmp_str.insert(0, tmp);\r\n                //cout << tmp_str << endl;\r\n                stk.pop();\r\n                n--;\r\n                int k(0), count(0);\r\n                while(!stk.empty() && (stk.top()-'0' >= 0) && (stk.top()-'0' <= 9)){\r\n                    int tmpn = stk.top() -'0';\r\n                    k += tmpn*pow(10,count++);\r\n                    stk.pop();\r\n                }\r\n                string tmp2(tmp_str);\r\n                k--;\r\n                while(k){\r\n                    tmp_str += tmp2;\r\n                    k--;\r\n                }\r\n                if(!n) {\r\n                    res_str.append(tmp_str);\r\n                    tmp_str.clear();\r\n                }\r\n\r\n                ++i;\r\n            }\r\n            else {\r\n                if (stk.empty()) res_str += s[i++];\r\n                else stk.push(s[i++]);\r\n            }\r\n\r\n        }\r\n\r\n        return res_str;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298123259","body":"### 思路\n\n1. num list化成int\n2. 加上k\n3. 转为list\n\n### 代码\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # if num == [0] and k == 0: return [0] \n        # x = 0\n        # out = []\n        # for i in num:\n        #     x = x*10 + i \n        # x += k\n        # while x > 0:\n        #     out.append(x % 10)\n        #     x //= 10\n        # return out[::-1]\n        return [int(a) for a in str(int(''.join(map(str,num)))+k)]\n```\n\n### 复杂度\n\nO(n) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299628742","body":"### 思路\n\n1. 从左遍历记录与最近 c的距离\n2. 从右遍历，顺便用min取最短距离\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size(), pos = -n;\n        vector<int> res(n,n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; i--) {\n            if (s[i] == c) pos = i;\n            res[i] = min(res[i], pos - i);\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度\n\nO(n) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302324672","body":"### 思路 \n\n...\n\n### 代码\n\n```C++\nclass CustomStack {\n    vector<int> stack;\n    int n;\npublic:\n    CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack.size() == n) return;\n        if (stack.size() < n) stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int x=stack.back();\n        stack.pop_back();\n        return x;\n    }\n    \n    void increment(int k, int val) {\n        int x=k;\n        if(stack.size()<k)\n            x=stack.size();\n        for(int i=0;i<x;i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303028763","body":"### 思路 \n\n用stack存储，四个cases\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_string = \"\"\n        k = 0\n\n        for char in s:\n            if char == \"[\":\n                # Just finished parsing this k, save current string and k for when we pop\n                stack.append((current_string, k))\n                # Reset current_string and k for this new frame\n                current_string = \"\"\n                k = 0\n            elif char == \"]\":\n                # We have completed this frame, get the last current_string and k from when the frame \n                # opened, which is the k we need to duplicate the current current_string by\n                last_string, last_k = stack.pop(-1)\n                current_string = last_string + last_k * current_string\n            elif char.isdigit():\n                k = k * 10 + int(char)\n            else:\n                current_string += char\n\n        return current_string\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304419378","body":"### 思路 \n\npop encoding\n\n### 代码\n\n```c++\nclass MyQueue {\n    public:\n        stack<int> s1, s2;\n        MyQueue() {        }\n\n        void push(int x) {\n            s1.push(x);\n//             // Move all elements from s1 to s2\n//             while (!s1.empty()) {\n//                 s2.push(s1.top());\n//                 s1.pop();       \n//             }           \n\n//             // Push the item to s1\n//             s1.push(x); \n\n//             // Push all elements in s2 back to s1\n//             while (!s2.empty()){\n//                 s1.push(s2.top());\n//                 s2.pop();       \n//             } \n        }\n\n        int pop() {\n            if (s1.empty() && s2.empty()) {\n                cout << \"empty queue\" << endl;\n                exit(0);                                                                  }\n            if (s2.empty()) {\n                while (!s1.empty()) {\n                    s2.push(s1.top());\n                    s1.pop();           \n                }                       \n            }\n            int temp = s2.top();\n            s2.pop();\n            return temp;\n            // // pop out the top element in s1\n            // if (s1.empty()) {\n            //     cout << \"error\" << endl;\n            //     exit(0);        \n            // }           \n            // int temp = s1.top();\n            // s1.pop();\n            // return temp;\n        }\n\n        int peek() {\n            if (s2.empty()) {\n                while (!s1.empty()) {\n                    s2.push(s1.top());\n                    s1.pop();\n                }\n            }\n            return s2.top();\n            // if (s1.empty()) {\n            //     cout << \"empty queue\" << endl;\n            //     exit(0);        \n            // }           \n            // return s1.top();\n        }\n\n        bool empty() {\n            return s1.empty() && s2.empty();\n            // return s1.empty();\n        }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304727109","body":"### 思路 \n\nusing stack to store the max item for potential blocks, return the length of the stack in the end\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n        for i,a in enumerate(arr):\n            maxi = a\n            while s and s[-1] > a:\n                maxi = max(maxi,s.pop())\n            s.append(maxi)\n        return len(s)\n```\n\n### 复杂度\n\nO(n) / O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305134751","body":"### 思路 \n\nCheck length -> the the # of rotation -> make as a loop -> traverse -> disconnect \n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n      \n      #check the length\n        lastNode, length = head, 1\n        while lastNode.next:\n            lastNode = lastNode.next\n            length += 1\n\n        # check the number of rotation\n        k = k % length\n\n      # setlast node point to the first node\n        lastNode.next = head\n\n      #traverse until (length - k) node\n        temp = head\n        for i in range(length - k - 1): temp = temp.next\n\n      #disconnect the first and last node\n        out = temp.next\n        temp.next = None\n\n        return out\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306756244","body":"``` python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        pre, pre.next = self, head\r\n        while pre.next and pre.next.next:\r\n            a = pre.next\r\n            b = a.next\r\n            pre.next, b.next, a.next = b, a, b.next\r\n            pre = a\r\n        return self.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307967276","body":"### 思路 \n\nDivide and conquer\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n\n        pre, slow, fast = None, head, head\n\n        # find the middle node of the linked list\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if pre: pre.next = None\n\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n### 复杂度\n\nO(nlogn) / O(long)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309864117","body":"### 思路 \n\n最后的指针走相同长度可以判断有没有重叠，没有的话同时为none\n\n### 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = headA, headB\n        while p != q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p\n```\n\n### 复杂度\n\nO(n+m) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311375729","body":"### 思路 \n\n1. 快慢指针走，如果相遇则是在环上，没有则是没有交点\n2. 从头走head继续走slow，之后的再次相遇就是在交点\n\n### 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        else:\n            return None\n        while head != slow:\n            slow = slow.next\n            head = head.next\n        return head\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312415686","body":"### 思路 \n\n使用ordereddic， get记得更新查询的元素，set如果cap满了pop出第一个（最旧的\n\n### 代码\n\n```python\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.dic = collections.OrderedDict()\n        self.remain = capacity\n\n    def get(self, key):\n        if key not in self.dic:\n            return -1\n        v = self.dic.pop(key) \n        self.dic[key] = v   # set key as the newest one\n        return v\n\n    def put(self, key, value):\n        if key in self.dic:    \n            self.dic.pop(key)\n        else:\n            if self.remain > 0:\n                self.remain -= 1  \n            else:  # self.dic is full\n                self.dic.popitem(last=False) \n        self.dic[key] = value\n```\n\n### 复杂度\n\nO(1) / O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312607223","body":"### 思路 \n\n递归。从底层向上返\n\n### 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312821721","body":"### 思路 \r\n\r\nBFS or recursion\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        # BFS\r\n        # queue = [(p, q)]\r\n        # while queue:\r\n        #     node1, node2 = queue.pop(0)\r\n        #     if not node1 and not node2: # no child\r\n        #         continue\r\n        #     elif None in [node1, node2]:\r\n        #         return False\r\n        #     else:\r\n        #         if node1.val != node2.val:\r\n        #             return False\r\n        #         queue.append((node1.left, node2.left))\r\n        #         queue.append((node1.right, node2.right))\r\n        # return True\r\n\r\n        #DFS\r\n        if not p and not q: return True\r\n        if not p or not q: return False\r\n        return p.val == q.val and self.isSameTree(q.left, p.left) and self.isSameTree(q.right, p.right)\r\n```\r\n\r\n### 复杂度\r\n\r\nO(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314921240","body":"### 思路 \n\n...\n\n### 代码\n\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        p = {root: root.val}\n        c = dict()\n        res = 0\n        while p:\n            for node, number in p.items():\n                if node.left:\n                    c[node.left] = number*10 + node.left.val\n                if node.right:\n                    c[node.right] = number*10 + node.right.val\n                if not node.left and not node.right:\n                    res += number\n            p = c\n            c = dict()\n        return res\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1315904603","body":"### 思路\n\nDFS 储存每一level的节点 最后返回最后一行最左的节点\n\n### 代码\n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        res = []\n        self.dfs(root, res, 0)\n        return res[-1][0]\n    \n    def dfs(self, root, res, level):\n        if not root: return\n        if level == len(res): res.append([])\n        res[level].append(root.val)\n        self.dfs(root.left, res, level + 1)\n        self.dfs(root.right, res, level + 1)\n```\n\n### 复杂度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317974492","body":"### 思路\n\n抄个答案\n\n### 代码\n\n```python\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def rserialize(root, string):\n            \"\"\" a recursive helper function for the serialize() function.\"\"\"\n            # check base case\n            if root is None:\n                string += 'None,'\n            else:\n                string += str(root.val) + ','\n                string = rserialize(root.left, string)\n                string = rserialize(root.right, string)\n            return string\n        \n        return rserialize(root, '')\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def rdeserialize(l):\n            \"\"\" a recursive helper function for deserialization.\"\"\"\n            if l[0] == 'None':\n                l.pop(0)\n                return None\n                \n            root = TreeNode(l[0])\n            l.pop(0)\n            root.left = rdeserialize(l)\n            root.right = rdeserialize(l)\n            return root\n\n        data_list = data.split(',')\n        root = rdeserialize(data_list)\n        return root\n```\n\n### 复杂度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319515275","body":"### 思路\n\n以root为idx0，左右坐标+-1 w/ BFS\n\n### 代码\n\n```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        g = collections.defaultdict(list) \n        queue = [(root,0)]\n        while queue:\n            new = []\n            d = collections.defaultdict(list)\n            for node, s in queue:\n                d[s].append(node.val) \n                if node.left:  new += (node.left, s-1), \n                if node.right: new += (node.right,s+1),  \n            for i in d: g[i].extend(sorted(d[i]))\n            queue = new\n        return [g[i] for i in sorted(g)]\n```\n\n### 复杂度\n\nO(nlogn)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320778491","body":"### 思路\n\n。。。\n\n### 代码\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ct = 0\n        ref = nums.copy()\n        while ct != len(nums)-1:\n            for i in range(len(nums)-1):\n                total = nums[ct] + nums[i+1]\n                if total == target:\n                    if nums[ct] == nums[i+1]:\n                        res = [ref.index(nums[ct])]\n                        n = ref.pop(ref.index(nums[ct]))#pop one of the numbers\n                        res += [ref.index(n)+1]\n                        return res\n                    return [ref.index(nums[ct]), ref.index(nums[i+1])]\n            nums.pop(0)\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321040139","body":"### 思路\n\n。。。\n\n### 代码\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        import heapq\n        from collections import Counter, defaultdict\n        heap = [(-1*v1, k1) for k1,v1 in Counter(nums).items()] # O(N) to build the heap\n        heapq.heapify(heap) # O((n-k) log n). Worst case O(n log n).\n        result = []\n        for i in range(k):\n            result.append(heapq.heappop(heap)[1]) # O(logN) / O((n-k) log n) for the pops\n        return result\n```\n\n### 复杂度\n\n见代码\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321342955","body":"### 思路\n\n。。。\n\n### 代码\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans=0\n        for i in points:\n            a={}\n            for j in points:\n                c=(i[0]-j[0])**2+(i[1]-j[1])**2\n                if c not in a:\n                    a[c]=1\n                else:\n                    ans+=a[c]\n                    a[c]+=1\n        return ans*2\n```\n\n### 复杂度\n\n。。。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323096578","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        l = 0\n        output = 0\n        for r in range(len(s)): #sliding window\n            if s[r] not in seen: # keep increasing the window size\n                output = max(output,r-l+1)\n            else:\n                if seen[s[r]] < l: # s[r] is inside the current window\n                    output = max(output,r-l+1) \n                else: # s[r] is not inside the current window\n                    l = seen[s[r]] + 1\n            seen[s[r]] = r\n        return output\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324592189","body":"### 思路\n\n（抄作业）滑动窗口+HashTable\n\n### 代码\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        ori_word_dict = defaultdict(int)\n\t\t\n        for word in words:\n            ori_word_dict[word] += 1\n        \n        all_word_len = len(words) * word_len\n        result = []\n        for i in range(word_len):\n            queue = deque()\n            word_dict = ori_word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word_dict.get(word, 0) != 0:\n                    word_dict[word] -= 1\n                    queue.append(word)\n                    if sum(word_dict.values()) == 0:\n                        result.append(j - all_word_len + word_len)\n                        last_element = queue.popleft()\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                else:\n                    while len(queue):\n                        last_element = queue.popleft()\n                        if last_element == word:\n                            queue.append(word)\n                            break\n                        else:\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                            if word_dict[last_element] > ori_word_dict[last_element]:\n                                word_dict = ori_word_dict.copy()\n\n        return result\n```\n\n### 复杂度\n\nO(n*m)/O(n+m)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326854119","body":"### 思路\n\n快慢指针\n\n### 代码\n\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327973991","body":"### 思路\n\n...\n\n### 代码\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # need to check length if no mentioned\n        # if len(nums) == 0: return 0\n        x = 1\n        for i in range(len(nums)-1):\n            if nums[i] != nums[i+1]:\n                nums[x] = nums[i+1]\n                x+=1\n        return x\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328158261","body":"### 思路\n\n二分\n\n### 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)-1\n        while l <= r:\n            mid = int(l+(r-l)/2)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r + 1\n```\n\n### 复杂度\n\nO(logn)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328584842","body":"### 思路\r\n\r\n抄作业：2 max stacks\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        class MaxStack:\r\n            def __init__(self):\r\n                self._stack = []\r\n                self._max_stack = []\r\n\r\n            def push(self, item):\r\n                self._stack.append(item)\r\n                self._max_stack.append(\r\n                    max(item, self._max_stack[-1]) if self._max_stack else item\r\n                )\r\n\r\n            def pop(self):\r\n                self._max_stack.pop()\r\n                return self._stack.pop()\r\n\r\n            def get_max(self):\r\n                return self._max_stack[-1] if self._max_stack else int(-1e6)\r\n\r\n            def empty(self):\r\n                return not self._stack\r\n\r\n        left = MaxStack()\r\n        right = MaxStack()\r\n        answer = []\r\n\r\n        for ind in range(k):\r\n            left.push(nums[ind])\r\n\r\n        for ind in range(k, len(nums)):\r\n            if right.empty():\r\n                while not left.empty():\r\n                    right.push(left.pop())\r\n\r\n            answer.append(max(left.get_max(), right.get_max()))\r\n            left.push(nums[ind])\r\n            right.pop()\r\n        answer.append(max(left.get_max(), right.get_max()))\r\n        return answer\r\n```\r\n\r\n### 复杂度\r\n\r\n。。。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329712292","body":"### 思路\n\nGraph...\n\n### 代码\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        trusts = [0] * (n+1)\n        for (a, b) in trust:\n            trusts[a] -= 1\n            trusts[b] += 1\n            \n        for i in range(1, len(trusts)):\n            if trusts[i] == n-1: return i\n        return -1\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331715059","body":"### 思路\n\n抄答案 / BFS\n\n### 代码\n\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        dislike = [[] for _ in range(n)]\n        for a, b in dislikes:\n            dislike[a-1].append(b-1)\n            dislike[b-1].append(a-1)\n\n        groups = [0] * n\n        for p in range(n):\n            if groups[p] == 0:\n                groups[p] = 1\n                q = deque([p])\n                while q: # bfs\n                    a = q.pop()\n                    for b in dislike[a]:\n                        if groups[b] == 0:\n                            groups[b] = 1 if groups[a] == 2 else 2\n                            q.appendleft(b)\n                        elif groups[a] == groups[b]:\n                            return False\n        return True\n```\n\n### 复杂度\n\n。。。\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334779521","body":"### 思路\n\n检查上/下，左/右的数量是否对等\n\n### 代码\n\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        return moves.count('U')==moves.count('D') and moves.count('R')==moves.count('L') if len(moves)%2 == 0 else False\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336037451","body":"### 思路\n\n抄答案\n\n### 代码\n\n```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        res = []\n        tasks = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])\n        i = 0\n        h = []\n        time = tasks[0][0]\n        while len(res) < len(tasks):\n            while (i < len(tasks)) and (tasks[i][0] <= time):\n                heapq.heappush(h, (tasks[i][1], tasks[i][2])) # (processing_time, original_index)\n                i += 1\n            if h:\n                t_diff, original_index = heapq.heappop(h)\n                time += t_diff\n                res.append(original_index)\n            elif i < len(tasks):\n                time = tasks[i][0]\n        return res\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298148770","body":"### 思路\n\n对每一位分别加减，\n\n### 代码\n\n\n```python3\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        res=[]\n        i=len(num)-1\n        s=0\n        carry=0\n        while i>=0 or k!=0:\n            x=num[i] if i>=0 else 0\n            y=k % 10\n            s = x + y + carry\n            carry =s // 10\n            k //= 10\n\n            i -= 1\n            res.insert(0,s%10)\n        \n        if carry != 0:\n            res.insert(0,carry)\n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300301035","body":"### 思路\n\n从左到右，从右到左分别遍历，最后一起比较\n\n### 代码\n\n\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        tmp=-len(s)\n        index =0\n        dis_l=[0]*len(s)\n        dis_r=[0]*len(s)\n        dis=[0]*len(s)\n        for i, Char in enumerate(s):\n            if  Char == c:\n                tmp = i\n            dis_l [i] = i-tmp\n\n        s=s[::-1]\n        tmp=-len(s)\n        for i, Char in enumerate(s):\n            if  Char == c:\n                tmp = i\n            dis_r [i] = i-tmp\n\n        dis_r=dis_r[::-1]\n        for i in range(len(s)):\n            dis[i]=min(abs(dis_l[i]),abs(dis_r[i]))\n        return dis    \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(3N)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301583588","body":"### 思路\n>列表变栈\n### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.CustomStack = [0]*maxSize\n        self.top = -1 #栈顶为-1，表示栈空\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.CustomStack) - 1:#栈顶为总长度-1，表示栈满\n            self.top += 1\n            self.CustomStack[self.top] = x\n        \n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.CustomStack[self.top+1]\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range( min( (k) , self.top + 1 ) ):\n            self.CustomStack[i] += val\n\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302876960","body":"### 思路\n循环字符串s\n非 \"]\" 默认全部入栈\n遇到\"]\"时\n维护strs和repeat两个空字符串\n先while循环获取所有字符串，条件为stack[-1] != '[' (因为题目明确无异常场景，故此处无需判断栈是否为空)\nstrs = stack.pop() + strs\n执行一次stack.pop() 删掉“[”\n再次while循环，条件为栈存在且栈顶为数字类型的字符串（“3[a]”场景，必须判断栈不为空）\nrepeat = stack.pop() + repeat\n现在栈中压入int(repeat) * strs即可\n\n### 代码\n``` py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for i in s:\n            if i == ']':\n                strs=''\n                repeat=''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop()+repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n### 复杂度\n双O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304560480","body":"### 双栈模拟队列，每次push，pop都要把输入栈导入输出栈\n### 代码\n``` py\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304819837","body":"### 代码\n``` py3\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305081132","body":"### 思路\n求长度，对于特殊的直接返回，取余求得实际旋转次数\n### 代码\n```py3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k==0 or not head or not head.next:\n            return head\n        #求长度\n        n=1\n        cur = head\n        while cur.next:\n            cur=head.next\n            n+=1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next=head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next=None\n        return ret\n```\n### 复杂度\n空间O(1),时间O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307334879","body":"### 思路\n递归，递归之后的前一个节点为head。head和头节点完成交换\n``` python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        tmp = head.next\n        head.next =  self.swapPairs( tmp.next )\n        tmp.next = head\n        return tmp \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308903375","body":"### 思路\n分治\n### 代码\n``` py\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310403568","body":"### 代码\n```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n                A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311675535","body":"### 思路\n快慢法\n### 代码\n``` py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        fast = head\n        slow = head\n\n        if not head or not head.next:\n            return\n\n        while True:\n            if not fast or not fast.next: return\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow : \n                break\n\n        fast = head\n\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n\n        return fast\n```\n### 算法复杂度\n时间O(n),空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312334328","body":"### 代码\n``` py\nclass ListNode: \n    def __init__(self, key = 0, value = 0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.cache = dict()\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = ListNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n\n\n    def addToHead (self,node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode (self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def moveToHead (self,node):\n        self.removeNode(node)\n        self.addToHead(node)\n    \n    def removeTail(self) -> ListNode:\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312636466","body":"### 递归\n### 代码\n··· py\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n### 复杂度\n时间O(N),空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313844898","body":"### 思路\n递归\n### 代码\n```py\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return true\n        if not p or not q:\n            return false\n        return p.val = q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n### 复杂度\n双ON","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314806465","body":"### DFS\n### 代码\n```py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs (root: Optional[TreeNode], total):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return total * 10 + root.val\n            return dfs (root.left, total * 10 + root.val) +  dfs (root.right, total * 10 + root.val)\n        return dfs (root, 0)\n```\n### 复杂度\n双ON","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316186621","body":"### DFS\n### 代码\n``` py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.res = 0\n        self.max_level = 0\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.res = root.val\n        def dfs(root,level):\n            if not root:\n                return\n            if level > self.max_level:\n                self.res = root.val\n                self.max_level = level\n            dfs (root.left, level + 1)\n            dfs (root.right, level + 1)\n        dfs (root,0)\n        return self.res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318105485","body":"### 搬运工\n### 代码\n``` py\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            i += 2\n            if lv != '#':\n                l =TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n            \n        return root\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320016078","body":"### 搬运工\n```py\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        seen = collections.defaultdict(lamda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n        \n        dfs (root)\n        ans = []\n        for x in sorted(seen):\n            level = []\n\n            for y in sorted(seen[x]):\n\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320805986","body":"### 思路\nmapper存储\n### 代码\n``` py\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n=len(nums)\n        mapper={}\n        for i in range(n):\n            if (target-nums[i] in mapper):\n                return [mapper[target-nums[i]] , i]\n            else:\n                mapper[nums[i]] = i\n        \n        return []\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321041923","body":"### 代码\n```py\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        return [i[0] for i in Counter(nums).most_common(k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321938021","body":"``` py\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1 \n            \n            for count in m.values():\n                ans += count * (count - 1)\n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323258696","body":"### 滑动窗口学习\n``` py\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n        left = 0\n        lookup = set()\n        n =len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left +=1\n                cur_len -= 1\n            if cur_len > max_len:\n                max_len= cur_len\n            lookup.add(s[i])\n        return max_len\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324929569","body":"### 滑动窗口\n### 代码\n```py\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        cnt, l = len(words), len(words[0])\n        i, j = 0, cnt * l - 1\n        ans = []\n        check = collections.Counter(words)\n        while j < len(s):\n            ss = s[i : j + 1]\n            tmp = []\n            for k in range(0, len(ss), l):\n                tmp.append(ss[k: k + l])\n            if collections.Counter(tmp) == check:\n                ans.append(i)\n            i += 1\n            j += 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325871828","body":"### 看着敲了一遍\n``` py\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327537250","body":"### 快慢指针\n### 代码\n```py\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328028361","body":"### 思路\n### 代码\n```py\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums: \n            return 0\n\n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328260010","body":"### 思路\n二分\n### 代码\n``` py\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329081839","body":"### 代码\n```py\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = collections.deque() # 本质就是单调队列\n        ans = []\n        for i in range(len(nums)):\n            while q and nums[q[-1]] <= nums[i]: q.pop() # 维持单调性\n            while q and i - q[0] >= k: q.popleft() # 移除失效元素\n            q.append(i)\n            if i >= k - 1: ans.append(nums[q[0]])\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330663484","body":"### 代码\n``` py\nclass Solution:\n     def findJudge(self, N, trust):\n        count = [0] * (N + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, N + 1):\n            if count[i] == N - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332042257","body":"### 代码\n``` py\nclass Solution:\n    def dfs(self,graph,colors,i,color,N):\n        colors[i] = color\n        for j in range(N):\n            if graph[i][j] == 1:\n                if colors[j] == color:\n                    return False\n                if colors [j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\n                    return False\n            \n        return True\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        graph = [[0] * n for i in range(n) ]\n        colors = [0] * n\n        for a,b in dislikes:\n            graph[a-1][b-1] = 1\n            graph[b-1][a-1] = 1\n        \n        for i in range(n):\n            if colors[i] == 0 and not self.dfs(graph,colors,i,1,n):\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333170076","body":"class Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334669613","body":"### 代码\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (const auto& move: moves){\n            if (move == 'U'){\n                y--;\n            }\n            else if (move == 'D'){\n                y++;\n            }\n            else if (move == 'L'){\n                x--;\n            }\n            else if (move == 'R'){\n                x++;\n            }\n        }\n        return x == 0 &&　y == 0;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298225704","body":"### 思路\n\n1. 将 数字 k 加至所给数组的最后一位\n2. 将该位取余，得到该位本身的值 \n3. 给该位除以10，得到该位向前一位的进数\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n\n        for(int i = n - 1;i >= 0 || k > 0;i--)\n        {\n            if(i >= 0)\n            {\n                k+=num[i];\n            }\n            res.push_back(k % 10);\n            k/=10;\n        }\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(|k| or n)，其中 |k| 为数字k的位数。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299459461","body":"### 思路\n\n1. 遍历字符串s\n2. 在遍历字符串s的每个字符s[i]时，再一次对s进行遍历，在内层的每次遍历中判断该字符是否等于c并计算出该字符c与外层当前遍历的s[i]的距离\n3. 通过min变量维护每个字符s[i]到字符c的最小值\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res;\n\n        for(int i = 0;i < s.size();i++)\n        {\n            int min = INT_MAX;\n\n            for(int j = 0;j < s.size();j++)\n            {\n                if((s[j] == c) && (abs(j - i) < min))\n                {\n                    min = abs(j - i);\n                }\n            }\n            res.push_back(min);\n        }\n\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n),n为字符串s的长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301729765","body":"### 思路\n\n1. 通过数组以及一个指向栈顶的指针来模拟栈\n2. 栈的增量操作：若k的值大于栈的容量，则进行栈的容量次循环；若k的值小于栈的容量，则进行k次循环\n\n### 代码\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        ownStack = new int[maxSize]();\n        this->maxSize = maxSize;\n        topPtr = -1;\n    }\n    \n    void push(int x) {\n        if(topPtr == this->maxSize - 1)\n        {\n            return;\n        }\n\n        ownStack[++topPtr] = x;\n    }\n    \n    int pop() {\n        if(topPtr == -1)\n        {\n            return -1;\n        }\n        \n        int tem = ownStack[topPtr--];\n        return tem;\n    }\n    \n    void increment(int k, int val) {\n        if(k < topPtr + 1)\n        {\n            for(int i = 0;i < k;i++)\n            {\n                ownStack[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i = 0;i < topPtr + 1;i++)\n            {\n                ownStack[i]+=val;\n            }\n        }\n    }\nprivate:\n    int* ownStack;\n    int maxSize;\n    int topPtr;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push和pop操作为O(1)，increment操作为O(k or n)（n为栈中元素的个数）\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303575583","body":"### 思路\n\n1. 采用分配律的思想\n2. 用一个栈保存数字，后出现的先使用；用一个栈保存高层级（外层）的字符串\n3. 当出现左括号时，说明应该保存这一层级的数字，以及上一层级的字符串（进行push操作）；当出现右括号时，说明应该获取当前层级的数字，用来作为循环条件（即进行乘法分配），获取上一层级的字符串与当前层级的字符串进行循环拼接，得到上一层级的字符串，（使用结束进行pop操作）\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        int num = 0;\n        stack<int> nums;\n        stack<string> lesserStrs;\n\n        int len = s.size();\n        for(int i = 0;i < len;i++)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + (s[i] - '0');\n            }\n            else if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                lesserStrs.push(res);\n                res = \"\";\n                nums.push(num);\n                num = 0;\n            }\n            else if(s[i] == ']')\n            {\n                int n = nums.top();\n                nums.pop();\n                for(int i = 0;i < n;i++)\n                {\n                    lesserStrs.top() = lesserStrs.top() + res;   \n                }\n                res = lesserStrs.top();\n                lesserStrs.pop();\n            }\n        }\n\n        return res;\n    }\n};\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n),n为字符串长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304428361","body":"### 思路\n\n1. 用两个栈模拟一个队列\n2. push操作：用push栈，直接进行栈的push操作；pop操作：用pop栈，本质上是对push栈进行一个反转，即栈底变栈顶，然后进行pop栈的pop操作，满足了队列先进先出的要求\n\n### 代码\n\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        pushConti.push(x);\n    }\n    \n    int pop() {\n        while(!pushConti.empty())\n        {\n            popConti.push(pushConti.top());\n            pushConti.pop();\n        }\n        int qTop = popConti.top();\n        popConti.pop();\n        while(!popConti.empty())\n        {\n            pushConti.push(popConti.top());\n            popConti.pop();\n        }\n\n        return qTop;\n    }\n    \n    int peek() {\n        while(!pushConti.empty())\n        {\n            popConti.push(pushConti.top());\n            pushConti.pop();\n        }\n        int qTop = popConti.top();\n        while(!popConti.empty())\n        {\n            pushConti.push(popConti.top());\n            popConti.pop();\n        }\n        \n        return qTop;\n    }\n    \n    bool empty() {\n        if(pushConti.empty())\n        {\n            return true;\n        }\n        return false;\n    }\nprivate:\n    stack<int> pushConti;\n    stack<int> popConti;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push,empty:O(1), pop,peek:O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828585","body":"### 思路\n\n1. 由于数组升序和分块后升序的顺序是不会变的（也就是说我们一定是按顺序进行分块的，前面的还没有分块则后面的也不能分块）\n2. 采用哈希表对原数组和排序后的数组中的元素进行匹配，该元素同时出现在原数组和排序后的数组后，删除该元素，表示已匹配\n3. 只有当i前面的所有元素都匹配成功后，我们才可以进行一次分块\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> sorted = arr;//Sorted array\n        sort(sorted.begin(),sorted.end());\n\n        unordered_map<int,int> times;\n        int count = 0;\n        for(int i = 0;i < n;i++)\n        {\n            times[arr[i]]++;\n            times[sorted[i]]--;\n\n            if(times[arr[i]] == 0)\n            {\n                times.erase(arr[i]);\n            }\n\n            if(times[sorted[i]] == 0)\n            {\n                times.erase(sorted[i]);\n            }\n\n            if(times.empty())\n            {\n                count++;\n            }\n        }\n\n        return count;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305008995","body":"### 思路\n\n1. 首先排除边界情况，当list为空及realRotate为0时直接返回头节点\n2. 一般情况下，不管旋转几步，都要先将尾部节点和头部节点相连；之后，我们再找到旋转后的尾部节点，将尾部节点的下一个节点赋值给head后，再对其下一个节点置为空\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //Get size of list\n        ListNode* count = head;\n        int size = 0;\n        while(count != NULL)\n        {\n            count = count->next;\n            size++;\n        }\n\n        if(size == 0)\n        {\n            return head;\n        }\n        int realRotate = k % size;\n        if(realRotate == 0)\n        {\n            return head;\n        }\n\n        //Conect the last one with the first one\n        ListNode* last = head;\n        while(last->next != NULL)\n        {\n            last = last->next;\n        }\n        last->next = head;\n\n        //Find the last one after rotating\n        ListNode* lastAR = head;\n        size--;\n        for(int i = 0;i < size - realRotate;i++)\n        {\n            lastAR = lastAR->next;\n        }\n        head = lastAR->next;\n        lastAR->next = NULL;\n\n        return head;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，遍历求list的大小\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306755286","body":"### 思路\n\n1. 链表的状态存在三种情况：（我们只关注两组相邻的节点）\n1） 从当前起只有只有两个节点\n2） 从当前起有三个节点\n3） 从当前起有四个节点\n2. 我们可以根据链表的不同的状态执行各自的程序\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)\n        {\n            return head;\n        }\n        \n        ListNode* first = head;\n        ListNode* second = first->next;\n        ListNode* secondNext = second->next;\n        head = head->next;\n        while(first)\n        {\n            second->next = first;\n            if(!secondNext)\n            {\n                //If the third node isn't existing,first node.next = NULL,return\n                first->next = NULL;\n                return head;\n            }\n            else if(!secondNext->next)\n            {\n                //If the fourth node isn't existing,first node.next = third nodde,return(third node.next = NULL)\n                first->next = secondNext;\n                return  head;\n            }\n            else\n            {\n                //If the fourth node is existing,first node.next = fourth node,and all pointer move back three places\n                first->next = secondNext->next;\n\n                first = secondNext;\n                second = first->next;\n                secondNext = second->next;\n            }\n        }\n\n        return head;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308179924","body":"### 思路\n\n1. 因为该链表是有序的，我们可以采用二分的方法来形成一棵高度平衡的二叉搜索树\n2. 这里需要对该有序列表按下标的形式进行多次访问，所以我们借助有序数组来代替该有序链表\n3. 形成二叉搜索树是一个递归的过程，每次递归时，我们要在当前范围内找到中间值形成根节点，并安排它的左子节点和右子节点（它的左子节点和右子节点也是在对应范围内找到中间值），当该范围为0时，即到达了递归出口\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> sArray;\n        while(head)\n        {\n            sArray.push_back(head->val);\n            head = head->next;\n        }\n\n        return sortedArraytToBST(sArray,0,sArray.size());\n    }\n\n    TreeNode* sortedArraytToBST(vector<int> sArray,int begin,int end)\n    {\n        if(begin == end)\n        {\n            return NULL;\n        }\n\n        int middle = (begin + end) / 2;\n        TreeNode* root = new TreeNode(sArray[middle]);\n\n        root->left = sortedArraytToBST(sArray,begin,middle);\n        root->right = sortedArraytToBST(sArray,middle + 1,end);\n\n        return root;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310186848","body":"### 思路\n\n       BF: 采用最简单的思路，在遍历listA的每个节点时，遍历一次listB，找出是否存在相等的节点地址，如存在，返回该节点地址；如不存在，返回NULL\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* temA = headA;\n        while(temA != NULL)\n        {\n            ListNode* temB = headB;\n            while(temB != NULL)\n            {\n                if(temA == temB)\n                {\n                    return temA;\n                }\n                temB = temB->next;\n            }\n            temA = temA->next;\n        }\n\n        return NULL;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n)\n- 空间复杂度：O(1)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311149896","body":"### 思路\n\n1. 用一个数组存储已经遍历过的，未成环的节点\n2. 在遍历每个节点时，比较该节点的下一节点与数组中存储的之前的节点，判断是否相等，如相等，则返回该节点的下一节点\n3. 遍历结束，返回NULL\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        vector<ListNode*> noloopNode;\n\n        ListNode* tem = head;\n        while(tem)\n        {\n            if(!noloopNode.empty())\n            {\n                for(ListNode* node : noloopNode)\n                {\n                    if(node == tem->next)\n                    {\n                        return node;\n                    }\n                }\n            }\n            noloopNode.push_back(tem);\n            tem = tem->next;\n        }\n\n        return NULL;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n)\n- 空间复杂度：O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312468271","body":"### 思路\n\nLRU（Least Recently Used）是一种cache替换算法，以下是一种很简单的实现思路，用另一个map来判断出近期最少使用的key值，不过时间复杂度并没有达到要要求，故超时\n\n### 代码\n\n```c++\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        max_size = capacity;\n    }\n    \n    int get(int key) {\n        if(m.find(key) != m.end())\n        {\n            map<int,int>::iterator iter = count.begin();\n            for(;iter != count.end();iter++)\n            {\n                iter->second++;\n            }\n            count[key] = 0;\n\n            return m[key];\n        }\n\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(m.find(key) == m.end())\n        {\n            map<int,int>::iterator iter = count.begin();\n            for(;iter != count.end();iter++)\n            {\n                iter->second++;\n            }\n            \n            if(m.size() < max_size)\n            {\n                m[key] = value;\n                count[key] = 0;\n            }\n            else\n            {\n                map<int,int>::iterator iter = count.begin();\n                map<int,int>::iterator max_count = count.begin();\n                for(;iter != count.end();iter++)\n                {\n                    if(iter->second > max_count->second)\n                    {\n                        max_count = iter;\n                    }\n                }\n                m.erase(max_count->first);\n                count.erase(max_count->first);\n                m[key] = value;\n                count[key] = 0;\n            }\n        }\n        else\n        {\n            map<int,int>::iterator iter = count.begin();\n            for(;iter != count.end();iter++)\n            {\n                iter->second++;\n            }\n\n            m[key] = value;\n            count[key] = 0;\n        }\n    }\n\n    map<int,int> m;\n    map<int,int> count;\n    int max_size;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：put 和 get 都为O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312726284","body":"### 思路\n\n1. 每棵子树寻求当前节点的最大深度的行为都是一样的，我们考虑使用递归的方式求解树的最大深度\n2. 当根节点为 NULL 时，即最大深度为0，返回 0；当根节点是叶子节点时，最大深度为1, 返回1；当根几点是普通节点时，最大深度为左子树和右子树二者中的最大深度加自身代表的深度，返回 max + 1\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root)\n        {\n            return 0;\n        }\n\n        int lSubDepth = maxDepth(root->left);\n        int rSubDepth = maxDepth(root->right);\n\n        return max(lSubDepth,rSubDepth) + 1;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313001330","body":"### 思路\n\n1. 判断两棵子树是否相同的行为是一样的，我们考虑使用递归的方式求解两棵树是否相同\n2. 当两棵树的根节点都为NULL时，返回true；当只有一棵树的根节点为NULL时，返回false；当两棵树的根节点都不为NULL，但当前节点的值不同时返回false；当两颗树的根几点都不为NULL,且当前节点的值相同时，判断这两棵树的左子树和右子树是否都相同\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q)\n        {\n            return true;\n        }\n        if((p && !q) || (!p && q))\n        {\n            return false;\n        }\n        if((p && q) && (p->val != q->val))\n        {\n            return false;\n        }\n        if((p && q) && (p->val == q->val))\n        {\n             return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n        }\n        \n        return false;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315226045","body":"### 思路\n\n1. 分析题意，根据给出示例，树的节点是类似于1->2 ,1->3这样遍历的，可以看出这是一种深度遍历\n2. 采用pre dfs，先求和，再往左，最后往右，利用一个 data member 来对最后的结果进行维护\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        sum = 0;\n        if(!root)\n        {\n            return 0;\n        }\n\n        pre_dfs(root,root->val);\n\n        return sum;\n    }\n    void pre_dfs(TreeNode* node,int tem_sum)\n    {\n        if(!node->left && !node->right)\n        {\n            sum+=tem_sum;\n            return;\n        }\n        if(node->left)\n            pre_dfs(node->left,tem_sum * 10 + node->left->val);\n        if(node->right)\n            pre_dfs(node->right,tem_sum * 10 + node->right->val);\n    }\nprivate:\n    int sum;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316941625","body":"### 思路\n\n1. 题目让我们找树左下角的值，树的左下角的值的定义是最底层且最左边，我们首先要满足最底层这个条件\n2. 和树的层级有关，我们考虑使用层级遍历，即bfs算法\n3. 通过一个变量count 维护每个层级的大小（在插入时维护）；通过一个变量tem_res维护在遍历当前层时的最左边的值，根据队列FIFO的特点，当前层最左边的值即队头的值\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> bfs;\n        bfs.push(root);\n\n        int count = 1;\n        int tem_res = 0;\n        while(!bfs.empty())\n        {\n            int n = 0;\n            tem_res = bfs.front()->val;\n\n            for(int i = 0;i < count;i++)\n            {\n                TreeNode* tem = bfs.front();\n                if(tem->left)\n                {\n                    bfs.push(tem->left);\n                    n++;\n                }\n                if(tem->right)\n                {\n                    bfs.push(tem->right);\n                    n++;\n                }\n                bfs.pop();\n            }\n            count = n;\n        }\n\n        int res = tem_res;\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318826145","body":"### 思路\n\n1. 题目对我们的输入输出格式没有要求，我们考虑使用思路简单的前序深度遍历算法\n2. pre dfs 对二叉树进行序列化操作时，顺序为DLR；同理对二叉树进行反序列化操作时，顺序也为DLR\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if(!root)\n        {\n            return \"null\";\n        }\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right) + \" \";\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        stringstream data_stream(data);\n        return pre_dfs(data_stream);\n    }\n    TreeNode* pre_dfs(stringstream& ss){\n        string tem;\n        ss >> tem;\n        if(tem == \"null\")\n        {\n            return NULL;\n        }\n\n        TreeNode* root = new TreeNode(stoi(tem));\n        root->left = pre_dfs(ss);\n        root->right = pre_dfs(ss);\n    \n        return root;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319557097","body":"### 思路\n\n1. 通过一个二维数组保存下所有节点的坐标及值信息，采用层序遍历算法\n2. 首先满足第一个要求，即从左到右；之后通过对得到的已满足第一个要求的数组进行排序，依次满足从上到下以及从小到大的要求\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> all_loc;\n        int arr[3] = {0,0,root->val};\n        vector<int> vec(arr,arr + 3);\n        all_loc.push_back(vec);\n\n        bfs(root,all_loc);\n\n        int x_min = 0;\n        int x_max = 0;\n        for(int i = 0;i < all_loc.size();i++)\n        {\n            if(all_loc[i][1] < x_min)\n            {\n                x_min = all_loc[i][1];\n            }\n            if(all_loc[i][1] > x_max)\n            {\n                x_max = all_loc[i][1];\n            }\n        }\n        cout << x_min << x_max;\n\n        vector<vector<int>> res;\n        for(int i = x_min;i <= x_max;i++)\n        {\n            vector<vector<int>> match_loc;\n            for(int j = 0;j < all_loc.size();j++)\n            {\n                if(all_loc[j][1] == i)\n                {\n                    match_loc.push_back(all_loc[j]);\n                }\n            }\n\n            for(int m = 0;m < match_loc.size();m++)\n            {\n                for(int n = m + 1;n < match_loc.size();n++)\n                {\n                    if(match_loc[n][0] < match_loc[m][0])\n                    {\n                        vector<int> tem = match_loc[m];\n                        match_loc[m] = match_loc[n];\n                        match_loc[n] = tem;\n                    }\n                    if(match_loc[n][0] == match_loc[m][0])\n                    {\n                        if(match_loc[n][2] < match_loc[m][2])\n                        {\n                            vector<int> tem = match_loc[m];\n                            match_loc[m] = match_loc[n];\n                            match_loc[n] = tem;\n                        }    \n                    }\n                }\n            }\n\n            vector<int> tem;\n            for(int k = 0;k < match_loc.size();k++)\n            {\n                tem.push_back(match_loc[k][2]);\n            }\n            res.push_back(tem);\n        }\n\n        return res;\n    }\n    \n    void bfs(TreeNode* root,vector<vector<int>>& all_loc){\n        queue<TreeNode*> nodes;\n        nodes.push(root);\n\n        while(!nodes.empty())\n        {\n            TreeNode* tem = nodes.front();\n\n            if(tem->left)\n            {\n                for(int i = 0;i < all_loc.size();i++)\n                {\n                    if(all_loc[i][2] == tem->val)\n                    {\n                        int y = all_loc[i][0];\n                        int x = all_loc[i][1];\n                        int arr[3] = {y + 1,x - 1,tem->left->val};\n                        vector<int> vec(arr,arr + 3);\n\n                        all_loc.push_back(vec);\n                        break;\n                    }\n                }\n                nodes.push(tem->left);\n            }\n\n            if(tem->right)\n            {\n                for(int i = 0;i < all_loc.size();i++)\n                {\n                    if(all_loc[i][2] == tem->val)\n                    {\n                        int y = all_loc[i][0];\n                        int x = all_loc[i][1];\n                        int arr[3] = {y + 1,x + 1,tem->right->val};\n                        vector<int> vec(arr,arr + 3);\n\n                        all_loc.push_back(vec);\n                        break;\n                    }\n                }\n                nodes.push(tem->right);\n            }\n\n            nodes.pop();\n        }\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n*n)\n- 空间复杂度：O(n*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320780215","body":"### 思路\n\n采用哈希表带来时间复杂度为O(1)的查找\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> m;\n        \n        for(int i = 0;i < nums.size();i++)\n        {\n            if(m.find(target - nums[i]) != m.end())\n                return {m[target - nums[i]],i};\n            m[nums[i]] = i;\n        }\n\n        return {};\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1326426936","body":"### 思路\r\n\r\n1. 通过哈希表保存每个数字以及其对应出现的次数\r\n2. 通过优先队列（小顶堆）保存前k个数字出现次数最多的pair（通过自己定义函数对象实现）\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int,int> cnt;\r\n        for(int i = 0;i < nums.size();i++)\r\n        {\r\n            cnt[nums[i]]++;\r\n        }\r\n\r\n        class MyGreater\r\n        {\r\n        public:\r\n            bool operator()(const pair<int,int>& p1,const pair<int,int>& p2)\r\n            {\r\n                return p1.second > p2.second;\r\n            }\r\n        };\r\n\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,MyGreater> q;\r\n        for(auto n : cnt)\r\n        {\r\n            q.push(n);\r\n            if(q.size() > k)\r\n            {\r\n                q.pop();\r\n            }\r\n        }\r\n\r\n        vector<int> res;\r\n        while(!q.empty())\r\n        {\r\n            res.push_back(q.top().first);\r\n            q.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298271102","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n=num.size();\r\n        vector<int> knum,res;\r\n        int bitsign=0;\r\n      \r\n        while(k>=1){\r\n        \r\n            knum.push_back(k-k/10*10);\r\n            k=k/10;\r\n        }\r\n        reverse(num.begin(),num.end());\r\n        int t=min(num.size(),knum.size());\r\n        for(int i=0;i<t;i++){\r\n            int bit=num[i]+knum[i]+bitsign;\r\n            \r\n            if(bit>=10){\r\n                res.push_back(bit-10);\r\n                bitsign=1;}\r\n\r\n            else \r\n            {res.push_back(bit);\r\n            bitsign=0;}\r\n        }\r\n        if(num.size()>knum.size()){\r\n            for(int i=knum.size();i<num.size();i++) res.push_back(num[i]);\r\n        }\r\n        else  for(int i=num.size();i<knum.size();i++) res.push_back(knum[i]);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299919275","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.length();\n        \n        vector<int> res;\n        for(int i=0;i<n;i++){\n           \n            if(s[i]==c) res.push_back(0);\n            else{\n                 for(int p=0,q=0;q<n-i||p<i;p++,q++){\n                     if(s[i+q]==c) {\n                         res.push_back(q);\n                         break;\n                         }\n                    if(s[i-p]==c){\n                        res.push_back(p);\n                        break;\n                    }\n\n                 }\n                \n                \n            }\n            \n        }\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301752515","body":"class CustomStack {\n    private List<Integer> stack=new ArrayList<>();\n    private int size;\n    \n\n    public CustomStack(int maxSize) {\n        size=maxSize;\n\n    }\n    \n    public void push(int x) {\n        if(stack.size()<size){\n        stack.add(x);}\n\n    }\n    \n    public int pop() {\n        return stack.isEmpty()?-1:stack.remove(stack.size()-1);\n\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<stack.size();i++){\n            stack.set(i,stack.get(i)+val);\n        }\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303098142","body":"```\r\nclass Solution:\r\n\r\n    def decodeString(self, s: str) -> str:\r\n\r\n        result = ''\r\n        string_stack = []\r\n        data = 0\r\n        for i in s:\r\n            if(i.isdigit()):\r\n                data = data*10 + int(i)\r\n\r\n            elif(i == '['):\r\n                string_stack.append([data, result])\r\n                result = ''\r\n                data = 0\r\n\r\n            elif(i.isalpha()):\r\n                result += i\r\n\r\n            elif(i == ']'):\r\n                result = string_stack[-1][1] + string_stack[-1][0] * result\r\n                string_stack.pop()\r\n        return result\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304412237","body":"```\r\npublic class MyQueue{\r\n   Stack<Integer> stack1;\r\n   Stack<Integer> stack2;\r\n```\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if(!stack2.isEmpty()){\r\n            return stack2.pop();\r\n        }else{\r\n            while(!stack1.isEmpty()){\r\n                int topValue=stack1.pop();\r\n                stack2.push(topValue);\r\n            }\r\n            return stack2.pop();\r\n        }\r\n    }\r\n\r\n    public int peek() {\r\n        if(!stack2.isEmpty()){\r\n            return stack2.peek();\r\n        }else{\r\n            while(!stack1.isEmpty()){\r\n                int topValue=stack1.pop();\r\n                stack2.push(topValue);\r\n            }\r\n            return stack2.peek();\r\n        }\r\n\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack1.isEmpty()&&stack2.isEmpty();\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304660862","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int n = arr.size();\r\n        vector<int> vmin(n+1, 1e8);\r\n        vector<int> vmax(n+1, 0);\r\n        for(int i=1;i<=n;i++) vmax[i] = fmax(vmax[i-1], arr[i-1]);\r\n        for(int i=n-1;i>=0;i--) vmin[i] = fmin(vmin[i+1], arr[i]);\r\n        int ans = 1;\r\n        for(int j=1;j<n;j++){\r\n            if(vmax[j] <= vmin[j]){\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304871633","body":"`\npublic:\n    ListNode* rotateRight(ListNode* head, int k) \n    {\n     if (head == NULL || k <= 0)\n\t\treturn head;\n\tListNode *end = NULL;\n\tListNode *index = head;\n\tListNode *cur = head;\n\tint len = 1;\n\twhile (cur->next != NULL)\n\t{\n\t\tlen++;\n\t\tcur = cur->next;\n\t}\n\tend = cur;\n\t//cout << len << endl;\n\n\tint rotateTimes =  k%len;\n\tif (rotateTimes == 0)\n\t\treturn head;\n\n\t//set ring\n\tend->next = head;\n\tint step = len  - rotateTimes;\n\twhile (step > 0)\n\t{\n\t\tstep--;\n\t\tindex = index->next;\n\t\tend = end->next;\n\t}\n\tend->next = NULL;\n\n\treturn index;\n    }\n};\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306087055","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n          ListNode prev=new ListNode();\r\n          prev.next=head;\r\n          ListNode cur=prev;\r\n          while(cur.next!=null&&cur.next.next!=null){\r\n              ListNode node1=cur.next;\r\n              ListNode node2=cur.next.next;\r\n              cur.next=node2;\r\n              node1.next=node2.next;\r\n              node2.next=node1;\r\n              cur=node1;\r\n          }\r\n          return prev.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308495117","body":"```\nclass Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head,null);\n    }\n\n    public TreeNode buildTree(ListNode left,ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMid(left,right);\n        TreeNode root = new TreeNode();\n        root.val = mid.val;\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    public ListNode getMid(ListNode left,ListNode right){\n        ListNode slow = left;\n        ListNode fast = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310514312","body":"```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311689964","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n\r\n        if(head == NULL) return head;\r\n        ListNode* slow = head, *fast = head, *ret = head;\r\n        while(fast && fast->next != NULL)\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if(slow == fast)\r\n            {\r\n                while(ret != slow)\r\n                {\r\n                    ret = ret-> next;\r\n                    slow = slow-> next;\r\n                }\r\n                return ret;\r\n            }\r\n        }\r\n        return NULL;\r\n}\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312251292","body":"```\nclass LRUCache {\n    private int cap;\n    private Map<Integer,Integer> map=new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n    this.cap=capacity;\n    }\n    \n    public int get(int key) {\n        if(map.keySet().contains(key)){\n            int value=map.get(key);\n            map.remove(key);\n            map.put(key,value);\n            return value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if(map.keySet().contains(key)){\n            map.remove(key);\n        }else if(map.size()==cap){\n            Iterator<Map.Entry<Integer,Integer>> iterator=map.entrySet().iterator();\n            iterator.next();\n            iterator.remove();\n        }\n        map.put(key,value);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312610440","body":"```\r\n\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        int res = 0;\r\n        queue<TreeNode*> q{{root}};\r\n        while (!q.empty()) {\r\n            ++res;\r\n            for (int i = q.size(); i > 0; --i) {\r\n                TreeNode *t = q.front(); q.pop();\r\n                if (t->left) q.push(t->left);\r\n                if (t->right) q.push(t->right);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n`````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312960180","body":"```c++\nclass Solution{\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    return inorderTraversal(p,q);\n}\nprivate boolean inorderTraversal(TreeNode p, TreeNode q) {\n    if(p==null&&q==null){\n        return true;\n    }else if(p==null || q==null){\n        return false;\n    }\n    \n    if(!inorderTraversal(p.left,q.left)){\n        return false;\n    }\n   \n    if(p.val!=q.val){\n       return false;\n    }\n   \n    if(!inorderTraversal(p.right,q.right)){\n        return false;\n    }\n    return true;\n}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314266558","body":"```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if(root==null) return 0;\n        dfs(root,root.val);\n         return sum;\n    }\n    int sum=0;\n    private void dfs(TreeNode root,int cursum){\n        if(root.left==null&&root.right==null){\n            sum+=cursum;\n            return;\n        }\n        if(root.left!=null){\n            dfs(root.left,cursum*10+root.left.val);\n        }\n        if(root.right!=null){\n            dfs(root.right,cursum*10+root.right.val);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316332285","body":"```Java\npublic class Solution {\n \n    public int findBottomLeftValue(TreeNode root) {\n        List<TreeNode> list = new ArrayList<>();\n        list.add(root);\n        TreeNode treeNode = levelSearch(list);\n        return treeNode.val;\n    }\n \n    private TreeNode levelSearch(List<TreeNode> list) {\n        List<TreeNode> nextList = new ArrayList<>();\n        for (TreeNode node : list) {\n            if (node.left != null) {\n                nextList.add(node.left);\n            }\n            if (node.right != null) {\n                nextList.add(node.right);\n            }\n        }\n        if (nextList.size() == 0) {\n            return list.get(0);\n        }\n        return levelSearch(nextList);\n    }\n \n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317994693","body":"```c++\nclass Codec {\npublic:\n \n    \n    string serialize(TreeNode* root) {\n        string str=\"\";\n        if(!root)return str;\n        search_pre(root,str);\n        return str;\n    }\n \n   \n    TreeNode* deserialize(string data) {\n        if(data.compare(\"\")==0)return nullptr;\n        TreeNode* head;\n        create_tree(head,data);\n        return head;\n    }\nprivate:\n   \n    void search_pre(TreeNode* root,string& str)\n    {\n        str+=to_string((long long)root->val);\n        str+=\",\";\n        if(root->left)search_pre(root->left,str);\n        else str+=\"null,\";\n        if(root->right)search_pre(root->right,str);\n        else str+=\"null,\";\n    }\n    \n    void create_tree(TreeNode*& root,string& str)\n    {\n        \n        int num=find_next_num(str);\n        if(num==INT_MIN)return;\n        root=new TreeNode(num);\n        create_tree(root->left,str);\n        create_tree(root->right,str);\n    }\n \n    int find_next_num(string& str)\n    {\n        int num=str.find(\",\");\n        string temp=str.substr(0,num);\n        str.erase(0,num+1);\n        if(temp.compare(\"null\")==0)return INT_MIN;//null return INT_MIN\n        else return stoi(temp);\n    }\n \n    \n    int stoi(string str)\n    {\n        bool negative=false;\n        if(str[0]=='-')\n        {\n            negative=true;\n            str.erase(0,1);\n        }\n        int n=str.length(),ans=0;\n        for(int i=0;i<n;++i)\n        {\n            ans+=(str[i]-'0')*(int)pow(10.0,n-i-1);\n        }\n        return negative?-ans:ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319344643","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes=new ArrayList<int[]>();\n        dfs(root,0,0,nodes);\n        Collections.sort(nodes,new Comparator<int[]>(){\n            public int compare(int[] a,int[] b){\n                if(a[0]!=b[0])\n                {return a[0]-b[0];}\n                else if(a[1]!=b[1]){\n                    return a[1]-b[1];\n                }\n                else {\n                    return a[2]-b[2];\n                }\n        }\n        });\n        List<List<Integer>> traversal=new ArrayList<List<Integer>>();\n        int col=Integer.MIN_VALUE;\n        int index=-1;\n        for(int[] node:nodes){\n            int curCol=node[0];\n            if(col!=curCol){\n                col=curCol;\n                traversal.add(new ArrayList<Integer>());\n                index++;\n            }\n            traversal.get(index).add(node[2]);\n        }\n        return traversal;\n\n    }\n    public void dfs(TreeNode node,int row,int col, List<int[]> nodes){\n        if(node==null)\n        return;\n        nodes.add(new int[]{col,row,node.val});\n        dfs(node.left,row+1,col-1,nodes);\n        dfs(node.right,row+1,col+1,nodes);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320806965","body":"```c\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n=nums.size();\n        vector<int> res;\n        int m=res.size();\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if(nums[i]+nums[j]==target) {\n                    res.push_back(i);\n                    res.push_back(j);\n                    break;\n                    \n                }\n                \n            }\n           if(m!=0) break;\n        }\n        return res;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321008875","body":"```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n              HashMap<Integer, Integer> count = new HashMap();\n                for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1);\n         PriorityQueue<Integer> heap = new PriorityQueue<Integer>((a, b) -> count.get(a) - count.get(b));\n        for (int n : count.keySet()) {\n            heap.add(n);\n            if (heap.size() > k)\n                heap.poll();\n        }\n        List<Integer> top_k = new LinkedList();\n        while (!heap.isEmpty())\n            top_k.add(heap.poll());\n        return top_k;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321246084","body":"```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res=0;\n        for(int i=0;i<points.size();i++) {\n            unordered_map<int,int> m;\n            for(int j=0;j<points.size();j++) {\n                int dx=points[i][0]-points[j][0];\n                int dy=points[i][1]-points[j][1];\n                m[dx*dx+dy*dy]++;\n            }\n            for(auto i:m) {\n                res+=i.second*(i.second-1);\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322870088","body":"```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n          int n=0;\n          int m=1;\n          int M=1;\n          int L=s.length();\n        while(m<L){\n            if(s[m]!=s[n]){\n                m++;\n                int t=m-n+1;\n                M=(M>t)?M:t;\n                }\n            \n            else{\n               n++;\n               m++;  \n}\n          }\n         return  M;\n       }\n    };\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1323951692","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        int totalLen = s.length();\n        int len = words[0].length();\n        int n = words.length;\n        if (n*totalLen == 0){\n            return result;\n        }\n        HashMap<String,Integer> wordMap = new HashMap<>();\n        for (String word:words) {\n            int value = wordMap.getOrDefault(word, 0);\n            wordMap.put(word,value+1);\n        }\n        \n        for (int i = 0; i <totalLen-n*len+1; i++) {\n          \n            Map<String,Integer> hasWords = new HashMap<>();\n            int num = 0;\n            while (num < n){\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\n                if (wordMap.containsKey(currWord)){\n                    int value = hasWords.getOrDefault(currWord,0);\n                    hasWords.put(currWord,value+1);\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\n                        break;\n                    }\n                }else {\n                    break;\n                }\n                num++;\n            }\n            if (num == n){\n                result.add(i);\n            }\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325960542","body":"```java\nclass Solution{\n    public int subarraysDivByK(int[] A, int K) {\n        int count=0;\n        int preSum=0;\n        Map<Integer,Integer> map=new HashMap<>();\n        map.put(0,1);\n        for(int a: A){\n            preSum+=a;\n\n            int currMo=(preSum%K+K)%K;\n            int preMoCount=map.getOrDefault(currMo,0);\n            \n            count+=preMoCount;\n            map.put(currMo,preMoCount+1);\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327020514","body":"```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* p=head;\n        int n=0;\n        while(p->next!=NULL){\n            n++;\n            p=p->next;\n        }\n        if(n%2!=0){\n            for(int i=0;i<=n/2+1;i++){\n                p=p->next;\n            }\n            return p;\n        }\n        else{\n         if(p!=NULL)\n         for(int i=0;i<=n/2+2;i++){\n                 p=p->next;\n            }\n            return p;\n        }\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327988198","body":"```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n=nums.length;\n        int l=0,r=0;\n        while(r<n){\n            while(r<n&&nums[r]==nums[l]) r++;\n            if(r<n){\n                l++;\n                nums[l]=nums[r];\n            }\n        }\n        return l+1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328105749","body":"```c++\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int m=nums.size();\n               for(int i=0;i<m;i++){\n            if(nums[i]==target) return i;\n            else if(nums[i]>target) return i;\n            else continue;\n\n        }\n        return m;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328853640","body":"```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n=nums.size();\n        int max=nums[0];\n        vector<int> ans;\n        if(n==1) {\n             ans.push_back(nums[0]);\n             return ans;\n        }\n        if(k==1){\n            for(int i=0;i<n;i++){\n                ans.push_back(nums[i]);\n            }\n            return ans;\n        }\n       \n    \n        for(int i=0;i<k-1;i++){\n           if(nums[i]<nums[i+1]) max=nums[i+1];\n           else max=nums[i];\n          \n        }\n         ans.push_back(max);\n        for(int i=1,j=k;j<n;i++,j++){\n            if(nums[i]>max) max=nums[i];\n            if(nums[j]>max) max=nums[j];\n            ans.push_back(max);\n\n\n        }\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330264168","body":"```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        int size=trust.size();\n        vector<int> res,ans;\n        for(int i=0;i<size;i++){\n            res.push_back(trust[i][0]);\n            \n        }\n        \n        for(int i=1;i<n;i++){\n            for(int j=0;j<size;j++){\n                if(i=res[j]) break;\n                }\n            ans.push_back(i);\n        }\n        int p=ans.size();\n        if(p!=1) return -1;\n        else return ans[0];\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331625291","body":"```python\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        graph = collections.defaultdict(list)\n        for u, v in dislikes: \n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}  \n        def dfs(node, c = 0):  \n            if node in color:  \n                return color[node] == c  \n            color[node] = c \n            return all(dfs(nei, c ^ 1) for nei in graph[node]) \n\n        return all(dfs(node) for node in range(1, N+1) if node not in color) \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333565881","body":"```c++\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        for(int i = 0; i < n; i++)\n        {\n            if(group[i] == -1)\n                group[i] = m++;\n        }\n        vector<vector<int>> itemgraph(n);\n        vector<vector<int>> groupgraph(m);\n        vector<int> itemIndegree(n, 0);\n        vector<int> groupIndegree(m, 0);\n        for(int i = 0; i < n; i++)\n        {\n            for(auto j : beforeItems[i])\n            {\n                itemgraph[j].push_back(i);\n                itemIndegree[i]++;\n                if(group[i] != group[j]) \n                {\t\n                    groupgraph[group[j]].push_back(group[i]);\n                    groupIndegree[group[i]]++;\n                }\n            }\n        }\n        vector<vector<int>> g_items(m);\n        \n        queue<int> q;\n        for(int i = 0; i < n; i++)\n            if(itemIndegree[i] == 0)\n                q.push(i);\n        int countItem = 0;\n        while(!q.empty())\n        {\n            int i = q.front();\n            q.pop();\n            countItem++;\n            g_items[group[i]].push_back(i);\n             for(auto j : itemgraph[i])\n            {\n                if(--itemIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countItem != n)\n            return {};\n        vector<int> g_order;\n        for(int i = 0; i < m; i++)\n            if(groupIndegree[i] == 0)\n                q.push(i);\n        int countgroup = 0;\n        while(!q.empty())\n        {\n            int g = q.front();\n            q.pop();\n            countgroup++;\n            g_order.push_back(g);\n            for(auto j : groupgraph[g])\n            {\n                if(--groupIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countgroup != m)\n            return {};\n        vector<int> ans(n);\n        int idx = 0;\n        for(auto g : g_order)\n        {\n            for(auto i : g_items[g])\n                ans[idx++] = i;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335053468","body":"```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int n=moves.length();\n        int x=0,y=0;\n        for(int i=0;i<n;i++){\n            if(moves[i]=='R') x++;\n            if(moves[i]=='L') x--;\n            if(moves[i]=='U') y++;\n            if(moves[i]=='D') y--;   \n        }\n        if(x==0&&y==0) return true;\n        else return false;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298276676","body":"```java\n/**\n    TC: O(max(N,logk)), N为数组的长度\n    SC: O(max(N,logk))\n*/\n\n// Method 2: 将 加数 k 整个 加入数组表示的数的最低位\n//           3 + 912 = 915, 5 留在当前这一位，将 910 / 10 = 91 以进位的形式加入下一位\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        for (int i = N - 1; i >= 0; i--){\n            int sum = num[i] + k;\n            res.add(0, sum % 10);\n            k = sum / 10;   // 更新 k 存进位 carry\n        }\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n\n// Method 1: 两个数拆解后 同时 从后往前逐位相加\nclass Solution1 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        \n        int i = N - 1;\n        int sum = 0, carry = 0;\n        while (i >= 0 || k > 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299355292","body":"```java\n/**\n    思路:     对每一个 i 从中心扩散找最近的 C     O(n^2)\n        ==>  空间换时间, 存储所有 c 的位置       O(nk), 出现 k 次\n        ==>  Greedy, 只关心最近的 C ==> 正向遍历+反向遍历\n    ------------------------------------------------------------------\n    实现:\n        两个数组 left 和 right 分别记录每个字符左/右侧出现的最后一个 C 字符的下标\n        同时比遍历这两个数组, 计算距离最小值\n\n    优化:    \n        1. 只需要最近的 C, 所以看情况可以覆盖掉第一个数组的值\n            case 1. 字符的左侧没有出现过 C 字符\n            case 2. i - left > right - i\n        2. 直接记录 C 与当前字符的距离, 而不是 C 的下标, 还可以省去最后遍历计算距离的过程\n                \n    TC: O(N), SC: O(1)      1ms\n*/\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        dist[0] = s.charAt(0) == c ? 0 : N;\n        for (int i = 1; i < N; i++) {\n            dist[i] = s.charAt(i) == c ? 0 : dist[i - 1] + 1;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n            dist[i] = Math.min(dist[i], dist[i + 1] + 1);  // 左侧距离 > 右侧距离, 未遇到 C 默认距离为 N\n        }\n        return dist;\n    }\n}\n\n/**\n    sliding window: 把 c 看成 s 的分割线\n    XXXX | XXXX | XXXXXX\n    \n    TC: O(N), SC: O(1)\n*/\nclass Solution1 {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        \n        int l = s.charAt(0) == c ? 0 : N;\n        int r = s.indexOf(c);\n        for (int i = 0; i < N; i++) {\n            dist[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n            if (i == r) {\n                l = r;\n                r = s.indexOf(c, l + 1);\n            }\n        }\n        return dist;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301193737","body":"```java\n/**\n    因为 stack 的 maxSize 限定 很直观能想到用 arr 解决\n    问题在于 如果让 increment 的 TC 能从 O(k) 降到 O(1)\n    \n    可以添加一个辅助数组 add, 单独储存每个元素的增量\n        1. increment: 将栈底 k 个元素+val, 则将 add[k - 1] += val\n        2. pop: 栈顶值 + add[top], 在次之后, add[top - 1] 累加 add[top]的增量\n                    也就是. add 的值在 pop 之后会向下传递, 自身则清零\n    \n    有点像差分数组的变种\n    这样所有操作 TC 都是 O(1)\n*/\n\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    int size;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.add = new int[maxSize];\n        this.top = -1;\n        this.size = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < size - 1)\n            stack[++top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) return -1;\n        int res = add[top] + stack[top];\n        if (top != 0) add[top - 1] += add[top];\n        add[top] = 0;\n        top--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        // for (int i = 0; i < k && i <= top; i++) {\n        //     stack[i] += val;\n        // }\n        if (top == -1) return;\n        add[Math.min(k - 1, top)] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302804971","body":"```java\n/**\n    TC: O(n), SC: O(n)\n*/\n\n// Method 1: iterative\nclass Solution1 {\n    public String decodeString(String s) {\n        int multi = 0;\n        StringBuilder sb = new StringBuilder();\n        \n        Deque<Integer> multi_stack = new ArrayDeque<>();\n        Deque<String> chars_stack = new ArrayDeque<>();\n        \n        for (char c : s.toCharArray()) {\n            if (c >= '0' && c <= '9') {                 // 1. 倍数\n                multi = multi * 10 + (c - '0');\n            } else if (c >= 'a' && c <= 'z') {          // 2. 字符\n                sb.append(c);\n            } else if (c == '[') {                      // 3. 入栈\n                multi_stack.addLast(multi);             // 接下来[sb]要重复的次数\n                chars_stack.addLast(sb.toString());     // 之前的sb\n                multi = 0;                              // 重置临时变量\n                sb = new StringBuilder();\n            } else { // if (c == ']')                   // 4. 出栈\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = multi_stack.pollLast();\n                for (int i = 0; i < cur_multi; i++)\n                    tmp.append(sb);                     // sb * multi次\n                sb = new StringBuilder(chars_stack.pollLast() + tmp);   // 把之前的和这一次的连起来\n            }\n        }\n        return sb.toString();\n    }\n}\n\n// Method 2: recursive\n//      先解析数字 x, 解析到了左括号 [，递归向下解析后面的内容，遇到对应的右括号就返回 ]\n//      [] 解析结束后, 再继续 解析] 右边的内容\nclass Solution {\n    int i = 0;\n    public String decodeString(String s) {\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            char c = s.charAt(i);\n            i++;\n            if (Character.isLetter(c)) {\n                sb.append(c);\n            } else if (Character.isDigit(c)) {\n                count = count * 10 + (c - '0');\n            } else if (c == ']') {      \n                break;\n            } else if (c == '[') {\n                String repeat = decodeString(s);\n                while (count > 0) {\n                    sb.append(repeat);\n                    count--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304345014","body":"```java\n/**\n    双栈实现 Queue\n    \n    push时压入 input 栈\n    peek 或者 peek 时, 如果 output 栈为空, 那么把 input 栈 pop 出来到 output\n    \n    TC: push: O(1), pop/peek: amortized O(1)\n    SC: O(N)\n*/\nclass MyQueue {\n    Stack<Integer> input = new Stack<>();\n    Stack<Integer> output = new Stack<>();\n\n    public MyQueue() {\n    }\n    \n    public void push(int x) {\n        input.push(x);\n    }\n    \n    public int pop() {\n        if (output.empty()) {\n            while (!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.pop();\n    }\n    \n    public int peek() {\n        if (output.empty()) {\n            while (!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304648451","body":"```java\n/**\n    思路: 和 769 类似\n    块的最大值呈升序排列, 维护一个单调递增栈 保存每个块的最大值\n        如果当前栈为空 || 栈顶 比当前小, 将当前元素 push 进去\n        如果当前栈非空 && 栈顶比当前大, 栈顶应该是目前块的最大值, pop 出来, \n                                    把所有比当前大的元素也 pop 出来\n                                    再把真正的最大值 pop 回去\n    TC: O(N), SC: O(N)\n*/\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] stack = new int[arr.length];\n        int top = -1;\n        for (int i : arr) {\n            if (top != -1 && stack[top] > i) {\n                int max = stack[top--];\n                while (top != -1 && stack[top] > i)\n                    top--;\n                stack[++top] =  max;\n            } else {\n                stack[++top] = i;\n            }\n        }\n        return top + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305036285","body":"```java\n/**\n    思路: 走 k 步, 由于 k 可能很大, 希望 k = k % N\n        1. 遍历, 计算链表长度N, 找到尾结点 tail\n        2. 断开两种方式\n            - 找到新的头结点, 连接旧头尾, 断开得到新的 head, 新的 tail 指向 null\n            - 先连成环, 再找到新的头尾, 断开\n            \n        (用 dummy head 的写法也很有趣)\n    TC: O(n) SC: O(1)\n*/\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy, slow = dummy;\n\n        int N = 0;\n        for (; fast.next != null; N++)\n            fast = fast.next;\n        for (int i = N - k % N; i > 0; i--) \n            slow = slow.next;\n\n        fast.next = dummy.next; \n        dummy.next = slow.next;\n        slow.next = null;\n    \n        return dummy.next;\n    }\n}\n\nclass Solution2 {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        int N = 0;\n        ListNode tail = null;\n        for (ListNode ptr = head; ptr != null; ptr = ptr.next) {\n            tail = ptr;\n            N++;\n        }\n        k %= N;\n        if (k == 0) return head;\n        tail.next = head;\n        for (int i = 0; i < N - k; i++) {\n            tail = tail.next;\n        }\n        ListNode newHead = tail.next;\n        tail.next = null;\n        return newHead;\n    }\n}\n\nclass Solution1 {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        // 1. 计算链表长度, 并找到 tail 节点\n        int N = 0;\n        ListNode tail = null;\n        for (ListNode ptr = head; ptr != null; ptr = ptr.next) {\n            tail = ptr;\n            N++;\n        }\n        // 2. 更新 k\n        k %= N;\n        if (k == 0) return head;\n        // 3. 因为头结点会是倒数 第k 个, 那么前面就有 N - k个节点, ptr 要移动 N - k - 1次\n        ListNode ptr = head;\n        for (int i = 0; i < N - k - 1; i++) {\n            ptr = ptr.next;\n        }\n        // 4. 先把 tail 指向原来的 head, 更新 head, 最后真正的 tail 也就是 ptr的 next 指向 null\n        tail.next = head;\n        head = ptr.next;\n        ptr.next = null;\n        return head;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1305948463","body":"```java\n// 思路: 两两翻转 TC: O(n) SC: O(1)\n// 像这种多次对链表进行相同操作, iterative 的写法用 dummy 节点会很方便\n\n// recursive\nclass Solution1 {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) \n            return head;\n        \n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode others = head.next.next;\n        \n        second.next = first;\n        first.next = swapPairs(others);\n        return second;\n    }\n}\n\n// iterative\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode tmp = dummy;\n        while (tmp.next != null && tmp.next.next != null) {\n            ListNode first = tmp.next;\n            ListNode second = tmp.next.next;\n            tmp.next = second;\n            first.next = second.next;\n            second.next = first;\n            tmp = first;\n        }\n        return dummy.next;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308067264","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// Approach 2: 中序遍历结果是链表本身:     TC: O(n), SC: O(logn)\n//             不直接找到中点的值, 而是构造完左子树, 指针自然指向中间结点, 再构造右子树\nclass Solution {\n    ListNode cur;\n    \n    public TreeNode sortedListToBST(ListNode head) {\n        cur = head;\n        int len = 0;\n        for (ListNode p = head; p != null; p = p.next)\n            len++;\n        return inOrderBuildTree(0, len - 1);\n    }\n    \n    private TreeNode inOrderBuildTree(int left, int right) {\n        if (left > right) return null;\n        int mid = left + (right - left) / 2;\n        \n        TreeNode leftTree = inOrderBuildTree(left, mid - 1);    // 构造左子树\n        TreeNode root = new TreeNode(cur.val);                  // 构造根节点\n        cur = cur.next;\n        TreeNode rightTree = inOrderBuildTree(mid + 1, right);  // 构造右子树\n        \n        root.left = leftTree;\n        root.right = rightTree;\n        return root;\n    }\n}\n\n// Approach 1: 快慢指针找链表中点    TC: O(nlogn), SC: O(logn)\nclass Solution1 {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    \n    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST\n    private TreeNode build(ListNode begin, ListNode end) {\n        if (begin == end) \n            return null; // 左闭右开 -> 空集\n        ListNode mid = getMid(begin, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(begin, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    \n    private ListNode getMid(ListNode begin, ListNode end) {\n        ListNode slow = begin, fast = begin;\n        while (fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309225501","body":"```java\n/**\n    TC: O(N + M), SC: O(1)\n    Approach 2: 计算两 LL 的长度, 长的那个先走差值, 然后再同时走\n*/\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0, lenB = 0;\n        for (ListNode p = headA; p != null; p = p.next) lenA++;\n        for (ListNode p = headB; p != null; p = p.next) lenB++;\n        ListNode p1 = headA, p2 = headB;\n        if (lenA > lenB) {\n            for (int i = 0; i < lenA - lenB; i++) p1 = p1.next;\n        } else {\n            for (int i = 0; i < lenB - lenA; i++) p2 = p2.next;\n        }\n        while (p1 != p2) {\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n\n/**\n    Approach 1: 双指针 遍历AB 两个LL\n    p1 遍历完链表 A 后遍历链表 B，p2 遍历完链表 B 后开始遍历链表 A\n    这样可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1\n    \n    A:    A A C C C B B B | C C C\n    B:    B B B C C C A A | C C C\n*/\nclass Solution1 {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2) {\n            if (p1 == null) p1 = headB;\n            else            p1 = p1.next;\n            if (p2 == null) p2 = headA;\n            else            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310938224","body":"```java\n/**\n    找到 LL 环的入口, 如果无环, 返回 null\n    \n    思路: 快慢指针, 快指针有环会追上慢指针 相遇\n    \n      a     b \n    -----------|    假设慢指针走 x 步, 快指针是 2x, \n        |      |    head 到环入口有 a 个节点, 环有 b 个节点\n        -------| c          \n        \n    x = a + b, 2x = a + b + c + b \n    2a + 2b = a + c + 2b\n    a = c\n    \n    所以 当 slow fast 相遇后, 我们再额外使用一个指针 ptr 指向 head\n    ptr 和 slow 和同时移动, 他们会在环的入口处相遇\n    \n    TC: O(n), SC: O(1)\n*/\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null)\n            return null;\n        \n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        // 无环\n        if (fast == null || fast.next == null)\n            return null;\n        // 有环\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312319429","body":"```java\n/**\n    LRU: 难点在于evict the least recently used key.\n    并且查询, 更新, 删除要 O(1) 完成\n    \n    那么数据结构的要求\n    1. 有时序    <== 删除最久未使用的 key\n    2. Hash     <== 快速找到某个 key 是否存在 \n    3. LL       <== 使用后更新在列表中的位置, 快速删除和添加\n    \n    既可以用LinkedHashMap直接实现, 也可以通过 hashmap 辅助双向链表实现,\n        双向链表 按 使用顺序 储存键值对, hashmap 映射 数据在链表中的位置\n    \n*/\n/**\n    Method 2: DoublyLinkedList + HashMap    60ms 95.39%\n*/\nclass LRUCache {\n    // 1. Node\n    class Node {\n        int key, val;\n        Node next, prev;\n        \n        public Node(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n    // 2. DoublyLinkedList      head -- ...nodes... --tail\n    //      添加/更新在 LL 末尾, 删除任意节点, 删除 oldest 返回新的 head\n    class DLL {\n        Node head, tail;\n        int size;\n        \n        public DLL() {\n            head = new Node(0, 0);\n            tail = new Node(0, 0);\n            head.next = tail;\n            tail.prev = head;\n            size = 0;\n        }\n        \n        public void addLast(Node x) {\n            x.next = tail;\n            x.prev = tail.prev;\n            tail.prev.next = x;\n            tail.prev = x;\n            size++;\n        }\n        \n        public void remove(Node x) {\n            x.prev.next = x.next;\n            x.next.prev = x.prev;\n            size--;\n        }\n        \n        public Node removeFirst() {\n            if (head.next == tail) return null;\n            Node first = head.next;\n            remove(first);\n            return first;\n        }\n    }\n    // 3. HashMap + DLL ==> Cache\n    // Hashmap 要存 key 在 DLL 中对应的 Node 的位置\n    private Map<Integer, Node> map;\n    private DLL cache;\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        this.map = new HashMap<>();\n        this.cache = new DLL();\n        this.capacity = capacity;\n    }\n    \n    // Return the value of the key if the key exists, \n    // otherwise return -1.\n    public int get(int key) {\n        Node node = map.get(key);\n        if (node == null) return -1;\n        updateToRecent(node);\n        return node.val;\n    }\n    \n    // Update the value of the key if the key exists. \n    // Otherwise, add the key-value pair to the cache. \n    // If the number of keys exceeds the capacity from this operation, \n    // evict the least recently used key.\n    public void put(int key, int val) {\n        Node node = map.get(key);\n        if (node == null) {\n            if (cache.size == capacity)\n                removeLeastRecent();\n            addToRecent(key, val);\n        } else {\n            removeNode(node);\n            addToRecent(key, val);\n        }\n    }\n    \n    private void updateToRecent(Node node) {\n        cache.remove(node);\n        cache.addLast(node);\n    }\n    \n    private void addToRecent(int key, int val) {\n        Node newNode = new Node(key, val);\n        cache.addLast(newNode);\n        map.put(key, newNode);\n    }\n    \n    private void removeNode(Node node) {\n        cache.remove(node);\n        map.remove(node.key);\n    }\n    \n    private void removeLeastRecent() {\n        Node leastRecent = cache.removeFirst();\n        map.remove(leastRecent.key);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n// 78ms 82.75%\nclass LRUCache0 extends LinkedHashMap<Integer, Integer> {\n    private int capacity;\n    \n    public LRUCache0(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    // 这个可不写\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312527943","body":"```java\n// TC: O(n), SC: O(height)\n\n// postorder\nclass Solution1 {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n\n// backtrack\nclass Solution {\n    int curDepth = 0;\n    int maxDepth = 0;\n    \n    public int maxDepth(TreeNode root) {\n        traverse(root);\n        return maxDepth;\n    }\n    \n    private void traverse(TreeNode root) {\n        if (root == null) return;\n        curDepth++;\n        maxDepth = Math.max(maxDepth, curDepth);\n        traverse(root.left);\n        traverse(root.right);\n        curDepth--;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313063316","body":"```java\n/**\n *  Preorder  TC:O(n), SC:O(h)\n * /\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null)\n            return p == q;\n        if (p.val != q.val)\n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314554054","body":"```java\n// TC: O(n), SC: O(h)\nclass Solution {\n    int total = 0;\n    \n    public int sumNumbers(TreeNode root) {\n        traverse(root, 0);\n        return total;\n    }\n    \n    private void traverse(TreeNode root, int curSum) {\n        if (root == null) return;\n        curSum = curSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            total += curSum;\n            return;\n        }\n        traverse(root.left, curSum);\n        traverse(root.right, curSum);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316328556","body":"```java\n/**\n    Approach 1:\n    DFS: 先左后右\n        记录遍历到的节点的 height 和 这个 height 最左边节点的值\n        如果 height 大于 curHeight, curVal = 当前节点的值, curHeight = height\n    TC: O(n), SC: O(h)\n*/\nclass Solution1 {\n    int curVal, curHeight;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        curVal = 0;\n        curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n    \n    public void dfs(TreeNode root, int height) {\n        if (root == null) return;\n        height++;\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n        dfs(root.left, height);\n        dfs(root.right, height);\n    }\n}\n\n/**\n    Approach 2: \n    BFS: 先右后左\n        先放右节点再放左节点, 最后一个节点是最底层最左边的节点\n    TC: O(n)    \n    SC: O(n) --> O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树, q 最多保存 n/2 个节点\n*/\nclass Solution2 {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            int sz = q.size();\n            for (int i = 0; i < sz; i++) {\n                TreeNode cur = q.poll();\n                if (cur.right != null) \n                    q.offer(cur.right);\n                if (cur.left != null) \n                    q.offer(cur.left);\n                res = cur.val;\n            }\n        }\n        return res;\n    }\n}\n\n/**\n    Approach 3:\n    BFS: 记录每层最左端的值\n    TC: O(n)    \n    SC: O(n) --> O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树, q 最多保存 n/2 个节点\n*/\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            int sz = q.size();\n            for (int i = 0; i < sz; i++) {\n                TreeNode cur = q.poll();\n                if (i == 0) {\n                    res = cur.val;\n                }\n                if (cur.left != null) \n                    q.offer(cur.left);\n                if (cur.right != null) \n                    q.offer(cur.right);\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317882126","body":"```java\nimport java.util.StringTokenizer;\n/**\n    BT <==> string, 构建满二叉树, null 节点以\"#\"的形式存在于 string 中\n            \n    BFS --> 如果要建的节点是 null, 建 null; 不是 null, 建 new TreeNode(cur.val), 把节点加入 q\n            1,2,3,#,#,4,5,#,#,#,#,\n    DFS -->  注意, preorder 列表最左侧是根节点, postorder 列表最右侧是割接点, deserialize先右后左\n            1,2,#,#,3,4,#,#,5,#,#,\n    TC: O(n)    SC: O(n)\n*/\n// ---------------------- DFS ----------------------\npublic class Codec {\n    String SEP = \",\";\n    String NULL = \"#\";\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        // System.out.println(sb.toString());\n        return sb.toString();\n    }\n    \n    private void serialize(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return;\n        }\n        sb.append(root.val).append(SEP);\n        serialize(root.left, sb);\n        serialize(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        StringTokenizer st = new StringTokenizer(data, SEP);\n        return deserialize(st);\n    }\n    \n    private TreeNode deserialize(StringTokenizer st) {\n        // if (!st.hasMoreTokens()) return null; // 这一句其实写了也不会 call 到的\n        String cur = st.nextToken();\n        if (cur.equals(NULL)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(cur));\n        root.left = deserialize(st);\n        root.right = deserialize(st);\n        return root;\n    }\n}\n\n// ---------------------- DFS: String split----------------------\n\nclass Codec2{\n    String SEP = \",\";\n    String NULL = \"#\";\n    \n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        return sb.toString();\n    }\n    \n    private void serialize(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return;\n        }\n        // sb.append(root.val).append(SEP);\n        serialize(root.left, sb);\n        serialize(root.right, sb);\n        sb.append(root.val).append(SEP);\n    }\n    \n    public TreeNode deserialize(String data) {\n        LinkedList<String> nodes = new LinkedList<>();\n        for (String s : data.split(SEP)) {\n            nodes.addLast(s);\n        }\n        return deserialize(nodes);\n    }\n    \n    private TreeNode deserialize(LinkedList<String> nodes) {\n        if (nodes.isEmpty()) return null;\n        /*--------前序遍历位置, 列表最左侧就是根节点-------*/\n        // String strVal = nodes.removeFirst();\n        String strVal = nodes.removeLast();\n        if (strVal.equals(NULL)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(strVal));\n        /*--------------------------------------------*/\n        // root.left = deserialize(nodes);\n        // root.right = deserialize(nodes);\n        root.right = deserialize(nodes);\n        root.left = deserialize(nodes);\n        return root;\n    }\n}\n\n// ---------------------- BFS ----------------------\n\nclass Codec1 {\n    String SEP = \",\";\n    String NULL = \"#\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            TreeNode cur = q.poll();\n            // Preorder: 把值塞进去\n            if (cur == null) {\n                sb.append(NULL).append(SEP);\n                continue;\n            }\n            sb.append(cur.val).append(SEP);\n            q.offer(cur.left);\n            q.offer(cur.right);\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data.isEmpty()) return null;\n        StringTokenizer st = new StringTokenizer(data, SEP);\n        TreeNode root = new TreeNode(Integer.parseInt(st.nextToken()));\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        while (st.hasMoreTokens()) {\n            TreeNode cur = q.poll();\n            String left = st.nextToken();\n            if (!left.equals(NULL)) {\n                cur.left = new TreeNode(Integer.parseInt(left));\n                q.offer(cur.left);\n            } else {\n                cur.left = null;\n            }\n            String right = st.nextToken();\n            if (!right.equals(NULL)) {\n                cur.right = new TreeNode(Integer.parseInt(right));\n                q.offer(cur.right);\n            } else {\n                cur.right = null;\n            }\n        }\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319445880","body":"```java\n/**\n    1. 遍历二叉树,对所有节点生成坐标\n    2. 对所有节点排序\n        - col: 从左到右\n        - row: 从上到下\n        - val: 从小到大\n    3. 将排序好的节点组装成题目要求的格式\n    \n    TC: O(nlogn)    SC: O(n)\n\n*/\n// PQ\nclass Solution2 {\n    record Info(TreeNode node, int col, int row) {}\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        PriorityQueue<Info> pq = new PriorityQueue<>((a, b) \n                                                     -> a.col != b.col? \n                                                        a.col - b.col : a.row != b.row? \n                                                        a.row - b.row : a.node.val - b.node.val);\n        traverse(root, pq, 0, 0);\n        while (!pq.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            Info cur = pq.poll();\n            tmp.add(cur.node.val);\n            int curCol = cur.col;\n            while (!pq.isEmpty() && pq.peek().col == curCol) {\n                tmp.add(pq.poll().node.val);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n    \n    private void traverse(TreeNode cur, PriorityQueue<Info> pq, int col, int row) {\n        if (cur == null) return;\n        pq.offer(new Info(cur, col, row));\n        traverse(cur.left, pq, col - 1, row + 1);\n        traverse(cur.right, pq, col + 1, row + 1);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320607445","body":"```java\n/**\n    Approach 1: loop all combination\n    两数差i从 1...N - 1, 两数中大数从 i...N - 1遍历所有数\n    TC: (N - 1) * (N - 2) = O(N^2)  SC: O(1)\n*/\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int N = nums.length;\n        for (int i = 1; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                if (nums[j] + nums[j - i] == target) {\n                    return new int[] {j, j - i};\n                }\n            }\n        }\n        return null;\n    }\n}\n\n/**\n    Approach 2: HashMap<num, index>\n    查看对于当前 num, map 中是有 complement 恰好组成 target\n        有则返回, 没有将当前<num, index>存进去\n    TC: O(N), SC: O(N)\n*/\nclass Solution1 {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] {i, map.get(complement)};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321151267","body":"```java\n/**\n    思路一: 堆      TC:O(nlogk) SC:O(n) for hashmap, O(k) for PQ\n*/\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] res = new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i] = queue.poll()[0];\n        }\n        resurn ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321306204","body":"```java\n/**\n    思路: 枚举每个 point 作为 V 型的拐点, 对于其余所有到 V 距离相等的点, 选两个\n    TC: O(N^2)  SC: O(N)\n*/\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        int N = points.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] x : points) {\n            map.clear();\n            for (int[] y : points) {\n                if (x[1] == y[1] && x[0] == y[0]) \n                    continue;\n                int xDist = x[1] - y[1], yDist = x[0] - y[0];\n                int dist = xDist * xDist + yDist * yDist;\n                int num = map.getOrDefault(dist, 0);\n                res += num * 2; // 对于之前每一个相同 dist 的数, 正反两次\n                map.put(dist, num + 1);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322354758","body":"```java\n/**\n    思路一: 滑动窗口\n    1. 要有 memo 记录是否有重复\n    2. 从左到右遍历, 一旦遇到重复, 窗口收缩\n    3. 记录最长长度\n    \n    TC: O(N),   SC: O(1)\n*/\nclass Solution1 {\n    public int lengthOfLongestSubstring(String s) {\n        int N = s.length();\n        if (N <= 1) return N;\n        int[] memo = new int[128];\n        int maxLen = 0;\n        int l = 0, r = 0;\n        for (; r < N; r++) {\n            char in = s.charAt(r);\n            memo[in]++;\n            while (memo[in] != 1) {\n                memo[s.charAt(l++)]--;\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n        }\n        return maxLen;\n    }\n}\n/**\n    思路二: 不用 memo 记录是否有重复, 记录 char 出现的位置 之后一位的位置\n            从而直接缩短窗口\n*/\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int N = s.length();\n        if (N <= 1) return N;\n        int[] memo = new int[128];\n        int maxLen = 0;\n        int l = 0, r = 0;\n        for (; r < N; r++) {\n            char in = s.charAt(r);\n            l = Math.max(l, memo[in]);\n            maxLen = Math.max(maxLen, r - l + 1);\n            memo[in] = r + 1;\n        }\n        return maxLen;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324578071","body":"```java\n/**\n    思路:\n    最好是可以一次遍历, 然后拿到所有的位置, 每次检查的长度为 所有 words 加起来的长度\n    \n    **滑动窗口式检查, 窗口一格格右移**\n        对于每个 word, 检查它在窗口中出现的次数 ?= words 中出现的次数\n        但是这样对于 按照单词长度倍数offset 的窗口来说, 中间的检查都是重复的    \n        \n    **优化**: 根据 起始点 在单词长度中的位置, offset=单词长度的倍数 进行偏移\n    比如说 一个单词长度为 4, 那么 048, 159, 这样检查\n        如果从头向后检查, 碰见没有出现过的 word 组合, 可以跳过之前检查的所有\n                       如果只是 freq 出现太多了, 窗口右移一个 wL, 但是这样其实还是有很多重复的检查 108ms\n        如果从后往前检查, 遇见 freq 出现次数过多或者没见过的 word 可以直接抛弃整个窗口\n                       这样写方便和快太多了 9ms\n        \n    TC: O(wN + sL * wL) ==> 1. 遍历words列表 O(wN) 2. 对于每种起始位置遍历整个 s O(sL * wL)\n    SC: O(wN)   ==> Hashmap\n*/\n\n// 对于每一个窗口从后向前\nclass Solution {\n   public List<Integer> findSubstring(String s, String[] words) {\n       List<Integer> res = new ArrayList<>();\n       \n       Map<String, Integer> wordToFreq = new HashMap<>();\n       for (String w : words) {\n           wordToFreq.put(w, wordToFreq.getOrDefault(w, 0) + 1);\n       }\n       \n       int wN = words.length;\n       int wL = words[0].length();\n       int tL = wL * wN;\n       int sL = s.length();\n       \n       if (tL > sL) return res;\n       \n       for (int k = 0; k < wL; k++) {                       // 起始点 从单词长度不同点开始\n           for (int i = k; i + tL <= sL; i+= wL) {          // 从起始点开始遍历整个 s\n               Map<String, Integer> tmp = new HashMap<>();\n               for (int j = i + tL - wL; j >= i; j -= wL) {\n                   String word = s.substring(j, j + wL);\n                   // System.out.println(word);\n                   int curFreq = tmp.getOrDefault(word, 0) + 1;\n                   int needFreq = wordToFreq.getOrDefault(word, 0);\n                   if (needFreq < curFreq) {\n                       i = j;\n                       break;\n                   } else if (j == i) {\n                       res.add(i);\n                   } else {\n                       tmp.put(word, curFreq);\n                   }\n               }\n               // System.out.println();\n           }\n       }\n       return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326021798","body":"```java\n/**\n    (allSum - rangeSum) % p == 0\n    allSum % p = rangeSum % p\n    \n    TC: O(n)    SC: O(n)\n*/\n\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        // mod for all sum\n        int mod = 0;\n        for (int v: nums) {\n            mod = (mod + v) % p;\n        }\n        if (mod == 0) {\n            return 0;\n        }\n\n        int res = nums.length; // cannot remove the whole array\n\n        Map <Integer, Integer> map = new HashMap < > (); // mod to last idx pos\n        map.put(0, -1);\n\n        int sum = 0, diff = 0;\n        int idx = 0;\n\n        for (int v: nums) {\n            sum = (sum + v) % p;\n            diff = (sum - mod + p) % p;\n            if (map.containsKey(diff)) {\n                res = Math.min(res, idx - map.get(diff));\n            }\n            map.put(sum, idx);\n            idx++;\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326895925","body":"```java\n/**\n    TC: O(n)    SC: O(1)\n    \n    注意写法:                        even 节点个数 (不包括 null)       奇数节点 永远落在正中间\n    fast && fast.next               ==> slow 落在靠右的中间节点\n    fast.next && fast.next.next     ==> slow 落在靠左的中间结点\n    \n*/\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327688730","body":"```java\n/**\n    TC: O(n)    SC: O(1)\n    双指针: 把不同的元素 copy 到前面来 \n*/\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int N = nums.length;\n        int i = 0, j = 1;\n        for (; j < N; j++) {\n            if (nums[j] != nums[i]) {\n                nums[++i] = nums[j];    // [0..i] no duplicates\n            }\n        }\n        return i + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328075334","body":"```java\n/**\n    找左边界: 找得到 left 就是结果, 找不到 left 就是大一位的 position\n    TC: O(nlogn)    SC: O(1)\n*/\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int N = nums.length;\n        int left = 0, right = N;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        } \n        return left;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328339249","body":"```java\n/**\n    将链表 切分成大小为 k 的 chunk\n    然后 left 记录在 chunk 内从左往右的最大值, \n         right 记录 chunk 内从右往左的最大值\n    滑动窗口只需要找 right[i] 和 left[i + k - 1]的最大值\n    \n            1  3  -1  * -3  5  3  *  6  7\n    left    1  3  3     -3  5  5     6  7\n    right   3  3  -1     5  5  3     7  7\n    \n    TC: O(N)    SC: O(N) 4ms\n\n*/\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int N = nums.length;\n        int[] res = new int[N - k + 1];\n        int[] left = new int[N];\n        int[] right = new int[N];\n        for (int i = 0; i < N; i += k) {\n            int max = Integer.MIN_VALUE;\n            int rightBound = Math.min(i + k - 1, N - 1);\n            // from left to right --> \n            for (int j = i; j <= rightBound; j++) {\n                if (nums[j] > max) \n                    max = nums[j];\n                left[j] = max;\n            }\n            // from right to left <--\n            max = Integer.MIN_VALUE;\n            for (int j = rightBound; j >= i; j--) {\n                if (nums[j] > max)\n                    max = nums[j];\n                right[j] = max;\n            }\n        }\n        for (int i = 0; i < N - k + 1; i++) {\n            int j = i + k - 1;\n            res[i] = Math.max(right[i], left[j]);\n        }\n        return res;\n    }\n}\n\n/**\n    维护一个 单调递减 的 Monotonic Queue, 尾进头出\n    TC: O(n)    SC: O(k)\n    36ms\n*/\nclass Solution1 {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int N  = nums.length;\n        int[] res = new int[N - k + 1];\n        Deque<Integer> queue = new ArrayDeque<>();\n        for (int i = 0; i < N; i++) {\n            // 保证窗口内 从大到小, 如果前面的数小则需要一次弹出, 直到满足要求\n            while (!queue.isEmpty() && nums[i] >= nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.addLast(i);\n            // 判断队首的值是否在 k 的滑动窗口内\n            if (queue.peekFirst() <= i - k) {\n                queue.poll();\n            }\n            // 当增长到窗口长度为k时 保存当前窗口中最大值\n            if (i + 1 - k >= 0) {\n                res[i + 1 - k] = nums[queue.peekFirst()];\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329634637","body":"```java\n/**\n\tTC: O(n)\tSC: O(n)\n*/\nclass Solution {\n    public int findJudge(int N, int[][] trust) {\n        if (trust.length < N - 1) \n            return -1;\n        \n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\n        \n        for (int[] t : trust) {\n            trustScores[t[1]]++;\n            trustScores[t[0]]--;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (trustScores[i] == N - 1)\n                return i;\n        }\n        return -1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1330986046","body":"```java\n/**\n    DFS: 遍历边 dfs, 看 source vetex 能不能给 child color 呈不同的颜色\n    \n    1. colors:  0: unseen\n                1 和 -1 互为 opposite color \n    2. 给未 color 的出发点 默认 color 成 1\n    \n    n 个人, m 个 dislike的关系\n    TC: O(n + m)    SC: O(n + m)    18ms\n*/\nclass Solution1 {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] e : dislikes) {\n            graph.get(e[0]).add(e[1]);\n            graph.get(e[1]).add(e[0]);\n        }\n        int[] colors = new int[n + 1];\n        for (int s = 1; s <= n; s++) {\n            if (colors[s] == 0 && !dfs(graph, s, colors, 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private boolean dfs(List<List<Integer>> graph, int s, int[] colors, int color) {\n        colors[s] = color;\n        for (int next : graph.get(s)) {\n            if (colors[next] == -color) continue;\n            if (colors[next] == color) return false;\n            if (!dfs(graph, next, colors, -color)) return false;\n        }\n        return true;\n    }\n}\n\n/**\n    DSU: 5ms\n    \n    a dislike b ==> a 和 b 互相讨厌\n            a 讨厌的人群 (包括 b) 会 share 同一个 parent\n            b 讨厌的人群 (包括 a) 会 share 同一个 parent\n            \n    TC: O(n + m * α(n))  α is inverse of the Ackermann function\n    SC: O(n)\n*/\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        DSU dsu = new DSU(n + 1);\n        \n        for (int[] d : dislikes) {\n            if (!dsu.union(d[0], d[1])) \n                return false;\n        }\n        return true;\n    }\n    \n    class DSU {\n        int[] parent;\n        int[] rival;\n        \n        public DSU(int N) {\n            parent = new int[N];\n            rival = new int[N];\n            Arrays.setAll(parent, r->r);\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public boolean union(int a, int b) { // a dislike b\n            int pa = find(a);\n            int pb = find(b);\n            if (pa == pb) return false;\n            \n            if (rival[a] != 0)\n                parent[rival[a]] = pb;\n            else \n                rival[a] = b;\n            \n            if (rival[b] != 0)\n                parent[rival[b]] = pa;\n            else\n                rival[b] = a;\n            return true;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333299848","body":"```java\n/**\n    topological sort: \n        \n    [6(0), 3(0), 4(0), 1(-1), 5(1), 2(1), 0(-1), 7(-1)]\n    -----------------  -----  ----------  ------------\n    思路一: (这个比较巧妙)\n    将 group 和 item 的关系存在一张 graph 中\n        graph[N + groupId] 是 group\n        graph[0 ... N + 1] 是 item\n        * 对于不属于任何一组的 item, 其实没必要给它一个新组, 因为它可能会穿插在别的组之间\n    \n    对于 graph 的关系\n        item 存在先后顺序, group 也存在先后顺序\n        item --> group      indegree[group]++       根据 group 生成\n        groupA --> groupB   indegree[groupB]++;     根据 beforeItems 生成\n        \n    思路二:\n    先确定 group 的先后, 再确认 item 的先后\n    \n    TC: O(N + M)    SC: O(N + M)\n*/\nclass Solution {\n    int[] res;\n    int idx;\n    \n    public int[] sortItems(int N, int M, int[] group, List<List<Integer>> beforeItems) {\n        int[] indegree = new int[N + M];\n        List<Integer>[] graph = new ArrayList[N + M];\n        for (int i = 0; i < N + M; i++) graph[i] = new ArrayList<>();\n        // 建立 group 的 关系\n        for (int i = 0; i < N; i++) {\n            if (group[i] == -1) continue;\n            graph[N + group[i]].add(i);\n            indegree[i]++;\n        }\n        // 在 group 的基础上, 把 item 放入 group 的列表中\n        for (int i = 0; i < N; i++) {\n            for (int before : beforeItems.get(i)) { // before --> item\n                // find the groupID of i and beforeItem\n                int a = group[before] == -1? before: N + group[before];\n                int b = group[i] == -1? i : N + group[i];\n                if (a == b) { // same group\n                    graph[before].add(i);\n                    indegree[i]++;\n                } else {\n                    graph[a].add(b);\n                    indegree[b]++;\n                }\n            }\n        }\n        // topological sort\n        res = new int[N]; idx = 0;\n        for (int i = 0; i < N + M; i++) {\n            if (indegree[i] == 0)\n                dfs(N, graph, indegree, i);\n        }\n        return (idx == N) ? res : new int[]{};\n    }\n    \n    private void dfs(int N, List<Integer>[] graph, int[] indegree, int cur) {\n        if (cur < N) \n            res[idx++] = cur;\n        indegree[cur]--; // 为了使每个 cur 只触动是否加入 res 一次, 到零之后减成-1\n        for (int next : graph[cur]) {\n            if (--indegree[next] == 0)\n                dfs(N, graph, indegree, next);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334899917","body":"```java\n/**\n    TC: O(N)    SC: O(1)\n*/\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int horiz = 0;\n        int verti = 0;\n        \n        for (char i : moves.toCharArray()) {\n            if (i == 'U') verti++;\n            else if (i == 'D') verti--;\n            else if (i == 'L') horiz--;\n            else if (i == 'R') horiz++;\n        } \n        \n        return horiz == 0 && verti == 0;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298298900","body":"### 解题思路\r\n倒序遍历num逐个与k的数组倒序相加, 设置一个进位sgn=0, 如果有进位sgn=1, 相加的时候把sgn加上\\\r\nk => [num,num...]  少的那个在左边补齐足够的0\r\n❓ 想着是否可以只相加min(num1,num2)长度的，剩下的直接原封不动复制过来，但是99999-xxx 这种怎么办啊😿\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let num2 = [...k.toString()].map(c=> +c);\r\n\r\n  if(num2.length<num.length){\r\n    num2.unshift(...new Array(num.length-num2.length).fill(0));\r\n  } else{\r\n    num.unshift(...new Array(num2.length-num.length).fill(0));\r\n  }\r\n  let n = num.length;\r\n  let sum=0;\r\n  let sgn=0;\r\n  let res=[];\r\n  for(let i=0; i<n;i++){\r\n    sum = num[n-1-i]+num2[n-1-i]+sgn;\r\n    sgn = sum>=10 ? 1: 0;\r\n    res.unshift(sum%10);\r\n  }\r\n  // for结束判断最后一位是否需要再进位\r\n  if (sgn===1){\r\n    res.unshift(1);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间空间都是O(N) ?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300671552","body":"### 解题思路\n1. 抽取出来所有目标字符c所在的索引的数组tar\n2. 每次只需要比较s中的每一位s[i]与它左右两个c的距离然后选最小; \n3. tar数组p指针和p-1控制当前s[i]最近的左右两个命中的目标点, p从1开始（0位置为dum离得非常远所以第一次命中肯定是p)，遍历s数组，当i命中了p对应的tar的值tar[p]也就是当前命中点在s里的索引，就res.push(0),然后右移p,没命中就res.push(min(i-左侧, 右侧-i))\n4. 考虑到只有一个目标的情况，所以索引数组tar左右两端加一个很远的坐标，like: -10000,10000\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n\n  let tar = [-10000];\n  for(let i=0; i<s.length; i++){\n    if(s[i]===c){\n      tar.push(i);\n    }\n  }\n  tar.push(10000);\n  let p = 1;\n  let res = [];\n  for(let i=0; i<s.length; i++){\n    if(i===tar[p]){\n      res.push(0);\n      p++;\n    } else{\n      res.push(Math.min(i-tar[p-1], tar[p]-i))\n    }\n  }\n  return res;\n};\n```\n### 复杂度\n**时间** : O(N) 两次遍历S\n**空间** : O(N) 为tar数组长度的额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301774652","body":"### 解题思路\r\n模拟，构造函数需要两个属性，一个数组stack一个maxSize；\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = new Array();   // [empty, ...]\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  // 最大长度限制\r\n  if(this.stack.length<this.maxSize){\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 栈顶为空的 =》 -1\r\n  if(this.stack.length===0){\r\n    return -1;\r\n  }\r\n  let val = this.stack.pop();\r\n  return val;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n  for(let i=0;i<n;i++){\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n### 复杂度\r\n时间: push/pop 都为O(1), increment需要O(k)\r\n空间: O(N) 一个栈的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303550516","body":"### 解题思路\r\n栈的使用\r\n1. 判断类型： 数字、字母、[、]\r\n  1. 数字 更新m 直接拼接\r\n  2. 字母，更新res, 直接拼接\r\n  3. [: 入栈  stack.push([res, +m])\r\n  4. ]: 出栈  res = pop出来的res +  当前res.repeat(pop出来的multi)\r\n\r\nJS的一些语法复习：\r\n1. 重复3次的str: \r\n  a. str.repeat(3)  ES6的语法\r\n  b. new Array(3).fill(str).join(\"\")\r\n  c. new Array(4).join(str)\r\n2. ASCII码:  0-9 : 48-57 ;  字母a-z: 97-122\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n\r\nvar decodeString = function(s) {\r\n  let m = \"\";\r\n  let stack = [];\r\n  let res = \"\";\r\n  for(let i=0;i<s.length;i++){\r\n    let asc = s[i].charCodeAt();\r\n    // 数字 更新m 直接拼接\r\n    if (asc>=48 && asc<=57){\r\n      m += s[i];  \r\n    } else if(asc>=97 && asc<=122){\r\n      // 字母 更新res\r\n      res += s[i];\r\n    } else if(s[i]==='['){\r\n      // 入栈[res,m] 置空这两个\r\n      stack.push([res,+m]);\r\n      res = '';\r\n      m = '';\r\n    } else if(s[i]===']'){\r\n      // 出栈\r\n      let [beforeRes,multi] = stack.pop();\r\n      res = beforeRes+ res.repeat(multi);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n空间：O(N)\r\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304505032","body":"### 解题思路\r\n几个要注意的点\r\n1. 两个栈首先命名用stackIn和stackOut容易记\r\n2. push永远只往stackIn里\r\n3. pop时先判断stackOut是否为空，不为空直接pop(), 为空就：把stackIn的所有一股脑全部倒入stackOut里\r\n4. 判断empty时记得两个栈都要为空才行\r\n\r\n### JavaScript代码\r\n\r\n```javascript\r\nvar MyQueue = function() {\r\n  // 两个栈 sIn, sOut\r\n  this.sIn = [];   // push永远只压入到这里\r\n  this.sOut = [];   //不为空就pop()  为空就一次性倒完\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.sIn.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if(this.sOut.length!==0){\r\n    return this.sOut.pop();\r\n  } \r\n  while(this.sIn.length!==0){\r\n    this.sOut.push(this.sIn.pop());\r\n  }\r\n  return this.sOut.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if(this.sOut.length!==0){\r\n    return this.sOut.slice(-1);\r\n  }\r\n  while(this.sIn.length!==0){\r\n    this.sOut.push(this.sIn.pop());\r\n  }\r\n  return this.sOut.slice(-1);\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.sIn.length===0 && this.sOut.length===0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n空间：O(N) 两个栈嘛\r\n时间：push和empty很好想就是O(1)； pop和peek思路一样（举个极端例子一连串的push后pop，这时候需要倒完N个到stackOut里，但是之后的push和pop全是一次操作解决，所以其实是O(2)吧，N个操作均摊O(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829528","body":"### 解题思路\r\n1. left[i]: arr[0]-arr[i]最大值\r\n2. right[i]: arr[i]-arr[n-1]的最小值\r\n3. 遍历for(i=1; i<n; n++) 如果arr[i-1]<=arr[i] 就在arr[i]前切一刀\r\n\r\n### Js代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  let l = new Array(arr.length).fill(arr[0]);\r\n  let r = new Array(arr.length).fill(arr[arr.length-1]);\r\n\r\n  let max = arr[0];\r\n  let min= arr[arr.length-1];\r\n  \r\n  for(let i=0; i<arr.length; i++){\r\n    max = Math.max(max, arr[i]);\r\n    l[i] = max;\r\n  }\r\n  for(let i=arr.length-1; i>=0; i--){\r\n    min = Math.min(min, arr[i]);\r\n    r[i] = min;\r\n  }\r\n  \r\n  let cnt = 0;\r\n  for(let j=1; j<arr.length; j++){\r\n    if(l[j-1] <= r[j]) cnt++;\r\n  }\r\n  return cnt+1;\r\n  \r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：两个额外的数组 O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298299088","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # a = ''\n        # for i in num:\n        #     a += str(i)\n        # b = int(a)+k\n        # res = []\n        # for i in str(b):\n        #     res.append(int(i))\n        # return res\n        \n        # return list(map(int,str(int(''.join(map(str,num))) + k)))\n\n        res = []\n        i, carry = len(num) - 1, 0\n        while i >= 0 or k != 0:\n            x = num[i] if i >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            res.append(sum % 10)\n            carry = sum // 10\n\n            i -= 1\n            k //= 10\n        if carry != 0: res.append(carry)\n        return res[::-1]\n\n        \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299676710","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # numlist = []\n        # reslist = []\n        # for i in range(len(s)):\n        #     if s[i] == c:\n        #         numlist.append(i)\n        # for j in range(len(s)):\n        #     reslist.append(min([abs(i - j) for i in numlist]))\n        # return reslist\n\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301871371","body":"class CustomStack:\r\n\r\n\r\n\r\n\r\n\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top+1]\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305611743","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or k == 0 :\r\n            return head\r\n        _len = 0\r\n        tempHead = head\r\n        while tempHead :\r\n            tempHead = tempHead.next\r\n            _len += 1\r\n        k = k % _len\r\n        former = head\r\n        latter = head\r\n        for i in range(0 , k ) :\r\n            former = former.next\r\n        while former.next :\r\n            former = former.next\r\n            latter = latter.next \r\n        former.next = head\r\n        newHead = latter.next\r\n        latter.next = None\r\n        return newHead\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311684700","body":"```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315265960","body":"```class Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326480353","body":" ``` class Solution:\n   def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        record = {0:1}\n        ans,total = 0,0\n        for i in nums:\n            total += i\n            m = total % k\n            l = record.get(m,0)\n            ans += l\n            record[m] = l + 1\n        return ans    \n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328978305","body":"```   class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = collections.deque()\n        res = []\n        if k < 1:\n            return res\n        for i in range (k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n        res.append(nums[q[0]])\n        for i in range (k, n):\n            while q and q[0] <= i-k: \n                q.popleft()\n            while q and nums[q[-1]] <= nums[i]:\n                q.pop()\n            q.append(i)\n            res.append(nums[q[0]])\n        return res ```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298382708","body":"# 解题思路：\n# 把列表转化成字符串，然后强制转化成int\n# 再进行正常的两个数的加法\n# 最后把结果转化成字符串，然后转化成列表\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,A))) + K)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300427307","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), -inf\n        for i, ch in enumerate(s):\n            if ch == c:\n                last = i\n            ans[i] = min(ans[i], i - last)\n        last = inf\n        for i, ch in enumerate(s[::-1]):\n            # 因为两者都有 len(s) - 1 的偏移量，可以一起去掉，减少运算            \n            # if ch == c:\n            #     last = len(s) - 1 - i\n            # ans[-1 - i] = min(ans[-1 - i], last - len(s) + 1 + i)\n            if ch == c:\n                last = -i\n            ans[-1 - i] = min(ans[-1 - i], last + i)\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301761523","body":"```\n/**\n    利用数组来模拟栈\n    注意：\n        1.当栈元素个数等于 maxSize 时不允许继续入栈；\n        2.当栈为空时，出栈操作返回 -1；\n        3.当栈非空，出栈操作发返回栈顶值\n        4.增量操作时，当栈元素多于 k 个，将栈底的 k 个元素都加 val，栈元素少于 k 个时将所有元素都加上 val。\n\n */\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize){\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const item = this.list.pop()\n    return item === void 0 ? -1 : item\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303112859","body":"```\n/**\n    利用栈的思想解题\n      设置两个变量：1.res 最终结果字符串 2.num 用来计数当前字符需要重复多少次 \n      构造两个栈：1.字符栈 strStack，表示需要重复的字符 2.数字栈，需要重复的次数 \n      如果当前 str === 数字，推入数字栈 \n      如果当前 str === [,strStack、numStack 入栈，num，res 清 0 \n      如果当前 str === ],strStack、numStack 出栈，形成一次字符串 \n      其他情况 把字符加到 res 中\n */\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let numStack = [],strStack = [],res = '',num = 0;\n\n    for (let str of s) {\n        if (!isNaN(str)) {\n            num = num * 10 + parseInt(str);\n        } else if (str === '[') {\n            strStack.push(res);\n            numStack.push(num);\n            res = '';\n            num = 0;\n        } else if (str === ']') {\n            res = strStack.pop() + res.repeat(numStack.pop());\n        } else {\n            res += str;\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304500973","body":"两个栈解题，一个输入栈、一个输出栈\nvar MyQueue = function() {\n    this.stackIn = [];\n    this.stackOut = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackIn.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    const size = this.stackOut.length;\n    if(size){\n        return this.stackOut.pop();\n    }\n    while(this.stackIn.length){\n        this.stackOut.push(this.stackIn.pop());\n    }\n    return this.stackOut.pop();  \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stackIn.length && !this.stackOut.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304751374","body":"```\n滑动窗口\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sorted = [...arr];\n    sorted.sort((a,b) => a-b);\n    \n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n    \n    for (let i = 0; i < arr.length; i++){\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if(sum1 == sum2){\n            count++;\n            sum1 = sum2 = 0;\n        }\n    }\n    return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305457790","body":"```\n/**\n 解题思路：快慢指针法\n*/\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head;\n    let len = 0,now = head;\n    while(now){\n        now = now.next;\n        len++;\n    }\n    k = k % len;\n    let slow = (fast = head);\n    while(fast.next){\n        if(k-- <= 0){\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n    let res = slow.next;\n    slow.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307056244","body":"```\n/**\n * 解题思路：虚拟表头\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let ret = new ListNode(0,head),temp = ret;\n    while(temp.next && temp.next.next){\n        let cur = temp.next.next,pre = temp.next;\n        pre.next=cur.next;\n        cur.next=pre;\n        temp.next=cur;\n        temp=pre;\n    }\n    return ret.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308374038","body":"```\n解题思路：快慢指针\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if(!head) return null;\n    return dfs(head,null);\n};\nfunction dfs(head,tail) {\n    if(head ==  tail) return null;\n    let fast = head;\n    let slow = head;\n    while(fast != tail && fast.next != tail){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    let root = new TreeNode(slow.val);\n    root.left = dfs(head, slow);\n    root.right = dfs(slow.next, tail);\n    return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309647716","body":"```\n/** \n * 解题思路：遍历两个链表，若有相同的则为相交结点\n * 通过遍历先把链表A,添加到Set集合 \n * 然后对链表B遍历，使用Set的has方法，如果包含则返回该结点，否则在循环外返回null。\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while(temp !== null){\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while(temp !== null){\n        if(visited.has(temp)){\n            return temp;\n        }\n        temp = temp.next;        \n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311388846","body":"```\n/ **\n * 解题思路：快慢指针法\n * 快指针和慢指针相遇在环上，则有交点，否则无交点\n * 从头继续遍历slow，再次相遇则为交点\n * 根据：\n * f=2s （快指针每次2步，路程刚好2倍）\n * f = s + nb (相遇时，刚好多走了n圈）\n * 推出：s = nb\n * 从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。\n * 如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head == null || head.next == null ) return null;\n    let fast = (slow = head);\n    do{\n        if(fast != null && fast.next != null){\n            fast = fast.next.next;\n        }else{\n            fast = null;\n        }\n        slow = slow.next;\n    }while(fast != slow);\n\n    if(fast == null) return null;\n    fast = head;\n    while(fast != slow){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312476252","body":"```\n/**\n * 解题思路:使用map解决\n */\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let key_has = this.map.has(key);\n    if( key_has){\n       let value = this.map.get(key);\n       this.map.delete(key); // 删除原有值，重新设置，会更新位置\n       this.map.set(key,value);\n       return this.map.get(key);\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 存在则删除\n    if(this.map.has(key)){\n        this.map.delete(key)\n    }\n    // map长度到达临界值则删除第一个\n    if(this.map.size == this.capacity){\n        // 调用map的[Symbol.iterator]生成迭代器，.next获取key\n        const { value: key,done} = this.map.keys().next();\n        this.map.delete(key);\n    }\n    this.map.set(key,value)\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313752596","body":"/**\n * 解题思路：\n * 深度优先遍历\n * 结束条件：当两棵树的当前节点都为空，return true\n * 当其中一个是null 另一个不为null,return false\n * 两个都不为空，且其值不相等，return false\n * 当满足终止条件时进行返回，不满足时分别判断左子树和右子树是否相同，其中要注意代码中的短路效应\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(q == null && p == null) return true;\n    if(p == null || q == null) return false;\n    if(p.val != q.val) return false;\n    return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315267984","body":"```\n/**\n * 思路：递归\n * 遇到叶子节点返回，每层都在取值后*10\n * 左右相加\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return count(root,0);\n};\n\nconst count = (cur,preSum) =>{\n\n    if(!cur) return 0;\n    let sum = preSum *10 +cur.val;\n    if(!cur.left && !cur.right) return sum;\n    else return count (cur.left,sum) + count(cur.right, sum);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316521930","body":"```\n/**\n层次遍历\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let queue = [];\n    if( root === null){\n        return null;\n    }\n    queue.push(root);\n    let resNode;\n    while(queue.length){\n        let length = queue.length;\n        for(let i = 0; i < length; i++){\n            let node = queue.shift();\n            if(  i == 0){\n                resNode = node.val;\n            }\n            node.left && queue.push(node.left);\n            node.right && queue.push(node.right);\n        }\n    }\n    return resNode;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317896869","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  }\n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list); // 构建的入口\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319697151","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    let res=[];\n    const stack = []\n    //前序遍历（迭代）\n    if(root) stack.push([root,0,0])\n    while (stack.length) {\n        const n = stack.pop()\n        let node=n[0];\n        let row=n[1];\n        let col=n[2];\n        res.push([node.val,row,col]);\n        if(node.right) stack.push([node.right,row+1,col+1])\n        if(node.left) stack.push([node.left,row+1,col-1])\n    }\n    //排序\n    res.sort((v1,v2)=>v1[2]-v2[2]||v1[1]-v2[1]||v1[0]-v2[0])\n    //合并\n    let result=[[res[0][0]]];\n    for(let i=1;i<res.length;i++){\n        if(res[i][2]!==res[i-1][2]){\n            result.push([res[i][0]]);\n        }else{\n            result[result.length-1].push(res[i][0])\n        }\n    }\n    return result\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320814363","body":"```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n       \n    let map = new Map();\n    for(let i = 0, len = nums.length; i < len; i++){\n        if(map.has(target - nums[i])){\n            return [map.get(target - nums[i]), i];\n        }else{\n            map.set(nums[i], i);\n        }\n    }\n    return [];\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321072458","body":"```\nvar topKFrequent = function(nums, k) {\n    //前k个高频元素\n    let hash = new Map();\n        //频率统计\n    for(let i of nums){\n        if(!hash.has(i)) hash.set(i,1);\n        else hash.set(i,hash.get(i)+1);\n    }\n    nums=new Array(hash.size);\n    let j=0;\n    for(let [key,value] of hash){\n        nums[j++]=[key,value];\n    }\n    getK(nums,0,nums.length-1,k);\n    let res=new Array(k);\n    for(let i=0;i<k;++i){\n        res[i] = nums[i][0];\n    }\n    return res;\n};\n\n//分治   \nvar getK = function(nums,left,right,k){\n    if(left>=right) return ;\n    let temp = quikSort(nums,left,right,k);\n    if(temp+1==k+left) return ;\n    else if(temp+1<k+left){\n        getK(nums,temp+1,right,k-(temp+1-left));  //前面的temp+1-left已经符合要求 找剩下的k-(temp+1-left)个最大元素\n    } else getK(nums,left,temp-1,k);      //继续找前k个最大元素\n    return ;\n}\n\nvar quikSort = function(nums,left,right){\n    if(left>=right) return left;\n    let pivot = nums[left];\n    let i=left,j=right;\n    while(i<j){\n        while(nums[j][1]<pivot[1] && i<j) --j;\n        nums[i] = nums[j];\n        while(nums[i][1]>=pivot[1] && i<j) ++i;\n        nums[j] = nums[i];\n        if(i==j) nums[i] = pivot;\n    }\n    return i;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321986764","body":"```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let res = 0;\n    for(let i = 0; i < points.length;i++){\n        let map = new Map();\n        for(let j = 0; j < points.length; j++){\n            if(j !== i){\n                let distance = dis(points[i],points[j]);\n                if(map.has(distance)){\n                    map.set(distance,map.get(distance)+1);\n                }else {\n                    map.set(distance,1)\n                }\n            }\n        }\n        map.forEach((count,distance) => res += count * (count-1));\n    }\n    return res;\n};\n\nfunction dis(x, y){\n    return (y[1] - x[1])* (y[1] - x[1]) + (y[0] - x[0]) * (y[0] - x[0]); //坐标两点距离，是+不是-\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323322163","body":"```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let res = 0;\n    for(let i = 0; i < s.length; i++){\n        let map = {};\n        for(let j = i; j < s.length; j++){\n            if(map[s[j]] !== undefined){\n                break;\n            }\n            map[s[j]] = true;\n            res = Math.max(res, j -i +1)\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325245343","body":"```\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    let wordlen=words[0].length;\n    let ans=[];\n    let sub=[]\n    words.sort();\n    let str1=words.toString()\n    for(let i=0;i<s.length;i++){\n        for(let j=0;j<words.length;j++){\n            sub.push(s.substr(i+wordlen*j,wordlen))\n            \n        }\n        sub.sort()\n        if(sub.toString()===str1){\n            ans.push(i)\n        }\n        sub=[]\n    }\n    return ans\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326416348","body":"```\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = floorMod(currSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326982848","body":"```\n/**\n 解题思路：快慢指针\n 详细步骤：使用快慢指针遍历链表，慢指针走一步，快指针走两步，当快指针到达链表最后时，慢指针位于中间\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = fast = (head);\n    while(fast&&fast.next){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328068978","body":"```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    const n = nums.length;\n    if (n === 0) {\n        return 0;\n    }\n    let fast = 1, slow = 1;\n    while (fast < n) {\n        if (nums[fast] !== nums[fast - 1]) {\n            nums[slow] = nums[fast];\n            ++slow;\n        }\n        ++fast;\n    }\n    return slow;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328231473","body":"```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0,\n    right = nums.length - 1;\n    while (left <= right) {\n        const middle = (left + right) >> 1;\n        const middleValue = nums[middle];\n        if (middleValue === target) {\n        return middle;\n        } else if (middleValue < target) {\n        left = middle + 1;\n        } else {\n        right = middle - 1;\n        }\n    }\n    return left;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329110728","body":"```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    let res = [];\n    let que = []; // 队列最多容纳k个数\n    for(let i = 0; i < nums.length; i++) {\n        if(que.length === 0) que.push(nums[i]);\n        else { // 维护队列\n            // 出队列就两种情况\n            // 1、 队头元素不在窗口（从队头出）\n            // 2、 当前元素大于队尾元素（从队尾出）\n            if(i - k >= 0 && nums[i - k] === que[0]) que.shift(); // 当队头元素出窗口时，弹出\n            // 当前元素若大于队尾元素，则移出，直到遇到小于的元素或者队列空了，进队\n            while(que.length > 0 && nums[i] > que[que.length - 1]){\n                que.pop();\n            }\n            que.push(nums[i]);\n        }\n        // 当滑动完k个元素之后开始提取队头元素\n        if(i >= k - 1) res.push(que[0]);\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330709478","body":"```\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const count = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0];\n        const y = edge[1];\n        count[y]++;\n        count[x]--;\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (count[i] === n - 1) {\n        return i;\n        }\n    }\n    return -1;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332182271","body":"```\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n  // 用于记录是否已经染色\n  const colors = new Array(n + 1).fill(0)\n  // 用于记录每个人讨厌的人\n  const dislikeMap = new Map()\n\n  for (const [first, second] of dislikes) {\n    const firstDislike = dislikeMap.get(first) || []\n    const secondDislike = dislikeMap.get(second) || []\n    dislikeMap.set(first, (firstDislike.push(second), firstDislike))\n    dislikeMap.set(second, (secondDislike.push(first), secondDislike))\n  }\n\n  // 深度优先进行染色\n  const dfs = (curPerson, curColor) => {\n    // 染色\n    colors[curPerson] = curColor\n    // 获取讨厌的人\n    const curPersonDislike = dislikeMap.get(curPerson) || []\n\n    for (const dis of curPersonDislike) {\n      // 如果讨厌的人已经染色了，并且颜色和自己一样，那么直接返回false\n      if (colors[dis] !== 0 && colors[dis] === colors[curPerson]) return false\n      // 如果当前还没有进行染色，那么递归调用dfs\n      // curColor ^ 3 实际上就是 把 1 变 2  把 2 变 1\n      if (colors[dis] === 0 && !dfs(dis, curColor ^ 3)) return false\n    }\n    return true\n  }\n\n  for (let i = 1; i <= n; i++) {\n    // 当前还未染色，并且染色过程发生冲突，直接返回false\n    if (colors[i] === 0 && !dfs(i, 1)) {\n      return false\n    }\n  }\n  return true\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335147767","body":"```\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n  let up = 0;\n  let left = 0;\n\n  for (let index = 0; index < moves.length; index++) {\n    switch (moves[index]) {\n      case \"R\":\n        left++;\n        break;\n      case \"L\":\n        left--;\n        break;\n      case \"U\":\n        up++;\n        break;\n      case \"D\":\n        up--;\n        break;\n      default:\n        break;\n    }\n  }\n\n  if (up === 0 && left === 0) {\n    return true;\n  }\n  return false;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298389769","body":"## 思路\n取`num`与数字`k`的最大长度`maxLen`，构造`maxLen`大小的切片，然后从最后遍历数组，进行累加。 最后返回的时候，判断res[0]是否等于0，否则截取res[1:]\n\n## 代码\n\n```golang\nfunc addToArrayForm(num []int, k int) []int {\n\tkLen := 0\n\ttmpK := k\n\tfor tmpK > 0 {\n\t\ttmpK /= 10\n\t\tkLen++\n\t}\n\tnumLen := len(num)\n\tmaxLen := numLen\n\tif kLen > maxLen {\n\t\tmaxLen = kLen\n\t}\n\n\tres := make([]int, maxLen+1)\n\tfor index := numLen - 1; index >= 0; index-- {\n\t\tamount := num[index] + k%10\n\t\tk /= 10\n\t\tif amount >= 10 {\n\t\t\tk++\n\t\t\tamount -= 10\n\t\t}\n\t\tres[maxLen] = amount\n\t\tmaxLen--\n\t}\n\tfor k > 0 {\n\t\tres[maxLen] = k % 10\n\t\tk /= 10\n\t\tmaxLen--\n\t}\n\tif res[0] == 0 {\n\t\treturn res[1:]\n\t}\n\treturn res\n}\n```\n\n## 复杂度分析\n\n- 空间复杂度： O(n)\n\n- 时间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302330762","body":"```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n\trecord := []int{}\r\n\tfor index := 0; index < len(s); index++ {\r\n\t\tif s[index] == c {\r\n\t\t\trecord = append(record, index)\r\n\t\t}\r\n\t}\r\n\tpreIndex := 0\r\n\tlastIndex := 0\r\n\tans := make([]int, len(s))\r\n\tfor index, _ := range s {\r\n\t\tif lastIndex < len(record)-1 {\r\n\t\t\tif index > record[lastIndex] {\r\n\t\t\t\tpreIndex = lastIndex\r\n\t\t\t\tlastIndex++\r\n\t\t\t}\r\n\t\t}\r\n\t\tans[index] = min821(abs821(record[preIndex]-index), abs821(record[lastIndex]-index))\r\n\r\n\t}\r\n\r\n\treturn ans\r\n}\r\n\r\nfunc min821(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n\r\nfunc abs821(a int) int {\r\n\tif a < 0 {\r\n\t\treturn -a\r\n\t}\r\n\treturn a\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302290290","body":"## 思路\n数组模拟\n\n## 代码实现\n```golang\ntype CustomStack struct {\n    MaxSize int\n    elems []int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        MaxSize: maxSize,\n        elems: []int{},\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.elems) < this.MaxSize {\n        this.elems = append(this.elems, x)\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if len(this.elems) == 0 {\n        return -1\n    }\n    res := this.elems[len(this.elems) - 1]\n    this.elems = this.elems[:len(this.elems) - 1]\n    return res\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    minLen := k\n    if len(this.elems) < k {\n        minLen = len(this.elems)\n    }\n    for index :=0; index < minLen; index++ {\n        this.elems[index] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n## 复杂度\n- 时间复杂度   push / pop O(1)  increment O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303603641","body":"## 思路\n模拟栈，并且插入一个 `#` 号键作为标识符\n\n## 代码\n```golang\nfunc decodeString1(s string) string {\n\tans := []rune{}\n\n\ti := true\n\tfor _, elem := range s {\n\t\tif elem >= '0' && elem <= '9' && i {\n\t\t\tans = append(ans, '#', elem)\n\t\t\ti = false\n\t\t} else if elem == '[' {\n\t\t\ti = true\n\t\t\tans = append(ans, elem)\n\t\t} else if elem == ']' {\n\t\t\ti = true\n\t\t\ttmpStr := \"\"\n\t\t\tamountStr := \"\"\n\t\t\tflag := false\n\t\t\tfor len(ans) > 0 {\n\t\t\t\tpopElem := ans[len(ans)-1]\n\t\t\t\tans = ans[:len(ans)-1]\n\t\t\t\tif popElem == '#' {\n\t\t\t\t\tbreak\n\t\t\t\t} else if popElem == '[' {\n\t\t\t\t\tflag = true\n\t\t\t\t} else if flag {\n\t\t\t\t\tamountStr = string(popElem) + amountStr\n\t\t\t\t} else {\n\t\t\t\t\ttmpStr = string(popElem) + tmpStr\n\t\t\t\t}\n\t\t\t}\n\t\t\tamount := 1\n\t\t\tif amountStr != \"\" {\n\t\t\t\tamount, _ = strconv.Atoi(amountStr)\n\t\t\t}\n\t\t\tstr := \"\"\n\t\t\tfor index := 0; index < amount; index++ {\n\t\t\t\tstr += tmpStr\n\t\t\t}\n\t\t\tans = append(ans, []rune(str)...)\n\n\t\t} else {\n\t\t\tans = append(ans, elem)\n\t\t}\n\t}\n\treturn string(ans)\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304572444","body":"```golang\ntype MyQueue struct {\n\tinStack  []int\n\toutStack []int\n}\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{}\n}\n\nfunc (this *MyQueue) Push(x int) {\n\tthis.inStack = append(this.inStack, x)\n}\n\nfunc (this *MyQueue) Pop() int {\n\tif len(this.outStack) == 0 {\n\t\tthis.in2Out()\n\t}\n\tx := this.outStack[len(this.outStack)-1]\n\tthis.outStack = this.outStack[:len(this.outStack)-1]\n\treturn x\n}\n\nfunc (this *MyQueue) Peek() int {\n\tif len(this.outStack) == 0 {\n\t\tthis.in2Out()\n\t}\n\treturn this.outStack[len(this.outStack)-1]\n}\n\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\n}\n\nfunc (this *MyQueue) in2Out() {\n\tfor len(this.inStack) > 0 {\n\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\n\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823193","body":"```golang\r\nfunc maxChunksToSorted(arr []int) int {\r\n\tsize := len(arr)\r\n\r\n\ttmpArr := make([]int, size)\r\n\tcopy(tmpArr, arr)\r\n\tsort.Sort(sort.IntSlice(tmpArr))\r\n\tnum := 0\r\n\tsum1, sum2 := 0, 0\r\n\tfor index, value := range arr {\r\n\t\tsum1 += tmpArr[index]\r\n\t\tsum2 += value\r\n\t\tif sum1 == sum2 {\r\n\t\t\tnum++\r\n\t\t}\r\n\t}\r\n\treturn num\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305770525","body":"## 思路\r\n闭环需要进行取模运算， 2个指针间隔k个节点，向尾结点一起遍历， 较快节点达到最后一个元素停止。 fast.next=head, slower.next = newHead, slow.next=nil 断开环形\r\n\r\n## 代码\r\n```golang\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tfast, slow, finalList := head, head, head\r\n\tnodeLen := 0\r\n\tfor finalList != nil {\r\n\t\tfinalList = finalList.Next\r\n\t\tnodeLen++\r\n\t}\r\n\r\n\tk = k % nodeLen\r\n\r\n\tfor fast.Next != nil {\r\n\t\tfast = fast.Next\r\n\t\tif k > 0 {\r\n\t\t\tk--\r\n\t\t} else {\r\n\t\t\tslow = slow.Next\r\n\t\t}\r\n\t}\r\n\r\n\tfast.Next = head\r\n\tfinalList = slow.Next\r\n\tslow.Next = nil\r\n\r\n\treturn finalList\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307371768","body":"## code\r\n```golang\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tdummy := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\tp := dummy\r\n\tfor p.Next != nil && p.Next.Next != nil {\r\n\t\tone := p.Next\r\n\t\ttwo := p.Next.Next\r\n\t\tp.Next = one.Next\r\n\t\tone.Next = two.Next\r\n\t\ttwo.Next = one\r\n\t\tp = one.Next\r\n\t}\r\n\treturn dummy.Next\r\n}\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308879305","body":"```golang\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\treturn treeCreate(head, nil)\r\n}\r\n\r\nfunc treeCreate(head *ListNode, tail *ListNode) *TreeNode {\r\n\tif head == tail {\r\n\t\treturn nil\r\n\t}\r\n\tfast, slow := head, head\r\n\tfor fast != tail && fast.Next != tail {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\tleft := treeCreate(head, slow)\r\n\tright := treeCreate(slow.Next, tail)\r\n\r\n\treturn &TreeNode{\r\n\t\tVal:   slow.Val,\r\n\t\tLeft:  left,\r\n\t\tRight: right,\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310427436","body":"```golang \r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\tone := headA\r\n\ttwo := headB\r\n\r\n\tfor one != two {\r\n\t\tif one != nil {\r\n\t\t\tone = one.Next\r\n\t\t} else {\r\n\t\t\tone = headB\r\n\t\t}\r\n\r\n\t\tif two != nil {\r\n\t\t\ttwo = two.Next\r\n\t\t} else {\r\n\t\t\ttwo = headA\r\n\t\t}\r\n\t}\r\n\treturn one\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311807261","body":"```golang\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\tfast, slow := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t\tif fast == slow {\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tif fast == nil || fast.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\tfast = head\r\n\tfor fast != slow {\r\n\t\tfast = fast.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\treturn fast\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312493252","body":"用的golang的list标准库。。\n```golang\ntype LRUCache struct {\n    Size int\n    l *list.List\n    Data map[int]*element\n}\n\ntype element struct{\n    Value int\n    e *list.Element\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    return LRUCache{\n        Size: capacity,\n        Data: map[int]*element{},\n        l: list.New(),\n    }\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n    if element, ok := this.Data[key]; ok{\n        this.l.MoveToBack(element.e)\n        return element.Value\n    }\n    return -1;\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if this.Get(key) != -1{\n        this.l.MoveToBack(this.Data[key].e)\n        this.Data[key].Value = value\n    } else {\n        this.l.PushBack(key)\n        this.Data[key] = &element{\n            Value: value,\n            e: this.l.Back(),\n        }\n    }\n    if len(this.Data) > this.Size{\n        delete(this.Data, this.l.Remove(this.l.Front()).(int))\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312758709","body":"## 思路\r\n子问题就是：每个父节点的深度等于子节点最大深度+1\r\n\r\n## 代码\r\n```golang\r\nfunc maxDepth(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\treturn max104(1+maxDepth(root.Left), 1+maxDepth(root.Right))\r\n}\r\n\r\nfunc max104(a, b int) int {\r\n\tif a > b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n## 复杂度\r\n- 空间复杂度 O(n)\r\n- 时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313044655","body":"## 思路\r\n先判断一个节点是否相等， 然后递归调用\r\n\r\n## 代码\r\n```golang\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n\tif p == nil && q == nil {\r\n\t\treturn true\r\n\t} else if p == nil || q == nil {\r\n\t\treturn false\r\n\t}\r\n\tif p.Val != q.Val {\r\n\t\treturn false\r\n\t}\r\n\ta := isSameTree(p.Left, q.Left)\r\n\tb := isSameTree(p.Right, q.Right)\r\n\treturn a && b\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315057850","body":"## 思路\n递归实现，每往下一层，当前数字就X10， 然后将parentNum与当前节点的val相加，最后判断如果该节点时最后一个节点，那么就将该数字加到总数上\n## 代码\n```golang\nfunc sumNumbers(root *TreeNode) int {\n\tvar result int\n\tvar dfs func(node *TreeNode, parentNum int)\n\tdfs = func(node *TreeNode, parentNum int) {\n\t\tif node != nil {\n\t\t\tcurrentNum := parentNum + node.Val\n\t\t\tif node.Left == nil && node.Right == nil {\n\t\t\t\tresult += currentNum\n\t\t\t} else {\n\t\t\t\tdfs(node.Left, currentNum*10)\n\t\t\t\tdfs(node.Right, currentNum*10)\n\t\t\t}\n\t\t} else {\n\n\t\t}\n\t}\n\tdfs(root, 0)\n\treturn result\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1315618356","body":"```golang\nfunc findBottomLeftValue(root *TreeNode) int {\n\tres := root.Val\n\tmaxAmount := 0\n\tvar dfs func(node *TreeNode, amount int)\n\tdfs = func(node *TreeNode, amount int) {\n\t\tif node != nil {\n\t\t\tif node.Left == nil && maxAmount < amount+1 {\n\t\t\t\tres = node.Val\n\t\t\t\tmaxAmount = amount + 1\n\t\t\t}\n\t\t\tif node.Left != nil {\n\t\t\t\tdfs(node.Left, amount+1)\n\t\t\t}\n\t\t\tif node.Right != nil {\n\t\t\t\tdfs(node.Right, amount+1)\n\t\t\t}\n\t\t}\n\n\t}\n\tdfs(root.Left, 0)\n\tdfs(root.Right, 0)\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318842622","body":"```golang\r\ntype Codec struct {\r\n}\r\n\r\nfunc Constructor() Codec {\r\n\treturn Codec{}\r\n}\r\n\r\n// Serializes a tree to a single string.\r\nfunc (this *Codec) serialize(root *TreeNode) string {\r\n\tsp := &strings.Builder{}\r\n\tvar dfs func(node *TreeNode)\r\n\tdfs = func(node *TreeNode) {\r\n\t\tif node == nil {\r\n\t\t\tsp.WriteString(\"null,\")\r\n\t\t\treturn\r\n\t\t}\r\n\t\tsp.WriteString(strconv.Itoa(node.Val))\r\n\t\tsp.WriteString(\",\")\r\n\t\tdfs(node.Left)\r\n\t\tdfs(node.Right)\r\n\t}\r\n\tdfs(root)\r\n\treturn sp.String()\r\n}\r\n\r\n// Deserializes your encoded data to tree.\r\nfunc (this *Codec) deserialize(data string) *TreeNode {\r\n\tsp := strings.Split(data, \",\")\r\n\tvar build func() *TreeNode\r\n\tbuild = func() *TreeNode {\r\n\t\tif sp[0] == \"null\" {\r\n\t\t\tsp = sp[1:]\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\tval, _ := strconv.Atoi(sp[0])\r\n\t\tsp = sp[1:]\r\n\t\treturn &TreeNode{\r\n\t\t\tVal:   val,\r\n\t\t\tLeft:  build(),\r\n\t\t\tRight: build(),\r\n\t\t}\r\n\t}\r\n\treturn build()\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320216711","body":"```golang\nfunc verticalTraversal(root *TreeNode) [][]int {\n\trecord := make(map[*TreeNode][]int)\n\n\tvalMap := make(map[int][]int)\n\tmin, max := 0, 0\n\n\tvar dfs func(node *TreeNode, point []int)\n\tdfs = func(node *TreeNode, point []int) {\n\t\tif node == nil {\n\t\t\treturn\n\t\t}\n\t\trecord[node] = point\n\t\tif _, ok := valMap[point[1]]; ok {\n\t\t\tvalMap[point[1]] = append(valMap[point[1]], node.Val)\n\t\t} else {\n\t\t\tvalMap[point[1]] = []int{node.Val}\n\t\t}\n\n\t\tif point[1] < min {\n\t\t\tmin = point[1]\n\t\t}\n\t\tif point[1] > max {\n\t\t\tmax = point[1]\n\t\t}\n\t\tdfs(node.Left, []int{point[0] + 1, point[1] - 1})\n\t\tdfs(node.Right, []int{point[0] + 1, point[1] + 1})\n\t}\n\tdfs(root, []int{0, 0})\n\tres := [][]int{}\n\n\tfor index := min; index <= max; index++ {\n\t\tvals := valMap[index]\n\t\tsort.Ints(vals)\n\t\tres = append(res, vals)\n\t}\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1321157862","body":"```golang\r\nfunc twoSum(nums []int, target int) []int {\r\n    numMap := make(map[int]int)\r\n    for index, value := range nums{\r\n        if _, ok := numMap[target - value];ok{\r\n            return []int{numMap[target - value], index}\r\n        }\r\n        numMap[value] = index\r\n    }\r\n    return []int{0}\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321162889","body":"```golang \r\ntype tt struct {\r\n\tnum    int\r\n\tamount int\r\n}\r\n\r\nfunc topKFrequent(nums []int, k int) []int {\r\n\trecord := make(map[int]int)\r\n\tarr := []*tt{}\r\n\tseq := 0\r\n\tfor _, num := range nums {\r\n\t\tif index, ok := record[num]; ok {\r\n\t\t\tarr[index].amount += 1\r\n\t\t} else {\r\n\t\t\trecord[num] = seq\r\n\t\t\tseq++\r\n\t\t\tarr = append(arr, &tt{\r\n\t\t\t\tnum:    num,\r\n\t\t\t\tamount: 1,\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\tsort.Slice(arr, func(i, j int) bool {\r\n\t\ta, b := arr[i], arr[j]\r\n\t\treturn a.amount > b.amount\r\n\t})\r\n\tres := make([]int, k)\r\n\tfor index := 0; index < k; index++ {\r\n\t\tres[index] = arr[index].num\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321990309","body":"```golang\nfunc numberOfBoomerangs(points [][]int) int {\n\tres := 0\n\tfor i, firstElem := range points {\n\t\thashMap := make(map[int]int)\n\t\tfor j, secondElem := range points {\n\t\t\tif i == j {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tx, y := secondElem[0]-firstElem[0], secondElem[1]-firstElem[1]\n\t\t\tdis := x*x + y*y\n\t\t\thashMap[dis]++\n\t\t}\n\t\tfor _, val := range hashMap {\n\t\t\tres += val * (val - 1)\n\t\t}\n\t}\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323863894","body":"```golang\nfunc lengthOfLongestSubstring(s string) int {\n\tleft, right := 0, 0\n\tans := 0\n\thashMap := make(map[byte]int)\n\tfor right < len(s) {\n\t\ta := s[right]\n\t\tif val, ok := hashMap[a]; ok {\n\t\t\tif left < val {\n\t\t\t\tleft = val\n\t\t\t}\n\t\t}\n\t\tif ans < right-left+1 {\n\t\t\tans = right - left + 1\n\t\t}\n\t\thashMap[a] = right + 1\n\t\tright++\n\t}\n\treturn ans\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1326565240","body":"```golang\r\nfunc findSubstring(s string, words []string) []int {\r\n\tstrLen := len(s)\r\n\twordCount := len(words)\r\n\twordLen := len(words[0])\r\n\r\n\twordDict := map[string]int{}\r\n\tfor _, word := range words {\r\n\t\twordDict[word] += 1\r\n\t}\r\n\r\n\tvalidLen := wordCount * wordLen\r\n\tres := []int{}\r\n\tfor index := 0; index < strLen-validLen+1; index++ {\r\n\t\tcurrentEndIndex := index + validLen\r\n\t\tcurStr := s[index:currentEndIndex]\r\n\t\tmatchDict := map[string]int{}\r\n\r\n\t\tj := 0\r\n\t\tfor ; j < currentEndIndex-index; j += wordLen {\r\n\t\t\tword := curStr[j : j+wordLen]\r\n\t\t\tif _, ok := wordDict[word]; !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tmatchDict[word] += 1\r\n\t\t\tif matchDict[word] > wordDict[word] {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif j == currentEndIndex-index {\r\n\t\t\tres = append(res, index)\r\n\t\t}\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326618573","body":"```golang\r\nfunc subarraysDivByK(nums []int, k int) int {\r\n\tm := map[int]int{\r\n\t\t0: -1,\r\n\t}\r\n\ttotal := 0\r\n\tfor _, num := range nums {\r\n\t\ttotal += num\r\n\t}\r\n\tmod := total % k\r\n\r\n\tpreTotal := 0\r\n\tans := len(nums)\r\n\tfor index, num := range nums {\r\n\t\tpreTotal += num\r\n\t\tcurMod := preTotal % k\r\n\t\ttarget := (curMod - mod + k) % k\r\n\t\tif val, ok := m[target]; ok {\r\n\t\t\tif index-val < ans {\r\n\t\t\t\tans = index - val\r\n\t\t\t}\r\n\t\t}\r\n\t\tm[curMod] = index\r\n\t}\r\n\tif ans == len(nums) {\r\n\t\treturn -1\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327628573","body":"快慢指针\n\n```golang\nfunc middleNode(head *ListNode) *ListNode {\n\tslower, faster := head, head\n\tfor faster != nil && faster.Next != nil {\n\t\tslower = slower.Next\n\t\tfaster = faster.Next.Next\n\t}\n\treturn slower\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328069651","body":"```golang\nfunc removeDuplicates(nums []int) int {\n    index, fast := 0, 1\n    for ;fast<len(nums);fast++{\n        if nums[index] != nums[fast]{\n            index++\n            nums[index] = nums[fast]\n        }\n    }\n    return index + 1\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328269810","body":"二分查找法\n\n```golang\nfunc searchInsert(nums []int, target int) int {\n\tleft, right := 0, len(nums)-1\n\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else if nums[mid] > target {\n\t\t\tright = mid - 1\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn left\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329321445","body":"```golang\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tif k > len(nums) {\n\t\treturn nil\n\t}\n\n\tslipArr := []int{}\n\tpush := func(i int) {\n\t\tfor len(slipArr) > 0 && nums[i] >= nums[slipArr[len(slipArr)-1]] {\n\t\t\tslipArr = slipArr[:len(slipArr)-1]\n\t\t}\n\t\tslipArr = append(slipArr, i)\n\t}\n\tfor index := 0; index < k; index++ {\n\t\tpush(index)\n\t}\n\n\tres := []int{nums[slipArr[0]]}\n\n\tfor index := k; index < len(nums); index++ {\n\t\tpush(index)\n\t\tfor slipArr[0] <= index-k {\n\t\t\tslipArr = slipArr[1:]\n\t\t}\n\t\tres = append(res, nums[slipArr[0]])\n\t}\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330858688","body":"```golang\nfunc findJudge(n int, trust [][]int) int {\n\trecord := make([]int, n+1)\n\tblack := make([]int, n+1)\n\tfor _, item := range trust {\n\t\tblack[item[0]]++\n\t\trecord[item[1]]++\n\t}\n\tfor index := 1; index <= n; index++ {\n\t\tif record[index] == n-1 && black[index] == 0 {\n\t\t\treturn index\n\t\t}\n\t}\n\treturn -1\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332377548","body":"```golang\nfunc possibleBipartition(n int, dislikes [][]int) bool {\n\tok := true\n\tcolor := make([]bool, n+1)\n\tvisited := make([]bool, n+1)\n\n\tbuildGraph := func(n int, disLikes [][]int) [][]int {\n\t\tgraph := make([][]int, n+1)\n\t\tfor index := 1; index <= n; index++ {\n\t\t\tgraph[index] = []int{}\n\t\t}\n\t\tfor _, edge := range disLikes {\n\t\t\tv := edge[1]\n\t\t\tw := edge[0]\n\t\t\tgraph[v] = append(graph[v], w)\n\t\t\tgraph[w] = append(graph[w], v)\n\t\t}\n\t\treturn graph\n\t}\n\n\tvar traverse func(graph [][]int, v int)\n\ttraverse = func(graph [][]int, v int) {\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tvisited[v] = true\n\t\tfor _, w := range graph[v] {\n\t\t\tif visited[w] {\n\t\t\t\tif color[w] == color[v] {\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor[w] = !color[v]\n\t\t\t\ttraverse(graph, w)\n\t\t\t}\n\t\t}\n\t}\n\n\tgraph := buildGraph(n, dislikes)\n\tfor v := 1; v <= n; v++ {\n\t\tif !visited[v] {\n\t\t\ttraverse(graph, v)\n\t\t}\n\t}\n\treturn ok\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335401777","body":"```golang \nfunc judgeCircle(moves string) bool {\n\tpoint := []int{0, 0}\n\tfor _, move := range moves {\n\t\tif move == 'U' {\n\t\t\tpoint[0] += 1\n\t\t} else if move == 'D' {\n\t\t\tpoint[0] -= 1\n\t\t} else if move == 'L' {\n\t\t\tpoint[1] -= 1\n\t\t} else if move == 'R' {\n\t\t\tpoint[1] += 1\n\t\t}\n\t}\n\treturn point[0] == 0 && point[1] == 0\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298393989","body":"## 思路\n- 将K和数组每一位相加，取余得出新数组每一位的数值，将相加的和作为进位。需要注意边界。\n## 代码\n```java\npublic class Solution {\n    public static List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList();\n        for(int i=num.length-1;i>=0;i--){\n            int sum = k + num[i];\n            result.add(sum%10);\n            k = sum/10;\n        }\n        if (k > 9) {\n            while(k > 9) {\n                int data = k%10;//取余\n                k = k/10;\n                result.add(data);\n            }\n            result.add(k);\n        }else if (k>0 && k<=9){\n            result.add(k);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1305452446","body":"## 思路\r\n- 栈的最大容量是确定的，可以考虑使用数组来实现，不用考虑扩容\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    private int[] data;\r\n    private int index;\r\n    public CustomStack(int maxSize) {\r\n        data = new int[maxSize];\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index == data.length) {\r\n            return;\r\n        }\r\n        data[index] = x;\r\n        index++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(index == 0) {\r\n            return -1;\r\n        }else{\r\n            int temp = data[index-1];\r\n            index--;\r\n            return temp;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i=0;i<k;i++) {\r\n            if(i < index) {\r\n                data[i] = data[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：push:O(1), pop:O(1),increment:O(N)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1305460621","body":"## 思路\r\n- 使用两个栈来回倒腾元素\r\n## 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new Stack();\r\n        stack2 = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!stack1.isEmpty()){\r\n            stack2.push(stack1.pop());\r\n        }\r\n        stack1.push(x);\r\n        while(!stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        } \r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        return stack1.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return stack1.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：push:O(1), pop:O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305422647","body":"## 思路\n- 先把链表成环，移动K次后断开环形链表。\n## 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return head;\n        }\n        //先成环\n        ListNode cur = head;\n        ListNode prev = new ListNode(-1);\n        prev.next = head;\n        int len = 1;\n        while(cur.next != null){\n            cur = cur.next;\n            prev = prev.next;\n            len++;\n        }\n        cur.next = head;\n        int num = len - k%len + 1;\n        while(num>0){\n            prev = prev.next;\n            cur = cur.next;\n            num--;\n        }\n        prev.next = null;\n        return cur;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306500593","body":"## 思路\n- 借助虚拟头节点，先反转前两个，然后循环此操作\n## 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //cur -> before -> after \n        ListNode dummyHead = new ListNode(-1);\n        dummyHead.next = head;\n        ListNode cur = dummyHead;\n        while(cur.next != null && cur.next.next != null) {\n            ListNode before = cur.next;\n            ListNode after  = cur.next.next;\n            cur.next = after;\n            before.next = after.next;\n            after.next = before;\n            cur = before;\n        }\n        return dummyHead.next;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310035558","body":"## 思路\n- 采用双指针，都走完A+B+C，相遇即是交点\n## 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b) {\n            if(a != null) {\n                a = a.next;\n            }else{\n                a= headB;\n            }\n            if(b != null) {\n                b = b.next;\n            }else {\n                b = headA;\n            }\n        }\n        return a;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311360914","body":"#### 思路\n- 快慢指针，快指针走两步，慢指针走一步\n#### 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        //快慢指针，快指针走两步，慢指针走一步\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow) {\n                //第一次相遇,继续判断\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return fast;\n            }\n        }\n        return null;  \n    }\n}\n```\n#### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320036116","body":"## 代码\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n        List<List<Integer>> ans = new ArrayList<>();\n        Deque<Node> deque = new ArrayDeque<>();\n        deque.addLast(new Node(0, root));\n        while (!deque.isEmpty()) {\n            int size = deque.size();\n            Map<Integer, List<Integer>> m = new HashMap<>();\n            while (size-- > 0) {\n                Node cur = deque.pollFirst();\n                m.computeIfAbsent(cur.idx, k -> new ArrayList<>()).add(cur.node.val);\n                if (cur.node.left != null) deque.addLast(new Node(cur.idx - 1, cur.node.left));\n                if (cur.node.right != null) deque.addLast(new Node(cur.idx + 1, cur.node.right));\n            }\n            for (Integer key : m.keySet()) {\n                Collections.sort(m.get(key));\n                map.computeIfAbsent(key, k -> new ArrayList<>()).addAll(m.get(key));\n            }\n        }\n        for (Integer key : map.keySet()) ans.add(map.get(key));\n        return ans;\n    }\n\n    class Node {\n        int idx;\n        TreeNode node;\n        public Node() {\n        }\n        public Node(int _idx, TreeNode _root) {\n            this.node = _root;\n            this.idx = _idx;\n        }\n\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298396077","body":"### 思路\n\n将整个加数 K加入数组表示的数的最低位，余数保留，高位数进位再相加\n\n### 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间：O（n）\n\n空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300627485","body":"### 思路\n\n~~~bash\n前后遍历，取距离最小的\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302133635","body":"### 思路\n\n~~~bash\n用一个数组来模拟栈，push操作的话，没满就把栈顶后移，pop操作的话，非空就迁移\n~~~\n\n### 代码\n\n~~~java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度： pop，push  O(1)   inc O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303215840","body":"### 思路\n\n~~~bash\n利用栈的思想，数字、字母和中括号分开，数字、字母和左括号直接进，遇到右括号的时候出栈，然后一直到遇到左括号停止，反转一下就是我们的字母队列，再去栈里面找数字就是重复的次数，然后根据新的字符串再进栈，如此循环往复即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304502487","body":"### 思路\n\n~~~bash\n将一个栈当作输入栈，用于压入push 传入的数据；另一个栈当作输出栈，用于pop 和 peek 操作。\n~~~\n\n### 代码\n\n~~~java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304794291","body":"### 思路\n\n~~~bash\n对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。\n有点儿没看懂，下去再看看。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305544918","body":"### 思路\n\n~~~bash\n把它想象成一个环，然后移动的次数对长度取模，为0那就是不变\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307079314","body":"### 思路\n\n~~~bash\n递归，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308440160","body":"### 思路\n\n~~~bash\n首先找到当前的根节点，构建根节点之后，对左右链表分别递归即可。用一个节点作为pre,pre在low前面，当low指向根节点之后跳出循环，这样可以把pre.next 设置为null\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return dfs(head);\n    }\n\n    public TreeNode dfs(ListNode head) {\n        if(head == null)\n            return null;\n        if(head.next == null)\n            return new TreeNode(head.val);\n        ListNode pre = new ListNode();\n        pre.next = head;\n        ListNode low = head, fast = head;\n        while(fast != null && fast.next != null) {\n            fast = fast.next.next;\n            low = low.next;\n            pre = pre.next;\n        }\n        pre.next = null;\n        TreeNode root = new TreeNode(low.val);\n        root.right = dfs(low.next);\n        root.left = dfs(head);\n        return root;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310435489","body":"### 思路\n\n~~~bash\n双指针，只需要考虑相交和不相交两种情况即可\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311763769","body":"### 思路\n\n~~~bash\n快慢指针，使用两个指针，一个移动1次，一个移动2次，如果存在环，那么终究会相遇\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312490331","body":"### 思路\n\n~~~bash\n哈希+双向链表\nLRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n没看太懂，后面再看看\n~~~\n\n### 代码\n\n~~~java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312746878","body":"### 思路\n\n~~~bash\n每棵树的最大深度即为其左右子树的最大深度加一\n~~~\n\n### 代码\n\n~~~java\nint maxDepth(struct TreeNode* root){\n    if(root==NULL) return 0;\n    else\n    return fmax(maxDepth(root->left)+1,maxDepth(root->right)+1);\n}\n~~~\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313262502","body":"### 思路\n\n~~~bash\n递归，拆分\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315263476","body":"### 思路\n\n~~~bash\n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316964613","body":"### 思路\n\n~~~bash\n使用广度优先搜索遍历每一层的节点。在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int ret = 0;\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode p = queue.poll();\n            if (p.right != null) {\n                queue.offer(p.right);\n            }\n            if (p.left != null) {\n                queue.offer(p.left);\n            }\n            ret = p.val;\n        }\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318598675","body":"### 思路\n\n~~~bash\n没看太懂，先提交了，后面再看看。\n二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。\n~~~\n\n### 代码\n\n~~~java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320865636","body":"### 思路\r\n\r\n~~~bash\r\n我们可以从根节点开始，对整棵树进行一次遍历，然后再根据（列，行，值）进行排序。\r\n~~~\r\n\r\n### 代码\r\n\r\n~~~java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<int[]> nodes = new ArrayList<int[]>();\r\n        dfs(root, 0, 0, nodes);\r\n        Collections.sort(nodes, new Comparator<int[]>() {\r\n            public int compare(int[] tuple1, int[] tuple2) {\r\n                if (tuple1[0] != tuple2[0]) {\r\n                    return tuple1[0] - tuple2[0];\r\n                } else if (tuple1[1] != tuple2[1]) {\r\n                    return tuple1[1] - tuple2[1];\r\n                } else {\r\n                    return tuple1[2] - tuple2[2];\r\n                }\r\n            }\r\n        });\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        int size = 0;\r\n        int lastcol = Integer.MIN_VALUE;\r\n        for (int[] tuple : nodes) {\r\n            int col = tuple[0], row = tuple[1], value = tuple[2];\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.add(new ArrayList<Integer>());\r\n                size++;\r\n            }\r\n            ans.get(size - 1).add(value);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        nodes.add(new int[]{col, row, node.val});\r\n        dfs(node.left, row + 1, col - 1, nodes);\r\n        dfs(node.right, row + 1, col + 1, nodes);\r\n    }\r\n}\r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320865976","body":"### 思路\n\n~~~bash\n哈希\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321143980","body":"### 思路\n\n~~~bash\n首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321580075","body":"### 思路\n\n~~~bash\n枚举 + 哈希表，暴力解法\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n            for (int[] q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int m = entry.getValue();\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1324980123","body":"### 思路\r\n\r\n~~~bash\r\n滑动窗口\r\n~~~\r\n\r\n### 代码\r\n\r\n~~~bash\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        if (s.length()==0) return 0;\r\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\r\n        int max = 0;\r\n        int left = 0;\r\n        for(int i = 0; i < s.length(); i ++){\r\n            if(map.containsKey(s.charAt(i))){\r\n                left = Math.max(left,map.get(s.charAt(i)) + 1);\r\n            }\r\n            map.put(s.charAt(i),i);\r\n            max = Math.max(max,i-left+1);\r\n        }\r\n        return max;\r\n        \r\n    }\r\n}\r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324988310","body":"### 思路\n\n~~~bash \n滑动窗口，没看太懂，先提交了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\n\n时间复杂度: 本质上我们的算法是将 s 划分为若干了段，这些段的长度为 m * km∗k，对于每一段我们最多需要检查 n - m * kn−m∗k 次，因此时间复杂度为 O(n * m * k)O(n∗m∗k)。\n\n空间复杂度: temp 在下一次循环会覆盖上一次的 temp，因此 temp 的空间在任意时刻都不大于 O(m)O(m), 因此空间复杂度为 O(m)O(m)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326555419","body":"### 思路\n\n~~~bash\n同余定理+前缀和的巧妙结合\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327629139","body":"### 思路\n\n~~~bash\n双指针\n~~~\n\n### 代码\n\n~~~java\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new IllegalArgumentException(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        ListNode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new ListNode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        ListNode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"NULL\");\n        return s.toString();\n    }\n}\n\npublic class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        ListNode head = new ListNode(arr);\n        Solution solution = new Solution();\n        ListNode res = solution.middleNode(head);\n        System.out.println(res);\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328054596","body":"### 思路\n\n~~~bash\n双指针，数组有序，那么相同的一定相邻，要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n~~~\n\n### 代码\n\n~~~java\n public int removeDuplicates(int[] nums) {\n    if(nums == null || nums.length == 0) return 0;\n    int p = 0;\n    int q = 1;\n    while(q < nums.length){\n        if(nums[p] != nums[q]){\n            nums[p + 1] = nums[q];\n            p++;\n        }\n        q++;\n    }\n    return p + 1;\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328249704","body":"### 思路\n\n~~~bash\n二分法\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(logn)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328992145","body":"### 思路\n\n~~~bash\n遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums == null || nums.length < 2) return nums;\n        // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序\n        LinkedList<Integer> queue = new LinkedList();\n        // 结果数组\n        int[] result = new int[nums.length-k+1];\n        // 遍历nums数组\n        for(int i = 0;i < nums.length;i++){\n            // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求\n            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){\n                queue.pollLast();\n            }\n            // 添加当前值对应的数组下标\n            queue.addLast(i);\n            // 判断当前队列中队首的值是否有效\n            if(queue.peek() <= i-k){\n                queue.poll();   \n            } \n            // 当窗口长度为k时 保存当前窗口中最大值\n            if(i+1 >= k){\n                result[i+1-k] = nums[queue.peek()];\n            }\n        }\n        return result;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330642336","body":"### 思路\n\n~~~bash\n图，计算各节点的入度和出度\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegrees = new int[n + 1];\n        int[] outDegrees = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332059962","body":"### 思路\n\n~~~bash\n没看太懂，先补上，回去再看下\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\n        color[curnode] = nowcolor;\n        for (int nextnode : g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1335157047","body":"### 思路\r\n\r\n~~~bash\r\n没看太懂，先补卡了\r\n~~~\r\n\r\n### 代码\r\n\r\n~~~java\r\nclass Solution {\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();\r\n        for (int i = 0; i < n + m; ++i) {\r\n            groupItem.add(new ArrayList<Integer>());\r\n        }\r\n\r\n        // 组间和组内依赖图\r\n        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();\r\n        for (int i = 0; i < n + m; ++i) {\r\n            groupGraph.add(new ArrayList<Integer>());\r\n        }\r\n        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();\r\n        for (int i = 0; i < n; ++i) {\r\n            itemGraph.add(new ArrayList<Integer>());\r\n        }\r\n\r\n        // 组间和组内入度数组\r\n        int[] groupDegree = new int[n + m];\r\n        int[] itemDegree = new int[n];\r\n        \r\n        List<Integer> id = new ArrayList<Integer>();\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.add(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        // 给未分配的 item 分配一个 groupId\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem.get(group[i]).add(i);\r\n        }\r\n        // 依赖关系建图\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (int item : beforeItems.get(i)) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph.get(item).add(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph.get(beforeGroupId).add(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 组间拓扑关系排序\r\n        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        int[] ans = new int[n];\r\n        int index = 0;\r\n        // 组内拓扑关系排序\r\n        for (int curGroupId : groupTopSort) {\r\n            int size = groupItem.get(curGroupId).size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));\r\n            if (res.size() == 0) {\r\n                return new int[0];\r\n            }\r\n            for (int item : res) {\r\n                ans[index++] = item;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {\r\n        Queue<Integer> queue = new LinkedList<Integer>();\r\n        for (int item : items) {\r\n            if (deg[item] == 0) {\r\n                queue.offer(item);\r\n            }\r\n        }\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        while (!queue.isEmpty()) {\r\n            int u = queue.poll(); \r\n            res.add(u);\r\n            for (int v : graph.get(u)) {\r\n                if (--deg[v] == 0) {\r\n                    queue.offer(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : new ArrayList<Integer>();\r\n    }\r\n}\r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335153489","body":"### 思路\n\n~~~bash\n我们只需按指令模拟机器人移动的坐标即可。起始时机器人的坐标为 (0,0)(0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 (0,0)(0,0) \n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298406485","body":"### 思路\r\n\r\nk和x不知道哪个位数多，先用map把两个数组存起来，然后对应位置相加，>=10就进位\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        map<int,int> nummap;\r\n        vector<int> revec;\r\n        int n=num.size(),flag=0;\r\n        reverse(num.begin(),num.end());\r\n        for(int i=0;i<n;i++){\r\n            nummap[i]=num[i];\r\n        }\r\n        int i=0;\r\n        while(k!=0){\r\n            nummap[i]+=k%10;\r\n            k=k/10;\r\n            i++;\r\n        }\r\n        for(auto it=nummap.begin();it!=nummap.end();it++){\r\n            if(it->second>=10&&it->first<nummap.size()-1){\r\n                it->second-=10;\r\n                it++;\r\n                it->second+=1;\r\n                it--;\r\n            }\r\n            if(it->second>=10&&it->first==nummap.size()-1){\r\n                it->second-=10;\r\n                flag++;\r\n            }\r\n            revec.push_back(it->second);\r\n        }\r\n        if(flag) revec.push_back(1);\r\n        reverse(revec.begin(),revec.end());\r\n        return revec;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299622674","body":"### 思路\r\n\r\n每个位置的字符，向前向后找离它最近的给定字符，一找到就跳出循环\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        vector<int> re;\r\n        for(int i=0;i<n;i++){\r\n            int left=i,right=i;\r\n            if(s[i]==c){\r\n                re.push_back(0);\r\n                continue;\r\n            }\r\n            left--;\r\n            right++;\r\n            while(true){\r\n                if(left<0&&right>n-1) break;\r\n                if(left>=0){\r\n                    if(s[left]==c){\r\n                        re.push_back(i-left);\r\n                        break;\r\n                    }\r\n                    left--;\r\n                } \r\n                if(right<=n-1){\r\n                    if(s[right]==c){\r\n                        re.push_back(right-i);\r\n                        break;\r\n                    }\r\n                    right++;\r\n                }\r\n            }\r\n        }\r\n        return re;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O($N^2$)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301961812","body":"### 思路\n\n用数组作为增量栈的数据结构，加一个cnt的变量，记录栈内当前的大小\n\n### 代码\n\n```C++\nclass CustomStack {\npublic:\n    vector<int> myvec;\n    int cnt=0;\n    CustomStack(int maxSize) {\n        for(int i=0;i<maxSize;i++) myvec.push_back(0);\n    }\n    \n    void push(int x) {\n        if(cnt<myvec.size()){\n            cnt++;\n            myvec[cnt-1]=x;\n        }\n    }\n    \n    int pop() {\n        if(cnt==0) return -1;\n        else{\n            int temp=myvec[cnt-1];\n            cnt--;\n            return temp;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(cnt<k) for(int i=0;i<cnt;i++) myvec[i]+=val;\n        else for(int i=0;i<k;i++) myvec[i]+=val;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：增量操作O(N)，push，pop操作O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303651417","body":"### 思路\n\n利用两个栈，一个存当前字符，一个存当前数量，遍历字符串，遇到字母，加入当前字符，遇到数字字符，当前数字*10加上当前数字字符，遇到‘[’，将当前字母和数字入栈，归0，遇到’]‘，将栈顶字母弹出，栈顶字母+栈顶数量*当前字符串=累计字符串；然后继续。\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n=s.size();\n        stack<string> stackstr;\n        stack<int> stacknum;\n        string curstr=\"\";\n        int curnum=0;\n        for(int i=0;i<n;i++){\n            if(s[i]>='0'&&s[i]<='9') curnum=curnum*10+(s[i]-'0');\n            if(s[i]>='a'&&s[i]<='z') curstr+=s[i];\n            if(s[i]=='['){\n                stackstr.push(curstr);\n                stacknum.push(curnum);\n                curstr=\"\";\n                curnum=0;\n            }\n            if(s[i]==']'){\n                string temp=curstr;\n                for(int i=0;i<stacknum.top()-1;i++) curstr+=temp;\n                curstr=stackstr.top()+curstr;\n                stackstr.pop();\n                stacknum.pop();\n            }\n        }\n        return curstr;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304427396","body":"### 思路\r\n\r\n队列：先进先出，栈：先进后出；两个栈模拟队列，要弹出队头的时候把一个栈里的腾空挪到另一栈，然后几句push的时候向第一个栈push；取队列头的时候检查第二个栈是否为空。\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> mainstack,tempstack;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        mainstack.push(x);\r\n    }\r\n    \r\n    int pop(){\r\n        int temp;\r\n        if(!tempstack.empty()){\r\n            temp=tempstack.top();\r\n            tempstack.pop();\r\n        }\r\n        else{\r\n            while(!mainstack.empty()){\r\n                temp=mainstack.top();\r\n                mainstack.pop();\r\n                tempstack.push(temp);\r\n            }\r\n            temp=tempstack.top();\r\n            tempstack.pop(); \r\n        }  \r\n        return temp;\r\n    }\r\n    \r\n    int peek() {\r\n        if(!tempstack.empty()) return tempstack.top();\r\n        else{\r\n            while(!mainstack.empty()){\r\n                int temp=mainstack.top();\r\n                mainstack.pop();\r\n                tempstack.push(temp);\r\n            }   \r\n            return tempstack.top();\r\n        }\r\n    }\r\n    \r\n    bool empty() {\r\n        if(mainstack.empty()&&tempstack.empty()) return true;\r\n        return false;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push O(1)，pop O(N) 其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305798715","body":"### 思路\r\n\r\n两个指针，一个比另一个快k，然后一起移动两个指针，快的指针移到末尾，慢的指针的next就是新链表的头节点，然后把慢指针的next设成原来的头节点，再把慢指针的新next设为nullptr\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode* newhead=head,*forward=head,*temp=head;\r\n        int count=1;\r\n        if(!head) return nullptr;\r\n        while(temp->next){\r\n            temp=temp->next;\r\n            count++;\r\n        }\r\n        k=k%count;\r\n        for(int i=0;i<k;i++){\r\n            forward=forward->next;\r\n        }\r\n        while(forward->next){\r\n            newhead=newhead->next;\r\n            forward=forward->next;\r\n        }\r\n        forward->next=head;\r\n        head=newhead->next;\r\n        newhead->next=nullptr;\r\n        \r\n        return head;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311916009","body":"### 思路\r\n\r\n环形链表，快慢指针，一定会套圈，相遇点和环入口的距离与头节点和环入口的距离相等\r\n\r\n### 代码\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode* slow=head,*fast=head;\r\n        while(fast&&fast->next){\r\n            slow=slow->next;\r\n            fast=fast->next->next;\r\n            if(fast==slow){\r\n                break;\r\n            }\r\n        }\r\n        if(fast&&fast->next){\r\n            slow=head;\r\n            while(fast!=slow){\r\n                slow=slow->next;\r\n                fast=fast->next;\r\n            }\r\n            return slow;\r\n        }\r\n        \r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312502531","body":"### 思路\r\n双向链表+map 调用函数则会使用过，放表头，修改，修改key在链表中的指向\r\n### 代码\r\n```C++\r\nclass LRUCache {\r\npublic:\r\n    unordered_map<int, list<pair<int, int>>::iterator> refMap; \r\n    list<pair<int, int>> cache;\r\n    int capacity;\r\n    LRUCache(int capacity) {\r\n        this->capacity = capacity;\r\n        cache.clear();\r\n    }\r\n    \r\n    bool doesKeyExist(int key) {\r\n        return refMap.count(key) > 0;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!doesKeyExist(key)) return -1;\r\n        int oldValue = (*refMap[key]).second;\r\n        //remove the current key reference from the map\r\n        put(key, oldValue);\r\n        return oldValue;\r\n    }\r\n    \r\n    void removeExistingKeyFromCache(int key) {\r\n        cache.erase(refMap[key]);\r\n        refMap.erase(key);\r\n    }\r\n        \r\n    \r\n    void put(int key, int value) {\r\n        //check if this key exists\r\n        if (doesKeyExist(key)) {\r\n            removeExistingKeyFromCache(key);\r\n        }\r\n        cache.push_front({key, value});\r\n        refMap[key] = cache.begin();\r\n        //if capacity is full, then remove the key from back\r\n        if (capacity < (int)cache.size()) {\r\n            int lruKey = cache.back().first;\r\n            refMap.erase(lruKey);\r\n            cache.pop_back();\r\n        }\r\n        return ;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312750167","body":"### 思路\n\n递归+回溯+前序遍历\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int mymax=INT_MIN,cnt=0;\n    int maxDepth(TreeNode* root) {\n        traversal(root);\n        \n        return mymax;\n    }\n    void traversal(TreeNode* cur){\n        if(!cur){\n            if(cnt>mymax) mymax=cnt;\n            return;\n        };\n        cnt++;\n        traversal(cur->left);\n        traversal(cur->right);\n        cnt--;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313600163","body":"### 思路\n\n递归，判断左右子树是否都相同。相同：分类讨论\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p&&!q) return true;\n        if(!p&&q||!q&&p) return false;\n        if(p->val!=q->val) return false;\n        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315245707","body":"### 思路\n\n前序遍历，回溯，遇到节点，原值*10+节点值\n\n### 代码\n\n\n```C++\n\nclass Solution {\npublic:\n    int curnum=0,sum=0;\n    int sumNumbers(TreeNode* root) {\n        traversal(root);\n        \n        return sum;\n    }\n    void traversal(TreeNode* cur){\n        curnum=curnum*10+cur->val;\n        if(cur->left) traversal(cur->left);\n        if(cur->right) traversal(cur->right);\n        if(!cur->left&&!cur->right){\n            sum+=curnum;\n        }\n        curnum=(curnum-cur->val)/10;\n        return;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317141012","body":"### 思路\n\n最左叶子节点，层序遍历，用循环，用两个队列倒来倒去\n\n### 代码\n\n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> curq,lastq;\n        if(!root) return 0;\n        curq.push(root);\n        while(!curq.empty()){\n            TreeNode* left=curq.front();\n            while(!curq.empty()){\n                TreeNode* temp=curq.front();\n                if(temp->left) lastq.push(temp->left);\n                if(temp->right) lastq.push(temp->right);\n                curq.pop();\n            }\n            if(lastq.empty()) return left->val;\n            while(!lastq.empty()){\n                TreeNode* temp2=lastq.front();\n                curq.push(temp2);\n                lastq.pop();\n            }\n        }\n        return 0;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320158040","body":"### 思路\n\n前序遍历，记录坐标\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    map<vector<int>,vector<int>> mymap;\n    map<int,vector<int>> newmap;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> re;\n        if(root) mymap[{0,0}].push_back(root->val);\n        traversal(root,0,0);\n    \n        for(auto it=mymap.begin();it!=mymap.end();it++){\n            vector<int> temp=it->second;\n            sort(temp.begin(),temp.end());\n            for(int i=0;i<temp.size();i++){\n                newmap[it->first[1]].push_back(temp[i]);\n            }\n        }\n        for(auto it=newmap.begin();it!=newmap.end();it++){\n            vector<int> newtemp;\n            for(int i=0;i<it->second.size();i++){\n                newtemp.push_back(it->second[i]);\n            }\n            re.push_back(newtemp);\n        }\n        return re;\n    }\n    void traversal(TreeNode* curnode,int currow,int curcol){\n        if(curnode->left){\n            mymap[{currow+1,curcol-1}].push_back(curnode->left->val);\n            traversal(curnode->left,currow+1,curcol-1);\n        }\n        if(curnode->right){\n            mymap[{currow+1,curcol+1}].push_back(curnode->right->val);\n            traversal(curnode->right,currow+1,curcol+1);\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：ON)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321162624","body":"### 思路\n\n用map\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        map<int,int> mymap;\n        int n=nums.size(),maxtemp=0,maxnum;\n        vector<int> results;\n        for(int i=0;i<n;i++){\n            if(mymap.find(nums[i])!=mymap.end()) mymap[nums[i]]++;\n            else mymap[nums[i]]=1;\n        }\n        while(k){\n            maxtemp=0;\n            for(auto it=mymap.begin();it!=mymap.end();it++){\n                if(it->second>maxtemp){\n                    maxtemp=it->second;\n                    maxnum=it->first;\n                }\n            }\n            results.push_back(maxnum);\n            mymap[maxnum]=0;\n            k--;\n        }\n        return results;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322237192","body":"### 思路\n\n三个点，循环两次，遍历每个点，再在循环内遍历和它不同的点，用map记录所有和它距离相同的点，然后用排列数求配对数\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int n=points.size();\n        int d,cnt=0;\n        for(int i=0;i<n;i++){\n            map<int,int> mymap;\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    d=pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2);\n                    mymap[d]++;\n                }\n            }\n            for(auto &p:mymap){\n                int temp=p.second;\n                if(temp) cnt+=temp*(temp-1);\n            }\n        }\n        return cnt;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323867612","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        map<int,int> mymap;\n        int n=s.size(),left=0,right=0,mymax=INT_MIN;\n        while(right<n){\n            auto it=mymap.find(s[right]);\n            if(it==mymap.end()){\n                mymap[s[right]]=right;\n                right++;\n            }\n            else{\n                mymap[s[right]]=right;\n                if(mymax<right-left) mymax=right-left;\n                left=it->second+1;\n                right++;\n            }\n        }\n        return mymax;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326555643","body":"### 思路\n\n同余 前缀和\n\n### 代码\n\n\n```py\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329305839","body":"### 思路\n滑动窗口，双指针\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> maxqueue;\n        int n=nums.size();\n        vector<int> results;\n        for(int i=0;i<k;i++){\n            if(maxqueue.empty()) maxqueue.push_back(nums[i]);\n            else{\n                while(!maxqueue.empty()&&maxqueue.back()<nums[i]) maxqueue.pop_back();\n                maxqueue.push_back(nums[i]);\n            }\n        }\n        \n        for(int i=0;i<n-k;i++){\n            results.push_back(maxqueue.front());\n            //cout<<\"i=\"<<i<<\" \"<<maxqueue.front()<<\" \";\n            if(nums[i]==maxqueue.front()){\n                maxqueue.pop_front();\n            }\n            if(maxqueue.empty()) maxqueue.push_back(nums[i+k]);\n            else{\n                while(!maxqueue.empty()&&maxqueue.back()<nums[i+k]) maxqueue.pop_back();\n                maxqueue.push_back(nums[i+k]);\n                //cout<<\"i=\"<<i<<\" \"<<nums[i+k]<<\" \"<<endl;\n            }\n            //results.push_back(maxqueue.front());\n        }\n        results.push_back(maxqueue.front());\n        return results;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298406546","body":"### 代码(java)\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int N = A.length;\n        int cur = K;\n        List<Integer> ans = new ArrayList();\n\n        int i = N;\n        while (--i >= 0 || cur > 0) {\n            if (i >= 0)\n                cur += A[i];\n            ans.add(cur % 10);\n            cur /= 10;\n        }\n\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300208592","body":"### 代码\n```java\npackage com.kami.leetcode.leetcodejiajia;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Description: 821. 字符的最短距离\n * 两次遍历\n * @author: scott\n * @date: 2022年11月02日 19:45\n */\npublic class DayTwo821 {\n\n    public static void main(String[] args) {\n        String s = \"loveleetcode\";\n        //  测试结果\n        int[] es = shortestToChar(s, 'e');\n        System.out.println(Arrays.toString(es));\n    }\n\n\n    public static int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301722550","body":"### 代码\n\n```java\npackage com.kami.leetcode.leetcodejiajia;\n\n/**\n * @Description: 数组模拟栈1381\n * @author: scott\n * @date: 2022年11月03日 13:46\n */\npublic class DayTHREETest1381 {\n\n    int [] stack;\n    int top;\n\n    public DayTHREETest1381(int maxSize){\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x){\n        if(top != stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n\n    public int pop(){\n        if(top == -1){\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n\n    public void increment(int k, int val){\n        int limit = Math.min(k, top + 1);\n        for(int i  = 0; i < limit; ++i){\n            stack[i] += val;\n        }\n    }\n}\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305493272","body":"### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306521515","body":"#### 代码一\n\n```java\n//递归思想\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n```\n\n#### 代码二\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        //虚拟头节点\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n\n        //两两相邻的节点中第一个节点的前驱节点\n        ListNode cur = dummy;\n        while (cur != null && cur.next != null && cur.next.next != null){\n\n            //第一个节点\n            ListNode first = cur.next;\n            //第二个节点\n            ListNode second = cur.next.next;\n            //第三个节点 \n            ListNode third = second.next;\n            \n            cur.next = second;\n            second.next = first;\n            first.next = third;\n            \n            //将cur向后移动两位\n            cur = cur.next.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308192139","body":"#### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309693832","body":"#### 思路\n1、先计算两个链表的长度。2、判断两个链表最后一位是否相同不相同就返回null。3、找到两个链表长的呢一个链表。4、让长的链表先往后next，直到两个链表的长度相同为止5、这时候同时遍历两个链表，进行链表节点一对一的比较，如果相同就返回，否则继续遍历6、如果上述没有找到相交节点就返回null\n\n#### 代码\n```\n**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null){\n            return null;\n        }\n\n        //计算长度\n        int lenA = 0;\n        int lenB = 0;\n        ListNode curA = headA;\n        ListNode curB = headB;\n        while (curA != null){\n            lenA++;\n            curA = curA.next;\n        }\n        while (curB != null){\n            lenB++;\n            curB = curB.next;\n        }\n\n        //如果这会curA和curB不相同就证明没有相交\n        if(curA != curB){\n            return null;\n        }\n\n        //找到long的链表\n        ListNode longer = headA;\n        ListNode shorter = headB;\n        if(lenA < lenB){\n            longer = headB;\n            shorter = headA;\n        }\n\n        //让长的先将长出来的自己走完\n        for(int i = 0; i < Math.abs(lenA - lenB); i++){\n            longer = longer.next;\n        }\n\n        //这时候在进行节点的比较\n        while (longer != null && shorter != null){\n            //判断两个链表的节点是否相同\n            if(longer == shorter){\n                return longer;\n            }\n            longer = longer.next;\n            shorter = shorter.next;\n        }\n        \n        //如果上面判断完没有相同的节点，证明没有相交，返回null\n        return null;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312905699","body":"#### 思路\n方法：深度优先搜索\n如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。\n如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。\n\n#### 代码\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314730790","body":"#### 深度优先搜索的思路\n```\n深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\n```\n\n#### 代码\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316298302","body":"#### 代码\n```java\nclass Solution {\n    int curVal = 0;\n    int curHeight = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n\n    public void dfs(TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318191594","body":"#### 思路：深度优先搜索\n\n#### 代码：\n```java\npublic String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319473680","body":"#### 代码\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325923940","body":"#### 代码\n\n```java\nimport java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328438333","body":"#### 代码\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] pair1, int[] pair2) {\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];\n            }\n        });\n        for (int i = 0; i < k; ++i) {\n            pq.offer(new int[]{nums[i], i});\n        }\n        int[] ans = new int[n - k + 1];\n        ans[0] = pq.peek()[0];\n        for (int i = k; i < n; ++i) {\n            pq.offer(new int[]{nums[i], i});\n            while (pq.peek()[1] <= i - k) {\n                pq.poll();\n            }\n            ans[i - k + 1] = pq.peek()[0];\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331786293","body":"#### 代码\n\n```java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\n        color[curnode] = nowcolor;\n        for (int nextnode : g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333398711","body":"#### 代码\n\n```java\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n + m; ++i) {\n            groupItem.add(new ArrayList<Integer>());\n        }\n\n        // 组间和组内依赖图\n        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n + m; ++i) {\n            groupGraph.add(new ArrayList<Integer>());\n        }\n        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n; ++i) {\n            itemGraph.add(new ArrayList<Integer>());\n        }\n\n        // 组间和组内入度数组\n        int[] groupDegree = new int[n + m];\n        int[] itemDegree = new int[n];\n        \n        List<Integer> id = new ArrayList<Integer>();\n        for (int i = 0; i < n + m; ++i) {\n            id.add(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem.get(group[i]).add(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (int item : beforeItems.get(i)) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph.get(item).add(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph.get(beforeGroupId).add(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return new int[0];\n        }\n        int[] ans = new int[n];\n        int index = 0;\n        // 组内拓扑关系排序\n        for (int curGroupId : groupTopSort) {\n            int size = groupItem.get(curGroupId).size();\n            if (size == 0) {\n                continue;\n            }\n            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));\n            if (res.size() == 0) {\n                return new int[0];\n            }\n            for (int item : res) {\n                ans[index++] = item;\n            }\n        }\n        return ans;\n    }\n\n    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {\n        Queue<Integer> queue = new LinkedList<Integer>();\n        for (int item : items) {\n            if (deg[item] == 0) {\n                queue.offer(item);\n            }\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        while (!queue.isEmpty()) {\n            int u = queue.poll(); \n            res.add(u);\n            for (int v : graph.get(u)) {\n                if (--deg[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : new ArrayList<Integer>();\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298429697","body":"### 思路\nnum和k相加，从个位开始相加，同时记录一个进位变量，将数据放入list,反转即可\n\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //获取K的每一位数，直到K/10=0\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        int i=num.length-1;\n        //记录一个进位变量\n        int carry=0;\n        while(i>=0 || k>0){\n            int a= i>=0?num[i]:0;\n            int sum = a +k%10+carry;\n            carry= sum/10;\n            i--;\n            k=k/10;\n            res.add(sum%10);\n        }\n        if(carry>0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299678058","body":"## 思路\n1.遍历字符串，获取到字符 c 的位置，放入List中\n2.定义两个指针，last和next,刚开始last和next相等，当当前指针大于next指针时，将next指向下一个字符位置，last指向上一个字符位置，将当前指针与两个指针的差值最小作为结果集的元素\n\n## 代码\n```java\nclass Solution {\n        public int[] shortestToChar(String s, char c) {\n\n            ArrayList<Integer> es = new ArrayList<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    es.add(i);\n                }\n            }\n            int z=0;\n            int next = es.get(z);\n            int last= es.get(z);\n            int[] res = new int[s.length()];\n            for (int j = 0; j < s.length(); j++) {\n                if (j > next && es.size()> ++z) {\n                    last = next;\n                    next=es.get(z);\n                }\n                    res[j] = Math.min(Math.abs(j - next), Math.abs(j - last));\n            }\n            return res;\n        }\n    }\n```\n\n**复杂度分析**\n- 时间复杂度 O(N)\n- 空间复杂度 O(N^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301609830","body":"## 思路\n- 使用数组模拟栈\n- 栈的属性,栈的最大元素个数，栈顶值（用来判断栈中元素是否满了或空了）\n- increment方法：需要比较k值和栈中元素个数\n\n##\n```java\nclass CustomStack {\n        //栈的大小\n        private int maxSize;\n        //使用数组模拟栈\n        private int[] stack;\n        //top=-1\n        private int top = -1;\n\n        public CustomStack(int maxSize) {\n            this.maxSize = maxSize;\n            stack = new int[this.maxSize];\n        }\n\n        public void push(int x) {\n            if (top != stack.length - 1) {\n                stack[++top] = x;\n            }\n        }\n\n        public int pop() {\n            if (top != -1) {\n                return stack[top--];\n            } else {\n                return -1;\n            }\n\n        }\n\n        public void increment(int k, int val) {\n            int m = Math.min(k, top + 1);\n            for (int i = 0; i < m; i++) {\n                stack[i] = stack[i] + val;\n            }\n        }\n    }\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n**复杂度分析**\n- 时间复杂度\n- 空间复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303692208","body":"## 思路\n- 声明两个栈，一个数字栈，一个字符串栈\n- 注意数字可能不是个位数，因此需要累加\n- 遇到[，表明数字结束，将数字加入栈中，同时将空字符串加入栈中，并将数字和字符串记录归0\n- 遇到],pop字符串和数字，按照数字个数组织字符串，并将新的字符串赋给buff\n\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        //声明一个栈，存放数字\n        Stack<Integer> stackNum = new Stack<>();\n        //声明一个栈，存放字符\n        Stack<StringBuffer> stackStr = new Stack<>();\n        //记录数字\n        int num=0;\n        StringBuffer buff = new StringBuffer();\n        for (int i = 0; i < s.length(); i++) {\n            if(Character.isDigit(s.charAt(i))){\n                num=num*10+s.charAt(i)-'0';\n            }else if(s.charAt(i)=='['){\n                //先将数字入栈\n                stackNum.push(num);\n                //把字符存起来\n                stackStr.push(buff);\n                //数字归0\n                num=0;\n                buff=new StringBuffer();\n\n            }else if(s.charAt(i)==']'){\n                //取出数字栈顶元素\n                Integer pop = stackNum.pop();\n                //取出栈顶的字符栈\n                StringBuffer str = stackStr.pop();\n                for (int j = 0; j < pop; j++) {\n                    str.append(buff.toString());\n                }\n                buff=str;\n            }else{\n                buff.append(s.charAt(i));\n            }\n\n        }\n\n        return buff.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304397283","body":"## 思路\n- 使用两个栈，一个输入栈，一个输出栈\n- push时pop到输入栈；pop或peek时需要将数据从输入栈pop出,push到输出栈，然后再将数据pop或peek\n- empty方法需要判断两个栈都为空\n\n## 代码\n```java\nclass MyQueue {\n     //一个输入栈\n        private Stack inStack;\n     //一个输出栈\n     private Stack outStack;\n    public MyQueue() {\n        this.inStack=new Stack<Integer>();\n        this.outStack=new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        //push时，将数据push近输入栈\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        int res=0;\n        //如果输出栈为空，则可以将数据从输入栈中出栈，入栈到输出栈，再pop\n        if(outStack.empty()){\n            while(!inStack.empty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return Integer.parseInt(outStack.pop().toString());\n    }\n    \n    public int peek() {\n        if(outStack.empty()){\n            while(!inStack.empty()){\n                outStack.push(inStack.pop());\n            }\n        }\n\n          return  Integer.parseInt(outStack.peek().toString());\n\n    }\n    \n    public boolean empty() {\n        if(outStack.empty() && inStack.empty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度:O(1)\n- 空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304819345","body":"## 思路\n- 考虑使用单调栈\n- 当栈为空或者后面的数字大于栈顶值时，需要将当前元素推入栈中；\n- 同时，当后面的元素小于栈顶元素时，需要和栈中所有的元素进行比较，以便判断当前元素是加入上一个块还是把比当前元素大的块都连在一起;\n- 最后，返回栈的大小\n\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if(stack.empty() || num>=stack.peek()){\n                //如果栈为空，或者当前元素大于等于栈顶元素，将当前元素入栈\n                stack.push(num);\n            }else{\n                //如果新加入的数字小于栈顶元素，则需要判断:是否比倒数第二个块的数字也小，\n                //如果小的话，需要将该块加入到一起，直到它大于以前块的最大值\n                Integer maxValue = stack.pop();\n                while(!stack.empty() && stack.peek()>num){\n                    stack.pop();\n                }\n                stack.push(maxValue);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度:O(N)\n- 空间复杂度:O(N),栈的长度最多为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305374813","body":"## 思路\n- 需要确认在什么位置截断，即确定旋转的插入点和新链表的头节点位置，链表长度-K对链表长度取模，遍历到该点后，此点的next指向新链表的头节点，并将尾节点指向头节点，并在此处将该点指向null\n\n## 关键点\n\n-  如何确定插入点的位置\n- 如果k>链表长度怎么处理\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n if (head==null) return null;\n        int i=1;\n        ListNode curr=head;\n        //获取链表的长度\n        while(curr.next!=null){\n            curr=curr.next;\n            i++;\n        }\n        k=k%i;\n        //如果k等于0，返回原链表\n        if(k==0) return head;\n        //找到要插入的位置\n        ListNode node=head;\n        int point=i-k;\n        for (int j = 1; j < point; j++) {\n            node=node.next;\n        }\n        //截断的点位处指向一个新的节点\n        ListNode newNode=node.next;\n        //成为一个循环链表\n        curr.next=head;\n        //将node.next指向null,截断\n        node.next=null;\n        return newNode;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ 遍历链表两次\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306556247","body":"\n## 思路\n- 需要明确一次交换的节点顺序；\n- 首先，确定此次交换后的头节点，即curr.next=end，同时也和pre.next连接起来\n- 其次，需要确定此次交换的尾部和未交换部分的连接，即start.next=end.next;\n- 再次，交换，即 end.next=start\n- 最后，移动curr,将curr=start,为下一次交换做准备\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n if(head==null || head.next==null){\n            return head;\n        }\n        //声明一个哑节点\n        ListNode pre=new ListNode(-1);\n        pre.next= head;、\n       //curr专门用来遍历\n        ListNode curr=pre;\n        while( curr.next!=null && curr.next.next!=null){\n            ListNode start=curr.next;\n            ListNode end=curr.next.next;\n            //确定此次翻转的头节点\n            curr.next=end;\n            //此次交换的尾部指向未交换的节点\n            start.next=end.next;\n            //交换，end的下一个指向start\n            end.next=start;\n            //移动curr,为下一次交换做准备\n            curr=start;\n        }\n        return pre.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308896585","body":"## 思路\n- 使用快慢指针找到中点，切断左右\n- 使用递归，利用递归的反转性，rootNode.left = sortedListToBST(head); 这样树的最左边节点就是最小值。rootNode.right = sortedListToBST(slow.next);这样树的右边第一个节点就是最大值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==null) return null;\n        else if(head.next==null) return new TreeNode(head.val);\n        ListNode curr=new ListNode();\n        curr.next=head;\n        ListNode slow=head;\n        ListNode fast=head;\n        //当fast结束时，slow就是中点，curr是slow的前一个节点\n        while(fast!=null && fast.next!=null){\n            curr=curr.next;\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n        //将slow前的节点截断\n        curr.next=null;\n        //中点就是根节点\n        TreeNode rootNode = new TreeNode(slow.val);\n        rootNode.left=sortedListToBST(head);\n        rootNode.right=sortedListToBST(slow.next);\n        return rootNode;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310057975","body":"## 思路\n- 使用双指针\n- 两个指针按照相同的步长和时间前进，当链表A走到终点，下一个节点为headB，当链表B走到终点，下一个节点为headA;\n- 当两个链表有公共尾部时，两个链表节点相等的即为相交节点，假如公共节点数量为c,链表A长度为a,链表b长度为b,此时指针a走过的距离为\na+(b-c),指针b走过的距离为b+(a-c),刚好相等；如果没有公共尾部，两个最后都会指向null,此时两个指针走过的距离为a+b\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n         if (headA == null || headB == null) return null;\n            ListNode currA = headA;\n            ListNode currB = headB;\n            while (currA != currB) {\n                currA = currA == null ? headB : currA.next;\n                currB = currB == null ? headA : currB.next;\n            }\n            return currA;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(a+b)$ a和b为链表长度\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311157220","body":"## 思路\n- 考虑使用map记录节点，map中包含遍历节点时，即说明该节点就是环形链表的入口节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n         //定义一个返回的节点\n        ListNode resultNode=null;\n        //定义一个遍历节点\n        ListNode curr=head;\n        //声明一个map，用于存储节点\n        HashMap<ListNode, ListNode> map = new HashMap<ListNode, ListNode>();\n        while(curr!=null){\n            if(!map.containsKey(curr)){\n                map.put(curr,curr.next);\n            }else{\n                resultNode=curr;\n                break;\n            }\n            curr=curr.next;\n        }\n        return resultNode;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312507146","body":"## 思路\n- map和双向链表\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass LRUCache {\n private HashMap<Integer,DoubleNode> map;\n        //双链表\n        private DoubleLinkList cache;\n        //最大容量\n        private int capacity;\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n        map=new HashMap<Integer,DoubleNode>();\n        cache=new DoubleLinkList();\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        //将该key提升为最常使用\n        makeRecently(key);\n        return map.get(key).val;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            //删除该节点，再将其加入到尾部，最近使用的节点\n            deleteKay(key);\n            addRecently(key,value);\n            return;\n        }\n        if(capacity==cache.size()){\n            //删除最久未使用的\n            removeLeastRecently();\n        }\n        //添加为最近使用的\n        addRecently(key,value);\n    }\n\n    //将某个key提升为最近使用的\n        private void makeRecently(int key){\n            DoubleNode doubleNode = map.get(key);\n            //先从链表中删除这个节点，再重新插入到尾部\n            cache.remove(doubleNode);\n            cache.addLast(doubleNode);\n        }\n        //添加最近使用的元素\n        private void addRecently(int key,int val){\n            DoubleNode node = new DoubleNode(key, val);\n            //尾部就是最近使用的元素\n            cache.addLast(node);\n            //同时再map中记录\n            map.put(key,node);\n        }\n        //删除某一个key\n        private void deleteKay(int key){\n            DoubleNode node = map.get(key);\n            //链表中删除\n            cache.remove(node);\n            //从map中删除\n            map.remove(key);\n        }\n        //删除长期未使用的元素\n        private void removeLeastRecently(){\n        //即第一个元素\n           DoubleNode node = cache.removeFirst();\n            int key = node.key;\n            map.remove(key);\n        }\n}\n//构建双链表\n    class DoubleLinkList{\n        //头尾节点\n    private DoubleNode head,tail;\n    //链表capacity\n    private int size;\n    public DoubleLinkList(){\n        //初始化双向链表的数据\n        head=new DoubleNode(0,0);\n        tail=new DoubleNode(0,0);\n        //双向链表,此时的head和tail都是哑节点，目前链表种没有元素\n        head.next=tail;\n        tail.pre=head;\n        size=0;\n    }\n    //在链表尾部添加节点x\n    public void addLast(DoubleNode x){\n        x.pre=tail.pre;\n        x.next=tail;\n        tail.pre.next=x;\n        tail.pre=x;\n        size++;\n    }\n    //删除链表种的x节点\n    public void remove(DoubleNode x){\n        x.pre.next=x.next;\n        x.next.pre=x.pre;\n        size--;\n    }\n    //删除链表中的第一个节点，并返回节点\n    public DoubleNode removeFirst(){\n        if(head.next==tail) return null;\n        DoubleNode first=head.next;\n        remove(first);\n        return first;\n    }\n    //返回链表的长度\n    public int size(){\n        return size;\n    }\n}\n    //双链表的节点类\n    class DoubleNode{\n        public int key;\n        public int val;\n        public DoubleNode next;\n        public DoubleNode pre;\n        public DoubleNode(int k,int v){\n            this.key=k;\n            this.val=v;\n        }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312686900","body":"## 思路\n- 树考虑使用递归\n- 递归终止条件 节点为null,说明该节点已经是叶子节点了\n- 加上本身这一层，就是树的深度\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n if(root==null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313846129","body":"## 思路\n- 递归\n- 比较两个树，左子树和右子树分别相等\n- 递归的终止：p和q均为null，返回true,p或q为null，则返回false,如果p和q的值不相等也返回false\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n if(p==null && q==null){\n            return true;\n        }\n        if(p==null || q==null){\n            return false;\n        }\n        if(p.val!=q.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315442149","body":"## 思路\n- 考虑使用dfs\n- 如何确定每一个路径上的值，当前节点的值*10+左子节点的值/右子节点的值，该值需要累计，使用sum表示\n- 递归的终止条件：当遇到叶子节点，此时该路径上的值可以返回，即该路径的最终值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n       return nodeSum(root,0);\n\n    }\n    public int nodeSum(TreeNode node,int sum){\n        if(node==null) return 0;\n        sum=sum*10+node.val;\n        if(node.left==null && node.right==null){\n            //已经是叶子节点了，可以返回该路径的最终值了\n            return sum;\n        }\n        return nodeSum(node.left,sum)+nodeSum(node.right,sum);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317130357","body":"## 思路\n- 广度优先遍历\n- 从右往左遍历，最后一个遍历的即是最后一层的最左边节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res=0;\n        ArrayDeque<TreeNode> arrayDeque = new ArrayDeque<TreeNode>();\n        arrayDeque.add(root);\n        while(!arrayDeque.isEmpty()){\n            TreeNode node = arrayDeque.poll();\n            if(node.right!=null){\n                arrayDeque.add(node.right);\n            }\n            if(node.left!=null){\n                arrayDeque.add(node.left);\n            }\n            res=node.val;\n        }\n        return res;\n    }\n}\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318809651","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n   public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root,sb);\n        return sb.toString();\n    }\n    \n    void serialize(TreeNode root,StringBuilder sb) {\n    \tif (root == null) {\n\t\t\tsb.append(\"null\").append(\",\");\n\t\t\treturn;\n\t\t}\n    \t\n    \tsb.append(root.val).append(\",\");\n    \t\n    \tserialize(root.left,sb);\n    \tserialize(root.right,sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        LinkedList<String> nodes = new LinkedList<>();\n        for (String str : data.split(\",\")) {\n\t\t\tnodes.add(str);\n\t\t}\n        return deserialize(nodes);\n    }\n    \n    public TreeNode deserialize(LinkedList<String> nodes) {\n    \tif (nodes.isEmpty()) {  //注意是数组转换为链表\n\t\t\treturn null;\n\t\t}\n    \t\n    \t//链表最左侧为根节点\n    \tString first = nodes.removeFirst();  \n    \tif (first.equals(\"null\")) {\n\t\t\treturn null;\n\t\t}\n    \tTreeNode root = new TreeNode(Integer.parseInt(first));\n    \t\n    \troot.left = deserialize(nodes);\n    \troot.right = deserialize(nodes);\n    \t\n    \treturn root;\n    \t\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320178694","body":"## 思路\n- 使用dfs遍历树\n- 注意遍历过程中将树加入到map中，map的key为TreeNode,value为列，行和节点值\n- 按照这三个排序，列从小到大，行从小到大，同行同列从小到大\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    Map<TreeNode,int[]> map=new HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root,new int[]{0,0,root.val});\n        dfs(root);\n        //对map中的节点进行排序，按照列号从小到大，行号从小到大，同行同列按值排序\n        List<int[]> list=new ArrayList<>(map.values());\n        Collections.sort(list,(a,b)->{\n            if(a[0]!=b[0]) return a[0] - b[0];\n            if(a[1]!=b[1]) return a[1] - b[1];\n            return a[2]-b[2];\n        });\n        int n=list.size();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n;) {\n            int j=i;\n            List<Integer> tmp = new ArrayList<>();\n            while(j<n && list.get(j)[0]==list.get(i)[0]){\n                tmp.add(list.get(j++)[2]);\n\n            }\n            ans.add(tmp);\n            i=j;\n\n        }\n        return ans;\n    }\n\n    void dfs(TreeNode root){\n        if(root==null) return;\n        int[] info=map.get(root);\n        int col=info[0];\n        int row=info[1];\n        int val=info[2];\n        if(root.left!=null){\n            map.put(root.left,new int[]{col-1,row+1,root.left.val});\n            dfs(root.left);\n        }\n        if(root.right!=null){\n            map.put(root.right,new int[]{col+1,row+1,root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320900921","body":"public int[] twoSum(int[] nums, int target) {\n        //声明一个map,key为val,value为index\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int[] res = new int[2];\n        //遍历数组\n        for (int i = 0; i < nums.length; i++) {\n           if(map.containsKey(target-nums[i])){\n              //如果map中包含target-num[i],则该点已经找到，返回\n              //key冲突问题在此处可以解决:如果两个key相同，在此处因为已经找到，不需要再入map,因此不存在冲突\n               res[0]=map.get(target-nums[i]);\n               res[1]=i;\n               break;\n           }\n           map.put(nums[i],i);\n        }\n\n        return res;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1322238251","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if(map.containsKey(num)){\n                Integer value = map.get(num);\n                map.put(num,value+1);\n            }else{\n                map.put(num,1);\n            }\n        }\n        // 遍历map，用最小堆保存频率最大的k个元素\n        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                return map.get(a) - map.get(b);\n            }\n        });\n        for (Integer key : map.keySet()) {\n            if (pq.size() < k) {\n                pq.add(key);\n            } else if (map.get(key) > map.get(pq.peek())) {\n                pq.remove();\n                pq.add(key);\n            }}\n        // 取出最小堆中的元素\n\n       int[] res = new int[k];\n\n        for (int i = 0; i < k; i++) {\n            res[i]=(pq.remove());\n        }\n\n        return res;\n\n    }\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322247476","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n int ans = 0;\n        for(int i=0;i<points.length;i++){\n            Map<Integer,Integer> map = new HashMap();\n            for(int j=0;j<points.length;j++){\n                int disX = points[i][0] - points[j][0];\n                int disY = points[i][1] - points[j][1];\n                int distance = disX * disX + disY * disY;\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n\n            for(int val : map.values()){\n                if(val > 1){\n                    ans += val * (val -1);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323858794","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s==null || s.length()==0){\n       return 0;\n   }\n   HashMap<Character,Integer> map = new HashMap<>();\n   int n = s.length();\n   int count = 0,max = 0;\n    for (int i = 0; i < n; i++) {\n        char ch = s.charAt(i);\n        if(map.containsKey(ch)){\n            i = map.get(ch);\n            map.clear();\n            count=0;\n        }else {\n            map.put(ch,i);\n            count++;\n            max = Integer.max(max,count);\n        }\n    }\n    return max;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325279116","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\nArrayList<Integer> res = new ArrayList<>();\n        if(words==null || words.length==0) return res;\n        //将words存入map\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word,map.getOrDefault(word,0)+1);\n        }\n        //字符串的长度\n        int length=s.length();\n        //单个word的长度\n        int wLen = words[0].length();\n        //words的个数\n        int count=words.length;\n        //按照words的总长度进行截断s\n        for (int i = 0; i < length-wLen*count+1; i++) {\n            //按照words的总长度进行截断\n            String curr = s.substring(i, i + wLen * count);\n            HashMap<String, Integer> temp = new HashMap<>();\n            //针对curr进行遍历，长度为words中每个元素的长度来遍历\n            int j = 0;\n            for (; j < curr.length(); j+=wLen) {\n                //获取单独一个word长度的字符\n                String word = curr.substring(j, j + wLen);\n                if(!map.containsKey(word)) break;\n                temp.put(word,temp.getOrDefault(word,0)+1);\n                if(temp.get(word)>map.get(word)) break;\n\n            }\n            if(j==curr.length()) res.add(i);\n\n        }\nreturn res;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326564498","body":"力扣同类型题目\nclass Solution {\n    public int subarraysDivByK(int[] A, int K) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        map.put(0,1);\n        int presum = 0;\n        int count = 0;\n        for (int x : A) {\n             presum += x;\n             //当前 presum 与 K的关系，余数是几，当被除数为负数时取模结果为负数，需修正\n             int key = (presum % K + K) % K;\n             //查询map获取key也就是余数的次数\n             if (map.containsKey(key)) {\n                 count += map.get(key);\n             }\n             //存入map当前key，也就是余数\n             map.put(key,map.getOrDefault(key,0)+1);\n        }\n        return count;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327144135","body":"## 思路\n- 快慢指针，慢指针一次走一步，快指针一次走两步\n- 重点需要注意链表节点个数，将初始指针直接定位head,无论个数是奇数还是偶数都能够指向题目要求的中间节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n//声明两个指针，一个慢指针，一个快指针\n        ListNode slow=head;\n        ListNode fast=head;\n        while(fast!=null && fast.next!=null){\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n        return slow;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ n为链表个数\n- 空间复杂度：$O(1)$ \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328049670","body":"## 思路\n- 双指针\n- 一个读指针，一个写指针，初始位置两个指针相同，当两个指针指向的值相同时，读指针向后移动；否则，写指针向后移动，并且将当前写指针指向的值置为都指针当前指向的值\n- 注意：因为目前返回的ifast是下标，但是需要返回的是数组长度，所以返回值要+1；\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int islow=0;\n        int ifast=0;\n       while(ifast < nums.length){\n           if(nums[islow]==nums[ifast]){\n               ++ifast;\n           }else{\n               //如果两个不相等，则将islow向后移动，并且将islow指向的值置为当前ifast的值\n               ++islow;\n               nums[islow]=nums[ifast];\n           }\n       }\n       return islow+1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ n为数组长度\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328185241","body":"## 思路\n- 二分法，双指针\n- 二分法，定义左右两个指针，找到中间指针，当target大于中间指针的值，说明中间指针左边的值都小于target,则left=mid+1;当target小于中间指针的值，说明中间指针右边的值都大于target,则right=mid-1;当中间指针的值与target值相等，则返回mid指针；\n- 直到left>=right指针循环结束\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n     \n       if(nums.length==0){\n           return -1;\n       }\n       int left=0;\n       int right=nums.length-1;\n       while(left<=right){\n           int mid=(left+right)/2;\n           if(nums[mid]>target){\n                right=mid-1;\n           }else if(nums[mid]<target){\n              left=mid+1;\n           }else if(nums[mid]==target){\n             return mid;\n           }\n       }\n       return left;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logN)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329234950","body":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length<2){\n            return nums;\n        }\n     //双向队列，保存当前窗口的最大值，保证队列中的值从大到小排列\n     LinkedList<Integer> queue = new LinkedList();\n     //结果\n     int[] res = new int[nums.length-k+1];\n     for(int i=0;i<nums.length;i++){\n         //队列中要保持从大到小排列，如果队尾的值小，则需要依次弹出\n         while(!queue.isEmpty()&&nums[queue.peekLast()]<=nums[i]){\n             queue.pollLast();\n         }\n         //添加当前值进入队列\n         queue.addLast(i);\n         //判断当前队列中队首的值是否有效\n         if(queue.peek()<=i-k){\n             queue.poll();\n         }\n         //当窗口长度为k时，保存当前窗口的最大值\n         if(i+1>=k){\n             res[i+1-k]=nums[queue.peek()];\n         }\n     }\n      return res; \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330694878","body":"## 思路\n- 将【ai,bi】看作一个有向图，ai->bi，ai为出度，bi为入度\n- 当入度为n-1，出度为0时，返回i\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n int[] in=new int[n+1];\n        int[] out=new int[n+1];\n        for (int[] ints : trust) {\n            int a=ints[0];\n            int b=ints[1];\n            //入度\n            in[b]++;\n            //出度\n            out[a]++;\n        }\n        for (int i = 1; i <=n ; i++) {\n            if(in[i]==n-1 && out[i]==0){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332339665","body":"## 思路\n- dfs\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color =new int[n+1];\n        List<Integer>[] g=new List[n+1];\n        for (int i = 0; i <= n; i++) {\n            g[i]=new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 0; i <=n; i++) {\n            if(color[i]==0 && !dfs(i,1,color,g)){\n                return false;\n            }\n        }\n        return true;\n    }\n    public boolean dfs(int curnode,int newcolor,int[] color,List<Integer>[] g){\n        color[curnode]=newcolor;\n        for(int nextnode:g[curnode]){\n            if(color[nextnode] !=0 && color[nextnode]==color[curnode]){\n                return false;\n            }\n            if(color[nextnode]==0 && !dfs(nextnode,3^newcolor,color,g)){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333845417","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n // 初始化，将Items分组扔进各个组的set里，将group放进一个set\n        Map<Integer, Set<Integer>> groupItems = new HashMap<>();\n        Set<Integer> groupIds = new HashSet<>();\n        int gId = m;\n        for(int i = 0; i < n; ++i){\n            if(group[i] == -1){\n                group[i] = gId++;\n            }\n            int groupId = group[i];\n            if(!groupItems.containsKey(groupId)){\n                groupItems.put(groupId, new HashSet());\n            }\n            groupItems.get(groupId).add(i);\n            groupIds.add(group[i]);\n        }\n\n        // 构造图，划分为组间的拓扑和组内item的拓扑图\n        // 数组计算各个group或item的入度，链表计算某group或item完成后可以减少哪些group或item入度\n        int[] betweenGroupInDev = new int[gId];\n        List<List<Integer>> groupNeighbours = new ArrayList<>();\n        int[] inGroupInDev = new int[n];\n        List<List<Integer>> itemNeighbours = new ArrayList<>();\n        for(int i = 0; i < n; ++i){\n            List<Integer> beforeItem = beforeItems.get(i);\n            for(int one: beforeItem){\n                if(group[i] == group[one]){\n                    // 同一个小组内，则计为组内的入度\n                    inGroupInDev[i]++;\n                    while(itemNeighbours.size() <= one){\n                        itemNeighbours.add(new ArrayList<>());\n                    }\n                    itemNeighbours.get(one).add(i);\n                }else{\n                    // 不同小组，则计为小组间的入度\n                    betweenGroupInDev[group[i]]++;\n                    while(groupNeighbours.size() <= group[one]){\n                        groupNeighbours.add(new ArrayList<>());\n                    }\n                    groupNeighbours.get(group[one]).add(group[i]);\n                }\n            }\n        }\n\n        // 开始拓扑排序，先组间拓扑排序\n        List<Integer> groupOrder = topSort(groupIds, betweenGroupInDev, groupNeighbours);\n        int[] res = new int[n];\n        if(groupOrder.size() == 0) return new int[0];\n\n        // 基于组间的拓扑顺序，对各个组内的item进行拓扑排序\n        int i = 0;\n        for(int group1: groupOrder){\n            List<Integer> itemOrder = topSort(groupItems.get(group1), inGroupInDev, itemNeighbours);\n            if(itemOrder.size() == 0) return new int[0];\n            for(int item: itemOrder){\n                res[i++] = item;\n            }\n        }\n        return res;\n    }\n\n    public List<Integer> topSort(Set<Integer> set, int[] inDev, List<List<Integer>> neighbours){\n        Deque<Integer> queue = new LinkedList<>();\n        List<Integer> res = new ArrayList<>();\n        for(int i: set){\n            if(inDev[i] == 0){\n                queue.offer(i);\n                res.add(i);\n            }\n        }\n        while(!queue.isEmpty()){\n            int cur = queue.poll();\n            if(neighbours.size() <= cur) continue;\n            for(int neighbour: neighbours.get(cur)){\n                if(--inDev[neighbour] == 0){\n                    queue.offer(neighbour);\n                    res.add(neighbour);\n                }\n            }\n        }\n        return res.size() == set.size()? res:new ArrayList<>();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335346149","body":"## 思路\n- 上下左右，按照每个步骤进行加减即可\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public boolean judgeCircle(String moves) {\n int x=0;\n        int y=0;\n        for (char c : moves.toCharArray()) {\n            if(c=='R'){\n                x++;\n            }else if(c=='L'){\n                x--;\n            }else if(c=='U'){\n                y++;\n            }else if(c=='D'){\n                y--;\n            }\n        }\n        return x==0 && y==0;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298455946","body":"```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n //一开始尝试转为数字逐位相加，没考虑越界问题，部分用例没有通过。参考了题解中的一个答案修改。\nvar addToArrayForm = function(num, k) {\n    const result = [];\n    let i = num.length - 1;\n    while(i>= 0 || k > 0){\n        if(i >= 0){\n            k += num[i];\n            i--;\n        }\n        result.push(k % 10);\n        k = parseInt(k / 10);\n    }\n   \n    return result.reverse();\n};\n//时间复杂度 O(n)\n//空间复杂度 O(1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298543068","body":"### 思路 \n反向逐位相加\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int add = 0;\n        int sum = 0;\n        for (int i = num.length - 1; i >= 0; --i) {\n            sum = num[i] + k % 10 + add;\n            add = sum / 10;\n            sum = sum % 10;\n            k = k / 10;\n            list.add(sum);\n        }\n        while (k > 0) {\n            sum = k % 10 + add;\n            add = sum / 10;\n            sum = sum % 10;\n            k = k / 10;\n            list.add(sum);\n        }\n        if (add > 0) {\n            list.add(add);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组⻓度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300684125","body":"### 思路 \n正向、反向遍历，取最小值\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] cs = s.toCharArray();\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, s.length());\n        int last = -s.length();\n        for (int i = 0; i < s.length(); ++i) {\n            if (cs[i] == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], i - last);\n        }\n        last = 2 * s.length();\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (cs[i] == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], last - i);\n        }\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组⻓度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308850243","body":"思路\n分治\n\n代码\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int ret = 0;\n        for (; head != nullptr; ++ret, head = head->next);\n        return ret;\n    }\n\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode();\n        root->left = buildTree(head, left, mid - 1);\n        root->val = head->val;\n        head = head->next;\n        root->right = buildTree(head, mid + 1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int length = getLength(head);\n        return buildTree(head, 0, length - 1);\n    }\n};\n\n复杂度\n时间 o(n)\n空间 o(logn)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312754621","body":"代码\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n复杂度分析\n令n为二叉树节点数\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320884577","body":"思路\n哈希表 target-num\n\n代码\n class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // 哈希表\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0;i < nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]),i};\n            }\n            map.put(target - nums[i],i);\n        }\n        return new int[]{};\n    }\n}   \n复杂度\n时间：o(n)\n空间：o(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326512842","body":"class Solution {\n    public int minSubarray(int[] nums, int p) {\n        // mod for all sum\n        int mod = 0;\n        for (int v: nums) {\n            mod = (mod + v) % p;\n        }\n        if (mod == 0) {\n            return 0;\n        }\n\n        int res = nums.length; // cannot remove the whole array\n\n        Map <Integer, Integer> map = new HashMap < > (); // mod to last idx pos\n        map.put(0, -1);\n\n        int sum = 0, diff = 0;\n        int idx = 0;\n\n        for (int v: nums) {\n            sum = (sum + v) % p;\n            diff = (sum - mod + p) % p;\n            if (map.containsKey(diff)) {\n                res = Math.min(res, idx - map.get(diff));\n            }\n            map.put(sum, idx);\n            idx++;\n        }\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328227780","body":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(target < nums[mid]){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335247904","body":"class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298566621","body":"## 思路\n从右至左逐位计算，并将每一位的计算结果更新至新数组\n\n## 复杂度\n时间复杂度 O(max(数组长度，数字位数))\n\n## 解决方案\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 创建集合保存最后输出结果\n        List<Integer> res = new ArrayList<>();\n        // 遍历计算每一位的值及进位的值，i表示数组指针，sum表示和，carry表示进位\n        int i = num.length - 1, sum = 0, carry = 0;\n        // 循环条件：两个数有一个没计算完\n        while (i >= 0 || k != 0) {\n            // 数组取一个数字\n            int x = i >= 0 ? num[i]: 0;\n            // 整数取一位数字\n            int y = k != 0 ? k % 10 : 0;\n            // 计算两数和\n            sum = x + y + carry;\n            // 进位计算\n            carry = sum / 10;\n            // 整数砍掉个位\n            k = k / 10;\n            // 数组指针右移\n            i--;\n            // 当前位计算结束\n            res.add(0, sum % 10);\n        }\n        // 若有进位，添加至0索引位\n        if (carry != 0) {\n            res.add(0, carry);\n        }\n        return res;\n    }\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302196513","body":"## 思路\n数组模拟栈，top模拟栈顶\n\n## 代码\n```java\nclass CustomStack {\n    private int[] stack;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int popValue = stack[top];\n        --top;\n        return popValue;\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i <limit ; i++) {\n            stack[i] += val;\n\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303713221","body":"## 思路\n模拟栈\n\n## 代码\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304557568","body":"## 思路\n使用一个输入栈一个输出栈模拟队列\n\n## 复杂度分析\npush O(1)\npop O(n)\npeek O(n)\nempty O(1)\n\n## 代码\n```java\nclass MyQueue {\n    // 输入栈\n    private Stack<Integer> a;   // [1, 2, 3]\n    // 输出栈\n    private Stack<Integer> b;   // [3, 2, 1]\n\n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n\n    public void push(int x) {\n        a.push(x);\n    }\n\n    public int pop() {\n        // a [1, 2, 3]   -> b [3, 2, 1] -> return b.pop() \n        // a [4] b [3, 2]\n        if (b.isEmpty()) {\n            while (!a.isEmpty()) {\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n\n    public int peek() {\n        // 同上\n        if (b.isEmpty()) {\n            while (!a.isEmpty()) {\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n\n    public boolean empty() {\n        // a，b其一不为空即可\n        return a.isEmpty()&&b.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304815953","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305716263","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312482652","body":"```java\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317078818","body":"O(N)\n```java\nclass Solution {\n    int curVal = 0;\n    int curHeight = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n\n    public void dfs(TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321145713","body":"```java\n    public int[] topKFrequent(int[] nums, int k) {\n        int[] res = new int[k];    // 结果数组\n        Map<Integer, Integer> map = new HashMap();\n        // 统计数组中各元素出现的次数\n        for(int num : nums){\n            if(map.containsKey(num)){\n                map.put(num, map.get(num) + 1);\n            }else{\n                map.put(num, 1);\n            }\n        }\n\n        int maxTimes = 0;    // 出现最多的元素的出现次数\n        // 找出出现次数最多的元素出现的次数\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n            if(entry.getValue() > maxTimes){\n                maxTimes = entry.getValue();\n            }\n        }\n\n        // 按出现次数从大到小添加到结果数组\n        while(k > 0){\n            for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n                if(entry.getValue() == maxTimes){\n                    res[k - 1] = entry.getKey();\n                    k--;\n                }\n            }\n            maxTimes--;\n        }\n\n        return res;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298569137","body":"```\nvar addToArrayForm = function(num, k) {\n    //把k转为数组\n    let numK = [];\n    do{\n            numK.unshift(parseInt(k%10));\n            k /= 10;\n        }while(k>=1);\n    //数组k与数组num从右到左逐位相加\n    let res = [];\n    let sum = 0;\n    let i=num.length-1, j=numK.length-1;\n    for(; i>=0 && j>=0; i--,j--){\n        sum = num[i] + numK[j] + sum;\n        if(sum<10){\n            res.unshift(sum);\n            sum = 0;\n        }\n        else {\n            res.unshift(parseInt(sum%10));\n            sum = 1;\n        }\n    }\n    if(i>=0){\n        for(; i>=0 ; i--){\n            num[i] += sum;\n            if(num[i] <10){\n                res.unshift(num[i]);\n                sum = 0;\n            }\n            else {\n                res.unshift(0);\n                sum = 1;\n            }\n        }\n    }\n    else if(j>=0){\n        for(; j>=0 ; j--){\n            numK[j] += sum;\n            if(numK[j] <10){\n                res.unshift(numK[j]);\n                sum = 0;\n            }\n            else {\n                res.unshift(0);\n                sum = 1;\n            }\n        }\n    }\n    if(sum === 1) res.unshift(sum);\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300557981","body":"```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let length = s.length;\n    let res = new Array(length).fill(0);\n    for(let i=0,idx = -length;i<length; i++){\n        if(s[i] === c) idx = i;\n        res[i] = i - idx;\n    }\n    for(let j=length-1, idx = 2*length; j>=0; j-- ){\n        if(s[j] === c) idx = j;\n        res[j] = Math.min(res[j], idx-j);\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308754527","body":"‘’‘\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = (head) => {\n    if(head == null) return null;\n    let slow = head;\n    let fast = head;\n    let preSlow ;\n    // 快慢指针\n    while( fast && fast.next ){\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const res = new TreeNode(slow.val);\n    if(preSlow != null){\n        preSlow.next = null;\n        res.left = sortedListToBST(head);\n    }\n    res.right = sortedListToBST(slow.next);\n    return res;\n};\n'''","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317236188","body":"```\nvar findBottomLeftValue = function(root) {\n    let queue = [];\n    if(root===null){\n        return null;\n    }\n    queue.push(root);\n    let resNode;\n    while(queue.length){\n        let length =  queue.length;\n        for(let i=0; i<length; i++){\n            let node = queue.shift();\n            if(i===0){\n                resNode = node.val;\n            }\n            node.left&&queue.push(node.left);\n            node.right&&queue.push(node.right);\n        }\n    }\n    return resNode;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298573753","body":"\r\n### 思路\r\n\r\n本质是模拟加法的过程，用一个循环来实现，循环次数为Max(num1Len,num2Len),\r\n循环里面用下标去找到本次循环要相加的两个数，注意各用一个值标识数组的下标，要加防空，计算出当前位和进位，并更新下一次循环要用到的进位。循环结束后要判断是否需要进位\r\n\r\n#### 模板\r\n\r\n\r\n```JS\r\n  let carry = 0\r\n  while (i1 >= 0 || i2 >= 0) {\r\n      //根据下标找到,注意防空\r\n      const x = i1 >= 0 ? num1[i1] : 0\r\n      const y = i2 >= 0 ? num2Arr[i2] : 0\r\n     // 和 = A 的当前位 + B 的当前位 + 进位carry\r\n      const sum = x + y + carry\r\n      res.push(sum % 10) //当前位\r\n      carry = Math.floor(sum / 10) //进位\r\n\r\n      i1--\r\n      i2--\r\n  }\r\n  //判断还有进位吗,进位不为 0 ,加在目标值前面\r\n  if (carry) res.push(carry)\r\n```\r\n\r\n  \r\n### 代码\r\n\r\n```js\r\n var addToArrayForm = function(num1, num2) {\r\n  const res = [],num2Arr=[...num2.toString()].map((i)=>parseInt(i))\r\n  let i1 = num1.length - 1\r\n  let i2 = num2Arr.length - 1\r\n  let carry = 0\r\n  while (i1 >= 0 || i2 >= 0) {\r\n      const x = i1 >= 0 ? num1[i1] : 0\r\n      const y = i2 >= 0 ? num2Arr[i2] : 0\r\n\r\n      const sum = x + y + carry\r\n      res.push(sum % 10)\r\n      carry = Math.floor(sum / 10)\r\n\r\n      i1--\r\n      i2--\r\n  }\r\n  if (carry) res.push(carry)\r\n  return res.reverse()\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N)\r\n\r\n空间复杂度：O(1) 只保存了常量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300653737","body":"##### 思路\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\n##### 代码\n```js\nvar shortestToChar = function (S, C) {\n  let arr = [],\n    prevC = -Infinity,\n    map = [];\n  //清空暂存栈\n  function clear(prev, next = Infinity) {\n    for (const targetIndex of map) {\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\n      arr.push(Index);\n    }\n    map = [];\n  }\n  for (let index = 0; index < S.length; index++) {\n    const ele = S[index];\n    if (ele === C) {\n      clear(prevC, index);\n      arr.push(0);\n      prevC = index;\n    } else {\n      map.push(index);\n    }\n  }\n  if (map.length > 0) {\n    clear(prevC);\n  }\n  return arr;\n};\n```\n##### 复杂度\n时间复杂度：$O(N)$, N 为S数组长度。\n空间复杂度：$O(N)$, N 为S数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301521004","body":"#### 思路\r\n两种做法:\r\n- 常规遍历\r\n- 运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈\r\n\r\n#### 复杂度\r\n\r\n1. 常规遍历\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2.  辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n\r\n```\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303300530","body":"### 思路\r\n循环 + 栈\r\n- 遇到字母块 (lz)、数字时，入栈；\r\n- 遇到 [ 时，入栈，用来标识当前进入一个模板解析了；\r\n- 遇到 ] 时，说明当前模板遍历完了，我们可以开始解析了。**开始出栈**，把出栈的字母块都拼接起来，等出栈到 [ 时，说明当前模板解析完成了。**继续出栈一个元素，这个元素就是当前模板要重复的次数**，**把\"字母块 * 次数\"后推入栈中**。之所以要推入栈中是因为模板是可以嵌套的，当前模板的外层可以还是一个模板，所以我们要把结果放回去，继续解析外层的模板。\r\n### 代码\r\n```\r\n\r\n/*\r\n * @lc app=leetcode.cn id=394 lang=javascript\r\n *\r\n * [394] 字符串解码\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function (s) {\r\n  const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n  const stack = [];\r\n  const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\r\n\r\n  while (reg.lastIndex < s.length) {\r\n      let token = reg.exec(s)[0];\r\n      if (token !== ']') {\r\n          // 数字，字母，左括号通通入栈\r\n          stack.push(token);\r\n      } else {\r\n          // 遇到右括号就开始出栈\r\n          let str = '';\r\n          // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n          while (peek() !== '[') {\r\n              str = stack.pop() + str;\r\n          }\r\n          // 丢掉左括号\r\n          stack.pop();\r\n          // 左括号前面的一定是模式重复的次数\r\n          const num = +stack.pop();\r\n          // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n          stack.push(str.repeat(num));\r\n      }\r\n  }\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(S)$，S 是解析后字符串的长度。\r\n空间复杂度：$O(S)$，S 是解析后字符串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304537012","body":"\n\n#### 思路\ninStack: 写栈，入队列时存储数据于此\n\noutStack：出栈，需要出队列时将inStack的数据依次出栈后入栈到此；出栈的尾部就是入栈的头部，因而出队列就是出栈的尾部，直接pop\n\n**注意:**: 栈2为空才能补充栈1的数据，否则会打乱当前的顺序。\n\n#### 复杂度\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\n时间复杂度：O(N)，其中 N 为 栈中元素个数，因为每次我们都要倒腾一 次。\n\n\n空间复杂度：O(N)，其中 N 为 栈中元素个数，多使用了一个辅助栈，这 个辅助栈的大小和原栈的大小一样。\n\n\n\n#### 代码\n```js\nvar MyQueue = function () {\n    this.inStack = [];\n    this.outStack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (this.outStack.length === 0) {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (this.outStack.length === 0) {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack[this.outStack.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\nreturn this.outStack.length===0 && this.inStack.length===0\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304806767","body":"### 768 最多能完成的排序块\r\n\r\n#### 思路\r\n\r\n后面块中的最小值一定大于前面块的最大值,这样才能保证分块有（即局部递减，整体递增）。因此直观上，我们又会觉得是不是”只要后面有较小值，那么前面大于它的都应该在一个块里面“，实际上的确如此。 因而这里，栈只需要保存该块中最大值就可以了。（将一个减序列压缩合并成最该序列的最大的值）\r\n\r\n#### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n\r\n  const stack=[];\r\n  for (const ele of arr) {\r\n    const cur=stack[stack.length-1]\r\n    if(stack.length>0 &&  cur>ele){\r\n      while(stack.length>0 && stack[stack.length-1] > ele){\r\n        stack.pop();\r\n      }\r\n      stack.push(cur)\r\n    }else{\r\n      stack.push(ele)\r\n    }\r\n  }\r\n  return stack.length\r\n};\r\n```\r\n\r\n\r\n\r\n#### 复杂度\r\n\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305786315","body":"#### 思路\n快指针比慢指针先走K步，当快指针到达终点时，慢指针正好是倒数第 k 个节点\n\n需要先求出链表的长度，再取余得到K\n\n一开始是想循环K遍(链表遍历结束就再从头遍历，但当K足够大时，遍历的次数可能超过2次，以及求倒数K个节点循环终止条件是遍历到链表尾部，此时K为负数，这里遍历过一遍后K可能为正数，需要修改终止条件)\n\n#### 代码\n```js\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0,\n    now = head;\n  while (now) {\n    now = now.next;\n    count++;\n  }\n  k = k % count;\n  let slow = (fast = head);\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n时间复杂度：节点最多只遍历两遍，时间复杂度为O(n)\n空间复杂度：未使用额外的空间，空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307079233","body":"##### 思路\n\n由于所有的两两交换逻辑都是一样的，因此我们**只要关注某一个两两交换**如何实现就可以了。\n\n因为要修改的是二个一组的链表节点，所以需要**操作 4 个节点**。例如：**将链表 A -> B 进行逆转，我们需要得到 A,B 以及 A 的前置节点 preA,以及 B 的后置节点 nextB**\n\n原始链表为 **preA -> A -> B -> nextB**，我们需要改为 **preA -> B -> A -> nextB**，接下来用同样的逻辑交换 nextB 以及 nextB 的下一个元素。\n\n这里的preA节点是我们创建一个空节点 preHead，让其 next 指针指向 A\n\n修改指针的顺序：\n\n1. A 节点的 next 指向 nextB:  \n\n   > 注意：不用更新nextB的指向，而是更新指向它的指针)\n\n2. B 节点的 next 指向 A\n\n3. preA 节点的 next 指向 B \n\n4. 修改preA节点和A节点，进入下一次循环\n\n##### 代码\n\n```\n/*\n * @lc app=leetcode.cn id=24 lang=javascript\n *\n * [24] 两两交换链表中的节点\n */\nfunction ListNode(val, next) {\n       this.val = (val===undefined ? 0 : val)\n      this.next = (next===undefined ? null : next)\n   }\n\n   function arrayToNodeList(list) {\n    let header = new ListNode(0)\n    let Arent = header\n    for (let i = 0; i < list.length; i++) {\n      Arent.next = { val: list[i], next: null }\n      Arent = Arent.next\n    }\n    return header.next\n  }\n  function nodeListToArray(node) {\n    const list = []\n    let header = node\n    while (header) {\n      list.push(header.val)\n      header = header.next\n    }\n    return list\n  }\n  \n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n     if(!head||!head.next) return head\n     let A=head,res=head.next;\n     let prevA = new ListNode();\n      prevA.next = head;\n\n     while(A && A.next){\n      const B = A.next,nextB=B.next;\n      A.next=nextB\n      B.next=A\n      prevA.next=B\n      prevA=A\n      A=A.next\n     }\n     return res\n};\n// @lc code=end\n\nswapPairs(arrayToNodeList([1,2,3,4]))\n```\n\n##### 复杂度分析\n\n- 时间复杂度：O(N)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作.\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308970652","body":"#### 思路\n- 快慢指针找到中间节点+递归+构建树结构。 \n- 链表中间节点就是根节点，根节点的左节点就是链表左边一段的中间节点\n\n#### 代码\n```js\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```\n#### 复杂度分析\n\n令 n 为链表长度。\n\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\n\n空间复杂度：空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310337400","body":"#### 思路\n哈希法:(摘自讲义)\n有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。\n遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\n\n#### 代码\n\n```\nvar getIntersectionNode = function(A, B) {\nlet data = new Set();\nwhile (A !== null) {\n  data.add(A);\n  A = A.next;\n}\nwhile (B !== null) {\n  if (data.has(B)) return B;\n  B = B.next;\n}\nreturn null;\n};\n```\n\n#### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311295223","body":"#### 双指针\n\n具体算法：\n\n定义一个 fast 指针,每次前进两步,一个 slow 指针,每次前进一步\n\n当两个指针相遇时(注意相遇不一定就相遇在环入口)，将 fast 指针重定位到链表头部,同时 fast 指针每次只前进一步，slow 指针继续前进,每次前进一步\n\n当两个指针再次相遇时,当前节点就是环的入口\n\n\n##### 代码\n```js\nif (head == null || head.next == null) return null;\nlet fast = (slow = head);\ndo {\n  if (fast != null && fast.next != null) {\n    fast = fast.next.next;\n  } else {\n    fast = null;\n  }\n  slow = slow.next;\n} while (fast != slow);\nif (fast == null) return null;\nfast = head;\nwhile (fast != slow) {\n  fast = fast.next;\n  slow = slow.next;\n}\nreturn fast;\n\n```\n##### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312509277","body":"**思路**\n\n哈希表+双向链表\n\n题目要求操作的复杂度都是O(1)，链表本身插入和删除都能做到，但查找不行，因而需要结合哈希表来记录每个 key 对应的链表节点引用 ( 空间复杂度增加到了 O(N) )。另外，由于**移除链表节点后还需要把该节点前后的两个节点连起来**,所以这里需要用双向链表\n\n**代码**\n\n```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：各种操作平均都是 O(1)。\n- 空间复杂度：链表占用空间 O(N)，哈希表占用空间也是 O(N)，因此总的空间复杂度为 O(N)，其中 N 为容量大小，也就是题目中的 capacity。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312629335","body":"#### 思路\n  用层次遍历bfs+变量i记录遍历的深度\n\n#### 代码\n```js\nvar maxDepth = function (root) {\n  if(!root) return 0;\n  let quene = []\n  quene.push(root)\n  let i = 0\n  while (quene.length) {\n      let curLevel = quene\n      quene = [];\n      i++;\n      for (let i = 0; i < curLevel.length; i++) {\n          if (curLevel[i].left) {\n              quene.push(curLevel[i].left)\n          }\n          if (curLevel[i].right) {\n              quene.push(curLevel[i].right)\n          }\n      }\n  }\n return i;\n};\n```\n#### 复杂度\n时间复杂度：O(N)，其中 N 为节点数。\n\n空间复杂度：O(h)，其中 h 为树的深度，最坏的情况 h 等于 N，其中 N 为节点数，此时树退化到链表。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313757656","body":"#### 思路\n\n判断两棵树是否相同，只需要判断树相同位置的元素值是否相同。可以借助队列实现**层次遍历**，每次拿到两个节点时比较，注意当两个节点都为null时不能返回true( 因为还不一定),只能暂停这次循环，进行下一次。 如果不一致，直接返回 false。如果访问完都没有发现不一致就返回 true。\n\n#### 代码\n\n```js\nfunction isSameTree(p, q) {\n  let queueA = [];\n  queueA.push(p);\n  queueA.push(q);\n  while (queueA.length) {\n    const p = queueA.shift(),\n      q = queueA.shift();\n    if (p == null && q == null) {\n      continue;\n    }\n    if (p == null || q == null || p.val != q.val) {\n      return false;\n    }\n    queueA.push(p.left);\n    queueA.push(q.left);\n\n    queueA.push(p.right);\n    queueA.push(q.right);\n  }\n  return true;\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N)，其中 N 为树的节点数。\n空间复杂度：O(Q)，其中 Q 为队列的长度最大值，在这里不会超过相邻两层的节点数的最大值。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315478613","body":"#### 深度优先递归DFS\n**思路**\n\n- 题目求的是根到叶子节点的值，所以只要在叶子节点这一层把每条路径的值按倍数加起来并求和就行。\n- 代码什么时候会跑到叶子节点呢？节点没有左子树和右子树的时候。\n- 这里还需要注意函数参数root可能是null,要判空\n\n**代码**\n```JS\nvar sumNumbers = function(root) {\n    return sumHelper(root, 0)\n};\n\nfunction sumHelper(root, sum){\n    if (!root) return 0;\n    const total = sum * 10 + root.val;\n    if (!root.left && !root.right) {\n        return total;\n    } else {\n        return sumHelper(root.left, total) + sumHelper(root.right, total);\n    }\n}\n\n\n```\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n#### BFS\n\n\n**思路**\n\n- 跟DFS思路一致，等到遍历到叶子节点的时候再把对应值加起来，不同的是这里把中间每一层对应的值都求出来\n\n**代码**\n```JS\nfunction sumNumbers(root) {\n  let sum = 0;\n  let curLevel = [];\n  if (root) {\n    curLevel.push(root);\n  }\n  while (curLevel.length) {\n    let nextLevel = [];\n    for (let i = 0; i < curLevel.length; i++) {\n      let cur = curLevel[i];\n      if (cur.left) {\n        cur.left.val = cur.val * 10 + cur.left.val;\n        nextLevel.push(cur.left);\n      }\n      if (cur.right) {\n        cur.right.val = cur.val * 10 + cur.right.val;\n        nextLevel.push(cur.right);\n      }\n      if (!cur.left && !cur.right) {\n        sum += cur.val;\n      }\n      curLevel = nextLevel;\n    }\n  }\n  return sum;\n}\n\n```\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317160733","body":"#### BFS\r\n\r\n**思路**\r\n\r\n- 只要记录每层最左边的节点值，遍历结束拿到的就是最后一层。\r\n\r\n- 这里有个知识点是内循环一次就是遍历一层节点，外循环的次数取决于树的层数，所以记录都是在每次内循环结束后操作。\r\n\r\n  \r\n\r\n  **代码**\r\n\r\n```\r\nvar findBottomLeftValue = function (root) {\r\n  let curLevel = [root];\r\n  let res = root.val;\r\n  while (curLevel.length) {\r\n    let nextLevel = [];\r\n    for (let i = 0; i < curLevel.length; i++) {\r\n      curLevel[i].left && nextLevel.push(curLevel[i].left);\r\n      curLevel[i].right && nextLevel.push(curLevel[i].right);\r\n    }\r\n    res = curLevel[0].val;\r\n    curLevel = nextLevel;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为树的节点数。\r\n- 空间复杂度：O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树，此时和 N 同阶，其中 N 为树的节点总数\r\n\r\n#### DFS\r\n\r\n**思路**\r\n\r\n- 递归方法需要一个参数表示当前遍历到的层级以及一个变量记录当前最深的层级的值\r\n- 如何保证是左下角，而不是右下角呢，这里是利用遍历的方法都是先遍历左结点而后右节点来保证的。所以前中后序遍历都可以。\r\n\r\n```\r\n function findBottomLeftValue(root) {\r\n  let res = root.val, maxDepth = 0;\r\n  order(root.left,1)\r\n  order(root.right,1)\r\n  return res\r\n  function order(root, depth) {\r\n      if (!root) return;\r\n      if (depth > maxDepth) {\r\n          maxDepth=depth;\r\n          res = root.val;\r\n      }\r\n      order(root.left, depth + 1)\r\n      order(root.right, depth + 1)\r\n  }\r\n\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为树的节点总数。\r\n- 空间复杂度：O(h)，其中 h 为树的高度。\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318816048","body":"\n**思路**\n\nBFS\n\n**代码**\n```JS\nconst serialize = (root) => {\n  const queue = [root];\n  let res = [];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      res.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      res.push(\"#\");\n    }\n  }\n  return res.join(\",\");\n};\n\nconst deserialize = (data) => {\n  if (data == \"#\") return null;\n\n  const list = data.split(\",\");\n\n  const root = new TreeNode(list[0]);\n  const queue = [root];\n  let cursor = 1;\n\n  while (cursor < list.length) {\n    const node = queue.shift();\n\n    const leftVal = list[cursor];\n    const rightVal = list[cursor + 1];\n\n    if (leftVal != \"#\") {\n      const leftNode = new TreeNode(leftVal);\n      node.left = leftNode;\n      queue.push(leftNode);\n    }\n    if (rightVal != \"#\") {\n      const rightNode = new TreeNode(rightVal);\n      node.right = rightNode;\n      queue.push(rightNode);\n    }\n    cursor += 2;\n  }\n  return root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为树的节点数。\n\n- 空间复杂度：O(Q)，其中 Q 为队列长度，最坏的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320160931","body":"**思路**\n  先存着，再根据y,x，val做排序\n**代码**\n```js\n var verticalTraversal = function (root) {\n  const res = new Map([[0, [[root.val]]]])\n  proder(root.left, 1, -1)\n  proder(root.right, 1, 1)\n\n  function proder(node, row, col) {\n    if(!node) return;\n      const arr = res.get(col) || []\n      arr[row] = [...(arr[row] || []), node.val]\n      res.set(col, arr)\n      node.left && proder(node.left, row + 1, col - 1)\n      node.right && proder(node.right, row + 1, col + 1)\n  }\n  const newLocal = [...res].sort(([a], [b]) => (a - b));\n  const result = newLocal.reduce(function (total, [cur, arr]) {\n      const items = arr.map(item => item.sort((a, b) => a - b)).flat()\n      total.push(items)\n      return total;\n  }, [])\n  return result;\n};\n```\n**复杂度**\n- 时间复杂度：O(NlogN)，其中 N 为树的节点总数。\n- 空间复杂度：O(N)，其中 N 为树的节点总数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320791332","body":"### 思路\n用哈希表记录已经出现过的元素，遍历循环时判断 target - num 是否也存在 哈希表中\n### 代码\n```js\nvar twoSum = function(nums, target) {\n  const hash=new Map()\nfor (const i in nums) {\n  const jian=target-nums[i]\n  if(hash.has(jian)){\n    return [hash.get(jian),i]\n  }\n  hash.set(nums[i],i)\n}\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321087052","body":"#### 快速选择\r\n**思路**\r\n\r\n>基本流程如下：\r\n>\r\n>1. 首先选定一个轴心值 `p`。\r\n>2. 将数组中小于 `p` 的值移到数组左端，其他移动到数组右端。\r\n>3. 计算轴心左端的数 (包括轴心自己) 有多少，记为 `count`\r\n>4. 如果 `count` 正好为 `k`，则返回此时轴心值，此值即为第 `k` 小的数。\r\n>5. 如果左端的数 `count` 大于 `k`，说明在左端，所以只递归左边即可。\r\n>6. 如果不在左端，只递归在右边寻找。\r\n\r\n**代码**\r\n\r\n```js\r\n//\r\nvar topKFrequent = function (nums, k) {\r\n  const counts = {};\r\n  for (let num of nums) {\r\n    counts[num] = (counts[num] || 0) + 1;\r\n  }\r\n  // 【次数，值】\r\n  let pairs = Object.keys(counts).map((key) => [counts[key], key]);\r\n\r\n  select(0, pairs.length - 1, k);\r\n  return pairs.slice(0, k).map((item) => item[1]);\r\n\r\n  // 快速选择\r\n  function select(left, right, offset) {\r\n    if (left >= right) {\r\n      return;\r\n    }\r\n    const pivotIndex = partition(left, right);\r\n    if (pivotIndex === offset) {\r\n      return;\r\n    }\r\n\r\n    if (pivotIndex <= offset) {\r\n      select(pivotIndex + 1, right, offset);\r\n    } else {\r\n      select(left, pivotIndex - 1,offset);\r\n    }\r\n  }\r\n\r\n  // 拆分数组为两个part\r\n  function partition(left, right) {\r\n    const [pivot] = pairs[right];\r\n    let cur = left;\r\n    let leftPartIndex = left;\r\n    while (cur < right) {\r\n      if (pairs[cur][0] > pivot) {\r\n        swap(leftPartIndex++, cur);\r\n      }\r\n      cur++;\r\n    }\r\n    swap(right, leftPartIndex);\r\n    return leftPartIndex;\r\n  }\r\n\r\n  function swap(x, y) {\r\n    const term = pairs[x];\r\n    pairs[x] = pairs[y];\r\n    pairs[y] = term;\r\n  }\r\n};\r\n```\r\n\r\n**复杂度**\r\n\r\n- 时间复杂度: O(N), 最坏能到 O(N^2)\r\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321292094","body":"### 思路\n\n哈希表可以用于优化暴力算法。\n\n- **使用哈希表预处理点信息**：第一层循环固定取一个点，并且找出所有和点 A 距离相同的点（统计频率的套路，将距离作为哈希表的key值，相同加一）。\n\n- **n 个数取两个数的全排列种类是 {A}_n^2，也就是 n*(n-1)**。比如找到了 n 个距离为 3 的点，那么我们选择第二个点有 n 种方案，选择第三个点有(n - 1)个方案。那么固定点 A 且距离为 3 的所有可能就是 n*(n-1)种，\n\n\n\n\n### 代码\n\n```\nfunction numberOfBoomerangs(points) {\n    let ans = 0\n    for (let i = 0; i < points.length; i++) {\n        let map = {}\n        for (let j = 0; j < points.length; j++) {\n            let instance = getTance(points[i], points[j])\n            map[instance] =  map[instance] ? ++map[instance] : 1\n        }\n        for (const key in map) {\n            ans += map[key] * (map[key] - 1)\n        }\n    }\n    return ans\n}\n// 求距离，可以不用开平方根\nvar getTance = function (point1, point2) {\n    return Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2)\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n\n- 空间复杂度：O(N)\n\n  \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323556372","body":"\r\n思路：滑动窗口+哈希表\r\n\r\n- 维护一个滑动窗口，当窗口中的字符不重复时，继续向右扩大窗口。\r\n- 当遇到重复字符 `d` 时，将窗口左侧收缩到 `d` 字符上次出现的位置 + 1（将起始位置**右移至重复字符的后一个位置**）。\r\n- 为了快速找到字符上次出现的位置，我们可以用一个哈希表来记录每个字符最新出现的位置。\r\n- 在滑动窗口遍历数组的过程中用一个变量记录窗口的最大长度。\r\n\r\n**代码**\r\n\r\n```js\r\n let lengthOfLongestSubstring = function (s) {\r\n  if (!s) return 0;\r\n  let l = 0,\r\n    max = 0;\r\n  const map = new Map();\r\n  for (let i = 0; i < s.length; i++) {\r\n    const index = map.get(s[i]);\r\n    // 如果 s[i] 曾在 [l, r] 滑动窗口中出现\r\n    // 就收缩滑动窗口左侧，把 l 指针移动到 s[i] 上次出现的位置 + 1\r\n    if (index >= l) l = index + 1;\r\n    // 更新 s[r] 出现的位置\r\n    map.set(s[i], i);\r\n    // 计算滑动窗口大小\r\n    max = Math.max(max, i - l + 1);\r\n  }\r\n  return max;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度: O(n)，n为字符串长度\r\n- 空间复杂度：O(s)，s为字符集元素个数\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324932028","body":"**思路**\r\n\r\n- 题目给的words是可以有重复项的，所以要用哈希表map1记录每项出现的次数。\r\n- 遍历s,取出子串为words.length*words[0].length(目标子串的长度),按words[0].length长度切割，用map2记录单词出现的次数，一旦次数超过map1或者单词并不存在map1中时，说明这次遍历的子串不满足条件，提前break;\r\n- 没有提前break的子串就是符合条件的，怎么获取这部分呢？可以通过判断for循环的变量是否等于循环的次数。\r\n**代码**\r\n```js\r\nvar findSubstring = function (s, words) {\r\n  const res = [], wordsLen = words[0].length, resLen = wordsLen * words.length;\r\n  let map = words.reduce((totalMap, cur) => {\r\n      totalMap.set(cur, (totalMap.get(cur) || 0) + 1)\r\n      return totalMap\r\n  }, new Map())\r\n  let r = 0;\r\n  while (r < s.length - resLen + 1) {\r\n      let mapT = new Map()\r\n      const curTotalStr = s.slice(r, r + resLen)\r\n      let i = 0\r\n      for (; i < resLen; i += wordsLen) {\r\n          const curStr = curTotalStr.slice(i, i + wordsLen)\r\n          if (!map.has(curStr)) break;\r\n          mapT.set(curStr, (mapT.get(curStr) || 0) + 1)\r\n          if (map.get(curStr) < mapT.get(curStr)) break;\r\n      }\r\n      if (i == resLen) {\r\n          res.push(r)\r\n      }\r\n      r += 1\r\n  }\r\n  return res\r\n};\r\n```\r\n**复杂度**\r\n\r\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\r\n\r\n时间复杂度：O(m+w×n)\r\n空间复杂度： O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326610078","body":"\n**先导知识**\n\n> -  看到连续子数组就可以考虑用前缀和进行优化。\n>    前缀和: 子数组 A[i:j] 的和就是 pres[j] - pres[i-1]，其中 pres 为 A 的前缀和。\n> -  看到被 x 整除，求余数等问题都可以尝试考虑是否可以使用数学中的同余定理\n>    同余定理: 两个模 k 余数相同的数字相减，得到的值定可以被 k 整除。\n\n**思路**：\n\n- 以先计算出总体的数组和 total 模 k 的余数，记为 target，那么我们的目标就是找到一段模 k 等于 target 的子数组。\n\n- 连续子数组相加的值又会等于两个子数组前缀和相减。于是目标转为求\n(pres[j] - pres[i-1])% K = target，根据公式可推导出 (pres[j]-target)%K =pres[i-1]%K\n\n- 可以将前缀和模 k 的余数 x 放到哈希表中，这个哈希表就充当了前缀和的角色，来记录最新的余数 x 对应的下标，随着循环遍历，最新的下标对应的前缀和数组越长，连续子数组越短，所以需要哈希记录最新下标\n\n**代码**\n\n```js\n// 注：-1 % 4 为-1，而我们期望为 3，为了解决正负数求余统一，采用 Math.floorMod，等同于先+4 再模 4\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\n\nvar subarraysDivByK = function(nums, k) {\n  var map = new Map();\n  map.set(0, -1);\n  var res = nums.length;\n  var target = 0;\n  var currSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    target += nums[i];\n  }\n  target = target % k;\n\n  for (let i = 0; i < nums.length; i++) {\n    currSum = (nums[i] + currSum) % k;\n    map.set(currSum, i);\n    var prevSum = floorMod(currSum - target, k);\n    if (map.has(prevSum)) {\n      res = Math.min(res, i - )map.get(prevSum);\n    }\n  }\n  return res === nums.length ? -1 : res;\n};\n```\n**复杂度**\n时间：O(N)\n空间：O(min(K,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327343442","body":"### 思路\n\n快指针每次最两步，慢指针每次走一步，这样当快指针走到链表尾部的时候， 慢指针刚好到达链表中间位置。\n\n- 关于快慢节点求中点，如果以 head 为起点，则最后 slow 是在后面那个中间节点\n- **如果以 head 的前一个节点为起点，那么 slow 就会在前面的中间节点**\n\n### 代码\n\n```\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\n\nvar middleNode = function(head) {\n    let slow = head, fast = head;\n    while(fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return slow\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328044893","body":"**思路**\n\n读写指针，需要注意写的时机：即读指针跟当前写指针指向的下标前一个值不相同时\n\n**代码**\n\n```js\n var removeDuplicates = function(nums) {\n  let slow=1;\n  for (let fast = 1; fast < nums.length; fast++) {\n   if(nums[slow-1]!==nums[fast]) \n    {\n      nums[slow]=nums[fast]\n      slow++;\n    }\n  }\n  nums=nums.slice(0,slow)\nreturn nums.length\n};\n```\n\n**思路**\n\n - 时间复杂度：O(N)\n - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328247157","body":"**思路**\n\n寻找最左插入位置=寻找最右满足小于 x 的位置 + 1=找到满足值时收缩右边界\n\n**代码**\n\n```js\n  var searchLeft = function (nums, target) {\n    let l = 0, r = nums.length - 1;\n    while (l <= r) {\n        mid = Math.floor((l + r) / 2)\n        if (target <= nums[mid]) r = mid - 1 //收缩右边界\n        else l = mid + 1\n    }\n    return l\n};\n```\n\n复杂度\n\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329298997","body":"**思路**\n\n#### 双端队列\n\n用一个双端队列来保存`接下来的滑动窗口可能成为最大值的数`\n\n\n\n具体做法：\n\n- 入队列\n- 移除失效元素，失效元素有两种\n\n1. 一种是已经超出窗口范围了，比如我遍历到第 4 个元素，k = 3，那么 i = 0 的元素就不应该出现在双端队列中了。具体就是`索引大于 i - k + 1的元素都应该被清除`\n2. 小于当前元素都没有利用价值了，具体就是`从后往前遍历（双端队列是一个递减队列）双端队列，如果小于当前元素就出队列`\n\n经过上面的分析，不难知道双端队列其实是一个递减的一个队列，因此队首的元素一定是最大的。\n\n```js\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const dequeue = new Dequeue([]);\n  // 前 k - 1 个数入队\n  for (let i = 0; i < k - 1; i++) {\n    dequeue.push(nums[i]);\n  }\n\n  // 滑动窗口\n  for (let i = k - 1; i < nums.length; i++) {\n    dequeue.push(nums[i]);\n    res.push(dequeue.max());\n    dequeue.shift(nums[i - k + 1]);\n  }\n  return res;\n};\n\nclass Dequeue {\n  constructor(nums) {\n    this.list = nums;\n  }\n\n  push(val) {\n    const nums = this.list;\n    // 保证数据从队头到队尾递减\n    while (nums[nums.length - 1] < val) {\n      nums.pop();\n    }\n    nums.push(val);\n  }\n\n  // 队头出队\n  shift(val) {\n    let nums = this.list;\n    if (nums[0] === val) {\n      // 这里的js实现shift()理论上复杂度应该是O(k), 就不去真实实现一个O(1)出队的队列了，意思到位即可\n      nums.shift();\n    }\n  }\n\n  max() {\n    return this.list[0];\n  }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330601195","body":"https://leetcode-cn.com/problems/find-the-town-judge/solution/yi-ge-shu-zu-gao-ding-tong-su-yi-dong-997-zhao-dao/\n\n### 思路\n\n有向图问题。 法官👩‍⚖️ 实际上就是出度为0，入度为 N - 1的节点。\n\n- 统计所有人的入度和出度信息(两个数组分别记录)，将满足出度为0，入度为 N - 1的节点输出。\n- 一种是直接用一个数组记录入度和出度的差值\n\n### 代码\n\n\n```js\n// 一个数组\nvar findJudge = function (n, trust) {\n    if (n === 1 && !trust.length) return 1\n    const arr = new Array(n + 1).fill(0)\n    for (const point of trust) {\n        const [i, j] = point\n        arr[i] -= 1\n        arr[j] += 1\n    }\n    for (const i in arr) {\n        if (arr[i] === n - 1)\n            return i\n    }\n    return -1\n};\n\n// 两个数组\nvar findJudge = function (n, trust) {\n  const count = new Array(n + 1).fill(0);\n  for (const edge of trust) {\n    const x = edge[0];\n    const y = edge[1];\n    count[y]++;\n    count[x]--;\n  }\n  for (let i = 1; i <= n; ++i) {\n    if (count[i] === n - 1) {\n      return i;\n    }\n  }\n  return -1\n}\n```\n\n##### \n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332218881","body":"\n\nhttps://leetcode-cn.com/problems/possible-bipartition/\n\n## 关键点\n\n- 二分图\n- 染色法\n- 图的建立和遍历\n\n\n\n**思路**\n\n- 用邻接矩阵表示人物的喜欢关系， 不喜欢的两人坐标点都标记为1.即(a,b)和(b,a)\n- 用数组存储分组情况，值为0代表未分组，-1和1分别代表两个组。\n- **整个判断过程其实就是递归假设**：开始分组时，先假设将a分到1组，再遍历a不喜欢的人，看其是否能分到-1组（这个判断过程也是先假设人已分到-1组，不喜欢的人能否分到1组）\n- 若有人不满足假设过程，则跳出循环，返回false.\n\n```js\n const possibleBipartition = (N, dislikes) => {\n  let graph = [...Array(N)].map(() => Array()), // 动态创建二维数组\n    colors = Array(N + 1).fill(0);\n\n  // build the undirected graph\n  for (const [a, b] of dislikes) {\n    graph[a - 1][b - 1] = 1\n    graph[b - 1][a - 1] = 1\n  }\n\n  const dfs = (cur, color = 0) => {\n    colors[cur] = color;\n  for (let i = 0; i < N; i++) {\n    if(graph[cur][i]==1){\n      // 不喜欢的人在同个组，不符合题意，返回false\n       if(colors[i]==color) return false;\n      //不喜欢的人还未分组，但不能分到相反组，返回false\n       if(colors[i]===0 && !dfs(i, color*-1) ) return false\n  } \n}\n    return true;\n  };\n\n\n  for (let i = 0; i < N; ++i) if (colors[i] === 0 && !dfs(i, 1)) return false;\n\n  return true;\n};\n```\n\n- 时间复杂度：O(N2)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334814018","body":"**思路**\nso easy\n**代码**\n```js\nvar judgeCircle = function (moves) {\n  let p = [0, 0];\n  for (let i = 0; i < moves.length; i++) {\n    if (moves[i] === \"U\") p[0] += 1;\n    if (moves[i] === \"D\") p[0] -= 1;\n    if (moves[i] === \"L\") p[1] -= 1;\n    if (moves[i] === \"R\") p[1] += 1;\n  }\n  return p[0] === 0 && p[1] === 0;\n};\n```\n**复杂度**\n时间：O(n)\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298583857","body":"## 思路\r\n大模拟，注意进位和数比数组大的情况，处理边界\r\n\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n         int t = k % 10;\r\n         int f=0;\r\n         for(int i = num.size(); i > 0 && (k||f); i--){\r\n             t = k % 10;\r\n             k /= 10;\r\n             if(t+num[i-1]+f>=10){\r\n                 num[i-1]=(t+num[i-1]+f)%10;\r\n                 f=1;\r\n                 }\r\n                 else{\r\n                     num[i-1]=t+num[i-1]+f;\r\n                     f=0;\r\n                     }\r\n            }\r\n            // 对数字较长情况\r\n            if(k){               \r\n                while(k){\r\n                    num.emplace(num.begin(), (k%10+f)%10);\r\n                    if((k%10+f)>=10)f=1;\r\n                    else f=0;\r\n                    k/=10;\r\n                }\r\n            }\r\n            // 对首位进位情况\r\n            if(f){\r\n                 num.emplace(num.begin(), f);\r\n            }       \r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 时间为O(n）\r\n+ 空间为O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299885137","body":"### 思路\n\n记录出现的下标，对字符串的字符进行处理，相同为0，不同跟两头比，注意左右边界。\n\n### 代码\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        for(int i=0;i<s.length();i++){\n            if(c==s[i]){\n                ans.push_back(i);\n            }\n        }\n        vector<int> ansl;\n        int p=0,l=-1;\n        for(int i=0;i<s.length();i++){\n            if(p<ans.size() && i==ans[p]){\n                ansl.push_back(0);\n                l=p;\n                p++;                \n            }else if(p<ans.size() && l!=-1){                     \n                ansl.push_back(min(abs(i-ans[p]),abs(i-ans[l])));\n            }else if(p<ans.size() && l==-1){            \n                ansl.push_back(ans[p]-i);\n            }else if(p>=ans.size()){               \n                ansl.push_back(i-ans[l]);\n            }\n        }\n        return ansl;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301646705","body":"### 思路1\n模拟，应该用数组维护top，偷懒用的了vector\n\n### 代码1\n```c++\nclass CustomStack {\npublic:\n    vector <int> a;\n    int max;\n    CustomStack(int maxSize) {\n        max=maxSize;\n    }\n    \n    void push(int x) {\n        if(a.size()>=max){}\n        else{\n        a.push_back(x);}\n\n    }\n    \n    int pop() {       \n        if(a.empty())return -1;\n        int t=a.back();\n        a.pop_back();\n        return t;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<a.size();i++){\n            a[i]+=val;\n        }\n    }\n};\n```\n\n### 复杂度\n+ Time O(N)\n+ Space O(N)\n\n### 思路2\n维护一个add数组，因为只有pop的时候需要最终值，inc的时候记录增加值的位置，+=val，注意pop时这个值会影响到后面记得传递一位。\n使用top效率会更高，偷懒用了back()。\n\n### 代码2\n```c++\nclass CustomStack {\npublic:\n    vector <int> a, add;\n    int max;\n    CustomStack(int maxSize) {\n        max=maxSize;\n        //add.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if(a.size()>=max){}\n        else{\n        a.push_back(x);\n        add.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(a.empty())return -1;\n        int t=a.back();\n        a.pop_back();\n        t+=add.back();\n        int acc=add.back(); \n        add.pop_back();       \n        if(add.empty()){}\n        else{\n            add.back()+=acc;\n        }        \n        return t;\n    }\n    \n    void increment(int k, int val) {\n        int lim=k<a.size()?k:a.size();\n        if(lim>0){\n            if(k<a.size()){\n                add[k-1]+=val;\n            }else{\n                add.back()+=val;\n            }\n        } \n    }\n};\n```\n### 复杂度\n+ Time O(1)\n+ Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303772828","body":"### 思路\r\n模拟，第一次想错了，用一个栈装数一个栈装字母，结果处理不了嵌套后两个右半括号之间有字母的情况，一直企图缝缝补补，发现得记录数字和字母是否在同一级，企图每个栈里面加pair 的 int 修补。\r\n后看了题解，其实将数字和字母装进同一格即可，理论上pair修补也行，但不是正道。\r\n递归也可以做（编译原理）题解版本。\r\n### 代码 (误）\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string ans;\r\n        int l=0,r=0;\r\n        int ls=0,rs=0;\r\n        vector<pair<int,int>> num;\r\n        vector<pair<int,string>> str;\r\n        int endnum=-1;\r\n        int cnt=0;\r\n        int flag=-1; // -1初始，1 num，2 alpha,[ 3,] 4\r\n        for(int i=0;i<s.length();i++){\r\n            if(num.empty()&&isalpha(s[i])){\r\n                ans+=s[i];\r\n            }\r\n            if(isdigit(s[i])){\r\n                if(flag!=1){\r\n                    if(flag==2){                        \r\n                        rs=i;\r\n                        pair <int,string> pi;\r\n                        pi.first=cnt;\r\n                        pi.second=s.substr(ls,rs-ls);                        \r\n                        str.push_back(pi);\r\n                    }\r\n                    l=i;\r\n                    // cout<<l<<endl;\r\n                    flag=1;\r\n                }      \r\n            }else if(isalpha(s[i])){\r\n                if(flag!=2){                    \r\n                    ls=i;\r\n                    flag=2;\r\n                }\r\n            }else if(s[i]=='['){\r\n                r=i;\r\n                int ss=stoi(s.substr(l,r-l)); \r\n                pair<int,int> pp;\r\n                pp.first=cnt;\r\n                pp.second=ss;               \r\n                num.push_back(pp);\r\n                cnt++;                \r\n                ls=i+1;\r\n                flag=3;\r\n            }else if(s[i]==']'){ \r\n                cnt--;               \r\n                endnum=i;      \r\n                rs=i;\r\n                pair <int,int> ti;                \r\n                ti=num.back(); \r\n                int time=ti.second;              \r\n                num.pop_back();                    \r\n                if(!num.empty()){\r\n                    if(flag==4){                        \r\n                        string aa;\r\n                        string sstr=str.back().second;\r\n                        // str.pop_back();\r\n                        for(int j=0;j<time;j++){                    \r\n                            aa+=sstr;\r\n                        }\r\n                        string te=str.back().second;\r\n                        int tt=str.back().first;\r\n                        str.pop_back();\r\n                        cout<<te+aa<<endl;\r\n                        \r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=te+aa;\r\n                        str.push_back(ppp);\r\n                        ls=i+1;\r\n                    }else{\r\n                         \r\n                        string ss=s.substr(ls,rs-ls);                        \r\n                        string aa;\r\n                        // str.pop_back();\r\n                        \r\n                        for(int j=0;j<time;j++){                    \r\n                            aa+=ss;\r\n                        }\r\n                        // cout<<aa<<endl;\r\n                        string te=str.back().second;\r\n                        int ttt=str.back().first;\r\n                        str.pop_back();\r\n                        pair <int,string> ppp;\r\n                        ppp.first=ttt;\r\n                        ppp.second=te+aa;\r\n                        str.push_back(ppp);\r\n                    }\r\n                }\r\n                else{\r\n                    cout<<\"!!!!\"<<i<<endl;                   \r\n                    if(flag==4){\r\n                        string acc=str.back().second;\r\n                        int tt=str.back().first;\r\n                        str.pop_back();\r\n                        string str1;\r\n                        for(int j=0;j<time;j++){                    \r\n                            str1+=acc;\r\n                        }\r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=str1;\r\n                        str.push_back(ppp);\r\n                    }else{                                                                \r\n                        string ss=s.substr(ls,rs-ls);\r\n                        cout<<ss<<endl;\r\n                        cout<<cnt<<endl;\r\n                        string str1;\r\n                        for(int j=0;j<time;j++){                    \r\n                            str1+=ss;\r\n                        }\r\n                        \r\n                        string str2;\r\n                        if(!str.empty()){\r\n                            str2=str.back().second;\r\n                            int ttt=str.back().first;\r\n                            str.pop_back();\r\n                        }               \r\n                            // str.push_back(str2+ss);\r\n                        str1=str2+str1;\r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=str1;\r\n                        str.push_back(ppp);\r\n                        cout<<str1<<endl;                                            \r\n                    }                   \r\n                }\r\n                flag=4;       \r\n            }\r\n        }\r\n        // for(int i=0;i<num.size();i++){\r\n        //     cout<<num[i]<<endl;\r\n        // }\r\n        // for(int i=0;i<str.size();i++){\r\n        //     cout<<str[i]<<endl;\r\n        // }\r\n        ans=str.back().second;\r\n        if(endnum+1 < s.length()){\r\n            string endstr=s.substr(endnum+1,s.length()-endnum);\r\n            // cout<<endstr<<endl;\r\n            ans+=endstr;\r\n        }        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 代码\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        int ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                int i;\r\n                for(i=ptr;i<s.size()&&isdigit(s[i]);i++){}\r\n                string digits = s.substr(ptr,i);\r\n                ptr=i;\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 代码（递归）\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string src; \r\n    size_t ptr;\r\n\r\n    int getDigits() {\r\n        int ret = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            ret = ret * 10 + src[ptr++] - '0';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString() {\r\n        if (ptr == src.size() || src[ptr] == ']') {\r\n            // String -> EPS\r\n            return \"\";\r\n        }\r\n\r\n        char cur = src[ptr]; int repTime = 1;\r\n        string ret;\r\n\r\n        if (isdigit(cur)) {\r\n            // String -> Digits [ String ] String\r\n            // 解析 Digits\r\n            repTime = getDigits(); \r\n            // 过滤左括号\r\n            ++ptr;\r\n            // 解析 String\r\n            string str = getString(); \r\n            // 过滤右括号\r\n            ++ptr;\r\n            // 构造字符串\r\n            while (repTime--) ret += str; \r\n        } else if (isalpha(cur)) {\r\n            // String -> Char String\r\n            // 解析 Char\r\n            ret = string(1, src[ptr++]);\r\n        }\r\n        \r\n        return ret + getString();\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n};\r\n```\r\n### 复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466309","body":"### 代码\n``` c++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    vector<int> ans,vc;\n    int f;\n    MyQueue() {\n        f=-1;\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        if(vc.empty())f=x;\n        vc.push_back(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int t;  \n        if(ans.empty()){\n            while(!vc.empty()){\n                t=vc.back();\n                ans.push_back(t);\n                vc.pop_back();\n                printf(\"%d\\n\",t);\n            }\n        }      \n        \n        t=ans.back();               \n        ans.pop_back();//printf(\"!!!\\n\"); \n        if(!ans.empty())f=ans.back();\n        return t;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        return f;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return vc.empty()&&ans.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304751977","body":"### 思路 1\n计数，本来想开数组桶排序，有点大，就map，只要这一节和排好序的一节拥有同样元素的同样个数，既可作为一块。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int ans=0;\n        vector<int> s(arr);\n        map<int,int> m;\n        sort(s.begin(),s.end());\n\n        for(int i=0;i<arr.size();i++){\n            m[arr[i]]++;\n            m[s[i]]--;\n            if(m[arr[i]]==0){\n                m.erase(arr[i]);\n            }\n            if(m[s[i]]==0){\n                m.erase(s[i]);\n            }\n            if(m.size()==0){\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度\n+ 时间 O(nlogn)\n+ 空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305578695","body":"### 思路\n取余，双指针\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==NULL||k==0)return head;\n        int cnt=1;\n        ListNode* p=head;\n        while(p->next){\n            p=p->next;\n            cnt++;\n        }        \n        k%=cnt;        \n        k=cnt-k;\n        // cout<<cnt<<\" \"<<k<<endl;\n        if(cnt==k)return head;\n        ListNode* p1=head;\n        ListNode* p2;\n        for(int i=1;i<k;i++){\n            p1=p1->next;\n        }\n        p2=p1->next;\n        p->next=head;\n        p1->next=NULL; \n        return p2;\n    }\n};\n```\n\n### 复杂度\n+ 时间 O(n)\n+ 空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306776159","body":"### 思路\n仨指针循环倒腾，俩用来变节点，另一个用来连原来的，注意(p!=nullptr && p->next）前后顺序\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* p=head;\n        if(head==NULL||head->next==nullptr)return head;\n        ListNode*ans=head->next;\n        ListNode* p2=head;\n        while(p!=nullptr && p->next){            \n            ListNode* p1=p->next;\n            p2->next=p1;\n            cout<<p2->val<<endl;\n            p->next=p1->next;\n\n            p1->next=p;\n            p2=p;                        \n            p=p->next;\n        }\n        return ans;\n    }\n\n};\n```\n### 复杂度\n+ time o(n)\n+ space o(1)\n\n### 思路\n看题解还可以递归，出口是为null，否则递归返回值赋给head->next。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* p=head;\n        if(head==NULL||head->next==nullptr)return head;\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n### 复杂度\nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307530656","body":"### 思路\n递归分治，出口是头和尾指向一个，快慢指针找中间。 也可以全捋成数组，每次查找方便一点。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head,ListNode* tail=nullptr) {\n        if(head==tail)return nullptr;\n        ListNode* fast=head,*slow=head;\n        while(fast != tail && fast->next != tail){\n            fast=fast->next->next;\n            slow=slow->next;\n        }\n        TreeNode* node=new TreeNode(slow->val);\n        node->left=sortedListToBST(head,slow);\n        node->right=sortedListToBST(slow->next,tail);\n        return node;\n    }\n};\n```\n\n### 复杂度\n+ time O(nlogn)\n+ space O(logn)\n\n### 思路\n看了题解，中序加分治，比一般二分还要效率高一点。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int ret = 0;\n        for (; head != nullptr; ++ret, head = head->next);\n        return ret;\n    }\n\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode(head->val);\n        root->left = buildTree(head, left, mid - 1);\n        root->val = head->val;\n        head = head->next;\n        root->right = buildTree(head, mid + 1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int length = getLength(head);\n        return buildTree(head, 0, length - 1);\n    }\n};\n```\n\n### 复杂度\n+ time O(n) 因为子任务不是计数了，光比较\n+ space O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309892875","body":"### 思路\n双指针，第一趟做差，第二趟换位保持差，换个开头，继续往后数，因为保持差值，会在交汇点相遇。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p1=headA,*p2=headB;\n        while(p1!=nullptr&&p2!=nullptr){\n            if(p1==p2)return p1;\n            p1=p1->next;\n            p2=p2->next;            \n        }\n\n        if(p1==nullptr){\n            p1=headB;\n            while(p2!=nullptr){\n                p1=p1->next;\n                p2=p2->next;\n            }\n            p2=headA;\n            while(p1!=nullptr&&p2!=nullptr){\n                if(p1==p2)return p1;\n                p1=p1->next;\n                p2=p2->next;\n                \n            }\n        }else if(p2==nullptr){\n            p2=headA;\n            while(p1!=nullptr){\n                p1=p1->next;\n                p2=p2->next;\n            }\n            p1=headB;\n            while(p1!=nullptr&&p2!=nullptr){\n                if(p1==p2)return p1;\n                p1=p1->next;\n                p2=p2->next;\n                \n            }\n        }\n        return nullptr;\n    }\n};\n```\n简化后\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *f=headA;\n        ListNode *s=headB;\n        while(f!=s){\n            if(f==nullptr)f=headB;\n            else f=f->next;\n            if(s==nullptr)s=headA;\n            else s=s->next;\n        }\n        return f;\n    }\n};\n```\n\n### 复杂度\n+ time O(n)\n+ space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311483336","body":"### 思路\n快慢指针，第一次相遇时，快指针多跑n-1圈多，半个弧D，此时fast重置到head，步长为1，再次相遇时，自己走了直线部分L，由上次经验(L+C)*2=L+n(D+C)+c可推L=(n-1)*(C+D)+D,slow正好走的就是公式右半部分，二者在交汇处相遇。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head;\n        ListNode *fast=head;\n        int i=0;\n        if(fast!=nullptr&&fast->next!=nullptr && fast->next->next!=nullptr){\n            slow=slow->next;\n            fast=fast->next->next; \n        }else{\n            return NULL;\n        }\n        while(fast!=slow && fast!=nullptr && slow!=nullptr){\n            slow=slow->next;\n            if (fast != nullptr && fast->next != nullptr) {\n            fast=fast->next->next;       }\n            else{fast=nullptr;}     \n        }\n\n        if(fast==slow){\n            fast=head;\n            while(fast!=slow){\n                slow=slow->next;\n                fast=fast->next;  \n            }\n        }\n        return fast;\n    }\n};\n```\n简化\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *f=head,*s=head;\n        while(f!=nullptr&&f->next!=nullptr){\n            f=f->next->next;\n            s=s->next;\n            if(f==s){\n                f=head;\n            \n            while(f!=s){\n                f=f->next;\n                s=s->next;\n            }            \n            return f;}\n        }\n        return NULL;\n    }\n};\n```\n\n### 复杂度\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1311977214","body":"### 思路\r\n哈希表加链表，用list写了链表，哈希表里放key和索引指针，list里用pair放key和value，每次get和put时都需要对该节点更新，先在链表里erase，再尾巴上插入，哈希表中更新索引。\r\n使用begin()，更方便。\r\n\r\n### 代码\r\n```c++\r\nclass LRUCache {\r\npublic:\r\n    map<int, list<pair<int, int>>::iterator> m;\r\n    list<pair<int,int>> l;\r\n    int n;\r\n    int i=0;\r\n    LRUCache(int capacity) {\r\n        n=capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        int ans=-1;\r\n        if(m.count(key)){\r\n            ans=(*m[key]).second;\r\n            l.erase(m[key]);\r\n            l.push_back(make_pair(key,ans));\r\n            list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n            m[key]=ll;            \r\n        }return ans;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(m.count(key)){            \r\n            l.erase(m[key]);\r\n            l.push_back(make_pair(key,value));\r\n            list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n            m[key]=ll;\r\n        }else{\r\n          \r\n            if(i<n){\r\n                i++;\r\n                l.push_back(make_pair(key,value));\r\n                list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n                m[key]=ll;                \r\n            }else{\r\n                // cout<<l.size()<<endl;  \r\n                m.erase(l.front().first);            \r\n                l.pop_front();\r\n                // l.erase(l.begin());\r\n                l.push_back(make_pair(key,value));\r\n                list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n                m[key]=ll;\r\n            }            \r\n        }\r\n\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n简化\r\n```c++\r\nclass LRUCache {\r\npublic:\r\n    pair<int,int> pa;\r\n    list<pair<int,int>> l;\r\n    unordered_map<int, list<pair<int, int>>::iterator> mp;\r\n    int M=0;\r\n\r\n    LRUCache(int capacity) {\r\n        M=capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        pa=make_pair(key,-1);   \r\n        if(mp.count(key)){\r\n            pa.second=(*mp[key]).second;\r\n            l.erase(mp[key]);\r\n            l.push_front(pa);\r\n            mp[key]=l.begin();\r\n\r\n        }\r\n        return pa.second;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        pa=make_pair(key,value);\r\n        if(mp.count(key)){            \r\n            l.erase(mp[key]);\r\n            l.push_front(pa);\r\n            mp[key]=l.begin();\r\n        }\r\n\r\n\r\n        else{            \r\n            if(l.size()==M){\r\n                mp.erase(l.back().first);\r\n                l.pop_back();\r\n            }          \r\n            l.push_front(pa);\r\n            mp[key]=l.begin();\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\nO(1)\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312641783","body":"### 思路\n递归dfs\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr)return 0;\n        else{\n            int l=maxDepth(root->left);\n            int r=maxDepth(root->right);\n            return l<r?r+1:l+1;\n        }        \n    }\n};\n```\n\n### 复杂度\nO(n)\nO(hight)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312782443","body":"### 思路\ndfs 挨个比，出口俩空true，只有一个空false，值不同false，否则递归左右子树。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {       \n        if(p==nullptr && q==nullptr){\n            return true;\n        }else if(p==nullptr || q==nullptr){\n            return false;\n        }else if(p->val==q->val){\n            bool a=isSameTree(p->left,q->left);\n            bool b=isSameTree(p->right,q->right);\n            return a&&b;\n        }else{\n            return false;\n        }         \n    }\n};\n```\nor\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q) return true;\n        if(!p || !q) return false;\n        if((p->val == q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right))\n        return true;\n        else{\n            return false;\n        }       \n    }\n};\n```\n###\nO(n)\n\n### 思路\n看了官方题解 bfs\n其中可以使用异或，表示两者不同的情况，也就是一个null一个有值，也可以考虑使用非指针的与和或来表示只有一个不为空的情况。\n        if (!leftNode && !rightNode) {  //\n                continue;\n            }    \n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\n                return false;\n            }\n\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        } else if (p == nullptr || q == nullptr) {\n            return false;\n        }\n        queue <TreeNode*> queue1, queue2;\n        queue1.push(p);\n        queue2.push(q);\n        while (!queue1.empty() && !queue2.empty()) {\n            auto node1 = queue1.front();\n            queue1.pop();\n            auto node2 = queue2.front();\n            queue2.pop();\n            if (node1->val != node2->val) {\n                return false;\n            }\n            auto left1 = node1->left, right1 = node1->right, left2 = node2->left, right2 = node2->right;\n            if ((left1 == nullptr) ^ (left2 == nullptr)) {\n                return false;\n            }\n            if ((right1 == nullptr) ^ (right2 == nullptr)) {\n                return false;\n            }\n            if (left1 != nullptr) {\n                queue1.push(left1);\n            }\n            if (right1 != nullptr) {\n                queue1.push(right1);\n            }\n            if (left2 != nullptr) {\n                queue2.push(left2);\n            }\n            if (right2 != nullptr) {\n                queue2.push(right2);\n            }\n        }\n        return queue1.empty() && queue2.empty();\n    }\n};\n```\nor\n```c++\nclass Solution {\npublic:\n\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == NULL && q == NULL) return true;\n        if (p == NULL || q == NULL) return false;\n        queue<TreeNode*> que;\n        que.push(p);   //\n        que.push(q);  //\n        while (!que.empty()) {  //\n            TreeNode* leftNode = que.front(); que.pop();\n            TreeNode* rightNode = que.front(); que.pop();\n            if (!leftNode && !rightNode) {  //\n                continue;\n            }\n            //\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\n                return false;\n            }\n            que.push(leftNode->left);   //\n            que.push(rightNode->left); //\n            que.push(leftNode->right);  //\n            que.push(rightNode->right);  //\n        }\n        return true;\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315116320","body":"### 思路\n递归dfs，出口一个0一个叶子节点，其余相加。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root, int sum=0) {\n        if(root==nullptr)return 0;\n        else if(root->left==nullptr && root->right==nullptr)return sum*10+root->val;\n        else{\n            int a=sum*10+root->val; \n            return sumNumbers(root->left,a)+sumNumbers(root->right,a);\n        }\n    }\n};\n``` \n### \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316958916","body":"### 思路\ndfs\n维护一个最大深度的变量，记录每个节点的深度，如果当前节点深度比最大深度要大，则更新最大深度和结果项。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int curhi=-1;\n    void dfs(TreeNode* root, int hi, int& cur){\n        if(root==nullptr){\n            return;\n        }\n        hi++;\n        if(hi>curhi){\n            curhi=hi;\n            cur=root->val;               \n        }\n        dfs(root->left,hi,cur);\n        dfs(root->right,hi,cur);\n\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        int cur=root->val;\n        dfs(root, 0, cur);\n        return cur;\n    }\n};\n```\n\n### \nO(n)\n\n### 思路\n层序\n\n### 代码\n``` c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int ans=root->val;\n        list<TreeNode*> l;\n        l.push_back(root);\n        int deep=0;\n        while(!l.empty()){\n            deep++;\n            if(l.front()!=nullptr)ans=(l.front())->val;\n            int cnt=l.size();\n            while(cnt--){\n                TreeNode* p=l.front();\n                l.pop_front();\n                if(p->left)l.push_back(p->left);\n                if(p->right)l.push_back(p->right);\n            }\n            \n        }\n        return ans;\n    }\n};\n```\n###\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1321195226","body":"### 思路\r\n第一次写的时候，序列化用的bfs，反序列化用的完全二叉树下标dfs，导致有的样例过不了，因为左子树早就没有了少null给右子树，就改了都bfs，但vector超时样例50，改用list。\r\n\r\n```c++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        string ans;\r\n        if(root==nullptr)return \"\";\r\n        list<TreeNode*> q;\r\n        q.push_back(root);\r\n        while(!q.empty()){ \r\n            TreeNode* temp=q.front();\r\n            q.pop_front();\r\n            if(temp!= NULL){\r\n                ans+=to_string(temp->val)+\",\";\r\n                q.push_back(temp->left);\r\n                q.push_back(temp->right);\r\n            }\r\n            else{\r\n                ans+=\"null,\";\r\n            }\r\n        }\r\n        // cout<<ans<<endl;\r\n        return ans;\r\n    }\r\n\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        if(data.empty())return NULL;\r\n        // vector<string> res;\r\n        list<string> res;\r\n        char * strs = new char[data.length() + 1] ; \r\n\t    strcpy(strs, data.c_str()); \r\n        // char * strs=data;\r\n        char * d = new char[2];\r\n        string ss=\",\";\r\n\t    strcpy(d, ss.c_str());\r\n\r\n        // char * d=\",\";       \r\n\r\n        char *p = strtok(strs, d);\r\n\t    while(p) {\r\n\t\t    string s = p; //分割得到的字符串转换为string类型\r\n\t\t    res.push_back(s); //存入结果数组\r\n\t\t    p = strtok(NULL, d);\r\n\t    }\r\n        queue<TreeNode*> que;\r\n        if (res.front() == \"null\") return NULL;\r\n        TreeNode* root = new TreeNode(stoi(res.front()));\r\n        que.emplace(root);\r\n        res.pop_front();\r\n        while (!que.empty() && !res.empty()) {\r\n            TreeNode* cur = que.front();\r\n            que.pop();\r\n            if(res.front()!=\"null\"){\r\n                TreeNode* node1 = new TreeNode(stoi(res.front()));\r\n                cur->left=node1;\r\n                que.push(node1);\r\n            }\r\n            res.pop_front();\r\n            if(res.front()!=\"null\"){\r\n                TreeNode* node2 = new TreeNode(stoi(res.front()));\r\n                cur->right=node2;\r\n                que.push(node2);\r\n            }\r\n            res.pop_front();\r\n        }\r\n\r\n        // int ann=atoi(res[0].c_str());\r\n        // // cout<<res[3]<<endl;\r\n        // TreeNode* root=new TreeNode();\r\n        // root->val=ann;\r\n        // dfs(root,res,0);\r\n        return root;\r\n    }\r\n    // void dfs(TreeNode* root, vector<string> a,int ind){\r\n    //     // cout<<\":\"<<ind<<\" \"<<a[ind]<<endl;\r\n    //     if(a[ind]==\"null\"){return;}\r\n    //     else{\r\n    //         int size=a.size();\r\n    //         if(size>2*ind+1){\r\n    //             if(a[2*ind+1]!=\"null\"){\r\n    //                 int aaa=atoi(a[2*ind+1].c_str());\r\n    //             TreeNode* tl=new TreeNode();\r\n    //             tl->val=aaa;\r\n    //             root->left=tl;dfs(root->left,a,2*ind+1);\r\n    //             }\r\n                \r\n    //         }if(size>2*ind+2){\r\n    //             if(a[2*ind+2]!=\"null\"){\r\n    //                 int aal=atoi(a[2*ind+2].c_str());\r\n    //             TreeNode* tr=new TreeNode();\r\n    //             tr->val=aal;\r\n    //             root->right=tr;dfs(root->right,a,2*ind+2);\r\n    //             }                \r\n    //         }\r\n    //         // cout<<aaa<<\" \"<<aal<<endl;\r\n    //     }\r\n    // }\r\n    \r\n};\r\n\r\n### \r\nO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319818224","body":"### 思路\n遍历时记录row，col，将其排序，优先级分别是l，r，val。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    typedef struct{\n        int val;\n        int r;\n        int l;\n    }treeno;\n    \n    static bool cmp(treeno a,treeno b)\n    {\n        if(a.l<b.l)return true;\n        else if(a.l==b.l){\n            if(a.r<b.r)return true;\n            else if(a.r==b.r){\n                return a.val<b.val;\n            }\n            else{\n                return false;\n            }\n        }\n        else{\n            return false;\n        }     \n    }\n    vector<treeno> temp;\n    int dfs(TreeNode* root,int r,int l){\n        if(root==nullptr)return 0;        \n        else{\n            treeno st;\n            st.val=root->val;\n            st.r=r;\n            st.l=l;\n            temp.push_back(st);\n            dfs(root->left,r+1,l-1);\n            dfs(root->right,r+1,l+1);\n            return 1;\n        }\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> ans;\n        vector<int> t;       \n        dfs(root,0,0);\n        sort(temp.begin(),temp.end(),cmp);\n        int index=temp.front().l;\n        for(int i=0;i<temp.size();i++){\n            if(index==temp[i].l){\n                t.push_back(temp[i].val);\n            }\n            else{\n                index=temp[i].l;\n                ans.push_back(t);\n                t.clear();\n                i--;\n            }\n            // cout<<temp[i].val<<\" \";\n        }\n        ans.push_back(t);\n        return ans;\n    }  \n};\n```\n\n###\nO(nlogn）\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320880971","body":"### 思路\n哈希\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> ans;\n        unordered_map<int,int> map;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            if(map.count(target-nums[i])){\n                return {i,map[target-nums[i]]};\n            }\n            else{\n                map[nums[i]]=i;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321055990","body":"### 思路\nmap+优先队列\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        vector<int> ans;\n        map<int,int> m;\n        for(int i=0;i<nums.size();i++){\n            if(m.count(nums[i])){\n                m[nums[i]]++;\n            }else{m[nums[i]]=1;}\n        }\n        map<int, int>::iterator iter;\n        iter = m.begin();\n        priority_queue<pair<int, int>> a;\n        pair<int, int> b;\n        while(iter != m.end()) {\n            b.first=iter->second;\n            b.second=iter->first;\n            a.push(b);\n            iter++;\n        }\n        while (!a.empty()&&k) \n        {\n            ans.push_back(a.top().second);\n            // cout << a.top().first << ' ' << a.top().second << '\\n';\n            a.pop();k--;\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度\nO(N  logK)\nO(N)\n\n快排选前k也行","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322173931","body":"### 思路\n遍历 hash\n第一回的时候考虑自身重复少算了一半，从i=j开始的，wa了，计算是（m-1+1）*（m-1）/2 * 2。\n\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans;\n        int size=points.size();\n        unordered_map<int,int> m;\n        for(int i=0;i<size;i++){\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tint dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\n                m[dis]++;\n\t\t\t}\n            for(auto it:m){\n\t\t\t\tans+=(it.second*(it.second-1));\n             //   cout<<it.first<<' '<<it.second<<endl;\n\t\t\t}\n            m.clear();\n            \n\t\t}\n        return ans;\n     }\n};\n```\n### \nO(n^2)\nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323660866","body":"### 思路\n双指针滑动窗口+hash\n注意边界处理\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size()==0)return 0;\n        int l=0,r=0;\n        map<char,int> m;\n        int mx=1;\n        while(l!=s.size() && r!=s.size()){            \n            if(m.count(s[r])){\n                cout<<m[s[r]]<<endl;\n                int t=m[s[r]]+1;                \n                for(int i=l;i<m[s[r]];i++){\n                    m.erase(s[i]);\n                }                \n                l=t;\n            }            \n            m[s[r]]=r;\n            mx=max(mx,r-l+1);                      \n            r++;            \n        }\n        return mx;\n    }\n};\n```\n\n###\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324884010","body":"### 思路\n暴力，俩hash，第一回超时了，修改了循环的终值。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> ans;\n        int n=s.length();\n        int wordn=words[0].size();\n        int m=words.size();\n        map<string, int> mp;\n        for(int i =0;i<m;i++){\n            mp[words[i]]++;\n        }\n        for(int i=0;i<=n-m*wordn;i++){\n            string temp=s.substr(i,m*wordn);\n            int k=0;\n            int cnt=0;\n            map<string, int> tmp;\n            for(k=0;k<m*wordn;k+=wordn){    \n                // cout<<temp.substr(k,wordn)<<endl;\n                if(!mp.count(temp.substr(k,wordn))){\n                    break;\n                }else{\n                    tmp[temp.substr(k,wordn)]++;\n                    if(tmp[temp.substr(k,wordn)]>mp[temp.substr(k,wordn)]){\n                        break;\n                    }                    \n                    cnt++;\n                }\n            }\n            if(k<m*wordn){\n            }else{\n                if(cnt==m){\n                    ans.push_back(i);\n                }\n                \n            }\n        }\n        return ans;\n    }\n};\n``` \n\n###\nO(n∗m∗k)\nO(m+n)空间复杂度是哈希表的长度，不知道需不需要乘以哈希表的每个单位长度。\n\n### 思路\n滑动窗口，不枚举了，右边扩张左边收缩，利用上回的信息。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        if (words.size() == 0) return {};\n        unordered_map<string, int> need, window;\n        \n        for (string w : words) need[w]++;\n        int len=words[0].length();\n        \n        int left = 0, right = 0;\n        int valid = 0;\n        vector<int> res; // 记录结果\n        int i=0;\n        while(i<len){\n            left=i++;\n            right=left;\n            window.clear();valid = 0;\n            while (right < s.size()) {\n            string c = s.substr(right,len);\n            // cout<<c<<endl;\n            right+=len;\n            // 进行窗口内数据的一系列更新\n            if (need.count(c)) {\n                window[c]++;\n                // right+=len;\n                if (window[c] == need[c]) \n                    valid++;\n            }\n            // 判断左侧窗口是否要收缩\n            while ((right - left) >= (words.size()*len)) {\n                // 当窗口符合条件时，把起始索引加入 res\n                if (valid == need.size())\n                    res.push_back(left);\n                string d = s.substr(left,len);\n                // cout<<d<<endl;\n                left+=len;\n                // 进行窗口内数据的一系列更新\n                if (need.count(d)) {\n                    if (window[d] == need[d])\n                        valid--;\n                    window[d]--;\n            }\n        }\n    }\n        }\n    return res;   \n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326235782","body":"### 思路\n暴力n3超时，前缀和加hash\n\n```c++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        mp[0]=1;\n        int sum = 0, ans = 0;\n        for (auto num: nums) {\n            sum += num;\n            int modulus = (sum % k + k) % k;\n            if (mp.count(modulus)) {\n                ans += mp[modulus];\n            }\n            ++mp[modulus];\n        }\n        return ans;\n    }\n};\n```\n###\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327510796","body":"### 思路\n快慢指针，快的到了，慢的刚好一半。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* l=head,*r=head;\n        while(r!=nullptr){            \n            if(r->next!=nullptr){\n                l=l->next;r=r->next->next;\n            }\n            else{                \n                break;\n            }\n        }\n        return l;\n    }\n};\n```\n###\nO(N)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328018390","body":"### 思路\n就地往前复制\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int p=0;\n        for(int i=1;i<nums.size();i++){\n            if(nums[i]!=nums[p]){\n                nums[++p]=nums[i];\n            }\n        }\n        return p+1;\n    }\n};\n```\n\n### \nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328231358","body":"### 思路\n遍历\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int ans=nums.size();\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]>=target){\n                return i;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n###\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328979240","body":"### 思路\n一开始觉得是优先队列，看了题解发现单调队列更快，将索引存队列，注意出的时候，由于后续有更大的需要把前面比他小的清除，应该popback的，第一次写成了popfront，导致中间小数没被删掉，有些不专心。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int mx=-1;\n        vector<int> ans;\n        list<int> l;\n        l.push_back(0);\n        for(int i=1;i<k;i++){        \n            while(!l.empty()&&nums[l.back()]<nums[i]){\n                l.pop_back();\n            }\n            l.push_back(i);\n            // mx=max(mx,nums[i]);\n        }\n        ans.push_back(nums[l.front()]);\n        for(int i=k;i<nums.size();i++){\n            // cout<<nums[i]<<\" \"<<nums[l.front()]<<endl; \n            while(!l.empty()&&nums[l.back()]<nums[i]){\n                l.pop_back();\n            }\n            // cout<<nums[i]<<\" \"<<nums[l.front()]<<endl; \n            l.push_back(i);            \n            // cout<<nums[i]<<\" \"<<nums[l.front()]<<endl; \n            while(l.front()<=i-k){\n                l.pop_front();\n            }\n            ans.push_back(nums[l.front()]);\n\n        }        \n        // for(auto a:l){\n        //     cout<<a<<endl;\n        // }\n        return ans;\n\n    }\n};\n```\n合并\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int mx=-1;\n        vector<int> ans;\n        list<int> l;\n        for(int i=0;i<nums.size();i++){\n            while(!l.empty()&&nums[l.back()]<nums[i]){\n                l.pop_back();\n            }\n            l.push_back(i);      \n            while(l.front()<=i-k){\n                l.pop_front();\n            }\n            if(i>=k-1)ans.push_back(nums[l.front()]);\n        }      \n        return ans;\n    }\n};\n```\n\n### \nO(n)\nO(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330193544","body":"### 思路\n因为互不相同，统计所有被信任的，计数，将所有符合n-1条件的进行判别，确定是不是唯一。\n\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        int a[1010]={};\n        vector<int> ans;\n        map<int,int> m;\n        if(n==1)return 1;\n        for(int i=0;i<trust.size();i++){\n            m[trust[i][0]]=trust[i][1];\n            if(n-1==(++a[trust[i][1]])){\n                ans.push_back(trust[i][1]);\n            };\n        }\n        int an=-1;\n        for(int i=0;i<ans.size();i++){\n            if(m.count(ans[i])){\n            }else{\n                if(an==-1){\n                    an=ans[i];\n                }else{\n                    return -1;\n                }\n            }   \n        }\n        return an;\n    }\n};\n```\n\n### \nO(n)\n\n看题解是统计出度入度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332371201","body":"### 思路\n第一次当简单题做wa了，应该二分图并查集，最后看题解发现是图dfs\n\n### 代码\n```c++\nclass Solution {\n    vector<vector<int>> g;\n    vector<int> _colors;\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        g=vector<vector<int>>(n);\n        for(int i=0;i<dislikes.size();i++){\n            g[dislikes[i][0]-1].push_back(dislikes[i][1]-1);\n            g[dislikes[i][1]-1].push_back(dislikes[i][0]-1);\n        }\n        for(int i=0;i<n;i++){\n            for(auto a:g[i]){\n                cout<<i<<\":\"<<a<<\" \";\n            }\n            cout<<endl;\n        }\n        _colors = vector<int>(n, 0);\n        for (int i = 0; i < n; i++)\n            if (_colors[i] == 0 && !dfs(i, 1))\n                return false;\n        return true;\n    }\n    bool dfs(int cur,int color){\n        _colors[cur] = color;\n        for(int next:g[cur]){\n            if(_colors[next]==color)return false;\n            if(_colors[next]==0&&!dfs(next,-color))return false;\n        }\n        return true;\n    }\n};\n```\n并查集\n```c++\nclass Solution {\npublic:\n    int findFa(int x, vector<int>& fa) {\n        return fa[x] < 0 ? x : fa[x] = findFa(fa[x], fa);\n    }\n\n    void unit(int x, int y, vector<int>& fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        if (x == y) {\n            return ;\n        }\n        if (fa[x] < fa[y]) {\n            swap(x, y);\n        }\n        cout<<fa[x]<<\" \"<<fa[y]<<endl;\n        fa[x] = fa[y];\n        fa[y] = x;\n        cout<<fa[x]<<\" \"<<fa[y]<<endl;\n    }\n\n    bool isconnect(int x, int y, vector<int>& fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        return x == y;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> fa(n + 1, -1);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < g[i].size(); ++j) {\n                unit(g[i][0], g[i][j], fa);\n                if (isconnect(i, g[i][j], fa)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n###\nO(V+E)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333970120","body":"### 思路\n拓扑排序，看了题解，要对两个key排序，bfs\n\n### 代码\n```c++\nclass Solution {\npublic:\n\n    vector<int> topS(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> q;\n        for(auto item:items){\n            if(deg[item]==0)q.push(item);\n        }\n        vector<int> res;\n        while(!q.empty()){\n            int temp=q.front();\n            q.pop();\n            res.push_back(temp);\n            for(auto v:graph[temp]){\n                if(--deg[v]==0)q.push(v);\n            }\n        }\n        return res.size()==items.size() ? res:vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        vector<vector<int>> groupGra(n + m);\n        vector<vector<int>> itemGra(n);\n\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.push_back(i);\n        }\n        int leftId = m;\n        for (int i = 0; i < n; ++i) {\n            if(group[i]==-1){\n                group[i]=leftId++;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i]++;\n                    itemGra[item].push_back(i);\n                }else{\n                    groupDegree[curGroupId]++;\n                    groupGra[beforeGroupId].push_back(curGroupId);\n                }\n            }\n        }\n\n        vector<int> groupTopS=topS(groupDegree,groupGra,id);\n        if(groupTopS.size()==0){\n            return vector<int>{};\n        }\n        vector<int> ans;\n        for(auto& curGroupId:groupTopS){\n            int size=groupItem[curGroupId].size();\n            if(size==0)continue;\n            vector<int> res=topS(itemDegree,itemGra,groupItem[curGroupId]);\n            if(res.size()==0)return vector<int>{};\n            for(auto& item:res)ans.push_back(item);\n        }\n        return ans;\n    }\n};\n```\n\n### \nO(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334964140","body":"### 思路\n模拟\n\n### 代码\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x=0,y=0;\n        for(auto a:moves){\n            if(a=='U')y++;\n            else if(a=='D')y--;\n            else if(a=='L')x--;\n            else x++;\n        }\n        return x==0&&y==0;\n    }\n};\n```\n\n###\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336099839","body":"### 思路\n模拟，第一回想的是直接优先队列，把下标也结构体并进去，重写排序函数，但其实只有在等待队列的进程才需要进入优先队列，应该拆分，一个数组第一回排序，记录下标和到达时间，另一个时间戳到了去优先队列，小顶堆需要修改声明。\n另：emplace比push多了构造函数。\n\n```c++\nclass Solution {\npublic:\n\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n=tasks.size();\n        vector<int> ans;        \n        vector<pair<int,int>> v;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;       \n        \n        for(int i=0;i<tasks.size();i++){\n            pair<int,int> a;\n            a.first=tasks[i][0];\n            a.second=i;\n            v.push_back(a);\n        }\n        sort(v.begin(),v.end());\n        // for(auto vv:v){\n        //     cout<<vv.first<<\" \"<<vv.second<<endl;\n        // }\n        long long int time=0;\n        int pp=0;\n        for(int i=0;i<n;i++){\n            if(q.empty()){\n                time=max(time,(long long int)tasks[v[pp].second][0]);\n            }\n            while(pp<n&&tasks[v[pp].second][0]<=time){\n                q.emplace(tasks[v[pp].second][1],v[pp].second);\n                ++pp;\n            }\n            auto && [pro,ind]=q.top();\n            time+=pro;\n            ans.push_back(ind);\n            q.pop();\n        }\n\n        // int time=v[0].first;\n        // ans.push_back(v[0].second);\n        // time+=tasks[v[0].second][1];\n\n        // cout<<\"!!\"<<endl;\n        // int time=0;\n        // while(!q.empty()){\n        //     pair<int,int>a;\n        //     a=q.top();\n        //     time=a.first;\n        //     cout<<q.top().first<<\" \"<<q.top().second<<endl;\n        //     q.pop();\n        // }\n        return ans;\n    }\n};\n```\n\n### \nO(nlogn)\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298592412","body":"### 思路\r\n\r\n先判断结果数组的长度，之后将k与num逆序按位相加取余后放到结果数组。\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        if (k == 0)\r\n            return num;\r\n\r\n        string kstr = to_string(k);\r\n        int len = max(num.size(), kstr.size());\r\n        vector<int> result(len+1,0);\r\n\r\n        int a, b;\r\n\r\n        for(int i = num.size() - 1; i >= 0; i--)\r\n        {\r\n            a = num[i];\r\n            k += a;\r\n            b = k % 10;\r\n            result[len--] = b;\r\n            k /= 10;\r\n        }\r\n        if (k)\r\n        {\r\n            while (k > 9)\r\n            {\r\n                b = k % 10;\r\n                result[len--] = b;\r\n                k /= 10;\r\n            }\r\n            result[len--] = k;\r\n        }\r\n        if(!result[0]) result.erase(result.begin());\r\n        return result;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300551765","body":"### 思路\r\n\r\n先遍历一次字符串，将所有字符出现位置的下标放到一个新数组；之后再便利一次数组，找到每个字符与数组所有出现位置的距离的最小值。\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> c_position;\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (s[i] == c)\r\n                c_position.push_back(i);\r\n        } \r\n        int dist;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n            for (int j = 0; j < c_position.size(); j++)\r\n            {\r\n                dist = abs(i - c_position[j]);\r\n                if (dist > res[i]) break;\r\n                else res[i] = dist;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*K)，其中 K 为字符出现的次数。\r\n- 空间复杂度：O(K)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302216723","body":"### 思路\r\n\r\n使用数组存放栈中的元素。\r\n\r\n### 代码\r\n\r\n\r\n```\r\ntypedef struct SNode CustomStack;\r\nstruct SNode {\r\n    int *data;\r\n    int top;\r\n    int maxsize;\r\n};\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    CustomStack *Stack = (CustomStack *)malloc(sizeof(CustomStack));\r\n    Stack->data = (int *)malloc(maxSize * sizeof(int));\r\n    Stack->maxsize = maxSize;\r\n    Stack->top = -1;\r\n    return Stack;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    if(obj->top < obj->maxsize - 1)\r\n        obj->data[++obj->top] = x;\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    if(obj->top > -1)\r\n        return obj->data[obj->top--];\r\n    else\r\n        return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    if (obj->top <= k - 1)\r\n    {\r\n        for(int i = 0; i <= obj->top; i++)\r\n            obj->data[i] += val;\r\n    }\r\n    else\r\n    {\r\n        for (int i = 0; i < k; i++)\r\n            obj->data[i] += val;;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    free(obj->data);\r\n    free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push 和 pop 的时间复杂度为 O(1)， increment 的时间复杂度为 O(min(k, cnt))。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303645062","body":"### 思路\r\n\r\n通过栈实现。\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack <int> nums;\r\n        stack <string> strs;\r\n        int num = 0;\r\n        int len = s.size();\r\n        for(int i = 0; i < len; ++ i)\r\n        {\r\n            if(s[i] >= '0' && s[i] <= '9')\r\n            {\r\n                num = num * 10 + s[i] - '0';\r\n            }\r\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if(s[i] == '[')\r\n            {\r\n                nums.push(num);\r\n                num = 0;\r\n                strs.push(res); \r\n                res = \"\";\r\n            }\r\n            else\r\n            {\r\n                int times = nums.top();\r\n                nums.pop();\r\n                for(int j = 0; j < times; ++ j)\r\n                    strs.top() += res;\r\n                res = strs.top(); \r\n                strs.pop();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1320891735","body":"### 思路\r\n双栈\r\n### 代码\r\n``` \r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(1)\r\n空间:o(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304766593","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> nums;\r\n        int maxNum = 0;\r\n        for (int i = 0; i < arr.size(); i++) {\r\n            if (nums.empty() || nums.top() <= arr[i]) {\r\n                nums.push(arr[i]);\r\n            } else {\r\n                maxNum = nums.top();\r\n                nums.pop();\r\n                while (!nums.empty() && nums.top() > arr[i]) {\r\n                    nums.pop();\r\n                }\r\n                nums.push(maxNum);\r\n            }\r\n        }\r\n        return nums.size();\r\n    }\r\n};\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305581440","body":"### 思路\r\n\r\n闭合为环\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0 || head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode* iter = head;\r\n        while (iter->next != nullptr) {\r\n            iter = iter->next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter->next = head;\r\n        while (add--) {\r\n            iter = iter->next;\r\n        }\r\n        ListNode* ret = iter->next;\r\n        iter->next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307187066","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* dummyHead = new ListNode(0); \r\n        dummyHead->next = head; \r\n        ListNode* cur = dummyHead;\r\n        while(cur->next != nullptr && cur->next->next != nullptr) {\r\n            ListNode* tmp = cur->next; \r\n            ListNode* tmp1 = cur->next->next->next; \r\n\r\n            cur->next = cur->next->next;    \r\n            cur->next->next = tmp;          \r\n            cur->next->next->next = tmp1;  \r\n\r\n            cur = cur->next->next; // cur移动两位，准备下一轮交换\r\n        }\r\n        return dummyHead->next;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308692238","body":"### 思路\r\n分治\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int getLength(ListNode* head) {\r\n        int ret = 0;\r\n        for (; head != nullptr; ++ret, head = head->next);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\r\n        if (left > right) {\r\n            return nullptr;\r\n        }\r\n        int mid = (left + right + 1) / 2;\r\n        TreeNode* root = new TreeNode();\r\n        root->left = buildTree(head, left, mid - 1);\r\n        root->val = head->val;\r\n        head = head->next;\r\n        root->right = buildTree(head, mid + 1, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int length = getLength(head);\r\n        return buildTree(head, 0, length - 1);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间 o(n)\r\n空间 o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1320890007","body":"### 思路\r\n哈希\r\n\r\n### 代码\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode *> visited;\r\n        ListNode *temp = headA;\r\n        while (temp != nullptr) {\r\n            visited.insert(temp);\r\n            temp = temp->next;\r\n        }\r\n        temp = headB;\r\n        while (temp != nullptr) {\r\n            if (visited.count(temp)) {\r\n                return temp;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n\r\n### 复杂度\r\n时间:o(m+n)\r\n空间:o(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311734467","body":"### 思路\r\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        unordered_set<ListNode *> visited;\r\n        while (head != nullptr) {\r\n            if (visited.count(head)) {\r\n                return head;\r\n            }\r\n            visited.insert(head);\r\n            head = head->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n###复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312496756","body":"###思路\r\n哈希表加双向链表\r\n\r\n### 代码\r\n```\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode* removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：o(1)\r\n空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312743482","body":"### 代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) return 0;\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n\r\n\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313562299","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == nullptr && q == nullptr) {\r\n            return true;\r\n        } else if (p == nullptr || q == nullptr) {\r\n            return false;\r\n        } else if (p->val != q->val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315340290","body":"### 思路\r\n深度优先搜索\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int dfs(TreeNode* root, int prevSum) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root->val;\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root->left, sum) + dfs(root->right, sum);\r\n        }\r\n    }\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间复杂度:o(n)\r\n空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317118352","body":"### 思路\r\n深度优先搜索\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    void dfs(TreeNode *root, int height, int &curVal, int &curHeight) {\r\n        if (root == nullptr) {\r\n            return;\r\n        }\r\n        height++;\r\n        dfs(root->left, height, curVal, curHeight);\r\n        dfs(root->right, height, curVal, curHeight);\r\n        if (height > curHeight) {\r\n            curHeight = height;\r\n            curVal = root->val;\r\n        }\r\n    }\r\n\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        int curVal, curHeight = 0;\r\n        dfs(root, 0, curVal, curHeight);\r\n        return curVal;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度:o(n)\r\n空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318680407","body":"### 代码\r\n``` \r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320078266","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<tuple<int, int, int>> nodes;\r\n\r\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            nodes.emplace_back(col, row, node->val);\r\n            dfs(node->left, row + 1, col - 1);\r\n            dfs(node->right, row + 1, col + 1);\r\n        };\r\n\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n        vector<vector<int>> ans;\r\n        int lastcol = INT_MIN;\r\n        for (const auto& [col, row, value]: nodes) {\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().push_back(value);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(nlogn)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320889105","body":"### 思路\r\n哈希表\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> hashtable;\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            auto it = hashtable.find(target - nums[i]);\r\n            if (it != hashtable.end()) {\r\n                return {it->second, i};\r\n            }\r\n            hashtable[nums[i]] = i;\r\n        }\r\n        return {};\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321160093","body":"### 思路\r\n堆\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\r\n        return m.second > n.second;\r\n    }\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for (auto& v : nums) {\r\n            occurrences[v]++;\r\n        }\r\n\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for (auto& [num, count] : occurrences) {\r\n            if (q.size() == k) {\r\n                if (q.top().second < count) {\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            } else {\r\n                q.emplace(num, count);\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while (!q.empty()) {\r\n            ret.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n\r\n## 复杂度\r\n时间:o(nlogk)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322110754","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>> &points) {\r\n        int ans = 0;\r\n        for (auto &p : points) {\r\n            unordered_map<int, int> cnt;\r\n            for (auto &q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                ++cnt[dis];\r\n            }\r\n            for (auto &[_, m] : cnt) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n### 复杂度\r\n时间:  O(n^2) \r\n空间:  O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323875361","body":"``` \r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_set<char> occ;\r\n        int n = s.size();\r\n        int rk = -1, ans = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (i != 0) {\r\n                occ.erase(s[i - 1]);\r\n            }\r\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\r\n                occ.insert(s[rk + 1]);\r\n                ++rk;\r\n            }\r\n            ans = max(ans, rk - i + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325121494","body":"### 思路\r\n滑动窗口\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string &s, vector<string> &words) {\r\n        vector<int> res;\r\n        int m = words.size(), n = words[0].size(), ls = s.size();\r\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\r\n            unordered_map<string, int> differ;\r\n            for (int j = 0; j < m; ++j) {\r\n                ++differ[s.substr(i + j * n, n)];\r\n            }\r\n            for (string &word: words) {\r\n                if (--differ[word] == 0) {\r\n                    differ.erase(word);\r\n                }\r\n            }\r\n            for (int start = i; start < ls - m * n + 1; start += n) {\r\n                if (start != i) {\r\n                    string word = s.substr(start + (m - 1) * n, n);\r\n                    if (++differ[word] == 0) {\r\n                        differ.erase(word);\r\n                    }\r\n                    word = s.substr(start - n, n);\r\n                    if (--differ[word] == 0) {\r\n                        differ.erase(word);\r\n                    }\r\n                }\r\n                if (differ.empty()) {\r\n                    res.emplace_back(start);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326367427","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int subarraysDivByK(vector<int>& nums, int k) {\r\n        unordered_map<int, int> record = {{0, 1}};\r\n        int sum = 0, ans = 0;\r\n        for (int elem: nums) {\r\n            sum += elem;\r\n            int modulus = (sum % k + k) % k;\r\n            if (record.count(modulus)) {\r\n                ans += record[modulus];\r\n            }\r\n            ++record[modulus];\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(min(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327551056","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n        while (fast != NULL && fast->next != NULL) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328045137","body":"### 思路\r\n双指针\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        int fast = 1, slow = 1;\r\n        while (fast < n) {\r\n            if (nums[fast] != nums[fast - 1]) {\r\n                nums[slow] = nums[fast];\r\n                ++slow;\r\n            }\r\n            ++fast;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328255415","body":"### 思路\r\n二分查找\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int n = nums.size();\r\n        int left = 0, right = n - 1, ans = n;\r\n        while (left <= right) {\r\n            int mid = ((right - left) >> 1) + left;\r\n            if (target <= nums[mid]) {\r\n                ans = mid;\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(logn)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329214242","body":"### 思路\r\n优先队列\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        priority_queue<pair<int, int>> q;\r\n        for (int i = 0; i < k; ++i) {\r\n            q.emplace(nums[i], i);\r\n        }\r\n        vector<int> ans = {q.top().first};\r\n        for (int i = k; i < n; ++i) {\r\n            q.emplace(nums[i], i);\r\n            while (q.top().second <= i - k) {\r\n                q.pop();\r\n            }\r\n            ans.push_back(q.top().first);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(nlogn)\r\n空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330703679","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDegrees(n + 1);\r\n        vector<int> outDegrees(n + 1);\r\n        for (auto& edge : trust) {\r\n            int x = edge[0], y = edge[1];\r\n            ++inDegrees[y];\r\n            ++outDegrees[x];\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332210614","body":"### 思路\r\n深度优先搜索\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\r\n        color[curnode] = nowcolor;\r\n        for (auto& nextnode : g[curnode]) {\r\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\r\n                return false;\r\n            }\r\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        vector<int> color(n + 1, 0);\r\n        vector<vector<int>> g(n + 1);\r\n        for (auto& p : dislikes) {\r\n            g[p[0]].push_back(p[1]);\r\n            g[p[1]].push_back(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n+m)\r\n空间：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333801158","body":"### 思路\r\n拓扑排序\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\r\n        queue<int> Q;\r\n        for (auto& item: items) {\r\n            if (deg[item] == 0) {\r\n                Q.push(item);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while (!Q.empty()) {\r\n            int u = Q.front(); \r\n            Q.pop();\r\n            res.emplace_back(u);\r\n            for (auto& v: graph[u]) {\r\n                if (--deg[v] == 0) {\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : vector<int>{};\r\n    }\r\n\r\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\r\n        vector<vector<int>> groupItem(n + m);\r\n\r\n        vector<vector<int>> groupGraph(n + m);\r\n        vector<vector<int>> itemGraph(n);\r\n\r\n        vector<int> groupDegree(n + m, 0);\r\n        vector<int> itemDegree(n, 0);\r\n        \r\n        vector<int> id;\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.emplace_back(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem[group[i]].emplace_back(i);\r\n        }\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (auto& item: beforeItems[i]) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph[item].emplace_back(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return vector<int>{};\r\n        } \r\n        vector<int> ans;\r\n        for (auto& curGroupId: groupTopSort) {\r\n            int size = groupItem[curGroupId].size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\r\n            if (res.size() == 0) {\r\n                return vector<int>{};\r\n            }\r\n            for (auto& item: res) {\r\n                ans.emplace_back(item);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:O(m+n)\r\n空间:O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335292726","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    bool judgeCircle(string moves) {\r\n        int x = 0, y = 0;\r\n        for (const auto& move: moves) {\r\n            if (move == 'U') {\r\n                y--;\r\n            }\r\n            else if (move == 'D') {\r\n                y++;\r\n            }\r\n            else if (move == 'L') {\r\n                x--;\r\n            }\r\n            else if (move == 'R') {\r\n                x++;\r\n            }\r\n        }\r\n        return x == 0 && y == 0;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298597962","body":"## Intuition\nsimilar to add two numbers\n\n## Code\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        for (int i = num.size() - 1; i >= 0 && k > 0; i--) {\n                    num[i] += k;\n                    k = num[i] / 10;\n                    num[i] %= 10;\n                }\n        while (k) {\n            num.insert(num.begin(), k % 10);\n            k /= 10;\n        }\n\n        return num; \n    }\n};\n```\n\n## Complexity\n- Time: O(N) N = max(len(k), len(num))\n- Space: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303730976","body":"### Idea\nStack\n\n### Code\n\n\n```\n\nclass Solution(object):\n    def decodeString(self, s):\n        stack = []; curNum = 0; curString = ''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString\n```\n\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1305876329","body":"### Thought\n\nuse a dummy node\n\n### Code\n\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n\n        dummy = ListNode(-1)\n        dummy.next = head \n\n        prev, cur = dummy, head \n\n\n        while cur and cur.next:\n            second = cur.next \n            prev.next = second \n            cur.next = second.next \n            second.next = cur \n\n            prev = cur\n            cur = cur.next \n        \n        return dummy.next\n\n```\n\n**Complexity**\n- Time：O(N\n- Space：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307627643","body":"### 思路\n\nDivide and Conquer \n\n### 代码\n\n\n```python\nlass Solution:\n\n    def findMiddle(self, head):\n        if not head or not head.next: \n            return head \n\n        fast = slow = head\n        prev = None\n        while fast and fast.next: \n            prev = slow \n            slow = slow.next \n            fast = fast.next.next\n\n        prev.next = None \n        return slow \n\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n\n        mid = self.findMiddle(head)\n        node = TreeNode(mid.val)\n\n        # base case \n        if head == mid:\n            return node\n\n        # Recursively\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n        \n        return node\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N logN)\n- 空间复杂度：O(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309262008","body":"\n### 代码\n\n\n```python \n\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        l1, l2 = headA, headB\n\n        while l1 != l2: \n            l1 = l1.next if l1 else headB\n            l2 = l2.next if l2 else headA\n        \n        return l1\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298600475","body":"python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return str(int(''.join(map(str,A)))+K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1301983242","body":"### 题目\r\n[LC821 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n### 思路一\r\n    1. 遍历一次把所有c的index找出来存成一个list\r\n    2. s中的每一个与c_list 求绝对值，取最小\r\n\r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        c_ls = []\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                c_ls.append(i)\r\n\r\n        ans = []\r\n        for i, val in enumerate(s):\r\n            tmp = []\r\n            for j in c_ls:\r\n                tmp.append(abs(j-i))\r\n            ans.append(min(tmp))\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(N2)\r\n    空间复杂度 O(n)\r\n    \r\n### 思路二\r\n    1. 绝对值 --> 双指针，左右遍历\r\n    2. 大小比较时先设定inf\r\n    3. 左右遍历时记得顺序\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = []\r\n        tar = float('-inf')\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                tar = i\r\n            left.append(i - tar)\r\n        \r\n        right = []\r\n        tar = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                tar = i\r\n            right.append(min(tar - i, left[i]))\r\n\r\n        return right[::-1]\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301982795","body":"### 题目\r\n[LC1381设计栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n### 思路\r\n按要求操作\r\n\r\n### 代码\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.stack[-1]\r\n            del self.stack[-1]\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > len(self.stack):\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]+=val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 push O(1), pop O(1), increment O(min(maxSize,k))\r\n    空间复杂度 O(maxSize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304398312","body":"### 题目\r\n[LC394 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n### 思路一\r\n    括号匹配\r\n    入栈，遇到右括号出栈，记录str，左侧加value，直到遇到左括号\r\n    重复数字n次，入栈\r\n    所有数据出栈合并\r\n    ------------\r\n    错误点，数字不仅是10以内的数\r\n    \r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                tmp = ''\r\n                while stack[-1] != '[':\r\n                    tmp = stack[-1] + tmp\r\n                    stack.pop()\r\n\r\n                stack.pop() # 去掉 [\r\n                # 获取数字\r\n                repeat,e = 0,0\r\n                while len(stack)>0 and stack[-1].isdigit():\r\n                    repeat += int(stack[-1]) * (10**e)\r\n                    e += 1\r\n                    stack.pop() # 去掉数字\r\n                stack.append(repeat*tmp)\r\n            else:\r\n                stack.append(s[i])\r\n\r\n        ans = ''\r\n        for v in stack:\r\n            ans += v\r\n        \r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)\r\n\r\n\r\n### 思路二\r\n    逆波兰式，字母一个栈，数字一个栈\r\n    巧妙点：上一个str和下一个要重复次数的数字，存成一个数组\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        num = 0\r\n        string = ''\r\n        stack = []\r\n        for i in s:\r\n            if i.isdigit():\r\n                num = num*10 + int(i)                                \r\n            elif i == '[':\r\n                stack.append((string, num))\r\n                string = ''\r\n                num = 0\r\n            elif i == ']':\r\n                pre, k = stack.pop()\r\n                string = pre + k * string\r\n            elif i.isalpha():\r\n                string += i\r\n        return string\r\n\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304398515","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304809014","body":"### 题目\r\n[LC768 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n### 思路\r\n    当前数值比后面的都大就不能分块\r\n    栈中留下排序块的最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        stack = []\r\n        for i in range(len(arr)):\r\n            if stack and arr[i]<stack[-1]:\r\n                head = stack.pop() # 最后一位是最大值\r\n                while stack and arr[i]<stack[-1]: # 为了跟前面的值对比，排序\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305659115","body":"### 题目\r\n[LC61 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n### 思路\r\n    链表拼接问题闭环再切断。首先遍历一遍计算出链表长度，为不影响原始链表，需要新声明一个链表。而后找出要切断的位置（相对于原始链表来说），cut=n-k%n。首尾闭环。循环找到切的点，cut.\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n\r\n        def rotateRight(self, head, k):\r\n            \"\"\"\r\n            :type head: ListNode\r\n            :type k: int\r\n            :rtype: ListNode\r\n            \"\"\"\r\n            #首先考虑边界，特殊情况\r\n            if k == 0 or not head or not head.next:\r\n                return head\r\n            \r\n            n = 1\r\n            cur = head\r\n\r\n            while cur.next:\r\n                cur = cur.next # 这里cur更新后，head不会更新，因为cur被重新赋值了，如果cur.next=xxx，那么head.next也会变化\r\n                n += 1\r\n            \r\n            add = n - k % n # 断开的位置\r\n            if add == n:\r\n                return head\r\n            \r\n            cur.next = head # 连接闭环\r\n            while add:\r\n                print(add)\r\n                cur = cur.next\r\n                add -= 1\r\n            \r\n            ret = cur.next\r\n            cur.next = None\r\n            return ret\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n) 最多遍历两次链表\r\n    空间复杂度 O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307266589","body":"### 题目\r\n[LC24 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n### 思路\r\n    虚拟头节点，减少边界的考虑。模拟+递归\r\n    这道题说明了对链表定义理解不透彻。节点（listNode）是一个数值+一个指针，不是像数组那样的好几个数值。力扣打印出来了，其实是循环打印了每一个节点，使得看起来像一个list。\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n\r\n        if head is None or head.next is None:\r\n            return head \r\n\r\n        # head = ListNode(-1,head) # 添加虚拟节点 也work，但是尽量不要更改原始链表\r\n        # tmp = head\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        tmp = dummyHead\r\n        \r\n        while tmp.next and tmp.next.next:\r\n            node1 = tmp.next\r\n            node2 = tmp.next.next\r\n            tmp.next = node2\r\n            node1.next = node2.next\r\n        return dummyHead.next\r\n\r\n    # 递归\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 迭代O(1) 递归O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308810683","body":"### 题目\r\n[LC109 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n### 思路\r\n    首先通过快两步慢一步针的方式找到中点\r\n    递归的方式，根节点等于中点，左节点等于左子树中点，右节点等于右子树中点\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: Optional[ListNode]\r\n        :rtype: Optional[TreeNode]\r\n        \"\"\"\r\n        \r\n        def getMid(left, right):\r\n            fast = slow = left # initial 先都从左侧第一个开始\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next # 错误点，指针移动需用用自身，left.next一直是同一个，没有动\r\n                slow = slow.next\r\n            return slow\r\n\r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMid(left,right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n\r\n        return buildTree(head, None)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(nlogn)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298600531","body":"### 思路\r\n先使用`join`方法把数组拍平成字符串，接着转成BigInt进行计算，再转成字符串，使用`split`方法转成数组\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const string = num.join('')\r\n    const sum = String(BigInt(string) + BigInt(k))\r\n    return sum.split('')\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300665137","body":"### 思路\r\n借鉴的官方的答案，自己确实没有思考出来。核心的思路是正反两个方向遍历，将目标点c的位置设置为0；由于在遇到c之前，idx是不存在的。因此官方使用-n（正向遍历）和2n（反向遍历）的初始值。其目的是保证在遇到第一个c之前result[i]足够大，这样在逆向操作时（逆向操作时的result[i]肯定会经过c，因此此时的result[i]是真正的值，所以会通过Math.min筛选出来）。如果还不理解的话，debug一下就清楚了\r\n\r\n### 代码\r\n\r\n```javascript\r\nconst shortestToChar = (strs, c) => {\r\n  let len = strs.length\r\n  const result = new Array(len).fill(0)\r\n  for(let i = 0, idx = -len; i < strs.length; i++) {\r\n    if (strs[i] === c) {\r\n      idx = i\r\n    }\r\n    result[i] = i - idx\r\n  }\r\n\r\n  for (let i = len - 1, idx = 2 * len; i >= 0; i--) {\r\n    if (strs[i] === c) {\r\n      idx = i\r\n    }\r\n\r\n    result[i] = Math.min(result[i], idx - i)\r\n  }\r\n\r\n\r\n  return result\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302303781","body":"### 思路\r\njs写很容易，没啥可说的\r\n\r\n### 代码\r\n```javascript\r\nvar CustomStack = function(maxSize) {\r\n    this.len = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.len) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length > 0) return this.stack.pop()\r\n    return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (this.stack.length < k) {\r\n        sum(this.stack, val)\r\n    } else {\r\n        let len = this.stack.length\r\n        let start = this.stack.slice(0, k)\r\n        let end = this.stack.slice(k, len)\r\n        sum(start, val)\r\n        this.stack = [...start, ...end]\r\n    }\r\n};\r\n\r\nconst sum = (list, val) => {\r\n    for(let i = 0; i < list.length; i++) {\r\n        list[i] = list[i] + val\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间：O(N)\r\n空间：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305780870","body":"### 思路\r\n\r\n将链表组成环，然后计算分割点`len - k%len`，再将两个分开的链表拼起来\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next) return head\r\n    if (k === 0) return head\r\n    let dummy = new ListNode()\r\n    dummy.next = head\r\n    let len = 1\r\n    let cur = dummy.next\r\n    let last = dummy.next\r\n    while (last.next) {\r\n      last = last.next\r\n      len++\r\n    }\r\n  \r\n    // 建立环\r\n    last.next = head\r\n    let i = 1\r\n    while(i < len - k%len) {\r\n      cur = cur.next\r\n      i++\r\n    }\r\n  \r\n  \r\n    let temp = cur.next\r\n  \r\n    dummy.next = temp\r\n    cur.next = null\r\n  \r\n    return dummy.next\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307384091","body":"### 思路\r\n\r\n双指针，利用虚拟节点dummy，每次传入前置节点`prev`，当前节点cur，以及后一个节点完整节点的更换next，然后将节点移至下一次要交换的节点处；\r\n\r\n### 代码\r\n\r\n```javascript\r\n\r\nvar swapPairs = function(head) {\r\n  if (!head || !head.next)  return head\r\n  let cur = head, next = cur\r\n  const dummy = new ListNode()\r\n  dummy.next = head\r\n  let prev = dummy\r\n  while(cur && cur.next) {\r\n    next = cur.next\r\n    swapTwoNode(prev, cur, next)\r\n    prev = cur\r\n    cur = cur.next\r\n    next = cur\r\n  }\r\n\r\n  return dummy.next\r\n};\r\n\r\n\r\nconst swapTwoNode = (prev, cur, next) => {\r\n  let temp = next.next\r\n  prev.next = next\r\n  next.next = cur\r\n  cur.next = temp\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310385710","body":"### 思路\r\n求链表相交的固定思路是双指针，分别在自己的链表上每次移动一个节点，跑完后去另一个链表头开始移动，如果两个节点存在相同的场景，就相交了；反之没有\r\n\r\n### 代码\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (headA === null || headB === null) {\r\n        return null;\r\n    }\r\n    let cur1 = headA, cur2 = headB\r\n    while(cur1 !== cur2) {\r\n        if (!cur1) {\r\n            cur1 = headB\r\n        } else {\r\n            cur1 = cur1.next\r\n        }\r\n        if (!cur2) {\r\n            cur2 = headA\r\n        } else {\r\n            cur2 = cur2.next\r\n        }\r\n    }\r\n\r\n    return cur1\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313977560","body":"### 思路\r\n广度遍历，依次比较，注意边界即可\r\n\r\n###代码\r\n```javascript\r\n    if (p == null && q == null) return true\r\n    if (!p || !q) return false\r\n    const queueP = [p]\r\n    const queueQ = [q]\r\n    let result = true\r\n    while(queueP.length > 0 && queueQ.length > 0) {\r\n        const nodeP = queueP.shift()\r\n        const nodeQ = queueQ.shift()\r\n\r\n        if (nodeP.val !== nodeQ.val) {\r\n            return false\r\n        }\r\n\r\n        if ((!nodeP.left && nodeQ.left) || (nodeP.left && !nodeQ.left)) return false\r\n        if ((!nodeP.right && nodeQ.right) || (nodeP.right && !nodeQ.right)) return false \r\n\r\n        if (nodeP.left) {\r\n            queueP.push(nodeP.left)\r\n        }\r\n        if (nodeP.right) {\r\n            queueP.push(nodeP.right)\r\n        }\r\n        if (nodeQ.left) {\r\n            queueQ.push(nodeQ.left)\r\n        }\r\n        if (nodeQ.right) {\r\n            queueQ.push(nodeQ.right)\r\n        }\r\n\r\n    }\r\n    if (queueP.length === 0 && queueQ.length === 0) return true\r\n    return false\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315382774","body":"### 思路\r\n遍历使用DFS，路径借用了字符串来存储，注意遍历到叶子节点时要回溯；获得路径集后使用`reduce`累加即可\r\n\r\n### 代码\r\n```javascript\r\n\r\nvar sumNumbers = function(root) {\r\n    if (!root) return 0\r\n    const result = []\r\n    const traverse = (root, str ) => {\r\n        if (!root) return\r\n        str = str + String(root.val)\r\n        // 叶子节点\r\n        if (root && !root.left && !root.right) {\r\n            result.push(str)\r\n            // 回溯\r\n            str = str.slice(0, -1)\r\n            return\r\n        }\r\n        traverse(root.left, str)\r\n        traverse(root.right, str)\r\n    }\r\n    traverse(root, '')\r\n\r\n    return result.reduce((sum, cur) => {\r\n        return sum += Number(cur)\r\n    }, 0)\r\n};\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317149565","body":"### 思路\r\n借助BFS，每次遍历时记录第一项，这是本行最左边的值\r\n\r\n### 代码\r\n```javascript\r\nvar findBottomLeftValue = function(root) {\r\n    if (!root) return null\r\n    let result = null\r\n    const queue = [root]\r\n    while (queue.length > 0) {\r\n        const len = queue.length\r\n        for (let i = 0; i < len; i++) {\r\n            const node = queue.shift()\r\n            if (i === 0) {\r\n                result = node\r\n            }\r\n            node.left && queue.push(node.left)\r\n            node.right && queue.push(node.right)\r\n        }\r\n    }\r\n    return result.val\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度: O(N)\r\n空间复杂度: O(N","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320799630","body":"## 思路\r\n将数组存入map中，再通过比较\r\n\r\n## 代码\r\n```javascript\r\nvar twoSum = function(nums, target) {\r\n    const map = {}\r\n    for (let i = 0; i < nums.length; i++) {\r\n        map[nums[i]] = i\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n        const num = nums[i]\r\n        if (i !== map[target - num] && map[target - num] > -1) {\r\n            return [i, map[target - num]]\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321134785","body":"## 思路\r\n用的不是二叉堆，使用的是哈希+排序\r\n\r\n## 代码\r\n```javascript\r\nvar topKFrequent = function(nums, k) {\r\n    const map = new Map()\r\n    for(let i = 0; i < nums.length; i++) {\r\n        if (!map.get(nums[i])) {\r\n            map.set(nums[i], 1)\r\n        } else {\r\n           map.set(nums[i], map.get(nums[i]) + 1)\r\n        }\r\n    }\r\n    let arr = Array.from(map).sort((a,b) => b[1] - a[1])\r\n    let result = arr.slice(0, k).map(num => num[0])\r\n    return result\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323892821","body":"## 思路\r\n滑动窗口，map记录字符和它对应得位置，max记录最长的字符串；两个指针start，end，每次遍历移动end；当遇到重复的字符串时，更新start的位置，同时更新这个字符串在map中的位置\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar lengthOfLongestSubstring = function(s) {\r\n    const map = new Map()\r\n    const len = s.length;\r\n    let max = 0\r\n    for (let start = 0, end = 0; end < len; end++) {\r\n        // 此时说明存在相同的字符串了，这时候需要重置start的位置\r\n        if (map.has(s.charAt(end))) {\r\n            start = Math.max(map.get(s.charAt(end)), start)\r\n        }\r\n        // 计算max的最大值\r\n        max = Math.max(max, end - start + 1)\r\n        // 在map中end向前滑动一位\r\n        map.set(s.charAt(end), end + 1)\r\n    }\r\n\r\n    return max\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327644048","body":"## 思路\r\n快慢指针，快指针一次走两步，慢指针一次走一步，快指针走完后，慢指针就为中点\r\n\r\n## 代码\r\n```javascript\r\nvar middleNode = function(head) {\r\n    if (!head) return null\r\n    let prev = cur = head\r\n    while (cur && cur.next) {\r\n        prev = prev.next\r\n        cur = cur.next.next\r\n    }\r\n\r\n    return prev\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327982616","body":"## 思路\r\n双指针，快指针遍历数组，慢数组维护不重复的数据\r\n\r\n## 代码\r\n```javascript\r\nvar removeDuplicates = function(nums) {\r\n  if (nums.length === 0) return 0\r\n  if (nums.length === 1) return 1\r\n  // 智障了，做过这道题\r\n  let len = nums.length\r\n  let cur = 1, next = 1\r\n  while (next < len) {\r\n    if (nums[next] !== nums[next - 1]) {\r\n      nums[cur] = nums[next]\r\n      cur++\r\n    }\r\n    next++\r\n  }\r\n  return cur\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328172742","body":"## 思路\r\n解决本题需要两步：1. 普通二分法查找目标节点；2. 插入到合适的位置；第一点很好处理，关于第二点，其实每次缩小搜索空间到极限时，要插入的点始终在右区间边界的下一位，所以直接返回end + 1就行了。\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let start = 0, end = nums.length - 1\r\n    let result = -1\r\n    let mid \r\n    while(start <= end) {\r\n        mid = Math.floor((start + end) / 2)\r\n        if (nums[mid] === target) {\r\n            return mid\r\n        } else if (nums[mid] < target) {\r\n            start = mid + 1\r\n        } else if (nums[mid] > target) {\r\n            end = mid - 1\r\n        }\r\n    }\r\n\r\n\r\n    return end + 1\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(logN)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330842947","body":"## 代码\r\n\r\n```javascript\r\nvar findJudge = function(N, trust) {\r\n    var stack = [];\r\n    var fake = []\r\n    if (N === 1){\r\n        return N\r\n    }\r\n    for (var i = 1; i <= N; i++){\r\n        var sum = 0;\r\n        for ( var a = 0;a < trust.length; a++){\r\n            if (i === trust[a][0]){\r\n                fake.push(i)\r\n            }\r\n            if (i === trust[a][1]){\r\n                sum++\r\n                if (sum === N - 1){\r\n                    stack.push(i)\r\n                    continue\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (stack.length === 0){\r\n        return -1\r\n    }\r\n    for (var i = 0; i < stack.length; i++){\r\n        for (var f = 0; f < fake.length; f++){\r\n            if (stack[i] === fake[f]){\r\n                stack.splice(i,1)\r\n            }\r\n        }\r\n    }\r\n    if (stack.length !== 0){\r\n        return stack[0]\r\n    }else{\r\n        return -1\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N*logN)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298606440","body":"#### 代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        out = []\n        i = len(num)-1\n        while i >= 0 or k!=0:\n            x = num[i] if i>=0 else 0\n            y = k%10 if k!=0 else 0\n\n            _sum = x+y+carry\n            carry = _sum//10\n            out.append(_sum%10)\n\n            i -=1\n            k = k//10\n        if carry!=0: \n            out.append(1)\n        return out[::-1]\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300599069","body":"#### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        out = [0]*n\n        indx = -n\n        for i,x in enumerate(s):\n            if x==c:\n                indx = i\n            out[i] = i-indx\n        indx = 2*n\n        for j in range(n-1,-1,-1):\n            if s[j]==c:\n                indx = j\n            out[j] = min(indx-j,out[j])\n\n        return out\n```\n#### 复杂度分析\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302177151","body":"#### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize-1\n        self.cur = -1\n        self.stack = [-1]*maxSize\n\n    def push(self, x: int) -> None:\n        if  self.cur< self.maxsize:\n            self.cur +=1\n            self.stack[self.cur] = x\n\n    def pop(self) -> int:\n        if self.cur == -1:\n            return -1\n        else:\n            self.cur -= 1\n            return self.stack[self.cur+1]\n\n    def increment(self, k: int, val: int) -> None:\n        minl = min(k,self.cur+1)\n        for i in range(minl):\n            self.stack[i] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n#### 复杂度分析\nO(k)  \nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303605792","body":"#### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, cstr, num = [], \"\", 0\n        for i in s:\n            if \"0\" <= i <= \"9\":\n                num = num*10 + int(i)\n            elif i == \"[\":\n                stack.append((cstr,num))\n                cstr, num = \"\", 0\n            elif i == ']':\n                _cstr,_num = stack.pop()\n                cstr = _cstr + cstr * _num\n            else:\n                cstr += i \n        return cstr\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304378754","body":"#### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout =[]\n\n    def push(self, x: int) -> None:\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stackout:\n            return self.stackout.pop()\n        else:\n            for i in range(len(self.stackin)):\n                self.stackout.append(self.stackin.pop())\n            return self.stackout.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stackout.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stackin or self.stackout)\n```\n#### 复杂度分析\nO(1)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304821843","body":"#### 代码\n``` python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num<stack[-1]:\n                head = stack.pop()\n                while stack and num<stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305481599","body":"#### 代码\n``` python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k==0:\n            return head\n        \n        n = 1\n        curt = head\n        while curt.next:\n            n += 1\n            curt = curt.next\n        \n        tk = (n-k)%n\n\n        if  tk ==0:\n            return head\n        \n        curt.next = head\n\n        while tk:\n            curt = curt.next\n            tk -= 1\n\n        newhead = curt.next\n        curt.next = None\n        return newhead    \n\n\n```\n#### 复杂度分析\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307274016","body":"#### 代码\n\n``` python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummyHead = ListNode(next = head)\n        cur = dummyHead\n\n        while cur.next and cur.next.next:\n            temp1 = cur.next\n            temp2 = cur.next.next\n            \n            temp1.next = temp2.next\n            temp2.next = temp1\n            cur.next = temp2\n\n            cur = temp1\n     \n        return dummyHead.next\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308780157","body":"#### 代码\n\n``` python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        elif not head.next:\n            return TreeNode(val=head.val)\n            \n        slow, fast = head, head\n        leftend = None\n        while fast and fast.next:\n            fast = fast.next.next\n            leftend = slow\n            slow = slow.next\n        if leftend:\n            leftend.next = None\n        \n        root = TreeNode(val=slow.val)\n        if slow == fast:\n            return root\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n#### 复杂度分析\n\nO(N)  \nO(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309607420","body":"#### 代码\n\n``` python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        cura, curb = headA, headB\n        while cura!=curb:\n            if cura:\n                cura = cura.next\n            else:\n                cura = headB\n            if curb:\n                curb = curb.next\n            else:\n                curb = headA\n        return cura\n\n```\n\n#### 复杂度分析\n\nO(m+n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311115889","body":"#### 代码\n\n``` python\nclass Solution(object):\n    def detectCycle(self, head):\n        slow,fast  = head, head\n        while True:\n            if not (fast and fast.next): \n                return None\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: \n                break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n\n#### 复杂度分析\n\nO(N)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312507147","body":"#### 代码\n\n``` python\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.capacity = capacity\n        self.size = 0\n        self.head = Dlinknode()\n        self.tail = Dlinknode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n\n        self._movenode2head(node)\n\n        return node.value\n\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = Dlinknode(key, value)\n            self.cache[key] = node\n\n            node.prev = self.head\n            node.next = self.head.next\n            self.head.next.prev = node\n            self.head.next = node\n\n            self.size += 1\n\n            if self.size > self.capacity:\n                node = self.tail.prev\n                node.prev.next = node.next\n                node.next.prev = node.prev\n                self.cache.pop(node.key)\n                self.size -= 1\n\n        else:\n            node = self.cache[key]\n            node.value = value\n            self._movenode2head(node)\n\n\n\n    def _movenode2head(self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n\nclass Dlinknode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n```\n\n#### 复杂度分析\n\nO(1)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312659613","body":"#### 代码\n\n``` python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        ##1\n        # if root is None:\n        #     return 0\n        # leftdep = self.maxDepth(root.left)\n        # rightdep = self.maxDepth(root.right)\n        # curdep = max(leftdep, rightdep) +1\n        # return curdep\n\n        ##2\n        if root is None:\n            return 0\n        layer = [root]\n        dep = 0\n        while layer:\n            dep += 1\n            nextlayer = []\n            for i in layer:\n                if i.left:\n                    nextlayer.append(i.left)\n                if i.right:\n                    nextlayer.append(i.right)\n            layer = nextlayer\n        return dep\n```\n\n#### 复杂度分析\n\nO(n)  \nO(height)\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313493502","body":"#### 代码\n\n``` python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        #1\n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        else:\n            if p.val ==q.val:\n                leftsame = self.isSameTree(p.left,q.left)\n                rightsame = self.isSameTree(p.right,q.right)\n                if leftsame and rightsame:\n                    return True\n                else:\n                    return False\n            else:\n                return False\n```\n\n#### 复杂度分析\n\nO(min(m,n))  \nO(min(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315417037","body":"#### 代码\n\n``` python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,preval):\n            if root is None: return 0\n            curval = preval*10 + root.val\n            if root.left is None and root.right is None:\n                return curval\n            else:\n                leftval = dfs(root.left,curval)\n                rightval = dfs(root.right, curval)\n                return leftval+rightval\n        return dfs(root, 0)   \n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317128249","body":"#### 代码\n\n``` python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        layer = deque([root])\n        while layer:\n            node = layer.popleft()\n            if node.right:\n                layer.append(node.right)\n            if node.left:\n                layer.append(node.left)\n            val = node.val\n        return val\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318807579","body":"#### 代码\n\n``` python\nclass Codec:\n    def serialize(self, root):\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n\n        return preorder(root)[:-1]\n\n    def deserialize(self, data: str):\n        nodes = data.split(\",\")\n\n        def preorder(i):\n            if i >= len(nodes) or nodes[i] == \"null\":\n                return i, None\n            root = TreeNode(nodes[i])\n            j, root.left = preorder(i + 1)\n            k, root.right = preorder(j + 1)\n            return k, root\n\n        return preorder(0)[1]\n```\n\n#### 复杂度分析\n\nO(n)  \nO(h)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319402477","body":"#### 代码\n\n``` python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = []\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node: return None\n            nodes.append((col, row, node.val))\n            dfs(node.left, row + 1, col - 1)\n            dfs(node.right, row + 1, col + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = [], None\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n        \n        return ans\n```\n\n#### 复杂度分析\n\nO(nlogn)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320760770","body":"#### 代码\n\n``` python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        table = {}\n        for i,x in enumerate(nums):\n            y = target - x\n            if y in table:\n                return [table[y],i]\n            else:\n                table[x] = i\n        return None\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321124065","body":"#### 代码\n\n``` python\nimport heapq\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        alldict = {}\n        for i in range(len(nums)):\n            num = nums[i]\n            alldict[num] = 1 if (num not in alldict) else alldict[num] +1\n            \n        pri_que = []\n        for key, val in alldict.items():\n            heapq.heappush(pri_que, (val,key))\n            if len(pri_que) > k:\n                heapq.heappop(pri_que)\n        \n        out = [0]*k\n        for j in range(k-1, -1, -1):\n            out[j] = heapq.heappop(pri_que)[1]\n        \n        return out\n```\n\n#### 复杂度分析\n\nO(nlogk)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321280333","body":"#### 代码\n\n``` python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0 \n        for x in points:\n            cntdict = {}\n            for y in points:\n                dis = (y[0]-x[0])**2 + (y[1]-x[1])**2\n                cntdict[dis] = 1 if dis not in cntdict else cntdict[dis]+1\n            for i in cntdict.values():\n                ans += i*(i-1)\n        return ans\n```\n\n#### 复杂度分析\n\nO(n^2)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323819263","body":"#### 代码\n\n``` python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        for i in range(n):\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n            lookup.add(s[i])\n            max_len = len(lookup) if len(lookup) > max_len else max_len\n        return max_len\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325246282","body":"#### 代码\n\n``` python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:\n            return []\n        one_l = len(words[0])\n        allword = len(words)\n        strlen = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0,one_l):\n            head_count = 0\n            left = i\n            right = i\n            cur_counter = Counter()\n            while right + one_l <= strlen:\n                w = s[right:right+one_l]\n                right += one_l\n                cur_counter[w] += 1\n                head_count += 1\n                while cur_counter[w] >words[w]:\n                    l_w = s[left:left+one_l]\n                    left += one_l\n                    cur_counter[l_w] -= 1\n                    head_count -= 1\n                if head_count == allword:\n                    res.append(left)\n        return res\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326500874","body":"#### 代码\n\n``` python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        presum = list(accumulate(nums))\n        extermod = presum[-1] % p\n        if extermod == 0: \n            return 0\n        numslen = len(nums)\n        res = len(nums)\n        moddict = {}\n        moddict[0] = -1\n        for i in range(numslen):\n            presumx = presum[i]\n            xmod = presumx % p\n            findsubmod = (xmod - extermod + p) %p\n            if findsubmod in moddict:\n                sublen = moddict[findsubmod]\n                tempres = i-sublen\n                res = tempres if res>tempres else res\n                if res == 1 and len(nums) != 1:\n                    return 1\n            moddict[xmod] = i\n        if res == numslen: \n            return -1\n        return res\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326919682","body":"#### 代码\n\n``` python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dumynode = ListNode(next=head)\n        slow = dumynode\n        fast = dumynode\n        while fast:\n            slow = slow.next\n            if fast.next and fast.next.next:\n                fast = fast.next.next\n            else:\n                break\n        return slow\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327995647","body":"#### 代码\n\n``` python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        n = len(nums)\n        slow = 0\n        fast = 1\n        for i in range(1,n):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                if fast - slow > 0:\n                    nums[slow] = nums[fast]\n            fast += 1\n        return slow +1\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328181220","body":"#### 代码\n\n``` python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)-1\n\n        while left <= right:\n            mid = (left + right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left\n```\n\n#### 复杂度分析\n\nO(logn)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329305392","body":"#### 代码\n\n``` python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(q)\n\n        ans = [-q[0][0]]\n        for i in range(k, n):\n            heapq.heappush(q, (-nums[i], i))\n            while q[0][1] <= i - k:\n                heapq.heappop(q)\n            ans.append(-q[0][0])\n        \n        return ans\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329950158","body":"#### 代码\n\n``` python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = [0] * (n+1)\n        out_degree = [0] * (n+1)\n        for x,y in trust:\n            out_degree[x] += 1\n            in_degree[y] += 1\n        for i in range(1,n+1):\n            if out_degree[i] == 0 and in_degree[i] == n-1:\n                return i\n        return -1\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332274220","body":"#### 代码\n\n``` python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3-c):\n                    return False\n            return True\n        \n        g = defaultdict(list)\n        color = [0]*n\n        for a,b in dislikes:\n            a, b = a-1, b-1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i,1) for i,c in enumerate(color))\n```\n\n#### 复杂度分析\n\nO(n+m)  \nO(n+m)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333869972","body":"```\nclass Solution:\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334519929","body":"#### 代码\n\n``` python\n        if len(moves)%2 == 1:\n            return False\n        y = 0\n        x = 0 \n        for i in moves:\n            if i == \"L\":\n                x += 1\n            elif i == \"R\":\n                x -= 1\n            elif i == \"U\":\n                y += 1\n            else:\n                y -= 1\n        if x == 0 and y == 0:\n            return True\n        else:\n            return False\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336092737","body":"```\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i,task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298616728","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int size = num.size();\n\n        for(int i = size -1;  i >= 0 || k > 0; i--){\n            if(i>=0){\n                k = num[i] + k;\n            }\n            res.push_back(k % 10);\n            k = k / 10;\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300499931","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> index;\n        vector<int> answer(s.length(), s.length());\n        for(int i = 0; i < s.length(); i++){\n            if(c == s[i] ){\n                index.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.length(); i++){\n            for(int j = 0; j < index.size(); j++){\n                int r = abs(i-index[j]);\n                if (r < answer[i]){\n                    answer[i] = r;\n                }\n            }\n        }\n        return answer;\n    }\n};\n时间复杂度：O(m * k)\n空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302284663","body":"class CustomStack {\npublic:\n    int size;\n    int top;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        size = maxSize;\n        stack = vector<int>(maxSize);\n        top = -1;\n    }\n\n    void push(int x) {\n        if(top < size-1){\n            top++;\n            stack[top]=x;\n        }\n        return;\n    }\n\n    int pop() {\n        if(top < 0){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n    }\n\n    void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top; i++){\n            stack[i] += val;\n        }\n        return;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303784300","body":"class Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304384000","body":"class MyQueue {\npublic:\n  vector<int> stdIn;\n  vector<int> stdOut;\n\n  MyQueue() {\n    stdIn = vector<int>();\n    stdIn = vector<int>();\n  }\n\n  void push(int x) {\n    stdIn.push_back(x);\n    if (stdOut.empty()) {\n      auto size = stdIn.size();\n      for (int i = 0; i < size; i++) {\n        stdOut.push_back(stdIn.back());\n        stdIn.pop_back();\n      }\n    }\n  }\n\n  int pop() {\n    if (stdOut.empty()) {\n      if (stdIn.empty()) {\n        throw \"\";\n      } else {\n        auto size = stdIn.size();\n        for (int i = 0; i < size; i++) {\n          stdOut.push_back(stdIn.back());\n          stdIn.pop_back();\n        }\n      }\n    }\n    auto res = stdOut.back();\n    stdOut.pop_back();\n    return res;\n  }\n\n  int peek() {\n    if (stdOut.empty()) {\n      if (stdIn.empty()) {\n        throw \"\";\n      } else {\n        auto size = stdIn.size();\n        for (int i = 0; i < size; i++) {\n          stdOut.push_back(stdIn.back());\n          stdIn.pop_back();\n        }\n      }\n    }\n    return stdOut.back();\n  }\n\n  bool empty() {\n    if (stdOut.empty() && stdIn.empty()) {\n      return true;\n    }\n    return false;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304736581","body":"原数组和有序数组从一端开始遍历，元素出现的频次相同即可分为一组\nclass Solution {\npublic:\n  int maxChunksToSorted(vector<int> &arr) {\n    unordered_map<int, int> cnt;\n    int res = 0;\n    vector<int> sortedArr = arr;\n    sort(sortedArr.begin(), sortedArr.end());\n    for (int i = 0; i < sortedArr.size(); i++) {\n      int x = arr[i], y = sortedArr[i];\n      cnt[x]++;\n      if (cnt[x] == 0) {\n        cnt.erase(x);\n      }\n      cnt[y]--;\n      if (cnt[y] == 0) {\n        cnt.erase(y);\n      }\n      if (cnt.size() == 0) {\n        res++;\n      }\n    }\n    return res;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305795989","body":"class Solution {\npublic:\n  ListNode *rotateRight(ListNode *head, int k) {\n    if (head == nullptr || head->next == nullptr || k == 0)\n      return head;\n\n    int length = 1;\n    ListNode *fast = head;\n    ListNode *slow = head;\n    while (fast->next != nullptr) {\n      length++;\n      fast = fast->next;\n      if (length > k + 1) {\n        slow = slow->next;\n      }\n    }\n    int t = k / length;\n    if (t > 0) {\n      int y = k % length;\n      for (int i = 0; i < length - y - 1; i++) {\n        slow = slow->next;\n      }\n    }\n    fast->next = head;\n    head = slow->next;\n    slow->next = nullptr;\n    return head;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307352872","body":"class Solution {\npublic:\n  ListNode *swapPairs(ListNode *head) {\n    if (head == nullptr || head->next == nullptr) {\n      return head;\n    }\n    auto first = head;\n    auto second = head->next;\n    auto others = head->next->next;\n    // 先把前两个元素翻转\n    second->next = first;\n    // 利用递归定义，将剩下的链表节点两两翻转，接到后面\n    first->next = swapPairs(others);\n    // 现在整个链表都成功翻转了，返回新的头结点\n    return second;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308912659","body":"class Solution {\npublic:\n  TreeNode *sortedListToBST(ListNode *head) {\n    if (head == nullptr)\n      return nullptr;\n    return sortedListToBST(head, nullptr);\n  }\n  TreeNode *sortedListToBST(ListNode *head, ListNode *tail) {\n    if (head == tail)\n      return nullptr;\n\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    while (fast != tail && fast->next != tail) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    TreeNode *root = new TreeNode(slow->val);\n    root->left = sortedListToBST(head, slow);\n    root->right = sortedListToBST(slow->next, tail);\n    return root;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310481659","body":"ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    ListNode* pA = headA;\n    ListNode* pB = headB;\n    while (pA != pB) {\n        pA = pA == NULL ? headB : pA->next;\n        pB = pB == NULL ? headA : pB->next;\n    }\n\n    return pA;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311872575","body":"ListNode *detectCycle(ListNode *head) {\n    set<ListNode*> seen;\n    ListNode *cur = head;\n    while (cur != NULL) {\n        if (seen.find(cur) != seen.end()) return cur;\n        seen.insert(cur);\n        cur = cur->next;\n    }\n    return NULL;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312512618","body":"class Node {\npublic:\n  int key;\n  int val;\n  Node *next;\n  Node *prev;\n\n  Node() : key(0), val(0), next(nullptr), prev(nullptr) {}\n  Node(int key, int x) : key(key), val(x), next(nullptr), prev(nullptr) {}\n};\nclass Linklist {\npublic:\n  int size;\n  Node *begin;\n  Node *end;\n  Linklist() : size(0), begin(new Node()), end(new Node()) {\n    begin->next = end;\n    end->prev = begin;\n  }\n  Node *insert_front(int key, int x) {\n    Node *node = new Node(key, x);\n    node->next = begin->next;\n    begin->next->prev = node;\n    node->prev = begin;\n    begin->next = node;\n    size++;\n    return node;\n  }\n  Node *delete_back() {\n    if (size <= 0) {\n      throw;\n    }\n    if (end->next == begin) {\n      throw;\n    };\n    auto node = end->prev;\n    end->prev = node->prev;\n    node->prev->next = end;\n    delete node;\n    size--;\n    return node;\n  }\n  Node *update(Node *node) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n\n    node->next = begin->next;\n    begin->next->prev = node;\n    node->prev = begin;\n    begin->next = node;\n    return node;\n  }\n};\nclass LRUCache {\nprivate:\n  int cap;\n  int size;\n  unordered_map<int, Node *> cacheMap;\n  Linklist cacheList;\n\npublic:\n  LRUCache(int capacity) : size(0), cap(capacity), cacheMap(), cacheList() {}\n\n  int get(int key) {\n    auto it = cacheMap.find(key);\n    if (it == cacheMap.end()) {\n      return -1;\n    }\n    auto node = it->second;\n    return node->val;\n  }\n\n  void put(int key, int value) {\n    if (size >= cap) {\n      auto d_node = cacheList.delete_back();\n      auto key = d_node->key;\n      cacheMap.erase(key);\n    }\n\n    auto it = cacheMap.find(key);\n    if (it == cacheMap.end()) {\n      auto node = cacheList.insert_front(key, value);\n      cacheMap[key] = node;\n      return;\n    }\n\n    auto node = it->second;\n    node->val = value;\n    cacheList.update(node);\n    return;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312667769","body":"class Solution {\npublic:\n  int maxDepth(TreeNode *root) {\n    if (root == nullptr) {\n      return 0;\n    }\n    auto left = maxDepth(root->left);\n    auto right = maxDepth(root->right);\n\n    return (left > right ? left : right) + 1;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313834224","body":"class Solution {\npublic:\n  bool isSameTree(TreeNode *p, TreeNode *q) {\n    if (p == nullptr && q == nullptr) {\n      return true;\n    }\n    if (p == nullptr || q == nullptr) {\n      return false;\n    }\n    if (p->val != q->val) {\n      return false;\n    }\n\n    auto res = isSameTree(p->left, q->left);\n    if (!res) {\n      return false;\n    }\n    res = isSameTree(p->right, q->right);\n    if (!res) {\n      return false;\n    }\n    return true;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315496365","body":"class Solution {\npublic:\n    int sum = 0;\n    int sumNumbers(TreeNode* root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    void dfs(TreeNode* root, int num) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            sum += num * 10 + root->val;\n            return;\n        }\n        dfs(root->left, num * 10 + root->val);\n        dfs(root->right, num * 10 + root->val);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317153858","body":"class Solution {\npublic:\n  int val = 0;\n  int current_max_depth = 0;\n  void findBottomLeftValue_d(TreeNode *root, int depth) {\n    if (root == nullptr) {\n      return;\n    }\n\n    findBottomLeftValue_d(root->left, depth + 1);\n    if (root->left == nullptr && root->right == nullptr) {\n      if (depth > this->current_max_depth) {\n        val = root->val;\n        this->current_max_depth = depth;\n      }\n    }\n    findBottomLeftValue_d(root->right, depth + 1);\n  }\n  int findBottomLeftValue(TreeNode *root) {\n    findBottomLeftValue_d(root, 1);\n    return val;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318767860","body":"  void encode(TreeNode *root, string &s) {\n    if (root == nullptr) { // 空节点在序列化的时候只加上一个逗号\n      s += \",\";\n      return;\n    }\n    s += to_string(root->val) +\n         \",\"; // 非空节点在序列化的时候先加上节点值再加上逗号\n    encode(root->left, s); // 先序遍历序列化二叉树\n    encode(root->right, s);\n  }\n\n  // Encodes a tree to a single string.\n  string serialize(TreeNode *root) {\n    string s;\n    encode(root, s); // 序列化编码的结果记录在字符串s里\n    return s;\n  }\n\n  TreeNode *decode(\n      string &s,\n      int &\n          cur) { // 从字符串s反序列化二叉树，cur是当前解码的字符在字符串s中的下标，这里注意s和cur必须是引用\n    if (s[cur] == ',') { // 如果两个逗号之间什么也没有，说明是空节点\n      ++cur;\n      return nullptr;\n    }\n    int end = cur; // end记录下一个逗号的位置\n    while (end < s.size() && s[end] != ',') {\n      ++end;\n    }\n    TreeNode *root = new TreeNode(stoi(s.substr(\n        cur, end - cur))); // 两个逗号之间的子串的值转为int就是当前节点的值\n    cur = end + 1; // cur从下一个逗号的下一个位置开始解码\n    root->left = decode(s, cur); // 先序遍历解码字符串s\n    root->right = decode(s, cur);\n    return root;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode *deserialize(string data) {\n    int cur = 0; // 从要解码的字符串的第0个字母开始解码\n    TreeNode *root = decode(data, cur);\n    return root;\n  }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320202811","body":"class Solution {\npublic:\n    struct node\n    {\n        int val;\n        int x;\n        int y;\n        node(int v,int X,int Y):val(v),x(X),y(Y){};\n    };\n    static bool cmp(node a,node b)\n    {\n        if(a.x^b.x)\n            return a.x<b.x;\n        if(a.y^b.y)\n            return a.y<b.y;\n        return a.val<b.val;\n    }\n    vector<node> a;\n    int minx=1000,maxx=-1000;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root,0,0);\n        sort(a.begin(),a.end(),cmp);\n        vector<vector<int>>ans(maxx-minx+1);\n        for(auto xx:a)\n        {\n            ans[xx.x-minx].push_back(xx.val);\n        }\n        return ans;\n    }\n    void dfs(TreeNode* root,int x,int y)\n    {\n        if(root==nullptr)\n            return;\n        if(x<minx)\n            minx=x;\n        if(x>maxx)\n            maxx=x;\n        a.push_back(node(root->val,x,y));\n        dfs(root->left,x-1,y+1);\n        dfs(root->right,x+1,y+1);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320904442","body":"func twoSum(nums []int, target int) []int {\n\tfor i, num1 := range nums {\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tif target == (num1 + nums[j]) {\n\t\t\t\treturn []int{i, j}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321018960","body":"class Solution {\nprivate:\n  map<int, int> frep;\n\n  // 最小堆\n  priority_queue<pair<int, int>, vector<pair<int, int>>,\n                 greater<pair<int, int>>>\n      q;\n\npublic:\n  vector<int> topKFrequent(vector<int> &nums, int k) {\n    for (auto it : nums) {\n      frep[it]++;\n    }\n    // 堆中元素为 [频次，数值] 元组，并根据频次维护小顶堆特性\n    for (auto it : frep) {\n      if (q.size() != k) {\n        q.push(make_pair(it.second, it.first));\n      } else {\n        if (it.second > q.top().first) {\n          q.pop();\n          q.push(make_pair(it.second, it.first));\n        }\n      }\n    }\n    vector<int> res;\n    while (q.size()) {\n      res.push_back(q.top().second);\n      q.pop();\n    }\n    return vector<int>(res.rbegin(), res.rend());\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322246046","body":"class Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323864841","body":"class Solution {\nprivate:\n  unordered_map<char, int> map;\n  pair<int, int> p = pair<int, int>(0, -1);\n  int maxLength = 0;\n\npublic:\n  int lengthOfLongestSubstring(string s) {\n    for (auto i = 0; i < s.length(); i++) {\n      auto c = s[i];\n      p.second = i;\n      auto it = map.find(c);\n      if (it == map.end() || it->second < p.first) {\n        map[c] = i;\n      } else {\n        p.first = it->second + 1;\n        it->second = i;\n      }\n\n      maxLength = max(maxLength, p.second - p.first + 1);\n    }\n\n    return maxLength;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325139893","body":"class Solution {\npublic:\n    vector<int> findSubstring(string &s, vector<string> &words) {\n        vector<int> res;\n        int m = words.size(), n = words[0].size(), ls = s.size();\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\n            unordered_map<string, int> differ;\n            for (int j = 0; j < m; ++j) {\n                ++differ[s.substr(i + j * n, n)];\n            }\n            for (string &word: words) {\n                if (--differ[word] == 0) {\n                    differ.erase(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                    word = s.substr(start - n, n);\n                    if (--differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                }\n                if (differ.empty()) {\n                    res.emplace_back(start);\n                }\n            }\n        }\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326451859","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int>predSumModK = {{0, 1}};\n        int sum = 0;\n        int res = 0;\n        for(const auto& x: nums){\n            sum += x;\n            int modK = (sum % k + k) % k; //负数取模为负数\n            predSumModK[modK]++;\n        }\n\n        for(const auto& [modK, count]: predSumModK){\n            res += (count * (count - 1) / 2);\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327516485","body":"class Solution {\npublic:\n  ListNode *middleNode(ListNode *head) {\n    ListNode *p = head;\n    ListNode *q = head;\n\n    while (q != nullptr && q->next != nullptr) {\n      p = p->next;\n      q = q->next->next;\n    }\n\n    return p;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328055804","body":"class Solution {\npublic:\n  int removeDuplicates(vector<int> &nums) {\n    int p = 0;\n    for (int i = 0; i < nums.size(); i++) {\n      if (nums[i] == nums[p]) {\n        continue;\n      }\n      p++;\n      swap(nums[p], nums[i]);\n    }\n    return p + 1;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328242128","body":"class Solution {\npublic:\n  int searchInsert(vector<int> &nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left <= right) {\n      auto mid = (right - left) / 2 + left;\n      if (nums[mid] == target) {\n        return mid;\n      }\n      if (nums[mid] < target)\n        left = mid + 1;\n      else\n        right = mid - 1;\n    }\n    return left;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329229081","body":"class Solution {\npublic:\n    vector<int> res;\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> q; // 双端队列，存储的是当前窗口最大值的索引，维护操作: 保持单调递减，队头是最大值\n\n        for (int i = 0; i < nums.size(); i++) {\n            // 依次地将数组元素加入到队列中\n            // 注意: 确保队列元素间的距离都在k以内\n            if (!q.empty() && i - k + 1 > q.front()) /* 倒着数第k个与队列开头数的index比较。窗口长度>k时，从队列中删掉最前面的数 */\n                q.pop_front();\n            while (!q.empty() && nums[i] >= nums[q.back()])\n                q.pop_back();  /* 不断地把左侧比自己小的数从队列中删掉, 遇到下一个比自己大的数时自己会被删掉。遇到比自己小的数得留着，最终双端队列会成为递减队列。 */\n\n            q.push_back(i);\n            if (i >= k - 1)      // 只要窗口大小 ≥ k 时, 窗口就会有最大值，将其放进res(结果vector)中\n            {\n                res.push_back(nums[q.front()]);\n            }\n        }\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330788372","body":"class Solution {\npublic:\n  int findJudge(int n, vector<vector<int>> &trust) {\n    if (trust.empty() && n == 1)\n      return 1;\n    unordered_map<int, int> count;\n    for (auto &relation : trust) {\n      count[relation[0]] += -1;\n      count[relation[1]] += 1;\n    }\n    for (auto &kvp : count) {\n      if (kvp.second == (n - 1))\n        return kvp.first;\n    }\n    return -1;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332268818","body":"class Solution {\npublic:\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\n        color[curnode] = nowcolor;\n        for (auto& nextnode : g[curnode]) {\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333825986","body":"import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\n\npublic class Solution {\n\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 第 2 步：实例化组和项目的邻接表\n        List<Integer>[] groupAdj = new ArrayList[m];\n        List<Integer>[] itemAdj = new ArrayList[n];\n        for (int i = 0; i < m; i++) {\n            groupAdj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemAdj[i] = new ArrayList<>();\n        }\n\n        // 第 3 步：建图和统计入度数组\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        int len = group.length;\n        for (int i = 0; i < len; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj[beforeGroup].add(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (Integer item : beforeItems.get(i)) {\n                itemAdj[item].add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        // 第 4 步：得到组和项目的拓扑排序结果\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupsList.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemsList.size() == 0) {\n            return new int[0];\n        }\n\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (Integer item : itemsList) {\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        List<Integer> res = new ArrayList<>();\n        for (Integer groupId : groupsList) {\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Integer front = queue.poll();\n            res.add(front);\n            for (int successor : adj[front]) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0) {\n                    queue.offer(successor);\n                }\n            }\n        }\n\n        if (res.size() == n) {\n            return res;\n        }\n        return new ArrayList<>();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335434734","body":"class Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y =0;\n        for (const char move : moves) {\n            if (move == 'R') {\n                x++;\n            }\n            if (move == 'L') {\n                x--;\n            }\n            if (move == 'U') {\n                y++;\n            }\n            if (move == 'D') {\n                y--;\n            }\n        }\n        return x==0 && y==0;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298627092","body":"### 思路\nK+num（个位加个位，十位加十位）\n个位 除 1 取余10，十位 除10 取余 10，百位 除 100 取余10 \n取余数的反转结果集\n[9,9,9,9,9,9,9,9,9,9] 1,报错，超过了int最大值，要么换long，要么换个思路，取余k，而不是给数组内的值\n\n### 代码\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, long k){\n        int numSize = num.length;\n        //[1,8,9,2]  k = 34  1926\n        ArrayList<Integer> rst = new ArrayList<>();\n        for(int i = numSize - 1 ;i >= 0; --i){\n            //36, 90+36 = 126,126 + 800 = 926,926 + 1000 = 1926\n            k += num[i] * Math.pow(10,numSize - i -1);\n            // 36, 12, 9,1\n            int j = (int) (k / Math.pow(10,numSize - i -1));\n            // 6,2,9,1\n            rst.add(j % 10);\n        }\n        //如果K比数组大，还要继续取余\n//        for (int i = )\n        k /= Math.pow(10,numSize);\n        for (;k>0;k/=10){\n            rst.add((int)(k % 10));\n        }\n        Collections.reverse(rst);\n        return rst;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，N为数组的长度，思考：1. N是否可以为K的长度，2. 列表不需要反转\n- 空间复杂度：O(N)，N为集合的长度","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305578942","body":"## 61. 旋转链表\n\n### 思路\n\n 1. 链表长度n，移动k次\n 2. 当k > n又n每移动n次变为原样，链表仅移动k mod n次\n 3. 新链表的最后一个位置为原链表的(n -1) - (k mod n)\n 4. 将链表链接成环，在指定位置断开\n\n### 代码\n\n```java\npublic class Solution {\n\n    public class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode() {\n        }\n\n        ListNode(int val) {\n            this.val = val;\n        }\n\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n\n    public ListNode rotateRight(ListNode head, int k) {\n\n        // 先链接成环\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        // n代表链表的长度\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n\n        // 找到指定位置\n        int add = n - (k % n);\n        // 断开\n        if (add == n) {\n            return head;\n        }\n\n        //尾头相连\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n\n        ListNode ret = iter.next;\n        iter.next = null;\n        // 返回\n\n        return ret;\n    }\n\n\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N),最坏遍历两次\n- 空间复杂度：O(1),常熟个空间存储若干变量","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298659136","body":"```\nvar addToArrayForm = function(num, k) {\n    //使用 BigInt是确保当数组足够长的时候，防止整形的精度丢失\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299694150","body":"```javascript\nvar shortestToChar = function(s, c) {\n    let res = [], arr = []\n    // 拿到所有c的索引值\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == c) arr.push(i)\n    }\n    // 利用双循环比较绝对距离\n    for(let i = 0; i < s.length; i++){\n        let min = +Infinity\n        for(let j = 0; j < arr.length; j++){\n            min = Math.min(Math.abs(i - arr[j]), min)\n        }\n        res.push(min)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302201160","body":"```javascript\n/**\n * @param {number} maxSize\n */\nfunction ListNode(val){\n    this.val=val;\n    this.next=null;\n}\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.head=null;\n    this.length=0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.length===this.maxSize) return;\n    let node=new ListNode(x);\n    let linkList=this.head;\n    node.next=linkList;\n    this.head=node;\n    this.length++;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.length===0) return -1;\n    let linkList=this.head.next;\n    let popVal=this.head.val;\n    this.head=linkList;\n    this.length--;\n    return popVal;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<0) return;\n    let start=this.length-k;\n    let currentNode=this.head;\n    if(start>0){\n        for(let i=0;i<start;++i){\n            currentNode=currentNode.next;\n        }\n    }\n    while(currentNode){\n        currentNode.val+=val;\n        currentNode=currentNode.next;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303743513","body":"```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let r = ''\n    var a = function(t) {\n        const firstClose = t.indexOf(']')\n        if ( firstClose == -1 ) r = t \n        if ( firstClose != -1 ) {\n        const rangeLastOpen =  t.substring(0, firstClose).lastIndexOf('[')\n        var reg = /(\\d+)$/g\n        var z = reg.exec(t.substring(0, rangeLastOpen))\n        if (z) {\n        const zNum = z[0]\n        const changeChars = t.substring(rangeLastOpen + 1, firstClose)\n        const num = parseInt(zNum)\n        let beforechange = ''\n        for(let a = 0; a < num ; a ++) {\n            beforechange += changeChars\n        }\n        const result = t.substring(0, rangeLastOpen - zNum.length) + beforechange + t.substring(firstClose + 1)\n        if (result.indexOf(']') != -1) a(result)\n        if (result.indexOf(']') === -1) r = result\n        }\n        }\n    }\n    a(s)\n    return r;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304554634","body":"```javascript\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    let tmp = this.outStack.pop()\n    this.outStack.push(tmp)\n    return tmp\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.inStack.length && !this.outStack.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304794630","body":"```javascript\nvar maxChunksToSorted = function(arr) {\n    let help = []\n    help[arr.length] = Number.MAX_SAFE_INTEGER\n    for (let i = arr.length - 1; i >= 0; i--) {\n        help[i] = Math.min(arr[i],help[i + 1])\n    }\n    let cnt = 0,mx = -1\n    arr.forEach((val,i) => {\n        mx = Math.max(mx,val)\n        if(mx <= help[i + 1]) cnt++\n    })\n    return cnt\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312478893","body":"```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map()\n    this.max = capacity\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map.has(key)) {\n        const value = this.map.get(key)\n        this.map.delete(key)\n        this.map.set(key, value)\n        return value\n    }\n    return -1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        this.map.delete(key)\n    }\n\n    if (this.map.size === this.max) {\n        const delKey = this.map.keys().next().value\n        this.map.delete(delKey)\n    }\n\n    this.map.set(key, value)\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314948080","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if(root === null) return -1;\n    const findAll = (root, path = []) => {\n        if(root === null) return;\n        path.push(root.val);\n        if(root.left === null && root.right === null) {\n            sum += parseInt(path.join(''));\n        }\n        root.left && findAll(root.left, path);\n        root.right && findAll(root.right, path);\n        path.pop();\n    };\n    let sum = 0;\n    findAll(root);\n    return sum;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319421959","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\n\nvar verticalTraversal = function(root) {\n  let ans = [], temp = []\n  const dfs = (root, row, col) => {\n    if(!root) return\n    row ++\n    temp.push([root.val, row, col])\n    dfs(root.left, row, col - 1)\n    dfs(root.right, row, col + 1)\n  }\n  dfs(root, 0, 0)\n\n  temp.sort((a,b) => a[2] - b[2] || a[1] - b[1] || a[0] - b[0])\n\n  let prev\n\n  for(let [val, , col] of temp){\n    if(col !== prev){\n      prev = col\n      ans.push([])\n    }\n    ans[ans.length -1].push(val)\n  }\n  return ans\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324596957","body":"```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    words = words.sort()\n    var wl = words[0].length;\n    var l = words.length * wl;\n    var res = [];\n    if (s.length < l) return res;\n    const regex = new RegExp(`.{${wl}}`, 'g')\n    for (var i = 0; i < s.length; i+=1) {\n        const ss = (s.substring(i, i+l).match(regex) || []).sort()\n        if (ss.length===words.length && ss.every((_,j) => ss[j]===words[j])) {\n            res.push(i)\n        }\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328407181","body":"```javascript\nvar maxSlidingWindow = function(nums, k) {\n const n = nums.length;\n    const q = [];\n    for (let i = 0; i < k; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n    }\n\n    const ans = [nums[q[0]]];\n    for (let i = k; i < n; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n        while (q[0] <= i - k) {\n            q.shift();\n        }\n        ans.push(nums[q[0]]);\n    }\n    return ans;\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298679459","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300415798","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n);\n        int k = -n;\n        \n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) k = i;\n            ans[i] =i-k;\n            ;\n    \n        }\n    \n    \n        \n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) k = i;\n            ans[i] = min(ans[i], abs(i - k));\n        }\n        return ans;\n    }\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303523803","body":"class Solution {\npublic:\n    string src; \n    size_t ptr;\n\n    int getDigits() {\n        int ret = 0;\n        while (ptr < src.size() && isdigit(src[ptr])) {\n            ret = ret * 10 + src[ptr++] - '0';\n        }\n        return ret;\n    }\n\n    string getString() {\n        if (ptr == src.size() || src[ptr] == ']') {\n            // String -> EPS\n            return \"\";\n        }\n\n        char cur = src[ptr]; int repTime = 1;\n        string ret;\n\n        if (isdigit(cur)) {\n            // String -> Digits [ String ] String\n            // 解析 Digits\n            repTime = getDigits(); \n            // 过滤左括号\n            ++ptr;\n            // 解析 String\n            string str = getString(); \n            // 过滤右括号\n            ++ptr;\n            // 构造字符串\n            while (repTime--) ret += str; \n        } else if (isalpha(cur)) {\n            // String -> Char String\n            // 解析 Char\n            ret = string(1, src[ptr++]);\n        }\n        \n        return ret + getString();\n    }\n\n    string decodeString(string s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304565205","body":"class MyQueue {\npublic:\n    MyQueue() {\n       \n    }\n     stack<int> A; //用来入队\n     stack<int> B; //用来出队\n    \n    void push(int x) {\n        A.push(x);\n    }\n    \n    int pop() {\n        \n        if(B.empty())\n        {\n            while(!A.empty())\n            {\n                B.push(A.top());\n                A.pop();\n            }            \n        }\n        //B栈不空，直接出栈，表示出队\n        int top = B.top();\n        B.pop();\n        return top;\n    }\n    \n    int peek() {\n         if(B.empty())\n        {\n            while(!A.empty())\n            {\n                B.push(A.top());\n                A.pop();\n            }            \n        }\n        return B.top();\n    }\n    \n    bool empty() {\n        return A.empty() && B.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304801035","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i=0; i<arr.size(); i++){\n\n            if(!stack.empty()&&stack.top()>arr[i]){\n\n                int cur = stack.top();\n            \n            \n                while(!stack.empty()&&stack.top()>arr[i]){\n\n                    stack.pop();\n                }\n                stack.push(cur);\n                }\n            else{\n                stack.push(arr[i]);\n            }\n\n        }\n        return stack.size();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305749716","body":"ListNode* rotateRight(ListNode* head, int k) {\n    if (head == nullptr\n        || head->next == nullptr\n        || k == 0)\n        return head;\n\n    int len = 1;\n    ListNode* cur = head;\n    while (cur->next != nullptr) {\n        cur = cur->next;\n        len++;\n    }\n\n    k %= len;\n\n    ListNode* fast = head;\n    ListNode* slow = head;\n\n    while (fast->next != nullptr) {\n        if (k-- <= 0) {\n            slow = slow->next;\n        }\n        fast = fast->next;\n    }\n\n    fast->next = head;\n    ListNode* new_head = slow->next;\n    slow->next = nullptr;\n    return new_head;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307108353","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) \n        return head;\n    ListNode* weito = new ListNode(-1,head);\n    ListNode* pre = weito;\n    ListNode* node = weito->next;\n     \n    while(node && node->next)\n    {\n        ListNode* sec = node->next;//存下第二个节点\n        node->next = sec->next;//第一个节点指向第三个节点\n        sec->next = node;//第二个节点指向第一个节点\n        pre->next = sec;//  前向节点指向新的交换后的节点\n    \n        pre = node;\n        node = node->next;\n        \n\n    }\n    return weito->next;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308861929","body":"class Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail){\n\n        if (head==tail) return nullptr;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast!=tail && fast->next!=tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n\n    }\n\n        \n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310246232","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode* headA, ListNode* headB) {\n        if (headA == NULL || headB == NULL) return NULL;\n    \n    map<ListNode*, bool> seen;\n    while (headA){\n\n        seen.insert(pair<ListNode*, bool>(headA, true));\n        headA = headA->next;\n    }\n    while (headB){\n        if (seen.find(headB) != seen.end()) return headB;\n        headB = headB->next;\n    }\n    return  NULL;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311752099","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *fast = head;\n        ListNode *slow = head;\n\n    while(fast && fast->next){\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast){\n            fast = head;\n        \n        while (slow != fast){\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n        }\n    }\n    return NULL;\n}\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312490640","body":"void afterNodeAccess(Node<K,V> e) { // move node to last\n    // 用 last 表示插入 e 前的尾节点\n    // 插入 e 后 e 是尾节点, 所以也是表示 e 的前一个节点\n    LinkedHashMap.Entry<K,V> last;\n    //如果是访问序，且当前节点并不是尾节点\n    //将该节点置为双向链表的尾部\n    if (accessOrder && (last = tail) != e) {\n        // p: 当前节点\n        // b: 前一个节点\n        // a: 后一个节点\n        // 结构为: b <=> p <=> a\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        // 结构变成: b <=> p <- a\n        p.after = null;\n\n        // 如果当前节点 p 本身是头节点, 那么头结点要改成 a\n        if (b == null)\n            head = a;\n        // 如果 p 不是头尾节点, 把前后节点连接, 变成: b -> a\n        else\n            b.after = a;\n\n        // a 非空, 和 b 连接, 变成: b <- a\n        if (a != null)\n            a.before = b;\n        // 如果 a 为空, 说明 p 是尾节点, b 就是它的前一个节点, 符合 last 的定义\n      \t// 这个 else 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null\n        else\n            last = b;\n\n        // 如果这是空链表, p 改成头结点\n        if (last == null)\n            head = p;\n        // 否则把 p 插入到链表尾部\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312741075","body":"class Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        int ans = 0;\r\n        Deque<TreeNode> d = new ArrayDeque<>();\r\n        if (root != null) d.addLast(root);\r\n        while (!d.isEmpty()) {\r\n            int sz = d.size();\r\n            while (sz-- > 0) {\r\n                TreeNode node = d.pollFirst();\r\n                if (node.left != null) d.addLast(node.left);\r\n                if (node.right != null) d.addLast(node.right);\r\n            }\r\n            ans++;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312991506","body":"先检查当前根节点，再检查当前节点的左右节点；\n然后递归，将左右节点作为根节点，继续检查左右\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q == nullptr) return true;\n        if( p == nullptr && q != nullptr) return false;\n        if(p != nullptr && q == nullptr) return false;\n    return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315331406","body":"class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n    if (root == nullptr){\n        return 0;\n    }\n    dfs(root, root->val);\n    return sum;\n    }\n    int sum = 0;\n    void dfs(TreeNode* root, int cursum){\n        if (root->left == nullptr && root->right == nullptr){\n            sum += cursum;\n            return;\n        }\n        if (root->left != nullptr){\n            dfs(root->left, cursum * 10 + root->left->val);\n        }\n        if (root->right != nullptr){\n            dfs(root->right, cursum * 10 + root->right->val);\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317098556","body":"\npublic class Solution513 {\n \n    public int findBottomLeftValue(TreeNode root) {\n        List<TreeNode> list = new ArrayList<>();\n        list.add(root);\n        TreeNode treeNode = levelSearch(list);\n        return treeNode.val;\n    }\n \n    private TreeNode levelSearch(List<TreeNode> list) {\n        List<TreeNode> nextList = new ArrayList<>();\n        for (TreeNode node : list) {\n            if (node.left != null) {\n                nextList.add(node.left);\n            }\n            if (node.right != null) {\n                nextList.add(node.right);\n            }\n        }\n        if (nextList.size() == 0) {\n            return list.get(0);\n        }\n        return levelSearch(nextList);\n    }\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318587293","body":"public class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) return \"\";\n        StringBuilder res = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode cur = queue.remove();\n            if(cur == null){\n                res.append(\"null,\");\n            }else{\n                res.append(cur.val + \",\");\n                queue.add(cur.left);\n                queue.add(cur.right);\n            }\n        }\n        return res.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data.length() == 0) return null;\n        String[] nodes = data.split(\",\");\n        TreeNode root = getNode(nodes[0]);\n        Queue<TreeNode> queue = new LinkedList();\n        queue.offer(root);\n        int index = 1;\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            if(!nodes[index].equals(\"null\")) {\n                temp.left = getNode(nodes[index]);\n                queue.offer(temp.left);\n            }\n            index++;\n            if(!nodes[index].equals(\"null\")) {\n                temp.right = getNode(nodes[index]);\n                queue.offer(temp.right);\n            }\n            index++;\n        }\n        return root;\n    }\n\n    private TreeNode getNode(String val){\n        if(val.equals(\"null\")){\n            return null;\n        }\n        return new TreeNode(Integer.valueOf(val));\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320169681","body":"public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        // 遍历所有节点信息\n        dfs(root, 0, 0, nodes);\n        // 自定义排序规则\n        Collections.sort(nodes, new Comparator<int[]>(){\n            public int compare(int[] a, int[] b) {\n                if (a[0] != b[0]) {\n                    // 优先按照col升序排序\n                    return a[0] - b[0];\n                }\n                else if (a[1] != b[1]) {\n                    // 其次按照row升序排序\n                    return a[1] - b[1];\n                }\n                else{\n                    // 最后按照节点值升序\n                    return a[2] - b[2];\n                }\n            }\n        });\n        List<List<Integer>> traversal = new ArrayList<List<Integer>>();\n        int col = Integer.MIN_VALUE;\n        int index = -1;\n        for (int[] node : nodes) {\n            int curCol = node[0];\n            // 若当前col已经和之前不同\n            if (col != curCol) {\n                // 更新col\n                col = curCol;\n                // 添加新列表\n                traversal.add(new ArrayList<Integer>());\n                // 更新集合下标\n                index++;\n            }\n            // 存入当前节点\n            traversal.get(index).add(node[2]);\n        }\n        return traversal;\n    }\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null)\n            return;\n        // 添加节点信息\n        nodes.add(new int[]{col, row, node.val});\n        // 递归遍历\n        dfs(node.left, row+1, col-1, nodes);\n        dfs(node.right, row+1, col+1, nodes);\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320894341","body":" class Solution{\n    public:\n    vector<int> twoSum(vector<int> & nums, int target){\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                if(nums[i] + nums[j]==target){\n                    return{i,j};\n                }\n            }\n        }\n        return{};\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321155490","body":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n         unordered_map<int,int> mp;      //先计算每个元素的频数\n        int length=nums.size();\n        for(int i=0;i<length;i++){\n            mp[nums[i]]++;\n        }\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > heap;       //利用 优先队列 进行排序\n        for(auto j:mp){\n            heap.push(make_pair(j.second,j.first));\n            if(heap.size()>k){\n                heap.pop();\n            }\n        }\n        vector<int> arr;            //将符合题意的元素放入数组arr中，并返回结果\n        for(int i=0;i<k;i++){\n            arr.push_back(heap.top().second);\n            heap.pop();\n        }\n        return arr;\n\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323790025","body":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        StringBuilder stringBuilder = new StringBuilder();\n        int l = 0;\n        for (int i = 0; i < s.length(); i++) {\n            String c = String.valueOf(s.charAt(i));\n            if (stringBuilder.indexOf(c) >= 0) {\n                stringBuilder.delete(0, stringBuilder.indexOf(c) + 1);\n            }\n            stringBuilder.append(c);\n            l = Math.max(stringBuilder.length(), l);\n        }\n        return l;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325238307","body":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m,w = len(words),len(words[0])\n        M = {}\n        for it in words:\n            if it not in M.keys(): M[it] = 1\n            else: M[it] += 1\n        for i in range(w):\n            S = {}\n            j,cnt = i,0\n            while j + w <= len(s):\n                if w * m <= j:\n                    t = s[j - w * m : j - w * (m - 1)]\n                    S[t] -= 1\n                    if t in M.keys() and S[t] < M[t]: cnt -= 1\n                t = s[j:j + w]\n                if t not in S.keys(): S[t] = 1\n                else: S[t] += 1\n                if t in M.keys() and S[t] <= M[t]:cnt += 1\n                if m == cnt:\n                    res.append(j - w * (m - 1))\n                j += w\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326498818","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int count = 0;\n        unordered_map<int,int> hash;\n        hash[0] = 1;   //自身能被整除需要直接计数\n        int cursum = 0;\n        for(int i = 0;i<nums.size();i++){\n            cursum += nums[i];\n            int mod = (cursum%k+k)%k;\n            if(hash.count(mod)) count += hash[mod];\n            hash[mod]++;\n        }\n        return count;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327519648","body":"struct ListNode* middleNode(struct ListNode* head){\n    struct ListNode* cur = head;\n    int count = 0;\n\n    //统计链表结点个数\n    while(cur !=NULL)\n    {\n        count++;\n        cur = cur->next;\n    }\n\n    int n = 0;\n    cur = head;\n\t//迭代走到中间的结点！\n    while(n <count/2)\n    {\n        n++;\n        cur = cur->next;\n    }\n    return cur;\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328244040","body":"\n\nfunc searchInsert(nums []int, target int) int {\n    l,r:=0,len(nums)-1\n    var mid int\n    for l<=r{\n        mid =l+(r-l)>>1\n        switch{\n            case nums[mid]<target:\n            l=mid+1\n            case nums[mid]>target:\n            r=mid-1\n            default :\n            return mid\n\n        }\n\n    } \n    return l\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329198768","body":"public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0)\n            return new int[0];\n \n        int[] arr = new int[nums.length - k + 1];\n        LinkedList<Integer> list = new LinkedList<>();\n \n        for (int index = 0, i = 0; i < nums.length; i++) {\n            while (!list.isEmpty() && nums[list.peekLast()] < nums[i]) {\n                list.pollLast();\n            }\n            list.add(i);\n            if (list.peek() == i - k) {\n                list.poll();\n            }\n            if (i >= k - 1) {\n                arr[index++] = nums[list.peek()];\n            }\n        }\n        return arr;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330679297","body":"class Solution {\npublic:\n    int findJudge(int N, vector<vector<int>>& trust) {\n        vector<unordered_set<int>> g1(N+1);     //信任别人的人 --> 出度\n        vector<unordered_set<int>> g2(N+1);     //被信任的人 --> 入度\n        for(const auto& t: trust){\n            g1[t[0]].insert(t[1]);\n            g2[t[1]].insert(t[0]);\n        }\n        int res = -1;\n        for(int i = 1; i <= N; i++){\n            if(g2[i].size() == N-1 && g1[i].size() == 0){\n                res = i;\n                // return i;\n                break;\n            }\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332250464","body":"class Solution {\npublic:\n    vector<int> colors;\n    map<int,vector<int>> mp;\n    bool dfs(int i , int color){\n        //设置当前人物的颜色\n        colors[i] = color;\n        for(int index : mp[i]){\n            if(colors[index] == color) // 和下个人物颜色相同\n                return false;\n            if(colors[index] == 0 && !dfs(index,-color))    //未被染色则进行染色\n                return false;\n        }\n        return true;\n    }\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        if(dislikes.size() == 0 )\n            return true;\n        colors.resize(N+1);\n        // 记录不共存的值\n        for(vector<int> dislike : dislikes){\n            mp[dislike[0]].push_back(dislike[1]);\n            mp[dislike[1]].push_back(dislike[0]);\n        }\n        //开始染色\n        for(int i = 1; i <= N; i ++){\n            if(colors[i] == 0 && !dfs(i,1))\n                return false;\n        }\n        return true;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298682601","body":"#思路\n对于数组A从右到左遍历，整数K也是从右到左遍历，逐位相加，注意需要两个辅助元素，1个记录进位的数，1个记录非进位数\n\n#代码\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        result = []\n        n, carry = len(num) - 1, 0\n        while n >= 0 or k != 0:\n            x = num[n] if n >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            result.append(sum % 10)\n            carry = sum // 10\n\n            n -= 1\n            k //= 10\n        if carry != 0: result.append(carry)\n        return result[::-1]\n\n#复杂度分析\n-时间复杂度 O(N)   【N是数组数组A与K的长度取最大值】\n-空间复杂度 O(N)      \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299663114","body":"#思路\n两次遍历，1）从左到右遍历，找到s中每个字符到其左侧最近的c的距离 2）从右到左遍历，找到s中每个字符到其右侧最近的c的距离\n#代码\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        answer = [0 if s[i]== c else None for i in range(n)]\n        #left\n        idx = -n\n        for i in range(n):\n            if s[i] == c:\n                idx = i \n            answer[i] = abs(i-idx)\n        #right\n        idx = 2*n\n        for i in range(n-1,-1,-1):\n            if s[i] == c:\n                idx = i\n            answer[i] = min(answer[i], idx - i)\n\n        return answer\n\n\n#复杂度分析\n-时间复杂度 O(N)  N是字符串s的长度\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301830289","body":"# 思路\n用数组模拟栈，用top变量来记录栈顶位置。\n\n# 代码\n```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x):\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n    \n    def pop(self):\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stack[self.top + 1]\n    \n    def increment(self, k, val):\n        inc_num = min(k, self.top + 1)\n        for i in range(inc_num):\n            self.stack[i] += val\n```\n\n# 复杂度分析\n## 时间复杂度： \npush, pop, 初始化 都是O(1), increment是O(k)\n## 空间复杂度：\nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302477429","body":"# 思路：\n利用栈 后入先出的思想\n\n# 代码：\n````python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        multi = 0\n        for item in s:\n            if item == '[':\n                stack.append([res, multi])\n                res = \"\"\n                multi = 0\n            elif item == ']':\n                last_res, cur_multi = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <=item <= '9':\n                multi = multi * 10 + int(item)\n            else:\n                 res += item\n        return res\n```\n\n# 复杂度分析\n   -时间复杂度 O(n) n是数组s的长度\n   -空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304539420","body":"232. 用栈实现队列\n#  思路\n栈：后入先出但是队列却是 先入先出，因此要实现队列，需要用两个栈，输入栈 和输出栈。\n把元素push到输入栈之后，输入的顺序会颠倒。因此，需要从输入栈pop，然后push到输出栈，这样顺序就是输入的顺序了，也就是实现了队列。\n\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        return self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n\n    def empty(self) -> bool:\n        print(self.stack2)\n        print(self.stack1)\n        print(not self.stack2)\n        print(not self.stack1)\n        return not self.stack2 and not self.stack1\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n# 复杂度分析\n-时间复杂度 push和empty 是O(1)  pop and peek 是O(N)\n-空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823907","body":"# 思路\n用一个栈来储存每一个分组的最大值\n\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if len(stack) == 0 or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(mx)\n        return len(stack)\n```\n# 复杂度分析\n-时间复杂度 O(n) 因为是遍历，所以时间复杂度是O(n) n是数组长度\n\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305184882","body":"#  思路\n首先找到链表的倒数第k+1个节点，然后将链表的倒数第k+1个节点与倒数第k个节点分开，把后半部分拼接到链表头部\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        n_len = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            n_len += 1\n        \n        k %= n_len\n        if k == 0:\n            return head\n        fast, slow = head, head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            fast, slow = fast.next, slow.next\n        \n        newHead = slow.next\n        slow.next = None\n        fast.next = head\n        return newHead \n```\n\n# 复杂度分析\n-时间复杂度 O(N) N是链表长度\n\n-空间复杂度分析 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306638105","body":"# 思路\n迭代的方法\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy_head = ListNode(0)\n        dummy_head.next = head\n        temp = dummy_head\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return dummy_head.next\n```\n# 复杂度分析\n-时间复杂度 O(N)\n\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308243117","body":"# 思路\n找到链表的中间节点作为根节点，再找到中点两边的子链的中点，递归\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMedian(left: ListNode, right: ListNode)->ListNode:\n            fast = left\n            slow = left \n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left:ListNode, right: ListNode)-> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        return buildTree(head, None)\n```\n# 复杂度分析\n-时间复杂度 O(Nlog(N))\n\n-空间复杂度 O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309767084","body":"# 思路\n假设链表A的长度为a，链表B的长度为b，二者公共部分的长度为c。\n定义两个指针A，B。A从headA出发遍历到链表A结尾，再从链表B出发，走b-c步；B从headB出发遍历完链表B，再从链表A出发走a-c步。\n于是A走了 a+(b-c) 步，B也走了b+(a-c)步。二者相遇。\n如果c>0, A,B 同时指向相遇的节点；\n如果c=0，A，B同时指向None。于是返回A即可。\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        A = headA\n        B = headB\n        while A!=B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n# 复杂度分析\n-时间复杂度：O(m+n) m+n 是链表A+B的长度\n\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311237062","body":"# 思路\n快慢指针。定义两个指针，快指针：一次移动两步，慢指针：一次移动一步。\n1）如果移动过程中，快指针指向null或者快指针.next指向null，则没有环，return None。\n2）如果上述情况不会发生，则有环。fast与slow第一次相遇（注意相遇不一定就相遇在环入口），则fast 走了2s步，slow走了s步，假设环前有a个节点，环内有b个节点。则2s-s=nb；于是s=nb\n如何让指针指向环入口呢？只要slow指针再走a步即可。\n3）让fast回到头部，然后fast每次移动一步，slow每次移动一步，如果fast与slow相遇，则slow一共走了a+nb步，此时指向环的入口。返回slow即可。\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while True:\n            if not(fast and fast.next):\n                return None\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        fast = head\n        while fast!= slow:\n            fast = fast.next\n            slow = slow.next\n        return slow \n```\n# 复杂度分析\n-时间复杂度：O(N)\n\n-空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312477485","body":"# 思路\n哈希+双链表\n\n\n# 代码\n```python \nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = dict()\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n\n\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                tail_node = self.removeTail()\n                self.cache.pop(tail_node.key)\n                self.size -= 1\n        \n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n\n    \n    def addToHead(self, node):\n        node.next = self.head.next \n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.next.prev = node.prev\n        node.prev.next = node.next \n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node \n```\n# 复杂度分析\n-时间复杂度分析： put和get都是O(1)\n\n-空间复杂度分析: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312633115","body":"# 思路\n递归\n\n# 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1\n```\n# 复杂度分析\n-时间复杂度O(n) n是二叉树节点的个数\n\n-空间复杂度O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312776850","body":"# 思路\n迭代\n\n# 代码\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif p is None and q is not None:\n            return False\n        elif p is not None and q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n# 复杂度分析\n-时间复杂度分析： O(\\min(m,n))O(min(m,n))，其中 mm 和 nn 分别是两个二叉树的节点数\n\n-空间复杂度分析  O(\\min(m,n))O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315473617","body":"# 思路 \n深度优先搜索\n\n# 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n```\n# 复杂度分析\n-时间复杂度 O(n)，其中 n是二叉树的节点个数\n\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317244103","body":"# 思路 递归\n# 代码\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n\n# 时间复杂度分析\n-时间复杂度：O(n) 其中 n是二叉树的节点个数\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318834097","body":"# 思路 \nbfs\n# 代码\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        queue = collections.deque([root])\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                res.append('None')\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        dataList = data[1:-1].split(',')\n        root = TreeNode(int(dataList[0]))\n        queue = collections.deque([root])\n        i = 1\n        while queue:\n            node = queue.popleft()\n            if dataList[i] != 'None':\n                node.left = TreeNode(int(dataList[i]))\n                queue.append(node.left)\n            i += 1\n            if dataList[i] != 'None':\n                node.right = TreeNode(int(dataList[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n\n# 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1318894827","body":"#思路 \nbfs\n# 代码\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        queue = collections.deque([[root, 0, 0]])\n        hashmap = collections.defaultdict(list)\n        \n        while queue:\n            node, j, i = queue.popleft()\n            hashmap[(j, i)].append(node.val)\n            if node.left:\n                queue.append([node.left, j - 1, i + 1])\n            if node.right:\n                queue.append([node.right, j + 1, i + 1])\n\n      \n        res, tmp= [], []\n        j_flag = -1001\n        for j, i in sorted(hashmap.keys()):\n            if j != j_flag:\n                res.append(tmp)\n                tmp = []\n                j_flag = j\n            tmp.extend(sorted(hashmap[(j, i)]))\n        res.pop(0)\n        res.append(tmp)\n        return res\n\n# 复杂度分析\n-时间复杂度 O(nlogn)\n-空间复杂度分析 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320904098","body":"# 思路\n哈希表\n# 代码\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n_len = len(nums)\n        hashtable = dict()\n\n        for i, elem in enumerate(nums):\n            if target - elem in hashtable:\n                return [hashtable[target-elem], i]\n            \n            else:\n                hashtable[elem] = i\n        return []\n# 复杂度分析 \n-时间复杂度 O(N) \n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320915931","body":"# 思路\n快排\n# 代码\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = collections.Counter(nums)\n        num_cnt = list(count.items())\n        topKs = self.findTopK(num_cnt, k, 0, len(num_cnt) - 1)\n        return [item[0] for item in topKs]\n    \n    def findTopK(self, num_cnt, k, low, high):\n        pivot = random.randint(low, high)\n        num_cnt[low], num_cnt[pivot] = num_cnt[pivot], num_cnt[low]\n        base = num_cnt[low][1]\n        i = low\n        for j in range(low + 1, high + 1):\n            if num_cnt[j][1] > base:\n                num_cnt[i + 1], num_cnt[j] = num_cnt[j], num_cnt[i + 1]\n                i += 1\n        num_cnt[low], num_cnt[i] = num_cnt[i], num_cnt[low]\n        if i == k - 1:\n            return num_cnt[:k]\n        elif i > k - 1:\n            return self.findTopK(num_cnt, k, low, i - 1)\n        else:\n            return self.findTopK(num_cnt, k, i + 1, high)\n\n# 复杂度分析\n-时间复杂度 平均O(n)\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322124900","body":"# 思路\n枚举+哈希表\n# 代码\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n# 复杂度分析\n-时间复杂度 O(n^2)\n-空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323911075","body":"# 思路\n滑动窗口\n\n# 代码\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_len -= 1\n            if cur_len > max_len:max_len = cur_len\n            lookup.add(s[i])\n        return max_len\n\n# 复杂度分析\n-时间复杂度 O(N)\n-空间复杂度 O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1326615419","body":"# 思路\r\n滑动窗口\r\n# 代码\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        res = []\r\n        m, n, ls = len(words), len(words[0]), len(s)\r\n        for i in range(n):\r\n            if i + m * n > ls:\r\n                break\r\n            differ = Counter()\r\n            for j in range(m):\r\n                word = s[i + j * n: i + (j + 1) * n]\r\n                differ[word] += 1\r\n            for word in words:\r\n                differ[word] -= 1\r\n                if differ[word] == 0:\r\n                    del differ[word]\r\n            for start in range(i, ls - m * n + 1, n):\r\n                if start != i:\r\n                    word = s[start + (m - 1) * n: start + m * n]\r\n                    differ[word] += 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                    word = s[start - n: start]\r\n                    differ[word] -= 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                if len(differ) == 0:\r\n                    res.append(start)\r\n        return res\r\n\r\n# 复杂度分析\r\n- 时间复杂度分析 O(s的长度 * words中单词的长度)\r\n- 空间复杂度分析 O（words中单词个数*words中单词的长度）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326610914","body":"# 思路\r\n哈希表\r\n# 代码\r\nclass Solution:\r\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\r\n        record = {0: 1}\r\n        total = 0\r\n        answer = 0\r\n        for item in nums:\r\n            total += item\r\n            modulus = total % k\r\n            same = record.get(modulus, 0)\r\n            answer += same\r\n            record[modulus] = same + 1\r\n        return answer\r\n# 复杂度分析\r\n-时间复杂度 O(n)\r\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326618133","body":"# 思路\r\n快慢指针\r\n\r\n# 代码\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n\r\n# 复杂度分析\r\n-时间复杂度 O(n)\r\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327658009","body":"# 思路\r\n快慢指针\r\n\r\n# 代码\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        \r\n        n = len(nums)\r\n        fast = slow = 1\r\n        while fast < n:\r\n            if nums[fast] != nums[fast - 1]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        \r\n        return slow\r\n# 复杂度分析\r\n-时间复杂度 O(n)\r\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328287641","body":"# 思路 \r\n二分查找\r\n# 代码\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left, right = 0, len(nums) \r\n        while left < right:\r\n            mid = left + (right - left)\r\n            if nums[mid] < target: \r\n                left = mid + 1 \r\n            else:\r\n                right = mid \r\n        return left\r\n\r\n# 复杂度分析\r\n-时间复杂度O(logn)\r\n-空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328288182","body":"# 思路\r\n优先队列\r\n# 代码\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        n = len(nums)\r\n        q = [(-nums[i], i) for i in range(k)]\r\n        heapq.heapify(q)\r\n\r\n        ans = [-q[0][0]]\r\n        for i in range(k, n):\r\n            heapq.heappush(q, (-nums[i], i))\r\n            while q[0][1] <= i - k:\r\n                heapq.heappop(q)\r\n            ans.append(-q[0][0])\r\n        \r\n        return ans\r\n\r\n# 复杂度分析\r\n-时间复杂度O(nlogn)\r\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329299144","body":"# 思路\r\n数组\r\n# 代码\r\nclass Solution:\r\n     def findJudge(self, N, trust):\r\n        in_degree = [0] * (N + 1)\r\n        out_degree = [0] * (N + 1)\r\n        for a, b in trust:\r\n            in_degree[b] += 1\r\n            out_degree[a] += 1\r\n        for i in range(1, N + 1):\r\n            if in_degree[i] == N - 1 and out_degree[i] == 0:\r\n                return i\r\n        return -1\r\n\r\n# 复杂度分析\r\n-时间复杂度O(N)\r\n-空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1330925701","body":"# 思路\r\n深度优先搜索\r\n# 代码\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = [[] for _ in range(n)]\r\n        for x, y in dislikes:\r\n            g[x - 1].append(y - 1)\r\n            g[y - 1].append(x - 1)\r\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\r\n        def dfs(x: int, c: int) -> bool:\r\n            color[x] = c\r\n            return all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\r\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\r\n\r\n# 复杂度分析\r\n-时间复杂度 O(m+n)\r\n-空间复杂度O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333076276","body":"# 思路\r\n# 代码\r\n···python\r\nclass Solution:\r\n    def topological_sort(self,items,indegree,neighbors):\r\n        # 建立队列和访问顺序\r\n        queue = collections.deque()\r\n        res = []\r\n        \r\n        # 初始化队列\r\n        for item in items:\r\n            if not indegree[item]:\r\n                queue.append(item)\r\n                \r\n        if not queue: return []\r\n        \r\n        # BFS\r\n        while queue:\r\n            cur = queue.popleft()\r\n            res.append(cur)\r\n            \r\n            # 遍历邻居节点\r\n            for neighbor in neighbors[cur]:\r\n                indegree[neighbor] -= 1\r\n                if not indegree[neighbor]:\r\n                    queue.append(neighbor)\r\n                    \r\n        return res\r\n    \r\n    \r\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n        for task in range(n):\r\n            if group[task] == -1:\r\n                group[task] = max_group_id\r\n                max_group_id += 1\r\n                \r\n        task_indegree = [0] * n    \r\n        group_indegree = [0] * max_group_id\r\n        task_neighbors = [[] for _ in range(n)]\r\n        group_neighbors = [[] for _ in range(max_group_id)]\r\n        group_to_tasks = [[] for _ in range(max_group_id)]\r\n        \r\n        for task in range(n):\r\n            group_to_tasks[group[task]].append(task)\r\n            \r\n            for prerequisite in beforeItems[task]:\r\n                \r\n                # 判断相关联的两个项目是否属于同一组\r\n                if group[prerequisite] != group[task]:\r\n                    \r\n                    # 不是同组，给小组建图\r\n                    group_indegree[group[task]] += 1\r\n                    group_neighbors[group[prerequisite]].append(group[task])\r\n                else:\r\n                    # 同组，给组内项目建图\r\n                    task_indegree[task] += 1\r\n                    task_neighbors[prerequisite].append(task)\r\n                    \r\n\r\n        res = []\r\n        \r\n        # 得到小组的访问顺序\r\n        group_queue = self.topological_sort([i for i in range(max_group_id)],group_indegree,group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id: return []\r\n        \r\n        for group_id in group_queue:\r\n            # 得到每组项目的访问顺序\r\n            task_queue = self.topological_sort(group_to_tasks[group_id],task_indegree,task_neighbors)\r\n\r\n            if len(task_queue) != len(group_to_tasks[group_id]):\r\n                return []\r\n            res += task_queue\r\n                    \r\n        return res\r\n···\r\n# 复杂度分析\r\n-时间复杂度O(m + n)\r\n-空间复杂度O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334533676","body":"# 思路\r\n模拟\r\n# 代码\r\n`class Solution(object):\r\n    def judgeCircle(self, moves):\r\n        x = y = 0\r\n        for move in moves:\r\n            if move == 'U': y -= 1\r\n            elif move == 'D': y += 1\r\n            elif move == 'L': x -= 1\r\n            elif move == 'R': x += 1\r\n\r\n        return x == y == 0\r\n`\r\n# 复杂度分析\r\n-时间复杂度 O(N)\r\n-空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298687572","body":"//一开始想复杂了，想着要把array转成数字然后做加法然后再将数字转成array，直到case 9999999999 超过int 范围之后发现这么做不好\r\n\r\n代码：\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> list = new ArrayList<Integer>();\r\n        int i = n - 1,sum = 0,carry = 0,remainder = 0;\r\n        while ( (i >= 0)|| k != 0 )\r\n        {\r\n            int origin = i >= 0 ? num[i] : 0;\r\n            remainder = k != 0 ? k % 10 : 0;\r\n            \r\n            sum = origin + remainder + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n            list.add(0,sum%10);\r\n        }\r\n        if(carry!=0)\r\n            list.add(0,carry);\r\n        \r\n        return list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299972946","body":"思路：双指针\r\n代码：\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, n);\r\n        int last = -n;\r\n        for(int i = 0; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                for(int j = i; j >= Math.max(0, (i + last - 1) / 2); j--)\r\n                    ans[j] = Math.min(ans[j], i - j);\r\n                last = i;\r\n            } else\r\n                ans[i] = Math.min(ans[i], i - last);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302253415","body":"```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303551874","body":"\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n    private String[] dfs(String s, int i) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        while(i < s.length()) {\r\n            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') \r\n                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); \r\n            else if(s.charAt(i) == '[') {\r\n                String[] tmp = dfs(s, i + 1);\r\n                i = Integer.parseInt(tmp[0]);\r\n                while(multi > 0) {\r\n                    res.append(tmp[1]);\r\n                    multi--;\r\n                }\r\n            }\r\n            else if(s.charAt(i) == ']') \r\n                return new String[] { String.valueOf(i), res.toString() };\r\n            else \r\n                res.append(String.valueOf(s.charAt(i)));\r\n            i++;\r\n        }\r\n        return new String[] { res.toString() };\r\n    } \r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304701683","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        long res = 0, sum1 = 0, sum2 = 0;\r\n        vector<int> expect = arr;\r\n        sort(expect.begin(), expect.end());\r\n        for (int i = 0; i < arr.size(); ++i) {\r\n            sum1 += arr[i];\r\n            sum2 += expect[i];\r\n            if (sum1 == sum2) ++res;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307224517","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308959425","body":"```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = findMid(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode findMid(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310203592","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A = headA, B = headB;\r\n        while (A != B) {\r\n            A = A != null ? A.next : headB;\r\n            B = B != null ? B.next : headA;\r\n        }\r\n        return A;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311599182","body":"```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n        while(fast != null && fast.next != null){\r\n            slow = slow. Next;\r\n            fast = fast.next.next;\r\n            // 第一次相遇\r\n            if(slow == fast){\r\n                fast = head;\r\n                while(true){\r\n                    // 第二次相遇\r\n                    if(slow == fast) return slow;\r\n                    slow = slow. Next;\r\n                    fast = fast. Next;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298691583","body":"采用逐位相加，大于10进1\n\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int *res = malloc(sizeof(int)* fmax(10,numSize+1));\n    *returnSize = 0;\n    for(int i = numSize -1; i>=0;--i)\n    {\n        int sum = num[i]+k%10;\n        k /= 10;\n        if(sum>=10)\n        {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for(;k>0;k /= 10)\n    {\n        res[(*returnSize)++] = k % 10;\n    }\n    for(int i =0;i<(*returnSize)/2;i++)\n    {\n        int tmp = res[i];\n        res[i] = res[(*returnSize)-1-i];\n        res[(*returnSize)-1-i] = tmp;\n    }\n    return res;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298710908","body":"var addToArrayForm = function (A, K) {\r\n    const res = []\r\n    let i = A.length - 1;\r\n    while (i >= 0 || K > 0) {\r\n        if (i >= 0) {\r\n            // A[i]有值时，加入\r\n            K += A[i];\r\n            i--;\r\n        }\r\n        // 使用push，然后reverse反转，比unshift稍快\r\n        res.push(K % 10);\r\n        K = parseInt(K / 10);\r\n    }\r\n    return res.reverse();\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300700229","body":"var shortestToChar = function(S, C) {\r\n let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307369946","body":"var swapPairs = function(head) {\r\n    if(!head)return null\r\n    if(!head.next)return head\r\n    let arr=[]\r\n    while(head!==null){\r\n        arr.push(head.val)\r\n        head=head.next\r\n    }\r\n    let len=arr.length\r\n    let result=new ListNode(-1)\r\n    let tmp=result\r\n    for(let i=0;i<len;i+=2){\r\n        if(arr[i+1]!==undefined){\r\n            tmp.next=new ListNode(arr[i+1])\r\n            tmp=tmp.next\r\n        }\r\n        tmp.next=new ListNode(arr[i])\r\n        tmp=tmp.next\r\n    }\r\n    return result.next\r\n};\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312757021","body":"function maxDepth(root) {\r\n    // 终止条件\r\n    if (root === null) return 0;\r\n\r\n    // 函数主功能\r\n    let leftDepth = maxDepth(root.left);\r\n    let rightDepth = maxDepth(root.right);\r\n\r\n    return Math.max(leftDepth, rightDepth) + 1;\r\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321167103","body":"function topKFrequent(nums: number[], k: number): number[] {\r\n    const map = new Map<number, number>()\r\n\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (!map.has(nums[i])) {\r\n            map.set(nums[i], 1)\r\n        } else {\r\n            let count = map.get(nums[i]) as number\r\n            map.set(nums[i], count + 1)\r\n        }\r\n    }\r\n\r\n    const arr = Array.from(map)\r\n    arr.sort((a, b) => b[1] - a[1])\r\n\r\n    const result = arr.map((v) => v[0])\r\n    // console.log(result.slice(0, k))\r\n\r\n    return result.slice(0, k)\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298713019","body":"**思路** \r\n一开始想的是大数相加，最后需要按位相加，并考虑到进位情况，\r\n细节点：num长度比k长，或者k的长度比num长度长\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let res = [];\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    // 每次都取k的最低位\r\n    let sum = num[i] + (k % 10);\r\n    // 取完一位最低位之后就除10，保证下次取的最低位是倒数第2位\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      // 有进位，进位放到k中，这样不仅仅少了一个变量，后面的逻辑也更简化\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.unshift(sum);\r\n  }\r\n  // num中所有数字都加完了之后，如果k中还有剩余再把k的加上\r\n  while (k > 0) {\r\n    res.unshift(k % 10);\r\n    k = Math.floor(k / 10);\r\n  }\r\n  return res;\r\n};\r\n```\r\nO(n)O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300430884","body":"```js\r\n// from xiaoranzi\r\n// n为S的length，m为C在S中的数量\r\n// 时间复杂度：O(nm)O(nm)\r\n// 空间复杂度：O(nm)O(nm)\r\nvar shortestToChar = function (S, C) {\r\n    const res = Array(S.length)\r\n    const indexArr = []\r\n    const maxVal = Infinity;\r\n    // 得到所有的c的坐标位置 存入indexArr\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    // 更新每个位置距离 每个indx坐标的位置\r\n    // 初始值为无穷大，不断更新res[i]元素的值\r\n    for (let i = 0; i < S.length; i++) {\r\n        res[i] = indexArr.reduce((tmp, item) => {\r\n            return Math.min(tmp, Math.abs(i - item))\r\n        }, maxVal)\r\n    }\r\n    return res\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302296378","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if( this.arr.length < this.maxSize ) this.arr.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if( this.arr.length == 0 ) return -1\r\n    return ( (this.arr).splice(this.arr.length - 1 , 1) )[0]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if( this.arr.length < k ){\r\n        for( let i = 0 ; i < this.arr.length ; i++ ){\r\n            (this.arr)[i] = (this.arr)[i] + val\r\n        }\r\n    }else{\r\n        for( let i = 0 ; i < k ; i++ ){\r\n            (this.arr)[i] = (this.arr)[i] + val\r\n        }\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308082230","body":"```js\r\nconst sortedListToBST = (head) => {\r\n  const arr = [];\r\n  while (head) { // 将链表节点的值逐个推入数组arr\r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  // 根据索引start到end的子数组构建子树\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\r\n    const mid = (start + end) >>> 1;     // 求中间索引 中间元素是根节点的值\r\n    const root = new TreeNode(arr[mid]); // 创建根节点\r\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\r\n    return root;                          // 返回当前子树\r\n  };\r\n\r\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\r\n};\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313862308","body":"\r\n```js\r\nvar isSameTree = function(p, q) {\r\n    function bst(rootP,rootQ){\r\n        if(rootP === null && rootQ === null){\r\n            return true;\r\n        }\r\n        if(rootP === null && rootQ !== null){\r\n            return false;\r\n        }\r\n        if(rootP !== null && rootQ === null){\r\n            return false;\r\n        }\r\n        if(rootP.val !== rootQ.val){\r\n            return false;\r\n        }\r\n        \r\n        return bst(rootP.left,rootQ.left) && bst(rootP.right,rootQ.right);\r\n    }\r\n    \r\n    return bst(p, q)\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327617042","body":"```js\r\n\r\nvar middleNode = function(head) {\r\n    let slow = head, fast = head;\r\n    let len = 0;\r\n    while(fast.next){\r\n        fast = fast.next;\r\n        len++;\r\n    }\r\n    for(let i = 0;i<len/2;i++){\r\n        slow = slow.next;\r\n    }\r\n    return slow;\r\n};\r\n```\r\n复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1329229134","body":"\r\n\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    while(left <= right){\r\n        let mid =Math.floor((left + right) / 2);\r\n        if(target === nums[mid]){\r\n            return mid\r\n        }else if(target < nums[mid]){\r\n            right = mid - 1;\r\n        }else{\r\n            left = mid + 1;\r\n        }\r\n    }\r\n    return left;\r\n};\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329274162","body":"var maxSlidingWindow = function(nums, k) {\r\n    const queue = [],\r\n          result = []\r\n    for (let i = 0; i < nums.length; i++) {\r\n        // 如果队列不为空，且要入队的元素大于队尾元素, 队尾元素出队\r\n        while (queue.length > 0 && nums[i] > nums[queue[queue.length - 1]]) {\r\n            queue.pop()\r\n        }\r\n        queue.push(i)\r\n\r\n        // j 是把 i 为作为滑动窗口最后一个值时滑动窗口第一个值的索引\r\n        const j = i - k + 1\r\n        // j >= 0 说明滑动窗口已构建完毕\r\n        if (j >= 0) {\r\n            // 当队首元素不属于当前滑动窗口时出队\r\n            if (queue[0] < j) queue.shift()\r\n            // 把队首元素添加到结果数组中\r\n            result.push(nums[queue[0]])\r\n        }\r\n    }\r\n    return result\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298724244","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\".join(list(map(str, num)))\n        return [int(i) for i in str(int(s) + k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300621317","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strs = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                strs.append(i)\n        \n        res = []\n        for i, ch in enumerate(s):\n            mini = float('inf')\n            for j in strs:\n                mini = min(mini, abs(i-j))\n            res.append(mini)\n            \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304562922","body":"### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 =[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            for i in range(len(self.stack1)):\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stack2.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stack1 or self.stack2)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829993","body":"### 思路\n单调栈，维护每个块的最大值\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                pivot = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(pivot)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305478463","body":"### 思路\n等价于是从第N个节点截断，当作链表头，将前面的链表接到后面\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head  \n\n        node_length = 0\n        yummy = head  \n        while yummy:\n            node_length += 1\n            yummy = yummy.next \n        \n        if k % node_length == 0:\n            return head  \n\n        k = node_length - k % node_length\n        slow, fast = head, head  \n\n        while k != 1:\n            k -= 1\n            fast = fast.next \n        new_start = fast.next\n        fast.next = None  \n\n        new_tail = new_start\n\n        while new_tail and new_tail.next:\n            new_tail = new_tail.next \n        new_tail.next = slow \n        return new_start\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312661078","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313538654","body":"### 代码\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True \n        if not p or not q or p.val != q.val:\n            return False\n\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321750210","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n\n        for i, (x, y) in enumerate(points):\n            hashdict = collections.defaultdict(list)\n            for j, (x1, y1) in enumerate(points):\n                if j == i:\n                    continue \n                \n                dis = (x-x1)**2 + (y-y1)**2\n                hashdict[dis].append((x1,y1))\n            \n            for k, v in hashdict.items():\n                if len(v) > 1:\n                    res += len(v)*(len(v)-1)\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326934522","body":"### 思路\n快慢指针\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head \n        while fast and fast.next:\n            slow = slow.next \n            fast = fast.next.next\n\n        return slow\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332144695","body":"```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        g = defaultdict(list)\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        p = list(range(n))\n        for i in range(n):\n            for j in g[i]:\n                if find(i) == find(j):\n                    return False\n                p[find(j)] = find(g[i][0])\n        return True\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298727843","body":"```JavaScript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298739620","body":"思路：k从num最后一位开始加，每次除10判断是否进位，再加上对应位置，检查是否进位。\nclass Solution:\n  def addToArrayForm(self,num:List[int],k:int)->List[int]:\n     result=[]\n    for i in range(Len(num)):\n       r=num[len(num)-1-i]+k\n       num[len(num)-1-i]=r%10\n       k=int(r/10)\n      if k==0:\n    break\n  if k!=0;\n  num.insert(0,k)\nreturn num\n时间复杂度是O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300581799","body":"思路：先找到字母的位置，求出所有可能的距离，最后找最小值。\nclass Solution:\n  def shortestToChar(self, s:str, c:str)->List[int]:\n    result=[]\n    c_position=[]\n    for i in range(len(s)):\n      if s[i]==c:\n          c_position.append(i)\n    for i in c_position:\n      for j in range(len(s)):\n        dis=abj(j-i)\n        result.append(dis)\n    result = np.array(result)\n    result = result.reshape(-1,len(s))\n    result1 = np.min(result,axis=0)\n    result = result1.tolist()\n    return result\n复杂度时间O(N)\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302307949","body":"思路：数组写栈 class CustomStack: def__init__(self, maxSize:int): self.stack=[] self.max = maxSize def push(self,x:int)->None: if len(self.stack)<self.max: self.stack.append(x) def pop(self): if len(self.stack)>0: return self.stack.pop() def increment(self,k,val): for i in range(min(k,len(self.stack)): self.stack[i]= self.stack[i]+val\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304831114","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298744285","body":"````c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300709010","body":"````c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302299180","body":"````c++\nclass CustomStack {\n    maxSize:number;\n    cnt:number;\n    stack: Array<number>;\n    incrementInfos: Array<number>;\n\n    constructor(maxSize: number) {\n      this.maxSize = maxSize;\n      this.cnt = -1;\n      this.incrementInfos = new Array(maxSize).fill(0);\n      this.stack = [];\n    }\n\n    push(x: number): void {\n      if (this.cnt < this.maxSize -1) {\n        this.cnt++;\n        this.stack.push(x);\n      }\n    }\n\n    pop(): number {\n      if (this.cnt === -1) return -1;\n      const inc = this.incrementInfos[this.cnt];\n\n      if (inc) {\n        this.incrementInfos[this.cnt] = 0;\n        this.incrementInfos[this.cnt -1] += inc;\n      }\n      this.cnt--;\n      return this.stack.pop() + inc;\n    }\n\n    increment(k: number, val: number): void {\n      let i = k;\n      if (this.cnt < i) i = this.cnt + 1;\n      if (i > 0 ) this.incrementInfos[i - 1] += val;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303795708","body":"````c++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828940","body":"````c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        unordered_map<int, int> cnt;\n        int res = 0;\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end());\n        for (int i = 0; i < sortedArr.size(); i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt[x]++;\n            if (cnt[x] == 0) {\n                cnt.erase(x);\n            }\n            cnt[y]--;\n            if (cnt[y] == 0) {\n                cnt.erase(y);\n            }\n            if (cnt.size() == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305793814","body":"````c++\nListNode* rotateRight(ListNode* head, int k) {\n    if (head == nullptr\n        || head->next == nullptr\n        || k == 0)\n        return head;\n\n    int len = 1;\n    ListNode* cur = head;\n    while (cur->next != nullptr) {\n        cur = cur->next;\n        len++;\n    }\n\n    k %= len;\n\n    ListNode* fast = head;\n    ListNode* slow = head;\n\n    while (fast->next != nullptr) {\n        if (k-- <= 0) {\n            slow = slow->next;\n        }\n        fast = fast->next;\n    }\n\n    fast->next = head;\n    ListNode* new_head = slow->next;\n    slow->next = nullptr;\n    return new_head;\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307438583","body":"````c++\nListNode* swapPairs(ListNode* head) {\n    if (head == nullptr || head->next == nullptr) return head;\n\n    ListNode* dummy = new ListNode(-1, head);\n    ListNode* prev = dummy;\n    ListNode* cur = prev->next;\n\n    while (cur != nullptr && cur->next != nullptr) {\n        ListNode* next = cur->next;\n        cur->next = next->next;\n        next->next = cur;\n        prev->next = next;\n\n        prev = cur;\n        cur = cur->next;\n    }\n    return dummy->next;\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308799545","body":"````c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==nullptr){\n            return nullptr;\n        }\n        return sortedListToBST_new(head,nullptr);\n    }\n    TreeNode* sortedListToBST_new(ListNode* head,ListNode*tail){\n        if(head==tail) return nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while(fast!=tail && fast->next!=tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode * root= new TreeNode(slow->val);\n        root->left= sortedListToBST_new(head,slow);\n        root->right = sortedListToBST_new(slow->next,tail); \n        return root;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309808255","body":"````c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *curA = headA;\n        ListNode *curB = headB;\n        while(curA!=curB){\n            curA = curA->next;\n            curB = curB->next;\n            if(curA==curB && curA==nullptr) return nullptr;\n            if(curA==nullptr) curA = headA;\n            if(curB==nullptr) curB =headB;\n        }\n        return curA;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311489672","body":"````c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n\n        while(fast && fast->next){\n            slow = slow->next;\n            fast = fast->next->next;\n\n            if(slow == fast){\n                ListNode *tmp = head;\n                while(tmp!=slow){\n                    tmp = tmp->next;\n                    slow = slow->next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312501652","body":"````c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312760393","body":"````c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr){\n            return 0 ;\n        }\n        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313730680","body":"````c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==nullptr && q==nullptr) return true;\n        if(p==nullptr && q!=nullptr) return false;\n        if(p!=nullptr && q==nullptr) return false;\n\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315502412","body":"````c++\nclass Solution {\npublic:\n    int sum = 0;\n    int sumNumbers(TreeNode* root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    void dfs(TreeNode* root, int num) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            sum += num * 10 + root->val;\n            return;\n        }\n        dfs(root->left, num * 10 + root->val);\n        dfs(root->right, num * 10 + root->val);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317046251","body":"### 思路\nBFS\n\n### 代码\n````c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode *> q;\n        TreeNode* ans = NULL;\n        q.push(root);\n        while(!q.empty()){\n            ans=q.front();\n            int size = q.size();\n            while(size--){\n                TreeNode *tmp = q.front();\n                q.pop();\n                if(tmp->left) q.push(tmp->left);\n                if(tmp->right) q.push(tmp->right);\n            }\n        }\n        return ans->val;\n    }\n};\n````","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320906160","body":"````Java\nclass Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            \n            if (map.containsKey(nums[i]))\n                return new int[]{map.get(nums[i]), i};\n            \n            map.put(target - nums[i], i);\n        }\n        \n        return new int[]{};\n    }\n}\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322240625","body":"````python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n````","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328191439","body":"````c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size();\n\n        while (l <= r) {\n            int mid = l + (r - l)/2;\n            if (nums[mid] == target) return mid;\n\n            if (nums[mid] < target) l = mid + 1;\n            else\n                r = mid - 1;\n        }\n\n        return l;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329200992","body":"````java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] ans = new int[nums.length - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; i++){\n            if (!deque.isEmpty() && deque.peekFirst() + k <= i) deque.pollFirst();\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n            if (i - k + 1 >= 0) ans[i - k + 1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330640863","body":"````c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        if (trust.empty() && n == 1) return 1;\n        unordered_map<int, int> count;\n        for (auto& relation : trust)\n        {\n            count[relation[0]] += -1;\n            count[relation[1]] += 1;\n        }\n        int no_k = -1;\n        for (auto& kvp : count)\n        {\n            if (kvp.second == (n-1)) no_k = kvp.first;\n        }\n        return no_k;\n    }\n};\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298751076","body":"思路：把k变成数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300737466","body":"```\n解题思路:双指针\n在遍历的时候记录上一次遇到c的位置，每次先更新距离为到上次遇到c的距离，直到遇到了另一个c。 \n将这个c和上一个c的中点，到这个c之间的点，更新为更近的新的c到它们的距离。\n同时上一个c变成了这个c。\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), None\n        for i, ch in enumerate(s):\n            if ch == c:\n                if last is not None:\n                    for j in range(i, (i - 1 + last) // 2 - 1, -1):\n                        ans[j] = min(ans[j], i - j)\n                else:\n                    for j in range(i, -1, -1):\n                        ans[j] = min(ans[j], i - j)\n                last = i\n            elif last is not None:\n                ans[i] = min(ans[i], i - last)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302300598","body":"```\n使用数组模拟栈，用一个变量 top 记录当前栈顶的位置。\n对于 push ，只要当前元素的个数是没达到上限，就把 top 后移一个位置并添加一个元素。\n对于 pop ，只要当前栈非空，则返回栈顶元素，并将top前移\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828655","body":"```\n单调栈\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305799809","body":"```\n快慢指针\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head or not head.next: \n            return head\n        # 求链表长度\n        _len = 0\n        cur = head\n        while cur:\n            _len += 1\n            cur = cur.next\n        # 对长度取模\n        k %= _len\n        if k == 0: return head\n        # 快慢指针 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 继续往后走\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # 新链表的头newHead，也就是倒数第 k 个节点\n        newHead = slow.next\n        # 将倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311780065","body":"```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n\n        slow, fast = head, head\n        while fast  and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break;\n        if not fast or not fast.next: \n            return None\n        fast = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312332707","body":"```\n哈希表+双向链表\n搬运工 学习一下\n\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n    def move_node_to_tail(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到尾节点前\n            #                 hashmap[key]                 hashmap[key]\n            #                      |                            |\n            #                      V        -->                 V\n            # prev <-> tail  ...  node                prev <-> node <-> tail\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到末尾\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                # 去掉哈希表对应项\n                self.hashmap.pop(self.head.next.key)\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            # 如果不在的话就插入到尾节点前\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312687409","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        # elif not root.left and not root.right:\n        #     return 1\n        else :\n            return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313874737","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        else:\n            return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314578622","body":"```\n#递归左子树，回溯，递归右子树\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = 0\n        path = []\n        def backtrace(root):\n            nonlocal res\n            # 空节点，返回\n            if not root: return \n            path.append(root.val)\n            # 叶子节点\n            if not root.left and not root.right: \n                res += get_sum(path)\n            # 左子树不空\n            if root.left: \n                backtrace(root.left)\n                path.pop()\n            # 右子树不空\n            if root.right: \n                backtrace(root.right)\n                path.pop()\n            \n\n        def get_sum(arr):\n            s = 0\n            for i in range(len(arr)):\n                s = s * 10 + arr[i]\n            return s\n\n        backtrace(root)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317064337","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n#广度优先搜索, 分层搜索，每层记录最左边的结点，最深一层记录的即所求结点\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue, ans = Deque([root]), None\n        while queue:\n            ans = queue[0].val\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320912182","body":"```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        res = {}\n        for i,value in enumerate(nums):\n            if target - value in res.keys():\n                return [i,res[target - value]]\n            else:\n                res[value] = i\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321128804","body":"```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # 先统计各数字数目，然后找出数目的第k大数\n        cnt = Counter(nums)\n        l = list(cnt.values())\n\n        # 小根堆\n        def findKthLargest(nums, k):\n            maxHeap = []\n            for x in nums:\n                heapq.heappush(maxHeap, -x)\n            for _ in range(k - 1):\n                heapq.heappop(maxHeap)\n            return -maxHeap[0]\n\n        ans = list()\n        n = findKthLargest(l, k)\n        for k, v in cnt.items():\n            if v >= n:\n                ans.append(k)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322174487","body":"```\n# 思路\n# 1、用哈希表记录某个点到其他点的距离，并统计每个距离相同的点个数\n# 2、遍历哈希表，从距离相同的点中选2个，作为回旋镖的后两个点\n# 3、对每个点都执行1和2\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(points)):\n            hashmap = collections.defaultdict(int)\n            for j in range(len(points)):\n                dx = points[i][0] - points[j][0]\n                dy = points[i][1] - points[j][1]\n                dis = dx * dx + dy * dy\n                hashmap[dis] += 1\n            for val in hashmap.values():\n                    res += val * (val - 1)\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323813979","body":"```\n#滑动窗口\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_len, hashmap = 0, {}\n        start = 0\n        #移动窗口右边界\n        for end in range(len(s)):\n            hashmap[s[end]] = hashmap.get(s[end], 0) + 1\n            if len(hashmap) == end - start + 1:\n                max_len = max(max_len, end - start + 1)\n        #移动窗口左边界\n            while end - start + 1 > len(hashmap):\n                head = s[start]\n                hashmap[head] -= 1\n                if hashmap[head] == 0:\n                    del hashmap[head]\n                start += 1\n        return max_len\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325171486","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:return []\n        one_word_len = len(words[0])\n        all_words_len = len(words) * one_word_len\n        n = len(s)\n        words_counter = collections.Counter(words)\n        res = []\n        for i in range(0, n - all_words_len + 1):\n            tmp = s[i:i+all_words_len]\n            c_tmp = []\n            for j in range(0, all_words_len, one_word_len):\n                c_tmp.append(tmp[j:j+one_word_len])\n            if collections.Counter(c_tmp) == words_counter:\n                res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326614429","body":"```\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        # 前缀和\n        ans, sum = [0], 0\n        for i in nums:\n            sum = sum + i\n            ans.append(sum)\n        # 字典\n        dict1 = {}\n        for i in ans:\n            if i % k not in dict1:\n                dict1[i % k] = 0\n            dict1[i % k] += 1\n        # 排列次数\n        total = 0\n        for v in dict1.values():\n            total = total + v * (v - 1) // 2\n        return total\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328068013","body":"```\n# 快慢指针\n# 初始化慢指针slow指向数组的起始位置（nums[0]），快指针fast指向指针slow的后一个位置（nums[1]）。\n# 随着指针fast不断向后移动，将指针fast指向的元素与指针slow指向的元素进行比较：\n\n# 如果nums[fast] ≠ nums[slow]，那么nums[slow + 1] = nums[fast]；\n\n# 如果nums[fast] = nums[slow]，那么指针fast继续向后查找；\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow, fast = 0, 1\n        while fast < len(nums):\n            if nums[fast] != nums[slow]:\n                slow = slow + 1\n                nums[slow] = nums[fast]\n            fast = fast + 1\n        return slow + 1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329339418","body":"```\ncopy\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or not k:\n            return []\n        if len(nums) == 1:\n            return [nums[0]]\n\n        # 初始化队列和结果，队列存储数组的下标\n        queue = []\n        res = []\n\n        for i in range(len(nums)):\n            # 如果当前队列最左侧存储的下标等于 i-k 的值，代表目前队列已满，新元素需要进来，列表最左侧的下标出队列\n            if queue and queue[0] == i - k:\n                queue.pop(0)\n\n            # 对于新进入的元素，如果队列前面的数比它小，那么前面的都出队列\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            # 新元素入队列\n            queue.append(i)\n\n            # 当前的大值加入到结果数组中\n            if i >= k-1:\n                res.append(nums[queue[0]])\n\n        return res\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298753812","body":"`func addToArrayForm(num []int, k int) []int {\r\n    n := len(num)\r\n    pre,sum:=0,0\r\n    out := []int{}\r\n    for i:=n-1;i>=0||k>0||pre>0;i--{\r\n        if i >= 0{\r\n            sum = num[i]+k%10+pre\r\n        }else{\r\n            sum =k%10 + pre\r\n        }\r\n        pre = sum/10\r\n        k /= 10\r\n        out = append(out,sum%10)\r\n    }\r\n    reverse(out)\r\n    return out\r\n}\r\nfunc reverse(out []int) []int{\r\n    for i:=0;i<len(out)/2;i++{\r\n        out[i],out[len(out)-1-i] = out[len(out)-1-i] , out[i]\r\n    }\r\n    return out\r\n}`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300758564","body":"*代码\r\n\r\n```python \r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302310783","body":"## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop(-1)\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        m = min(self.size, k)\r\n        for i in range(m):\r\n            self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303793836","body":"## 代码\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1303910219","body":"## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304780087","body":"## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305798946","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308976671","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1313897620","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if root:\r\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n        else:\r\n            return 0\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313898860","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        return p != None and q != None and q.val == p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317240257","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        self.h = 0\r\n        self.v = 0\r\n\r\n        def dfs(root, last_h):\r\n            if not root:\r\n                return 0\r\n            else:\r\n                h = last_h + 1\r\n\r\n                if not root.left and not root.right:\r\n                    if h > self.h:\r\n                        self.h = h\r\n                        self.v = root.val\r\n                \r\n                dfs(root.left, h)\r\n                dfs(root.right, h)\r\n        dfs(root,0)\r\n        return self.v\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318810442","body":"##代码##\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        self.open = [root]\r\n        self.res = []\r\n        self.children = []\r\n\r\n        while self.open:\r\n            node = self.open.pop(0)\r\n            if node:\r\n                self.res.append(str(node.val))\r\n                self.open.append(node.left)\r\n                self.open.append(node.right)\r\n            else:\r\n                self.res.append('None')\r\n        # return self.res\r\n        return '[' + ','.join(self.res) + ']'\r\n\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return []\r\n        dataList = data[1:-1].split(',')\r\n        root = TreeNode(int(dataList[0]))\r\n        self.open = [root]\r\n        i = 1\r\n        while self.open:\r\n            node = self.open.pop(0)\r\n            if dataList[i] != 'None':\r\n                node.left = TreeNode(int(dataList[i]))\r\n                self.open.append(node.left)\r\n            i += 1\r\n            if dataList[i] != 'None':\r\n                node.right = TreeNode(int(dataList[i]))\r\n                self.open.append(node.right)\r\n            i += 1\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320084504","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        \r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1299362003","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] = divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry\r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\ntime O(N) space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299379101","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lr = [float('inf')] * len(s)\r\n        rl = [float('inf')] * len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lr[i] = 0\r\n            else:\r\n                if i-1 >= 0:\r\n                    lr[i] = lr[i-1] + 1\r\n                else:\r\n                    lr[i] = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                rl[i] = 0\r\n            else:\r\n                if i+1 < len(s):\r\n                    rl[i] = rl[i+1] + 1\r\n                else:\r\n                    rl[i] = float('inf')\r\n        for i in range(len(s)):\r\n            lr[i] = min(lr[i], rl[i])\r\n        return lr\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301125936","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.index = []\r\n        self.curSize = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.curSize < self.maxSize:\r\n            self.stack.append(x)\r\n            self.index.append(0)\r\n            self.curSize += 1\r\n        \r\n    def pop(self) -> int:\r\n        if self.curSize == 0:\r\n            return -1\r\n        else:\r\n            self.curSize -= 1\r\n            inc = self.index.pop()\r\n            if self.curSize > 0:\r\n                self.index[-1] += inc\r\n            return self.stack.pop() + inc\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(self.curSize, k)\r\n        if s != 0:\r\n            self.index[s-1] += val\r\n```\r\ntime O(1), space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302775657","body":"```\r\nfrom collections import deque\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = deque()\r\n        k = \"\"\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] in \"0123456789\":\r\n                k += s[i]\r\n            else:\r\n                if k != \"\":\r\n                    n = int(k[::-1])\r\n                    temp = []\r\n                    # pop until ] or end\r\n                    while stack:\r\n                        c = stack.popleft()\r\n                        if c == \"]\":\r\n                            break\r\n                        else:\r\n                            if c != \"[\":\r\n                                temp.append(c)\r\n                    # repeate k time\r\n                    for _ in range(n):\r\n                        # push back\r\n                        for c in temp[::-1]:\r\n                            stack.appendleft(c)\r\n                    # clear k\r\n                    k = \"\"\r\n                stack.appendleft(s[i])\r\n        if k != \"\":\r\n            # repeate\r\n            n = int(k[::-1])\r\n            temp = []\r\n            # pop until ] or end\r\n            while stack:\r\n                c = stack.popleft()\r\n                if c == \"]\":\r\n                    break\r\n                else:\r\n                    if c != \"[\":\r\n                        temp.append(c) \r\n            # repeate k time\r\n            for _ in range(n):\r\n                # push back\r\n                for c in temp[::-1]:\r\n                    stack.appendleft(c)\r\n        return \"\".join(stack)\r\n```\r\ntime O(len(string)) space O(len(string)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304387929","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.push_stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.pop_stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if self.pop_stack or self.push_stack:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304744134","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for val in arr:\r\n            if stack:\r\n                max_val = stack[-1]\r\n                if val < max_val:\r\n                    while stack and val < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(max_val)\r\n                else:\r\n                    stack.append(val)\r\n            else:\r\n                stack.append(val)\r\n        return len(stack)\r\n```\r\ntimeO(N),  space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1306238924","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        p = head\r\n        length = 0\r\n        while p:\r\n            length += 1\r\n            p = p.next\r\n        k = k % length\r\n        # \r\n        if k == 0:\r\n            return head\r\n        num = length - k\r\n        p = head\r\n        acc = 0\r\n        for _ in range(length):\r\n            if acc == num-1:\r\n                b = p\r\n            if acc == length-1:\r\n                f = p\r\n            p = p.next\r\n            acc += 1\r\n        # b.next will be None\r\n        ans = b.next\r\n        b.next = None\r\n        # cut the \r\n        f.next = head\r\n        return ans\r\n```\r\ntime O(N) space O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306731796","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        p = head\r\n        ans = head\r\n        acc = 1\r\n        while p.next:\r\n            if acc % 2 == 1:\r\n                if acc == 1:\r\n                    next_node = p.next\r\n                    p.next = next_node.next\r\n                    next_node.next = p\r\n                    ans = next_node\r\n                else:\r\n                    next_node = p.next\r\n                    p.next = next_node.next\r\n                    pre_node.next = next_node\r\n                    next_node.next = p\r\n            else:\r\n                pre_node = p\r\n                p = p.next\r\n            acc += 1\r\n        return ans\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307975865","body":"```\r\nclass Solution:\r\n    def helper(self, nums):\r\n        if not nums:\r\n            return None\r\n        h_node = len(nums) // 2\r\n        ans = TreeNode(val=nums[h_node])\r\n        ans.left = self.helper(nums[:h_node])\r\n        ans.right = self.helper(nums[h_node+1:])\r\n        return ans\r\n        \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        p = head\r\n        nums = []\r\n        while p:\r\n            nums.append(p.val)\r\n            p = p.next\r\n        ans = self.helper(nums)\r\n        return ans\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309881204","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pa = headA\r\n        pb = headB\r\n        while pa != pb:\r\n            pa = headB if pa is None else pa.next\r\n            pb = headA if pb is None else pb.next\r\n        return pa\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311249452","body":"```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        p = head\r\n        pool = set()\r\n        while p:\r\n            if p in pool:\r\n                return p\r\n            else:\r\n                pool.add(p)\r\n            p = p.next\r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312672343","body":"```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        self.s = capacity\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n            return self[key]\r\n        else:\r\n            return -1\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.s:\r\n            self.popitem(last=False)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312652958","body":"```\r\nclass Solution:\r\n    def helper(self, branch, num):\r\n        if not branch:\r\n            return num\r\n        l = self.helper(branch.left, num+1)\r\n        r = self.helper(branch.right, num+1)\r\n        return max(l, r)\r\n        \r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        #if not root:\r\n        #    return 0\r\n        #l = self.helper(root.left, 1)\r\n        #r = self.helper(root.right, 1)\r\n        return self.helper(root, 0)\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312779350","body":"```\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        \r\n        if p and q:\r\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n        elif p and not q:\r\n            return False\r\n        elif not p and q:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314199324","body":"```\r\nclass Solution:\r\n    \r\n    def helper(self, node, num):\r\n        \r\n        if not node.left and not node.right:\r\n            return num*10 + node.val\r\n        elif not node.left and node.right:\r\n            num = num*10 + node.val\r\n            return self.helper(node.right, num)\r\n        elif node.left and not node.right:\r\n            num = num*10 + node.val\r\n            return self.helper(node.left, num)\r\n        else:\r\n            num = num*10 + node.val\r\n            return self.helper(node.left, num) + self.helper(node.right, num)\r\n        \r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        if not root.left and not root.right:\r\n            return root.val\r\n        elif not root.left and root.right:\r\n            return self.helper(root.right, root.val)\r\n        elif root.left and not root.right:\r\n            return self.helper(root.left, root.val)\r\n        else:\r\n            return self.helper(root.left, root.val) + self.helper(root.right, root.val)\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316524727","body":"```\r\nclass Solution:\r\n    ans = 0\r\n    max_v = -float(\"inf\")\r\n    min_h = float(\"inf\")\r\n    def helper(self, node, v, h):\r\n        if v > self.max_v:\r\n            self.max_v = v\r\n            self.min_h = h\r\n            self.ans = node.val\r\n        if v == self.max_v:\r\n            if h < self.min_h:\r\n                self.min_h = h\r\n                self.ans = node.val\r\n        if node.left:\r\n            self.helper(node.left, v+1, h-1)\r\n        if node.right:\r\n            self.helper(node.right, v+1, h+1)\r\n        \r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        self.helper(root, 0, 0)\r\n        return self.ans\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318269257","body":"```\r\nfrom collections import deque\r\nclass Codec:\r\n    ans_str = \"\"\r\n    def serialize_helper(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if root:\r\n            self.ans_str += str(root.val)\r\n            self.ans_str += \" \"\r\n        else:\r\n            self.ans_str += \"None\"\r\n            self.ans_str += \" \"\r\n            return\r\n        self.serialize_helper(root.left)\r\n        self.serialize_helper(root.right)\r\n    \r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        else:\r\n            self.serialize_helper(root)\r\n        return self.ans_str\r\n        \r\n    def deserialize_helper(self, data):\r\n        if not data:\r\n            return None\r\n        val = data.popleft()\r\n        if val == \"None\":\r\n            return None\r\n        ans = TreeNode(int(val))\r\n        ans.left = self.deserialize_helper(data)\r\n        ans.right = self.deserialize_helper(data)\r\n        return ans\r\n        \r\n        \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data = deque(data.split())\r\n        ans = self.deserialize_helper(data)\r\n        return ans\r\n        \r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319686694","body":"```\r\nclass Solution:\r\n    def helper(self, node, tup, r, c):\r\n        if node:\r\n            tup.append((c, r, node.val))\r\n            self.helper(node.left, tup, r+1, c-1)\r\n            self.helper(node.right, tup, r+1, c+1)\r\n            \r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        tup = []\r\n        self.helper(root, tup, 0, 0)\r\n        tup = sorted(tup)\r\n        ans = collections.OrderedDict()\r\n        for c in tup:\r\n            if c[0] not in ans:\r\n                ans[c[0]] = []\r\n                ans[c[0]].append(c[-1])\r\n            else:\r\n                ans[c[0]].append(c[-1])\r\n        return list(ans.values())\r\n```\r\n\r\ntime O(nlogn) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320270100","body":"```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        can = {}\r\n        for i, val in enumerate(nums):\r\n            if val in can:\r\n                return [can[val], i]\r\n            else:\r\n                can[target-val] = i\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320956093","body":"```\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        nums = collections.Counter(nums)\r\n        min_key, min_val = 0, float(\"inf\")\r\n        ans = {}\r\n        for key, val in nums.items():\r\n            if len(ans) < k:\r\n                ans[key] = val\r\n                if val < min_val:\r\n                    min_key = key\r\n                    min_val = val\r\n            else:\r\n                if val > min_val:\r\n                    del ans[min_key]\r\n                    ans[key] = val\r\n                    min_val = float(\"inf\")\r\n                    for kk, vv in ans.items():\r\n                        if vv < min_val:\r\n                            min_val = vv\r\n                            min_key = kk\r\n        return ans.keys()\r\n```\r\ntime O(N) spce O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321309068","body":"```\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for i, a in enumerate(points):\r\n            distance = collections.defaultdict(int)\r\n            for j, b in enumerate(points):\r\n                if i == j:\r\n                    continue\r\n                dist = (a[0] - b[0])**2 + (a[1] - b[1])**2\r\n                distance[dist] += 1\r\n            #\r\n            for k, v in distance.items():\r\n                if v >=2:\r\n                    ans += v*(v-1)\r\n        return ans\r\n```\r\ntime O(N**2) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322502631","body":"```\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:\r\n            return 0\r\n        l, r = 0, 0\r\n        pool = set()\r\n        pool.add(s[0])\r\n        ans = 1\r\n        for r in range(1, len(s)):\r\n            while s[r] in pool:\r\n                pool.remove(s[l])\r\n                l += 1\r\n            \r\n            pool.add(s[r])\r\n            ans = max(ans, len(pool))\r\n        return ans\r\n```\r\ntime (N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324242509","body":"```\r\nclass Solution:\r\n    def helper(self, s, start, words, w_len, s_len, golden):\r\n        ans = []\r\n        if len(s) < s_len:\r\n            return ans\r\n        l, r = 0, 0\r\n        target = collections.defaultdict(int)\r\n        for r in range(0, s_len, w_len):\r\n            target[s[r: w_len+r]] += 1\r\n        if target == golden:\r\n            ans.append(l+start)\r\n            \r\n        if s_len > len(s) - w_len:\r\n            return ans\r\n        \r\n        for r in range(s_len, len(s), w_len):\r\n            target[s[r: r+w_len]] += 1\r\n            target[s[l: l+w_len]] -= 1\r\n            if target[s[l: l+w_len]] == 0:\r\n                del target[s[l: l+w_len]]\r\n            l += w_len\r\n            if target == golden:\r\n                ans.append(l+start)\r\n        return ans\r\n            \r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        w_len = len(words[0])\r\n        s_len = len(words)*w_len\r\n        ans = []\r\n        target = collections.Counter(words)\r\n        if len(s) < s_len:\r\n            return ans\r\n        else:\r\n            for i in range(w_len):\r\n                ans += self.helper(s[i:], i, words, w_len, s_len, target)\r\n            return ans\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326017208","body":"```\r\nclass Solution:\r\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\r\n        pool = collections.defaultdict(list)\r\n        pre = 0\r\n        ans = 0\r\n        pool[0] = [-1]\r\n        for j in range(len(nums)):\r\n            pre += nums[j]\r\n            target = pre % k\r\n            if target in pool:\r\n                ans += len(pool[target])\r\n            pool[target].append(j)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326832407","body":"```\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        fast, slow = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327931255","body":"```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        diffs = set()\r\n        l, r, ans = 0, 0, 1\r\n        diffs.add(nums[0])\r\n        for r in range(1, len(nums)):\r\n            if nums[r] in diffs:\r\n                continue\r\n            else:\r\n                l += 1\r\n                nums[l] = nums[r]\r\n                ans += 1\r\n                diffs.add(nums[r])\r\n        return ans\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328120307","body":"```\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums)-1\r\n        while l <= r:\r\n            mid = (l+r) // 2\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] > target:\r\n                r = mid-1\r\n            else:\r\n                l = mid+1\r\n        return l\r\n```\r\ntime O(logN) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1331453649","body":"```\r\nimport heapq\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        h, ans = [], []\r\n        for i in range(k):\r\n            heapq.heappush(h, (-nums[i], i))\r\n        ans.append(-h[0][0])\r\n        for i in range(k, len(nums)):\r\n            heapq.heappush(h, (-nums[i], i))\r\n            while h[0][1] < i-k+1:\r\n                heapq.heappop(h)\r\n            ans.append(-h[0][0])\r\n        return ans\r\n```\r\ntime O(NlogK) space O(k)\r\n\r\n```\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        s = collections.deque()\r\n        ans = []\r\n        for i in range(len(nums)):\r\n            while s and nums[s[-1]] <= nums[i]:\r\n                s.pop()\r\n            while s and i-s[0] >= k:\r\n                s.popleft()\r\n            s.append(i)\r\n            if i >= k-1:\r\n                ans.append(nums[s[0]])\r\n        return ans\r\n```\r\ntime O(N) space O(K)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1331463124","body":"```\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        in_degree, out_degree = [0]*(n+1), [0]*(n+1)\r\n        for f, t in trust:\r\n            in_degree[t] += 1\r\n            out_degree[f] += 1\r\n        for i in range(1, n+1):\r\n            if in_degree[i] == n-1 and out_degree[i] == 0:\r\n                return i\r\n        return -1\r\n```\r\ntime O(N) space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331466464","body":"```\r\nclass Solution:\r\n    def dfs(self, g, i, c, colors):\r\n        colors[i] = c\r\n        # for it's connector v, try to color -1*c\r\n        for j in g[i]:\r\n            if colors[j] == c:\r\n                return False\r\n            elif colors[j] == 0 and not self.dfs(g, j, -1*c, colors):\r\n                return False\r\n        return True\r\n    \r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = collections.defaultdict(list)\r\n        for x, y in dislikes:\r\n            g[x-1].append(y-1)\r\n            g[y-1].append(x-1)\r\n        colors = [0] * n\r\n        for i in range(n):\r\n            if colors[i] == 0 and not self.dfs(g, i, 1, colors):\r\n                return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1334823957","body":"```\r\nclass Solution:\r\n    # 拓扑排序\r\n    def tp_sort(self, items, indegree, neighbors):\r\n        q = collections.deque([])\r\n        ans = []\r\n        for item in items:\r\n            if not indegree[item]:\r\n                q.append(item)\r\n        while q:\r\n            cur = q.popleft()\r\n            ans.append(cur)\r\n\r\n            for neighbor in neighbors[cur]:\r\n                indegree[neighbor] -= 1\r\n                if not indegree[neighbor]:\r\n                    q.append(neighbor)\r\n\r\n        return ans\r\n\r\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n        for project in range(n):\r\n            if group[project] == -1:\r\n                group[project] = max_group_id\r\n                max_group_id += 1\r\n\r\n        project_indegree = collections.defaultdict(int)\r\n        group_indegree = collections.defaultdict(int)\r\n        project_neighbors = collections.defaultdict(list)\r\n        group_neighbors = collections.defaultdict(list)\r\n        group_projects = collections.defaultdict(list)\r\n\r\n        for project in range(n):\r\n            group_projects[group[project]].append(project)\r\n\r\n            for pre in pres[project]:\r\n                if group[pre] != group[project]:\r\n                    # 小组关系图\r\n                    group_indegree[group[project]] += 1\r\n                    group_neighbors[group[pre]].append(group[project])\r\n                else:\r\n                    # 项目关系图\r\n                    project_indegree[project] += 1\r\n                    project_neighbors[pre].append(project)\r\n\r\n        ans = []\r\n        # 先对组进行拓扑排序\r\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id:\r\n            return []\r\n\r\n        for group_id in group_queue:\r\n            # 对小组中的项目进行拓扑排序\r\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\r\n\r\n            if len(project_queue) != len(group_projects[group_id]):\r\n                return []\r\n            ans += project_queue\r\n\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334822061","body":"```\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        res = collections.Counter(moves)\r\n        return res[\"L\"]==res[\"r\"] and res[\"U\"]==res[\"D\"]\r\n```\r\ntime O(N) space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299479938","body":"## Thought: \nSweep from left side, compute the distance.\nThen sweep from right side, compute distance again.\nCompare the results from left and right, and output the min. \n\n## Code:\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # initialization \n        N = len(s)\n        left,right,res = [None] * N, [None] * N, [None] * N\n\n        ind = float('inf')\n        # sweep from left\n        for ii in range(N):\n            if s[ii] == c:\n                ind = ii\n            left[ii] = abs(ind - ii) \n        # sweep from right\n        ind = float('inf')\n        for ii in range(N-1,-1,-1):\n            if s[ii] == c:\n                ind = ii\n            right[ii] = abs(ind - ii)             \n        \n        # take the min of left and right \n        for ii in range(N):\n            res[ii] = min(left[ii],right[ii])\n        \n        return res\n\n```\n\n## Complexity: \nTime complexity: O(n)\n\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301595367","body":"## Thought \n\nUse list to work for a stack.\nUse append method for push and pop method for pop.\n## Code \n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n        else:\n            print(\"Max size has been reached!\")            \n\n\n    def pop(self) -> int:\n        if len(self.stack) >=1:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val      \n```\n## Complexity: \n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305044968","body":"## Thought:\n1. Find length of linked list n\n2. Linked list will be rotated k%n times\n3. Jump to the pivot:\n           make tne next node new head\n           link the pivot to None\n           link tail to old head\n## Code \n```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        # get the length of the list\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n    \n        k = k % length\n        # no change in this case\n        if k == 0:\n            return head\n        \n        cur = head\n        for i in range(length-k-1):\n            cur = cur.next\n        \n        \n        new_head = cur.next\n        cur.next = None\n        tail.next = head\n        \n        return new_head\n```\n\n## Complexity:\n\nTO: O(n)\n\nSO: O(1)\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312806315","body":"(参考题解学习)\n## 思路： 迭代\n\n## 代码：\n```python3\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n## 复杂度：\nTC: O(n)\nSC: O(h)","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325912380","body":"(参考题解)\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328111117","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n\nO(logn), O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330013033","body":"(参考题解)\n```python\nclass Solution:\n     def findJudge(self, N, trust):\n        in_degree = [0] * (N + 1)\n        out_degree = [0] * (N + 1)\n        for a, b in trust:\n            in_degree[b] += 1\n            out_degree[a] += 1\n        for i in range(1, N + 1):\n            if in_degree[i] == N - 1 and out_degree[i] == 0:\n                return i\n        return -1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299539108","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1306150550","body":" public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || k == 0)\r\n            return head;\r\n        ListNode pointer = head;\r\n        int count = 0;\r\n        while(pointer.next != null) {\r\n            pointer = pointer.next;\r\n            count++;\r\n        }\r\n        pointer.next = head;\r\n        count++;\r\n        int times = k/count+1;\r\n        for(int i = 0; i < count - (k%count); i++) {\r\n            head = head.next;\r\n            pointer = pointer.next;\r\n        }\r\n        ListNode ans = head;\r\n        pointer.next = null;\r\n        return ans;\r\n    }","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306147261","body":"if not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312372140","body":"class LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : _capacity(capacity) {\r\n\r\n    }\r\n    \r\n    int get(int key) {\r\n        auto it = _table.find(key);\r\n        if (it != _table.end()) {\r\n            _lru.splice(_lru.begin(), _lru, it->second);\r\n            return it->second->second;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        auto it = _table.find(key);\r\n        if (it != _table.end()) {\r\n            _lru.splice(_lru.begin(), _lru, it->second);\r\n            it->second->second = value;\r\n            return;\r\n        }\r\n        \r\n        _lru.emplace_front(key, value);\r\n        _table[key] = _lru.begin();\r\n        \r\n        if (_table.size() > _capacity) {\r\n            _table.erase(_lru.back().first);\r\n            _lru.pop_back();\r\n        }\r\n    }\r\nprivate:\r\n    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;\r\n    std::list<std::pair<int, int>> _lru;\r\n    int _capacity;\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1318968555","body":"class Solution {\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<tuple<int, int, int>> nodes;\r\n\r\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            nodes.emplace_back(col, row, node->val);\r\n            dfs(node->left, row + 1, col - 1);\r\n            dfs(node->right, row + 1, col + 1);\r\n        };\r\n\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n        vector<vector<int>> ans;\r\n        int lastcol = INT_MIN;\r\n        for (const auto& [col, row, value]: nodes) {\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().push_back(value);\r\n        }\r\n        return ans;\r\n    }\r\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1327479577","body":"class Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        // 记录字符上一次出现的位置\r\n        int[] last = new int[128];\r\n        for(int i = 0; i < 128; i++) {\r\n            last[i] = -1;\r\n        }\r\n        int n = s.length();\r\n\r\n        int res = 0;\r\n        int start = 0; // 窗口开始位置\r\n        for(int i = 0; i < n; i++) {\r\n            int index = s.charAt(i);\r\n            start = Math.max(start, last[index] + 1);\r\n            res   = Math.max(res, i - start + 1);\r\n            last[index] = i;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327469826","body":"var middleNode = function(head) {\r\n  if(!head) return head;\r\n  let newHead = head;\r\n  let quick = newHead;\r\n  let slow = newHead;\r\n  while(quick && quick.next){\r\n    quick = quick.next.next;\r\n    slow = slow.next;\r\n  }\r\n  return slow;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299576804","body":"var shortestToChar = function(s, c) {\r\n    let num = [],res = []\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i] === c){\r\n            num.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min = Infinity\r\n        for(let j=0;j<num.length;j++){\r\n            min = Math.min(Math.abs(i-num[j]),min)\r\n        }\r\n        res.push(min)\r\n    }\r\n    return res\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301955903","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length < this.maxSize){\n        this.arr.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.arr.length?this.arr.pop():-1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let min = Math.min(k,this.arr.length)\n    for(let i=0;i<min;i++){\n        this.arr[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304452988","body":"var MyQueue = function() {\n    this.arr = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr.push(x)\n    return this.arr\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.arr.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.arr[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.arr.length?false:true\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304757577","body":"var maxChunksToSorted = function(arr) {\n    let arr1 = [...arr]\n    let arr2 = arr.sort((a,b)=>a-b)\n    let sum1 = sum2 = sum = 0\n    for(let i=0;i<arr1.length;i++){\n        sum1 += arr1[i]\n        sum2 += arr2[i]\n        if(sum1 === sum2){\n            ++sum\n        }\n    }\n    return sum\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305000850","body":"var rotateRight = function(head, k) {\n    if(!head)return null\n    let newhead = head,ln = 1\n    while(newhead.next){\n        newhead = newhead.next\n        ++ln\n    }\n    let move = ln - k%ln\n    newhead.next = head\n    while(move){\n        newhead = newhead.next\n        --move\n    }\n    let cur = newhead.next\n    newhead.next = null\n    return cur\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308124972","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let arr = [],newhead = head\n    while(newhead){\n        arr.push(newhead.val)\n        newhead = newhead.next\n    }\n    const dps = (start,end)=>{\n        if(start>end)return null\n        let mid = start + end >> 1\n        let root = new TreeNode(arr[mid])\n        root.left = dps(start,mid - 1)\n        root.right = dps(mid+1,end)\n        return root\n    }\n    return dps(0,arr.length-1)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309660428","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let map = new Map()\n    let h1 = headA\n    while(h1){\n        map.set(h1,true)\n        h1 = h1.next\n    }\n    let h2 = headB\n    while(h2){\n        if(map.get(h2)){\n            return h2\n        }else{\n            h2 = h2.next\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311140277","body":"var detectCycle = function(head) {\n    let m = new Map()\n    let cur = head\n    while(cur){\n        if(m.get(cur)){\n            return cur\n        }else{\n            m.set(cur,true)\n            cur = cur.next\n        }\n    }\n    return null\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312747309","body":"/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.ln = capacity\n    this.m = new Map()\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.m.has(key)){\n        let val = this.m.get(key)\n        this.m.delete(key)\n        this.m.set(key,val)\n        return val\n    }\n    return -1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    this.m.delete(key)\n    this.m.set(key,value)\n    if(this.m.size > this.ln){\n        let k = this.m.keys().next().value\n        this.m.delete(k)\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312944016","body":"var isSameTree = function(p, q) {\n    if(!p && !q){\n        return true\n    }\n    if(p && q && p.val === q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)){\n        return true\n    }\n    return false\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314663924","body":"var sumNumbers = function(root) {\n    const dfs = (root,pre)=>{\n        if(!root)return 0\n        let cur = pre * 10 + root.val\n        if(!root.left && !root.right){\n            return cur\n        }else{\n            return dfs(root.left,cur) + dfs(root.right,cur)\n        }\n    }\n    return dfs(root,0)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316402051","body":"var findBottomLeftValue = function(root) {\n    let stack = [root],res = 0\n    while(stack.length){\n        let ln = stack.length\n        for(let i=0;i<ln;i++){\n            let node = stack.shift()\n            if(i === 0){\n                res = node.val\n            }\n            node.left && stack.push(node.left)\n            node.right && stack.push(node.right) \n        }\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318140253","body":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    return dfsSerialize(root,'')\n};\nvar dfsSerialize = (root,str)=>{\n   if(!root){\n       str += 'None,'\n   }else{\n       str += root.val + ','\n       str = dfsSerialize(root.left,str)\n       str = dfsSerialize(root.right,str)\n   }\n   return str\n}\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    let arr = data.split(',')\n    return dfsDeserialize(arr)\n};\nvar dfsDeserialize = (dataList)=>{\n    if(dataList[0] === 'None'){\n        dataList.shift()\n        return null\n    }\n    let root = new TreeNode(parseInt(dataList[0]))\n    dataList.shift()\n    root.left = dfsDeserialize(dataList)\n    root.right = dfsDeserialize(dataList)\n    return root\n}\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321320562","body":"var topKFrequent = function(nums, k) {\n    let obj = {}\n    for(let i=0;i<nums.length;i++){\n        let key = nums[i]\n        if(typeof obj[key] === 'undefined'){\n            obj[key] = 1\n        }else{\n            obj[key] += 1\n        }\n    }\n    console.log(obj)\n    let cur = []\n    for(let k in obj){\n        let val = obj[k]\n        cur.push({number:val,key:k})\n    }\n    cur.sort((a,b)=>b.number-a.number)\n    console.log(cur)\n    let res = []\n    for(let i=0;i<k;i++){\n        res.push(cur[i].key)\n    }\n    return res\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326001198","body":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let set = new Set(),rk = -1,max = 0\n    for(let i=0;i<s.length;i++){\n        if(i !== 0){\n            set.delete(s[i-1])\n        }\n        while(rk+1<s.length && !set.has(s[rk+1])){\n            set.add(s[rk+1])\n            ++rk\n        }\n        max = Math.max(max,rk+1-i)\n    }\n    return max\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299631296","body":"# 思路\r\n用空间换时间,先遍历记录index到 distance set,然后遍历一般根据distance set求最短距离\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_set = set()\r\n        res = [-1] * len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                char_set.add(i)\r\n        for j in range(len(s)):\r\n            lowest = float('inf')\r\n            for index in char_set:\r\n                if lowest > abs(index - j):\r\n                    lowest = abs(index - j)\r\n            res[j] = lowest\r\n        return res\r\n```\r\n\r\n\r\n# 复杂度\r\n时间复杂度: O(N) * O(M) , M取决于c出现的次数\r\n空间复杂度: O(M), M取决于c出现的次数\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304550486","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        \r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311428342","body":"```\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299691427","body":"### 思路\n先将字符串中C表示的字符的位置记录下来，然后计算字符串中每一个字符与所有字符C的距离，并求出最小距离\n\n\n\n### 代码\n\n```py\n\n\n\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        loc=[]\n        dis=[]        \n        for i in range(0,len(S)):\n            if S[i]==C:\n                loc.append(i)#记录e在列表中的位置\n        for i in range(0,len(S)):\n            t=[]\n            for j in loc:\n                t.append(abs(i-j))#计算每一个字符和所有C的距离\n            dis.append(min(t))#将最小距离添加到结果数组中\n        return dis\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，\n- 空间复杂度：O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303067731","body":"### 思路\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n如果当前的字符为字母或者左括号，直接进栈\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（这个次数和字符串构造出新的字符串并进栈\n\n### 代码\n\n\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n\n\n\n```\n\n**复杂度分析**\n时间复杂度 O(N)，递归会更新索引，因此实际上还是一次遍历 s；\n空间复杂度 O(N)，极端情况下递归深度将会达到线性级别。\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306396231","body":"### 思路\n\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\n\n\n\n### 代码\n\n\n```py\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310824821","body":"### 思路\n双指针第一次相遇，第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 ，双指针第二次相遇：\n\nslow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 11 步；双指针第二次相遇：\n\nslow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 11 步；\n\n\n### 代码\n\n\n```py\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n**复杂度分析**\n时间复杂度 O(N)O(N) ：第二次相遇中，慢指针须走步数 a < a + ba<a+b；第一次相遇中，慢指针须走步数 a + b - x < a + ba+b−x<a+b，其中 xx 为双指针重合点与环入口距离；因此总体为线性复杂度；\n空间复杂度 O(1)O(1) ：双指针使用常数大小的额外空间。\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312914024","body":"### 思路\n如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。\n\n### 代码\n\n\n```py\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(min(m,n))\n- 空间复杂度：O(min(m,n))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316108439","body":"### 思路\n深度优先搜索\n### 代码\n\n\n```py\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数目。需要遍历 nn 个节点。\n\n空间复杂度：O(n)O(n)。递归栈需要占用 O(n)O(n) 的空间\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321257128","body":"### 思路\n题目所描述的回旋镖可以视作一个 V\\texttt{V}V 型的折线。我们可以枚举每个 points[i]\\textit{points}[i]points[i]，将其当作 V\\texttt{V}V 型的拐点。设 points\\textit{points}points 中有 mmm 个点到 points[i]\\textit{points}[i]points[i] 的距离均相等，我们需要从这 mmm 点中选出 222 个点当作回旋镖的 222 个端点，由于题目要求考虑元组的顺序，因此方案数即为在 mmm 个元素中选出 222 个不同元素的排列数，即：\n\n### 代码\n\n\n```py\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n^2)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326000667","body":"var subarraysDivByK = function(nums, k) {\n    let count = 0, sum = 0;\n    let map = {} ;\n    map[0] = 1;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        const mod = (sum % k + k) % k\n        if (map[mod])\n            count += map[mod];\n        map[mod] = (map[mod]|| 0) + 1;\n    }\n    return count;\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328375800","body":"class Solution:\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\nn = len(nums)\nq = [(-nums[i], i) for i in range(k)]\nheapq.heapify(q)\n\n    ans = [-q[0][0]]\n    for i in range(k, n):\n        heapq.heappush(q, (-nums[i], i))\n        while q[0][1] <= i - k:\n            heapq.heappop(q)\n        ans.append(-q[0][0])\n    \n    return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331718787","body":"class Solution {\n    public int findJudge(int N, int[][] trust) {\n        if (trust.length < N - 1) \n            return -1;\n        \n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\n        \n        for (int[] t : trust) {\n            trustScores[t[1]]++;\n            trustScores[t[0]]--;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (trustScores[i] == N - 1)\n                return i;\n        }\n        return -1;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300584266","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304546499","body":"#  用栈实现队列-python \n## 思路\n添加数据用stack1 append， pop/peek数据时stack1pop到stack2, stack2再pop出来\n```bash\nclass MyQueue():\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n         \n    def push(self, x):\n        self.stack1.append(x)\n    \n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n        \n    def peek(self):\n        val = self.pop()\n        self.stack2.append(val)\n        return val\n        \n    def empty(self):\n        if not self.stack1 and not self.stack2:\n            return True\n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304758987","body":"##768. 最多能完成排序的块 II-python\n\n解法1：排序\n```bash\n\nfrom collections import defaultdict\n\nclass Solution(object):\n    \n    def maxChunksToSorted(self, arr):\n        count_a = defaultdict(int)\n        count_b = defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n解法2：递增\n```bash\nclass Solution(object):\n    \n    def maxChunksToSorted(self, arr):\n        stack = []\n        for a in arr:\n            if stack:\n                if stack[-1] > a:\n                    cur = stack[-1]\n                    while stack and stack[-1] > a:\n                        stack.pop()\n                    stack.append(cur)   \n            else:\n                stack.append(a)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305515774","body":"''' \n61. 旋转链表\n\n求单链表的倒数第 N 个节点\n\ninput:  1->2->3->4->5->6->NULL, k = 2\noutput: 5->6->1->2->3->5->NULL\n\n双指针\n\n注意：\n1. k大于指针长度时: length%k\n2. 指针2比指针1快k步,当指针2到尾部时,指针1刚好到倒数第k+1个值,\n    此时 指针1.next=Null返回 head\n    此时 指针1.next!Null返回 指针1.next\n'''\n\n```bash\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        \nclass Solution(object):\n    def rotateRightList(self , head: ListNode, k) -> ListNode:\n        if head:\n            p1 = head\n            p2 = head\n        \n            i = 0\n            length = 0\n            while i<k:\n                if p2.next:\n                    p2 = p2.next\n                    i += 1\n                    length += 1\n                else:\n                    k = length%length\n                    i = 0\n                    p2 = head\n            \n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n            \n            if p1.next:\n                temp = p1.next\n            else:\n                return head\n            \n            p1.next = None\n            p2.next = head\n            \n            return temp\n```\n                ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1328218657","body":"```bash\nclass ListNode():\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution():\n    def changlist(self, head:ListNode):\n        if not head or not head.next: return head\n        \n        prehead = ListNode(-1)\n        prehead.next = head\n        \n        cur = prehead\n        \n        while cur.next and cur.next.next:\n            node1 = cur.next\n            node2 = node1.next\n            node3 = node2.next\n            \n            cur.next = node2\n            node1.next = node3\n            node2.next = node1\n            \n            cur = node1\n            node1 = node3\n            \n        return prehead.next\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1328218784","body":"```bash\n'''\n109. 有序链表转换二叉搜索树\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树\n(一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1)\n\n思路：\n让根节点左子树中的节点个数与右子树中的节点个数尽可能接近\n\nstep:\n1. 获取当前链表的中点\n2. 以链表中点为根\n3. 中点左边的值都小于它,可以构造左子树\n4. 同理构造右子树\n5. 循环第一步\n'''\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        \nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        \n        def getmid(left: ListNode, right: ListNode):\n            node1, node2 = left, left\n            while node2!=right and node2.next!=right:\n                node2=node2.next.next\n                node1=node1.next\n            return node1\n            \n        def bulid_tree(left: ListNode, right: ListNode):\n            if left == right:\n                return None # x\n            \n            mid = getmid(left, right)\n            node = TreeNode(mid.val)\n            node.left = bulid_tree(left, mid)\n            node.right = bulid_tree(mid.next, right)\n            return node # x\n        \n        return bulid_tree(head, None)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1328226687","body":"```bash\n'''160. 相交链表\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null\n'''\n\nclass ListNode():\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n    \nclass Solution:\n    def IntersectList(self, headA:ListNode, headB:ListNode):\n        \n        ## 遍历headA，存在哈希表中，将headB与哈希表对比\n        # if not headA or not headB:\n        #     return None\n        \n        # hashlist = []\n        # cur1 = headA\n        # while headA:\n        #     hashlist.append(cur1)\n        #     cur1 = cur1.next\n        \n        # cur2 = headB\n        # while headB:\n        #     if cur2 in hashlist:\n        #         return cur2\n        #     cur2 = cur2.next\n        \n        # return None\n        \n        ## 双指针\n        node1, node2 = headA, headB\n        while node1!=node2:\n            if node1:\n                node1 = node1.next\n            else:\n                node1 = headB\n                \n            if node2:\n                node2 = node2.next\n            else:\n                node2 = headA\n                \n        return node1\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1328232130","body":"```bash\n'''hash 或者 快慢指针\n'''\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode):\n        ## 遍历headA，存在哈希表中，将headB与哈希表对比\n        # if not head:\n        #     return None\n        \n        # hashlist = []\n        # cur1 = head\n        # while head:\n        #     if cur1 in hashlist:\n        #         return cur1\n        #     else:\n        #         hashlist.append(cur1)\n        #         cur1 = cur1.next\n        \n        # return None\n        \n        ## 双指针\n        node1, node2 = head, head\n        flag = False\n        while node2 and node2.next:\n            node2 = node2.next.next\n            node1 = node1.next\n            if node1 == node2:\n                flag = True\n                break\n        \n        if not flag:\n            return None\n        \n        node2 = head\n        while node1!=node2:\n            node1 = node1.next\n            node2 = node2.next\n        \n        return node1\n        \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1329064758","body":"```bash \n'''146. LRU 缓存机制\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n// put\nif key 存在:\n    更新节点值\n    把节点移到链表头部\n    \nelse:\n    if 缓存满了:\n        移除最后一个节点\n        删除它在哈希表中的映射\n\n    新建一个节点\n    把节点加到链表头部\n    在哈希表中增加映射\n\n// get\nif key 存在:\n    返回节点值\n    把节点移到链表头部\nelse:\n    返回 -1\n    \n'''\nfrom collections import OrderedDict\n\nclass solution():\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.dict = OrderedDict()\n    \n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        self.dict.move_to_end(key) # x 把节点移到链表头部\n        return self.dict[key]\n    \n    def put(self, key, value):\n        if key in self.dict:\n            self.dict.move_to_end(key)\n        self.dict[key] = value\n        \n        if len(self.dict) > self.capacity:\n            self.dict.popitem(last=False)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1329066534","body":"```bash\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        \nclass Solution:\n    def maxDepth(self, root:TreeNode): \n        if root==None: #叶子结点返回0\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n        \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313132641","body":"```bash\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        \n\nclass Solution:\n    def isSameTree(self , p: TreeNode, q:TreeNode):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val==q.val and \\\n            (self.isSameTree(p.left, q.left)) and \\\n                (self.isSameTree(p.right, q.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1316517896","body":"# 思路\nBFS 两个队列管理node 以及node对应的数字\n```bash\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass solution:\n    def sumtree(self, root: TreeNode):\n        if not root:\n            return 0\n        \n        nodequene = deque()\n        numquene = deque()\n        nodequene.append(root)\n        numquene.append(root.val)\n        \n        total = 0\n        \n        while nodequene:\n            length = len(nodequene)\n            \n            for i in range(length):\n                node = nodequene.popleft()\n                left, right = node.left, node.right\n                \n                num = numquene.popleft()\n                if not left and not right:\n                    total+=num\n                else:\n                    if left:            \n                        numquene.append(num*10 + left.val)\n                        nodequene.append(left)\n                    if right:\n                        numquene.append(num*10 + right.val)\n                        nodequene.append(right)\n\n        return total\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316516743","body":"# python\n思路 bfs\n```bash\nfrom collections import deque\nclass TreeNode():\n    def __init__(self, val=0, left=None, right=None) -> None:\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass Solution():\n    def find_bottom_left_value(self, root:TreeNode):\n        if not root:\n            return None\n        \n        nodequene = deque()\n        numquene = deque()\n\n        nodequene.append(root)\n        numquene.append(root.val)\n        \n        while nodequene:\n            length = len(nodequene)\n            num = nodequene[0].val\n            \n            for i in range(length):\n                node = nodequene.popleft()\n                left, right = node.left, node.right\n                \n                if left:\n                    numquene.append(left.val)\n                    nodequene.append(left)\n                if right:\n                    numquene.append(right.val)\n                    nodequene.append(right)\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318140840","body":"## bfs\n```bash\n# Definition for a binary tree node.\nfrom collections import deque\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        # if not root: return None\n        \n        nodequene = deque()\n        nodequene.append(root)\n        \n        ans = ''\n        while nodequene:\n            length = len(nodequene)\n            for _ in range(length):\n                node = nodequene.popleft()\n                if node:\n                    ans += str(node.val)+','\n                    left, right = node.left, node.right\n                    nodequene.append(left)\n                    nodequene.append(right)\n                else:\n                    ans+='null,'\n        return ans[:-1]\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        \n        nodequene = deque()\n        nodequene.append(root)\n        \n        i = 0\n        while i<len(nodes)-1:\n            node = nodequene.popleft()\n            left, right = nodes[i+1], nodes[i+2]\n            i += 2\n            if left!='null':\n                n_left = TreeNode(left)\n                node.left = n_left\n                nodequene.append(n_left)\n            if right!='null':\n                n_right = TreeNode(right)\n                node.right = n_right\n                nodequene.append(n_right)\n        return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Solution()\n# deser = Solution()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1328050175","body":"```bash\n''' 二叉树的垂序遍历\n'''\nclass TreeNode():\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution():\n    def verticalTraversal(self, root:TreeNode):\n        record = list()\n        \n        def dfs(node, row, col ):\n            record.append((col, row, node.val))\n            dfs(node.left, row+1, col-1)\n            dfs(node.right, row+1, col+1)\n            \n        dfs(root, 0, 0)\n        \n        record.sort()\n        \n        lastcol = float(\"-inf\")\n        ans = []\n        \n        for col, _, node_val in record:\n            if col != lastcol:\n                lastcol = col\n                ans.append([])\n            ans[-1].append(node_val)\n            \n        return ans\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325161039","body":"```bash\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    if differ[word] == 0:\n                        del differ[word]\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325936792","body":"同余定理\n```bash\nclass Solution:\n    def subarraysDivByK(self, nums, k):\n        record = {0: 1} # 初始化\n        total, ans = 0, 0\n        for nu in nums:\n            total += nu\n            modulus = total % k\n            same = record.get(modulus, 0)\n            record[modulus] = same + 1\n            ans += same\n        return ans\n    \n\nnums = [4,5,0,-2,-3,1]\nk=5\ns = Solution()\nans = s.subarraysDivByK(nums,k)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328038330","body":"'''快慢指针,快指针2,慢指针1\n'''\n```bash\nclass ListNode():\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        \nclass Solution():\n    def middlelist(self, head):\n        head1 = head\n        head2 = head\n        while head1 and head1.next:\n            head1 = head1.next.next\n            head2 = head2.next\n        return head2\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328036971","body":"```bash\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n-1,0,-1): \n            if nums[i] == nums[i-1]: \n                nums.pop(i)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328199017","body":"'''给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置\n   二分法\n'''\n```bash\nclass Solution():\n    def findvalue(self, nums, target):\n        # if not nums:\n        #     return None\n        \n        # flag = False\n        # for i, num in enumerate(nums):\n        #     if num != target:\n        #         continue\n        #     return i\n        \n        # if not flag:\n        #     for i, num in enumerate(nums[::-1]):\n        #         if target >= num:\n        #             return len(nums)-i\n        #     return 0\n        \n        ############################3\n        l = 0\n        r = len(nums)-1\n        \n        while(l<=r):\n            mid = (r+l)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328541210","body":"```bash\n'''239. 滑动窗口最大值\n给定一个数组 nums,有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n'''\n\nimport heapq\n\nclass Solution:\n    def shiftwindow(self, nums:list, k:int):\n        # # 超时了 O(nk)\n        # if not nums or not k:\n        #     return None\n        \n        # ans = []\n        # for i in range(len(nums)-k+1):\n        #     window = nums[i:i+k]\n        #     ans.append(max(window))\n            \n        # return ans\n    \n        # 堆\n        n = len(nums)\n        q = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(q)\n        \n        ans = [-q[0][0]]\n        for i in range(k, n):\n            heapq.heappush(q, (-nums[i], i))\n            while q[0][1] <= i-k:\n                heapq.heappop(q)\n            ans.append(-q[0][0])    \n        \n        return ans\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330039641","body":"```bash\n'''997. 找到小镇的法官\n   小镇的法官不相信任何人。\n   每个人（除了小镇法官外）都信任小镇的法官。\n   只有一个人同时满足条件 1 和条件 2\n   \n   思路：\n   找到入度为 n-1, 出度为 0 的点\n   \n   复杂度:O(n)\n'''\nclass Solution:\n     def findJudge(self, n, trust):\n        count = [0] * (n + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, n + 1):\n            if count[i] == n - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331624723","body":"```bash\n'''886. 可能的二分法\n   给定一组 N 人(编号为 1,2,...,N), 我们想把每个人分进任意大小的两组。\n   每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n   形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。\n   当可以用这种方法将每个人分进两组时,返回true; 否则返回false。\n   \n   # 二分图\n'''\n\nclass Solution:\n    def dfs(self, i, graph, colors, n, color=None):\n        colors[i]=color\n        for j in range(n):\n            if graph[i][j]!=1: #i不喜欢的人\n                continue\n            if colors[j]==color: #i不喜欢的人与i在同一组\n                return False\n            if colors[j]==0: #i不喜欢的人还没有分组\n                if not self.dfs(j, graph, colors, n, color=-1*color):\n                    return False\n        return True\n\n    def possibleBipartition(self, n, dislikes):\n        graph = [[0]*n for i in range(n)]\n        for (a, b) in dislikes:\n            graph[a-1][b-1]=1\n            graph[b-1][a-1]=1\n        \n        colors = [0]*n\n        for i in range(n):\n            if colors[i]!=0:\n                continue\n            if not self.dfs(i, graph, colors, n, color=1):\n                return False\n        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333339321","body":"```bash\n''' 公司共有 n 个项目和 m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责\n    拓扑排序：对于一张有向图 G,我们需要将 G 的 n 个点排列成一组序列，使得图中任意一对顶点 <u,v>,\n    如果图中存在一条 u→v 的边，那么 u 在序列中需要出现在 v 的前面\n'''\nfrom collections import defaultdict, deque\nimport numpy as np\n\nclass Solution:\n    \n    # 拓扑排序\n    def tp_sort(self, indegree, graph, items):\n        q = deque([])\n        ans = []\n        for item in items:\n            if indegree[item]==0:\n                q.append(item)\n        \n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n            \n            for neib in graph[cur]:\n                indegree[neib] -= 1\n                if indegree[neib]==0:\n                    q.append(neib)\n        return ans\n                    \n    def sortItems(self, n, m, group, beforeItems):\n        # 无人负责的项目单独为一组\n        max_group = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_group\n                max_group += 1\n                \n        project_graph = defaultdict(list)\n        project_indegree = defaultdict(int)\n        \n        group_graph = defaultdict(list)\n        group_indegree = defaultdict(int)\n        \n        group_projects = defaultdict(list)  \n        \n        for i in range(n):\n            # 一组处理的项目\n            group_projects[group[i]].append(i)\n            \n            # 如果一个项目和这个项目的依赖（如果存在）需要不同的组来完成，那么这两个组就拥有依赖关系\n            before_projects_i = beforeItems[i]\n            for before_project in before_projects_i:\n                if group[before_project] != group[i]: \n                    # 小组关系图\n                    group_indegree[group[i]] += 1\n                    group_graph[group[before_project]].append(group[i])\n                else:\n                    # 项目关系图\n                    project_indegree[i] += 1\n                    project_graph[before_project].append(i)\n        \n        # 先对group排序：\n        group_items = np.arange(max_group).tolist()\n        group_quene = self.tp_sort(group_indegree, group_graph, group_items)\n        \n        if len(group_quene) != max_group:\n            return []\n        \n        ans = []\n        for group_id in group_quene:\n            # 对每个group里的project排序\n            project_items = group_projects[group_id]\n            project_quene = self.tp_sort(project_indegree, project_graph, project_items)\n            \n            if len(project_quene) != len(project_items):\n                return []\n            \n            ans += project_quene\n            \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334697009","body":"```bash\nclass Solution:\n    def judgeCircle(self, moves: str):\n        begin = [0,0]\n\n        for m in moves:\n            if m == 'R':\n                begin[0]+=1\n            if m == 'L':\n                begin[0]+=-1\n            if m == 'U':\n                begin[1]+=1\n            if m == 'D':\n                begin[1]+=-1\n                \n        return begin == [0,0]\n        \n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300675274","body":"## 解题思路\r\n\r\n最初思路：先找到第一个 c，并把前面的距离填充好，后面再继续找 c，最后按左右对称来填充。\r\n看了题解：前后两趟遍历（Orz）\r\n\r\n## 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> ans(n);\r\n        int index;\r\n\r\n        index = -2*n; // 保证足够小，i - index 得到一个足够大的数。\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = i - index;\r\n        }\r\n\r\n        index = 2*n;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = min(ans[i], index - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复制度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302251142","body":"## 思路\n使用 vector 存放\n\n## 代码\n\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int top, max;\n\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (top == max - 1) {\n            return;\n        }else{\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：pop O(0), push O(1), inc O(k)\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303618337","body":"## 思路\n用栈实现类似计算器的操作\n\n## 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466540","body":"# 思路\r\n\r\n两个栈之间移动元素\r\n\r\n# 代码\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            int x = inStack.top();\r\n            outStack.push(x);\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n    \r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304990179","body":"# 思路\r\n基本思路：\r\n找到关键的 3 个点（断开部分的两个点 p1、p2、尾部节点 p3），利用穿针引线法连接。\r\n\r\n大致步骤：\r\n- 判断边界条件：当 K 为 0，链表长度为 0、1  时不需要旋转。\r\n- 求解移动长度：k = k % len。在这确定尾部节点，设置为 p3。\r\n- 设置快慢指针：让快指针先走 k 步。在这确定断开的两个点，设置为 p1 和 p2。\r\n- 将各个点相连，返回 p2。\r\n\r\n# 算法\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(k == 0 || head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode *cur = head;\r\n        while(cur->next != nullptr){\r\n            len+=1;\r\n            cur = cur->next;\r\n        }\r\n        k = k % len;\r\n        if(k == 0){\r\n            return head;\r\n        }\r\n\r\n        ListNode *p1, *p2, *p3, *slow, *fast;\r\n        p3 = cur;\r\n\r\n        slow = head;\r\n        fast = head;\r\n        while(k-- > 0){\r\n            fast = fast->next;\r\n        }\r\n\r\n        while(fast->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        p1 = slow;\r\n        p2 = slow->next;\r\n\r\n        p3->next = head;\r\n        p1->next = nullptr;\r\n\r\n        return p2;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306496624","body":"## 思路\n基本思路：\n使用四点法交换节点。\n\n大致步骤：\n1. 判断边界条件进行打表。\n2. 设置 dummy 头。\n3. 使用 cur 指针遍历链表，每次移动两步。\n4. 在遍历过程中利用四点法不断交换节点。\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        \n        ListNode dummy;\n        dummy.next = head;\n        ListNode *p1, *p2, *p3, *p4, *cur = &dummy;\n        while(cur != nullptr && cur->next != nullptr && cur->next->next != nullptr){\n            p1 = cur;\n            p2 = cur->next;\n            p3 = cur->next->next;\n            p4 = cur->next->next->next;\n\n            p1->next = p3;\n            p3->next = p2;\n            p2->next = p4;\n\n            cur = cur->next->next;\n        }\n        return dummy.next;\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308177600","body":"类似 105. 从前序与中序遍历序列构造二叉树\n\n# 思路\n\n基本思路：\n每次构建一个节点。使用中间节点构建当前节点，使用左侧的节点构建左子树，使用右侧的节点构建右子树。\n\n大致流程：\n1. 将当前子树的序列作为参数。\n2. 根据子树序列的中值作为根节点。\n3. 以中值划分左右子树，递归构建左子树和右子树。\n\n# 代码\n\n```c++\nclass Solution {\nprivate:\n    deque<int> values;\n\npublic:\n    TreeNode* buildTree(int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode(values[mid]);\n        root->left = buildTree(left, mid-1);\n        root->right = buildTree(mid+1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        while(head != nullptr){\n            values.push_back(head->val);\n            head = head->next;\n        }\n        return buildTree(0, values.size() - 1);\n    }\n};\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309724960","body":"## 基本思路\n\n- 走到尽头见不到你，于是走你来时的路，等到相遇时才发现，你也走过我来时的路。\n\n\n\n## 大致步骤\n\n1. pA 和 pB 将两个链表都遍历一遍，但 pA 从 A 链表开始，pB 从 B 链表开始。当 pA 等于 pB 时，pA/pB 要么指向 NULL，要么指向同一个节点。\n2. pA 和 pB 同时进行遍历。\n3. 如果 pA 遍历完 A 链表，那么让 pA 在继续遍历 B 链表。\n4. 如果 pB 遍历完 B 链表，那么让 pB 在继续遍历 A 链表。\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pA, *pB;\n        pA = headA;\n        pB = headB;\n\n        while(pA != pB){\n            if(pA == NULL){\n                pA = headB;\n            }else{\n                pA = pA->next;\n            }\n            if(pB == NULL){\n                pB = headA;\n            }else{\n                pB = pB->next;\n            }\n        }\n        return pA;\n    }\n};\n```\n\n\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311169395","body":"## 基本思路：\n\n简化模型，最后求得快慢指针相交点和链表相交点的关系 a=c+(n-1)(b+c)\n\n\n\n## 大致步骤：\n\n1. 打表。\n1. 使用 head 指针遍历链表，并设置快指针每次走两步。\n1. 如果没有环 head 会等于 NULL，否则会一直循环。\n1. 如果快慢指针移动到相交的地方， 定义 ptr 指针从链表头开始，直到慢指针和 ptr 指针重合，退出循环。\n1. 返回 head 指针。\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == NULL){\n            return NULL;\n        }\n\n        ListNode *fast, *ptr;\n        fast = ptr = head;\n\n        while(head != NULL){\n            head = head->next;\n            if(fast->next != NULL && fast->next->next != NULL){\n                fast = fast->next->next;\n            }else{\n                head = NULL;\n                break;\n            }\n\n            if(fast == head){\n                while(ptr != head){\n                    ptr = ptr->next;\n                    head = head->next;\n                }\n                break;\n            }\n        }\n\n        return head;\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312295522","body":"## 基本思路：\n\n- get：哈希字典查找 O(1)。\n- put：将节点放入链表尾部 O(1)。\n\n\n\n## 大致步骤：\n\n1. put：从哈希字典中寻找 key，如果找到该节点，那么把节点放在最前面（和 get 相同）。如果没有找到该节点，那么在最前面插入一个节点。如果超过容量，那么就从尾部删除一个节点。\n2. get：从哈希字典中寻找 key，如果找到该节点，那么把节点放在最前面。\n\n\n\n## 代码：\n\n```c++\nstruct DNode{\n    int key, value;\n    DNode* prev;\n    DNode* next;\n    DNode(): key(0), value(0), prev(nullptr), next(nullptr){}\n    DNode(int k, int v): key(k), value(v), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DNode*> _cache;\n    DNode *_head;\n    DNode *_tail;\n    int _size;\n    int _capacity;\n\n    DNode* removeTail(){\n        DNode *node = _tail->prev;\n        removeNode(node);\n        return node;\n    }\n\n    void removeNode(DNode *node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void addNodeToHead(DNode *node){\n        _head->next->prev = node;\n        node->next = _head->next;\n        _head->next = node;\n        node->prev = _head;\n    }\n\n    void moveToHead(DNode *node){\n        removeNode(node);\n        addNodeToHead(node);\n    }\n\npublic:\n    LRUCache(int capacity): _capacity(capacity), _size(0) {\n        _head = new DNode();\n        _tail = new DNode();\n        _head->next = _tail;\n        _tail->prev = _head;\n    }\n    \n    int get(int key) {\n        if(!_cache.count(key)){\n            return -1;\n        }\n        DNode *node = _cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        DNode *node, *removed;\n        if(!_cache.count(key)){\n            node = new DNode(key, value);\n            addNodeToHead(node);\n            _cache[key] = node;\n            _size+=1;\n            if(_size > _capacity){\n                removed = removeTail();\n                _cache.erase(removed->key);\n                _size--;\n                delete removed;\n            }\n        }else{\n            node = _cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：put=O(1)、get=O(1)\n- 空间复杂度：put=O(1)、get=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312591979","body":"## 基本思路：\n\n- 直接套层序遍历模版\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr){\n            return 0;\n        }\n        queue<TreeNode *> q;\n        TreeNode *node;\n        int step, size, i;\n        \n        step = 0;\n        q.push(root);\n        \n        while(!q.empty()){\n            size = q.size();\n            for(i=0; i<size; i++){\n                node = q.front();\n                q.pop();\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            step+=1;\n        }\n\n        return step;\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1314695030","body":"## 基本思路：\r\n\r\n- 递归判断当前节点、左子树、右子树。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表，当 p 或 q 树有空节点。\r\n2. 当前节点、左子树、右子树都相同时，左右子树相同。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p == nullptr || q == nullptr){\r\n            return p == q;\r\n        }\r\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(min(m, n))\r\n- 空间复杂度：O(min(m, n))","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314744258","body":"## 基本思路：\r\n\r\n- 「自顶向下」求子树和，「自底向上」算节点值。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表。分别讨论：空节点、叶子节点。\r\n2. 求解下一个子树的 base 值。\r\n3. 将左子树和右子树的值相加，作为当前节点的值。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    int dfs(TreeNode* root, int pre){\r\n        if(root == nullptr){\r\n            return 0;\r\n        }\r\n        if(root->left == nullptr && root->right == nullptr){\r\n            return pre*10 + root->val;\r\n        }\r\n        \r\n\r\n        int cur = pre*10 + root->val;\r\n        return dfs(root->left, cur) + dfs(root->right, cur);\r\n    }\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316109310","body":"## 基本思路：\r\n\r\n- BFS 找到最底层最左侧的节点。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 使用层序遍历模版。\r\n2. 使用 flag 来判断是不是第一个节点，根据叶子节点判断是不是最底层。如果两个条件都满足，更新 ans。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode *> q;\r\n        q.push(root);\r\n        int size, i;\r\n        TreeNode *node;\r\n        int ans;\r\n        bool flag;\r\n\r\n        while(!q.empty()){\r\n            size = q.size();\r\n            flag = true;\r\n\r\n            for(i=0; i<size; i++){\r\n                node = q.front();\r\n                q.pop();\r\n\r\n                if(flag && node->left == nullptr && node->right == nullptr){\r\n                    ans = node->val;\r\n                    flag = false;\r\n                }\r\n                if(node->left != nullptr){\r\n                    q.push(node->left);\r\n                }\r\n                if(node->right != nullptr){\r\n                    q.push(node->right);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(2^h-1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318422465","body":"## 基本思路：\r\n\r\n- 深度优先搜索\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n- 序列化：\r\n  1. 使用前序遍历，将所有节点保存起来（包括空节点）。\r\n- 反序列化\r\n  1. 从左到右遍历序列。\r\n  2. 打表。如果当前元素为 None，则当前为空树。\r\n  3. 构建当前节点。\r\n  4. 递归构建左子树，递归构建右子树。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319431161","body":"## 基本思路：\r\n\r\n- 按照（列、行、节点值）进行排序。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历二叉树，保存所有节点。\r\n2. 按照（列、行、节点值）进行排序。\r\n3. 按照 col 分割，放到 ans 数组中。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    vector<tuple<int, int, int>> nodes;\r\n    void dfs(TreeNode* root, int col, int row){\r\n        if(root == nullptr){\r\n            return;\r\n        }\r\n        nodes.emplace_back(col, row, root->val);\r\n        dfs(root->left, col-1, row+1);\r\n        dfs(root->right, col+1, row+1);\r\n    }\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n\r\n        vector<vector<int>> ans;\r\n        int cur_row = INT_MIN;\r\n\r\n        for(const auto &[col, row, val]: nodes){\r\n            if(cur_row != col){\r\n                cur_row = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().emplace_back(val);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320667596","body":"## 基本思路：\r\n\r\n- 空间换时间\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 使用字典将遍历过的点都记录下来。\r\n2. 如果遇到合适的点，那么就直接退出循环并返回结果。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> res;\r\n        int i;\r\n        for(i=0; i<nums.size(); i++){\r\n            if(res.count(nums[i])){\r\n                break;\r\n            }\r\n            res[target - nums[i]] = i;\r\n        }\r\n        return vector<int>{res[nums[i]], i};\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321363203","body":"## 基本思路：\r\n\r\n- 利用堆获取前 k 个。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历数组，统计出现次数。\r\n1. 将数组存入小顶堆，然后维护小顶堆的大小为 k。\r\n1. 最后将小顶堆转换为数组返回。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    static bool cmp(const pair<int, int>& n, const pair<int, int>& m){\r\n        return n.second > m.second;\r\n    }\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for(const auto& num: nums){\r\n            occurrences[num]++;\r\n        }\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for(const auto &[num, count]: occurrences){\r\n            if(q.size() < k){\r\n                q.emplace(num, count);\r\n            }else{\r\n                if(q.top().second < count){\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            }\r\n        }\r\n\r\n        vector<int> ans;\r\n        while(!q.empty()){\r\n            ans.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(Nlogk)，哈希表记录的时间复杂度是 O(N)，每次堆操作需要 O(logk)，累计需要 O(Nlogk)。\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321406992","body":"## 基本思路：\r\n\r\n- 枚举+哈希表+求排列数。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 将所有节点设置为出发点。\r\n2. 求点到点的距离，并保存距离的个数。\r\n3. 求解排列数。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        unordered_map<int, int> count;\r\n        int distants, ans;\r\n        ans = 0;\r\n\r\n        for(const auto & point: points){\r\n            count.clear();\r\n            for(const auto & p: points){\r\n                if(p != point){\r\n                    distants = (point[0] - p[0]) * (point[0] - p[0]) + (point[1] - p[1]) * (point[1] - p[1]);\r\n                    count[distants]++;\r\n                }\r\n            }\r\n            for (auto &[_, m] : count) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n*n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323128794","body":"## 基本思路：\r\n\r\n- 滑动窗口+哈希集合\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 左指针 i 从 0 到 n-1，每次移动都删掉一个哈希集合中的元素。\r\n2. 右指针 rk 从 0 向右移动，直到发现重复字符。\r\n3. 保存最长子串的长度 rk - i。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_set<char> occ;\r\n        int i, rk = 0, size=s.size(), ans = 0;\r\n        for(i=0; i<size; i++){\r\n            if(i>0){\r\n                occ.erase(s[i-1]);\r\n            }\r\n            while(rk<size && occ.count(s[rk]) == 0){\r\n                occ.insert(s[rk]);\r\n                rk++;\r\n            }\r\n            if(ans < rk-i){\r\n                ans = rk-i;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(k)，k 为最长子串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324935324","body":"```c++\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int totalLen = s.length();\r\n        int len = words[0].length();\r\n        int n = words.length;\r\n        if (n*totalLen == 0){\r\n            return result;\r\n        }\r\n        HashMap<String,Integer> wordMap = new HashMap<>();\r\n        for (String word:words) {\r\n            int value = wordMap.getOrDefault(word, 0);\r\n            wordMap.put(word,value+1);\r\n        }\r\n        \r\n        for (int i = 0; i <totalLen-n*len+1; i++) {\r\n          \r\n            Map<String,Integer> hasWords = new HashMap<>();\r\n            int num = 0;\r\n            while (num < n){\r\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\r\n                if (wordMap.containsKey(currWord)){\r\n                    int value = hasWords.getOrDefault(currWord,0);\r\n                    hasWords.put(currWord,value+1);\r\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n                num++;\r\n            }\r\n            if (num == n){\r\n                result.add(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328528952","body":"## 基本思路：\r\n\r\n- 快慢指针\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode *slow=head, *fast=head;\r\n        while(fast != nullptr && fast->next != nullptr){\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328526240","body":"## 基本思路：\r\n\r\n- 双指针\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表。\r\n2. 快慢指针都从第一个元素开始。\r\n3. 当 fast 小于 n 时，如果找到不相同的值改变 slow 位置的值并且移动 slow，每次 fast 都 +1。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if(n == 0){\r\n            return 0;\r\n        }\r\n        int fast = 1, slow = 1;\r\n        while(fast <= n-1){\r\n            if(nums[fast] != nums[fast-1]){\r\n                nums[slow++] = nums[fast]; \r\n            }\r\n            fast++;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328167354","body":"## 基本思路：\r\n\r\n- 二分查找\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 定义左指针和右指针。\r\n2. 当左指针小于或等于右指针时，根据中间值移动 l 或 r。\r\n3. 返回 l（如果等于，取左）。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int size = nums.size();\r\n        int l = 0, r = size-1, mid;\r\n        while(l <= r){\r\n            mid = l + (r-l)/2;\r\n            if(nums[mid] < target){\r\n                l = mid+1;\r\n            }else{\r\n                r = mid-1;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(log(n))\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330371642","body":"## 基本思路：\r\n\r\n- 计算各节点的入度和出度\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历所有节点，保存入度和出度。\r\n2. 遍历所有的居民（1, n），找出符合条件的居民（入度为 n-1，出度为 0）。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDegree(n+1);\r\n        vector<int> outDegree(n+1);\r\n        int i, size = trust.size();\r\n        for(i=0; i<size; i++){\r\n            outDegree[trust[i][0]]++;\r\n            inDegree[trust[i][1]]++;\r\n        }\r\n        for(i=1; i<n+1; i++){\r\n            if(inDegree[i] == n-1 && outDegree[i] == 0){\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n+m), m 是 Trust 的长度，n 是居民人数。\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332042657","body":"## 基本思路：\r\n\r\n- 深度优先搜索\r\n- 染色法\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 定义 color 数组存储每个人的颜色，定义 g 数组存储不能与某个人在一组的人。\r\n2. 遍历每个人，使用深度优先搜索检验是否分配到了不同的组。如果分配到了相同的组，则返回 false。\r\n3. 如果没有找到不符合规范的人，则返回 true。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\r\n        color[curnode] = nowcolor;\r\n        for (auto& nextnode : g[curnode]) {\r\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\r\n                return false;\r\n            }\r\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        vector<int> color(n + 1, 0);\r\n        vector<vector<int>> g(n + 1);\r\n        for (auto& p : dislikes) {\r\n            g[p[0]].push_back(p[1]);\r\n            g[p[1]].push_back(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(m+n), n 是题目中给定的人数，m 为给定的 dislike 数组的大小。\r\n- 空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333284225","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\r\n        queue<int> Q;\r\n        for (auto& item: items) {\r\n            if (deg[item] == 0) {\r\n                Q.push(item);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while (!Q.empty()) {\r\n            int u = Q.front(); \r\n            Q.pop();\r\n            res.emplace_back(u);\r\n            for (auto& v: graph[u]) {\r\n                if (--deg[v] == 0) {\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : vector<int>{};\r\n    }\r\n\r\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\r\n        vector<vector<int>> groupItem(n + m);\r\n\r\n        // 组间和组内依赖图\r\n        vector<vector<int>> groupGraph(n + m);\r\n        vector<vector<int>> itemGraph(n);\r\n\r\n        // 组间和组内入度数组\r\n        vector<int> groupDegree(n + m, 0);\r\n        vector<int> itemDegree(n, 0);\r\n        \r\n        vector<int> id;\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.emplace_back(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        // 给未分配的 item 分配一个 groupId\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem[group[i]].emplace_back(i);\r\n        }\r\n        // 依赖关系建图\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (auto& item: beforeItems[i]) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph[item].emplace_back(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 组间拓扑关系排序\r\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return vector<int>{};\r\n        } \r\n        vector<int> ans;\r\n        // 组内拓扑关系排序\r\n        for (auto& curGroupId: groupTopSort) {\r\n            int size = groupItem[curGroupId].size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\r\n            if (res.size() == 0) {\r\n                return vector<int>{};\r\n            }\r\n            for (auto& item: res) {\r\n                ans.emplace_back(item);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336098381","body":"## 基本思路：\r\n\r\n- 模拟\r\n- 堆\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 对 task 进行排序，并将下标存入 indices 数组。\r\n1. 遍历 indices 数组，每次处理一个任务，并更新时间戳。如果没有任务处理，就根据 ptr 来更新时间戳，并将任务放入优先队列中。\r\n1. 返回 ans 数组。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    using PII = pair<int, int>;\r\n    using LL = long long;\r\n\r\npublic:\r\n    vector<int> getOrder(vector<vector<int>>& tasks) {\r\n        int n = tasks.size();\r\n        vector<int> indices(n);\r\n        iota(indices.begin(), indices.end(), 0);\r\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\r\n            return tasks[i][0] < tasks[j][0];\r\n        });\r\n\r\n        vector<int> ans;\r\n        // 优先队列\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\r\n        // 时间戳\r\n        LL timestamp = 0;\r\n        // 数组上遍历的指针\r\n        int ptr = 0;\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            // 如果没有可以执行的任务，直接快进\r\n            if (q.empty()) {\r\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\r\n            }\r\n            // 将所有小于等于时间戳的任务放入优先队列\r\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\r\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\r\n                ++ptr;\r\n            }\r\n            // 选择处理时间最小的任务\r\n            auto&& [process, index] = q.top();\r\n            timestamp += process;\r\n            ans.push_back(index);\r\n            q.pop();\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300705109","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int leng = s.length();\r\n        int[] ans = new int[leng];\r\n        for (int i=0, flag=-leng; i<leng; ++i) {\r\n            if (s.charAt(i)==c) {\r\n                flag = i;\r\n            }\r\n            ans[i] = i - flag;\r\n        }\r\n        for (int i=leng-1, flag=2*leng; i>=0; --i) {\r\n            if (s.charAt(i)==c) {\r\n                flag = i;\r\n            }\r\n            ans[i] = Math.min(ans[i], flag-i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304547233","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> sIn;\r\n    Deque<Integer> sOut;\r\n\r\n    public MyQueue() {\r\n        sIn = new ArrayDeque<Integer>();\r\n        sOut = new ArrayDeque<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        sIn.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (sOut.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return sOut.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (sOut.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return sOut.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if (sIn.isEmpty() && sOut.isEmpty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!sIn.isEmpty()) {\r\n            int x = sIn.pop();\r\n            sOut.push(x);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304705799","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> numbers = new ArrayDeque<>();\r\n        for (int i=0; i<arr.length; i++) {\r\n            if (numbers.isEmpty() || numbers.peek() <= arr[i]) {\r\n                numbers.push(arr[i]);\r\n            } else {\r\n                int val = numbers.pop();\r\n                while (!numbers.isEmpty() && numbers.peek() > arr[i]) {\r\n                    numbers.pop();\r\n                }\r\n                numbers.push(val);\r\n            }\r\n        }\r\n        return numbers.size();\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n其中 N 为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305793408","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if (not head) or (not head.next):\r\n            return head\r\n        cnt = 0\r\n        p = head\r\n        while p:\r\n            cnt += 1\r\n            p = p.next\r\n        k = k % cnt\r\n        if k == 0:\r\n            return head\r\n        p = head\r\n        for i in range(cnt-k-1):\r\n            p = p.next\r\n        mark_tail = p\r\n        p = p.next\r\n        mark_tail.next = None\r\n        new_head = p\r\n        while p.next != None:\r\n            p = p.next\r\n        p.next = head\r\n        return new_head\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312759784","body":"递归\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315506045","body":"```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n\r\n    public int dfs(TreeNode root, int prevSum) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root.val;\r\n        if (root.left == null && root.right == null) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root.left, sum) + dfs(root.right, sum);\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323682277","body":"```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:\r\n            return 0\r\n        l = [0]\r\n        for i in range(1, len(s)):\r\n            pres = s[l[i-1]:i]\r\n            if s[i] not in pres:\r\n                l.append(l[i-1])\r\n            else:\r\n                l.append(l[i-1] + pres.index(s[i]) + 1)\r\n        return max([i-v+1 for i, v in enumerate(l)])\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328263837","body":"```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int n = nums.length;\r\n        int left = 0, right = n - 1, ans = n;\r\n        while (left<=right) {\r\n            int mid = (left + right) >> 1;\r\n            if (nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid - 1;\r\n                ans = mid;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332141770","body":"```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        int[] color = new int[n + 1];\r\n        List<Integer>[] g = new List[n + 1];\r\n        for (int i = 0; i <= n; ++i) {\r\n            g[i] = new ArrayList<Integer>();\r\n        }\r\n        for (int[] p : dislikes) {  // 建立依赖\r\n            g[p[0]].add(p[1]);\r\n            g[p[1]].add(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {  // 未染色，不能染上第一种颜色\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\r\n        color[curnode] = nowcolor;\r\n        for (int nextnode : g[curnode]) {\r\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {  // 已染色，色同\r\n                return false;\r\n            }\r\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {  // 未染色，不能染上另一色 3^1=2 3^2=1\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298865077","body":"# 思路 \r\n- List 的长度和 k的长度谁大谁小\r\n- 逐位相加 (Two Number Add)\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int p1 = num.length - 1;\r\n        int sum = 0;\r\n        int carry = 0;\r\n        int a = 0;\r\n        int b = 0;\r\n\r\n        while(p1 >= 0 || k != 0){\r\n            a = p1 >= 0 ? num[p1] : 0;\r\n            b = k != 0 ? (k % 10) : 0;\r\n                \r\n            sum = a + b + carry;\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            \r\n            p1--;\r\n            res.add(0, sum % 10);\r\n        }\r\n\r\n        if(carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}\r\n\r\n// Time Complexity: O(n) \r\n// Space Complexity: O(n)\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301181920","body":"class CustomStack {\r\n    \r\n    private int[] arr;\r\n    private int   curr = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (curr+1 < arr.length) {\r\n            arr[++curr] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return curr < 0 ? curr : arr[curr--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301632698","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n \n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n        \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(k, len(self.stack))):\n            self.stack[i] += val","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304682841","body":"/**\r\n    思路: 维护一个单调递增的stack\r\n    TC: O(N), SC: O(N)\r\n*/\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n          stack = []\r\n          for num in arr:\r\n              if not stack or num >= stack[-1]:\r\n                  stack.append(num)\r\n              else:\r\n                  pop_num = stack.pop()\r\n                  while stack and stack[-1] > num:\r\n                      stack.pop()\r\n                  stack.append(pop_num)\r\n          return len(stack)\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312142028","body":"思路:\r\n这是一个经常常考叠加design的题。主要还是根据要求的几个function进行分别设计。我是运用了ordereddict这么一个已有结构进行设计。实质上还是哈希。\r\n\r\n```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n     \r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self)> self.capacity:\r\n            self.popitem(last = False)\r\n```\r\n\r\n复杂度：\r\nTC: O(1)\r\nSC: O(n)    ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327998932","body":"思路：\r\n类似于快慢指针。只有不同时才copy后一个数字给前一位，并且更新左指针。 不然就一直挪动后一位。那么结果就是左指针的index。\r\n\r\n```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        len_ = 1\r\n        if len(nums)==0:\r\n            return 0\r\n        for i in range(1,len(nums)):\r\n            if nums[i] != nums[i-1]:\r\n                nums[len_] = nums[i]\r\n                len_ +=1\r\n        return len_\r\n```\r\n\r\nTC:  O(n)\r\nSC: O(1）不需要额外空间储存。只需要更新左指针的index","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334784324","body":"思路:  x是水平移动，y是上下移动\n```\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0\n```\nTC O(n) \nSC O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302262952","body":"```java\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n学习一下","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302840545","body":"```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304548436","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<Integer>();\r\n        outStack = new ArrayDeque<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304817122","body":"```java\r\npublic class Solution {\r\n\r\n     public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0;\r\n        int nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i];\r\n            int y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) {\r\n                nonzero--;\r\n            }\r\n            if (count.get(x) == 1) {\r\n                nonzero++;\r\n            }\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) {\r\n                nonzero++;\r\n            }\r\n            if (count.get(y) == 0) {\r\n                nonzero--;\r\n            }\r\n\r\n            if (nonzero == 0) {\r\n                ans++;\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305148682","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while(now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        k = k % count;\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null){\r\n            if(k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315342382","body":"```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int sum = 0;\r\n\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = queue.poll();\r\n\r\n                if (cur.left == null && cur.right == null) {\r\n                    sum = sum + cur.val;\r\n                }\r\n\r\n                if (cur.left != null) {\r\n                    cur.left.val = cur.val * 10 + cur.left.val;\r\n                    queue.offer(cur.left);\r\n                }\r\n\r\n                if (cur.right != null) {\r\n                    cur.right.val = cur.val * 10 + cur.right.val;\r\n                    queue.offer(cur.right);\r\n                }\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302322956","body":"```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const n = num.length;\r\n    let carry = 0;\r\n    let res = 0;\r\n    let i = n-1;\r\n    let arr = [];\r\n    while(i>=0 || k!=0) {\r\n        const a = i>=0 ? num[i] : 0\r\n        const b = k!=0 ? k%10 : 0;\r\n        res = a+b+carry;\r\n        arr.push(res%10)\r\n        carry = Math.floor(res/10) \r\n\r\n        i--;\r\n        k=Math.floor(k/10);\r\n    }\r\n\r\n\r\n    if(carry) {\r\n        arr.push(carry)\r\n    }\r\n    arr.reverse()\r\n    return arr\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302326047","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let n = s.length;\r\n    let resArr = new Array(n).fill(0);\r\n    for(let i=0, cIndex=-n; i<n; i++){\r\n        if(s[i] === c) {\r\n            cIndex = i;\r\n        }\r\n        resArr[i] = i-cIndex;\r\n    }\r\n\r\n    for(let i=n-1, cIndex=2*n; i>=0; i--){\r\n        if(s[i] === c) {\r\n            cIndex = i;\r\n        }\r\n        resArr[i] = Math.min( resArr[i], cIndex - i);\r\n    }\r\n  \r\n    return resArr\r\n};\r\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305592578","body":"### 代码\n```javasscript\nvar rotateRight = function(head, k) {\n    // 只有一位直接返回\n    if(!head || !head.next) return head; \n    // 求链表长度\n    let len = 0,now = head;\n    while(now){\n        now = now.next;\n        len++;\n    }\n    // 当k大于链表长度则取余\n    k = k % len;\n    // 快慢指针\n    let slow = (fast = head);\n    while(fast.next){\n        if(k-- <= 0){\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n    let res = slow.next;\n    slow.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307193677","body":"### 代码\n```javascript\nvar swapPairs = function(head) {\n    while(head == null || head.next === null) {\n        return head\n    }\n\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head\n    return newHead\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313789900","body":"### 思路\n深度遍历\n终止条件\n1. 两个都是null true\n2. 其中一个为null false\n3. 相同位置值不相等 false\n\n### 代码\n```javascript\nvar isSameTree = function(p, q) {\n    if(p===null && q===null) {\n        return true\n    }\n    if(p===null || q===null) {\n        return false\n    }\n    if(p.val !== q.val ) {\n        return false\n    }\n\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315338979","body":"### 思路\n深度优先搜索 \n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，对其子节点递归遍历，求其子节点对应的数据\n### 代码\n```javascript\nvar sumNumbers = function(root) {\n    return dfs(root,0)\n};\n\nconst dfs = (root, preNvm) => {\n    if (root == null){\n       return 0;\n    }\n    let sum = preNvm * 10 + root.val;\n    if (root.left == null && root.right == null) {\n        return sum\n    } else {\n        return dfs(root.left,sum) + dfs(root.right,sum)\n    } \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317124078","body":"### 思路\n深度优先搜索\n先遍历左子树，然后遍历右子树。遍历的过程中记下深度\n### 代码\n```javascript\nvar findBottomLeftValue = function(root) {\n    const dfs = (root, height) => {\n        if(root == null) {\n            return\n        }\n        height++\n        dfs(root.left,height)\n        dfs(root.right,height)\n        if(height > curHeight) {\n            curHeight = height\n            curVal = root.val\n        }\n    }\n    let curHeight = 0;\n    dfs(root, 0)\n    return curVal\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321088426","body":"### 思路\n哈希表存储每个值的个数，然后对每个值的个数进行排序，取k个，并返回\n### 代码\n```javascript\nvar topKFrequent = function(nums, k) {\n  var map = new Map()\n  var len = nums.length\n  for (var i = 0; i < len; i++) {\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\n  }\n  return [...map]\n    .sort((a, b) => b[1] - a[1])\n    .filter((v, i) => i < k)\n    .map(v => v[0])\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302485327","body":"'''\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = ''\r\n        stack = []\r\n        cur_num = 0\r\n        \r\n        for i in range(len(s)):\r\n            if s[i].isdigit():\r\n                cur_num = cur_num*10 + int(s[i])\r\n            elif s[i] == '[':\r\n                stack.append((ans,cur_num))\r\n                ans = ''\r\n                cur_num = 0\r\n                \r\n            elif s[i] == ']':\r\n                cur_str, n = stack.pop()\r\n                ans = cur_str + ans *n\r\n            else:\r\n                ans += s[i]\r\n        return ans\r\n'''\r\nO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304641977","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        #chunk in previous chunk should small than nums in following chunk\n        lowest_right = [-1 for i in range(len(arr))] #each pos store the lowest value on right side\n        maxnum = float('inf')\n        #update to each pos store the lowest value on right side\n        for i in range(len(arr)-1,-1,-1):\n            lowest_right[i] = maxnum\n            maxnum = min(arr[i],maxnum)\n        \n        ans = 0\n        i = 0\n        largest_left = -1\n        while i < len(arr):\n            largest_left = max(arr[i],largest_left)\n            if arr[i]<= lowest_right[i] and largest_left<= lowest_right[i]:\n                ans += 1\n                i += 1\n            else:\n                i+=1\n\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307795096","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return\n        #don't miss this\n        if not head.next:\n            return TreeNode(head.val)\n        slow,fast = head, head.next.next\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        \n        temp = slow.next\n        slow.next = None\n        root = TreeNode(temp.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(temp.next)\n        \n        return root\n        ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312367781","body":"```\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dic = collections.OrderedDict()\n        \n\n    def get(self, key: int) -> int:\n        if key in self.dic:\n            v = self.dic[key]\n            \n            self.dic.pop(key)\n            self.dic[key] = v\n            \n            return v\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dic:\n            self.dic.pop(key)\n            self.dic[key] = value\n        else:\n            if len(self.dic)>= self.capacity:\n                self.dic.popitem(last=False) \n                self.dic[key] = value\n            else:\n                self.dic[key] = value\n```        \n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312843982","body":"class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316144330","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            length = len(queue)\n            ans = queue[0].val\n            for i in range(length):\n                node = queue.popleft()\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318118813","body":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return ''\n        queue = deque()\n        queue.append(root)\n        nodes = []\n        while queue:\n            cur = queue.popleft()\n            if not cur:\n                nodes.append('n')\n                continue\n            else:\n                nodes.append(str(cur.val))\n            queue.append(cur.left)\n            queue.append(cur.right)\n        return \",\".join(nodes)\n            \n\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        nodes= data.split(',')\n        if not nodes:\n            return None\n        print(nodes)\n        root = TreeNode(nodes[0])\n        queue = deque([root])\n        i = 1\n        while i<len(nodes)-1:\n            node = queue.popleft()\n            if nodes[i] !=  'n':\n                l = TreeNode(nodes[i])\n                queue.append(l)\n                node.left = l\n            if nodes[i+1] !=  'n':\n                r = TreeNode(nodes[i+1])\n                queue.append(r)\n                node.right = r\n\n            i += 2\n        return root\n\n        return root\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320973704","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for i in nums:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n        \n        dic = sorted(dic, key = dic.get, reverse = True)\n        #print(dic)\n        ans = []\n        count = 0\n        for i in dic:\n            if count == k:\n                break\n            ans.append(i)\n            count += 1\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322860892","body":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        #dic \n        if not s:\n            return 0\n        dic = {}\n        l,r = 0,0\n        ans = 0\n        while l<=r and r < len(s):\n            if s[r] not in dic:\n                dic[s[r]] = r\n                ans = max(ans, r-l+1)\n                r += 1\n            else:\n                temp = l\n                l = dic[s[r]] + 1\n                for i in range(temp,l):\n                    del dic[s[i]]\n                ans = max(ans, r-l+1)\n                dic[s[r]] = r\n                r += 1\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326661555","body":"class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        l,r = head,head\n\n        while r and r.next:\n            l = l.next\n            r = r.next.next\n        return l\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327759344","body":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i = 1\n\n        while i<len(nums):\n            if nums[i] == nums[i-1]:\n                nums.pop(i)\n            else:\n                i += 1\n        return len(nums)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328146092","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l,r = 0,len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid - 1\n            elif nums[mid] < target:\n                l = mid + 1\n        \n        return l    ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1332779046","body":"class Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334789073","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        dic= {\"R\": 0,\"L\":0,\"U\":0,\"D\":0}\n\n        for i in moves:\n            dic[i] += 1\n        \n        if dic['R'] == dic['L'] and dic['U'] == dic['D']:\n            return True\n        else:\n            return False\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336018562","body":"class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(j[0],i,j[1]) for i,j in enumerate(tasks)]\n        tasks.sort()\n        ans = []\n        queue = []\n        time = 0\n        pos = 0\n        for _ in tasks:\n            if not queue:\n                time = max(time, tasks[pos][0])\n            #add available task to queue\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(queue, (tasks[pos][2],tasks[pos][1]))\n                pos += 1\n            t,index = heapq.heappop(queue)\n            time += t\n            ans.append(index)\n        return ans ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1317302288","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))<br/>\nspace O(max(num和k的长度))\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1317302811","body":"## 思路\n\n先标记有 char 的 idx 的值为 0， 再遍历一遍数组如果不为 0 的地方就左右扩散找，取最小值\n\n## 代码\n\n    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            n = len(s)\n            res = [n] * n\n            for i in range(n):\n                if s[i] == c:\n                    res[i] = 0\n\n            for i in range(n):\n                if res[i] == 0:\n                    idx = i\n                    idx2 = i\n                    while idx + 1 < n and res[idx + 1] != 0:\n                        res[idx + 1] = min(res[idx] + 1, res[idx + 1])\n                        idx += 1\n                    while idx2 - 1 >= 0 and res[idx2 - 1] != 0:\n                        res[idx2 - 1] = min(res[idx2] + 1, res[idx2 - 1])\n                        idx2 -= 1\n            return res\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1317303312","body":"## 思路\n\n最优解前缀和，用 increment 数组把要增加的前 k 个元素和存起来，pop 时为 stack.pop() + increment[cnt - 1]， 同时把 increment[cnt - 2] 加上 increment[cnt - 1], 把 increment[cnt - 1] = 0，防止影响后续 pop 操作，这样 increment 操作为 O(1)。\n\n## 代码\n\n    class CustomStack(object):\n\n        def __init__(self, maxSize):\n            \"\"\"\n            :type maxSize: int\n            \"\"\"\n            self.capacity = maxSize\n            self.stack = []\n            self.cnt = 0\n            self.increments = [0] * maxSize\n\n\n        def push(self, x):\n            \"\"\"\n            :type x: int\n            :rtype: None\n            \"\"\"\n            if self.cnt < self.capacity:\n                self.stack.append(x)\n                self.cnt += 1\n\n\n\n        def pop(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            if self.cnt == 0:\n                return -1\n            if self.cnt >= 2:\n                self.increments[self.cnt - 2]  += self.increments[self.cnt - 1]\n            val = self.stack.pop() + self.increments[self.cnt - 1]\n\n            self.increments[self.cnt - 1] = 0\n            self.cnt -= 1\n            return val\n\n\n\n        def increment(self, k, val):\n            \"\"\"\n            :type k: int\n            :type val: int\n            :rtype: None\n            \"\"\"\n            if self.cnt > 0:\n                self.increments[min(self.cnt, k) - 1] += val\n\n## 复杂度\n\ntime O(1)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302868479","body":"## 思路\n\n如果不是']'，就把当前字符放入 stack 中，否则就把从 stack pop 出 string 和 repeat time，最后再把结果放在栈里面\n\n## 代码\n\n```py\n    class Solution:\n        def decodeString(self, s: str) -> str:\n            stack = []\n            for char in s:\n                if char != \"]\":\n                    stack.append(char)\n                else:\n                    temp = \"\"\n                    count = \"\"\n                    while len(stack) != 0 and stack[-1] != \"[\":\n                        temp = stack.pop() + temp\n                    stack.pop()\n                    while len(stack) != 0 and stack[-1].isdigit():\n                        count = stack.pop() + count\n                    stack.append(temp * int(count))\n            return  \"\".join(stack)\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1317303775","body":"## 思路\n\n队列 push 时，把元素都加入到第一个栈中；当 pop 或 peek 时，把元素倒着出栈加入到第二个栈中，此时的栈顶元素就是队列的头\n\n## 代码\n\n    class MyQueue(object):\n\n        def __init__(self):\n            self.stack1 = []\n            self.stack2 = []\n\n        def push(self, x):\n            \"\"\"\n            :type x: int\n            :rtype: None\n            \"\"\"\n            self.stack1.append(x)\n\n\n        def pop(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n\n            popOut = self.stack2.pop()\n\n            while len(self.stack2) != 0:\n                self.stack1.append(self.stack2.pop())\n            return popOut\n\n\n        def peek(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n\n            peekNum = self.stack2[-1]\n\n            while len(self.stack2) != 0:\n                self.stack1.append(self.stack2.pop())\n            return peekNum\n\n        def empty(self):\n            \"\"\"\n            :rtype: bool\n            \"\"\"\n            return len(self.stack1) == 0\n\n## 复杂度\n\npush time O(1)<br/>\npop time O(N)<br/>\npeek time O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1317305154","body":"## 思路\r\n\r\n前一个模块的 max 必须小于等于后面模块的 min，所以只要后面出现小于前面 max 的，要把前面的都踢出去，留下之前的 max\r\n最后返回栈的长度，栈存的是左边模块的分界点\r\n\"\"\"\r\n[2,1,3,4,4] => [2, 3, 4, 4]\r\n\"\"\"\r\n\r\n## 代码\r\n\r\n```python\r\n    # Definition for singly-linked list.\r\n\r\n    class Solution:\r\n        def maxChunksToSorted(self, arr: List[int]) -> int:\r\n            stack = []\r\n            for num in arr:\r\n                if stack and num < stack[-1]:\r\n                    curMax = stack[-1]\r\n                    while stack and num < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(curMax)\r\n                else:\r\n                    stack.append(num)\r\n            return len(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(N)<br/>\r\nspace O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1317304435","body":"## 思路\n\n注意 corner case，head 为空，head 为 1 个节点，k 为 0 时要直接 return；k 取模后如果为 0 也要直接 return\n\n## 代码\n\n    # Definition for singly-linked list.\n    # class ListNode(object):\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    class Solution(object):\n        def rotateRight(self, head, k):\n            \"\"\"\n            :type head: ListNode\n            :type k: int\n            :rtype: ListNode\n            \"\"\"\n            if not head or k == 0 or head.next == None:\n                return head\n\n            newTail= head\n            cur = head\n            length = 0\n            while cur != None:\n                cur = cur.next\n                length += 1\n\n            k %= length\n            if k == 0:\n                return head\n\n            cur = head\n            for i in range(k):\n                cur = cur.next\n\n            while cur.next != None:\n                cur = cur.next\n                newTail = newTail.next\n\n            newHead = newTail.next\n            newTail.next = None\n            cur.next = head\n            head = newHead\n            return head\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1308119107","body":"## 思路\r\n\r\n前驱节点获得要交换的两个节点，前驱节点先指向交换节点的后节点，交换的前节点指向后节点的 next 后，才能开始交换\r\n\r\n## 代码\r\n\r\n```python\r\n    # Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        cur = dummy\r\n        while cur.next and cur.next.next:\r\n            p2 = cur.next\r\n            p3 = cur.next.next\r\n            cur.next = p3\r\n            p2.next = p3.next\r\n            p3.next = p2\r\n\r\n            cur = p2\r\n        return dummy.next\r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(N)<br/>\r\nspace O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308118669","body":"## 思路\n\n注意当只有一个节点的时候要返回这个节点。获得中间节点的值，然后分别构建左右子树。\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            mid = self.findMid(head)\n            cur = mid.next\n            mid.next = None\n            root = TreeNode(cur.val)\n            root.left = self.sortedListToBST(head)\n            root.right = self.sortedListToBST(cur.next)\n            return root\n\n\n        def findMid(self, head):\n            if not head:\n                return None\n            p1, p2 = head,head\n            pre = None\n            while p2 and p2.next:\n                pre = p1\n                p1 = p1.next\n                p2 = p2.next.next\n            return pre\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309734337","body":"## 思路\n\nheadA, headB 分别指向链表 A, B 的头结点, 两个链表都分别遍历过，如果有交点就会返回。\n\n## 代码\n\n```python\n    class Solution:\n        def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n            p1, p2 = headA, headB\n            while p1 != p2:\n                p1 = p1.next if p1 != None else headB\n                p2 = p2.next if p2 != None else headA\n            return p1\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1317298258","body":"## 思路\n\n先快慢指针直到相遇，相遇后把其中一指针放回起点，然后两指针同时向前走，直到相遇。相遇点就是环的开始点。否则不存在环\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (slow == fast) break;\n        }\n\n        if (fast == null || fast.next == null) return null;\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1317297812","body":"## 思路\n\n用双向链表和哈希表实现，用 map 能在 O(1)时间内读取，双向链表不需要前驱节点删除，添加也是 O(1)\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n\n    class ListNode:\n        def __init__(self, key, val):\n            self.key = key\n            self.val = val\n            self.pre = None\n            self.next = None\n\n    class Linkedlist:\n        def __init__(self):\n            self.head = ListNode(0, 0)\n            self.tail = ListNode(0, 0)\n            self.head.next = self.tail\n            self.tail.pre = self.head\n\n\n        def addFirst(self, node):\n            node.pre = self.head\n            node.next = self.head.next\n    #         先写pre指向node！！\n            self.head.next.pre = node\n            self.head.next = node\n\n        def delete(self, node):\n            key = node.key\n            node.next.pre = node.pre\n            node.pre.next = node.next\n            return key\n\n        def deleteLast(self):\n            if self.head.next == self.tail:\n                return -1\n            return self.delete(self.tail.pre)\n\n\n\n\n    class LRUCache(object):\n\n        def __init__(self, capacity):\n            \"\"\"\n            :type capacity: int\n            \"\"\"\n            self.cache = Linkedlist()\n            self.map = {}\n            self.capacity = capacity\n\n        def get(self, key):\n            \"\"\"\n            :type key: int\n            :rtype: int\n            \"\"\"\n            if key not in self.map:\n                return -1\n            node = self.map[key]\n            val = node.val\n            self.cache.delete(node)\n            self.cache.addFirst(node)\n            return val\n\n\n        def put(self, key, value):\n            \"\"\"\n            :type key: int\n            :type value: int\n            :rtype: None\n            \"\"\"\n            newnode = ListNode(key, value)\n    #         如果遇到满了但是要改写key val的例子，优先改写key\n            if key in self.map:\n                node = self.map[key]\n                self.cache.delete(node)\n\n            elif len(self.map.keys()) == self.capacity:\n                k = self.cache.deleteLast()\n                self.map.pop(k)\n\n\n\n            self.map[key] = newnode\n            self.cache.addFirst(newnode)\n\n\n\n\n\n\n    # Your LRUCache object will be instantiated and called as such:\n    # obj = LRUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n```\n\n## 复杂度\n\ntime O(1)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1317296667","body":"## 思路\n\nroot 的最大深度等于 max(左子树的最大深度，右子树的最大深度) + 1\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution(object):\n        def maxDepth(self, root):\n            \"\"\"\n            :type root: TreeNode\n            :rtype: int\n            \"\"\"\n            if not root:\n                return 0\n            left = self.maxDepth(root.left)\n            right = self.maxDepth(root.right)\n            return max(left, right) + 1\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1317296283","body":"## 思路\n\n两棵树每个节点遍历判断\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n            if not p and not q:\n                return True\n            if not p or not q:\n                return False\n            if p.val != q.val:\n                return False\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1317295773","body":"## 思路\n\n注意其中一边子树为空的情况，要多加两个条件判断左子树为空或者右子树为空\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sumNumbers(self, root: Optional[TreeNode]) -> int:\n            if not root:\n                return 0\n            return self.helper(root, 0)\n\n\n        def helper(self, root, sumNum):\n            if not root.left and not root.right:\n                return sumNum * 10 + root.val\n            if not root.left:\n                return self.helper(root.right, sumNum * 10 + root.val)\n            if not root.right:\n                return self.helper(root.left, sumNum * 10 + root.val)\n            left = self.helper(root.left, sumNum * 10 + root.val)\n            right = self.helper(root.right, sumNum * 10 + root.val)\n            return left + right\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317294311","body":"## 思路\n\nBFS，然后返回最左边 bottom 的节点\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n            q = deque()\n            q.append(root)\n            res = []\n            while q:\n                size = len(q)\n                temp = []\n                for i in range(size):\n                    cur = q.popleft()\n                    temp.append(cur.val)\n                    if cur.left:\n                        q.append(cur.left)\n                    if cur.right:\n                        q.append(cur.right)\n                res.append(temp[:])\n            return res[-1][0]\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317293780","body":"## 思路\n\npreorder traversal transform the root data to a string, and use queue to store the data after transform it to array.\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, x):\n    #         self.val = x\n    #         self.left = None\n    #         self.right = None\n\n    class Codec:\n\n        def serialize(self, root):\n            \"\"\"Encodes a tree to a single string.\n            \n            :type root: TreeNode\n            :rtype: str\n            \"\"\"\n            if not root:\n                return \"#\"\n            return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\n            \n\n        def deserialize(self, data):\n            \"\"\"Decodes your encoded data to tree.\n            \n            :type data: str\n            :rtype: TreeNode\n            \"\"\"\n            temp = data.split(\",\")\n            q = deque(temp)\n            return self.helper(q)\n            \n        def helper(self, q):\n            if not q:\n                return None\n            \n            cur = q.popleft()\n            if cur == \"#\":\n                return None\n            root = TreeNode(cur)\n            root.left = self.helper(q)\n            root.right = self.helper(q)\n            return root\n            \n\n    # Your Codec object will be instantiated and called as such:\n    # ser = Codec()\n    # deser = Codec()\n    # ans = deser.deserialize(ser.serialize(root))\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1325955752","body":"## 思路\r\n\r\n用map记录每个坐标节点list的值，最后加进来的时候要把同坐标的list排序\r\n\r\n## 代码\r\n\r\n```python\r\n    # Definition for a binary tree node.\r\n    # class TreeNode(object):\r\n    #     def __init__(self, val=0, left=None, right=None):\r\n    #         self.val = val\r\n    #         self.left = left\r\n    #         self.right = right\r\n    class Solution(object):\r\n        def verticalTraversal(self, root):\r\n            \"\"\"\r\n            :type root: TreeNode\r\n            :rtype: List[List[int]]\r\n            \"\"\"\r\n            self.seen = collections.defaultdict(lambda: collections.defaultdict(list))\r\n            self.dfs(root, 0, 0)\r\n            \r\n            res = []\r\n            for col in sorted(self.seen):\r\n                level = []\r\n                for row in sorted(self.seen[col]):\r\n                    level += list(v for v in sorted(self.seen[col][row]))\r\n                res.append(level[:])\r\n            return res\r\n            \r\n        def dfs(self, root, row, col):\r\n            if not root:\r\n                return \r\n            self.seen[col][row].append(root.val)\r\n            self.dfs(root.left, row + 1, col - 1)\r\n            self.dfs(root.right, row + 1, col + 1)\r\n            \r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(NlogN)\r\nspace O(N)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1325957089","body":"## 思路\n\n如果另一个数字的idx不等于当前idx，就返回结果数组，然后对遍历的每项都存到map中\n\n## 代码\n\n```python\n    class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        map = {}\n        for idx, val in enumerate(nums):\n            num2 = target - val\n            if map.get(num2) != None and map.get(num2) != idx:\n                return [map.get(num2), idx]\n            map[val] = idx\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1325956836","body":"## 思路\n\n与215类似，先用map统计数字频率，用set去重后再用heapq排序，建最大堆，然后取前k个元素即可。\n\n## 代码\n\n```python\n    class Solution(object):\n        def topKFrequent(self, nums, k):\n            \"\"\"\n            :type nums: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            m = collections.defaultdict(int)\n            for num in nums:\n                m[num] += 1\n            s = set(nums)\n            \n            pq = []\n            heapq.heapify(pq)\n            while s:\n                num = s.pop()\n                heapq.heappush(pq, (-m[num], num))\n                \n            res = []\n            for i in range(k):\n                count, num = heapq.heappop(pq)\n                res.append(num)\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1325956609","body":"## 思路\n\n排列组合，遍历每个点作为中间点，然后求所有到这个点距离的次数count，res += count * (count - 1)\n\n## 代码\n\n```python\n    class Solution(object):\n        def numberOfBoomerangs(self, points):\n            \"\"\"\n            :type points: List[List[int]]\n            :rtype: int\n            \"\"\"\n            res = 0\n            for i in range(len(points)):\n                m = collections.defaultdict(int)\n                for j in range(len(points)):\n                    dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                    m[dis] += 1\n                for count in m.values():\n                    res += count * (count - 1)\n            return res\n```\n\n## 复杂度\n\ntime O(N ^ 2)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1325956249","body":"## 思路\n\n只要set中有重复数字就移动左窗口，移动后求res。\n\n## 代码\n\n```python\n    class Solution:\n        def lengthOfLongestSubstring(self, s: str) -> int:\n            charSet = set()\n            left, res = 0, 0\n            for i in range(len(s)):\n                char = s[i]\n                while char in charSet:\n                    d = s[left]\n                    left += 1\n                    charSet.remove(d)\n                charSet.add(char)\n                res = max(res, i - left + 1)\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325956115","body":"## 思路\n\n双指针\n\n## 代码\n\n```python\n    class Solution:\n        def findSubstring(self, s: str, words: List[str]) -> List[int]:\n            counter = Counter(words)\n            sLen = len(s)\n            n = len(words)\n            wordLen = len(words[0])\n            res = []\n            \n    #         iterate windows\n            for i in range(sLen - n * wordLen + 1):\n    #             当前window的可能，从i开始\n                cur = s[i:i + wordLen * n]\n                j = 0\n    #         收集当前cur的每个词的频率，如果跟counter不一样就剪枝\n                temp = collections.defaultdict(int)\n                while j < len(cur):\n                    word = cur[j: j + wordLen]\n                    # print(word)\n                    if word not in counter:\n                        break\n                        \n                    temp[word] += 1\n                    if temp[word] > counter[word]:\n                        break\n                    j += wordLen\n                if j == len(cur):\n                    res.append(i)\n            return res\n\n```\n\n## 复杂度\n\ntime O(N * M)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325955959","body":"## 思路\n\n前缀和+哈希表\n累加求得每项余数，题目求减掉多少项能被整除，就是求subarray余数之差为总数和的余数\n\n## 代码\n\n```python\n    class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        map = collections.defaultdict(int)\n        total = 0\n        res = len(nums)\n        mod = sum(nums) % p\n#         initalize\n        map[0] = -1\n        if mod == 0:\n            return 0\n        for i in range(len(nums)):\n            total += nums[i]\n            cur = total % p\n            target = ((cur - mod) % p + p) % p\n            if target in map:\n                res = min(res, i - map[target])\n            map[cur] = i\n\n        return res if res != len(nums) else -1\n\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1330004869","body":"## 思路\r\n\r\n二分模版\r\n\r\n## 代码\r\n\r\n```python\r\n    class Solution(object):\r\n        def searchInsert(self, nums, target):\r\n            \"\"\"\r\n            :type nums: List[int]\r\n            :type target: int\r\n            :rtype: int\r\n            \"\"\"\r\n            lo, hi = 0, len(nums) - 1\r\n            res = 0\r\n            while lo <= hi:\r\n                mid = (lo + hi) >> 1\r\n                if nums[mid] == target:\r\n                    return mid\r\n                elif nums[mid] > target:\r\n                    # res = mid\r\n                    hi = mid - 1\r\n                else:\r\n                    # res = mid\r\n                    lo = mid + 1\r\n            return lo\r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(LogN)\r\nspace O(1)\r\n","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303797717","body":"## 思路\n使用递归的方法，每遇到一个“[”就递归一次，“]”return\n## 代码\n```\nclass Solution(object):\n    def decodeString(self, s):\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                # 获取乘数\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                # 左括号则递归获取字符串\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                # 右括号则返回需要拼接的字符串\n                elif s[i] == ']':\n                    return i, res\n                # 字母则直接接到后面\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n```\n## 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)\nn为字符串长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304820805","body":"## 思路\n使用单调栈的方法，一边遍历，一边找出最多的块数。\n局部来看，若分成两块后合并后能排序成功，则前一块的最大值应小于或等于后一块的最小值，即`max(arr1)<=min(arr2)`;\n由此，用一个栈去记录每一块的最大值，当前值大于上一个块的最大值时，将当前值作为一个单独的块，并记入stack中；\n当前值小于上一个块最大值时，将此时stack中的最大值（最后一个值 ）pop出数组存于head中，然后回溯stack，直至stack的最大值小于等于当前值。\n## 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack=[]\n        for num in arr:\n            if stack and stack[-1]>num:\n                head = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(head)\n            else:    \n                stack.append(num)\n        return len(stack)\n```\n## 复杂度\n时间复杂度$O(N)$\n空间复杂度$O(N)$\nN为字符串长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307424916","body":"## 思路\n使用递归的方法，调换链表的节点\n## 代码\n```\nclass Solution(object):\n    def swapPairs(self, head):\n        # 若链表有至少两个节点\n        if head and head.next:\n            # 用newhead存新的链表头\n            newhead = head.next\n            # 递归调换\n            head.next = self.swapPairs(newhead.next)\n            newhead.next = head\n            return newhead\n        else: return head\n```\n## 复杂度\n时间复杂度：$O(N)$\n\n空间复杂度：$O(N)$\n\nN为链表的节点数","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312719679","body":"## 代码\n```python\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        else:\n            return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n\n## 复杂度\n时间复杂度 $O(N)$  N为节点数量\n\n空间复杂度$O(h)$  h为二叉树高度\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321078349","body":"## 思路\n哈希表+快排\n\n## 代码\n```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        count = collections.Counter(nums)\n        num_cnt = list(count.items())\n        topKs = self.findTopK(num_cnt, k, 0, len(num_cnt) - 1)\n        return [item[0] for item in topKs]\n    \n    def findTopK(self, num_cnt, k, low, high):\n        pivot = random.randint(low, high)\n        num_cnt[low], num_cnt[pivot] = num_cnt[pivot], num_cnt[low]\n        base = num_cnt[low][1]\n        i = low\n        for j in range(low + 1, high + 1):\n            if num_cnt[j][1] > base:\n                num_cnt[i + 1], num_cnt[j] = num_cnt[j], num_cnt[i + 1]\n                i += 1\n        num_cnt[low], num_cnt[i] = num_cnt[i], num_cnt[low]\n        if i == k - 1:\n            return num_cnt[:k]\n        elif i > k - 1:\n            return self.findTopK(num_cnt, k, low, i - 1)\n        else:\n            return self.findTopK(num_cnt, k, i + 1, high)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328262974","body":"## 思路\n二分法\n## 代码\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left + (right - left)//2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302841924","body":"- Iterate through the num reversely, and stop the loop when k is zero. \r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = []\r\n        remainder = 0\r\n        i = len(num) - 1\r\n        while k > 0:\r\n            digit = num[i] if i >= 0 else 0\r\n            remainder = (digit + k) % 10\r\n            sum.append(remainder)\r\n            k = int((digit + k)/10)\r\n            i -= 1\r\n        return num[:i+1] + sum[::-1] if i+1 > 0 else sum[::-1]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302862574","body":"- Method 1: two pointers\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        for i in range(len(s)):\r\n            left = i\r\n            right =min((i + 1), (len(s) - 1))\r\n            while True:\r\n                if s[left] == c or s[right] == c or (left == 0 and right == len(s) - 1):\r\n                    break\r\n                left = max(left - 1, 0)\r\n                right = min((right + 1), (len(s) - 1))\r\n                \r\n            print(left, right)\r\n                \r\n            if s[left] == c:\r\n                ans[i] = i - left\r\n            elif s[right] == c:\r\n                ans[i] = right - i\r\n            else:\r\n                ans[i] = 0\r\n            \r\n        return ans\r\n```\r\n\r\n- Method 2: Go through the whole list from left2right and right2left\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        left2right = self.findShortestFromLeft(s, c)\r\n        right2left = self.findShortestFromLeft(s[::-1], c)\r\n        for l, r in zip(left2right, right2left[::-1]):\r\n            ans += [min(l, r)]\r\n        return ans\r\n    \r\n    def findShortestFromLeft(self, s, c):\r\n        shortest = [0] * len(s)\r\n        buffer = len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                buffer = 0\r\n            else:\r\n                buffer += 1\r\n            shortest[i] = buffer\r\n        return shortest\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302870473","body":"- Use python list to emulate a stack\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack += [x]\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            ans = self.stack[-1]\r\n            self.stack.pop(-1)\r\n            return ans\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        pointer = 0\r\n        while pointer < k and pointer < len(self.stack):\r\n            self.stack[pointer] += val\r\n            pointer += 1\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304662127","body":"- Stack\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = []\r\n        stack = []\r\n        for i in range(len(s)):\r\n            stack.append(s[i])\r\n            if s[i] == ']':\r\n                j = len(stack) - 1\r\n                while j > 0:\r\n                    if stack[j] == '[':\r\n                        k = j - 1\r\n                        while k >= 0 and ('0' <= stack[k] <= '9'):\r\n                            k -= 1\r\n                        temp = stack[j + 1:-1] * int(\"\".join(stack[k + 1: j]))\r\n                        stack = stack[: k + 1] + temp\r\n                        break\r\n                    j -= 1\r\n        return \"\".join(stack)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304702423","body":"- Two stacks\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n    def empty(self) -> bool:\r\n        return not (bool(self.stack1) or bool(self.stack2))\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304704402","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s1, s2 = 0, 0\r\n        ans = 0\r\n        for i,j in zip(arr, sorted(arr)):\r\n            s1 += i\r\n            s2 += j\r\n            ans += s1 == s2\r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302905333","body":"### Idea:\r\nschool math, 逐位加然后进位\r\n\r\n### Complexity: \r\nTime: O(max(N, log k))\r\nSpace: O(1)\r\n\r\n### Code:\r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            if k == 0 : break\r\n            k, num[i] = divmod(num[i] +k,10)\r\n        while k > 0:\r\n            k, a = divmod(k, 10)\r\n            num = [a] + num   \r\n        return num   \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302952263","body":"### Idea: \r\n顺序/逆序遍历，记下距离；在出现第一个char之前的距离计算都不作数\r\n\r\n### Complexity: \r\nTime: O(N)\r\nSpace: O(N)\r\n\r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        shortest_distance = []\r\n        lens = len(s)\r\n\r\n        if lens == 1:\r\n            return [0]\r\n        \r\n        k = 10001\r\n        for i in range(0, lens):\r\n            if s[i] == c: \r\n                k = 0\r\n            else:\r\n                if k != -1: k += 1\r\n            shortest_distance.append(k)\r\n\r\n        k = 10001\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c: \r\n                k = 0\r\n            else:\r\n                if k != -1: k += 1\r\n            if k < shortest_distance[j]:\r\n                shortest_distance[j]=k\r\n\r\n        return shortest_distance\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1304738280","body":"### Idea:\r\nReplace Time by Space, 等pop的时候再处理单个元素，先把应该进行的操作用另一个数组存下\r\n\r\n### Complexity: \r\nTime: all-O(1) \r\nSpace: O(cnt/N), N是操作数\r\n\r\n### Code:\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = []\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.incrementals = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.stk.append(x)\r\n            self.incrementals.append(0)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1 \r\n        self.cnt -= 1\r\n        if self.cnt >= 1: \r\n            self.incrementals[-2] += self.incrementals[-1]\r\n        return self.stk.pop() + self.incrementals.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incrementals: \r\n            self.incrementals[min(k, self.cnt)-1] += val\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1307215442","body":"### Complexity:\r\nTime & Space: O(S)\r\n\r\n## Solution 1: Stack\r\n### Idea: \r\n见到], 出栈字符串，出栈数字，重新入栈字符串\r\n### Code:\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n        for c in s: \r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stk and stk[-1]!='[':\r\n                    repeatStr = stk.pop() + repeatStr\r\n                stk.pop()\r\n                while stk and stk[-1].isdigit():\r\n                    repeatCount = stk.pop() + repeatCount\r\n                stk.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stk.append(c)\r\n        return \"\".join(stk)  \r\n```\r\n\r\n## Solution 2: Iterative\r\n### Idea:\r\n碰到左括号进⼊递归，碰到右括号就跳出递归返回\r\n\r\n### Code:\r\n```\r\nclass Solution: \r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(start):\r\n            repeatStr = repearCount = '' # \r\n            while start < len(s):\r\n                if s[start].isdigit():\r\n                    repearCount += s[start]\r\n                elif s[start] == '[': # 进入递归条件\r\n                    start, t_str = dfs(start+1)\r\n                    print (start, t_str)\r\n                    repeatStr = repeatStr + t_str*int(repearCount) # 之前递归的结果相加\r\n                    repearCount = ''\r\n                elif s[start] == ']': # 退出递归条件\r\n                    return start, repeatStr\r\n                else: # 最小子问题情况\r\n                    repeatStr += s[start]\r\n                start += 1\r\n            return repeatStr\r\n        return dfs(0)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304568728","body":"### Complexity \r\nTime: push O(N), pop/peak/empty O(1)\r\nSpace: O(N)\r\n\r\n### Code \r\n\r\n```\r\nclass MyQueue(object):\r\n    def __init__(self):\r\n        self.in_stk = []\r\n        self.out_stk = []\r\n\r\n    def push(self, x):\r\n        self.in_stk.append(x)\r\n\r\n    def pop(self):\r\n        self.peek()\r\n        return self.out_stk.pop()\r\n\r\n    def peek(self):\r\n        if not self.out_stk:\r\n            while self.in_stk:\r\n                self.out_stk.append(self.in_stk.pop())\r\n        return self.out_stk[-1]\r\n\r\n    def empty(self):\r\n        return not self.in_stk and not self.out_stk\r\n```\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312494167","body":"\r\n### Complexity:\r\nTime: O(1)\r\nSpace: O(n)\r\n\r\n### Code:\r\n```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n     \r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self)> self.capacity:\r\n            self.popitem(last = False)\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320879963","body":"### Complexity:\r\nTime: O(n)\r\nSpace: O(n)\r\n\r\n### Code:\r\n```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        table = {}\r\n        for i,x in enumerate(nums):\r\n            y = target - x\r\n            if y in table:\r\n                return [table[y],i]\r\n            else:\r\n                table[x] = i\r\n        return None\r\n```\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328052565","body":"#### Complexity:\r\nTime: O(n)\r\nSpace: O(1)\r\n\r\n#### Code: \r\n\r\n```\r\nclass Solution:  \r\n    def removeDuplicates(self, nums: List[int]) -> int:  \r\n        if not nums:  \r\n            return 0  \r\n        n = len(nums)  \r\n        p = q = 0   \r\n        while q<n:  \r\n            if nums[p] ==nums[q]:  \r\n                q +=1  \r\n            else:  \r\n                nums[p+1]=nums[q]  \r\n                p +=1  \r\n                q +=1  \r\n        return p+1  \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304643562","body":"Algorithm\r\n1. add k to the end of the array\r\n2. iterate through array elements,  update carry and add carry to the element ahead\r\n3. after the iteration, if there is still carry, add separate digit ( divmod() or list( map( int,str(carry) ) ) ) to the head of array \r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        A[-1] = A[-1] + k\r\n        \r\n        for i in range(len(A)-1,-1,-1):\r\n            carry, A[i] = divmod(A[i],10)\r\n            if i != 0:\r\n                A[i-1] = A[i-1] + carry\r\n        while carry:\r\n            carry, a = divmod(carry, 10)\r\n            A = [a] + A\r\n\r\n            ## or\r\n\r\n       # if carry:\r\n            # carry = list(map(int, str(carry)))\r\n            # A = carry + A\r\n\r\n        return A\r\n```\r\n\r\ntime: O(M+N)  M -> length of input A, N ->  length of str(carry)\r\nspace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1304656554","body":"Algorithm\r\n1. loop through string from left and record the distance to the left nearest c\r\n2. loop through string from right and update the distance to the right nearest c\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = [0]*len(s)\r\n        \r\n        for p in range(len(s)):\r\n            if s[p] == c:\r\n                prev = p\r\n            ans[p] = p - prev\r\n        \r\n        prev = float('inf')\r\n        for p in range(len(s)-1,-1,-1):\r\n            if s[p] == c:\r\n                prev = p\r\n            ans[p] = min(ans[p],prev - p)\r\n            \r\n        return ans\r\n```\r\ntime: O(N) N is the length of input string, scan through the string twice\r\nspace: O(N) the size of ans","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1311035828","body":"idea:\r\n\r\nrotate k times equals to rotate k % (length of list) times. after rotate the kth node from end will be the new head of list, and k+1th from end will the new end.\r\n\r\nthus problems becomes find the k+1th from end.\r\n\r\ncode:\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        \r\n        length = 1\r\n        oldEnd = head\r\n        \r\n#         get the length of list\r\n        while oldEnd and oldEnd.next:\r\n            length += 1\r\n            oldEnd = oldEnd.next\r\n            \r\n        k = k % length\r\n        if k == 0:\r\n            return head\r\n#         find the k+1th node, make it the new end, and k th node as the new head, new head point to the old head\r\n        else:\r\n            newEnd = self.findNodeFromEnd(head,k+1)\r\n            print(newEnd)\r\n            newHead = newEnd.next\r\n            newEnd.next = None\r\n            oldEnd.next = head\r\n        return newHead\r\n            \r\n    def findNodeFromEnd(self,head,n):\r\n        p1 = p2 = head\r\n        \r\n        for i in range(n):\r\n            p2 = p2.next\r\n        \r\n        while p2 != None:\r\n            p2 = p2.next\r\n            p1 = p1.next\r\n            \r\n        return p1\r\n```\r\ntime O(n)-> O(n) get length of list + O(N) find the k+1th node from end\r\nspace O(1)","onTime":false},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319365483","body":"```python\r\n        \r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        res = []\r\n        node_list = []\r\n        # traverse all node and update colMap\r\n        def traverse(node,row,col):\r\n                if not node:\r\n                    return\r\n\r\n                node_list.append([node.val,row,col])\r\n                traverse(node.left, row+1,col-1)\r\n                traverse(node.right,row+1,col+1)\r\n        \r\n        # traverse tree, and update colMap\r\n        traverse(root,0,0)\r\n        \r\n        # sort rules:\r\n        # 1. sort node by col\r\n        # 2. if col is same, sort by row\r\n        # 3. if row and col is same, sort by node.val \r\n        \r\n        \r\n        # sort cols, and append nodes which in same col into res \r\n        node_list = sorted(node_list, key = lambda x: (x[2], x[1], x[0]))\r\n        node_map = OrderedDict()\r\n        \r\n        for node_val,row,col in node_list:\r\n            if col not in node_map:\r\n                node_map[col] = []\r\n            node_map[col].append(node_val)\r\n            \r\n        return node_map.values()\r\n    \r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321284379","body":"思路\r\n\r\n排列组合： 在n个数中选k个数进行有顺序排列有 n!/(n-k)! 个解。第一步有n个选择，第二步有n-1个选择，以此类推。\r\n对于每一个point，找到和其他point的距离，并将相同距离的points放在一起，用map实现，由于题目不需要知道具体的点坐标，那么统计相同距离的点数量即可。因为已经固定一个点，使用排列组合公式求出n个与其相同距离的点中，选2个数进行有顺序排列的数量，组成一个boomerang，累加到res中。\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        res = 0 \r\n        \r\n        for x,y in points:\r\n            distance_map = {}\r\n            for a,b in points:\r\n                distance = (x-a)**2 + (y-b)**2\r\n                if distance not in distance_map:\r\n                    distance_map[distance] = 0\r\n                distance_map[distance] += 1\r\n            \r\n            for _,val in distance_map.items():\r\n                if val > 1:\r\n                    res += val*(val-1)\r\n        \r\n        return res\r\n```\r\n\r\ntime: O(n^2)\r\nspace: O(n) for distance_map ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322714307","body":"siding window\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        max_len = 0\r\n        count = {}\r\n        lo = hi = 0\r\n        \r\n        while hi < len(s):\r\n            # update count map\r\n            c = s[hi]\r\n            if c not in count.keys():\r\n                count[c] = 0\r\n            count[c] += 1\r\n            \r\n            # check and remove repeating char\r\n            while count[c] > 1:\r\n                # shrink lo\r\n                remove_c = s[lo]\r\n                count[remove_c] -= 1\r\n                lo += 1\r\n                \r\n            max_len = max(max_len, hi - lo + 1)\r\n            hi += 1\r\n            \r\n        return max_len\r\n```\r\ntime: O(2n) = O(n)O(2n)=O(n). In the worst case each character will be visited twice by lo and hi.\r\nspace: O(n) for sliding window (hashmap)\r\n\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328363305","body":"思路\r\n单调队列\r\n\r\n```py\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        from collections import deque\r\n        q = deque() # stores *indices*\r\n        res = []\r\n        for i, cur in enumerate(nums):\r\n            while q and nums[q[-1]] <= cur:\r\n                q.pop()\r\n            q.append(i)\r\n            # remove first element if it's outside the window\r\n            if q[0] == i - k:\r\n                q.popleft()\r\n            \r\n            if i >= k - 1:\r\n                res.append(nums[q[0]])\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304679567","body":"### Thought:\r\nTake k as carry, add k to the last digit of num array, update k and add to the higher digit of num array.\r\n\r\n### Code\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<>();\r\n        int curNum = 0;\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            curNum = (num[i] + k) % 10;\r\n            ret.add(0, curNum);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while (k != 0) {\r\n            ret.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return ret;\r\n    }\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(1)","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304929603","body":"```\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n        int sz = 1;\n        ListNode oldTail = head;\n\n        //Calculate the size of linkedlist\n        while (oldTail.next != null) {\n            oldTail = oldTail.next;\n            sz++;\n        }\n\n        //Connect the oldtail and head\n        oldTail.next = head;\n\n        //Update k circumvent the repeat procedure\n        k %= sz;\n\n        //Find the newtail after k's operation.\n        ListNode newTail = head;\n        for (int i = 0; i < sz - k - 1; i++) {\n            newTail = newTail.next;\n        }\n\n        //The newhead is next to the newtail\n        ListNode newHead = newTail.next;\n\n        //Break the loop\n        newTail.next = null;\n\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306556460","body":"Recursive approach:\n```\npublic ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        \n        ListNode firstNode = head;\n        ListNode secondNode = firstNode.next;\n\n        firstNode.next = swapPairs(secondNode.next);\n        secondNode.next = firstNode;\n\n        return secondNode;\n        \n    }\n```\nTime complexity: O(N)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308158290","body":"Thought:\nuse fast and slow pointer to find the mid element (which is the root of BST), and use prev pointer to divide left element of mid element, aka left subtree of BST, and right element of root. Find the corner case and recursively find left subtree and right subtree.\n\nCode:\n```\npublic TreeNode sortedListToBST(ListNode head) {\n        if (head == null)\n            return null;\n        \n        ListNode mid = findMid(head);\n        TreeNode n = new TreeNode(mid.val);\n\n        if (head == mid)\n            return n;\n        \n        n.left = sortedListToBST(head);\n        n.right = sortedListToBST(mid.next);\n        return n;\n    }\n\n    public ListNode findMid(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode prev = null, slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        if (prev != null) {\n            prev.next = null;\n        }\n        return slow;\n    }\n```\nTime complexity: O(NlogN)\nSpace complexity: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309782606","body":"Thought:\nUsing two pointer to initialize the l1 and l2. Traverse l1 and l2, condition check is when l1 != l2. if l1 and l2 are not the same length, then they would encounter at the intersection point or null. If l1 and l2 are not the same length, they would traverse worst case(l1.length + l2.length) and meet in the intersection point or null.\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode l1 = headA;\n        ListNode l2 = headB;\n        while (l1 != l2) {\n            l1 = l1 == null ? headB : l1.next;\n            l2 = l2 == null ? headA : l2.next;\n        }\n        return l1;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311352203","body":"Thought:\nUse two pointer, fast and slow pointer to check if there is a cycle in linkedlist. After they met, use another pointer to start from the beginning, traverse with slow pointer in same pace. When they met, the node would be the cycle entrance.\n\nCode:\n```\npublic ListNode cycleDetect(ListNode head) {\n        if (head == null || head.next == null)\n            return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast)\n                return slow;\n        }\n        return null;\n    }\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n        ListNode newL = head;\n        ListNode cycle = cycleDetect(head);\n        if (cycle == null) return null;\n        while (newL != cycle) {\n            newL = newL.next;\n            cycle = cycle.next;\n        }\n        return newL;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312388736","body":"Thoughts:\nLearned from leetcode discussion, use hashmap + doubleLinkedList.\n\nCode:\n```\nclass LRUCache {\n    \n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n    \n    private void addNode(DLinkedNode node) {\n        // add node after head;\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        \n    }\n    \n    private void removeNode(DLinkedNode node) {\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n        \n        prev.next = next;\n        next.prev = prev;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        //move some node right after head\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode ret = tail.prev;\n        removeNode(ret);\n        return ret;\n    }\n    \n    private HashMap<Integer, DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n    \n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity  = capacity;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null)\n            return -1;\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.value = value;\n            newNode.key = key;\n            cache.put(key,newNode);\n            addNode(newNode);\n            size++;\n            if (size > capacity) {\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        }\n        else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n}\n```\nTime complexity: O(1)\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312649662","body":"Thought:\r\nRecursive solution. Conduct a boundary check and recursively find the left node and right node of root\r\n\r\nCode:\r\n```\r\npublic int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1320813322","body":"Thought:\r\nSame idea as symmetric tree. check boundary condition if p and q are null at the same time, if so return true, else false. then conduct normal recursively check on same node in p and q.\r\n\r\nCode:\r\n```\r\npublic boolean isSameTree(TreeNode p, TreeNode q) {\r\n        TreeNode l1 = p, l2 = q;\r\n        if (l1 == null && l2 == null) return true;\r\n        if (l1 == null || l2 == null) return false;\r\n        return (l1.val == l2.val && isSameTree(l1.left,l2.left) && isSameTree(l1.right, l2.right));\r\n    }\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity:O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1320811449","body":"Thoughts:\r\ndfs, use preorder traversal to concatenate their node value, recursively add them up.\r\n\r\nCode:\r\n```\r\npublic int sumNumbers(TreeNode root) {\r\n        return preorder(root, 0);\r\n\r\n    }\r\n\r\n    int preorder(TreeNode root, int sum) {\r\n        if (root == null) return 0;\r\n        if (root.left == null && root.right == null) {\r\n            sum = sum * 10 + root.val;\r\n            return sum;\r\n        }\r\n        sum = sum * 10 + root.val;\r\n        int left = preorder(root.left, sum);\r\n        int right = preorder(root.right, sum);\r\n        return left + right;\r\n    }\r\n```\r\nTime complexity: O(n);\r\nSpace complexity: O(H)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316207588","body":"Thoughts:\nBFS. Using queue traverse the nodes for each layer from right to left, then root will be the bottom layer leftmost value.\n\nCode:\n```\nQueue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            root = q.poll();\n            if (root.right != null)\n                q.add(root.right);\n            if (root.left !=null)\n                q.add(root.left);\n        }\n        return root.val;\n```\nTime Complexity: O(n)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1319738172","body":"Thought:\r\nserialize: using a divider to separate different node, use a string N to denote null value. and dfs for the whole tree.\r\ndeserialize:  dfs the whole deque/queue with each node value till buildup the whole tree\r\n```\r\nprivate static final String divider = \",\";\r\n    private static final String N = \"X\";\r\n    \r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        StringBuilder sb = new StringBuilder();\r\n        buildString(root, sb);\r\n        return sb.toString();\r\n    }\r\n    \r\n    private void buildString(TreeNode root, StringBuilder sb) {\r\n        if (root == null)\r\n            sb.append(N).append(divider);\r\n        else {\r\n            sb.append(root.val).append(divider);\r\n            buildString(root.left, sb);\r\n            buildString(root.right, sb);\r\n        }\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        Deque<String> nodes = new LinkedList<>();\r\n        nodes.addAll(Arrays.asList(data.split(divider)));\r\n        return buildTree(nodes);\r\n    }\r\n    \r\n    private TreeNode buildTree(Deque<String> nodes) {\r\n        String val = nodes.remove();\r\n        if (val.equals(N)) return null;\r\n        else {\r\n            TreeNode node = new TreeNode(Integer.valueOf(val));\r\n            node.left = buildTree(nodes);\r\n            node.right = buildTree(nodes);\r\n            return node;\r\n        }\r\n        \r\n    }\r\n```\r\nTime complexity:O(n)\r\nSpace complexity:O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320781302","body":"Thought:\nClassic two sum. use hashmap to store element's value and index. if two number in the map can add up to target, then return these two number's index.\n\nCode:\n```\npublic int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> hm = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (hm.containsKey(target - nums[i]))\n                return new int[]{hm.get(target - nums[i]), i};\n            hm.put(nums[i], i);\n        }\n        return null;\n    }\n```\nTime Complexity: O(n)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1324533650","body":"Thought:\r\nWhen it comes to \"Top K frequent\", I would consider minHeap or maxHeap to do this kind of question. Use a hashmap to store the frequency of integer, and put the frequency into the minHeap. If the heap size larger than k. pop out the first element in queue. After traverse the whole map, everything left in pq is the final answer.\r\n\r\nCode:\r\n```\r\npublic int[] topKFrequent(int[] nums, int k) {\r\n        if (k == nums.length) return nums;\r\n        HashMap<Integer, Integer> hm = new HashMap<>();\r\n        for (int i : nums)\r\n            hm.put(i, hm.getOrDefault(i, 0) + 1);\r\n        \r\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> hm.get(a) - hm.get(b));\r\n\r\n        for (int i : hm.keySet()) {\r\n            pq.add(i);\r\n            if (pq.size() > k) \r\n                pq.poll();\r\n        }\r\n\r\n        int[] ret = new int[k];\r\n        while (k > 0)\r\n            ret[--k] = pq.poll();\r\n        \r\n        return ret;\r\n    }\r\n```\r\nTime Complexity: O(nlogk)\r\nSpace Complexity: O(n + k) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321409351","body":"Thought:\nUse hashmap to store the two points distance, if this distance appeared more than once, then use permutation formula: n * (n - 1) to the final result.\neach traverse for total array should clear map afterwards.\n\nCode:\n```\npublic int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        if (n < 3) return 0;\n        int ret = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int d = distance(points[i], points[j]);\n                hm.put(d, hm.getOrDefault(d,0) + 1);\n            }\n            for (int val : hm.values())\n                ret += val * (val - 1);\n            hm.clear();\n        }\n        \n        return ret;\n    }\n\n    int distance(int[] x, int[] y) {\n        return (y[0] - x[0]) * (y[0] - x[0]) + (y[1] - x[1]) * (y[1] - x[1]);\n    }\n```\nTime Complexity: O(n^2)\nSpace Complexity: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328810844","body":"Code:\r\n```\r\nListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n```\r\nTIme complexity: O(n);\r\nSpace complexity:O(1);","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328813216","body":"Thought: two pointer\r\nCode:\r\n```\r\nif (nums.length == 1) return 1;\r\n        int l = 1;\r\n        for (int i = 0; i < nums.length - 1; i++) {\r\n            if (nums[i] != nums[i + 1])  {\r\n                nums[l] = nums[i + 1];\r\n                l++;\r\n            }\r\n\r\n        }\r\n        \r\n        return l;\r\n```\r\ntime complexity:O(n)\r\nspace complexity:O(1)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823818","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num<stack[-1]:\n                head = stack.pop()\n                while stack and num<stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305784520","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304848673","body":"```py\r\nclass Solution:\r\n    def addToArrayForm(self, nums: List[int], k: int) -> List[int]:\r\n        n = len(nums)\r\n        num = 0\r\n        for i in range(n):\r\n            num = num * 10 + nums[i]\r\n            \r\n            \r\n        num += k\r\n        result = []\r\n        while num > 0:\r\n            result.append(num % 10)\r\n            num //= 10\r\n            \r\n            \r\n        return result[::-1]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1304853414","body":"two pass, one pass check from left, one pass check from right\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        result = [n] * n\r\n        \r\n        pos = n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = abs(i - pos)\r\n            \r\n        pos = 0\r\n        for i in reversed(range(n)):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = min(result[i], abs(i-pos))\r\n            \r\n            \r\n        return result\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1304868133","body":"\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)            \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop(-1)\r\n        \r\n        return -1\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304918160","body":"\r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        if s.find('[') == -1:\r\n            return s\r\n        bracketStack = []\r\n        digitStack = []\r\n        n = len(s)\r\n                \r\n        leftBracket, rightBracket = -1, -1\r\n        digitPos = -1\r\n        digit = -1\r\n        for i in range(n):\r\n            if s[i].isdigit():\r\n                if digitPos == -1:\r\n                    digitPos = i\r\n                \r\n                digitStack.append(int(s[i]))\r\n               \r\n            if s[i] == '[':\r\n                if digit == -1:\r\n                    digit = self.getDigit(digitStack)\r\n                bracketStack.append(i)\r\n                if leftBracket == -1:\r\n                    leftBracket = i\r\n            if s[i] == ']':\r\n                bracketStack.pop()\r\n                if len(bracketStack) == 0:\r\n                    rightBracket = i               \r\n                    break\r\n        \r\n        a = s[:digitPos]\r\n        b = digit * self.decodeString(s[leftBracket+1: rightBracket])\r\n        c = self.decodeString(s[rightBracket+1:])\r\n        \r\n        return  a + b + c\r\n                    \r\n    def getDigit(self, stack: List[int]) -> int:\r\n        result = 0\r\n        for num in stack:\r\n            result = result * 10 + num\r\n            \r\n        return result\r\n                    \r\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304844838","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return \r\n        dummyHead = ListNode(next=head)\r\n\r\n        n = self.getLength(head)\r\n        k = k % n\r\n        \r\n        # get the right side head\r\n        cur = dummyHead\r\n        for i in range(n - k):\r\n            cur = cur.next\r\n            \r\n        newHead = cur.next\r\n        cur.next = None\r\n        \r\n        \r\n        # keep the oldHead\r\n        oldHead = head\r\n        \r\n        \r\n        # connect the oldHead to the tail of prev right side\r\n        dummyHead.next = newHead\r\n        cur = dummyHead\r\n        while cur.next:\r\n            cur = cur.next\r\n        \r\n        cur.next= oldHead\r\n        \r\n        return dummyHead.next\r\n        \r\n        \r\n    def getLength(self, head: Optional[ListNode]) -> int:\r\n        result = 0\r\n        dummyHead = ListNode(next=head)\r\n        cur = dummyHead\r\n        while cur.next:\r\n            result += 1\r\n            cur = cur.next\r\n        \r\n        return result\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309389643","body":"获取两个链表的长度， 两个长度的差值则是分别从头开始往后走的差值\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if headA == None or headB == None:\n            return None\n        \n        lenA, lenB = self.getLen(headA), self.getLen(headB)\n        longerHead, shorterHead = headA if lenA > lenB else headB,  headB if lenA > lenB else headA\n        \n        for i in range(abs(lenA - lenB)):\n            longerHead = longerHead.next\n        \n        while longerHead:\n            if longerHead == shorterHead:\n                return longerHead\n            longerHead = longerHead.next\n            shorterHead = shorterHead.next\n        \n        return None\n            \n    \n    def getLen(self, head: ListNode) -> int:\n        count = 0\n        dummy = ListNode(next=head)\n        while dummy:\n            dummy = dummy.next\n            count += 1\n        return count\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312763659","body":"```py\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = OrderedDict()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        \r\n        result = self.cache[key]\r\n        self.cache.move_to_end(key, last=False)\r\n        \r\n        return result\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            self.cache[key] = value\r\n            self.cache.move_to_end(key, last=False)\r\n            if len(self.cache) > self.capacity:\r\n                self.cache.popitem()\r\n            \r\n            return\r\n        \r\n        \r\n        # key in self.cache\r\n        self.cache[key] = value\r\n        self.cache.move_to_end(key, last=False)\r\n        \r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312762077","body":"```py\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        return max(self.maxDepth(root.left) + 1, self.maxDepth(root.right) + 1)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312805832","body":"```py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        \n        if p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304924255","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(k == 0 || head == null || head.next == null) return head;\n        // count the number of list\n        ListNode countNode = head; \n        int count;\n        for( count = 1; countNode.next != null; count++){\n            countNode = countNode.next;\n        }\n        // make a circle \n        countNode.next = head;\n        ListNode tail = countNode;\n        ListNode prev = head;\n        for(int i = 0; i < count - k%count; i++ ){\n            tail = tail.next;\n        }\n        prev = tail.next;\n        tail.next = null;\n        return prev;\n\n    \n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309752034","body":"# 思路 \n假设两个链表有交点，A链表交点前的长度为A，B交点前的长度为B，共同交点后面的长度为C，遍历A链表的长度为A+C\n遍历B链表的长度为B+C，遍历完两个链表分别再遍历B和A链表，在交点前的遍历的总长度分别为A+C+B 和 B + C + A,相等的，\n相等时就是交点，返回一个指针。\n当不相交的时候，因为两个指针都遍历的两个链表，所以当遍历完的时候两个指针也是相等的，等于null；\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA;\n        ListNode pB = headB;\n        // if pA.next is not null, pA = pA.next\n        // if pA.next is null, pA = headB;\n        // if pB.next is null, pB = headA;\n        // if pB.next is not null, pB = pB.next\n        while(pA != pB){\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n## 复杂度\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311227759","body":"# 解题思路\nspace O(N), use hashset to store the listNode, when there is exist same listnode in hashset, return this node.\n\nspace O(1), slow pointer moves 1 step, fast pointer moves 2 steps.\n## 代码\n```java \n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        // check whether head is null\n        if(head == null){\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while(fast != null){\n            slow = slow.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }\n            else{\n                return null;\n            }\n            if(fast == slow){\n                ListNode ptr = head;\n                while(ptr != slow){\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313149577","body":"# 思路\n递归\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null || q == null){\n            return false;\n        }\n        if(p.val != q.val){\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1319468341","body":"# 递归\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        //DFS\r\n        return dfsNums( root, 0);\r\n    \r\n    }\r\n    \r\n    public int dfsNums( TreeNode root, int sum){\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        sum = sum * 10 + root.val;\r\n        if(root.left == null && root.right == null){\r\n            return sum;\r\n        }\r\n        return dfsNums(root.left, sum) + dfsNums(root.right, sum);\r\n    }\r\n}","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320683270","body":"# 思路\n\n哈希表，key存target-nums[i] 更高效，当nums[i] 与已知的key相等的时候，返回\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashmap = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(hashmap.containsKey(nums[i]))\n                return new int[]{ hashmap.get(nums[i]), i,};\n            hashmap.put(target - nums[i], i);\n        }\n        return new int[]{};\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327068883","body":"# 思路\r\n快慢指针，一步两步\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while( fast != null && fast.next != null ){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n时间复杂度O(n), 空间O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1332885766","body":"```java\r\nclass Solution {\r\n    \r\n    class MonotonicQueue {\r\n        LinkedList<Integer> q = new LinkedList<>();\r\n        public void push(int n) {\r\n\r\n            while (!q.isEmpty() && q.getLast() < n) {\r\n                q.pollLast();\r\n            }\r\n            q.addLast(n);\r\n        }\r\n\r\n        public int max() {\r\n            return q.getFirst();\r\n        }\r\n\r\n        public void pop(int n) {\r\n            if (n == q.getFirst()) {\r\n                q.pollFirst();\r\n            }\r\n        }\r\n    }\r\n\r\n   \r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        MonotonicQueue window = new MonotonicQueue();\r\n        List<Integer> res = new ArrayList<>();\r\n\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (i < k - 1) {              \r\n                window.push(nums[i]);\r\n            } else {               \r\n                window.push(nums[i]);               \r\n                res.add(window.max());            \r\n                window.pop(nums[i - k + 1]);\r\n            }\r\n        }\r\n   \r\n        int[] arr = new int[res.size()];\r\n        for (int i = 0; i < res.size(); i++) {\r\n            arr[i] = res.get(i);\r\n        }\r\n        return arr;\r\n    }\r\n}","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334790273","body":"```java\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305034426","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果是空和只有一个元素链表就直接返回\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        int len = 1, index;\r\n        ListNode temp = head,newHead;\r\n        //计算链表长度\r\n        while(temp.next != null){\r\n            len++;\r\n            temp = temp.next;\r\n        }\r\n    \r\n    //将列表设为循环链表\r\n        temp.next = head;\r\n        k %= len;\r\n        index = len - k;\r\n        //找到要断开循环链表的结点 记录链表新的头节点\r\n        while (index-- > 0) {\r\n            temp = temp.next;\r\n        }\r\n        newHead = temp.next;\r\n        temp.next = null;\r\n        return newHead;\r\n\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312762888","body":"```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305289929","body":"思路：1.假设有N个元素，将链表元素向右移动k个位置。\n           2.将n-k个元素采用头插法插入链表。\n代码：\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    struct ListNode* p, *q;\n    int i,n = 1;\n    if(head==NULL)\n    {\n         return NULL;\n    }\n    for(p=head; p->next!=NULL; p=p->next)\n    {\n         n++;\n    }\n    k %= n;\n    q = p;\n    for(p=head,i=0; n-k-1!=i; p=p->next,i++);\n    q->next = head;\n    head = p->next;\n    p->next=NULL;\n    return head;\n}\n时间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307139487","body":"思路：使用递归的方式解答该题更加简便；\n          每次做了两个结点的交换并且连接下一个头结点。\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {       \n        if(head == nullptr || head->next == nullptr)\n        return head;\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        return next;//每一次返回交换那个头结点。\n    }\n}\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305768345","body":"```JavaScript\r\nvar rotateRight = function(head, k) {\r\n    if(!head) return head\r\n    let prev = head, cur = head, tail\r\n    let len = 1\r\n\r\n    while(cur.next) {\r\n        cur = cur.next\r\n        len++\r\n    }\r\n    k %= len\r\n    if(k == 0) return head\r\n\r\n    tail = cur\r\n    cur = head\r\n    for(let i = 0; i < len - k; i++) {\r\n        prev = cur\r\n        cur = cur.next\r\n    }\r\n\r\n    tail.next = head\r\n    prev.next = null\r\n    \r\n    return cur\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305788422","body":"``` python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313876227","body":"```javascript\nvar isSameTree = function(p, q) {\n    let pQ = [p], qQ = [q], res = true\n\n    while (pQ.length) {\n        pNode = pQ.shift()\n        qNode = qQ.shift()\n\n        if (pNode === null && qNode === null) {\n            res = true\n        } else if (pNode === null || qNode === null) {\n            res = false\n            break \n        } else {\n            if (pNode.val !== qNode.val) {\n                res = false\n                break \n            } else {\n                pQ.push(pNode.left)\n                pQ.push(pNode.right)\n\n                qQ.push(qNode.left)\n                qQ.push(qNode.right)\n            }\n        }\n    }\n\n    return res\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321112579","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dict ={}\n        nums.sort()\n        length = len(nums)\n        for i in nums:\n            dict[i] = dict.get(i,0)+1\n        dict = sorted(dict.items(), key=lambda dict:dict[1], reverse=True)\n        res = []\n        for x, y in dict:\n            res.append(x)\n        return res[:k]\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328093761","body":"```javascript\nvar searchInsert = function(nums, target) {\n    const n = nums.length;\n    let left = 0, right = n - 1, ans = n;\n    while (left <= right) {\n        let mid = ((right - left) >> 1) + left;\n        if (target <= nums[mid]) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306558053","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310432319","body":"Idea: \r\nThe key idea is to set pointers to each head and let the pointer run through each linkedlist once. If the two linkedlists do have intersection, they will definitely meet at that node during the traversal. If the two linkedlists don't, they will both reach to the null value at the tail of each linkedlist. \r\n\r\n```python\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        pA, pB = headA, headB \r\n\r\n        while pA != pB: \r\n            if not pA:\r\n                pA = headB \r\n            else: \r\n                pA = pA.next \r\n            if not pB: \r\n                pB = headA \r\n            else: \r\n                pB = pB.next \r\n\r\n        return pA \r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311925801","body":"```java \r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        fast, slow = head, head \r\n\r\n        while fast and fast.next: \r\n            fast = fast.next.next \r\n            slow = slow.next \r\n\r\n            if fast == slow: \r\n                break \r\n        if not fast or not fast.next: \r\n            return None\r\n \r\n        slow = head\r\n        while fast != slow: \r\n            fast = fast.next \r\n            slow = slow.next \r\n\r\n        return slow\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312534144","body":"```python\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.head = Node(-1, -1)\r\n        self.tail = Node(-1, -1)\r\n        self.head.next = self.tail \r\n        self.tail.prev = self.head \r\n        self.hashtable = {}\r\n        self.capacity = capacity \r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.hashtable: \r\n            return -1 \r\n        node = self.hashtable[key]\r\n        self.put_in_front(node)\r\n        return node.val \r\n\r\n    def put_in_front(self, node): \r\n        left = node.prev \r\n        right = node.next \r\n\r\n        \"break process, break left, break right, connect left and right\"\r\n        if left: \r\n            left.next  = node.next \r\n            node.prev = None \r\n        if right: \r\n            node.next = None \r\n            right.prev = left \r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node \r\n        node.prev = self.head \r\n        \r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key in self.hashtable: \r\n            node = self.hashtable[key]\r\n            node.val = value \r\n            self.put_in_front(node)\r\n        else: \r\n            node = Node(key, value)\r\n            self.hashtable[key] = node \r\n            self.put_in_front(node)\r\n            \r\n            \"evict the least used key\"\r\n            if len(self.hashtable) > self.capacity: \r\n               \r\n                to_evict = self.tail.prev \r\n                key_to_evict = to_evict.key\r\n                del self.hashtable[key_to_evict]\r\n                left = to_evict.prev \r\n                right = to_evict.next \r\n                to_evict.prev, to_evict.next = None, None \r\n                left.next, right.prev = right, left\r\n        \r\n\r\nclass Node(object): \r\n    def __init__(self, key, val): \r\n        self.val = val\r\n        self.key = key\r\n        self.prev = None \r\n        self.next = None \r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312739637","body":"```java\r\nvar maxDepth = function (root) {\r\n  if(!root) return 0;\r\n  let quene = []\r\n  quene.push(root)\r\n  let i = 0\r\n  while (quene.length) {\r\n      let curLevel = quene\r\n      quene = [];\r\n      i++;\r\n      for (let i = 0; i < curLevel.length; i++) {\r\n          if (curLevel[i].left) {\r\n              quene.push(curLevel[i].left)\r\n          }\r\n          if (curLevel[i].right) {\r\n              quene.push(curLevel[i].right)\r\n          }\r\n      }\r\n  }\r\n return i;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312968399","body":"```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif p is None and q is not None:\r\n            return False\r\n        elif p is not None and q is None:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315352286","body":"```python\r\nvar sumNumbers = function(root) {\r\n   let result = []\r\n    if (root == null) {\r\n        return result\r\n    }\r\n    let dfs = (node, path) => {\r\n        path.push(node.val)\r\n        if (node.left == null && node.right == null) {\r\n            result.push([...path].join(''))\r\n            path.pop()\r\n            return\r\n        }\r\n        if (node.left != null) {\r\n            dfs(node.left, path)\r\n        }\r\n        if (node.right != null) {\r\n            dfs(node.right, path)\r\n        }\r\n        path.pop()\r\n    }\r\n    dfs(root, [], 0);\r\n\r\n    let sum = 0;\r\n    for(let i=0;i<result.length;i++) {\r\n        sum += parseInt(result[i]);\r\n    }\r\n\r\n    return sum;\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316969990","body":"```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        curVal = curHeight = 0\r\n        def dfs(node: Optional[TreeNode], height: int) -> None:\r\n            if node is None:\r\n                return\r\n            height += 1\r\n            dfs(node.left, height)\r\n            dfs(node.right, height)\r\n            nonlocal curVal, curHeight\r\n            if height > curHeight:\r\n                curHeight = height\r\n                curVal = node.val\r\n        dfs(root, 0)\r\n        return curVal\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1320960634","body":"```python\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        # 考虑最基本的情况，当一个节点为空节点的时候用什么字符代替\r\n        if not root:\r\n            return 'x'\r\n        # 对树进行先序遍历\r\n        return ','.join([str(root.val),self.serialize(root.left),self.serialize(root.right)])\r\n\r\n    def deserialize(self, data):\r\n        # 遇到x则置为null\r\n        self.data = data\r\n        if self.data[0] == 'x':\r\n            return None\r\n        node = TreeNode(self.data[:self.data.find(',')])\r\n        node.left = self.deserialize(self.data[self.data.find(',')+1:])\r\n        node.right = self.deserialize(self.data[self.data.find(',')+1:])\r\n        return node\r\n\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320960578","body":"```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        self.info = []\r\n        self.dfs(root, 0, 0)\r\n\r\n        info = sorted(self.info)\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col, row, val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n\r\n    def dfs(self, root, row, col):\r\n        if not root:\r\n            return None\r\n        self.info.append((col, row, root.val))\r\n        self.dfs(root.left, row + 1, col - 1)\r\n        self.dfs(root.right, row + 1, col + 1)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320960409","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        int N = nums.length;\r\n        for (int i = 1; i < N; i++) {\r\n            for (int j = i; j < N; j++) {\r\n                if (nums[j] + nums[j - i] == target) {\r\n                    return new int[] {j, j - i};\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320960514","body":"```java\r\n\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> counts = new HashMap<>();\r\n        for (int n: nums) {\r\n            counts.put(n, counts.getOrDefault(n, 0) + 1);\r\n        }\r\n        int[] res = new int[k];\r\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(\r\n            (a, b) -> counts.get(a) - counts.get(b)\r\n        );\r\n        for (int key: counts.keySet()) {\r\n            minHeap.offer(key);\r\n            if (minHeap.size() > k) {\r\n                minHeap.poll();\r\n            }\r\n        }\r\n        for (int i = 0; i < k; i++) {\r\n            res[i] = minHeap.poll();\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325409218","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> res = new ArrayList();\r\n        if (s == null || s.length() == 0 || words == null || words.length == 0){\r\n             return res;\r\n        }\r\n        int n = s.length();\r\n        int m = words.length;\r\n        int w = words[0].length();\r\n\r\n        //预处理，统计 words 中每个单词的数量\r\n        Map<String, Integer> total = new HashMap();\r\n        for (String word : words) {\r\n            total.put(word, total.getOrDefault(word, 0) + 1);\r\n        }\r\n\r\n        for (int i = 0; i < w; ++i) {\r\n            HashMap<String, Integer> wd = new HashMap<>();\r\n            // 统计窗口内单词在 words 中出现的次数\r\n            int cnt = 0; \r\n            for (int j = i; j + w <= n; j += w) {\r\n                //窗口已经满，需要去掉窗口最左边的单词，才能在窗口中添加新的单词\r\n                if (j >= i + w * m) {\r\n                    //获取窗口最左边的单词\r\n                    String word = s.substring(j - m * w, w + j - m * w); \r\n                    //去除窗口最左边的单词\r\n                    wd.put(word, wd.get(word) - 1); \r\n                    if (total.get(word) != null && wd.get(word) < total.get(word))\r\n                        cnt--;\r\n                }\r\n                String word = s.substring(j, j + w); \r\n                wd.put(word, wd.getOrDefault(word, 0) + 1); //在窗口最右边添加新的单词\r\n                if (total.get(word) != null && wd.get(word) <= total.get(word)){\r\n                    cnt++;\r\n                }\r\n                if (cnt == m){\r\n                    res.add(j - (m - 1) * w);\r\n                }\r\n            }\r\n        }\r\n        return res; \r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325957520","body":"```python\r\n\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        total = sum(nums)\r\n        mod = total % k\r\n\r\n        ans = len(nums)\r\n        total = 0\r\n        dic = {0: -1}\r\n        for j in range(len(nums)):\r\n            total += nums[j]\r\n            cur = total % k\r\n            target = (cur - mod + k) % k\r\n            if target in dic:\r\n                ans = min(ans, j - dic[target])\r\n            dic[cur] = j\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327775989","body":"```python\r\n\r\n\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if head is None:\r\n            return None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328301858","body":"```java \r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        int j = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (nums[i] != nums[j]) {\r\n                nums[++j] = nums[i];\r\n            }\r\n        }\r\n        return j + 1;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328301759","body":"```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let low = 0;\r\n    let high = nums.length - 1;\r\n     while (low <= high) {\r\n        let mid = Math.floor((low + high) / 2);\r\n        if (nums[mid] == target) {\r\n            return mid\r\n        } else if (nums[mid] < target) {\r\n            low = mid + 1\r\n        } else {\r\n            high = mid - 1\r\n        }\r\n    }\r\n    return low;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1332977397","body":"```java\r\n\r\n\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int n = nums.length;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\r\n            public int compare(int[] pair1, int[] pair2) {\r\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];\r\n            }\r\n        });\r\n        for (int i = 0; i < k; ++i) {\r\n            pq.offer(new int[]{nums[i], i});\r\n        }\r\n        int[] ans = new int[n - k + 1];\r\n        ans[0] = pq.peek()[0];\r\n        for (int i = k; i < n; ++i) {\r\n            pq.offer(new int[]{nums[i], i});\r\n            while (pq.peek()[1] <= i - k) {\r\n                pq.poll();\r\n            }\r\n            ans[i - k + 1] = pq.peek()[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1332976869","body":"```java  \r\n\r\n/**\r\n\tTC: O(n)\tSC: O(n)\r\n*/\r\nclass Solution {\r\n    public int findJudge(int N, int[][] trust) {\r\n        if (trust.length < N - 1) \r\n            return -1;\r\n        \r\n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\r\n        \r\n        for (int[] t : trust) {\r\n            trustScores[t[1]]++;\r\n            trustScores[t[0]]--;\r\n        }\r\n        \r\n        for (int i = 1; i <= N; i++) {\r\n            if (trustScores[i] == N - 1)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332976333","body":"```python\r\n\r\nimport collections\r\n\r\n\r\nclass Solution(object):\r\n    def possibleBipartition(self, n, dislikes):\r\n        Not_COLORED,BLUE,GREEN = 0,1,-1\r\n        def helper(person_id,color):\r\n            color_table[person_id] = color\r\n            for the_other in dislike_table[person_id]:\r\n                if color_table[the_other] == color:\r\n                    return False\r\n                if color_table[the_other] == Not_COLORED and not helper(the_other,-color):\r\n                    return False\r\n            return True\r\n        if n==1 or not dislikes:\r\n            return True\r\n        dislike_table = collections.defaultdict(list)\r\n        color_table = collections.defaultdict(int)\r\n        for p1,p2 in dislikes:\r\n            dislike_table[p1].append(p2)\r\n            dislike_table[p2].append(p1)\r\n        for person_id in range(1,n+1):\r\n            if color_table[person_id] == Not_COLORED and not helper(person_id,BLUE):\r\n                return False\r\n        return True\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333689044","body":"```java \r\n\r\nclass Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        // 第 2 步：实例化组和项目的邻接表\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        // 第 3 步：建图和统计入度数组\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        // 第 4 步：得到组和项目的拓扑排序结果\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\r\n        // key：组，value：在同一组的项目列表\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334655977","body":"```java \r\n\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0,y=0;\r\n        char[] c = moves.toCharArray();\r\n        for(char each:c){\r\n            if(each-'U' == 0){\r\n                y--;\r\n            }else if(each - 'D' == 0){\r\n                y++;\r\n            }else if(each - 'L' == 0){\r\n                x--;\r\n            }else if(each - 'R' == 0){\r\n                x++;\r\n            }\r\n        }\r\n\r\n        if(x == 0 && y ==0){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308976668","body":"    ‘\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return nod\n     ’","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313783363","body":"递归实现\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p == None and q == None:\n            return True\n        if p == None or q == None:\n            return False\n        if p.val != q.val:\n            return False\n\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312745376","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320731791","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        int[] ans = new int[2];\n        for (int i = 0; i < nums.length; i++){\n            if (map.containsKey(target - nums[i])){\n                ans[0] = i;\n                ans[1] = map.get(target - nums[i]);\n                break;\n            }\n            map.put(nums[i], i);\n        }\n        return ans;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326984140","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(fast != null && fast.next != null && fast.next.next != null){\n            slow = slow.next;\n            fast = fast.next;\n            fast = fast.next;\n        }\n        return slow.next;\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335057443","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int r = 0;\n        int u = 0;\n        for(char c : moves.toCharArray()){\n            if(c == 'R'){\n                r++;\n            }else{\n                if(c == 'L'){\n                    r--;\n                }else{\n                    if(c == 'U'){\n                        u++;\n                    }else{\n                        u--;\n                    }\n                }\n            }\n        }\n        return r == 0 && u == 0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316444570","body":"Level order traversal\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque([root])\n        \n        while(queue):\n            res = queue[0]\n            \n            for _ in range(len(queue)):\n                node = queue.popleft()\n                \n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n        \n        return res.val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318151510","body":"```\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return ''\n        \n        data = []\n        queue = collections.deque()\n        queue.append(root)\n        \n        while(queue):\n            node = queue.popleft()\n            if node:\n                data.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                data.append(str('#'))\n        \n        return ','.join(data)\n            \n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        \n        data = data.split(',')\n        root = TreeNode(data[0])\n        queue = collections.deque()\n        queue.append(root)\n        \n        for i in range(1,len(data),2):\n            node = queue.popleft()\n            \n            if node:\n                if data[i]=='#': \n                    node.left = None\n                else: \n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                \n                if i+1<len(data) and data[i+1]=='#':\n                    node.right = None\n                elif i+1<len(data): \n                    node.right = TreeNode(data[i+1])\n                    queue.append(node.right)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319546082","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        memo = collections.defaultdict(lambda: collections.defaultdict(list))\n        self.helper(memo, root, 0, 0)\n        res = []\n        for i in sorted(memo.keys()):\n            temp = []\n            for j in sorted(memo[i]):\n                temp += sorted(memo[i][j])\n            res.append(temp)\n        \n        return res\n    \n  \n    def helper(self, memo, root, x, y):\n        memo[x][y].append(root.val)\n        \n        if root.left:\n            self.helper(memo, root.left, x-1, y+1)\n        if root.right:\n            self.helper(memo, root.right, x+1, y+1)\n        \n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321279735","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        n = len(points)\n        \n        for i in range(n):\n            memo = collections.defaultdict(int)\n            for j in range(n):\n                if i!=j:\n                    dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                    memo[dis] += 1\n                \n            for key in memo:\n                res += memo[key] * (memo[key]-1)\n        \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324552060","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        memo = collections.defaultdict(int) \n        \n        m = len(words)\n        n = len(words[0])\n        \n        if m*n > len(s): return []\n        \n        for word in words:\n            memo[word] += 1\n        \n        res = []\n        for i in range(len(s)):\n            curr = s[i: i+ m*n]\n            temp = collections.defaultdict(int) \n            j = 0\n            \n            while(j<m*n):\n                sub_str = curr[j:j+n]\n                if sub_str not in memo: break\n                temp[sub_str]+=1\n                \n                if temp[sub_str] >memo[sub_str]: break\n                j+=n\n            \n            if j == m * n:\n                res.append(i)\n        \n        \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327982635","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = i = 0\n        \n        while(i< len(nums)):\n            nums[k] = nums[i]\n            while(i+1 < len(nums) and nums[i] == nums[i+1]):\n                i += 1\n            \n            k+=1\n            i+=1\n        \n        return k\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330171903","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        memo = [0] * (n+1)\n        \n        for t in trust:\n            memo[t[1]]+=1\n            memo[t[0]]-=1\n        \n        for i in range(1, n+1):\n            if memo[i] == n - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331599069","body":"```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        colors = [0] * (n+1)\n        graph = collections.defaultdict(list)\n        \n        for d in dislikes:\n            graph[d[0]].append(d[1])\n            graph[d[1]].append(d[0])\n            \n        visited = set()\n        for i in graph:\n            if i in visited: continue\n            if colors[i] == 0:\n                colors[i] = 1\n            \n                queue = collections.deque([i])\n\n                while(queue):\n                    node = queue.popleft()\n \n                    for j in graph[node]:\n                        if colors[j] == colors[node]: return False\n                        if j in visited : continue\n                        \n                        colors[j] = colors[node] * -1\n                        queue.append(j)\n                        visited.add(j)\n                        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333062879","body":"```\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_id = m \n        \n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_id\n                max_id += 1\n        \n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n        \n        \n        for i in range(n):\n            group_projects[group[i]].append(i)\n            \n            for pre in beforeItems[i]:\n                if group[pre] != group[i]:\n                    group_indegree[group[i]] += 1\n                    group_neighbors[group[pre]].append(group[i])\n                else:\n                    project_indegree[i]+=1\n                    project_neighbors[pre].append(i)\n        \n        res = []\n        \n        group_queue = self.tp_sort([i for i in range(max_id)], group_indegree, group_neighbors)\n        \n        if len(group_queue) != max_id: return []\n        \n        for group_id in group_queue:\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n            \n            if len(project_queue) != len(group_projects[group_id]): return []\n            \n            res += project_queue\n        \n        return res\n                    \n        \n    def tp_sort(self, items, indegree, neighbors):\n        res = []\n        queue = collections.deque([])\n        \n        for item in items:\n            if indegree[item] == 0:\n                queue.append(item)\n                \n        while(queue):\n            t = queue.popleft()\n            res.append(t)\n            \n            for neighbor in neighbors[t]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336011915","body":"```\nclass Solution(object):\n    def getOrder(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(tasks)):\n            tasks[i].append(i)\n        \n        tasks.sort()\n        \n        n = len(tasks)\n        res = []\n        h = []\n        pos = 0\n        time = 0\n        \n        while(len(res) < len(tasks)):\n            if not h:\n                time = max(time, tasks[pos][0])\n            \n            while(pos < n and tasks[pos][0] <= time):\n                heapq.heappush(h, [tasks[pos][1], tasks[pos][2]])\n                pos += 1\n            \n            process_t, idx = heapq.heappop(h)\n            time += process_t\n            res.append(idx)\n        \n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316988683","body":"#### 【Day 16】513. 找树左下角的值 \n\n解题思路\nBFS\n\n```c++\n /*\n * Definition for a binary tree node.\n * struct TreeNode {\n * int val;\n * TreeNode *left;\n * TreeNode *right;\n * TreeNode() : val(0), left(nullptr), right(nullptr) {}\n * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n   */\n   class Solution {\n   public:\n   int findBottomLeftValue(TreeNode* root) {\n       vector<int> leftnode;\n       queue<TreeNode*> qu; \n       if(!root) return 0;\n       qu.push(root);\n       while(!qu.empty()){\n           int currsize = qu.size();\n           for(int i=1;i<=currsize;i++){\n               TreeNode* node = qu.front();\n               qu.pop();\n               if(i==1) leftnode.push_back(node->val);\n               if(node->left) qu.push(node->left);\n               if(node->right) qu.push(node->right);\n           }\n       }\n       return leftnode[leftnode.size()-1];\n   }\n   };\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318458892","body":"#### 【Day 17】297. 二叉树的序列化与反序列化 \n\n解题思路：\n\n深度优先搜索（前序遍历+递归）\n\n代码\n\n```c++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    void rserialize(TreeNode* root, string& str) {\n        // 前序遍历（中左右，遇到空节点输入null），用逗号隔开\n        if (root == NULL) str += \"null,\";\n        else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }      \n    }\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    // Decodes your encoded data to tree.\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if(dataArray.front() == \"null\") {\n            dataArray.erase(dataArray.begin());\n            return NULL;\n        }\n        // 前序遍历（中左右）恢复树结构\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        // 添加各节点val\n        // 按引用传递，按值传递会增加耗时\n        for (auto& c : data) {\n            if (c == ',') {\n                // 以逗号作为节点分割\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(c);\n            }\n        }\n        // 添加尾部节点val\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319915975","body":"#### 【Day 18】987. 二叉树的垂序遍历\n\n##### 思路：深度优先搜索\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);     //通过dfs遍历，把节点都安插到mymap里\n        vector<vector<int>> ans;  //用于保存答案\n        map<int, vector<pair<int, int>>>::iterator itB = myMap.begin(), itE = myMap.end();         //用于遍历mymap\n        while(itB != itE){\n            vector<pair<int, int>> &col = itB->second;   //取出mymap里的vector<pair>\n            sort(col.begin(), col.end());           //对其排序\n            const int length = col.size();         //它的长度\n            vector<int> tmp(length);              //准备将它转换成vector<int>\n            for(int i = 0; i < length; ++i)\n                tmp[i] = col[i].second;          //取出值\n            ans.push_back(tmp);                   //放入ans\n            ++itB;\n        }\n        return ans;\n    }\nprivate:\n    map<int, vector<pair<int, int>>> myMap;  //int是列，vector里存的是该节点的行数和值\n    void dfs(TreeNode* root, int row, int col){\n        if(root == nullptr)        //空指针就不用搜索下去了\n            return;\n        myMap[col].push_back({row, root->val}); //加入该列，first是行，second是值\n        dfs(root->left, row + 1, col - 1);   //继续搜索\n        dfs(root->right, row + 1, col + 1);\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320863313","body":"#### 两数之和\n\n##### 思路：哈希表 \n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        map<int,int> hx;\n        for(int i=0;i<nums.size();i++)\n        {\n            int num = target - nums[i];\n            if(hx.find(num) != hx.end())\n            {\n                return {hx[num],i};\n            }\n            hx[nums[i]] = i;\n        }\n        return {-1,-1};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321110367","body":"#### 347. 前 K 个高频元素 \n\n##### 构造一个大小为K的堆来降低算法复杂度\n\n```\nclass Solution {\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\n        return m.second > n.second;\n    }\n\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> occurrences;\n        for (auto& v : nums) {\n            occurrences[v]++;\n        }\n\n        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for (auto& [num, count] : occurrences) {\n            if (q.size() == k) {\n                if (q.top().second < count) {\n                    q.pop();\n                    q.emplace(num, count);\n                }\n            } else {\n                q.emplace(num, count);\n            }\n        }\n        vector<int> res;\n        while (!q.empty()) {\n            res.emplace_back(q.top().first);\n            q.pop();\n        }\n        return res;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321968129","body":"#### 【Day 21】447. 回旋镖的数量 \n\n##### 思路：枚举 + 哈希表\n\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323594927","body":"#### 【Day 22】3. 无重复字符的最长子串 \n\n##### \n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char>u;\n        int left=0,right=0,Max=0;\n        int n=s.size();\n        while(right<n){\n            if(u.end()==u.find(s[right])){\n                u.insert(s[right++]);\n                Max=max(right-left,Max);\n            } else u.erase(s[left++]);\n        }\n        return Max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324993012","body":"#### 【Day 23】30. 串联所有单词的子串\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string &s, vector<string> &words) {\n        vector<int> res;\n        int m = words.size(), n = words[0].size(), ls = s.size();\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\n            unordered_map<string, int> differ;\n            for (int j = 0; j < m; ++j) {\n                ++differ[s.substr(i + j * n, n)];\n            }\n            for (string &word: words) {\n                if (--differ[word] == 0) {\n                    differ.erase(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                    word = s.substr(start - n, n);\n                    if (--differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                }\n                if (differ.empty()) {\n                    res.emplace_back(start);\n                }\n            }\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326329314","body":"#### 【Day 24】删除子表使和能被K整除\n\n##### 同余定理\n\n```c++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int>predSumModK = {{0, 1}};\n        int sum = 0;\n        int res = 0;\n        for(const auto& x: nums){\n            sum += x;\n            int modK = (sum % k + k) % k; //负数取模为负数\n            predSumModK[modK]++;\n        }\n\n        for(const auto& [modK, count]: predSumModK){\n            res += (count * (count - 1) / 2);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327439387","body":"#### 【Day 25】876. 链表的中间结点 \r\n\r\n##### 链表遍历后存成数组\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        vector<ListNode*> A = {head};\r\n        while (A.back()->next != NULL)\r\n            A.push_back(A.back()->next);\r\n        return A[A.size() / 2];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328047301","body":"#### Day 26】26.删除排序数组中的重复项 \n\n##### 双指针\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int m = 0;\n        int w = 1;\n        \n        while(w<nums.size()){\n            if(nums[m] != nums[w]){\n                // nums[++m] = nums[w];\n                nums[m+1] = nums[w];\n                ++m;\n            }\n            w++;\n            \n        }\n        return 1+m;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328237310","body":"#### 【Day 27】35. 搜索插入位置 \n\n##### 双指针\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0;\n        int ans = nums.size();\n        int right = ans-1;\n        while( left <= right ){\n            int i = 0.5*(left + right);\n            if(nums[i] >= target){\n                ans = i;\n                right = i -1;;\n            }\n            else{\n                left = i + 1;\n            }\n            \n        }\n        return ans; \n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328973008","body":"#### 【Day 28】239. 滑动窗口最大值 \n\n##### \n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        priority_queue<pair<int, int>> q;\n        for (int i = 0; i < k; ++i) {\n            q.emplace(nums[i], i);\n        }\n        vector<int> ans = {q.top().first};\n        for (int i = k; i < n; ++i) {\n            q.emplace(nums[i], i);\n            while (q.top().second <= i - k) {\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330601883","body":"#### 【Day 29】997. 找到小镇的法官 \n\n##### 有向图中节点的入度和出度\n\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332196198","body":"#### 【Day 30】886. 可能的二分法 \n\n##### 染色法判断二分图\n\n```c++\nclass Solution {\npublic:\n    bool dfs(int u,const vector<vector<int>> & g, vector<int>& col)\n    {\n        for(int v:g[u]){\n            if(col[v] == -1){\n                col[v] = 1 - col[u];\n                if(!dfs(v,g,col))\n                    return false;\n            }\n            else if(col[u]== col[v]) return false;\n        }\n        return true;\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>>  mp(n);\n        for (auto& edge : dislikes) {\n            int x = edge[0] -1, y = edge[1] - 1;\n            mp[x].push_back(y);\n            mp[y].push_back(x);\n        }\n\n        vector<int> col(n,-1);\n\n        for(int i=0;i<n;i++)\n            if(col[i] == -1)\n            {\n                col[i] = 0;\n                if(!dfs(i,mp,col)) \n                    return false;\n            }\n        return true;\n    \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333685911","body":"#### 【Day 31】1203. 项目管理 \n\n##### \n\n```c++\nclass Solution {\npublic:\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> Q;\n        for (auto& item: items) {\n            if (deg[item] == 0) {\n                Q.push(item);\n            }\n        }\n        vector<int> res;\n        while (!Q.empty()) {\n            int u = Q.front(); \n            Q.pop();\n            res.emplace_back(u);\n            for (auto& v: graph[u]) {\n                if (--deg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        // 组间和组内依赖图\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        // 组间和组内入度数组\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        \n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.emplace_back(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].emplace_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.emplace_back(item);\n            }\n        }\n        return ans;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335126477","body":"#### 【Day 32】657. 机器人能否返回原点 \n\n##### 一条过\n\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int row=0,list=0;\n        for(auto move:moves){\n            if(move == 'U') row++;\n            if(move == 'D') row--;\n            if(move == 'L') list--;\n            if(move == 'R') list++;\n\n        }\n        if(row==0&&list==0) return true;\n        else{\n          return false;  \n        }\n       \n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317020322","body":"### 思路\n\nBFS，先加右节点，就能保证最后一个退出队列的是我们要的。\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode *> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            if (q.front()->right) {\n                q.push(q.front()->right);\n            }\n            if (q.front()->left) {\n                q.push(q.front()->left);\n            }\n            if (q.size() == 1) {\n                return q.front()->val;\n            }\n            q.pop();\n        }\n        return 0;\n    }\n};\n```\n\n### 复杂度分析\n\n时间 O(N), 空间 O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318629741","body":"### 思路\n\nDFS或BFS。这次用的是无递归的DFS，用栈来实现。deserialize和serialize的过程是一样的，只不过一个是栈给字符串提供值，一个是栈从字符串里取值\n\n### 代码\n\n```cpp\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        cout << root;\n        stack<TreeNode*> dfs;\n        string str;\n        dfs.push(root);\n        while (!dfs.empty()) {\n            TreeNode* top = dfs.top();\n            dfs.pop();\n            if (top == nullptr) {\n                str += \"n,\";\n                continue;\n            }\n            str += to_string(top->val) + \",\";\n            dfs.push(top->right);\n            dfs.push(top->left);\n        }\n        return str;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        TreeNode* root = nullptr;\n        stack<TreeNode**> dfs;\n        dfs.push(&root);\n        int val;\n        char t;\n        stringstream stream(data);\n\n        while (!stream.eof()) {\n            if (stream >> val) {\n                TreeNode* newNode = new TreeNode(val);\n                *dfs.top() = newNode;\n                dfs.pop();\n                dfs.push(&newNode->right);\n                dfs.push(&newNode->left);\n            }\n\n            if (stream.fail()){\n                stream.clear();\n            }\n\n            if (stream >> t && t == 'n') {\n                dfs.pop();\n            }\n        }\n\n        return root;\n    }\n};\n```\n\n### 复杂度分析\n\n时间：O(N)  \n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319441200","body":"### 思路\n\n从上到下，所以用BFS可以省去对深度的排序。也可以将二维map简化为一维map。\n\n### 代码\n\n```cpp\n\nstruct XNode {\n    int x;\n    TreeNode* node;\n    XNode(int val, TreeNode* n) : x(val), node(n) {}\n};\n\nvector<vector<int>> verticalTraversal(TreeNode* root) {\n    vector<vector<int>> res;\n    map<int, vector<int>> all_map;\n    queue<XNode> bfs;\n    bfs.push(XNode(0, root));\n    while (!bfs.empty()) {\n        unordered_map<int, vector<int>> layer_map;\n        int n_layer = bfs.size();\n        while (n_layer--) {\n            XNode front = bfs.front();\n\n            if (layer_map.count(front.x)) {\n                layer_map[front.x].push_back(front.node->val);\n            }\n            else{\n                layer_map[front.x] = (vector<int>){front.node->val};\n            }\n\n            if (front.node->left != nullptr) {\n                bfs.push(XNode(front.x - 1, front.node->left));\n            }\n            if (front.node->right != nullptr) {\n                bfs.push(XNode(front.x + 1, front.node->right));\n            }\n            bfs.pop();\n        }\n\n        for (auto &it : layer_map) {\n            sort(it.second.begin(), it.second.end());\n            if (all_map.count(it.first)) {\n                all_map[it.first].insert(\n                        all_map[it.first].end(),\n                        it.second.begin(),\n                        it.second.end()\n                );\n            }\n            else {\n                all_map[it.first] = it.second;\n            }\n        }\n    }\n    for (auto it : all_map) {\n        res.push_back(it.second);\n    }\n    return res;\n}\n\n```\n\n### 复杂度分析\n时间 O(Nlog(N))  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320832022","body":"### 思路\n\n用map或数组来解决，就可以只遍历一遍数组\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> complements;\n        for (int i = 0; i < nums.size(); i++) {\n            int diff = target - nums[i];\n            if (complements.count(diff)) {\n                return {i, complements[diff]};\n            }\n            complements[nums[i]] = i;\n        }\n        return nums;\n    }\n};\n```\n\n### 复杂度分析\n\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321045844","body":"### 思路\n\n一般第k个问题会用堆或者快速选择算法，但这道题需要排序的东西是有限种可能的，所以可以用map来变成线性复杂度。\n\n### 代码\n\n```cpp\nclass Solution {\n  public:\n  vector<int> topKFrequent(vector<int>& nums, int k) {\n      unordered_map<int, int> num_freq;\n      unordered_map<int, vector<int>> freq_num;\n      vector<int> res;\n      for (auto it : nums) {\n          if (num_freq.count(it)) {\n              num_freq[it]++;\n          }\n          else {\n              num_freq[it] = 1;\n          }\n      }\n      int freq_max = 0;\n      for (auto it: num_freq) {\n          if (it.second > freq_max) {\n              freq_max = it.second;\n          }\n          if (freq_num.count(it.second)) {\n              freq_num[it.second].push_back(it.first);\n          }\n          else {\n              freq_num[it.second] = vector<int> {it.first};\n          }\n      }\n      int count = 0;\n      for (int i = freq_max; count < k; i--) {\n          if (freq_num.count(i)) {\n              for (int j = 0; j < freq_num[i].size() && count < k; j++, count++) {\n                  res.push_back(freq_num[i][j]);\n              }\n          }\n      }\n      return res;\n  }\n};\n```\n\n### 复杂度分析\n\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321937898","body":"### 思路\n\nMap\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int count = 0;\n        for (int i = 0; i < points.size(); i++) {\n            unordered_map<int, int> dist_count;\n            for (int j = 0; j < points.size(); j++) {\n                if (i == j) { continue;}\n                int dist = (points[j][0] - points[i][0]) * (points[j][0] - points[i][0]) +\n                        (points[j][1] - points[i][1]) * (points[j][1] - points[i][1]);\n                dist_count[dist] += 1;\n                count += (dist_count[dist] - 1) * 2;\n            }\n        }\n        return count;\n    }\n};\n```\n\n### 复杂度分析\n时间 O(N^2)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323415230","body":"### 思路\n\n双指针\n\n### 代码\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, unsigned> flag;\n        unsigned longest = 0;\n        unsigned start = 0;\n        for (unsigned i = 0; i < s.length(); i++) {\n            if (flag.count(s[i]) && flag[s[i]] >= start) {\n                longest = max(i - start, longest);\n                start = flag[s[i]] + 1;\n            }\n            flag[s[i]] = i;\n        }\n        longest = max((int) s.length() - start, longest);\n        return longest;\n    }\n};\n```\n\n### 复杂度分析\n\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324472562","body":"### 思路\n\n用 `word.length - 1` 个 sliding window，因为我们的步长是 `word,length`。用hash table记录下单次出现的位置，通过与start位置对比，就可以知道是否在这个substring里出现过。用queue作为hash table里的value来存储位置，解决重复的word的问题，因为是从前向后遍历，因此queue里的位置是自动排序的，每次对比只需要对比queue.front()。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        unordered_map<string, unsigned> count;\n        for (auto& word : words) {\n            count[word]++;\n        }\n        unsigned length = words[0].length();\n        for (unsigned i = 0; i < length; i++) {\n            unordered_map<string, queue<unsigned>> pos;\n            int start = i;\n            for (unsigned j = i; j < s.length() - length + 1; j += length) {\n                string sub = s.substr(j, length);\n                if (count.count(sub)) {\n                    if (pos[sub].size() == count[sub] && pos[sub].front() >= start) {\n                        start = pos[sub].front() + length;\n                    }\n                    if (pos[sub].size() == count[sub]) {\n                        pos[sub].pop();\n                    }\n                    pos[sub].push(j);\n                }\n                else {\n                    start = j + length;\n                }\n                if (j + length - start == length * words.size()) {\n                    res.push_back(start);\n                    start += length;\n                }\n            }\n        };\n        return res;\n    }\n};\n```\n\n### 复杂度分析\n时间 `O(words.size() + s.length() * word.length())`  \n空间 `O(words.size() + word.length())`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325887628","body":"### 思路\n\nThe sum of subarray `sum(m, n)` can be calculated by `sum(0, n) - sum(0, m)`. So this problem is to find all pairs of `sum(0, i)` that have a same modulo (remainder), which can be solved like [[1. Two Sum]].\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> modulo_count = {{0, 1}};\n        int sum = 0;\n        int count = 0;\n        for (auto& num : nums) {\n            sum += num;\n            int modulo = (sum % k + k) % k;\n            count += modulo_count[modulo];\n            modulo_count[modulo]++;\n        }\n        return count;\n    }\n};\n```\n\n\n### 复杂度分析\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327323391","body":"```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* middle = head;\n        while (head != nullptr && head->next != nullptr) {\n            head = head->next->next;\n            middle = middle->next;\n        }\n        return middle;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327948039","body":"```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for (int p = 1; p < nums.size(); p++) {\n            if (nums[p] == nums[k]) {continue;}\n            k++;\n            nums[k] = nums[p];\n        }\n        return k + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328160547","body":"```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size();\n        while (right > left) {\n            int med = (left + right) / 2;\n            if (nums[med] == target) {\n                return med;\n            }\n            if (nums[med] > target) {\n                right = med;\n            }\n            else {\n                left = med + 1;\n            }\n        }\n        return left;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328661247","body":"### 思路\n\n滑动窗口+最大最小 = 单调队列\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> mono;\n        vector<int> res;\n        for (int i = 0; i < k; i++) {\n            while (!mono.empty() && nums[mono.back()] < nums[i]) {\n                mono.pop_back();\n            }\n            mono.push_back(i);\n        }\n        res.push_back(nums[mono.front()]);\n        for (int i = k; i < nums.size(); i++) {\n            if (mono.front() < i - k + 1) {\n                mono.pop_front();\n            }\n            while (!mono.empty() && nums[mono.back()] < nums[i]) {\n                mono.pop_back();\n            }\n            mono.push_back(i);\n            res.push_back(nums[mono.front()]);\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\nO(N) / O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330510965","body":"```cpp\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        int judge = -1;\n        vector<int> trust_count(n);\n        vector<int> trusted_count(n);\n        for (auto& pair : trust) {\n            trust_count[pair[0] - 1]++;\n            trusted_count[pair[1] - 1]++;\n        }\n        for (int i = 0; i < n; i++){\n            if (trust_count[i] == 0 && trusted_count[i] == n - 1) {\n                if (judge != -1) {\n                    return -1;\n                }\n                else {\n                    judge = i + 1;\n                }\n            }\n        }\n        return judge;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332067667","body":"### 思路\n\nDFS或BFS，依据相连接的点不能讨论，来寻找有冲突的地方。注意虽然讨厌有方向，但对分组没影响，所以应该看作无向图\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> flag(n);\n        vector<vector<int>> graph(n);\n        for (auto& dislike : dislikes) {\n            graph[dislike[0] - 1].push_back(dislike[1] - 1);\n            graph[dislike[1] - 1].push_back(dislike[0] - 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (!flag[i]) {\n                flag[i] = 1;\n                if (!color(graph, flag, i)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    bool color(vector<vector<int>>& graph, vector<int>& flag, int from) {\n        for (int to : graph[from]) {\n            if (flag[to]) {\n                if (flag[to] != 3 - flag[from])\n                    return false;\n            }\n            else {\n                flag[to] = 3 - flag[from];\n                if (!color(graph, flag, to)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n### 复杂度分析\nO(N + K) / O (N + K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333892100","body":"还没de完bug\n```cpp\nclass Solution {\npublic:\n    vector<unordered_set<int>> all_before;\n    vector<int> ranks;\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> group_items(m);\n        vector<int> res;\n        int rank_min = 0;\n\n        all_before.resize(n);\n        ranks.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            if (group[i] >= 0) {\n                group_items[group[i]].push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (auto before : beforeItems[i]) {\n                int group_before = group[before];\n                int group_after = group[i];\n                if (group_before >= 0 && group_before != group_after) {\n                    for (auto after : group_items[group_after]) {\n                        all_before[after].insert(group_items[group_before].begin(), group_items[group_before].end());\n                    }\n                }\n                else {\n                    all_before[i].insert(before);\n                }\n            }\n        }\n        vector<bool> path(n);\n        for (int item = 0; item < n; item++) {\n            if (ranks[item]) {continue;}\n            int rank = dfs(item, path, rank_min - 1);\n            if (!rank) {return res;}\n            rank_min = min(rank, rank_min);\n        }\n        vector<vector<int>> rank_items(-rank_min);\n        for (int item = 0; item < n; item++) {\n            rank_items[ranks[item] - rank_min].push_back(item);\n        }\n        for (int rank = 0; rank < -rank_min; rank++) {\n            res.insert(res.end(), rank_items[rank].begin(), rank_items[rank].end());\n        }\n        return res;\n    }\n    int dfs(int p, vector<bool>& path, int rank) {\n        int rank_min = rank;\n        if (path[p]) {return 0;}\n        path[p] = true;\n        ranks[p] = min(ranks[p], rank);\n        for (auto item : all_before[p]) {\n            int rank_res = dfs(item, path, rank - 1);\n            if (!rank_res) {return 0;}\n            rank_min = min(rank_res, rank_min);\n        }\n        path[p] = false;\n        return rank_min;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334821348","body":"```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int UD = 0, LR = 0;\n        for (auto c : moves) {\n            switch(c) {\n                case 'L': {\n                    LR++;\n                    break;\n                }\n                case 'R': {\n                    LR--;\n                    break;\n                }\n                case 'U': {\n                    UD++;\n                    break;\n                }\n                default: {\n                    UD--;\n                }\n            }\n        }\n        return !LR && !UD;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318097487","body":"```\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        queue = collections.deque([root])\r\n        res = []\r\n        while queue:\r\n            node = queue.popleft()\r\n            if node:\r\n                res.append(str(node.val))\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                res.append('None')\r\n        return '[' + ','.join(res) + ']'\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return []\r\n        dataList = data[1:-1].split(',')\r\n        root = TreeNode(int(dataList[0]))\r\n        queue = collections.deque([root])\r\n        i = 1\r\n        while queue:\r\n            node = queue.popleft()\r\n            if dataList[i] != 'None':\r\n                node.left = TreeNode(int(dataList[i]))\r\n                queue.append(node.left)\r\n            i += 1\r\n            if dataList[i] != 'None':\r\n                node.right = TreeNode(int(dataList[i]))\r\n                queue.append(node.right)\r\n            i += 1\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319463393","body":"```\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        \r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1318899016","body":"# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        col2nodes = defaultdict(list)\r\n\r\n        def dfs(node,r,c):\r\n            if not node:\r\n                return \r\n            col2nodes[c].append((r, node.val))\r\n            dfs(node.left, r+1, c-1)\r\n            dfs(node.right, r+1, c+1)\r\n        \r\n        dfs(root, 0, 0)\r\n        # print(col2nodes)\r\n        minColIndex = min(col2nodes.keys())\r\n        maxColIndex = max(col2nodes.keys())\r\n        res = []\r\n        for i in range(minColIndex, maxColIndex + 1):\r\n            cur = sorted(col2nodes[i])\r\n            temp = list(x[1] for x in cur)\r\n            res.append(temp)\r\n        \r\n        # print(res)\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320434999","body":"```\nclass Solution:\n    def twoSum(self, A: List[int],t: int) -> List[int]:\n        n = len(A)\n        d = {}\n        for i, v in enumerate(A):\n            if t - v in d:\n                return [d[t- v], i]\n            \n            d[v] = i\n    ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320957010","body":"```\nclass Solution:\n    def topKFrequent(self,a: List[int], k: int) -> List[int]:\n        n = len(a)\n        # # 经典top k 问题\n        # minHeap = []\n\n        # val2freq = Counter(a)\n\n        # for val, freq in val2freq.items():\n        #     heapq.heappush(minHeap, (freq, val))\n\n        #     while len(minHeap) > k:\n        #         heapq.heappop(minHeap)\n        \n        # # print(minHeap)\n\n        # return [v for _, v in minHeap]\n        \n        # 解法二: 快速选择算法\n        # val2freq = Counter(a)\n        # # inplace 交换vals里面的元素\n        # vals = list(val2freq.keys())\n        # t = len(vals) - k\n        # def quick_select(l, r):\n        #     if l >= r:\n        #         return \n        #     pivot_index = partition(l, r)\n\n        #     if pivot_index == t:\n        #         return \n        #     elif pivot_index < t:\n        #         quick_select(pivot_index + 1, r)\n        #     else:\n        #         quick_select(l, pivot_index - 1)\n        # def partition(l, r):\n        #     i = l - 1\n        #     pivot = val2freq[vals[r]]\n        #     for j in range(l ,r):\n        #         if val2freq[vals[j]] < pivot:\n        #             i += 1\n        #             swap(i, j)\n        #     swap(i+1, r)\n        #     return i + 1\n                    \n        # def swap(l, r):\n        #     temp = vals[l]\n        #     vals[l] = vals[r]\n        #     vals[r] = temp\n        \n\n        # quick_select(0, len(vals) - 1)\n        # return vals[t:]\n\n\n        # 解法三: 计数排序\n        val2freq = Counter(a)\n        count2vals = [[] for _ in range(n + 1)] # 最多出现n次\n        # print(count2vals)\n        for val, freq in val2freq.items():\n            count2vals[freq].append(val)\n        \n        # print(count2vals)\n        \n        res = []\n        for i in range(len(count2vals) - 1, -1, -1):\n            for val in count2vals[i]:\n                res.append(val)\n                if len(res) == k:\n                    return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322548172","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def get_dist(a, b):\n            x1, y1 = a[0], a[1]\n            x2, y2 = b[0], b[1]\n            return (x2 - x1) ** 2 + (y1 - y2) ** 2\n        ans = 0\n        n = len(points)\n        d = defaultdict(lambda: defaultdict(int))\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = get_dist(points[i], points[j])\n                d[tuple(points[i])][dist]+= 1\n        \n        ans = 0\n        for point in points:\n            for dist, val in d[tuple(point)].items():\n                ans += val * (val - 1)\n        \n        return ans\n```\n一般需要暴力枚举的题目要不就是二分优化要不就是哈希表优化\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322509976","body":"```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        window = defaultdict(int)\n\n        res = j = 0\n\n        for i, ch in enumerate(s):\n            window[ch] += 1\n\n            while j < n and window[ch] > 1:\n                window[s[j]] -= 1\n                j += 1\n\n            res = max(res, i - j + 1) \n        \n        return res\n```\n标准滑动窗口模版题, 用一个dict记录字符count, 有重复的就缩小窗口直到没有重复","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325679995","body":"···\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        need = defaultdict(int)\n        for word in words:\n            need[word] += 1\n        n = len(s)\n        m = len(words)\n        w = len(words[0])\n        res = []\n        # 分类所有w的起始位置\n        for i in range(0, w):\n            window = defaultdict(int)\n            cnt = 0\n\n            j = i\n            # 起始下标在j, 长度为w的最后一个单词的下表是 j + w - 1 <= n - 1 => j + w <= n\n            # 遍历 0, w, 2w, 3w....\n            #     1, w + 1, 2w + 1 ....\n            #     2, w + 2, 3w + 2\n            # 遍历从i开始的所有起始点下标\n            while j + w <= n:\n                # i + m * w 是 原来的位置, 需要删左边的\n                if j >= i + m * w:\n                    word = s[j - m * w: j - m * w + w]\n                    window[word] -= 1\n                    if window[word] < need[word]:\n                        cnt -= 1\n                \n                # 现在的单词是s[j: j + w]\n                word = s[j: j + w]\n                # 当前窗口的单词数 + 1\n                window[word] += 1\n                \n                if window[word] <= need[word]: cnt += 1\n\n                if cnt == m:\n                    res.append(j - (m - 1) * w)\n                \n                j += w\n        \n        return res\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325675903","body":"···\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        tot = sum(nums)\r\n        if tot % p == 0:\r\n            return 0\r\n        n = len(nums)\r\n        s = 0\r\n        # (tot - remove) % p == 0\r\n        # remove % p == C\r\n        t = tot % p\r\n        # (rightSum - leftSum) % p == target\r\n        # rightSum % p - leftSum % p == target\r\n        # leftSum % p == (rightSum % p) - target\r\n        # (s % p) - t = left % p\r\n        res = n\r\n        d = defaultdict(int)\r\n        d = {\r\n            0: -1\r\n        }\r\n        res = len(nums)\r\n        for i in range(len(nums)):\r\n            s += nums[i]\r\n            curmod = s % p\r\n           这里有可能是负数所以要这么操作\r\n            tarmod = (curmod - t + p) % p\r\n            if tarmod in d:\r\n                dis = i - d[tarmod]\r\n                res = min(res, dis)\r\n            d[curmod] = i\r\n        return res if res != n else -1\r\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326743502","body":"```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # 1 2 3 4 返回 3\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n        // 1 2 3 4 返回2\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328165501","body":"···\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        def process(nums, k):\n            idx = 0\n            for x in nums:\n                # 如果idx不足k个数直接保存\n                # 如果 1 1 1 1 4 5 5 5 5 5 k = 3 \n                #     0 1 2 3 4 \n               #  if idx - k >= 0:\n                #     print(idx, nums[idx - k], x)\n                if idx < k or nums[idx - k] != x:\n                    if idx - k >= 0:\n                        print(nums[idx])\n                    nums[idx] = x\n                    if idx - k >= 0:\n                        print(numsa[idx])\n                    # print(nums[idx])\n                    idx += 1\n                print(nums)\n            return idx\n        return process(nums, 3)\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328165382","body":"···\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        l, r = 0, n\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] >= target:\n                r = m\n            else:\n                l = m + 1\n        \n        return l\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328501550","body":"···\nclass MQ:\n    def __init__(self):\n        self.q = deque()\n        self.maxq = deque()\n    \n    def add(self, val):\n        self.q.append(val)\n\n        while self.maxq and self.maxq[-1] < val:\n            self.maxq.pop()\n        self.maxq.append(val)\n    \n    def pop(self):\n        val = self.q.popleft()\n        if val == self.maxq[0]:\n            self.maxq.popleft()\n    \n    def max(self):\n        return self.maxq[0]\n\n    def size(self):\n        return len(self.q)\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        window = MQ()\n        res = []\n        for i, v in enumerate(nums):\n            window.add(v)\n            if window.size() == k:\n                res.append(window.max())\n                window.pop()\n        \n        # print(res)\n        return res\n\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1331106743","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # 1 - n n个人\n        # judge 谁都不信\n        # 每个人, 除了judge自己, 都相信judge\n        # 只有一个人满足性质1 和 性质2\n        # judge可以得到得分为 n - 1, 只存在唯一一个judge, 即数组中不存在两个得分为n-1的人\n        # judge 自己不可以相信自己 \n        points = [0] * (n + 1)\n\n        for a, b in trust:\n            points[b] += 1\n            points[a] -= 1\n        \n        #$ print(points)\n        seen = False\n        ans = -1\n        for i in range(1, n+1):\n            if not seen and points[i] == n - 1:\n                seen = True\n                ans = i\n            elif seen and points[i] == n - 1:\n                return -1\n        \n        return ans \n\n            \n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331126673","body":"```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        # 二分图模拟题\n        # \n        # 染色\n        # 1 - n\n        # 每个人的颜色是WHITE和BLACK, 看看能不能分成两组\n        color = [0] * (n + 1)\n        vis = [False] * (n + 1)\n\n        g = defaultdict(list)\n        for u, v in dislikes:\n            g[u].append(v)\n            g[v].append(u)\n        \n        ans = True\n        def dfs(o):\n            nonlocal ans\n            if not ans:\n                return \n            \n            vis[o] = True\n\n            for nei in g[o]:\n                if not vis[nei]:\n                    color[nei] = not color[o]\n                    dfs(nei)\n                else:\n                    if color[o] == color[nei]:\n                        ans = False\n                        return \n        for i in range(1, n + 1):\n            dfs(i)\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1332674880","body":"···\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        # 数据的预处理, 将 为-1的组分到别的组里面\n        \n        for i in range(len(group)):\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n        groupAdj = defaultdict(list)\n        itemAdj = defaultdict(list)\n        groupInd = [0] * m\n        itemInd = [0] * n\n        # 建立组的有向图\n        for i in range(len(group)):\n            currGroup = group[i]\n            for beforeItem in beforeItems[i]:\n                beforeGroup = group[beforeItem]\n                if currGroup != beforeGroup:\n                    groupAdj[beforeGroup].append(currGroup)\n                    groupInd[currGroup] += 1\n        # 建立item的有向图\n        for i in range(n):\n            \n            for item in beforeItems[i]:\n                itemAdj[item].append(i)\n                itemInd[i] += 1\n                \n        groupList = self.topologicalSort(groupAdj, groupInd, m)\n        if len(groupList) == 0:\n            return []\n        itemsList = self.topologicalSort(itemAdj, itemInd, n)\n        if len(itemsList) == 0:\n            return []\n        \n        group2Items = defaultdict(list)\n        for item in itemsList:\n            group2Items[group[item]].append(item)\n        res  = []\n        for groupId in groupList:\n            res.extend(group2Items[groupId])\n        \n        return res\n    \n    def topologicalSort(self, graph, ind, n):\n        q = deque()\n        for i in range(n):\n            if ind[i] == 0:\n                q.append(i)\n        res = []\n        while q:\n            curr = q.popleft()\n            res.append(curr)\n            for nei in graph[curr]:\n                ind[nei] -= 1\n                if ind[nei] == 0:\n                    q.append(nei)\n        \n        if len(res) == n:\n            return res\n        return []\n        \n        \n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334135190","body":"···\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        dirs = {\n            \"R\": (0, 1),\n            \"L\":(0, -1),\n            \"D\":(1, 0),\n            \"U\":(-1, 0)\n        }\n        start = [0, 0]\n        for v in moves:\n            dx, dy = dirs[v]\n            start[0] += dx\n            start[1] += dy\n        return start == [0, 0]\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1335648801","body":"···\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        n = len(tasks)\n        a = list([enque_time, process_time, i] for i, (enque_time, process_time) in enumerate(tasks))\n        a.sort()\n        t = 0\n        # i 指针在a上挪动, 用来放可以执行的tasks\n        i = 0\n        res = []\n        minHeap = []\n        while len(res) < n:\n            # 如果没有可以执行的任务, 时间跳过\n            if not minHeap:\n                t = max(t, a[i][0])\n            # 这里错误的原因是因为, 虽然当前的时间 < a[i][0], 但是任务队列中还有可以执行的任务, 所以不要这样加时间\n            # while i < n and t < a[i][0]:\n            #     t += 1\n            # print(t)\n            while i < n and a[i][0] <= t:\n                heapq.heappush(minHeap, (a[i][1], a[i][2]))\n                i += 1\n            # 执行tasks\n            if minHeap:\n                # print(minHeap)\n                process_time, _id = heapq.heappop(minHeap)\n                res.append(_id)\n                t += process_time\n        # print(res)\n        return res\n···","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1320839822","body":"## 解题思路：\n把数组nums转换成整数，然后加上k值，  \n然后再把求到的和值进行数值切分，添加到列表的头部，最后返回整个数组  \n\n## 代码：\n    class Solution:  \n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:  \n            item = 0  \n            new_list = []  \n            for i in num:  \n                item = item*10 + i  \n            new_total = item + k  \n            while new_total !=0:  \n                last =  new_total % 10  \n                new_total //= 10    \n                new_list.insert(0,last)  \n            return new_list  \n\n## 复杂度分析：\n时间复杂度：O(n),for循环遍历整个数组，n为数组元素个数，\nwhile循环遍历整数值，相当于for循环遍历，所以时间复杂度为O(n)  \n空间复杂度：新开辟一个列表的存储空间，列表长度为n，所以空间复杂度为O(n)  ","onTime":false},null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1320068706","body":"dfs深度优先搜索解题思路：   \n前序遍历二叉树  \n二叉树最大深度 = max（左子树最大深度，右子树最大深度）+ 1  \n只要求出两边子树的最大深度即可求出整个二叉树的最大深度  \n\n\"\"\"\n\n    class Solution:  \n        def maxDepth(self, root) -> int:  \n            if root is None:  \n                return 0  \n            else:  \n                left_deep = self.maxDepth(root.left)  \n                right_deep = self.maxDepth(root.right)  \n                return max(left_deep,right_deep) + 1  \n\n\n\"\"\"\n\n时间复杂度分析：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。  \n\n空间复杂度分析：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1320162601","body":"## 深度搜索思路：\n    if q 和 p 都为空 return True\n    if q 或 p 有一个为 空 return False\n    if q 和 p 都不空：\n        比较两个树的根节点，左子树，右子树。\n        算法使用递归调用\n## 代码\n    class Solution:  \n        def isSameTree(self, p, q) -> bool:  \n            if not p and not q :  \n                return True  \n            elif not p or not q :  \n                return False  \n            elif p.val == q.val:  \n                return (self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right))  \n            else:  \n                return False  \n\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1320227647","body":"## 深度搜索题解思路：\n\nif 根节点为空，return 0  \nelse: 从根节点开始遍历，if 当前为叶子节点：叶子节点 + 数字之和    \n                                           #                                                 #  ##### ##########else 继续遍历  \n\n## 代码\n\n    class Solution:  \n        def sumNumbers(self, root) -> int:  \n            def dfs(root,number):  \n                if not root:  \n                    return 0  \n                total_number = 10 * number + root.val  \n                print(\"左叶子节点\", not root.left)  \n                if not root.left and not root.right:  \n                    print(total_number)  \n                    return total_number  \n                else:  \n                    return dfs(root.left,total_number) + dfs(root.right,total_number)  \n            return dfs(root,0)  \n\n## 复杂度分析：\n时间复杂度：O(n)，其中 n是二叉树的节点个数。对每个节点访问一次。\n\n空间复杂度：O(n)，其中 n是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320247070","body":"## 解体思路：\n遍历整个二叉树，把二叉树的节点的x,y,value放到一个列表list_0中，x表示横坐标，y表示纵坐标，value表示当前节点的值。按照y值的大小进行升序排列。要把list_0进行遍历，要取出相同y值 \n 的的value值，放到一个列表中。\n## 代码：\n\n    from operator import itemgetter  \n        class Solution:  \n            def verticalTraversal(self, root):  \n                list_0 = list()  \n                def dfs(list_1, x, y):  \n                    \"\"\"\n                    :param node: 树的节点值\n                    :param x: 横坐标\n                    :param y: 纵坐标\n                    :return: none\n                    \"\"\"\n                    if not list_1:  \n                        return  \n                    list_0.append((x, y, list_1.val))  \n                    dfs(list_1.left, x + 1, y - 1)  \n                    dfs(list_1.right, x + 1, y + 1)  \n    \n                dfs(root, 0, 0)  \n                list_0.sort()  \n                list_0 = sorted(list_0,key=itemgetter(1))  \n                print(list_0)  \n                ans, lasty = list(), float(\"-inf\")  \n                for x, y, value in list_0:  \n                    print(y)  \n                    if y != lasty:  \n                        lasty = y  \n                        ans.append(list())  \n                    ans[-1].append(value)  \n                    print(\"lasty\", ans)  \n                return ans  \n”“”\n\n## 复杂度分析：\n时间复杂度：O(nlogn)  \n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320731061","body":"## 解题思路：\r\n暴力枚举：遍历nums数组，判断是否 y + x=target\r\n\r\n## 代码：\r\n    class Solution:\r\n        def twoSum(self, nums, target):\r\n            for i in range(len(nums)):\r\n                for j in range(i+1,len(nums)):\r\n                    if nums[j] + nums[i] == target:\r\n                        return [i,j]\r\n\r\n## 复杂度分析：\r\n时间复杂度：嵌套遍历nums两遍 O(n²)  \r\n空间复杂度：O(1)\r\n\r\n## 哈希表思路：\r\n将nums 中的值和下表放到哈希表中，哈希表组成一个字典，通过查询target-x 的值是否在字典中，返回对应的下标。  \r\n\r\n## 代码\r\n    class Solution:  \r\n        def twoSum(self, nums: List[int], target: int) -> List[int]:  \r\n            hashtable = dict()  \r\n            for i, num in enumerate(nums):  \r\n                if target - num in hashtable:  \r\n                    return [hashtable[target - num], i]  \r\n                hashtable[nums[i]] = i  \r\n            return []  \r\n    a = Solution()  \r\n    numbers = [1,2,3,4,5,6,7,8,9]  \r\n    print(a.twoSum(numbers,8))  \r\n\r\n## 复杂度分析\r\n时间复杂度：O（n)  \r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321128371","body":"class Solution:  \n    def topKFrequent(self, nums, k: int) -> int:\n\n        heap = [(-1 * v1, k1) for k1, v1 in Counter(nums).items()]  # O(N) to build the heap\n        heapq.heapify(heap)  # O((n-k) log n). Worst case O(n log n).\n        result = []\n        for i in range(k):\n            result.append(heapq.heappop(heap)[1])  # O(logN) / O((n-k) log n) for the pops\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322277709","body":"     class Solution:\n        def numberOfBoomerangs(self, points: List[List[int]]) -> int:  \n            an = 0  \n            for i in points:  \n                cnt = defaultdict(int)  \n                #print(cnt)  \n                for m in points:  \n                    dist = (i[0]-m[0])*(i[0]-m[0])+(i[1]-m[1])*(i[1]-m[1])  \n                    cnt[dist] += 1  \n                print(cnt)  \n                for m in cnt.values():  \n                    print(m)  \n                    an += m * (m - 1)  \n            return an  \n\n## 复杂度分析：\n\n时间复杂度为O(n^2)  \n空间复杂度为O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328035256","body":"    class Solution:  \n        def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:  \n           p=q=head  \n           while q and q.next:  \n               p = p.next  \n               q = q.next.next  \n           return p  ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328033327","body":"# 思路：\n考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：  \n1.比较 p 和 q 位置的元素是否相等。  \n如果相等，q 后移 1 位  \n2.如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位  \n重复上述过程，直到 q 等于数组长度。返回 p + 1，即为新数组长度  \n\"\"\"  \n# 代码\n    class Solution:  \n        def removeDuplicates(self, nums: List[int]) -> int:  \n            if not nums:  \n                return 0  \n            n = len(nums)  \n            p = q = 0   \n            while q<n:  \n                if nums[p] ==nums[q]:  \n                    q +=1  \n                else:  \n                    nums[p+1]=nums[q]  \n                    p +=1  \n                    q +=1  \n            return p+1  \n    m = Solution()  \n    data = [1,1,2]  \n    m.removeDuplicates(data)  \n\n\"\"\"\n# 复杂度分析：  \n时间复杂度：O(n)  \n空间复杂度：O(1)  \n\"\"\"","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333867834","body":"class Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_id = m \n        \n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_id\n                max_id += 1\n        \n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n        \n        \n        for i in range(n):\n            group_projects[group[i]].append(i)\n            \n            for pre in beforeItems[i]:\n                if group[pre] != group[i]:\n                    group_indegree[group[i]] += 1\n                    group_neighbors[group[pre]].append(group[i])\n                else:\n                    project_indegree[i]+=1\n                    project_neighbors[pre].append(i)\n        \n        res = []\n        \n        group_queue = self.tp_sort([i for i in range(max_id)], group_indegree, group_neighbors)\n        \n        if len(group_queue) != max_id: return []\n        \n        for group_id in group_queue:\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n            \n            if len(project_queue) != len(group_projects[group_id]): return []\n            \n            res += project_queue\n        \n        return res\n                    \n        \n    def tp_sort(self, items, indegree, neighbors):\n        res = []\n        queue = collections.deque([])\n        \n        for item in items:\n            if indegree[item] == 0:\n                queue.append(item)\n                \n        while(queue):\n            t = queue.popleft()\n            res.append(t)\n            \n            for neighbor in neighbors[t]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326840784","body":"\"public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        if (fast.next == null) {\n            return slow;\n        } else {\n            return slow.next;\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327999479","body":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        len_ = 1\n        if len(nums)==0:\n            return 0\n        for i in range(1,len(nums)):\n            if nums[i] != nums[i-1]:\n                nums[len_] = nums[i]\n                len_ +=1\n        return len_","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330062488","body":"class Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] outDegrees = new int[n + 1];\n        int[] inDegrees = new int[n + 1];\n        for (int[] ab : trust) {\n            outDegrees[ab[0]] += 1;\n            inDegrees[ab[1]] += 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334773485","body":"class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332156113","body":"class Solution {\nprivate:\n    vector<int> color;\n    vector<vector<int>> edges;\n\n    bool bitpart(int u, int c) {\n        color[u] = c;\n        for(int v : edges[u]) {\n            if(color[v] != -1 && color[v] == c) {\n                return false;\n            }\n            if(color[v] == -1 && !bitpart(v,!c))return false;\n        }\n        return true;\n    }\npublic:\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        edges.resize(N+1);\n        for(vector<int> edg:dislikes) {\n            edges[edg[0]].push_back(edg[1]);\n            edges[edg[1]].push_back(edg[0]);\n        }\n        color.resize(N+1,-1);\n        for(int i = 1;i <= N; ++i) {\n            if(color[i] == -1 && !bitpart(i,0))return false;\n        }\n        return true;\n    }\n};、","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}