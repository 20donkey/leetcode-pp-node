{"ruohai0925":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916226878","body":"## 思路\r\n\r\n从个位开始加，用carry表示进位\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# from typing import List\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, A, K):\r\n        if K == 0:\r\n            return A\r\n\r\n        i = len(A) - 1\r\n        carry = 0\r\n\r\n        # d = []\r\n        d = deque()\r\n\r\n        while i >= 0 and K > 0:\r\n            temp = A[i] + carry + K % 10\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n            i -= 1\r\n\r\n        while i < 0 and K > 0:\r\n            temp = K % 10 + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n\r\n        while i >= 0:\r\n            temp = A[i] + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            i -= 1\r\n\r\n        if carry > 0:\r\n            #d.insert(0, carry)\r\n            d.appendleft(carry)\r\n\r\n        #return d\r\n        return list(d)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ImSingee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916251691","body":"```rust\r\nimpl Solution {\r\n    pub fn add_to_array_form(num: Vec<i32>, mut k: i32) -> Vec<i32> {\r\n        let mut result = Vec::new();\r\n        for i in (0..num.len()).rev() {\r\n            result.push({\r\n                let result = num[i] + k;\r\n                let x = result % 10;\r\n                k = result / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        while k > 0 {\r\n            result.push({\r\n                let x = k % 10;\r\n                k = k / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        result.reverse();\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度 O(len(num)) [logk约等于1 忽略] \r\n额外空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916253690","body":"### 思路\r\n按照官方题解\r\n\r\n### CPP代码\r\n```Cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0; --i){\r\n            int curSum = num[i] + k % 10;\r\n            k /= 10;\r\n            if(curSum >= 10){\r\n                k++;\r\n                curSum -=10;\r\n            }\r\n            res.push_back(curSum);\r\n        }\r\n        while(k > 0){\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dana-Dai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916255452","body":"## 思路\n直接对数组操作，但要注意进位，尤其是K > A的情况，要在数组开头插入以进位\n\n## 语言\ncpp\n\n## 代码\n···\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        //把K直接加到数组num上\n        int len = num.size() - 1;\n        while (k > 0) {\n            num[len] += k;\n            k = num[len] / 10;\n            num[len] %= 10;\n            len --;\n\n            if (len < 0 && k > 0) {\n                num.insert(num.begin(), 0);\n                len = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n## 复杂度分析\n时间复杂度：$O（N）$即需要遍历一遍数组，故为N\n空间复杂度：$O（1）$不需要额外开辟空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-Battle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916257585","body":"## 思路\n\n## 关键点\n\n-  从个位开始往前面推算，每计算一位就放入vector结果中，并通过carry维护进位，最后再反转\n- 注意数组下标和k的位数要保证有效，防止越界\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int carry = 0, len = num.size() - 1;\n        int tmparr = 0, tmpk = 0, sum = 0;\n        int i = len;\n        while (i >= 0 || k != 0) {\n            tmparr = 0;\n            tmpk = 0;\n            if (k != 0) {\n                tmpk = k % 10;\n                k /= 10;\n            }\n            if (i >= 0) {\n                tmparr = num[i];\n                --i;\n            }\n\n            sum = tmparr + tmpk + carry;\n            carry = sum / 10;\n            res.emplace_back(sum % 10);    \n        }\n        \n        if (carry) {\n            res.emplace_back(carry);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916262628","body":"## 思路\r\n简单数值解法\r\n## 代码\r\n\r\n```py3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = 0\r\n        ans=[]\r\n        if len(num)==1 and num[0]==0 and k==0: return[0]\r\n        for i in num:\r\n            x = x*10 + i\r\n        x = x + k\r\n        while x!=0:\r\n            ans.append(x%10)\r\n            x=x//10\r\n        return ans[::-1]\r\n```\r\n\r\n## 复杂度\r\n时间：O(2n)\r\n空间：O(ans)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916267006","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0 ; i--) {\n            temp = k%10;\n            k/=10;\n            if (temp+num[i]>=10){\n                k++;\n                ans.addFirst((temp+num[i])%10);\n            }else {\n                ans.addFirst(temp+num[i]);\n            }\n            if (i==0){\n                while (k>0){\n                    temp = k%10;\n                    k/=10;\n                    ans.addFirst(temp);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916274001","body":"## 思路 \n从低位往高位顺着加\n### 代码 ： java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n\n### 复杂度分析\n - 时间复杂度：O(n)，其中 n 为数组的长度\n - 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916275711","body":"\n从低到高递归处理每一位以及前面的进位\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = num[::-1]\n        k = [int(x) for x in str(k)][::-1]\n        ret = []\n        def add1(l1, l2, carry, idx):\n            nonlocal ret\n            if carry == 0 and idx >= len(l1) and idx >= len(l2): return\n            n1 = 0 if idx >= len(l1) else l1[idx]\n            n2 = 0 if idx >= len(l2) else l2[idx]\n            ret.append((n1+n2+carry) % 10)\n            carry = (n1+n2+carry)//10\n            add1(l1, l2, carry, idx+1)\n        add1(num, k, 0, 0)\n        return ret[::-1]\n```\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916277083","body":"## 代码\r\nJava:\r\n\r\n```java\r\n// Space = O(n) / O(1) 数组/k长度\r\n// Time = O(Math.max(n, log(k)) / O(1): num或k长度中较大的\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用LinkedList不断从头将位数和加入index 0\r\n        List<Integer> res = new LinkedList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            //从末尾往前扫，加和取余的值\r\n            res.add(0, (num[i] + k) % 10);\r\n            //更新k存进位carry\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        \r\n        // post-possing: 处理k位数大于num的情况剩下的部分\r\n        // Time = O(log(k))\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n##  复杂度分析\r\nSpace = O(n) / O(1) ：数组/k长度\r\n\r\nTime = O(Math.max(n, log(k)) / O(1): num或k长度中较大的","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916278377","body":"## 思路\nAddition from right to left\n\n## 代码\n\n```Kotlin\nfun addToArrayForm(num: IntArray, k: Int): List<Int> {\n  val res = mutableListOf<Int>()\n  var carry = 0\n  var index = num.size - 1\n  var tmp = k\n\n  while (index >= 0 || tmp > 0 || carry > 0) {\n    var sum = carry\n    if (index >= 0) sum += num[index--]\n    if (tmp > 0) sum += tmp % 10\n\n    res.add(sum % 10)\n\n    carry = sum / 10\n    tmp /= 10\n  }\n  return res.reversed()\n}\n```\n\n## 复杂度分析\n- Time：O(len(num))\n- Space：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916281347","body":"#### JS\n\n```js\nvar addToArrayForm = function (num, k) {\n    const ret = [];\n    let i = num.length - 1, carry = 0;\n    while (i >= 0 || k != 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n\n        const sum = x + y + carry;\n\n        ret.push(sum % 10);\n        carry = Math.floor(sum / 10);\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if (carry) {\n        ret.push(carry);\n    }\n    return ret.reverse();\n};\n```\n#### 复杂度分析\n- 时间复杂度：O（n），再具体不会了\n- 空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916284826","body":"# LC989. Add to Array-Form of Integer\r\n## Main Idea\r\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\r\n\r\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\r\n\r\n## Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length, carry = 0, i = n - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int kDigit = k % 10;\r\n            k /= 10;\r\n            int sum = i >= 0 ? carry + kDigit + num[i] : carry + kDigit;\r\n            res.add(sum % 10);\r\n            carry = sum >= 10 ? 1 : 0;\r\n            --i;\r\n        }\r\n      \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity Analysis\r\nTime: `O(max(N, log(K)))`\r\n* Given a number `K`, its length will be `log_{2}(K)`, the time complexity depends on the length of `N` and `K`, whichever is longer.\r\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition. If we insert at the head of array, then it will take `O(n^2)` of time.\r\n\r\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293322","body":"## LC 989 Add to Array-Form of Integer\n\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Topics  \n\n- Array\n- Math\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/add-two-numbers/\n\nEasy\n- https://leetcode.com/problems/plus-one/\n- https://leetcode.com/problems/add-binary/\n- https://leetcode.com/problems/add-strings/\n\n\n### 思路 \nAdd the number K to the array from right to left.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carrier = 0\n        num_len = len(num)\n        i = num_len -1\n        # Add all matching digit        \n        while i >= 0 and k > 0:\n            cur_k, k = k%10, k//10\n            t_carrier = (num[i] + cur_k + carrier) // 10\n            num[i] = (num[i] + cur_k + carrier) % 10\n            carrier = t_carrier\n            i -= 1\n        \n        # Check whether num or k is left\n        if i >= 0:\n            while i >= 0:\n                t_carrier = (num[i] + carrier) // 10\n                num[i] = (num[i] + carrier) % 10\n                carrier = t_carrier\n                if carrier == 0:\n                    break\n                i -= 1\n            \n        if k > 0:\n            while k > 0:\n                cur_k, k = k%10, k//10\n                t_carrier = (cur_k + carrier) // 10\n                num = [(cur_k + carrier) % 10] + num\n                carrier = t_carrier\n\n        # Deal with carrier\n        if carrier > 0:\n            return [carrier] + num\n        else:\n            return num\n            \n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293869","body":"## 思路\r\n\r\n双指针 + 进位加法逻辑\r\n\r\n双指针, 让两个数的末位对齐, 两个指针 i, j均从各自字符串的末尾开始走。\r\n\r\n定义一个数组来存放结果, 一个int值carry来记录每位的进位值, 初始值设为0。\r\n算当前位置的数时, sum = a[i] + b[j] + carry, 每趟都要记得更新carry的值。\r\n\r\n循环结束时, 由于低位的数字字符先加到了结果字符串中, 最后还需要 reverse 一次, 让位置恢复正常。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int k) {\r\n        if (k == 0) return A;\r\n        vector<int> res;\r\n        int n = A.size();\r\n        // 对位相加\r\n        int carry = 0;\r\n        int sum = 0;      \r\n        int i = n - 1; \r\n        while (k > 0 || i >= 0)\r\n        {\r\n            sum = carry + (k % 10);\r\n            if (i >= 0) // 保证访问A[i]前不越界\r\n                sum += A[i];\r\n\r\n            carry = (sum <= 9) ? 0 : 1;\r\n            res.push_back(sum % 10);            \r\n            k = k / 10;\r\n            \r\n            i--;\r\n        }\r\n        if (carry == 1) res.push_back(1);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数K的长度。\r\n- 空间复杂度：O(n), 主要是结果数组用的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314383","body":"- Talk about how to make an easy problem complicated:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int size = Math.max(num.length, String.valueOf(k).length());\n        int dif = size - num.length; \n        int[] ans = new int[size];\n        int carry = 0;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            int n = (i - dif) < 0 ? 0:num[i - dif];\n            int m = k % 10;\n            k = k / 10;\n            ans[i] = (n + m + carry) % 10;\n            carry = (n + m + carry) / 10;\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        if (carry == 1) list.add(1);\n        for (int i: ans) list.add(i);\n        \n        return list;\n    }\n}\n```\n\n- So turns out all we need to do is adding digits from the last position and reverse the list.\n- Time and space O(max(n, m)) where n is the length of num and m is the number of digits in k.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314749","body":"``` python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n        \r\n```\r\n\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916315048","body":"# ***Title:989. Add to Array-Form of Integer***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/)\n\n## ***Solution***\n1. Revert the array, so that we only need to manipulate the end of the array.\n2. Extract the lowest digit of K and add into the array ascendingly. \n3. After each addition, if the item at the given index excceds 10, then only keep the lowest digit part and add 1 to the next item in the array (Watch out the array boundary and expand the array by 1 if needed..\n4. After processed K, check if there still exist delta > 0, if so keep on repeating the process similar to step 2 until delta equals 0.\n5. Revert the array back.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int index = 0;\n        int delta = 0;\n        \n        std::reverse(num.begin(), num.end());\n        \n        while (k > 0) {\n            delta += k % 10 + num[index];\n            k /= 10;\n            \n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (k > 0 || delta > 0))\n                num.push_back(0);\n        }\n        \n        while (delta > 0) {\n            delta += num[index];\n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (delta > 0))\n                num.push_back(0);\n        }\n            \n        std::reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(max(N, M)), N is the size of the array, while M is the size of the virtual array form of K, which is logarithm of base 10 -> log10(K).\n\n### ***Space Complexity and Explaination***\nO(1) since we reuse the input array and didn't need any extra space","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916317988","body":"## 思路\r\n### 模版\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n### 代码\r\n- 语言： Python3\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) -1\r\n        res = []\r\n        carry = 0\r\n\r\n        while i >=0 or k != 0:\r\n            if i >= 0:\r\n                curr_num = num[i]\r\n            else:\r\n                curr_num = 0\r\n            if k != 0:\r\n                curr_k = k % 10 \r\n            else:\r\n                curr_k = 0\r\n\r\n            total = curr_num + curr_k + carry\r\n            curr_total = total % 10\r\n            carry = total // 10\r\n            res.append(curr_total)\r\n            i -= 1\r\n            k = k // 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n\r\n        return res[::-1]\r\n```\r\n\r\n### 复杂度：\r\n- 时间复杂度：$O(n)$ 遍历\r\n- 空间复杂度：$O(n)$ 新创立了一个ans list","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916322388","body":"### 思路\n\nDeque, Array遍历；\n\n注意题目要求，1 <= A.length <= 10000，所以直接做加法是不可能的。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int pos = 0;\n        int carry = 0;\n        Deque<Integer> res = new LinkedList<>();\n        while(pos < num.length || k >= Math.pow(10, pos) || carry > 0){\n            int fromNum = pos < num.length?num[num.length - 1 - pos]:0;\n            int fromK = (k / (int)Math.pow(10, pos)) % 10;\n            int sum = fromNum + fromK + carry;\n            res.addFirst(sum % 10);\n            carry = sum > 9?1:0;\n            pos++;\n        }\n                \n        return new ArrayList<>(res);\n    }\n}\n```\n\n### 复杂度\n\nO(MAX(num.length, Integer.valueOf(k).toString.length()))\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916330275","body":"思路：\nadd with carry\n\nPython:\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        n = len(num)\n        while(n > 0 or k > 0):\n            if n > 0:\n                k += num[n - 1]\n            k, r = divmod(k, 10)\n            res.append(r)\n            n -= 1\n        return res[::-1]\n```\nC++:\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum;\n        for (int i = n - 1; i >=0; --i){\n            \n            /*Calculation of current digit*/\n            \n            sum = num[i] + k % 10;\n            k /= 10;\n            \n            /*Add the carry to k if there is any*/\n            \n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            \n            /*Append the sum to the end*/\n            \n            res.push_back(sum);\n        }\n        \n        /* Append the rest of k to the end if k is bigger than n*/\n        \n        for (k = k; k > 0; k/= 10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度：O(len(A) + len(str(k)) + len(res)) = O(max(len(A), len(str(k))))\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916334960","body":"[LC 989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路**\n- 把num list转化成数字\n- 数字和k相加\n- 相加的和转化成list\n\n**python代码**\n```class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        true_number = 0\n        result = []\n        if k == 0 and len(num) == 1:\n            return num\n        for i in range(n):\n            true_number = true_number + num[i]*10**(n-i-1)\n\n        add_up = true_number + k\n        while add_up:\n            result.append(add_up%10)\n            add_up = add_up//10\n\n        return result[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JiangyanLiNEU":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916335257","body":"### Two ideas hit me when I saw this problem.\n* convert array num to integer --> add k to the integer --> convert new integer to array --> return this array\n* Use k as carry on number, and keep adding it to the elements in num until k is 0. Note that, we might  need to insert elements into num array.\n\n### Here is my implement:\n* #### Convert idea ( Runtime = O( len(num) ), Space = O( len(num) ) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # convert array num into string version\n        num_string = ''\n        for n in num:\n            num_string += str(n)\n\n        # add num and k, and convert it to string version\n        num_add_k_string = str(int(num_string) + k)\n\n        # convert result into array of int version\n        toReturn = [ int(i) for i in num_add_k_string ]\n        return toReturn\n```\n\n* #### carry k idea ( Runtime = O( len(num) ), Space = O(1) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # add k into the last digit of num, and check if there should be a carryOn number\n        num[-1] += k\n        if num[-1] < 10:\n            return num\n        # if no carryOn number, then just return num, otherwise, we keep adding carry on into previous digit and update carryOn\n        carryOn = num[-1]//10\n        num[-1] = num[-1]%10\n        index = -2\n        while carryOn != 0:\n            # when there are enough digits for us to add\n            if index >= -len(num):\n                num[index] += carryOn\n            # we need to insert new digit at the beginning of the array\n            else:\n                num.insert(0, carryOn)\n            carryOn = num[index] // 10\n            num[index] %= 10\n            index -= 1\n        return num\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916338863","body":"思路：\n历遍数组\n\nPython:\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n\n时间复杂度：O(N+max(0,K−N) \n空间复杂度：O(1)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jackielj":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916352332","body":"### LC 989. Add to Array-Form of Integer\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int fromNum = i >= 0 ? num[i] : 0;\n            int fromK = k % 10;\n            int val = fromNum + fromK + carry;\n            list.add(0, val % 10);\n            carry = val > 9 ? 1 : 0;\n            k = k / 10;\n            i--;\n        }\n        return list;\n    }\n}\n\n```\n### 时空复杂度：\n时间：O(Math.max(len(num), len(k.toString()))\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916354433","body":"### 思路\r\n从末位开始，向vector里添加各对应位置数字与进位之和。如原数组里各位置已加完，则需处理K中剩余数字与进位之和。\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int carry = 0;\r\n        vector<int> res;\r\n        for (int i = num.size() - 1; i >= 0; i--) {\r\n            res.push_back((carry + num[i] + k % 10) % 10);\r\n            carry = (carry + num[i] + k % 10) / 10;\r\n            k /= 10;\r\n        }\r\n        carry = carry + k;\r\n        while (carry) {\r\n            res.push_back(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N + logN + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。 \r\n- 空间复杂度：O(Max(1, K - N))，N为数组A的长度，K为K的长度。 ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916360004","body":"# 思路\r\n从后往前加，直到没有为止\r\n\r\n# 代码(Python3)\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        add1 = 0\r\n        add2 = 0\r\n        stop1Flag = False\r\n        stop2Flag = False\r\n        \r\n        resultStack = []\r\n        \r\n        k_int = list(map(int,str(k)))\r\n        \r\n        index = -1\r\n        while(True):\r\n            try:\r\n                add1 = num[index]                \r\n            except:\r\n                stop1Flag = True\r\n                add1 = 0\r\n                \r\n            try:\r\n                add2 = k_int[index]\r\n            except:\r\n                stop2Flag = True\r\n                add2 = 0\r\n            \r\n            index -= 1\r\n            \r\n            if(stop1Flag and stop2Flag):\r\n                if carry != 0:\r\n                    resultStack.append(carry)\r\n                break\r\n            else:\r\n                resultStack.append((add1 + add2 + carry)%10)\r\n                carry = (add1 + add2 + carry)//10\r\n        return (list(resultStack[::-1])\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(N + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。\r\n空间复杂度：O(Max(1, K + N))，N为数组A的长度，K为K的长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RonghuanYou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916378066","body":"按照加法的运算顺序从后往前遍历，r是余数，也就是做完加法后的当前位的值\nk是除去最后一位的值\n结束循环，如果k>0，就要一直处理最后的carry，就是k%10放入output array\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sumArr = []\n        for i in range(len(num) - 1, -1, -1):\n            r = (num[i] + k) % 10\n            k = (num[i] + k) // 10\n            sumArr.append(r)\n            \n        while k > 0:\n            sumArr.append(k % 10)\n            k = k // 10\n        return sumArr[::-1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916379125","body":"## Java代码\r\n\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Stack<Integer> stack = new Stack<>();\r\n        int borrow = 0;\r\n        int i = num.length - 1;\r\n\r\n        while (k != 0 || i >= 0 || borrow != 0) {\r\n            int currentNumber;\r\n           if (i >= 0 && k != 0) {\r\n                currentNumber = num[i] + k % 10;\r\n           } else if (i >=0) {\r\n               currentNumber = num[i];\r\n           } else {\r\n               currentNumber = k % 10;\r\n           }\r\n            stack.add((currentNumber + borrow) % 10);\r\n            borrow = (currentNumber + borrow) / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n\r\n        while (!stack.isEmpty()) {\r\n            res.add(stack.pop());\r\n        }\r\n        return res;\r\n    } \r\n```\r\n\r\n## 时间复杂度\r\n\r\nO(n)\r\n\r\n## 空间复杂度\r\n\r\nO(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916390741","body":"JAVA code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;\r\n        int index = A.length - 1;\r\n        while(K > 0 || index >= 0){\r\n            int curK = K % 10;\r\n            int curA = index >= 0 ? A[index]: 0;\r\n            int curDigitSum = curK + curA + carry;\r\n            int toBeAdded = curDigitSum % 10;\r\n            carry = curDigitSum / 10;\r\n            index --;\r\n            K /= 10;\r\n            res.addFirst(toBeAdded);\r\n        }\r\n        if(carry != 0){\r\n            res.addFirst(1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n);\r\nSpace: O(n);\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408530","body":"Python 3 code:\r\n     \r\n    class Solution:\r\n         def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n              if num[0] == 0 and k == 0:\r\n                 return [0]\r\n              inputnum = 0\r\n              for number in num:\r\n                   inputnum = inputnum * 10 + number\r\n              summ = inputnum + k \r\n              res = []\r\n              while summ > 0:\r\n                      digit = summ % 10\r\n                      res.append(digit)\r\n                      summ = summ // 10\r\n              return res[::-1]\r\n\r\nTime Complexity: O(n) because we run through the given array one time\r\nSpace Complexit: O(n) because we created a new array res to record the sum","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408891","body":"## 代码\nJava:\n```\n public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int i = num.length-1;\n        int carry = k;\n        while (i >= 0 || carry > 0) {\n            int n = i >= 0 ? num[i--] : 0;\n            carry += n;\n            list.add(carry % 10);\n            carry /= 10;\n        }\n        \n        Collections.reverse(list);\n        return list;\n    }\n```\nTime：O(n)     \nSpace：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409263","body":"# Solution1\n\nUse while loop to add K to num digit by digit. Maintain the carry and end the loop when carry is 0 and all digits from K has been added. Note that inserting to the list head is not efficient.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        while k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            if idx < 0:\n                num.insert(0, 0)\n                i = 0\n            else:\n                i = idx\n            tmp = num[i] + digit + carry\n            num[i] = tmp % 10\n            carry = tmp // 10\n            idx -= 1\n        return num\n```\n\nTime complexity: O(N + max(0, K - N)^2), K is length of k and N is length of num\n\nSpace complexity: O(max(1, K - N))\n\n# Solution2\n\nCreate another result array and always append the digit sum to the result end to avoid insert to head. Reverse the result list before return. The while loop end condition will also need to check if it has traversed all the num list.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        res = []\n        while idx >= 0 or k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            n = num[idx] if idx >= 0 else 0\n            res.append((n + digit + carry) % 10)\n            carry = (n + digit + carry) // 10\n            idx -= 1\n        return reversed(res)\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409706","body":"很笨的办法， 请忽略  \n时间复杂度 o(n),\n空间复杂度o(n)\n\n  `def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        n = len(num)\n        temp = 0\n        for i in range(n):\n            temp +=num[i]* (10**(n-1-i))     \n        b = temp + k\n        res = []\n        while b>9:\n            d = b%10\n            b = b//10\n            res.append(d)\n        res.append(b)\n        res.reverse()        \n        return res`\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916420802","body":"## Thinking\nassume  num length is n, k has m digits\n\nTake [1,2,3]+999 as an example\n\nFirst convert [1,2,3] into 123 which takes O(m)\n\nThen add 123 with 999 = 1122, which takes O(1)\n\nFinally convert 1122 to [1,1,2,2] which is O(max(m,n)+1)  = O(max(m,n)\n\n\n## Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        m = 0\n        for digit in num:\n            m = m * 10 + digit\n        sum_ = m + k\n        result = []\n        while sum_:\n            result.append(sum_ % 10)\n            sum_ //= 10\n        return result[::-1] if result else [0]\n\n```\n\n## Complexity\nTime: O(n)+O(1)+O(max(m,n) = O(m+n)\n\nSpace Complexity: O(max(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916424749","body":"**思路:**\r\n1. 数组num的第1个元素num[0]表示整数的最高位数字, 第n个元素num[n - 1]代表整数的个位数字\r\n2. 新的整数的每一位数字由三个部分决定：num[i], 整数k的当前位(k % 10), 进位(carry)->sum = val + k % 10 + carry\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(max(N, lgk))，N为数组num的长度, k为给定整数k\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n        int carry = 0, val = 0, sum = 0;\r\n        while (n >= 0 || k != 0) {\r\n            val = (n >= 0) ? num[n] : 0;\r\n            sum = val + k % 10 + carry;\r\n            res.push_back(sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        if (carry)\r\n            res.push_back(carry);\r\n        \r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916425383","body":"**Explanation**\r\n\r\n- Convert k to its array-form. \r\n- Add the array-forms of num and k by digit from the end to the beginning and save it in the result array. \r\n- Reverse the array-form of the result. \r\n\r\nUse the quotient and remainder divided by 10: set the current position as the remainder and update the quotient for the next position.\r\n\r\n**Python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        newK = []\r\n        for i in str(k):\r\n            newK.append(int(i))\r\n        \r\n        result = []\r\n        i, j = len(num)-1, len(newK)-1\r\n        quotient, remainder = 0, 0\r\n        while i >= 0 or j >= 0:\r\n            currI = num[i] if i >= 0 else 0\r\n            currJ = newK[j] if j >= 0 else 0\r\n            curr = currI + currJ + quotient\r\n            result.append(curr % 10)\r\n            quotient = curr // 10\r\n            i -= 1\r\n            j -= 1\r\n            \r\n        if quotient != 0:\r\n            result.append(quotient)\r\n        return result[::-1]\r\n```\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: ```O(max(N, logk))``` where N is the length of the ```num``` array.\r\n- Space Complexity: ```O(max(N, logk))``` \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916426832","body":"## Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n \r\n## Python\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\n```\r\n\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZhuMengCheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916429301","body":"思路:\r\n从末尾相加后截取末尾存储进位,, 测试用例: [2,1,5]  806  \r\n 比如806和5相加等于811 ,保存末尾1,\r\n继续相加为81+1=82. 保存2 类推,\r\n 8会和下一个2相加为10,  \r\n整个数组的值变成[10,2,1] 截取10的情况,可能计算次数超过数组长度.需要添加额外条件判断计算次数\r\n`/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = []\r\n    // k>0 如果遇到合为10需要多一次计算 ,查询条件不能限制为只有num数组的长度\r\n    for(let i = num.length-1 ;i>=0 || k > 0;--i){\r\n        // 大于0的位数直接相加后取余数进位\r\n        if(i >= 0){\r\n            k += num[i]\r\n        }\r\n        res.push(k % 10)\r\n        // 计算是否有等于10 或者大于0的情况,在执行下次进位\r\n        k  =   (k - k  % 10) / 10\r\n    }\r\n    return res.reverse()\r\n}`\r\n\r\n时间复杂度：O(max(n,log k))\r\n空间复杂度:  O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lllouiselao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916434574","body":"[989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n#### 想法：最brutal way： traverse list->str->int->list \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        str_turple = ''\n        for i in num:\n            str_turple += str(i)\n\n        str_int = int(str_turple) + k\n        int_str = str(str_int)\n\n        output = []\n        for n in int_str:\n            output.append(int(n))\n        return output\n```\n#### complexcity O(n^2) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916452724","body":"### 思路: \n\nFirst, we should convert k to list and iterate from back of the list. If the sum of two digits at the same position plus carry is greater than 10, then we set the carry to 1. The modulo of the sum is the result at that position. \n\n### 代码：\n```\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n**复杂度分析**\n\nTime Complexity: O(n) n is the largest length of two numbers\n\nSpace Complexity: O(n) \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481597","body":"## Java\n#### 解题思路\n+ 整型数组开始与k相应的位上的数字相加（从个位开始，整型数组的个位是num[num.length-1]），并将每位上相加的结果添加到一个整型的Array数组中。\n+ 这里需要注意如果相对应位置上的数相加大于10时，我们应该有进位操作，即 让k+1，number-10（ps：这里的number代表整型数组与k的相应位置上的数相加后得到的结果）\n+ 最后如果k>0,这说明最高位上有进位，最后得到的数组少最高位，我们应该再把k的每个位置的数取出来加入到数组中。\n+ 由于低数位先加入我们最终得到的Array数组中，所以我们需要翻转一下得到的数组，在java中可以调用Collections.reverse()函数来实现。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        List<Integer> resultList = new ArrayList<>();\n        int sum =0;\n        for(int i=len-1;i>=0;i--){\n            sum = num[i]+k%10;\n            k=k/10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            resultList.add(sum);\n        }\n        while(k>0){\n            resultList.add(k%10);\n            k=k/10;\n        }\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n#### 时间复杂度\nO(n)\n#### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481742","body":"### 思路\r\n convert a list of integers into a number\r\n update this number by adding k \r\n convert back the result into a list of integers\r\n### 代码\r\n```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        for n in num:\r\n            num_str += str(n)\r\n        output = []\r\n        for n in str(int(num_str) + k):\r\n            output.append(int(n))\r\n        return output\r\n```\r\n**复杂度分析**\r\nTime Complexity：O(n)\r\nSpace Complexity：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916499894","body":"\n\n\n## 思路\n- 把K按照位转换成vector。则求解方法和求解两个vector 数相加相同，从后往前遍历。注意carry。时间复杂度 k的位数N，A的位数位M, O(N) + O(max(N,M)) 空间复杂度为 O(N + max(N,M)) \n\n\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        vector<int> veck;  \n        while(k)\n        {\n            veck.push_back(k%10);\n            k =k /10; \n        }\n        bool next = false; \n        int left =num.size()-1; \n        int right =0; \n        vector<int> ret; \n        while(left>=0 && right < veck.size())\n        {\n            int sum = num[left] + veck[right] + (next? 1:0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--; \n            right++; \n        }\n        while(left>=0)\n        {\n            int sum = num[left] + (next? 1:0); \n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--;                 \n        }\n        while(right < veck.size())\n        {\n            int sum = veck[right] + (next? 1 : 0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            right++;             \n        }\n        if(next)\n            ret.push_back(1);\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916507442","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    ans = [];\r\n    while(i >= 0 || k != 0) {\r\n      sum = carry;\r\n      if (i >= 0) {\r\n        sum += num[i];\r\n        i--;\r\n      }\r\n      if (k != 0) {\r\n        sum += k % 10;\r\n        k = Math.floor(k / 10);\r\n      }\r\n\r\n      carry = Math.floor(sum / 10);\r\n      ans.unshift(sum % 10);\r\n    }\r\n\r\n    if (carry > 0) {\r\n      ans.unshift(carry);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。 k <= 10^4 不计\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916511474","body":"JS 占坑\r\n其实可以用力扣第二题（两数之和） 类似的解法\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for (let i = num.length - 1; i >= 0 || k > 0; i--) {\r\n\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n\r\n        res.push(k % 10); // 当时个位上的数\r\n        k = (k - k % 10) / 10;\r\n    }\r\n\r\n    return res.reverse();\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916531466","body":"思路：\n1.数组从个位开始[即从后往前计数]，用一个sum保存位和[加数+被加数+低位进位],一个pre保存进位\n重新设置一个输出数组out。\n2.数组从后往前遍历，每位与k%10相加、与低位进位相加，获得sum 。 sum%10加入数组，sum/10为进\n位值，运算完记得把k/10.\n3.若数组跑完k还有值或进位有值，则再跑一遍循环处理完剩余的数据\n4.最后对整个数组首尾交换即可\n代码：\n```Go\nfunc largestRectangleArea(heights []int) int {\n    stack := []int{}\n    N := len(heights)\n    st, result := make([]int,N+2), 0\n    for i:=0; i< N+2;i++{\n        if i == 0 || i == N+1{\n            st[i] = 0\n        }else{\n            st[i] = heights[i-1]\n        }\n    }\n    for i:=0; i < N+2;i++{\n        for len(stack) > 0 &&st[i] < st[stack[len(stack)-1]]{\n            mid := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            w := i - stack[len(stack)-1] - 1\n            h := st[mid]\n            result = max(result, w*h)\n        }\n            stack = append(stack, i)\n    }\n    return result\n}\n\nfunc max(x, y int) int{\n    if x > y{\n        return x\n    }else{\n        return y\n    }\n}\n```\n时间复杂度：O(n)\n空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534184","body":"### 解题思路\n因为数组num的长度太大，会越界，所以每一数位单独运算。把k先用字符串方法转换为各个数位的数组。用`carry`记录进位，每一个对应数位进行加法运算，结果存到链表头部。注意循环结束后再查看一下最终进位`carry`是否为0，不为0的话存到链表中。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        String str = String.valueOf(k); // Convert k to string, can also use Integer.toString(k)\n        String[] elements = str.split(\"\"); // Get individual digits as String format\n        int klen = elements.length;\n\n        int carry = 0;\n        LinkedList<Integer> result = new LinkedList<>();\n        int nlen = num.length;\n        int length = nlen > klen ? nlen : klen;\n\n        for (int i = 0; i < length; i++) {\n            int knum = i < klen ? Integer.parseInt(elements[klen - 1 - i]) : 0;\n            int cur = nlen - 1 - i;\n            int n = i < nlen ? num[cur] : 0;\n            result.addFirst((n + knum + carry) % 10);\n            carry = (n + knum + carry) / 10;\n        }\n\n        if (carry != 0) result.addFirst(carry);       \n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(n), 创建链表储存结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZJP1483469269":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534668","body":"#### 思路\n对数组与k进行按位加 保留进位位，并与下一位的k和数组相加 最后判断k是否加完，若没有则直接加进队列\n#### 代码\n    class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int c=0;\n        int a=0;\n        LinkedList<Integer> ans = new LinkedList<>();\n        for(int i=len-1;i>=0;i--){\n            a = (num[i] + k%10 + c )%10;\n            c = (num[i] + k%10 + c)/10;\n            k = k/10;\n            ans.addFirst(a);\n        }\n        if(c!=0){\n            k=k+c;\n        }\n        if(k!=0){\n            while(k!=0){\n                ans.addFirst(k%10);\n                k/=10; \n            }\n        }\n        return ans;\n    }\n}; \n\n####复杂度分析\n时间复杂度：O(n) n为数组长度\n空间复杂度：O(n) n为数组长度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916536901","body":"## 思路\r\n\r\n+ 当前位 = 数字A + 数字B + 进位\r\n+ 利用 k 作为进位和数字B的和\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int size = num.size(), sum = 0;\r\n        for (int i = size - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            result.push_back(k % 10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 空间复杂度 `O(n)`\r\n+ 时间复杂度`O(max(n, logk))`\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916539064","body":"## 989. Add to Array-Form of Integer\n\nThe **array-form** of an integer `num` is an array representing its digits in left to right order.\n\n- For example, for `num = 1321`, the array form is `[1,3,2,1]`.\n\nGiven `num`, the **array-form** of an integer, and an integer `k`, return *the **array-form** of the integer* `num + k`.\n\n**Example 1:**\n\n```\nInput: num = [1,2,0,0], k = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n```\n\n## Note\n\n1. O(n), O(n), `n is max(n.length,k.digitsNum)`\n   1. **From right to left**, pick the digits from the num array and k to construct the result array; Reverse the result array when returning.\n   2. CurrentValue is comprised of value from num, k and carry;Keep running the loop **as long as there is a value in num, k or carry**;\n2. Problems:\n   1. The num array could be too big to perform normal addition which leads to a totally wrong answer. \n   2. The summation of num array could be less than k which means that we may run out of the num array first.\n   3. Never forget carry.\n   4. The division in JS won’t give you an Int, please use `Math.floor()`.\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res=[];\n    let carry=0;\n    let rightIndex=num.length-1;\n    \n    while(rightIndex>=0 || k>0 || carry>0){\n        let currentSum=rightIndex>=0?num[rightIndex]+carry+ k%10:carry+ k%10;\n        k=Math.floor(k/10);\n        carry=Math.floor(currentSum/10)\n        res.push(currentSum%10);\n        rightIndex--;\n    }\n  \n    return res.reverse();\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916540032","body":"```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const res = [];\n    let carry = 0;\n    num.reverse();\n    const strK = String(k).split('').reverse().join('');\n    const maxLen = Math.max(num.length, strK.length)\n    for (let index = 0; index < maxLen; index++) {\n        let value = Number(strK[index] ? strK[index] : 0) + (num[index] ? num[index] : 0) + carry;\n        if (value >= 10) {\n            value %= 10;\n            carry = 1\n        } else {\n            carry = 0\n\n        }\n        res.push(value);\n    }\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916541347","body":"### 代码\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        num_k = []\n        while k > 0:\n            num_k.insert(0, k%10)\n            k = k // 10\n        l, lk = len(num), len(num_k)\n        if l < lk:\n            num, num_k = num_k, num\n            l, lk = lk, l\n        carry = 0\n        for i in range(max(l, lk)):\n            s = carry\n            l_idx, lk_idx = l-i-1, lk-i-1\n            s += num[l_idx]\n            if lk_idx >= 0:\n                s += num_k[lk_idx]\n            if s >= 10:\n                carry = s // 10\n                s = s % 10\n            else:\n                carry = 0\n            num[l_idx] = s\n        if carry > 0:\n            num.insert(0, carry)\n        return num\n```\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916548236","body":"##  当前的问题：\r\n\r\n### 题目 run 的时候被 accept 了，但是 submit 的时候说是答案是错的。新手不知道该怎么改进。先把卡打了再说。如果有大佬看到，可以指点迷津吗？谢谢。我会继续改进。\r\n\r\n##  思路: \r\n\r\n- 先把当前 array 中转 string 再转回 integer, numInt；\r\n- 把 numInt 和 k 加起来成和, sum；\r\n- 利用 sum 除以 10 的余数来加入到新 array 的尾部\r\n\r\n## 代码 Javascript \r\n\r\n```\r\nconst addToArrayForm = function(num, k) {\r\n    const numInt = parseInt(num.join(''));\r\n    let sum = numInt + k;\r\n    const resultArray = [];\r\n    while (sum >= 0) {\r\n           let el = sum % 10 ;\r\n           sum = Math.floor(sum / 10);\r\n           resultArray.splice(0, 0, el);\r\n           }\r\n    return resultArray;\r\n```\r\n\r\n##  复杂度分析\r\n\r\n时间与空间均为 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916558714","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length-1;\n        while(i>=0||k>0){\n            if(i>=0){\n                k +=num[i];\n            }\n            list.addFirst(k%10);\n            k /= 10;\n            i--;\n        }\n        return list;\n    }\n}\n复杂度分析：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559464","body":"两个思路：\n\n1.将数组元素转化为数字，然后数字相加，返回数组【但是，数字表示范围容易超限】\n\n2.按位相加\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        long long n = 0;\n        for (int i = 0; i < num.size(); ++i)\n        {\n            n = n * 10 + num[i];\n        }\n        n += k;\n        vector<int>res;\n        if(n==0) return {0};\n        while (n != 0)\n        {\n            res.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n超出数字表示范围\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        int i = num.size()-1;\n        vector<int>res;\n        while(i>=0)\n        {\n            int temp = num[i] + k;\n            res.push_back(temp%10);\n            k = temp/10;\n            i--;\n        }\n        while(k>0) {\n\t\t\tres.push_back(k%10);\n\t\t\tk/=10;\n\t\t}\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n时间复杂度O（N）\n\n空间复杂度O（N）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559576","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n## S1: 逐位相加\r\n\r\n将数字逐位相加，从低位到高位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        int carry = 0;\r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int a = i >= 0 ? num[i--] : 0;\r\n            int b = k > 0 ? k % 10 : 0;\r\n            k /= 10;\r\n            int sum = a + b + carry;\r\n            ans.push_back(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$，N 是 num 的长度，logk 是 k 的位数。进行逐位相加以及最后 reverse 数组的时间分别都是 $O(max(N,logk))$。\r\n- ***Space:** $O(1)$，*除返回值外，使用的是常数空间。\r\n\r\n## S2: 相加\r\n\r\n将 k 从低位到高位直接加到数组的每一位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        while (i >= 0 || k > 0) {\r\n            k += i >= 0 ? num[i--] : 0;\r\n            ans.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$\r\n- ***Space:** $O(1)$*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916561783","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        # if k is 0, do an early return\r\n        if k == 0:\r\n            return num\r\n        # convert the array into an integer\r\n        temp = 0\r\n        for i in range(len(num)):\r\n            temp = temp * 10 + num[i]\r\n        # get the updated integer\r\n        temp = temp + k\r\n        # convert it back to an array by appending digits of the integer backwards to the result array\r\n        result = []\r\n        while temp > 0:\r\n            result.append(temp%10)\r\n            temp = temp // 10\r\n        return result[::-1]\r\n\r\n\r\ntime: O(n) - n is the length of num\r\nspace: O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916563357","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n\r\n### 官方求解方法\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        result1=[]\r\n        for i in range(len(num)-1,-1,-1):\r\n            r1=num[i]+k%10\r\n\r\n            remain1=k//10+r1//10\r\n            if r1>=10:\r\n                r1=r1%10\r\n            result1.insert(0,r1)\r\n            k=remain1\r\n        if k>0:\r\n            while k:\r\n                result1.insert(0,k%10)\r\n                k=(k-k%10)//10\r\n        return result1\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n### 字符串求解\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        str1=''\r\n        for num1 in num:\r\n            str1+=str(num1)\r\n        result1=int(str1)+k\r\n        return [int(s1) for s1 in str(result1)]\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiQAQ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566326","body":"### 一位一位相加即可\n````java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int x = 0;\n        LinkedList<Integer> list = new LinkedList<>();\n        for (int i = 0; i < num.length; i++) {\n            int num1 = num[num.length - i - 1];\n            int num2 = k % 10;\n            k /= 10;\n            int sum = num1 + num2 + x;\n            if(sum >= 10) {\n                sum = sum - 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(sum);\n        }\n        while (k > 0 || x == 1) {\n            int num1 = k % 10 + x;\n            k /= 10;\n            if(num1 >= 10) {\n                num1 -= 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(num1);\n        }\n\n        return list;\n    }\n}\n````\n### 复杂度分析\n时间复杂度: O(max(n, logk))\n空间复杂度: O(max(n, logk)) 存储需要返回的结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566437","body":"## 思路\r\n\r\n---\r\n\r\n从数组末尾（个位）开始，逐位相加，并计算进位，因为是从低位开始计算，每次结果都要添加到结果数组的头部\r\n\r\n## 代码：JavaScript\r\n\r\n---\r\n\r\n```JavaScript\r\nvar addToArrayForm = function(num, k) {\r\n    const ans = [];\r\n    let carry = 0;\r\n    let cur;\r\n    let Addres;\r\n    let item;\r\n    let pos = num.length - 1;\r\n    do {\r\n        cur = k % 10;\r\n        k = ~~(k / 10); // ~~ 用于下取整\r\n        item = num[pos] ?? 0;\r\n        Addres = (cur + carry + item) % 10;\r\n        carry = ~~((cur + carry + item) / 10);\r\n        ans.unshift(Addres);\r\n        --pos;\r\n    } while( (k || carry) || pos >= 0)\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n---\r\n\r\n- 时间复杂度： `O(n + logk)`  n 为输入数组长度，k为非负整数大小\r\n\r\n- 额外空间复杂度： `O(1)`  \r\n\r\n## 标签\r\n\r\n---\r\n\r\n`数组` , `模拟`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568209","body":"### 思路：\n\n和链表相加一样，while后面的条件是 || 然后循环里面再去判断\n\n### 代码：\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)\n        i=n-1\n        res=[]\n        carry=0\n        while i>=0 or k!=0  or carry:\n            temp=0\n            if(i>=0):\n                temp+=num[i]\n                i-=1\n            if(k!=0):\n                temp+=k%10\n                k//=10\n                \n            res.append((temp+carry)%10)\n            carry=(temp+carry)//10\n        return res[::-1]\n```\n\n### 时间复杂度\n\nO(max（n，log(k)）) n为数组长度\n\n拓展一下链表加法\n\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        p=ListNode(0)\n        head=p\n        carry=0\n        while (l1 or l2 or carry):\n            if l1:\n                carry+=l1.val\n                l1=l1.next\n            if l2:\n                carry+=l2.val\n                l2=l2.next\n            p.next=ListNode(carry%10)\n            p=p.next\n            carry=carry//10\n        return head.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568816","body":"## Problem\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n## Notes\n- Cannot solve the problem by converting `num` to int then do the addition and convert it back to int array. Because `1 <= num.length <= 104` and Integer.MAX_VALUE is smaller than that, the conversion or addition will cause overflow.\n- When doing addition, need to consider when the sum is larger than `9`, need to do the `k++` and `sum -= 10` to carry `1`, after `k /= 10`.\n- The length of `num` may be shorter than the length of `k`, the first loop condition should use the length of `num`. Use the second loop to convert the remain of `k`.\n- The length of `num` may be longer than the length of `k`, since `k%10` and `k/10` will be always 0 after `k` becomes 0, so it's ok to use the length of `num` in the first loop.\n- The original length of ArrayList is `10`, and the solution can always add the new digit at index 0 of the List, perhaps using LinkedList as the returned List would have better performance.\n\n## Solution\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k%10;\n             k /= 10;\n            if(sum > 9){\n                k++;\n                sum -= 10;\n            }\n            result.add(0, sum);\n        }\n        while(k > 0){\n            result.add(0, k%10);\n            k /= 10;\n        }\n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: The solution processes each element of `num` and each digit of `k`. So it's O(max(n, `the number of digits of k`)). And the `the number of digits of k` is `logk` (https://brilliant.org/wiki/finding-digits-of-a-number/). So it's O(max(n, logk)) (n is the length of `num`).\n- Space: Except the returned List, the extra space used is O(1).","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916569778","body":"### 代码\n```python \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A_list = [str(i) for i in num ]\n        A_number = int(''.join(A_list))\n        result_number = A_number + k\n        result = [int(i) for i in str(result_number)]\n        return result\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571164","body":"## day 1\n\n简单粗暴的解法：\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for number in num:\n            n = n * 10 + number\n        return [int(ch) for ch in str(k + n)]\n```\n复杂度：`O(n)`\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571254","body":"# 989.数组形式的整数加法\n\n## 思路：\n\n首先的思路是：\n\n1. 遍历数组整合成整数\n2. 与k值相加\n\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n思考缺点：\n\n1. 对数据不敏感\n2. 思考不完整\n3. 读题不明确就上手做\n\n## 代码段：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n无嵌套,除返回值以外，操作空间为O(1)\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)\n\n如果解释有所错误，欢迎朋友指正，感谢！\n\n## ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916573727","body":"## 思路\r\n- k 添加到末尾\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        \r\n        return res[::-1]\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575375","body":"# 思路\n- 把k转数组，变成两个数组相加\n- 生成res数组。长度要比num 和 kArr 最大长度 + 1\n- 个位数相加，添加到res 数组\n- 判断进位carry，返回结果\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  var l1 = num.length - 1;\n  var kArr = String(k).split('');\n  var l2 = kArr.length - 1;\n  var resLen = (l1 > l2 ? l1 : l2) + 1;\n  var res = new Array(resLen + 1).fill(0);\n  var carry = 0;\n\n  while (l1 > -1 || l2 > -1) {\n    var val1 = l1 > -1 ? num[l1] : 0;\n    var val2 = l2 > -1 ? kArr[l2] : 0;\n\n    var sum = val1 + Number(val2) + carry;\n    var carry = Math.floor(sum / 10);\n    res[resLen] = Math.floor(sum % 10);\n\n    resLen--;\n    if (l1 > -1) l1--;\n    if (l2 > -1) l2--;\n  }\n\n  if (carry) {\n    res[resLen] = carry;\n  } else {\n    res.shift();\n  }\n  return res;\n};\n```\n# 复杂度分析\nN是数组nums的长度，K是数字k的长度\n- 时间复杂度  O(max(N,K) + shift) shift 是数组删除第一个元素\n- 空间复杂度 O(max(N,K)+1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575768","body":"### 思路\n列表转成数值，加上k，然后倒着一位一位加到列表，然后反转列表\n### 代码（Python3）\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        inta = 0\n        for i in A:\n            inta = inta*10 + i\n        inta = inta+K\n        res = []\n        while inta!=0:\n            res.append(inta%10)\n            inta//=10\n        if not res:\n            res.append(0)\n        return res[::-1]\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Toms-BigData":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916577408","body":"# 思路\n将数组中的数字转化为字符拼接成字符串，将字符串转化为int类型与K相加后再次转化为字符串，通过list()和map()函数将字符串拆分成int数组\n# 代码：Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = \"\".join('%s' %id for id in num)\n        num_data = str(int(num_str) + k)\n        return list(map(int,num_data))\n# 时间复杂度\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916579966","body":"# **思路**\n\n从低位开始相加，大于10就进位\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public List<Integer> addToArrayForm(int[] num, int k){\n        List<Integer> res = new ArrayList<Integer>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                //进一位\n                k++;\n                //减去10才是需要的数\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n\n        /**\n         * 如果k位数比数组多\n         */\n        for(; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n\n        //链表反转\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(max(n, logk))，如果n>k，那么复杂度就是O(n)，如果k比n大，那么复杂度就是O(logk)\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580190","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间复杂度: O(Max(n, k))\r\n* 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"TimmmYang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580399","body":"## 思路\n从低到高逐位相加。如果k的位数比X多，就继续执行一遍。可以把两个循环合并，给结果单开一个list逆序返回。\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            summ = num[i] + k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num[i] = summ\n        if carry == 1 and k == 0:\n            num.insert(0, 1)\n            return num\n        while k != 0:\n            summ = k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num.insert(0, summ)\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n```\n## 复杂度\n时间：O(max(n, log(k)))，n为num长度\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnhTom2000":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916581198","body":"## 思路\r\n遍历数组并且拆分k进行诸位相加，过程中注意如果两者的和超过了个位数，需要累计进位。\r\n## Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int i = num.length - 1;\r\n        while( i >= 0 || k > 0){\r\n          if( i >= 0){\r\n          int sum = num[i] + k % 10;\r\n          k/=10;\r\n          if(sum >=10){\r\n            k++;\r\n            sum-=10;\r\n          }\r\n          list.addFirst(sum);\r\n          i--; \r\n        }else {\r\n          list.addFirst(k%10);\r\n          k/=10;\r\n        }\r\n      }\r\n        return list;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：`O(n+logk)`,n为数组长度\r\n空间复杂度：`O(max(n,k))`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}