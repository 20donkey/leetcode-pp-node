{"577961141":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085986299","body":"## 题目思路\n解法一：假如，需要计算的数组为[1,2,3]和数字1095；首先向1095取余（以10），那么得到5再和数组3相加，得到8，将结果加入到新的数组；再将1095向下取整，再取余，得到9，在和数组的2相加，会发现得到的结果超过了10，那么就要将结果减10后加入新的数组，109还需要加一。重复以上步骤即可。\n\n解法二： 假如，需要计算的数组为[1,2,3]和数字1095；我们可以直接向1095加上数组的末尾的数，即1095+3然后取余，得到8，加入到新的数组中去，一直重复这个步骤即可。\n\n## 题目的题解code\n解法1：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $remainder = $k % 10;\n            $addVal = $remainder + $num[$i];\n\n            if ($addVal >= 10) {\n                $addVal = $addVal % 10;\n                $k = floor($k /10) + 1;\n            }else {\n                $k = floor($k /10);\n            }\n            $res[] = $addVal;\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n解法2：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $k = $num[$i] + $k;\n            $res[] = $k % 10;\n            $k = floor($k / 10);\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(max(n,logk)),其中n为数组的长度，k为数值的长度\n空间复杂度：O(1),除了返回值之外，其余全是常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086643481","body":"## 题目思路\n1. 先遍寻左边，记录上一次字符C出现的位置```prev```,那么答案就是```i-prev```\n2. 再遍寻右边，记录上一次字符C出现的位置```prev```,那么答案就是```prev-i```\n3. 最后比较相同位置的数值，谁小取谁\n\n## 题目的题解code\n```PHP\n<?php\n\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $c\n     * @return Integer[]\n     */\n    function shortestToChar($s, $c) {\n        $ans = [];\n        $len = mb_strlen($s);\n\n        // 计算左边\n        $prev = PHP_INT_MIN / 2;\n        for ($i = 0; $i < $len; $i++) {\n            if ($s[$i] == $c) {\n                $prev = $i;\n            }\n\n            $ans[] = $i - $prev;\n        }\n\n        // 计算右边\n        $prev = PHP_INT_MAX / 2;\n        for ($j = $len - 1; $j >= 0; $j--) {\n            if ($s[$j] == $c) {\n                $prev = $j;\n            }\n\n            $ans[$j] = min($ans[$j], $prev - $j);\n        }\n\n        return $ans;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度： O(N),N是字符串的长度，我们需要遍历两次\n空间复杂度： O(N),ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858899","body":"## 题目思路\n额。思路没有挺简单的\n\n## 题目的题解code\n```PHP\n<?php\n\nclass CustomStack {\n    public $maxSize;\n    public $stack = [];\n    /**\n     * @param Integer $maxSize\n     */\n    function __construct($maxSize) {\n        $this->maxSize = $maxSize;\n    }\n\n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        if  (count($this->stack) < $this->maxSize) {\n            array_push($this->stack, $x);\n        }\n\n        return null;\n    }\n\n    /**\n     * @return Integer\n     */\n    function pop() {\n        if (count($this->stack) <= 0) {\n            return -1;\n        }\n\n        return array_pop($this->stack);\n    }\n\n    /**\n     * @param Integer $k\n     * @param Integer $val\n     * @return NULL\n     */\n    function increment($k, $val) {\n        for ($i = 0; $i < $k && $i < count($this->stack); $i++) {\n            $this->stack[$i] += $val;\n        }\n\n        return null;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * $obj = CustomStack($maxSize);\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $obj->increment($k, $val);\n */\n```\n\n## 时间和空间复杂度\n时间复杂度：所有操作的渐进时间复杂度均为O(1)。\n空间复杂度：这里用到了两个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为O(maxSize)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087609034","body":"## 题目思路\n用栈的方式进行题解\n1. 将`数字`、`字母`、`[`一个一个加入到栈中；\n2. 如果遇到`]`,就从栈中取出字母，直到遇到`[`\n3. 将`[`去掉，然后从栈中取出数字（判断是否为数字，因为可能有多个）\n4. 重复这些字母\n5. 重复上面的步骤\n\n## 题目的题解code\n```PHP\nclass Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function decodeString($s) {\n        $stack = [];\n        for ($i = 0; $i < mb_strlen($s); $i++) {\n             if ($s[$i] === \"]\") {\n                 $repeatStr = \"\";\n                 $repeatCount = \"\";\n\n                 while ($stack && end($stack) !== \"[\") {\n                     $repeatStr = array_pop($stack).$repeatStr;\n                 }\n\n                 // 去掉[\n                 array_pop($stack);\n\n                 while ($stack && is_numeric(end($stack))) {\n                     $repeatCount = array_pop($stack).$repeatCount;\n                 }\n\n                 $repeatStr = str_repeat($repeatStr, (int)$repeatCount);\n                 array_push($stack, $repeatStr);\n            } else {\n                 array_push($stack, $s[$i]); // 加入栈中\n             }\n        }\n        return implode('', $stack);\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 为解码后的 s 的长度。\n空间复杂度：O(N)，其中 N 为解码后的 s 的长度。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090131592","body":"## 题目思路\n贪心算法\n\n\n## 题目的题解code\n```GOLANG\nfunc maxChunksToSorted(arr []int) int {\n    // 排序后，对两个数组进行diff，偏移量为0时，表示可以分块\n\tb := append([]int{}, arr...)\n\tsort.Ints(b)\n\n\tret := 0\n\tdiff := 0\n\tm := map[int]int{}\n\tfor i := 0; i < len(arr); i++ {\n\t\tm[b[i]]++\n\t\tif m[b[i]] > 0 { //该数拉开了两个数组的差距，正向偏移（偏向b数组）\n\t\t\tdiff++\n\t\t} else { // 抵消了arr数组的偏移\n\t\t\tdiff--\n\t\t}\n\n\t\tm[arr[i]]--\n\t\tif m[arr[i]] < 0 { //该数拉开了两个数组的差距，负向偏移（偏向arr数组）\n\t\t\tdiff++\n\t\t} else { // 抵消了b数组的偏移\n\t\t\tdiff--\n\t\t}\n\n\t\tif diff == 0 {\n\t\t\tret++\n\t\t}\n\t}\n\treturn ret\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(N^2)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091636667","body":"## 题目思路\n算法：快慢指针\n\n思路：\n1. 快指针与慢指针都以每一步一个节点的速度向后遍历\n2. 快指针比满指针先走K步\n3. 当快指针到达终点时，慢指针正好是倒数第K个节点\n\n伪代码：\n```PHP\n快指针 = 慢指针 = $head;\n\nwhile(快指针->next) {\n    if ($k-- <= 0) {\n        慢指针 = 满指针-> next;\n    }\n    快指针 = 快指针->next;\n}\n```\n\n经过这样的处理，我们旋转了一位，而题目是要旋转 k 位，实际上我们只需要将上面的算法微调即可。将 1 改成 k ， 2 改成 k + 1。\n\n算法描述：\n\n获取单链表的倒数第 k 与倒数第 k + 1 个节点\n\n将倒数第 k + 1 个节点的 next 指向 null\n\n将尾节点 next 指向 head（拼起来）\n\n返回倒数第 k 个节点\n\n例如链表 A -> B -> C -> D -> E 右移 2 位，依照上述步骤为：\n\n获取节点 C 与 D\n\nA -> B -> C -> null, D -> E\n\nD -> E -> A -> B -> C -> nul\n\n返回节点 D\n\n注意：假如链表节点长度为len，则右移K位与右移k%len效果是一样的，就像环形跑道为1000米，你跑100米和1100米是一样的位置\n\n伪代码如下：\n\n```PHP\n获取链表的长度\nk = k % 链表的长度\n获取倒数第K+1，倒数第K个节点与链表尾节点\n倒数第k+1节点.next = null\n链表尾节点.next = head\nreturn 倒数第k个节点\n```\n\n## 题目的题解code\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function rotateRight($head, $k) {\n        if (!$head || !$head->next) return $head;\n        // 获取链表的长度\n        $count = 0;\n        $now = $head;\n        while ($now) {\n            $count++;\n            $now = $now->next;\n        }\n\n        // 获取实际上的$k\n        $k = $k % $count;\n\n        // 快指针获取链表的倒数第一个节点；慢指针获取倒数K+1个指针\n        $slow = $fast = $head;\n\n        while($fast->next) {\n            if ($k-- <=0) {\n                $slow = $slow->next;\n            }\n            $fast = $fast->next;\n        }\n\n        $fast->next = $head;\n        $res = $slow->next;\n        $slow->next = null;\n        return $res;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 链表的长度。\n空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092898594","body":"### 迭代\n\n假如原始链表为preA->A->B->nextB,我们需要修改为preA->B->A->nextB,接下来的元素按照这个逻辑交换就行\n\n那么修改指针的顺序为\n\n1. A节点的next指向nextB:\n> preA->A->nextB\n> \n> B->nextB\n\n2. B节点的next指向A\n>preA->A->nextB\n> \n> B->A\n\n3. preA->节点的next指向B\n> preA->B->A->nextB\n\n伪代码：\n```PHP\n$A.next = next.B;\n$B.next = $A;\npreA.next = B;\n```\n\n我们可以创建一个preHead，让其next指针指向A。\n\n## 题目的题解code\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function swapPairs($head) {\n        if (!$head || $head->next == null) { //为空或者只有一个节点\n            return $head;\n        }\n\n        $prevNode = new ListNode();// 前置节点\n        $prevNode->next = $head; // 前置节点的指针等于第一个节点\n        $oneNode = $head; // 第一个节点\n        $res = $oneNode->next; // 返回的结果（第二个节点就是要返回的节点）\n        while ($oneNode && $oneNode->next != null) { // 当前节点有值且有下一个节点\n            $twoNode = $oneNode->next; // 获取第二个节点\n            $afterPointer = $twoNode->next; // 第二个节点的指针\n\n            $oneNode->next = $afterPointer; // 第一个节点的下一个指针指向第二个节点的下一个指针\n            $twoNode->next = $oneNode; // 第二个节点的指针指向第一个节点\n            $prevNode->next = $twoNode;// 前置的指针改成是第二节点\n\n            $prevNode = $oneNode; // 前置节点等于第一个节点\n            $oneNode = $afterPointer; // 第一各节点修改为第二个节点的指针\n        }\n        return $res;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 链表的长度。\n空间复杂度：O(1),没用到额外空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094010940","body":"## 题目思路\n\n### 解法一：快慢指针\n1. 获取当前链表的中点\n2. 以链表中点为根\n3. 中点左边的值都小于它，可以构造左子树\n4. 同理构造右子树\n5. 循环第一步\n\n具体： \n1. 定义一个快指针和一个慢指针，快指针步数为2，慢指针步数为1\n2. 当快指针到达尾部的时候，慢指针正好指到的点为中点\n\n### 解法二： 缓存法\n1. 以空间换时间，用一个数组存储链表的节点\n2. 然后去数组的中间点建立树\n3. 左右两边的子树按照这个方式遍寻\n\n## 题目的题解code\n### 解法一\n```PHP\n<?php\n\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param ListNode $head\n     * @return TreeNode\n     */\n    function sortedListToBST($head)\n    {\n        if (!$head) {\n            return null;\n        }\n        return $this->dfs($head, null);\n    }\n\n    /**\n     * @param ListNode $head 头结点\n     * @param ListNode $tail 尾节点\n     * @return TreeNode|null\n     */\n    private function dfs($head, $tail)\n    {\n        if ($head == $tail) { // 这个的作用是头尾节点相等的时候就不用遍寻了，说明就没有了\n            return null;\n        }\n\n        $fast = $head; // 快指针\n        $slow = $head; // 慢指针\n        while ($fast != $tail && $fast->next != $tail) { // 兼容奇数和偶数\n            $fast = $fast->next->next;\n            $slow = $slow->next;\n        }\n        $root = new TreeNode($slow->val);\n        $root->left = $this->dfs($head, $slow);\n        $root->right =$this->dfs($slow->next, $tail);\n\n        return $root;\n    }\n}\n```\n\n### 解法二\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param ListNode $head\n     * @return TreeNode\n     */\n    function sortedListToBST($head)\n    {\n        $res = [];\n        while ($head) {\n            $res[] = $head->val;\n            $head = $head->next;\n        }\n        return $this->dfs($res, 0, count($res) - 1);\n    }\n\n    private function dfs($res, $l, $r)\n    {\n        if ($l > $r) {\n            return null;\n        }\n        $mid = ceil(($r - $l)/2) + $l;\n        $root = new ListNode($res[$mid]);\n        $root->left = $this->dfs($res, $l, $mid-1);\n        $root->right = $this->dfs($res, $mid+1, $r);\n        return $root;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n### 解法一：\n- 时间复杂度：递归树的深度为 lognlogn，每一层的基本操作数为 nn，因此总的时间复杂度为O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)\n### 解法二：\n- 时间复杂度：递归树每个节点的时间复杂度为 O(1)，每次处理一个节点，因此总的节点数就是 nn， 也就是说总的时间复杂度为O(n)。\n- 空间复杂度：使用了数组对链表的值进行缓存，空间复杂度为O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095138054","body":"# 142. 环形链表 II\n\n## 题目链接\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目思路\n### 解法一：使用哈希法\n1. 使用哈希表存储链表的每一个节点\n2. 遍寻每一个节点都要检查在哈希表里是否存在\n3. 存在就直接返回。如果不存在就返回null\n\n### 解法二：使用快慢指针\n1. 建立快慢指针，都在链表的原点\n2. 快指针的步长为2，慢指针的步长为1\n3. 当两个指针相遇时，快指针回到链表的原点\n4. 这时快指针的步长为1，这时候快慢指针相遇就是交点\n\n## 题目的题解code\n### 解法一：\n```PHP\n<?php\n\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function detectCycle($head) {\n        $data = [];\n        while ($head != null) {\n            if (in_array($head, $data)) {\n                return $head;\n            }else {\n                $data[] = $head;\n            }\n            $head = $head->next;\n        }\n        return null;\n    }\n}\n```\n\n### 解法二\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function detectCycle($head) {\n        $fast = $head; $slow = $head;\n\n        while($fast != null) {\n            $slow = $slow->next;\n            if ($fast->next != null) {\n                $fast = $fast->next->next;\n            } else {\n                return null;\n            }\n\n            if ($slow->val == $fast->val) {\n                $current = $head;\n                while ($current->val != $slow->val) {\n                    $current = $current->next;\n                    $slow = $slow->next;\n                }\n                return $current->val;\n            }\n        }\n        return null;\n    }\n}\n```\n## 时间和空间复杂度\n### 解法一：\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n### 解法二：\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096802839","body":"# 146.LRU缓存机制\n\n## 题目链接\n\nhttps://leetcode-cn.com/problems/lru-cache/\n\n## 题目思路\n为什么不用数组？因为我们需要频繁的插入数据(调整数据的位置)\n和删除数据；所以使用链表，那能用单链表吗？也不行，因为我们需要在移除链表节点后还需要把该节点前后两个节点连起来，所以我们使用双链表来插入和删除数据，为了查找方便，还需要结合哈希表的方式记录数据的位置\n\n## 题目的题解code\n```PHP\nclass Node\n{\n    public $key;\n    public $value;\n    public $prev;\n    public $next;\n\n    public function __construct($key, $value)\n    {\n        $this->key = $key;\n        $this->value = $value;\n    }\n}\n\nclass LRUCache\n{\n    public $capacity;\n    public $useCapacity = 0;\n    public $hash = [];\n    public $head;\n    public $tail;\n\n    public function __construct($capacity)\n    {\n        $this->capacity = $capacity;\n        $this->head = new Node(0, 0);\n        $this->tail = new Node(0, 0);\n        $this->head->next = $this->tail;\n        $this->tail->prev = $this->head;\n    }\n\n    public function put($key, $val)\n    {\n        if (array_key_exists($key, $this->hash)) {\n            $node = $this->hash[$key];\n            $node->value = $val;\n            $this->addToHead($this->deleteNode($node));\n        } else {\n            if ($this->isFull()) {\n                $node = $this->tail->prev;\n                unset($this->hash[$node->key]);\n                $this->deleteNode($node);\n                $this->useCapacity--;\n            }\n            $node = new Node($key, $val);\n            $this->hash[$key] = $node;\n            $this->addToHead($node);\n            $this->useCapacity++;\n        }\n    }\n\n    public function get($key)\n    {\n        if(array_key_exists($key, $this->hash)) {\n            $node = $this->hash[$key];\n            $this->addToHead($this->deleteNode($node));\n            return $node->value;\n        }\n        return -1;\n    }\n\n    private function isFull()\n    {\n        return $this->capacity === $this->useCapacity;\n    }\n\n    private function deleteNode($node)\n    {\n        $node->prev->next = $node->next;\n        $node->next->prev = $node->prev;\n        $node->prev = null;\n        $node->next = null;\n\n        return $node;\n    }\n\n    private function addToHead($node)\n    {\n        $head = $this->head->next;\n        $node->next = $head;\n        $head->prev = $node;\n        $node->prev = $this->head;\n        $this->head->next = $node;\n    }\n}\n```\n## 时间和空间复杂度\n\n令n为链表总的节点数\n- 时间复杂度：O(1)，采用双链表插入和删除时间复杂度都是O(1)，再通过哈希查找那么时间复杂度也为O(1)，所以整体的时间复杂度为O(1)\n- 空间复杂度：O(n)，n为$capacity的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097924556","body":"# 104. 二叉树的最大深度\n## 题目链接\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n## 题目思路\n递归\n\n### 思路\n1. 假设有一个函数f，来求解深度\n2. 那么思考一个问题深度与f(root)、f(root.left)、f(root.right)是什么关系？没错深度=1+max(f(root.left),f(root.right))\n3. 循环终止的条件是如果递归到达叶子节点，那么就返回0\n\n## 题目的题解code\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxDepth($root) {\n        if ($root === null) {\n            return 0;\n        }\n\n        return max($this->maxDepth($root->left), $this->maxDepth($root->right)) + 1;\n    }\n}\n```\n## 时间和空间复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(h),h为深度，最大的h为n,这时候的树就是链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099086790","body":"# 100. 相同的树\n\n## 题目链接\n\nhttps://leetcode-cn.com/problems/same-tree/\n\n## 题目思路\n\n### 解法一\n\n递归\n\n1. 先判断p和q是否为空，有一个为空就返回false，两个都为空那么则为true\n2. 然后，再判断p和q的值是否相等&&p.left和q.left重新调用这个方法&&p.right和q.right重新调用这个方法\n\n### 解法二\n\n层序遍历\n\n1. 每次都比较每一层是否才相同\n2. 采用队列的形式，每次从队列中取出参数，如果不一致返回false，否则返回truel\n\n### 解法三\n\n前序中序遍历确定一颗数，如果两个数都经过这前中序遍历是一样的话，那就说明他们是一样的\n\n## 题目的题解code\n\n### 解法一\n\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q)\n    {\n        if (!$p || !$q) {\n            return !$p && !$q;\n        }\n\n        return $p->val === $q->val && $this->isSameTree($p->left, $q->left) && $this->isSameTree($p->right, $q->right);\n    }\n}\n```\n\n解法二：\n\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q)\n    {\n        $curLeveA = [$p];\n        $curLeveB = [$q];\n\n        while (count($curLeveA) && count($curLeveB)) {\n            $nextLeveA = [];\n            $nextLeveB = [];\n            $isOk = $this->isSameLevel($curLeveA, $curLeveB, $nextLeveA, $nextLeveB);\n            if ($isOk) {\n                $curLeveA = $nextLeveA;\n                $curLeveB = $nextLeveB;\n            }else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * 层级是否相同\n     *\n     * @param $curLeveA\n     * @param $curLeveB\n     * @param $nextLeveA\n     * @param $nextLeveB\n     * @return bool\n     * @author 陈维锐\n     * @date 2022/04/14 18:54\n     */\n    private function isSameLevel($curLeveA, $curLeveB, &$nextLeveA, &$nextLeveB)\n    {\n        if (count($curLeveA) != count($curLeveB)) {\n            return false;\n        }\n\n        for ($i = 0; $i < count($curLeveA); $i++) {\n            if (!$this->isSameNode($curLeveA[$i], $curLeveB[$i])) {\n                return false;\n            }\n            $curLeveA[$i] && array_push($nextLeveA, $curLeveA[$i]->left, $curLeveA[$i]->right);\n            $curLeveB[$i] && array_push($nextLeveB, $curLeveB[$i]->left, $curLeveB[$i]->right);\n        }\n        return true;\n    }\n\n    /**\n     * 节点是否相同\n     *\n     * @param $nodeA\n     * @param $nodeB\n     * @return bool\n     * @author 陈维锐\n     * @date 2022/04/14 18:55\n     */\n    private function isSameNode($nodeA, $nodeB)\n    {\n        if (!$nodeA || !$nodeB) {\n            return $nodeA === $nodeB;\n        }\n        return $nodeA->val === $nodeB->val;\n    }\n}\n```\n\n### 解法三：\n\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $p\n     * @param TreeNode $q\n     * @return Boolean\n     */\n    function isSameTree($p, $q)\n    {\n        $preordeP = $this->preorder($p, []);\n        $preordeQ = $this->preorder($q, []);\n        $inorderP = $this->inorder($p, []);\n        $inorderQ = $this->inorder($q, []);\n\n        return implode(\",\", $preordeP) === implode(\",\", $preordeQ) && implode(\",\", $inorderP) === implode(\",\", $inorderQ);\n    }\n\n    /**\n     * 前序遍历\n     *\n     * @param $root\n     * @param $arr\n     * @return mixed\n     * @author 陈维锐\n     * @date 2022/04/14 19:17\n     */\n    private function preorder($root, $arr)\n    {\n        if ($root === null) {\n            array_push($arr, '');\n            return $arr;\n        }\n\n        array_push($arr, $root->val);\n        $arr = $this->preorder($root->left, $arr);\n        $arr = $this->preorder($root->right, $arr);\n        return $arr;\n    }\n\n    /**\n     * 中序遍历\n     *\n     * @param $root\n     * @param $arr\n     * @return mixed\n     * @author 陈维锐\n     * @date 2022/04/14 19:17\n     */\n    private function inorder($root, $arr) {\n        if ($root === null) {\n            array_push($arr, '');\n            return $arr;\n        }\n\n        $arr = $this->inorder($root->left, $arr);\n        array_push($arr, $root->val);\n        $arr = $this->inorder($root->right, $arr);\n        return $arr;\n    }\n}\n```\n\n## 时间和空间复杂度\n\n### 解法一\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(h),h为树的深度，\n\n### 解法二\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(h),h为队列的长度的最大值，最大不会超过相邻两层节点的最大值\n\n### 解法三\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n),树的节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100022266","body":"# 129. 求根到叶子节点数字之和\n\n## 题目链接\n\nhttps://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n## 题目思路\n\n### 解法一：\n\n采用dfs的方式进行循环遍历。公式是当前的值 = 上一个值*10+当前节点的值\n- 先检查当前节点如果为null，那么直接返回0\n- 如果当前节点不为null，那么当前的值 = 上一个值*10+当前节点的值\n- 检查这个节点的左右子树如果都是空，那么就直接返回当前节点的值\n- 这个节点的左右子树如果都不为空，那么再次按照上面的循环左右子树，并且将他们的结果求和\n\n### 解法二：\n\nBFS,将每一层的值算出来\n\n## 题目的题解code\n\n### 解法一：\n\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function sumNumbers($root)\n    {\n        return $this->dfs($root, 0);\n    }\n\n    /**\n     * dfs遍寻求和\n     *\n     * @param $root\n     * @param $cur\n     * @return int\n     * @author 陈维锐\n     * @date 2022/04/15 17:27\n     */\n    private function dfs($root, $cur)\n    {\n        if ($root == null) {\n            return 0;\n        }\n        $curSum = $cur * 10 + $root->val;\n\n        if (!$root->left && !$root->right) {\n            return $curSum;\n        }\n\n        return ($this->dfs($root->left, $curSum))+($this->dfs($root->right, $curSum));\n    }\n}\n```\n\n### 解法二\n\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function sumNumbers($root)\n    {\n        $sum = 0;\n        $curLevel = [];\n\n        if ($root) {\n            $curLevel = [$root];\n        }\n\n        while (count($curLevel)) {\n            $nextLevel = [];\n            for ($i = 0; $i < count($curLevel); $i++) {\n                $cur = $curLevel[$i];\n                if ($cur->left) {\n                    $cur->left->val = $cur->val * 10 + $cur->left->val;\n                    array_push($nextLevel, $cur->left);\n                }\n\n                if ($cur->right) {\n                    $cur->right->val = $cur->val * 10 + $cur->right->val;\n                    array_push($nextLevel, $cur->right);\n                }\n\n                if (!$cur->left && !$cur->right) {\n                    $sum += $cur->val;\n                }\n                $curLevel = $nextLevel;\n            }\n        }\n        return $sum;\n    }\n}\n```\n\n## 时间和空间复杂度\n### 解法一：\n- 时间复杂度：O(n)\n- 空间复杂度：O(h),为树的深度\n\n### 解法二：\n- 时间复杂度：O(n)\n- 空间复杂度：O(q)。最坏的情况是满二叉树，此时和 n 同阶。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101310052","body":"# 513. 找树左下角的值\n\n## 题目链接\n\nhttps://leetcode-cn.com/problems/find-bottom-left-tree-value/\n\n## 题目思路\n\n实际上就是找树的最后一行的左边节点\n\n### 解法一：\n\nbfs层序遍历:\n\n### 解法二：\n\nBFS,将每一层的值算出来\n\n## 题目的题解code\n\n### 解法一：\n\n使用dfs，直接使用先序遍历或者中序遍历，为什么不是后序遍历，因为左节点一定要比右节点先处理的。用一个变量最大深度，在每次遍寻的时候都要和最大深度比较，如果大于最大深度，就记录最大深度，并且记录当前的值。这样就能找出你想要树的最左子节点的值\n\n```PHP\n<?php\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function findBottomLeftValue($root) {\n        $curLeve = [$root];\n        $res = $curLeve[0]->val;\n        while(count($curLeve)) {\n            $nextLeve = [];\n            for ($i = 0; $i < count($curLeve); $i++) {\n                $curLeve[$i]->left && array_push($nextLeve, $curLeve[$i]->left);\n                $curLeve[$i]->right && array_push($nextLeve, $curLeve[$i]->right);\n            }\n            $res = $curLeve[0]->val;\n            $curLeve = $nextLeve;\n        }\n\n        return $res;\n    }\n}\n```\n\n### 解法二\n\n```PHP\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n    private $maxDepth = 0;\n    private $res = 0;\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function findBottomLeftValue($root)\n    {\n        $this->res = $root->val;\n\n        $this->dfs($root->left, 0);\n        $this->dfs($root->right, 0);\n        return $this->res;\n    }\n\n    /**\n     * dfs遍寻\n     *\n     * @param $cur\n     * @param $depth\n     * @author 陈维锐\n     * @date 2022/04/18 18:48\n     */\n    private function dfs($cur, $depth)\n    {\n        if (!$cur) {\n            return;\n        }\n\n        $curDepth = $depth + 1;\n        if ($curDepth > $this->maxDepth) {\n            $this->maxDepth = $curDepth;\n            $this->res = $cur->val;\n        }\n\n        $this->dfs($cur->left, $curDepth);\n        $this->dfs($cur->right, $curDepth);\n    }\n}\n```\n\n## 时间和空间复杂度\n### 解法一：\n- 时间复杂度：O(n)\n- 空间复杂度：O(q),其中q为队列的长度，最坏的情况下为满二叉树，此时和N同阶，其中N为树的节点总数\n\n### 解法二：\n- 时间复杂度：O(n)\n- 空间复杂度：O(h)。为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102745990","body":"# 1. 两数之和\n\n## 时间\n\n## 题目链接\nhttps://leetcode-cn.com/problems/two-sum/\n\n## 题目思路\n1. 通过哈希表存储$val和$key\n2. 每次循环当前值的另一个值 = $target - 当前值，然后再判断哈希表是否存在另一值，存在就按照要求返回\n\n## 题目的题解code\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $target\n     * @return Integer[]\n     */\n    function twoSum($nums, $target) {\n        $hashtable = [];\n        $res = [];\n\n        foreach ($nums as $key => $val) {\n            $tmp = $target - $val;\n            if (isset($hashtable[$tmp])) {\n                $res = [$hashtable[$tmp], $key];\n                break;\n            }\n            $hashtable[$val] = $key;\n        }\n\n        return $res;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103797427","body":"# 347. 前 K 个高频元素\n\n## 题目链接\nhttps://leetcode-cn.com/problems/top-k-frequent-elements/\n\n## 题目思路\n1. 因为加班，暂时用PHP内置的函数来使用，后续补回来\n\n## 题目的题解code\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function topKFrequent($nums, $k) {\n        $hashtable = [];\n\n        foreach ($nums as $val) {\n            if (!isset($hashtable[$val])) {\n                $hashtable[$val] = 1;\n            }else {\n                $hashtable[$val] += 1;\n            }\n        }\n        arsort($hashtable);\n\n        return array_keys(array_slice($hashtable, 0, $k, true));\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105287809","body":"# 447. 回旋镖的数量\n\n## 题目链接\nhttps://leetcode-cn.com/problems/number-of-boomerangs/\n\n## 题目思路\n欧式算法：\n![](https://my-note-image.oss-cn-beijing.aliyuncs.com/img/20220421222021.png)\n思路：\n采用哈希表的方式存储，欧式算法的结果。过程如下\n1. 两次遍寻，两次遍寻的key不能是同一个，同一个就跳过，因为本身不计算欧式距离\n2. 当key不同时，将val传入计算欧式距离的方法`distance`里面\n3. 然后用哈希表存起来，key为方法`distance`结果的值，value为次数\n4. 假如出现距离为3的次数为2，那么组合总共有2*(2-1),按照这个公式累加其他距离出现的次数即可等到正确答案\n## 题目的题解code\n```PHP\n<?php\n\nclass Solution\n{\n\n    /**\n     * @param Integer[][] $points\n     * @return Integer\n     */\n    function numberOfBoomerangs($points)\n    {\n        $res = 0;\n        foreach ($points as $key1 => $val1) {\n            $map = []; // 建立一个哈希表\n            foreach ($points as $key2 => $val2) {\n                if ($key1 == $key2) { // 如果key相等就跳过，不计算自身的数据\n                    continue;\n                }\n                $temp = $this->distance($val1, $val2); // 欧式距离\n                $map[$temp] = isset($map[$temp]) ? $map[$temp] + 1 : 1; // 用哈希表记录相同的欧式距离\n            }\n            foreach ($map as $item) {\n                $res += $item * ($item - 1); // 每个符合距离的欧式距离的个数= n*(n-1)\n            }\n\n        }\n\n        return $res;\n    }\n\n    /**\n     * 欧式距离算法，不需要带根号\n     *\n     * @param $i\n     * @param $j\n     * @return float|int\n     */\n    private function distance($i, $j)\n    {\n        return ($i[0] - $j[0]) * ($i[0] - $j[0]) + ($i[1] - $j[1]) * ($i[1] - $j[1]);\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(n^2),循环两次\n空间复杂度：O(n)，最坏的情况下存储n个节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106052116","body":"# 3. 无重复字符的最长子串\n\n## 题目链接\nhttps://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n## 题目思路\n方法\n- 双指针\n- 滑动窗口\n- 哈希表\n\n思路：\n- 维护一个滑动窗口（这个滑动窗口由两个指针维护），当窗口中的值不是重复的时候，右指针就往不断重复的右边+1移动\n- 当移动到在滑动窗口有重复的值d的时候，将窗口左侧收缩到d字符上次出现的位置+1\n- 为了快速找到上次出现的位置，我们可以用一个哈希表来记录每个字符的位置，如果字符是重复的，就替换成这个字符的当前位置\n- 在滑动窗口遍历数组的过程中用一个变量记录窗口的最大长度\n\n![](https://raw.githubusercontent.com/577961141/static/master/20220422142040.png)\n\n## 题目的题解code\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tstr := \"abcabcbb\"\n\tfmt.Println(lengthOfLongestSubstring(str))\n}\n\nfunc lengthOfLongestSubstring(s string) int {\n\tm := map[uint8]int{} // 存储字符的位置\n\tl := 0 // 左指针\n\tr := 0 // 右指针\n\tmax := 0 // 存储最大不重复的字符数\n\n\tfor r < len(s) {\n\t\tpos,ok := m[s[r]] // 获取当前字符的位置\n\n\t\tif pos >= l && pos <= r && ok != false { // 这个字符存在map里面，看看是否在当前窗口里面。如果在的话左指针的位置+1\n\t\t\tl = pos+1\n\t\t}\n\n\t\tm[s[r]] = r // 更新当前字符的位置\n\t\tmax = getMax(max, r-l+1) // 获取最大不重复的字符数\n\t\tr++\n\t}\n\treturn max\n}\n\n\nfunc getMax(x int, y int) int{\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(n),n为元素的个数\n空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），本题没有说明字符集，因此可以默认位ASCII码在[0,128)内的字符，而哈希表就是用来存储这些字符集的，在最坏的情况下也就存储128个（哈希表里面字符存储不重复）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107471654","body":"## 题目思路\n很简单的，直接用一个数组来存储就行\n## 题目的题解code\n```PHP\n<?php\n\nclass MyHashSet {\n    /**\n     * @var array\n     */\n    private $hash;\n\n    /**\n     */\n    function __construct() {\n        $this->hash = [];\n    }\n\n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function add($key) {\n        $this->hash[$key] = '';\n        return null;\n    }\n\n    /**\n     * @param Integer $key\n     * @return NULL\n     */\n    function remove($key) {\n        unset($this->hash[$key]);\n        return null;\n    }\n\n    /**\n     * @param Integer $key\n     * @return Boolean\n     */\n    function contains($key) {\n        return isset($this->hash[$key]);\n    }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * $obj = MyHashSet();\n * $obj->add($key);\n * $obj->remove($key);\n * $ret_3 = $obj->contains($key);\n */\n```\n\n## 时间和空间复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107844361","body":"# https://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K\n\n## 题目链接\nhttps://binarysearch.com/problems/Delete-Sublist-to-Make-Sum-Divisible-By-K\n\n## 题目思路\n看题解，我也没太懂\n\n\n## 题目的题解code\n```PHP\n<?php\n\nclass Solution\n{\n    public function solve($nums, $k)\n    {\n        $map = [];\n        $map[0] = -1;\n        $res = count($nums);\n        $target = 0;\n        $currSum = 0;\n        for ($i = 0; $i < count($nums); $i++) {\n            $target += $nums[$i];\n        }\n        $target = $target % $k;\n        for ($i = 0; $i < count($nums); $i++) {\n            $currSum = ($nums[$i] + $currSum) % $k; // 同余\n            $map[$currSum] = $i;\n            $prevSum = $this->floorMod($currSum - $target, $k);\n            if (isset($map[$prevSum])) {\n                $res = min($res, $i -$map[$prevSum]);\n            }\n        }\n        \n\n        return $res === count($nums) ? -1 : $res;\n\n    }\n\n    private function floorMod($a, $b)\n    {\n        return (($a % $b) + $b) % $b;\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(n)\n空间复杂度：O(min(n,k))","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111745688","body":"# 239.滑动窗口最大值\n\n## 题目链接\nhttps://leetcode-cn.com/problems/sliding-window-maximum/\n\n## 题目思路\n\n解法一：\n\n暴力解法，这种很容易超时，不推荐\n\n解法二：\n\n- 双端队列\n- 双指针（固定滑动窗口）\n\n双指针是一个固定为`$k`的滑动窗口,我们先定义`left`和`right`都是从0开始的，然后`right`一直循环自增（right 超过nums的就停止）， `right`的每次自增之前，都要把`nums[right]`加入到优先队列中，在加入到优先队列之前，都要循环的比较优先队列的最后一个数是否是小于`nums[right]`,如果小于的话，就去掉优先队列的最后一个数，直到循环比较到不符合条件为止，这样就能保证优先队列的头部一定是最大值。当`right`自增到`right -left + 1 = k`的时候代表着，可以从这个优先队列里面头部的值，加入到要返回的`res`里面，但是要注意这个优先头部的最大值是否等于`nums[left]`,如果等于的话就需要去掉这个优先队列里面头部的值，以保证下一个滑动窗口比较不会被用到，然后left页进行自增。重复上面的步骤就能求出解\n\n`leetleetcode`解释：\n\n其实，我们没必须存储窗口内的所有元素。 如果新进入的元素比前面的大，那么前面的元素就不再有利用价值，可以直接移除。这提示我们使用一个单调递增栈来完成。\n\n但由于窗口每次向右移动的时候，位于窗口最左侧的元素是需要被擦除的，而栈只能在一端进行操作。而如果你使用普通的数组实现，就是可以在另一端操作了，但是时间复杂度仍然是 O(k)\n\n因此，我们考虑使用链表来实现，维护两个指针分别指向头部和尾部即可，这样做的时间复杂度是 O(1)，这就是双端队列。\n\n因此思路就是用一个双端队列来保存接下来的滑动窗口可能成为最大值的数。\n\n具体做法：\n\n- 入队列\n\n- 移除失效元素，失效元素有两种\n\n1. 一种是已经超出窗口范围了，比如我遍历到第 4 个元素，k = 3，那么 i = 0 的元素就不应该出现在双端队列中了。具体就是索引大于 i - k + 1的元素都应该被清除\n\n2. 小于当前元素都没有利用价值了，具体就是从后往前遍历（双端队列是一个递减队列）双端队列，如果小于当前元素就出队列\n\n经过上面的分析，不难知道双端队列其实是一个递减的一个队列，因此队首的元素一定是最大的。用图来表示就是：\n\n![](https://raw.githubusercontent.com/577961141/static/master/20220428115326.png)\n\n## 题目的题解code\n解法一：\n```PHP\nclass Solution\n{\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k)\n    {\n        $res = [];\n        for ($i = 0; $i <= count($nums) - $k; $i++) {\n            $cur = $this->maxInSlidingWindow($nums, $i, $i+$k);\n            $res[] = $cur;\n        }\n\n        return $res;\n    }\n\n    /**\n     * 获取数组某个区间的最大值\n     *\n     * @param array $nums 数组\n     * @param int $start 开始的索引\n     * @param int $end 结束的索引\n     * @return mixed\n     * @author 陈维锐\n     * @date 2022/04/28 9:44\n     */\n    private function maxInSlidingWindow($nums, $start, $end)\n    {\n        $max = $nums[$start];\n        for ($i = $start; $i < $end; $i++) {\n            $max = max($max, $nums[$i]);\n        }\n        return $max;\n    }\n}\n```\n\ngolang\n```goland\n\n```\n\n解法二：\n```php\nclass Solution\n{\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function maxSlidingWindow($nums, $k)\n    {\n        $left = $right = 0;\n        $len = count($nums);\n        $queue = new SplQueue();\n        $res = [];\n\n        while ($right < $len) {\n            $r_num = $nums[$right];\n            // 当队列不为空，且队列的最后一个值小于当前的值，那么就移除队列的最后一个值，一直循环下去，到不满足条件为止，确保队列的首个值为最大值\n            while (!$queue->isEmpty() && $queue->top() < $r_num) {\n                $queue->pop();\n            }\n            $queue->enqueue($r_num);\n\n            if ($right - $left + 1 == $k) {\n                $l_num = $nums[$left];\n                $res[] = $queue->bottom();\n                // 左边的数等于队列的数说明一个问题，那就是队列是存储滑动窗口最左边的值为最大值，那么在下一次循环的时候，就要去掉在队列中的这个值，防止再次比较这个值\n                if ($l_num == $queue->bottom()) {\n                    $queue->dequeue();\n                }\n                $left++;\n            }\n            $right++;\n        }\n        return $res;\n    }\n}\n```\n```golang\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tq := []int{}\n\n\tpush := func(i int) {\n\t\tfor len(q) > 0 && nums[q[len(q) - 1]] < nums[i] { // 循环去掉最后一项\n\t\t\tq = q[:len(q) -1]\n\t\t}\n\t\tq = append(q, i)\n\t}\n\n\tfor i := 0; i < k; i++ { // 找出前k项最大值的k\n\t\tpush(i)\n\t}\n\n\tn := len(nums)\n\tans := make([]int, 1, n-k+1)\n\tans[0] = nums[q[0]]\n\tfor i := k; i < n; i++ {\n\t\tpush(i)\n\t\tif q[0] <= i - k { // 防止重复比较\n\t\t\tq = q[1:]\n\t\t}\n\t\tans = append(ans, nums[q[0]])\n\t}\n\treturn ans\n}\n```\n## 时间和空间复杂度\n解法一：\n- 时间复杂度：O(n*k)\n- 空间复杂度：O(1)\n\n解法二：\n- 时间复杂度: O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112842900","body":"# 997. 找到小镇的法官\n\n## 题目链接\n\nhttps://leetcode-cn.com/problems/find-the-town-judge/\n\n## 题目思路\n- 图\n\n可以把这道题想象成图的`出度`和`入度`来做\n\n先看题目的描述：\n\n1. 小镇的法官不会相信任何人，代表着法官的出度为0\n2. 每个人（除了小镇法官）都信任这位小镇法官，代表着这位小镇法官的入度为n-1\n3. 只有一个人同时满足属性 1 和属性 2 。那么代表法官是唯一的，题解如下\n\n## 题目的题解code\n\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $trust\n     * @return Integer\n     */\n    function findJudge($n, $trust) {\n        $inDegress = [];\n        $outDegress = [];\n\n        foreach ($trust as $val) {\n            $inDegress[$val[1]]++;\n            $outDegress[$val[0]]++;\n        }\n\n//        var_dump($inDegress, $outDegress );die;\n\n        for ($i = 1; $i <= $n; $i++) {\n            if ($inDegress[$i] == $n - 1 && $outDegress[$i] == 0) {\n                return $i;\n            }\n        }\n\n        return -1;\n    }\n}\n```\n\n```golang\nfunc findJudge(n int, trust [][]int) int {\n\tinDegress := make([]int, n+1)\n\toutDegerss := make([]int, n+1)\n\n\tfor _, val := range trust {\n\t\tinDegress[val[1]]++\n\t\toutDegerss[val[0]]++\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tif inDegress[i] == n-1 && outDegerss[i] == 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n```\n\n## 时间和空间复杂度\n\n- 时间复杂度：O(n+m),`m`代表的是`trust`数组的个数(遍寻多少次)，`n`代表的是小镇的人的个数（也要遍寻）\n- 空间复杂度：O(n),记录各个节点的入度和出度需要O(n)的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1973719588":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085541708","body":"思路：将int型的数字变为str字符串型的就很好处理了\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        i = ''\r\n        for x in num:\r\n            i = i + str(x)\r\n        numi = int(i)\r\n        xx = numi + k\r\n        ls = []\r\n        for s in str(xx):\r\n            ls.append(int(s))\r\n\r\n        return ls\r\n```\r\n\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1089832526","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        ls = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ls.append(i)\n        l = ls[:]\n        lss = []\n        for i in range(len(s)):\n            for j in range(len(ls)):\n                l[j] = abs(ls[j] - i)\n            print(l)\n            k = min(l)\n            lss.append(k)\n\n        return lss","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1089839494","body":"```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.maxl = maxSize\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        l = len(self.stack)\r\n        if l < self.maxl:\r\n            self.stack.append(x)\r\n\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack == []:\r\n            return -1\r\n        else:\r\n            return self.stack.pop()\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        l = len(self.stack)\r\n        if l < k:\r\n            for i in range(l):\r\n                self.stack[i] = self.stack[i] + val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i] = self.stack[i] + val\r\n\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n时间复杂度：每次pop和push的时间复杂度都是O(1)\r\n空间复杂度：O(N)","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091654293","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        def rotate(head):\r\n            curl = head\r\n            while curl.next:\r\n                pre = curl\r\n                curl = curl.next\r\n            end = curl\r\n            end.next = head\r\n            pre.next = None\r\n            return end\r\n        \r\n        if head == None or head.next == None:\r\n            return head\r\n        \r\n        l = 1\r\n        curl = head\r\n        while curl.next:\r\n            l = l + 1\r\n            pre = curl\r\n            curl = curl.next\r\n        if k > l:\r\n            k = k % l\r\n\r\n        while k > 0:\r\n            head = rotate(head)\r\n            k = k - 1\r\n        \r\n        return head\r\n```\r\n空间复杂度：O(1)\r\n时间复杂度：max (k)O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1095048339","body":"```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if head == None:\r\n            return head\r\n        \r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        if pre:\r\n            pre.next = None\r\n        root = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return root\r\n\r\n        root.left = self.sortedListToBST(head)\r\n        root.right =self.sortedListToBST(slow.next)\r\n\r\n        return root\r\n```\r\n空间复杂度：O(log N)\r\n时间复杂度：O(N log N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094966232","body":"```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        curlA = headA\n        curlB = headB\n        while curlA and curlB:\n            if curlA == curlB:\n                return curlA\n\n            if curlA.next == None and curlB.next != None:\n                curlA = headB\n                curlB = curlB.next\n            elif curlB.next == None and curlA.next != None:\n                curlA = curlA.next\n                curlB = headA\n\n            elif curlA.next == None and curlB.next == None:\n                return None\n            else: \n                curlA = curlA.next\n                curlB = curlB.next\n```\n空间复杂度：O(1)\n时间复杂度：O(m+n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094910697","body":"```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if head == None or head.next == None or head.next.next == None:\n            return None\n        \n        fast = head.next.next\n        slow = head.next\n        while fast.next and fast.next.next:\n            if slow != fast:\n                slow = slow.next\n                fast = fast.next.next\n            else:\n                while slow != head:\n                    slow = slow.next\n                    head = head.next\n                return head\n        \n        return None\n```\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1097512121","body":"```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value =value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.cache = dict()\n        self.capacity = capacity\n        self.size = 0\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def removeNode(self, node):\n        node.next.prev = node.prev\n        node.prev.next = node.next\n\n    def addToHead(self,node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n\n    def movetohead(self,node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        \n        node = self.cache[key]\n        val = node.value\n        self.movetohead(node)\n        return val\n\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            self.size += 1\n            self.addToHead(node)\n            if self.capacity < self.size:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size -= 1\n\n\n        else:\n            node = self.cache[key]\n            node.value = value\n            self.movetohead(node)\n        \n```\n时间复杂度：O(1)\n空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097513838","body":"# 思路\r\n广度优先遍历\r\n# 代码\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        # BFS 广度遍历比较清晰\r\n        if root == None:\r\n            return 0\r\n\r\n        steps = 0\r\n        que = deque()\r\n        que.appendleft(root)\r\n\r\n        while que:\r\n            l = len(que)\r\n            for _ in range(l):\r\n                node = que.pop()\r\n                if node.right:\r\n                    que.appendleft(node.right)\r\n                if node.left:\r\n                    que.appendleft(node.left)\r\n            \r\n            steps = steps + 1\r\n\r\n        return steps\r\n```\r\n# 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099893342","body":"## 思路\n用python的队列deque，实现广度优先搜索\n## 代码\n```python\nfrom collections import deque\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        que1 = deque()\n        que2 = deque()\n        ls = []\n\n        que1.appendleft(root)\n        que2.appendleft(root.val)\n\n        while que1:\n            l = len(que1)\n            for _ in range(l):\n                node = que1.pop()\n                val = que2.pop()\n\n                if node.left:\n                    que1.appendleft(node.left)\n                    valleft = val*10 + node.left.val\n                    que2.appendleft(valleft)\n                \n                if node.right:\n                    que1.appendleft(node.right)\n                    valright = val*10 +node.right.val\n                    que2.appendleft(valright)\n\n                if not node.left and not node.right:\n                    ls.append(val)\n\n        sumre = sum(ls)\n\n        return sumre \n```\n## 复杂度\n时间复杂度：O(N) N为树中节点树\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1101012529","body":"BFS\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        que1 = deque()\r\n        que1.appendleft(root)\r\n\r\n        while que1:\r\n\r\n            l = len(que1)\r\n            ls = []\r\n            for _ in range(l):\r\n                node = que1.pop()\r\n                ls.append(node.val)\r\n                if node.left:\r\n                    que1.appendleft(node.left)\r\n                if node.right:\r\n                    que1.appendleft(node.right)\r\n                \r\n\r\n        return ls[0]\r\n```\r\n空间复杂度：O(N)\r\n时间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1101056680","body":"```python\nfrom collections import deque\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return ''\n        que1 = deque()\n        res = []\n        que1.appendleft(root)\n\n        while que1:\n            node = que1.pop()\n\n            if not node:\n                res.append('None')\n            else:\n                res.append(str(node.val))\n                que1.appendleft(node.left)\n                que1.appendleft(node.right)\n\n        return '[' + ','.join(res) + ']'\n\n\n\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        datalist = data[1:-1].split(',')\n        root = TreeNode(val = int(datalist[0]))\n        que2 = deque()\n        que2.appendleft(root)\n        i = 1\n\n        while que2:\n            node = que2.pop()\n            if datalist[i] != 'None':\n                node.left = TreeNode(int(datalist[i]))\n                que2.appendleft(node.left)\n            i = i + 1\n            if datalist[i] != 'None':\n                node.right = TreeNode(int(datalist[i]))\n                que2.appendleft(node.right)\n            i = i + 1\n\n        \n        return root\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101172396","body":"```python\nfrom collections import deque\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        que1 = deque()\n        ls1 = []\n        ls2colrow = []\n        que2 = deque()\n\n        row = 0\n        col = 0\n\n        que1.appendleft(root)\n        que2.appendleft(col)\n        \n        while que1:\n            l = len(que1)\n            for _ in range(l):\n\n                node = que1.pop()\n                col = que2.pop()\n                val = node.val\n                ls1.append(val)\n                ls2colrow.append([col,row])\n\n                if node.left:\n                    que1.appendleft(node.left)\n                    que2.appendleft(col-1)\n\n                if node.right:\n                    que1.appendleft(node.right)\n                    que2.appendleft(col+1)\n \n            row = row + 1\n\n        for i in range(len(ls2colrow)):\n            ls2colrow[i].append(ls1[i])\n\n        ls2colrow.sort()\n        \n        lsres = []\n        lss = []\n        a = ls2colrow[0][0]\n        lss.append(ls2colrow[0][2])\n\n        for i, _, k in ls2colrow[1:]:\n            \n            if i != a:\n                a = i\n                lsres.append(lss)\n                lss = []\n                lss.append(k)\n            else:\n                lss.append(k)\n        \n        lsres.append(lss)\n\n        \n        return lsres\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101907727","body":"```python\n# 利用哈希表的话可以实现只用遍历一次即可\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashtable = {}\n\n        for i, num in enumerate(nums):\n            if target - num in hashtable:\n                a = hashtable[target - num]\n                break\n            else:\n                hashtable[num] = i\n\n        return [i, a]\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103430186","body":"运用哈希表，记录频次\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for x in nums:\n            if x not in dic:\n                dic[x] = 1\n            else:\n                dic[x] += 1\n        \n        val = dic.values()\n        val = list(val)\n\n        val.sort()\n        kmax = val[-k:]\n\n        ls = []\n        for z in dic:\n            if dic[z] in kmax:\n                ls.append(z)\n        \n        return ls\n```\n时间复杂度：O(NlogN)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104656961","body":"```python\nimport numpy as np\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) <= 2:\n            return 0\n\n        sum = 0\n        for i in range(len(points)):\n            dic = {}\n            for j in range(len(points)):\n                if i != j:\n                    a, b = points[i]\n                    x, y = points[j]\n                    le = np.sqrt(abs(a-x)**2 + abs(b-y)**2)\n                    if le not in dic:\n                        dic[le] = 1\n                    else:\n                        dic[le] += 1\n            for x in dic:\n                y = dic[x]\n                sum = sum + y * (y-1)\n                \n\n        return sum\n```\n时间复杂度：O(N^2)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105914063","body":"```python\nfrom collections import deque\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ans = 0\n        j = 0\n        m = []\n        for i in range(len(s)):       \n            while s[i] in m:\n                m = m[1:]   \n            m.append(s[i])\n            ans = max(ans, len(m)) \n            \n        return ans\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1108270082","body":"```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        allWords = collections.Counter(words)\n        wordNum = len(words)\n        wordLen = len(words[0])\n        res = []\n        for i in range(len(s) - wordNum * wordLen + 1):\n            subWords = collections.defaultdict(int)\n            index = i\n            while index < i + wordNum * wordLen:\n                curWord = s[index: index + wordLen]\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\n                    break\n                subWords[curWord] += 1\n                index += wordLen\n            if index == i + wordNum * wordLen:\n                res.append(i)\n        return res\n```\n时间复杂度：O(N*M)\n空间复杂度：O(N)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108174270","body":"```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if head.next == None:\n            return head\n        if head.next.next == None:\n            return head.next\n\n        slow = head.next\n        fast = head.next.next\n\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        if fast.next == None:\n            return slow\n        else:\n            return slow.next\n```\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109211438","body":"快慢指针\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i = 0\n        for j in range(1,len(nums)):\n            if nums[j] == nums[i]:\n                continue\n            else:\n                i = i + 1\n                nums[i] = nums[j]\n        \n        k = i + 1\n\n        return k\n```\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110636350","body":"## 思路\n二分法\n## 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        i = 0\n        j = len(nums) - 1\n        while i <= j:\n            mid = (i + j) // 2\n            if target == nums[mid]:\n                return mid\n            if target > nums[mid]:\n                i = mid + 1\n            if target < nums[mid]:\n                j = mid - 1\n            \n        return i\n```\n## 复杂度\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111877480","body":"```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = collections.deque()\n        for i in range(k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n\n        ans = [nums[q[0]]]\n        for i in range(k, n):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            while q[0] <= i - k:\n                q.popleft()\n            ans.append(nums[q[0]])\n        \n        return ans\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112817800","body":"```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if len(trust) == 0:\n            if n == 1:\n                return 1\n            else:\n                return -1\n        \n        ren = []\n        mayfa = {}\n\n        for a, b in trust:\n            ren.append(a)\n            if b not in mayfa:\n                mayfa[b] = 1\n            else:\n                mayfa[b] += 1\n        \n        ren = set(ren)\n        if n > len(ren) + 1:\n            return -1\n        ls= []\n\n        for x in mayfa:\n            if mayfa[x] == len(ren):\n                ls.append(x)\n        \n        if len(ls) == 0:\n            return -1\n        for c in ls:\n            if c not in ren:\n                return c\n\n        return -1\n\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085303351","body":"## Idea\nScan the array from end to begin. Use an extra variable to record the carry number.\n\n## Code\n```python 3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = k\n        for i in range(len(num) - 1, -1, -1):\n            total = (num[i] + carry)\n            carry = total // 10\n            A = total % 10\n            num[i] = A\n        if carry:\n            return [int(i) for i in str(carry)] + num\n        return num\n                \n```\n\n## Complexity:\nTime: O(N). N = max(len(num), len(k))\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642145","body":"## Idea\nDeque q for the index of character c. For each index i in s check whether abs(i - q[0])>abs(i - q[1]) and q has more than 1 element. If it is, pop the most front element from the q. \n\n## Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = collections.deque()\n        for i in range(len(s)):\n            if s[i] == c:\n                position.append(i)\n        ans = []\n        for i in range(len(s)):\n            if len(position)>1 and abs(i-position[0])>abs(i-position[1]):\n                position.popleft()\n            ans.append(abs(i-position[0]))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894362","body":"## Idea\nSimulation\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cap = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.cap:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n```\n\n## Complexity:\nTime: Increment: O(k.) Others: O(1)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087668420","body":"## Idea\nStack\n\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l=[]\n        for i in s:\n            if i!=']':\n                l.append(i)\n            else:\n                if len(l)==0:\n                    break\n                temp=''\n                while l[-1]!='[':\n                    temp=l.pop()+temp\n                l.pop()\n                temp2=''\n                while len(l)>0 and l[-1].isdigit():\n                    temp2=l.pop()+temp2\n                res=temp*int(temp2)\n                l.append(res)\n        \n        ans=''\n        for i in l:\n            ans+=i\n        return ans\n```\n\n## Compexity:\nTime: O(maxK^Countk * N)\nSpace: O(sum(maxK ^CountK*n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088734659","body":"## Idea\nTwo stacks. One for push, one for peek and pop\n\n## Code\n\n```python\nclass MyQueue:\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n\n    def push(self, x: int) -> None:\n        self.instack.append(x)\n\n    def pop(self) -> int:\n        if not self.outstack:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack.pop()\n\n    def peek(self) -> int:\n        if not self.outstack:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n\n    def empty(self) -> bool:\n        return len(self.instack)==0 and len(self.outstack) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## Complexity:\nSapce: O(N)\nTime: PushL O(1). Pop & peek: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090267640","body":"## Idea\nMonotonic stack. The element in the stack is the largest element of each chunk. Because it's monotonic stack, it ensures the element smaller than current chunk's largest element will be merged into current chunk. In other words, the smallest element of next chunk will not be smaller than current chunk's largest element.\n\n## Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091711239","body":"## Idea\nCircle list's tail to the head, then disconnect the list at the n-k%n-1 node. Return n-k%n node\n\n## Code\n```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n\n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n        # break the ring\n        new_tail.next = None\n        \n        return new_head\n```\n\n## Complexity:\nTime: O(N)\nSpace: o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092847190","body":"## Idea\nIterative\n\n## Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        new_head = None\n        pre, cur, nex = None, head, head.next\n        while nex:\n            tmp = nex.next\n            if pre:\n                pre.next = nex\n                nex.next = cur\n                cur.next = tmp\n            else:\n                new_head = nex\n                nex.next = cur\n                cur.next = tmp\n            if tmp:\n                pre, cur, nex = cur, tmp, tmp.next\n            else:\n                break\n        return new_head\n```\n## Complexity\nTIme: o(N)\nSapce: o(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094161147","body":"## Idea\nTwo pointers. Go through both linkedlists. If one of them reaches the end, change its pointer to the other linkedlist's head. After two turns and both pointers meet at the same node, return it. otherwise, return null\n\n## Code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        d1 = headA\n        d2 = headB\n        r = 0\n        while r<=2:\n            while d1 and d2:\n                if d1 == d2:\n                    return d1\n                d1 = d1.next\n                d2 = d2.next\n            if not d1:\n                d1 = headB\n            if not d2:\n                d2 = headA\n            r+= 1\n        return None\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095086901","body":"## Idea\nTwo pointers. Floyd's Tortoise and Hare\n\n## Code\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if not fast or not fast.next:\n            return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow=slow.next\n        return fast\n            \n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095392507","body":"## Idea\r\nDoublelinked List + hashmap\r\n\r\n## Code\r\n```python\r\nclass DLList:\r\n    def __init__(self):\r\n        self.key = 0\r\n        self.val = 0\r\n        self.pre = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    \r\n    def _add_node(self, node):\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n    \r\n    def _delete_node(self, node):\r\n        pre = node.pre\r\n        nex = node.next\r\n        \r\n        pre.next = nex\r\n        nex.pre = pre\r\n    \r\n    def _move_to_head(self, node):\r\n        self._delete_node(node)\r\n        self._add_node(node)\r\n    \r\n    def _pop_tail(self):\r\n        pre = self.tail.pre\r\n        self._delete_node(pre)\r\n        return pre\r\n\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        self.cache = {}\r\n        self.head, self.tail = DLList(),DLList()\r\n        \r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        node = self.cache.get(key, None)\r\n        if not node:\r\n            return -1\r\n        self._move_to_head(node)\r\n        return node.val\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        node = self.cache.get(key, None)\r\n        if not node:\r\n            newNode = DLList()\r\n            newNode.key = key\r\n            newNode.val = value\r\n            self.cache[key] = newNode\r\n            self._add_node(newNode)\r\n            if len(self.cache) > self.size:\r\n                del self.cache[self._pop_tail().key]\r\n\r\n        else:\r\n            node.val = value\r\n            self._move_to_head(node)\r\n```\r\n\r\n## Complexity:\r\nTime: O(1)\r\nSpace: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097112234","body":"## Idea\nDFS\n\n## Code\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n\n## Complexity\nTime: O(N)\nSpace: O(log N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098582988","body":"## Idea\nDFS + Preorder\n\n## Code\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p:\n            return not q\n        if not q:\n            return not p\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(log N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099379748","body":"## Idea\nDfs + preOrder\n\n## Code\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        def dfs(root, pre):\n            nonlocal ans\n            if not root.left and not root.right:\n                ans += pre*10 + root.val\n                return\n            if root.left:\n                dfs(root.left, pre*10 + root.val)\n            if root.right:\n                dfs(root.right, pre*10+root.val)\n        dfs(root, 0)\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(logN）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100450780","body":"## Idea\nBFS\n\n## Code\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        stack = collections.deque()\n        stack.append(root)\n        ans = root.val\n        while stack:\n            l = len(stack)\n            ans = stack[0].val\n            for _ in range(l):\n                cur = stack.popleft()\n                if cur.left:\n                    stack.append(cur.left)\n                if cur.right:\n                    stack.append(cur.right)\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(H). H the widest layer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100703832","body":"## Idea\nDFS+Preorder\n\n## Code\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"N\"\n        return str(root.val)+\"#\"+self.serialize(root.left)+\"#\"+self.serialize(root.right)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        array = data.split(\"#\")\n        self.i = 0\n        if array[0] == \"N\":\n            return None\n        def dfs():\n            if array[self.i] == \"N\":\n                self.i+=1\n                return None\n            if self.i>=len(array):\n                return\n            node = TreeNode(int(array[self.i]))\n            self.i+=1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100913033","body":"## Idea\nBFS\n\n## Code\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        seen = collections.defaultdict(list)\n        left, right = 0, 0\n        depth = 0\n        def bfs(root, row, col):\n            nonlocal left, right, depth\n            stack = collections.deque()\n            stack.append((root, 0, 0))\n\n            while stack:\n                l = len(stack)\n                depth+=1\n                for _ in range(l):\n                    cur, row, col = stack.popleft()\n                    left = min(left, col)\n                    right = max(right, col)\n                    seen[(col,row)].append(cur.val)\n                    if cur.left:\n                        stack.append((cur.left, row+1, col-1))\n                    if cur.right:\n                        stack.append((cur.right, row+1, col+1))\n        bfs(root, 0, 0)\n        ans = [[]for _ in range(right - left+1)]\n        for i in range(left, right+1):\n            for j in range(depth):\n                ans[i-left].extend(sorted(seen[(i,j)]))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101567482","body":"## Idea\nHashMap\n\n## Code\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        seen = {}\n        for i in range(len(nums)):\n            rest = target - nums[i]\n            if rest not in seen:\n                seen[nums[i]] = i\n            else:\n                return [i, seen[rest]]\n        return []\n```\n\n## Complexity:\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103351887","body":"## Idea\nHeap + Hashmap\n\n##Code\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        freq = collections.Counter(nums)\n        for f in freq:\n            if len(heap) < k:\n                heapq.heappush(heap, (freq[f], f))\n            else:\n                if freq[f] > heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (freq[f], f))\n        return [h[1] for h in heap]\n```\n\n## Complexity:\nTime: O(N log K)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104575879","body":"## Idea\nHashmap\n\n## Code\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n```\n\n## Complexity:\nTime: O(N^2)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105705576","body":"## Idea\nSliding window + Hashmap. The left side of the sliding window will be the index of most right repeated char in current window. Every time we meet a repeat element, we will compare the left boundary of current sliding window with the last index of that repeated char.\n\n## Code\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        index = collections.defaultdict(int)\n        ans = 0\n        left = -1\n        if not s:\n            return ans\n        for i in range(len(s)):\n            char = s[i]\n            if char in index:\n                left = max(left, index[char])\n            ans = max(ans, i - left)\n            index[char]=i\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107072555","body":"## Code\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(s)\n        k = len(words)\n        word_length = len(words[0])\n        substring_size = word_length * k\n        word_count = collections.Counter(words)\n        \n        def sliding_window(left):\n            words_found = collections.defaultdict(int)\n            words_used = 0\n            excess_word = False\n            \n            # Do the same iteration pattern as the previous approach - iterate\n            # word_length at a time, and at each iteration we focus on one word\n            for right in range(left, n, word_length):\n                if right + word_length > n:\n                    break\n\n                sub = s[right : right + word_length]\n                if sub not in word_count:\n                    # Mismatched word - reset the window\n                    words_found = collections.defaultdict(int)\n                    words_used = 0\n                    excess_word = False\n                    left = right + word_length # Retry at the next index\n                else:\n                    # If we reached max window size or have an excess word\n                    while right - left == substring_size or excess_word:\n                        # Move the left bound over continously\n                        leftmost_word = s[left : left + word_length]\n                        left += word_length\n                        words_found[leftmost_word] -= 1\n\n                        if words_found[leftmost_word] == word_count[leftmost_word]:\n                            # This word was the excess word\n                            excess_word = False\n                        else:\n                            # Otherwise we actually needed it\n                            words_used -= 1\n                    \n                    # Keep track of how many times this word occurs in the window\n                    words_found[sub] += 1\n                    if words_found[sub] <= word_count[sub]:\n                        words_used += 1\n                    else:\n                        # Found too many instances already\n                        excess_word = True\n                    \n                    if words_used == k and not excess_word:\n                        # Found a valid substring\n                        answer.append(left)\n        \n        answer = []\n        for i in range(word_length):\n            sliding_window(i)\n\n        return answer\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107541826","body":"## Idea\nPredix sum + HashMap\n\n## Code\n```python\nclass Solution:\n    def solve(self, nums, k):\n        s = sum(nums)\n        if s%k==0:\n            return 0\n        dic = {0:-1}\n        mod = s%k\n        total = 0\n        ans = len(nums)\n        for i in range(len(nums)):\n            total += nums[i]\n            cur = total % k\n            target = (cur -mod +k)%k\n            if target in dic:\n                ans = min(ans, i - dic[target])\n            dic[cur] = i\n        return -1 if ans == len(nums) else ans\n```\n## Complexity:\nTime: O(N)\nSpace: O(min(N, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107900383","body":"## Idea\nTwo pointers\n\n## Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        slow, fast = head, head.next\n        while fast:\n            slow = slow.next\n            fast = fast.next.next if fast and fast.next else None\n        return slow\n```\n\n## Complexty:\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1108945737","body":"## Idea\nTwo pointers\n\n## Code\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n<2:\n            return n\n        i, j = 0, 1\n        while j<len(nums):\n            while j < len(nums) and nums[i] == nums[j]:\n                j += 1\n            if j >= len(nums):\n                break\n            nums[i+1]= nums[j]\n            i+=1\n            j+=1\n        return i+1\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111089004","body":"## Idea\nBinary Seaarch\n\n## Code\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if target < nums[0]:return 0\n        if target > nums[-1]:return len(nums)\n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = (left + right)//2\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111533401","body":"## Idea\nMonotonic Array\n\n## Code\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        record = collections.deque()\n        ans = []\n        i, j = 0, k-1\n        for m in range(k):\n            while record and nums[m]>record[-1][1]:\n                record.pop()\n            record.append((m, nums[m]))\n        ans.append(record[0][1])\n        while j < len(nums)-1:\n            i += 1\n            j += 1\n            while record and i>record[0][0]:\n                record.popleft()\n            while record and nums[j]>record[-1][1]:\n                record.pop()\n            record.append((j, nums[j]))\n            ans.append(record[0][1])\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112548597","body":"## Idea\nGraph. Check the indegrees and outdegrees.\n\n## Code\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if n == 1 and not trust:\n            return 1\n        inDegree = collections.defaultdict(set)\n        outDegree = collections.defaultdict(set)\n        maxOut = [0, 1]\n        for i in trust:\n            s, e = i\n            inDegree[e].add(s)\n            outDegree[s].add(e)\n            if len(inDegree[e])>maxOut[0]:\n                maxOut = [len(inDegree[e]), e]\n        if len(outDegree) != n-1 or len(inDegree[maxOut[1]]) != n-1:\n            return -1\n        return maxOut[1]\n```\n## Complexity:\nTime: O(edge)\nSpace: O(nodes * nodes)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113642651","body":"## idea\nGraph + DFS\n\n## Code\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        G = collections.defaultdict(list)\n        for f, t in dislikes:\n            G[f].append(t)\n            G[t].append(f)\n        Groups = {}\n        def dfs(root, label):\n            Groups[root] = label\n            for nei in G[root]:\n                if nei in Groups and Groups[nei] == label:\n                    return False\n                elif nei not in Groups and not dfs(nei, -label):\n                    return False\n            return True\n            \n        for i in range(1, n+1):\n            if i not in Groups and not dfs(i, 1):\n                return False\n        return True\n```\n\n## Complexity:\nTime: O(V+E)\nSpace: O(V^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085327382","body":"> 实现思路\n\n实际上就是一个模拟人工加法的过程\n\n> 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)\n\n> 代码实现\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> ans = new ArrayList<>();\n        num[n-1] += k;\n        int t  = 0;// 用 t 来表示进位 \n        for(int i = n - 1; i >=0 ; i--) {\n            // 比如说 now = 11， ans 的当前位就是 1，进位为 10\n            int now = num[i] + t; // 当前位 + 进位之后的结果\n            ans.add(now % 10);// ans 中当前位的结果是 now 的个位\n            t = now / 10; // 进位就是 除了个位 以上的为\n        }\n        if(t > 0){\n            while(t != 0) {\n                ans.add(t % 10);\n                t /= 10;\n            }\n        }\n        Collections.reverse(ans); \n        return ans;\n    }\n}\n\n```\n> [高精度加法](https://www.acwing.com/problem/content/description/793/)\n> Acwing\n\n```markdown\n给定两个正整数（不含前导 0），计算它们的和。\n\n # 输入格式\n \n共两行，每行包含一个整数。\n\n # 输出格式\n共一行，包含所求的和。\n\n# 数据范围\n1≤ 整数长度 ≤100000\n```\n\n```c\n#include<iostream>\n#include<cstring>\n#include<vector> \nusing namespace std;\nvector<int> add(vector<int> A,vector<int> B) {\n    if(A.size() < B.size()) return add(B,A);\n    vector<int> C;\n    int t = 0;// 表示进位\n    for(int i = 0 ;i < A.size(); i++) {\n        t += A[i];\n        if(i < B.size()) t+= B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    if(t > 0) {\n        while(t !=0 ) C.push_back(t % 10), t/=10;\n    }\n    return C;\n    \n}\nint main() {\n    string a,b;\n    vector<int> A,B;\n    cin>>a>>b;\n    for(int i = a.size()-1; i >=0 ;--i) {\n        A.push_back(a[i] - '0');\n    }\n    for(int i = b.size() - 1; i >= 0; --i) {\n        B.push_back(b[i] - '0');\n    }\n    auto C = add(A,B);\n    for(int i = C.size() - 1; i >= 0; i--){\n        cout<<C[i];\n    }\n    return 0;\n    \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086474703","body":"[原题链接](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n> 算法一\n1. 时间复杂度为：O(n ^ 2)\n2. 思路：暴力枚举，对于每个位置都向左右两个方向进行搜索，判断每个位置上的字符是否是c，如果是，进行相应的计算即可\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++){\n            int left = i;\n            int right = i+1;\n            int res  = Integer.MAX_VALUE;\n            while(left >= 0) {\n                if(s.charAt(left) == c) res = Math.min(res, Math.abs(i - left));\n                left --;\n            }\n            while(right < n) {\n                if(s.charAt(right) == c) res = Math.min(res, Math.abs(i - right));\n                right ++;\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n}\n```\n> 算法二\n \n\n  - 时间复杂度：O(n)\n-  思路： 在算法一中，对于每个位置我们都要向左 和向右搜索距离这个位置最近的c，这种算法的时间复杂度很高，并且在做很多无用功。对于每个位置，我们如果说知道了他的前一位，距离最近的c    的位置，我们就不需要每个位置都进行枚举\n-  通过这种思想，我们只需要向左扫一遍，记住每个位置上，左边距离它最近的c的距离；在向右扫一遍，记住每个位置上，右边距离它最近的c的位置，就行。\n- 这里pre 除以2 的目的是为了，防止越界 \n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int pre = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for(int i = n -1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i],pre- i);\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086787651","body":"[原题链接](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n@[toc]\n# 思路\n题目中已经确切的告诉了我们，数组中会放入多少个元素，这种情况并且只有添加操作，这种情况之下，使用数组模拟效率会更高一点。\n# 代码\n> 用数组模拟栈,击败100%\n```java\nclass CustomStack {\n    private int[] stack;\n    private int tt;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(tt == stack.length) return;\n        stack[tt++] = x;\n    }\n    \n    public int pop() {\n        if(tt == 0) return -1;\n        return stack[--tt];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < tt; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n#  用数组来模拟栈\n> 用一个数组来表示栈结构，并且加一个索引来方便操作,这里的 tt 指向的是 下一次要放的位置 \n\n```c\nconst int N  = 10010;\nint stack[N];\nint tt;\n// 向栈中添加元素\nstack[tt++] = x;\n// 弹出栈顶元素\n--tt;\n// 判断栈是否是空\ntt == 0;\n// 栈顶\nint top = tt;\nstack[top--];\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087502634","body":"```\nclass Solution {\n    public String decodeString(String s) {\n        //定义结果\n        StringBuffer buffer = new StringBuffer();\n        //用来 定义字符栈\n        LinkedList<String> listString = new LinkedList<>();\n        // 用来定义数字栈\n        LinkedList<Integer> listInt = new LinkedList<>();\n        for(int i = 0;i<s.length();){\n            if(s.charAt(i)!=']'){\n                char a = s.charAt(i);\n                if(a>'9' || a<'0'){\n                    //进入字符栈中\n                    listString.add(a+\"\");\n                    i++;\n                }else{\n                    //就是数字，进入数字栈中\n                    int j  = i+1;\n                    int tem = a-'0';\n                    while(s.charAt(j)<='9' && s.charAt(j)>='0' && j<s.length()){\n                        tem = tem *10 + (s.charAt(j)-'0');\n                        j++;\n                    }\n                    i = j;\n                    listInt.add(tem);\n                }\n            }else{\n                //用来取出字符栈中的元素\n                String temString = new String();\n                //用来拿出栈顶的数字\n                int temInt = listInt.getLast();\n                listInt.removeLast();\n                // 循环拿出 字符\n                while(!listString.isEmpty() && !listString.getLast().equals(\"[\")){\n                    temString = listString.getLast()+temString;\n                    listString.removeLast();\n                }\n                listString.removeLast();\n                StringBuffer sb = new StringBuffer();\n                for(int k = 1;k<=temInt;k++){\n                    sb.append(temString);\n                }\n                //如果说listInt不是空的，就将结果压在listString栈中\n                if(!listInt.isEmpty()){\n                    listString.add(sb.toString());\n                }else{\n                    //反之，加到结果中\n                    String ss = \"\";\n                    while(!listString.isEmpty()){\n                        ss = listString.getLast()+ss;\n                        listString.removeLast();\n                    }\n                    buffer.append(ss);\n                    buffer.append(sb);\n                }\n                i++;\n            }\n        }\n        if(!listString.isEmpty()){\n            for(int i =0;i<listString.size();i++){\n                buffer.append(listString.get(i));\n            }\n        }\n        return buffer.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088670739","body":"\n# 思路\n栈的特点是先进后出， 队列的特点是先进先出。 我们可以设计两个栈， 一个栈`stackPush`用来存放数据， 另一个栈`stackPop`用来存放`stackPush`栈中元素的倒序结果， 利用栈的特点，删除`stackPop`的栈顶， 就相当于进行了出队操作。 比如说：\n\n- `stackPush`: 栈底 1 2 3 4 5  栈头\n- `stackPop`:  栈底 5 4 3 2 1   栈头\n\n按照队列的顺序` 1 2 3 4 5 `。出队的话，就是出 1，相当于就是 `stackPop`的队头。\n\n\n\n> 向栈中添加元素\n\n- 向`stackPush`中添加即可\n\n> 删除队头元素\n - 当`stackPop`中仍然有元素的时候，直接返回头即可\n - 如果上一步没有执行，说明`stackPop`中没有元素，先判断一下 ，有没有向`stackPush`中添加元素，如果说没有，返回 -1\n - 最后，说明`stackPush`中有元素，但是没有倒在`stackPop`中，倒入\n - 返回 `stackPop`的栈顶\n\n# 代码\n```java\nclass MyQueue {\n    private LinkedList<Integer> stackPush;\n    private LinkedList<Integer> stackPop;\n    private int size;\n    public MyQueue() {\n        size = 0;\n        stackPop = new LinkedList<>();\n        stackPush = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        size++;\n        stackPush.add(x);\n    }\n    \n    public int pop() {\n        size--;\n        //移除队列开头的元素\n        if(!stackPop.isEmpty()) return stackPop.removeLast();\n        if(stackPush.isEmpty()) return -1;\n        while(!stackPush.isEmpty()) {\n            stackPop.addLast(stackPush.removeLast());\n        }\n        return stackPop.removeLast();\n    }\n    \n    public int peek() {\n        // 返回队列开头的元素\n        if(!stackPop.isEmpty()) return stackPop.getLast();\n        if(stackPush.isEmpty()) return -1;\n        while(!stackPush.isEmpty()) {\n            stackPop.add(stackPush.removeLast());\n        }\n        return stackPop.getLast();\n\n    }\n    \n    public boolean empty() {\n        return size == 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090160716","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        if(arr.length == 0 || arr == null){\n            return 0;\n        }\n        LinkedList<Integer> stack = new LinkedList<>();\n        for(int i = 0; i < arr.length; i++){\n            int temp  = -1;\n            while(!stack.isEmpty() && stack.getLast() > arr[i]){\n                temp = Math.max(temp,stack.getLast());\n                stack.removeLast();\n            }\n            if(temp !=-1){\n                stack.add(temp);\n            }else{\n                stack.add(arr[i]);\n            }\n        }\n        return stack.size();      \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091713641","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || k==0  || head.next==null){\n            return head;\n        }\n        int num = 1;\n        // 形成一个环形链表\n        ListNode headTem = new ListNode();\n        headTem = head;\n        //寻找未节点\n        while(headTem.next!=null){\n            headTem= headTem.next;\n            num++;\n        }\n        if(num == k){\n            return head;\n        }\n        //形成 一个循环链表\n        headTem.next = head;\n  \n        ListNode l1 = head;\n        for(int i =1;i<=num-1-(k%num);i++){\n            l1 = l1.next;\n        }\n        ListNode res = l1.next;\n        l1.next = null;\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093006180","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094067670","body":"```java\nclass Solution {\n    static TreeNode build(int[] nums, int l, int r)\n    {\n        if(l > r) return null;\n        int k = (l + r) / 2;\n        TreeNode root = new TreeNode(nums[k]);\n        root.left = build(nums, l, k - 1);\n        root.right = build(nums, k + 1, r);\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int n = nums.length;\n        return build(nums,0,n - 1);\n    }\n    public TreeNode sortedListToBST(ListNode head) {\n        int k = 0;\n        ListNode p = head;\n        while(p != null)\n        {\n            k ++;\n            p = p.next;\n        }\n        int[] nums = new int[k];\n        p = head;\n        int t = 0;\n        while(p != null)\n        {\n            nums[t ++] = p.val;\n            p = p.next;\n        }\n        return sortedArrayToBST(nums);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094289140","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n\n        ListNode ha = headA;\n        ListNode hb = headB;\n\n        while(ha != hb) {\n            if(ha == null && hb == null) return null;\n            ha = ha == null ? headB:ha.next;\n            hb = hb == null ? headA:hb.next;\n        }\n        return ha;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094450441","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) return null;\n\n        ListNode s = head;\n        ListNode f = head.next;\n\n        while(f != null) {\n            s = s.next;\n            f = f.next;\n            if(f == null) return null;\n            f = f.next;\n            if(s == f) {\n                s = head;\n                f = f.next;\n                while(s != f) {\n                    s = s.next;\n                    f = f.next;\n                }\n                return s;\n            }\n        }\n        return null;\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095912122","body":"```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097483454","body":"```java\nclass Solution {\n    public static int dfs(TreeNode node) {\n        // 定义一个变量，记录答案，结果为求最大值，答案赋值为最小值\n        int res = Integer.MIN_VALUE;\n        // 如果说该节点为空，返回 0\n        if(node == null) return 0;\n        // 如果说左子树不为空，左子树上深度就是 1 + 左子树的深度\n        if(node.left != null) res = Math.max(res,1+dfs(node.left));\n        // 如果说右子树不为空，右子树上深度就是 1 + 右子树的深度\n        if(node.right != null) res = Math.max(res,1+dfs(node.right));\n        // 如果说初始值没有被改变过，说明只有该节点一个节点\n        if(res == Integer.MIN_VALUE) return 1;\n        // 返回结果\n        return res;\n    }\n    public int maxDepth(TreeNode root) {\n        return dfs(root);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099106404","body":"```java\nclass Solution {\n    public boolean dfs(TreeNode p,TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null && q != null) return false;\n        if(p != null && q == null) return false;\n        if(p.val != q.val) return false;\n        return dfs(p.left,q.left) && dfs(p.right,q.right);\n\n    }\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        return dfs(p,q);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100125998","body":"```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root,0);\n    }\n    public int dfs(TreeNode root,int res){\n        if(root == null){\n            return 0;\n        }\n        res = res*10+root.val;\n        if(root.left == null && root.right==null){\n            return res;\n        }else{\n            return dfs(root.left,res)+dfs(root.right,res);\n        }\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100636229","body":"```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        LinkedList<TreeNode> list = new LinkedList<>();\n        if(root == null) return -1;\n        list.add(root);\n        int res = root.val;\n        int floor = 1;\n        while(!list.isEmpty()) {\n            for(int i = 0;i < floor; i++) {\n                 TreeNode node = list.getFirst();\n                 list.removeFirst();\n                 if(i == 0) res = node.val;\n                 if(node.left != null) list.add(node.left);\n                 if(node.right != null) list.add(node.right);\n            }\n            floor = list.size();\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100894772","body":"```java\npublic class Codec {\n    //根据先序遍历的顺序，每次只拿第一元素作为根\n    static TreeNode dfs(List<String> list)\n    {\n        if(list.get(0).equals(\"#\"))\n        {\n            list.remove(0);\n            return null;\n        }\n\n        TreeNode root = new TreeNode(Integer.parseInt(list.get(0)));\n        list.remove(0);\n        root.left = dfs(list);\n        root.right = dfs(list);\n        return root;\n    }\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null)\n            return \"#\";\n\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] s = data.split(\",\");\n        List<String> list = new ArrayList<String>(Arrays.asList(s));\n        return dfs(list);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101396170","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102460689","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        int n = nums.length;\n        for(int i = 0; i < n; i++) {\n            int tem = target - nums[i];\n            if(map.containsKey(tem)) {\n                res[0] = map.get(tem);\n                res[1] = i;\n                return res;\n            } else {\n                map.put(nums[i],i);\n            }\n        }\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103893707","body":"```java\nclass Solution {\n   public int[] topKFrequent(int[] nums, int k) {\n        int[] res = new int[k];    // 结果数组\n        Map<Integer, Integer> map = new HashMap();\n        // 统计数组中各元素出现的次数\n        for(int num : nums){\n            if(map.containsKey(num)){\n                map.put(num, map.get(num) + 1);\n            }else{\n                map.put(num, 1);\n            }\n        }\n\n        int maxTimes = 0;    // 出现最多的元素的出现次数\n        // 找出出现次数最多的元素出现的次数\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n            if(entry.getValue() > maxTimes){\n                maxTimes = entry.getValue();\n            }\n        }\n\n        // 按出现次数从大到小添加到结果数组\n        while(k > 0){\n            for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n                if(entry.getValue() == maxTimes){\n                    res[k - 1] = entry.getKey();\n                    k--;\n                }\n            }\n            maxTimes--;\n        }\n\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105384658","body":"> # 447. 回旋镖的数量\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/number-of-boomerangs/\r\n> \r\n> ## 前置知识\r\n> * 哈希表\r\n> * 两点间距离计算方法\r\n> * 排列组合基础知识\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定平面上  n 对不同的点，“回旋镖” 是由点表示的元组  (i, j, k) ，其中  i  和  j  之间的距离和  i  和  k  之间的距离相等（需要考虑元组的顺序）。\r\n> \r\n> 找到所有回旋镖的数量。你可以假设  n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。\r\n> \r\n> 示例:\r\n> \r\n> \r\n> 输入:\r\n> [[0,0],[1,0],[2,0]]\r\n> \r\n> 输出:\r\n> 2\r\n> \r\n> 解释:\r\n> 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\r\n> ```\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int ret = 0 ;\r\n        int n = points.length ;        \r\n        for (int i = 0 ; i < n ; ++i) {\r\n            HashMap<Integer,Integer> map = new HashMap<>();\r\n            for (int j = 0 ; j < n ; ++j) {\r\n               if (j == i) continue ;\r\n               int d = get(points[i], points[j]) ;\r\n               int cnt = map.getOrDefault(d, 0) + 1 ;\r\n               map.put(d, cnt) ;\r\n            }\r\n            for (int k : map.keySet()) {\r\n                int val = map.get(k) ;\r\n                if (val >= 2) {\r\n                    ret += val * (val - 1)  ;\r\n                }\r\n            }\r\n        }\r\n        return ret ;        \r\n    }\r\n\r\n    int get (int [] a, int [] b){\r\n        int d1 = a[0] - b[0] ;\r\n        int d2 = a[1] - b[1] ;\r\n        return d1 * d1 + d2 * d2 ;\r\n\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106588842","body":"```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int res = 0;\n        int left = 0;\n        int n = s.length();\n        Map<Character,Integer> map = new HashMap<>();\n        for(int right = 0; right < n; right++) {\n            if(map.containsKey(s.charAt(right))) {\n                left = Math.max(left,map.get(s.charAt(right)) + 1);\n            }\n            map.put(s.charAt(right),right);\n            res = Math.max(res,right - left + 1);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107070159","body":"```java\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\nclass Solution {\npublic:\n    unordered_map<string, int> map;\n    int totalLen;\n    int oneWordLen;\n    int finalProgress;\n    vector<int> res;\n    vector<int> findSubstring(string s, vector<string>& words) {\n        for(string& str : words)\n            map[str]++;\n        \n        oneWordLen = words[0].size();\n        totalLen   = oneWordLen * words.size();\n        finalProgress = words.size();\n\n        if(s.size() < totalLen)\n            return res;\n\n        //to try to constrcut the target string\n        for(int i = 0; i <= s.size() - totalLen; i++){\n            dfs(s, i, 0);\n        }\n\n        return res;\n    }\n\n    void dfs(string& s, int curPos, int progress){\n        if(progress == finalProgress){\n            res.push_back(curPos - totalLen);\n            return;\n        }\n\n        string frac = s.substr(curPos, oneWordLen);\n\n        if(map[frac] == 0)\n            return;\n        \n        map[frac]--;\n        dfs(s, curPos + oneWordLen, progress + 1);\n        map[frac]++;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107678026","body":"```java\nimport java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n        for (int n : nums)\n            tar += n;\n        \n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108014523","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        Map<Integer,ListNode> map = new HashMap<>();\n        ListNode tem = head;\n        int index = 0;\n        while(tem != null) {\n            map.put(index++,tem);\n            tem = tem.next;\n        }\n        return map.get(index >> 1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109923034","body":"···java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        int k = 0;\n        for(int i = 0;i < n;i ++)\n        { \n            int j = i;\n            while(j < n && nums[j] == nums[i]) j ++;\n\n            nums[k ++] = nums[i];\n            i = j - 1;\n        }\n        return k;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1109983960","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int r = nums.length;\n        if(r == 0) return 0;\n        int l = 0;\n        while(l < r) {\n            int mid = l + r >>1;\n            if(nums[mid] >= target) {\n                r = mid;\n            }else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111679436","body":"```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length < k) return new int[]{};\n        int hh = 0 ;\n        int tt  = -1;\n        int n = nums.length;\n        int[] q = new int[n+1];\n        List<Integer> list = new ArrayList<>();\n        for(int i = 0 ; i < n ;i ++){\n            if(hh <= tt && i - k + 1 > q[hh]) hh++;\n            while(hh <= tt && nums[q[tt]] <= nums[i]) tt--;\n            q[++tt] = i;\n            if(i >= k-1) list.add(nums[q[hh]]);\n        }\n        int[] res = new int[list.size()];\n        for(int i = 0 ;i < list.size(); i++) res[i] = list.get(i);\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112865328","body":"```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegrees = new int[n + 1];\n        int[] outDegrees = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tonylee017":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085338085","body":"#### 思路\n\n直接把k加到num[i]上，保留个位数在num[i]，k取为其他位数。\n\n#### 代码实现\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088864782","body":"#### 思路\n利用双栈进行模拟队列，stack_push作为输入的栈，保存所有元素，stack_pop作为输出的栈。\n\n#### 代码\nclass MyQueue:\n\n    def __init__(self):\n        # 使用两个栈. 一个用来push stack_push, 一个用来pop stack_pop.\n        self.stack_push = []\n        self.stack_pop = []\n\n    def push(self, x: int) -> None:\n        self.stack_push.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return -1\n        self.peek()\n        return self.stack_pop.pop()\n\n    def peek(self) -> int:\n        if not self.stack_pop:\n            while self.stack_push:\n                self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop[-1]\n\n    def empty(self) -> bool:\n        return not self.stack_push and not self.stack_pop\n\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090416578","body":"#### 思路\n遍历一遍数组，动态判断到当前数字num为止最多能分出多少排序块，并保存每个排序块的最大值head。每遍历到下个数字num，动态判断前面所有的排序块是否成立，并更新所有排序块。\n\n#### 代码\n``` python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]:\n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n#### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094071438","body":"#### 解题思路\n先获取根节点，再利用分治方法构造左右子树。\n#### 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMid(left,right):\n            fast = slow = left\n            while fast!=right and fast.next!=right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n       \n        def buildTree(left,right):\n            if left == right:\n                return None\n            # 寻找根节点\n            mid = getMid(left,right)\n            # 构造根节点\n            root = TreeNode(mid.val)\n            # 构造左子树\n            root.left = buildTree(left,mid)\n            # 构造右子树\n            root.right = buildTree(mid.next,right)\n            return root\n        \n        return buildTree(head,None)\n```\n#### 复杂度分析\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094159819","body":"#### 解题思路\n使用双指针的方法。\n#### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pA,pB = headA,headB\n        if pA == pB: return pA\n        while pA!=pB:\n            pA = pA.next\n            pB = pB.next\n            # 同时遍历完\n            if not pA and not pB:\n                return None\n            if not pA:\n                pA = headB\n            if not pB:\n                pB = headA\n        return pA\n```\n\n#### 复杂度分析\n- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094933698","body":"#### 解题思路\n使用双指针法求解\n#### 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        p =  head\n        while p != slow:\n            p = p.next\n            slow = slow.next\n        return p\n```\n#### 复杂度分析\n- 时间复杂度分析：O(n)\n- 空间复杂度分析：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096313989","body":"#### 思路\n双向链表+哈希表\n#### 代码\n```python\nclass DlinkedNode:\n    def __init__(self,key = 0,value = 0):\n        # 双向链表的结点\n        self.key = key  # 结点在cache的键\n        self.value = value \n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict() # 缓存\n        # 利用伪头尾结点构建双链表\n        self.head = DlinkedNode() \n        self.tail = DlinkedNode()\n        # 连接伪头伪尾结点\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0 #用于对比缓存容量\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 获取对应键的结点\n        node = self.cache[key]\n        # 移动到头结点处\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 加入新节点\n            node = DlinkedNode(key,value)\n            self.cache[key] = node\n            self.addToHead(node) #移动到结点头\n            self.size += 1\n\n            # 超出容量，删除双向链表尾结点\n            if self.size > self.capacity:\n                removed = self.removeTail() #获取删除的结点\n                self.cache.pop(removed.key) #删除在cache的信息\n                self.size -= 1\n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)  # 移动到头结点处\n    \n    def addToHead(self,node):\n        node.prev = self.head\n        self.head.next.prev = node\n        node.next = self.head.next\n        self.head.next = node\n\n    def removeNode(self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def moveToHead(self,node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev #删除伪尾结点前的一个结点，注意不是删除伪尾结点\n        self.removeNode(node)\n        return node\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n#### 复杂度分析\n- 时间复杂度：O(1)\n- 空间复杂度：O(capacity)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098632771","body":"#### 思路\n对两个二叉树同时进行深度优先搜索，递归地判断两个二叉树是否相同。\n#### 代码\n``` python\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val == q.val:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n        else:\n            return False\n```\n#### 复杂度分析\n- 时间复杂度分析：O(min(m,n))\n- 空间复杂度分析：O(min(m,n))，其中m和n分别是两个二叉树的节点数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099790081","body":"#### 思路\n利用深度优先搜索对二叉树进行前序遍历，到达叶子结点的时候开始累加。\n#### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        if not root:return 0\n        res = 0\n        def dfs(root,num):\n            if not root: return\n            num = num * 10 + root.val\n            nonlocal res\n            if not root.left and not root.right:\n                res += num\n                return \n            dfs(root.left,num)\n            dfs(root.right,num)\n\n        dfs(root,0)\n        return res\n```\n#### 算法复杂度分析\n- 时间复杂度：O(n)，其中n是二叉树的节点个数。对每个节点访问一次。\n- 空间复杂度：O(n)，空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100698365","body":"#### 思路\ndfs+递归\n#### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        global max_level\n        max_level = 0\n        global left\n        left = 0\n        def dfs(root,level):\n            if not root: return\n            global max_level\n            global left\n            if level > max_level:\n                left = root.val\n                max_level = level\n            dfs(root.left,level+1)\n            dfs(root.right,level+1)\n        dfs(root,1)\n        return left\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，n为结点数","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100898417","body":"### 思路\n深度优先搜索+递归\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'null'\n        left = self.serialize(root.left)\n        right = self.serialize(root.right)\n        return str(root.val) + ',' + left + ',' + right\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data = data.split(',')\n        node = self.bulidTree(data)\n        return node\n    \n    def bulidTree(self,data):\n        val = data.pop(0)\n        if val == 'null':\n            return None\n        Node = TreeNode(val)\n        Node.left = self.bulidTree(data)\n        Node.right = self.bulidTree(data)\n        return Node\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101032647","body":"### 思路\n从根节点开始，对整棵树进行一次遍历（深度优先搜索），在遍历的过程中使用数组nodes记录下每个节点的信息，即行号row，列号col以及值value。然后按照col为第一关键字升序，row为第二关键字升序，value为第三关键字升序，对所有的节点进行排序。最后对nodes进行一次遍历，把同一列的结点放在同一个数组中。\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        # 遍历记录各节点的位置信息\n        nodes = list()\n        def dfs(node,row,col):\n            if not node: return\n            nodes.append((col,row,node.val))\n            dfs(node.left,row+1,col-1)\n            dfs(node.right,row+1,col+1)\n        dfs(root,0,0)\n        # 遍历nodes\n        nodes.sort()\n        res,lastcol = list(),float('-inf')\n        for col,row,value in nodes:\n            if col != lastcol:\n                lastcol = col\n                res.append(list())\n            res[-1].append(value)\n        return res\n```\n### 复杂度分析\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102344928","body":"### 思路\n- 方法一：循环穷举\n- 方法二：哈希表\n### 代码\n```python\n# 方法一：\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        res = []\n        if not nums:\n            return res\n        for i in range(len(nums)):\n            if target - nums[i] in nums:\n                j = nums.index(target - nums[i])\n                if j != i:\n                    res.append(i)\n                    res.append(j)\n                    return res\n# 方法二：\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        if not nums: return []\n        hashTable = dict()\n        for i,num in enumerate(nums):\n            if target - num in hashTable:\n                return [i,hashTable[target - num]]\n            hashTable[num] = i\n        return []\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104080382","body":"### 思路\n- Map+排序\n### 代码\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        hashTable = dict()\n        for i in range(len(nums)):\n            if nums[i] in hashTable:\n                hashTable[nums[i]] += 1\n            else:\n                hashTable[nums[i]] = 1\n        num_list = sorted(hashTable.items(),key = lambda x:-x[1])\n        return [temp[0] for temp in num_list][:k]\n```\n### 复杂度分析\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104659680","body":"### 思路\n哈希表+穷举\n### 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for p in points:\n            count = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0])**2 + (p[1] - q[1])**2\n                count[dis] += 1\n            for m in count.values():\n                res += m*(m-1)\n        return res\n```\n### 复杂度分析\n- 时间复杂度：O(n^2) \n- 空间复杂度：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105978847","body":"### 思路\n- 穷举+hash\n### 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ## 暴力循环+hash集合\n        res,left = 0,0\n        hash = set()\n        for i in range(len(s)):\n            if s[i] not in hash:\n                hash.add(s[i])\n            else:\n                res = max(len(hash),res)\n                while True:\n                    hash.remove(s[left])\n                    # 循环删除，直至删掉重复的元素\n                    left += 1\n                    if s[i] not in hash:\n                        hash.add(s[i])\n                        break\n        return max(res,len(hash))\n```\n### 复杂度分析\n- 时间复杂度：O(n)，n为字符串长度\n- 空间复杂度：O(k)，k为字符集大小","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108666060","body":"### 思路\r\n- 双指针\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        p1 = head\r\n        p2 = head\r\n        while p2 and p2.next:\r\n            p1 = p1.next\r\n            p2 = p2.next.next\r\n        return p1\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109211384","body":"### 思路\n- 双指针\n### 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:return 0\n        pleft,pright = 0,0\n        while pright < len(nums):\n            if nums[pleft] != nums[pright]:\n                pleft += 1\n                nums[pleft] = nums[pright]\n            pright += 1\n        return pleft+1\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110440805","body":"### 思路\n- 双指针+二分法\n### 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return 0\n        low,high = 0,len(nums)-1\n        while low <= high:\n            mid = (high-low)//2 + low\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid +1\n            else:\n                high = mid -1\n        if nums[mid]>target:\n            return mid\n        else:\n            return mid +1\n```\n### 复杂度分析：\n- 时间复杂度：O(log n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111863506","body":"### 思路\r\n- 优先队列\r\n### 代码\r\n```python\r\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n      if len(nums) == 1: return nums\r\n        queue = [(-nums[i],i) for i in range(k)]\r\n        heapq.heapify(queue)  #最大堆\r\n\r\n        res = [-queue[0][0]]\r\n        for i in range(k,len(nums)):\r\n            heapq.heappush(queue,(-nums[i],i))\r\n            while queue[0][1] <= i-k:\r\n                heapq.heappop(queue)\r\n            res.append(-queue[0][0])\r\n        return res\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113278014","body":"### 思路\n- 求图中各结点的出度、入度。满足出度为0，入度为n-1的结点即为所求。\n### 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if n == 1: return 1\n        # 统计出度、入度\n        # out_degree = {}\n        # in_degree = {}\n        # for i in range(n):\n        #     out_degree[i+1] = 0\n        #     in_degree[i+1] = 0\n        # for i in range(len(trust)):\n        #     if trust[i][0] in out_degree:\n        #         out_degree[trust[i][0]] += 1\n        #     if trust[i][1] in in_degree:\n        #         in_degree[trust[i][1]] += 1\n\n        out_degree = Counter(x for x, _ in trust)\n        in_degree = Counter(y for _,y in trust)\n        for i in range(1,n+1):\n            if out_degree[i] == 0 and in_degree[i] == n-1:\n                return i\n        return -1\n```\n### 复杂度分析：\n- 时间复杂度：O(n+m)，其中n为结点数，m为trust数组长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113887010","body":"### 思路\n- 图+DFS\n### 代码\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        Graph = collections.defaultdict(list)\n        for u,v in dislikes:\n            Graph[u].append(v)\n            Graph[v].append(u)\n\n        dict = {}\n        def dfs(node,c=0):\n            if node in dict:\n                return dict[node] == c\n            dict[node] = c\n            for nei in Graph[node]:\n                if not dfs(nei,c^1):\n                    return False\n            return True\n        \n        for i in range(1,n+1):\n            if i not in dict:\n                if not dfs(i):\n                    return False\n        return True\n```\n### 复杂度分析：\n- 时间复杂度：O(n+e)\n- 空间复杂度：O(n+e)，n为结点数，e为边数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youxucoding":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085341434","body":"### 思路\r\n\r\n模拟加法，类似链表两数相加那题，所以我使用的LinkedList。\r\n\r\n\r\n### 代码实现\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int vaild = 0;\r\n        int i = num.length-1;\r\n        while(i >= 0 || k > 0){\r\n            int cur = 0;\r\n            if(i < 0){\r\n                cur = (k % 10) + vaild;\r\n            }else if(k == 0){\r\n                cur = num[i] + vaild;\r\n            }else{\r\n                cur = num[i] + (k % 10) +vaild;\r\n            }\r\n            vaild = cur/10;\r\n            cur = cur % 10;\r\n            k = k / 10;\r\n            i--;\r\n            res.addFirst(cur);\r\n        }\r\n        if(vaild > 0){\r\n            res.addFirst(vaild);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086568629","body":"> 4月2日\n\n- 【day02】\n\n### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n难度简单218\n\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\n\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\n\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n```\n\n\n\n### 思路：\n\n1. 暴力解法：得到所有目标字符的下标，遍历字符串一一比较，获得最近距离\n2. 滑动窗口：按照目标字符重复出现的位置，将字符串划分为若干窗口，在窗口内就可以计算出当前下标与目标字符最近距离。\n\n### 代码实现：\n\n- 暴力解法：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> list = new ArrayList<>();\n        int res[] = new int[s.length()];\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        for(int j = 0;j < s.length();j++){\n            res[j] = Integer.MAX_VALUE;\n            for(Integer i : list){\n                res[j] = Math.min(res[j],Math.abs(j-i));\n            } \n        }\n        return res;\n    }\n}\n```\n\n- 滑动窗口：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int cur = 0;\n        int left = Integer.MAX_VALUE;\n        int right = -1;\n        int res[] = new int[s.length()];\n        while(cur < s.length()){\n            right++;\n            while((s.charAt(right) == c || right == s.length() - 1)&&cur <= right){\n               if((right == s.length() - 1) && (s.charAt(right) != c)){\n                   res[cur] = Math.abs(cur - left);\n                   cur++;\n               }else{\n                    res[cur] = Math.min(Math.abs(cur-left),Math.abs(cur-right));\n                    if(cur == right){\n                        left = cur;\n                    }\n                    cur++;\n                }\n                \n            }\n\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 暴力解法：\n  - 时间复杂度：O(m*n)\n  - 空间复杂度：O(n)\n- 滑动窗口：\n  - 时间复杂度：O(n)\n  - 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086783707","body":"> 4月3日\r\n\r\n- 【day03】\r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度  中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n### 思路：\r\n\r\n看到题目上的前缀和标签就尝试了使用差分数组思想，构建原数组（也就是本题中的栈）的差分数组。在差分数组目标区间起点增加值，在终点后一位减值。最后通过差分数组更新原数组。\r\n\r\n\r\n\r\n### 代码实现：\r\n\r\n```java\r\nclass CustomStack {\r\n    private int stack[];\r\n    private int top;\r\n    private int diff[];\r\n    public CustomStack(int maxSize) {\r\n        this.stack = new int[maxSize];\r\n        this.top = -1;\r\n        this.diff = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top > -1){\r\n            return stack[top--];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        diff[0] = stack[0];\r\n        for(int i = 1;i <= top;i++){\r\n            diff[i] = stack[i] - stack[i-1];\r\n        }\r\n        if(k > top+1){\r\n            diff[0] += val;\r\n        }else{\r\n        diff[0] += val;\r\n        diff[k] -= val;\r\n        }\r\n\r\n        stack[0] = diff[0];\r\n        for(int i = 1;i <= top;i++){\r\n            stack[i] = diff[i] + stack[i-1];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析：\r\n\r\n- 时间复杂度：O(N) N为题中方法 increment 参数k\r\n- 空间复杂度：O(N) N = maxSize\r\n\r\nps:使用差分数组思想不是最优解","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087489461","body":"> 4月3日\n>\n> - 【day03】\n\n#### [leetcode.394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n难度   中等\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n**示例 2：**\n\n```java\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n```\n\n\n\n### 思路：\n\n使用栈辅助，数字字符也就是倍数需要一个栈维护，要重复的字符串需要一个栈维护，本题难点在于字符串中存在嵌套方括号，需要从里向外一层层抽丝剥茧一般解决问题，类似于递归，因此需要使用栈。\n\n细节：遍历字符串，每当遇到数字或字符记录到数字变量和字符串变量中，每个数字字符出现也意味着左括号的出现，每当遇到左括号时，数字变量和字符串变量压入相应的栈中，当遇到右括号时就是真正“解码”的时刻，当遍历到第一个右括号，此时计算的是 **最内层的结果** : 当前字符串变量重复刚刚入栈的倍数（也就是处于**栈顶的倍数**）再连接上当前左括号与前一个左括号中的字符串（**此字符串应在对应的字符串辅助栈顶**） 到此最内层括号中“解码”完毕，向外的每一层同理即可。\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\t\tDeque<Integer> num_stack = new LinkedList();\n        Deque<StringBuffer> string_stack = new LinkedList();\n        int num = 0;\n        StringBuffer res = new StringBuffer();\n        for(Character c : s.toCharArray()){\n            if(c == '['){\n                num_stack.push(num);\n                string_stack.push(res);\n                num = 0;\n                res = new StringBuffer();\n            }else if(c == ']'){\n                StringBuffer temp = new StringBuffer();\n                Integer cur_num = num_stack.pop();\n                for(int i = 0;i < cur_num;i++){\n                    temp.append(res);\n                }\n                res = string_stack.pop().append(temp);\n            }else if(c >= '0' && c <= '9'){\n             \tnum = num * 10 + Integer.parseInt(c+\"\");\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088233081","body":"\n> 4月5日 【day05】\n\n### [leetcode.232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n难度  简单\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n- ``void push(int x)`` 将元素 x 推到队列的末尾\n- `int pop()` 从队列的开头移除并返回元素\n- `int peek()` 返回队列开头的元素\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n**说明：**\n\n- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**示例 1：**\n\n```java\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\n\n\n### 思路：\n\n题目中明确需要使用**两个栈** 实现队列，队列的特点是先进先出，队尾进队头出，队尾进入我们可以使用压栈实现（栈头即队尾），关键点在于队头出队怎么实现？\n\n使用两个栈，一个称为stack_tail 即栈头是队尾，另一个成为stack_head 即栈头是队头，实现push() 直接向stack_tail压栈即可，当实现pop()时，将stack_tail栈中元素逐个弹出，并逐个压入stack_head，此时``stack_head.pop()``将弹出队头元素，再将此栈逐个弹出并压入stack_tail中，至此pop实现完成，stack_tai栈中的栈底元素（即队头）已经弹出。\n\n\n\n### 代码实现：\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack_head;\n    private Stack<Integer> stack_tail;\n    public MyQueue() {\n        stack_head = new Stack<Integer>();\n        stack_tail = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stack_tail.push(x);\n    }\n    \n    public int pop() {\n        int res = 0;\n        if(!stack_tail.empty()){\n            while(!stack_tail.empty()){\n                stack_head.push(stack_tail.pop());\n            }\n            res = stack_head.pop();\n            while(!stack_head.empty()){\n                stack_tail.push(stack_head.pop());\n            }\n        }\n        return res;\n    }\n    \n    public int peek() {\n        int res = 0;\n        if(!stack_tail.empty()){\n            while(!stack_tail.empty()){\n                stack_head.push(stack_tail.pop());\n            }\n            res = stack_head.peek();\n            while(!stack_head.empty()){\n                stack_tail.push(stack_head.pop());\n            }\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return stack_tail.empty();\n    }\n}\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：\n  - push：O(1)\n  - pop：O(N)\n  - peek：O(N)\n  - empty：O(1)\n- 空间复杂度：\n  - push：O(1)\n  - pop：O(N)\n  - peek：O(N)\n  - empty：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090281796","body":"\n#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n难度困难119\n\n*这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为`2000`，其中的元素最大为`10**8`。*\n\n`arr`是一个可能包含**重复元素**的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n**示例 1:**\n\n```java\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n```\n\n### 思路：\n\n使用单调栈\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091076135","body":"#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n难度  中等\n\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n\n```java\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n```\n\n\n\n### 思路：\n\n快慢指针可解，思路与**删除倒数第n个节点**大致相似，本题将每个节点向右移动k个位置，可看作将最后k个节点断掉并重新接到头部位置，所以只要找到倒数第k-1位置，将其后的节点“断开”，其中细节：当k大于链表长度时，可采用取模的方法。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        int len = 0;\n        ListNode cur = head;\n        while(cur != null){\n            len++;\n            cur = cur.next;\n        }\n        if(k == 0 || k % len == 0){\n            return head;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        for(int i = 0;i < k % len;i++){\n            fast = fast.next;\n        }\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092388533","body":"> 4月8日\n>\n> 【day08】\n\n#### [leetcode.24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n难度    中等\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n```java\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n### 思路：\n\n递归解法，类似与k个一组反转链表，本题可看作为两个一组反转链表，只要做过k个一组反转链表，这题基本就没什么问题了。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode a = head;\n        ListNode b = head.next.next;\n        ListNode newHead = swap(a,b);\n        a.next = swapPairs(b);\n        return newHead;\n    }\n    //反转相邻的两个节点\n    public ListNode swap(ListNode a,ListNode b){\n        ListNode newHead = a.next;\n        a.next.next = a;\n        a.next = null;\n        return newHead;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093895456","body":"> 4月9日\n>\n> 【day09】\n\n#### [leetcode.109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n难度  中等\n\n给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。\n\n \n\n**示例 1:**\n\n![img](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n\n```java\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n```\n\n\n\n### 思路：\n\n由于BST的性质可知，BST的中序遍历是单调递增的，题目中也说明了元素顺序递增，这样一来中序遍历构造二叉树即可，额外使用left,right,mid 三个元素规划左右子树空间，这样便免去寻找根节点的过程，借助一个辅助变量在链表中由前向后取值即可(链表顺序即为中序顺序)。\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    ListNode node;\n    public TreeNode sortedListToBST(ListNode head) {\n        node = head;\n        ListNode cur = head;\n        int len = 0;\n        while(cur != null){\n            len++;\n            cur = cur.next;\n        }\n        return traverse(0,len-1);\n    }\n    TreeNode traverse(int left,int right){\n        if(left > right){\n            return null;\n        }\n        int mid = (left+right)/2;\n        TreeNode root = new TreeNode();\n        root.left = traverse(left,mid-1);\n        root.val = node.val;\n        node = node.next;\n        root.right = traverse(mid+1,right);\n        return root;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094285021","body":"> 4月10日\n>\n> 【day10】\n\n#### [leetcode.160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n难度  简单\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**自定义评测：**\n\n**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：\n\n- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`\n- `listA` - 第一个链表\n- `listB` - 第二个链表\n- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数\n- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。\n\n \n\n**示例 1：**\n\n[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n\n```java\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n\n\n### 思路：\n\n双指针解法，假设两条链表相交，如果两个指针齐头并进那么一定会在相交点相遇，如果a指针遍历完A链表后从B链表头部继续出发，同样b指针遍历完从A链表头部出发，你会发现在相交前两指针已经齐头并进了。\n\n### 代码实现：\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        if(headA == null && headB ==null){\n            return null;\n        }\n        while(nodeA != null || nodeB != null){\n            if(nodeA == nodeB){\n                return nodeA;\n            }\n            nodeA = nodeA == null ? headB : nodeA.next;\n            nodeB = nodeB == null ? headA : nodeB.next;\n        }\n        return null;\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094969320","body":"\n>4月11日\n>\n>【day11】\n\n#### [leetcode.142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n难度中等1511\n\n给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n**不允许修改** 链表。\n\n\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\n```java\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n\n\n### 思路：\n\n本题有一个隐藏小技巧，假设链表存在环，使用快慢指针，当快指针与慢指针相遇时，定义一临时指针指向头部，与慢指针共同移动，必定会在成环节点相遇，具体数学推导移步官方题解\n\n\n\n### 代码实现：\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                ListNode res = head;\n                while(true){\n                    if(res == slow){\n                        return res;\n                    }\n                    res = res.next;\n                    slow = slow.next;\n                }\n            }\n            \n        }\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096807291","body":"> 4月12日\n>\n> 【day12】\n\n## [leetcode.146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)\n\n难度  中等\n\n请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。\n\n实现 `LRUCache` 类：\n\n- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存\n- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。\n- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。\n\n函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。\n\n \n\n**示例：**\n\n```java\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n```\n\n\n\n### 思路：\n\n最近最少使用，缓存中的元素应该是有时序的，将缓存看作队列，刚操作过的元素应该置于队头位置，最久未操作的元素置于队尾，当容量满了后，应删除队尾元素（即最久未使用）要求O(1)的get和put，哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 `LinkedHashMap`。\n\n### 代码实现：\n\n```java\nclass LRUCache {\n    LinkedHashMap<Integer,Integer> map;\n    int cap ;\n    public LRUCache(int capacity) {\n        map = new LinkedHashMap();\n        cap = capacity;\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        int val = map.get(key);\n        map.remove(key);\n        map.put(key,val);\n        return val;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            map.remove(key);\n            map.put(key,value);\n            return;\n        }\n        if(map.size() == cap){\n            removeLastly();\n            map.put(key,value);\n        }else{\n            map.put(key,value);\n        }\n    }\n\n    public void removeLastly(){\n        int key = map.keySet().iterator().next();\n        map.remove(key);\n    }\n}\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098080816","body":">4月13日\n>\n>【day13】\n\n## [leetcode.104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n难度  简单\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例：**\n给定二叉树 `[3,9,20,null,null,15,7]`，\n\n```java\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n\n返回它的最大深度 3 。\n\n\n\n### 思路：\n\n题目需求是求最大深度，思考：对于每个节点来说，要求出最大深度需要做什么，最大深度=当前节点左子树最大深度和右子树最大深度的最大值 + 1（当前节点），套用后序遍历即可。\n\n\n\n### 代码实现：\n\n```java\nClass Solution{\n    public int maxDepth(TreeNode root){\n        if(root == null){\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left,right)+1;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099259161","body":"\n> 4月13日\n>\n> 【day13】\n\n## [leetcode.100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n难度 简单\n\n给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\n\n```java\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n```\n\n###  思路：\n\n两棵树同时进行遍历，并且保证遍历顺序一致。思考当前节点需要做什么？\n\n以当前节点为根节点，若左右子树都相同即返回`true`\n\n如果当前两个节点同时为空那么返回`true`，反之返回`false`，如果当前两节点`val`值不相等，返回`false`。确定好边界条件后，使用后续遍历递归两颗树就可以了\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null || q == null){\n            return false;\n        }     \n        if(p.val != q.val){\n            return false;\n        }\n        boolean leftFlag = isSameTree(p.left,q.left);\n        boolean rightFlag = isSameTree(p.right,q.right);\n        return leftFlag && rightFlag;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100129209","body":"\n> 4月15日\n>\n> 【day15】\n\n## [leetcode.129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\n\n难度  中等\n\n给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。\n\n计算从根节点到叶节点生成的 **所有数字之和** 。\n\n**叶节点** 是指没有子节点的节点。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)\n\n```java\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n```\n\n\n\n### 思路：\n\n深度优先，找到所有根节点到叶子节点的路径和，使用前序遍历\n\n### 代码实现：\n\n```java\nclass Solution {\n    List<Integer> res = new ArrayList();\n    public int sumNumbers(TreeNode root) {\n        int value = 0;\n        int rtn = 0;\n        traverse(root,value);\n        for(Integer i : res){\n            rtn+=i;\n        }\n        return rtn;\n    }\n    void traverse(TreeNode root,int value){\n        if(root == null){\n            return ;\n        }\n        value = value*10+root.val;\n        if(root.left == null && root.right == null){\n            res.add(value);\n        }\n        traverse(root.left,value);\n        traverse(root.right,value);\n        value = value/10;\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100674470","body":"> 4月16日\n>\n> 【day16】\n\n## [leetcode.513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n难度  中等\n\n给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。\n\n假设二叉树中至少有一个节点。\n\n \n\n**示例 1:**\n\n![img](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)\n\n```java\n输入: root = [2,1,3]\n输出: 1\n```\n\n### 思路：\n\n使用max变量作为当前的最大深度，使用res变量记录当前『最深』且在『最左侧』的『叶子结点』的值。由前序遍历的顺序可知，遍历叶子结点的一定是从左到右的。所以整体思路就是前序遍历整棵树如果遇到叶子结点，判断当前结点是否处于最大深度，如果比最大深度还要大，更新res记录值。最后得到的res就是处于最深且最左侧的。\n\n### 代码实现：\n\n```java\nclass Solution {\n    int res = 0;\n    int max = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        traverse(root,0);\n        return res;\n    }\n    void traverse(TreeNode root,int depth){\n        if(root == null){\n            return ;\n        }\n        depth++;\n        if(root.left == null&&root.right == null && depth > max){\n            max = depth;\n            res = root.val;\n        }\n        traverse(root.left,depth);\n        traverse(root.right,depth);\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100886576","body":"> 4月17日\r\n>\r\n> 【day17】\r\n\r\n## [leetcode.297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\r\n\r\n难度 困难\r\n\r\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\r\n\r\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\r\n\r\n**提示:** 输入输出格式与` LeetCode` 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\r\n\r\n```java\r\n输入：root = [1,2,3,null,null,4,5]\r\n输出：[1,2,3,null,null,4,5]\r\n```\r\n\r\n\r\n\r\n### 思路：\r\n\r\n使用前序遍历顺序得到序列化的字符串，其中空节点使用`#`表示，每个结点之间使用`,`分隔，序列化比较简单，只需要将遍历到的结点按照对应的字符加在字符串后。反序列化也不难，可以将序列化的字符串通过`,`分割成字符数组，再将其转化为双向链表便于操作，根据前序顺序构建这个树就好\r\n\r\n### 代码实现：\r\n\r\n```java\r\npublic class Codec {\r\n    String NULL = \"#\";\r\n    String SEP = \",\";\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        StringBuffer s = new StringBuffer();\r\n        traverse(root,s);\r\n        return s.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        LinkedList<String> res = new LinkedList();\r\n        for(String s : data.split(SEP)){\r\n            res.addLast(s);\r\n        }\r\n        return build(res);\r\n\r\n    }\r\n\r\n    void traverse(TreeNode root,StringBuffer s){\r\n        if(root == null){\r\n            s.append(NULL).append(SEP);\r\n            return ;\r\n        }\r\n        s.append(root.val).append(SEP);\r\n        traverse(root.left,s);\r\n        traverse(root.right,s);\r\n    }\r\n\r\n    TreeNode build(LinkedList<String> s){\r\n        if(s.isEmpty()){\r\n            return null;\r\n        }\r\n        String tmp = s.removeFirst();\r\n        if(tmp.equals(NULL)){\r\n            return null;\r\n        }\r\n        TreeNode root = new TreeNode(Integer.parseInt(tmp));\r\n        root.left = build(s);\r\n        root.right = build(s);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析：\r\n\r\n- 时间复杂度：\r\n  - 序列化：    O(N)\r\n  - 反序列化：O(N)\r\n- 空间复杂度：\r\n  - 序列化：   O(N)\r\n  - 反序列化：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101468352","body":"\n> 4月18日\n>\n> 【day18】\n\n## [leetcode.987. 二叉树的垂序遍历](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)\n\n难度  困难\n\n给你二叉树的根结点 `root` ，请你设计算法计算二叉树的 **垂序遍历** 序列。\n\n对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)` 。树的根结点位于 `(0, 0)` 。\n\n二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n\n返回二叉树的 **垂序遍历** 序列。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)\n\n```java\n输入：root = [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。\n```\n\n\n\n### 思路：\n\n首先遍历整个树，将结点信息保存下来`（col,row,val）`，按照规则进行排序；排序的规则是：首先按列从小到大，再按行从小到大，最后同行同列按照val从小到大，使用`Collections.sort(list,compare)`的自定义排序，这个如果不会，先学一下。最后按照排好的顺序，『按列』构建出结果list。\n\n### 代码实现：\n\n```java\nclass Solution {\n    List<int[]> list = new ArrayList();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        dfs(root,0,0);\n        Collections.sort(list, new Comparator<int[]>() {\n            \n            public int compare(int[] o1, int[] o2) {\n                if(o1[0] != o2[0])\n                    return o1[0]-o2[0];\n                if(o1[1] != o2[1])\n                    return o1[1]-o2[1];\n                return o1[2]-o2[2];\n            }\n        });\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\n        int last = Integer.MIN_VALUE;\n        int size = 0;\n        for(int[] arr : list){\n            int col = arr[0];\n            int row = arr[1];\n            int value = arr[2];\n            if(col != last){\n                last = col;\n                res.add(new ArrayList<Integer>());\n                size++;\n            }\n            res.get(size-1).add(value);\n        }\n        return res;\n\n    }\n    void dfs(TreeNode root,int row,int col){\n        if(root == null){\n            return ;\n        }\n        list.add(new int[]{col,row,root.val});\n        dfs(root.left,++row,--col);\n        row--;\n        col++;\n        dfs(root.right,++row,++col);\n        row--;\n        col--;\n\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(NlogN)  『排序的api复杂度是NlogN』\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102691851","body":"\n> 4月19日\n>\n> 【day19】\n\n## [leetcode.1. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n难度  简单\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n \n\n**示例 1：**\n\n```java\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n\n\n### 思路：\n\n使用哈希表，比较简单。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> map = new HashMap();\n        for(int i = 0;i < nums.length;i++){\n            if(map.containsKey(target - nums[i])){\n                return new int[]{map.get(target - nums[i]),i};\n            }\n            map.put(nums[i],i);\n        }\n        return null;\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103958367","body":"- 思路：\nHashMap+堆\n- 代码实现\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105344547","body":"> 4月21日\n>\n> 【day21】\n\n## [leetcode.447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)\n\n难度  中等\n\n给定平面上 `n` 对 **互不相同** 的点 `points` ，其中 `points[i] = [xi, yi]` 。**回旋镖** 是由点 `(i, j, k)` 表示的元组 ，其中 `i` 和 `j` 之间的距离和 `i` 和 `k` 之间的欧式距离相等（**需要考虑元组的顺序**）。\n\n返回平面上所有回旋镖的数量。\n\n**示例 1：**\n\n```java\n输入：points = [[0,0],[1,0],[2,0]]\n输出：2\n解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n```\n\n### 思路：\n\n遍历每个点，并计算当前点与其他点的距离存入HashMap中，因为需要考虑元组顺序，这里有一个排列组合过程。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for(int[] i : points){\n            HashMap<Integer,Integer> map = new HashMap();\n            for(int[] j : points){\n                int dis = (j[0]-i[0])*(j[0]-i[0]) + (j[1]-i[1])*(j[1]-i[1]);\n                map.put(dis,map.getOrDefault(dis,0)+1);\n            }\n            for(int dis : map.keySet()){\n                int count = map.get(dis);\n                res+=count*(count-1);\n            }\n        }       \n        return res; \n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N*N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106589886","body":"> 4月22日\n>\n> 【day22】\n\n## [leetcode3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n难度  中等\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n \n\n**示例 1:**\n\n```java\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n```java\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n### 思路：\n\n滑动窗口解法，使用HashMap模拟一个窗口，使这个窗口在字符串上『滑动』，保证窗口内的字符都是不重复的，如果即将进入窗口的字符已经在窗口中存在，缩小窗口，同时也要一直记录着窗口最大的长度。\n\n### 代码实现：\n\n```java\nclass Solution{\n    public int lengthOfLongestSubstring(String s){\n        HashMap<Character,Integer> window = new HashMap();\n        int res = 0;\n        int left = 0;\n        int right = 0;\n        while(right < s.length()){\n            char c = s.charAt(right);\n            while(window.containsKey(c)){\n                window.remove(s.charAt(left++));\n            }\n            window.put(c,1);\n            right++;\n            res = Math.max(res,right-left);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107516559","body":"\n> 4月23日\n>\n> 【day23】\n\n## [leetcode.30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)\n\n难度困难648\n\n给定一个字符串 `s` 和一些 **长度相同** 的单词 `words` **。**找出 `s` 中恰好可以由 `words` 中所有单词串联形成的子串的起始位置。\n\n注意子串要与 `words` 中的单词完全匹配，**中间不能有其他字符** ，但不需要考虑 `words` 中单词串联的顺序。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n```\n\n### 思路：\n\n滑动窗口思想，因为word长度相同，维护一个『word长度』* 『words长度』的窗口，判断窗口内的words与输入的words是否相同，这点可以使用HashMap。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList();\n        int wordLen = words[0].length();\n        int len = wordLen*words.length;\n        HashMap<String,Integer> need = new HashMap();\n        HashMap<String,Integer> window = new HashMap();\n        for(String ss : words){\n            need.put(ss,need.getOrDefault(ss,0)+1);\n            \n        }\n        \n        if(s.length() < len){\n            return res;\n        }\n        int left = 0;\n        int right = left+len;\n        int vaild = 0;\n        while(right <= s.length()){\n            for(int i = 1;i <= words.length;i++){\n                String tmp = s.substring(left+(i-1)*wordLen,left+i*wordLen);\n                if(!need.containsKey(tmp)){\n                    break;\n                }else{\n                    window.put(tmp,window.getOrDefault(tmp,0)+1);\n                    if(need.get(tmp).equals(window.get(tmp))){\n                        vaild++;\n                    }\n                }\n                \n            }\n            if(vaild == need.size()){\n                res.add(left);\n            }\n            window.clear();\n            vaild = 0;\n            left++;\n            right++;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N*N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107849032","body":"##代码实现：\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        pre = list(accumulate(nums, add))\n        mod = pre[-1] % p\n        hashT = {0:-1}\n        if mod == 0: return 0\n\n        res = len(nums)\n        for i in range(len(nums)):\n            curmod = pre[i] % p\n            tarmod = (curmod - mod + p) % p\n            if tarmod in hashT:\n                dis = i - hashT[tarmod]\n                res = dis if dis < res else res\n                if res == 1 and len(nums) != 1:\n                    return 1\n            hashT[curmod] = i\n        if res == len(nums):\n            res = -1\n        return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108651379","body":"> 4月25日\n>\n> 【day25】\n\n## [leetcode.876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n难度  简单\n\n给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n \n\n**示例 1：**\n\n```java\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n```\n\n\n\n### 思路：\n\n『快慢指针法』\n\n链表长度为奇数时，只有一个中间结点，快指针走到链表尾部，此时慢指针为中间结点\n\n链表长度为偶数时，有两个中间结点，快指针走到尾部倒数第二个结点，此时慢指针为第一个中间结点，返回`slow.next`\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next != null && fast.next.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        if(fast.next == null){\n            return slow;\n        }\n        return slow.next;\n    }\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111083935","body":"> 4月27日\n>\n> 【day27】\n\n## [leetcode.35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n难度  简单\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 `O(log n)` 的算法。\n\n \n\n**示例 1:**\n\n```java\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n```\n\n\n\n### 思路：\n\n题目中说明使用logn的方法，那就一定非二分莫属了。需要注意若目标数字不存在，合理选择插入位置\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int lo = 0;\n        int hi = nums.length - 1;\n        while(lo < hi){\n            int mid = lo + (hi - lo) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(nums[mid] < target){\n                lo = mid + 1;\n            }else{\n                hi = mid - 1;\n            }\n        }\n        if(nums[lo] < target){\n            return lo + 1;\n        }else{\n            return lo;\n        }\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112327677","body":"> 4月28日\n>\n> 【day28】\n\n## [leetcode.239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n难度  困难\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回 *滑动窗口中的最大值* 。\n\n \n\n**示例 1：**\n\n```java\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n\n\n### 思路：\n\n『双端队列方法』\n\n感觉思想类似于单调栈，不同于单调栈的是双端队列可以在两边操作数据，只需要保留最大值，所以只需要保证当前队头到队尾按照从大到小排列。\n\n细节：注意出队的时机\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] res = new int[nums.length - k + 1];\n        Deque<Integer> window = new LinkedList();\n        for (int i = 0; i < nums.length; i++){\n            if (!window.isEmpty() && i - window.peekFirst() >= k){\n                window.removeFirst();\n            }\n            while (!window.isEmpty() && nums[window.peekLast()] <= nums[i]){\n                window.removeLast();\n            }\n            window.addLast(i);\n            if (i >= k - 1){\n                res[i - k + 1] = nums[window.getFirst()];\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forestie9":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085353261","body":"### Idea\nConvert int item in list to get the first value, and add up with k. Then convert the final value to item in a list.\n\n### Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = ''.join([str(i) for i in num])\n        summ = str(int(s) + k)\n        return [int(i) for i in summ]\n```\n### Complexity\nTime O(n) <br>\nSpace O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086719398","body":"## Ideas\nUse addition array to make `increment` O(1)\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.len = maxSize\n        self.s = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.s) < self.len:\n            self.s.append(x)\n            self.inc.append(0)\n        \n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.s.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n```\n## Complexity\nO(1) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086905383","body":"## Ideas\nUse stack to track letter and count, reset values in every left bracket\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num = 0\n        string = ''\n        stack = []\n        for i in s:\n            if i.isdigit():\n                num = num*10 + int(i)                                \n            elif i == '[':\n                stack.append((string, num))\n                string = ''\n                num = 0\n            elif i == ']':\n                pre, k = stack.pop()\n                string = pre + k * string\n            elif i.isalpha():\n                string += i\n        return string\n```\n## Complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087860594","body":"### Ideas\nUse two stacks. Push to one stack, in peek and pop, reversely push element in first stack to second to get O(1).\n### Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.top = []\n        \n    def push(self, x: int) -> None:\n        self.stack.append(x)        \n\n    def pop(self) -> int:\n        self.peek()\n        return self.top.pop()\n        \n    def peek(self) -> int:\n        if not self.top:\n            while self.stack:\n                self.top.append(self.stack.pop())\n        return self.top[-1]\n        \n    def empty(self) -> bool:\n        return not self.stack and not self.top \n```\n### Complexity\nO(1) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089300643","body":"不会做，看了discussion，用preSum来比较，如果面试遇到，应该怎么个思路啊？\n### Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        org, sort = 0, 0\n        arr_sort = sorted(arr)\n        ans = 0\n        for i in range(len(arr)):\n            org += arr[i]\n            sort += arr_sort[i]\n            if org == sort:\n                ans += 1\n        return ans\n```\n### Complexity  \nO(n) time and space\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090733255","body":"### Ideas\nUse two nodes, one to cycle the list, and another to check the movement of k%n steps\n### Code\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n        if not head.next: return head\n        cnt = 1\n        slow, fast = head, head\n        while fast.next:\n            fast = fast.next\n            cnt += 1\n        fast.next = head # circle the list\n        for i in range(cnt - k%cnt - 1):\n            slow = slow.next\n        new_head = slow.next    \n        slow.next = None\n        return new_head\n```\n### Complexity\nO(n) time, O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092166031","body":"### Ideas\nUse recursion to swap every two nodes\n### Code\n```python\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]: \n        if not head or not head.next: return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head            \n        return newHead\n```\n### complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093525716","body":"### Ideas\nUse the list middle value as root, then recursively build the tree. Note the base case where only one element left in the recursion and should return node.\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        value = []\n        while head:\n            value.append(head.val)\n            head = head.next    \n\n        def convertBST(l, r):\n            if l > r: return None\n            mid = (l + r) // 2\n            node = TreeNode(value[mid])\n            \n            if l == r: return node # base case\n            \n            node.left = convertBST(l, mid - 1)\n            node.right = convertBST(mid + 1, r)\n            return node\n            \n        return convertBST(0, len(value)-1)\n```\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094150303","body":"### Ideas\n太赞了，相交的尾巴长度一样，所以俩个list绕回intersect一圈长度应该相等\n\n```python\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # the \"tails\" is of the same length\n        nodeA = headA\n        nodeB = headB\n        while nodeA != nodeB:\n            nodeA = nodeA.next if nodeA else headB\n            nodeB = nodeB.next if nodeB else headA\n        return nodeA\n```\n### Complexity  \nO(n+m) time and O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094357305","body":"### Ideas\nUse slow and fast node to find intersect point, then adjust the speed to find the start of cycle.\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next    \n            fast = fast.next.next\n            if slow == fast:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow                \n        return None\n```\n### Complexity\nO(n) Time, O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095499147","body":"### Ideas\n用一个hash表，一个double linkedList来实现\n借鉴 https://walkccc.me/LeetCode/problems/0146/?h=146\n```python\nclass Node:\n  def __init__(self, key: int, value: int):\n    self.key = key\n    self.value = value\n    self.prev = None\n    self.next = None\n\n\nclass LRUCache:\n  def __init__(self, capacity: int):\n    self.capacity = capacity\n    self.keyToNode = {}\n    self.head = Node(-1, -1)\n    self.tail = Node(-1, -1)\n    self.join(self.head, self.tail)\n\n  def get(self, key: int) -> int:\n    if key not in self.keyToNode:\n      return -1\n\n    node = self.keyToNode[key]\n    self.remove(node)\n    self.moveToHead(node)\n    return node.value\n\n  def put(self, key: int, value: int) -> None:\n    if key in self.keyToNode:\n      node = self.keyToNode[key]\n      node.value = value\n      self.remove(node)\n      self.moveToHead(node)\n      return\n\n    if len(self.keyToNode) == self.capacity:\n      lastNode = self.tail.prev\n      del self.keyToNode[lastNode.key]\n      self.remove(lastNode)\n\n    self.moveToHead(Node(key, value))\n    self.keyToNode[key] = self.head.next\n\n  def join(self, node1: Node, node2: Node):\n    node1.next = node2\n    node2.prev = node1\n\n  def moveToHead(self, node: Node):\n    self.join(node, self.head.next)\n    self.join(self.head, node)\n\n  def remove(self, node: Node):\n    self.join(node.prev, node.next)\n```\n### Complexity\nO(1) time, O(capacity) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097172938","body":"### Idea\nUse recursion, the max depth of left or right child plus 1 is the max depth of the tree\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n### Complexity\nO(n) time: traverse each node\nO(log(n)) space: if tree is balanced, the space is height of tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098610774","body":"### Ideas\nRecursion\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p and q:\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n### Complexity\nO(n) time and O(h) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099680825","body":"### Ideas\nRecursion, sum numbers up when at leaf node\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:       \n        def dfs(root, cur):\n            if root:\n                cur = cur * 10 + root.val \n            if not root.left and not root.right:\n                self.ans += cur   \n            if root.left:\n                dfs(root.left, cur)\n            if root.right:\n                dfs(root.right, cur)\n                \n        self.ans = 0                \n        dfs(root, 0)\n        return self.ans\n```\n### Complexity\nO(n) time, O(h) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100561148","body":"### Ideas\nTree level traversal and return last level right item\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        res = []\n        def dfs(root, level):\n            if not root: return\n            if level >= len(res):\n                res.append([])\n            res[level].append(root.val)\n            dfs(root.left, level + 1)\n            dfs(root.right, level + 1)\n        \n        dfs(root, 0)    \n        return res[-1][0]\n```\n### complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100723197","body":"### Ideas\nDFS, use list to store data instead of string, as value can be negative\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"        \n        def dfs(root):\n            if not root:\n                self.s.append('#')\n            else:\n                self.s.append(str(root.val))\n                dfs(root.left)\n                dfs(root.right)\n\n        self.s = []  \n        dfs(root)\n        return ' '.join(self.s)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs():\n            if data:\n                cur = data.popleft()\n                if cur == '#':\n                    return\n                node = TreeNode(int(cur))\n                node.left = dfs()\n                node.right = dfs()\n            return node\n                        \n        data = collections.deque(val for val in data.split())\n        return dfs()\n```\n### complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100920579","body":"### Ideas\nStore row, col and node value all together\n```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def dfs(root, col, row):\n            if not root: return\n            self.ans[col].append([root.val, row])\n            dfs(root.left, col - 1, row+1)\n            dfs(root.right, col + 1, row+1)\n        \n        self.ans = collections.defaultdict(list)\n        dfs(root, 0, 0)\n        temp = [sorted(self.ans[key], key = lambda i: (i[1], i[0])) for key in sorted(self.ans.keys())] # use row as second sort\n        ans = []\n        for item in temp:\n            ans.append(i[0] for i in item)\n        return ans        \n```\n### Complexity\nO(nlogn) time, O(n) space         \n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101690249","body":"### Ideas\nHashMap\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dic = {}\n        for i, num in enumerate(nums):\n            cur = target - num\n            if cur in dic:\n                return [i, dic[cur]]\n            dic[num] = i\n        return [-1, -1]\n```\n### complexity\nO(n) space and time","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103001153","body":"### Ideas \nHashMap, heap\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        c = collections.Counter(nums)\n        h = []\n        for key, val in c.items():\n            if len(h) < k:\n                heapq.heappush(h, [val, key])\n            else:\n                heapq.heappushpop(h, [val, key])            \n        return [key for val, key in h]\n```\n### Complexity\nTime O(nlogk), space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104528535","body":"### Ideas\nUse hashmap, count the matched one twice\n```python\n  def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n    ans = 0\n\n    for x1, y1 in points:\n      count = collections.defaultdict(int)\n      for x2, y2 in points:\n        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]\n        count[(x1 - x2)**2 + (y1 - y2)**2] += 1\n\n    return ans\n```\n### complexity\nTime O(n^2), space O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105852962","body":"### Ideas\nTwo pointers, use hashmap to count frequency\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l, r = 0, 0\n        dic = collections.defaultdict(int)\n        ans = 0\n        while r < len(s):\n            c = s[r]\n            dic[c] += 1\n            r += 1\n            while dic[c] > 1:\n                d = s[l]\n                dic[d] -= 1\n                l += 1\n            ans = max(ans, r - l)\n        return ans\n```\n### complexity\nO(n) time and O(k) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107173531","body":"### Ideas\nRefer to solutions: use hashmap to record count of each word, and iterate every n length of word to update the seen dictionary.\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if len(s) == 0 or words == []:\n            return []\n\n        k = len(words)\n        n = len(words[0])\n        ans = []\n        count = Counter(words)\n\n        for i in range(len(s) - k * n + 1):\n            seen = defaultdict(int)\n            j = 0\n            while j < k:\n                word = s[i + j * n: i + j * n + n]\n                seen[word] += 1\n                if seen[word] > count[word]:\n                    break\n                j += 1\n            if j == k:\n                ans.append(i)\n\n        return ans\n```\nO(a*n) time, O(a+b) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107636577","body":"### Ideas\nPrefix sum, hashMap\n```python\n    def minSubarray(self, A, p):\n        need = sum(A) % p\n        dp = {0: -1}\n        cur = 0\n        res = n = len(A)\n        for i, a in enumerate(A):\n            cur = (cur + a) % p\n            dp[cur] = i\n            if (cur - need) % p in dp: # 判断与need差值的mod是否在dp，如果同样mod出现过，则配成对，可以remove\n                res = min(res, i - dp[(cur - need) % p])\n        return res if res < n else -1\n```\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107917263","body":"### Ideas\nTwo pointers\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\nO(n) time and O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1108991420","body":"### Ideas\ntwo pointers\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        pos = 0\n        for i in range(1, len(nums)):\n            if nums[i] != nums[pos]:\n                pos += 1\n                nums[pos] = nums[i]\n        return pos+1\n```\n### complexity\nO(n) time and O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110232185","body":"### Ideas\nBinary search\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\nO(logn) time, O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112248307","body":"### Ideas\nmonotonic queue\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        res = []\n        q = deque()\n        for i in range(n):\n            while q and nums[q[-1]] < nums[i]: #q[-1] is popright (end of queue, min in queue)\n                q.pop()\n            q.append(i)\n            if q[0] == i - k: ## 队头删除元素的index\n                q.popleft()\n            if i >= k - 1: ## 先把窗口的前 k - 1 填满, 就可以开始记录最大值了\n                res.append(nums[q[0]])\n        return res\n```\nO(N) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112674303","body":"### Ideas\nGraph, indegree and outdegree\n```python\ndef findJudge(self, N: int, trust: List[List[int]]) -> int:\n    \n    if len(trust) < N - 1:\n        return -1\n    \n    indegree = [0] * (N + 1)\n    outdegree = [0] * (N + 1)\n    \n    for a, b in trust:\n        outdegree[a] += 1\n        indegree[b] += 1\n        \n    for i in range(1, N + 1):\n        if indegree[i] == N - 1 and outdegree[i] == 0:\n            return i\n    return -1\n```\nO(E) time, O(N) space","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houmk1212":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085369488","body":"# 思路\n用数组模拟加法运算，注意进位和数组的长度。\n\n# 代码\npublic class ClockIn20220401 {\n    public static void main(String[] args) {\n  \n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        if (i != j) {\n            nums[i] = nums[i] ^ nums[j];\n            nums[j] = nums[i] ^ nums[j];\n            nums[i] = nums[i] ^ nums[j];\n        }\n    }\n    public static int[] solution(int[] nums, int k) {\n        int upper = 0;\n        int exp = 1;\n        int n = nums.length;\n        int kLeng = 0;\n        // 先找最大的范围\n        for (int e = 1; k / e > 0; e *= 10) {\n            kLeng ++;\n        }\n        int maxLeng = Math.max(n , kLeng);\n        int[] result = new int[maxLeng + 1];\n        int i = 0;\n        int j = n-1;\n        while (i < n / 2) {\n            swap(nums, i , j);\n            i ++;\n            j --;\n        }\n        i = 0;\n        while (i < maxLeng || upper == 1) {\n            int left = i < n ? nums[i] : 0;\n            int right = k / exp > 0 ? (k / exp) % 10 : 0;\n            result[i] = (left + right + upper) % 10;\n            upper = left + right + upper >= 10 ? 1 : 0;\n            exp *= 10;\n            i ++;\n        }\n        int[] ans = new int[i];\n        int p = 0;\n        for (int q = i - 1; q >= 0; q--) {\n            ans[p ++] = result[q];\n        }\n        return ans;\n    }\n}\n\n# 复杂度\n时间复杂度: O(n + e)   n是数组的长度， e是k的位数;\n\n空间复杂度：O(max(n,e))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086508946","body":"# 思路\r\n因为是找左右侧距离目标字符的最短距离，想到类似单调栈的找右侧最小或者最大值的做法。左侧的目标字符的下表可以用一个变量存，右侧的目标距离可以用单调栈来得到。当目标元素入栈时，弹出所有栈中非目标字符，并得到他们的结果。\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] ans = new int[s.length()];\r\n        int pre = - 1;\r\n        for (int i = 0 ; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) {\r\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\r\n                    int p = stack.pop();\r\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\r\n                }\r\n                pre = i;\r\n            }\r\n            stack.push(i);\r\n        }\r\n        while (!stack.isEmpty()) {\r\n            int p = stack.pop();\r\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度： 每个字符串s中的字符都要入栈一次，出栈一次，所以时间复杂度是O（N）， N是字符串的长度。\r\n空间复杂度：栈的大小，是O（N）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086760827","body":"# 思路\n需要实现方便按索引存取的栈结构，所以用数组。\n\n# 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top >= stack.length) return;\n        stack[top ++] = x;\n    }\n\n    public int pop() {\n        if (top == 0) return -1;\n        int peek = stack[top - 1];\n        top --;\n        return peek;\n    }\n\n    public void increment(int k, int val) {\n        int tmp = Math.min(top, k);\n        for (int i = 0; i < tmp; i++) {\n            sta ck[i] += val;\n        }\n    }\n}\n```\n\n# 复杂度分析\n时间复杂度： push和pop  都是O(1)  inc是O(K)\n\n空间复杂度： O(N)  N是数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087030986","body":"# 思路\n类似于括号匹配。遇到数字、左括号、字母入栈，遇到右括号，把到上一个左括号之间的内容弹出，并重复最后弹出的数字次数，并将结果重新入栈。最后结果会放在栈中。\n\n# 代码\n```\nclass Solution {\n    public boolean isNumber(char c) {\n        return c >= '0' && c <= '9';\n    }\n\n    public boolean isWord(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    public String decodeString(String s) {\n        int index = 0;\n        Stack<String> stack = new Stack();\n        int n = s.length();\n        while (index < n) {\n            if (isNumber(s.charAt(index))) {\n                int to = s.indexOf('[', index);\n                stack.push(s.substring(index, to));\n                index = to - 1;\n            } else if (isWord(s.charAt(index))) {\n                stack.push(s.substring(index, index + 1));\n            } else if (s.charAt(index) == '[') {\n                stack.push(\"[\");\n            } else { // s.charAt(index) == ']'\n                String tmp = \"\";\n                while (!stack.peek().equals(\"[\")) {\n                    tmp = stack.pop() + tmp;\n                }\n                stack.pop(); //弹出'['\n                int times = Integer.parseInt(stack.pop()) ;  // 弹出数字 也就是重复次数\n                String result = \"\";\n                for (int i = 0; i < times; i++) {\n                    result += tmp;\n                }\n                stack.push(result);\n            }\n            index++;\n        }\n        String ans = \"\";\n        while (!stack.isEmpty()) {\n            ans = stack.pop() + ans;\n        }\n        return ans;\n    }\n}\n```\n\n# 复杂度\n时间复杂度：O(N)， N是字符串长度\n\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088196696","body":"# 思路\n使用两个栈，来实现队列的操作；入队时候，可以不管，直接入栈1。出队的时候，为了获得栈低的元素，需要把栈1中的元素出栈，并依次入栈2.  当栈2不空的时候，出队需要从栈2中弹栈。\n\n# 代码\n```\nclass MyQueue {\n    private ArrayDeque<Integer> stack1;\n    private ArrayDeque<Integer> stack2;\n    public MyQueue() {\n        stack1 = new ArrayDeque<Integer>();\n        stack2 = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int ans = stack2.pop();\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return ans;\n    }\n\n    public int peek() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int ans = stack2.peek();\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return ans;\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n# 复杂度\n时间复杂度：入队O(1)  peek和pop  O(N)\n\n空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089704315","body":"# 思路\n参考了官方题解中的思路一，当前数组的最终期望是排序后的数组。 那么一个块中，需要和期望块中具有相同的元素个数。 还需要继续学习大家的做法\n\n# 代码\n```\nclass Solution768 {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] tmp = arr.clone();\n        Arrays.sort(tmp);\n        int ans = 0;\n        int flag = 0;\n        for (int i = 0; i < n; i ++) {\n            hashMap.put(arr[i], hashMap.getOrDefault(arr[i], 0) + 1);\n            if (hashMap.get(arr[i]) == 0)\n                flag --;\n            if (hashMap.get(arr[i]) == 1)\n                flag ++;\n\n            hashMap.put(tmp[i], hashMap.getOrDefault(tmp[i], 0) - 1);\n            if (hashMap.get(tmp[i]) == 0)\n                flag --;\n            if (hashMap.get(tmp[i]) == - 1)\n                flag ++;\n\n            if (flag == 0)\n                ans ++;\n        }\n        return ans;\n    }\n}\n```\n\n# 复杂度\n时间复杂度O(nlogn)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091034465","body":"# 思路\n找到倒数第k个节点（双指针），作为新链表的头节点。原来的头节点，放到尾节点之后。注意处理k大于链表长度的情况。\n\n# 代码\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0)\n            return head;\n        int len = 0;\n        ListNode fast = head;\n        while (len < k && fast != null) {\n            fast = fast.next;\n            len ++;\n        }\n        if (len == k && fast == null)\n            return head;\n        if (len < k) {  // k比链表长度长\n            len = k % len;\n            if (len == 0) {\n                return head;\n            }\n            fast = head;\n            while (len > 0) {\n                len --;\n                fast = fast.next;\n            }\n        }\n        ListNode slow = head;\n        ListNode preSlow = null;\n        ListNode preFast = null;\n        while (fast != null) {\n            preFast = fast;\n            preSlow = slow;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        if (preFast != null && preSlow != null) {\n            preSlow.next = null;\n            preFast.next = head;\n        }\n\n        return slow;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度： O(N)  N是链表长度\n- 空间复杂度： O(1)  除了题目给的链表结构外，没有额外的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092374308","body":"# 思路\n用递归来求解。相邻两个节点交换。那么，也就是head和head.next交换，head.next的后面是交换后的链表就可以了。\n\n# 代码\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next.next;\n        ListNode pre = head;\n        head = head.next;\n        head.next = pre;\n        pre.next = swapPairs(next);\n        return head;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N)  N是链表的长度\n- 空间复杂度: O(N)  递归调用的栈空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093567389","body":"## 思路\n根据二叉搜索树的性质，升序链表的中间节点一定是一个局部二叉搜索子树的根。因此，可以先找到链表的中间节点，然后再递归构建树结构。\n\n## 代码\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return binaryCreate(head, null);\n    }\n    public TreeNode binaryCreate(ListNode l, ListNode r) {\n        if (l == null || l == r)\n            return null;\n        if (l.next == null || r == l.next)\n            return new TreeNode(l.val);\n        ListNode slow = l;\n        ListNode fast = l;\n        while (fast != r && fast.next != r) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = binaryCreate(l, slow);\n        root.right = binaryCreate(slow.next, r);\n        return root;\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(NlogN)\n- 空间复杂度： O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094159739","body":"# 思路\n相交链表，用双指针就可以。\n\n# 代码\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null)\n            return null;\n        ListNode p = headA;\n        ListNode q = headB;\n        while (p != q) {\n            if (p == null)\n                p = headB;\n            if (q == null)\n                q = headA;\n            if (p == q)\n                break;\n            p = p.next;\n            q = q.next;\n        }\n        return p;\n    }\n\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N) . N是两个链表的长度和\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094479822","body":"# 思路\nFloyd判环算法，设置快慢指针，可以判断链表是否有环，且能得到入环的第一个节点。\n\n# 代码\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null)\n            return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast)\n                break;\n        }\n        if (fast == null || fast.next == null)\n            return null;\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N); N是链表长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095870389","body":"```\nclass LRUCache {\n    public int size;\n    public int capacity;\n    public ListNode head;\n    public ListNode tail;\n    public HashMap<Integer, Integer> map;\n    public HashMap<Integer, Integer> oldMap;\n    public int time = 0;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        map = new HashMap<>();\n        oldMap = new HashMap<>();\n        head = new ListNode(new int[]{-1, 0});\n        tail = head;\n        this.time = 0;\n    }\n\n    public int get(int key) {\n        time++;\n        if (map.containsKey(key)) {\n            // key使用过了，得修改它的指针和oldMap\n            oldMap.put(key, time);\n            tail.next = new ListNode(new int[]{key, time});\n            return map.get(key);\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        time++;\n        if (map.containsKey(key)) {\n            map.put(key, value);\n            oldMap.put(key, time);\n            // 修改key的陈旧度,直接插入一个新的节点到链表中\n            tail.next = new ListNode(new int[]{key, time});\n            tail = tail.next;\n        } else {\n\n            if (this.size >= capacity) {\n                ListNode p = head.next;\n                while(p!=null){\n                    System.out.println(Arrays.toString(p.value));\n                    p=p.next;\n                }\n                // 删除最久不用的\n                while (head.next.value[1] != oldMap.get(head.next.value[0])) {\n                    head = head.next;\n                }\n                System.out.println(\"```\"+Arrays.toString(head.next.value));\n                ListNode next = head.next;\n                head.next = next.next;\n                next.next = null;\n                map.remove(next.value[0]);\n                oldMap.remove(next.value[0]);\n\n                map.put(key, value);\n                oldMap.put(key, time);\n                // 链表插入\n                tail.next = new ListNode(new int[]{key, time});\n                tail = tail.next;\n            } else { // 可以直接存入\n                size++;\n                map.put(key, value);\n                oldMap.put(key, time);\n                //链表插入\n                tail.next = new ListNode(new int[]{key, time});\n                tail = tail.next;\n            }\n        }\n\n    }\n\n    class ListNode {\n        public int[] value;\n        public ListNode next;\n\n        public ListNode(int[] value, ListNode next) {\n            this.value = value;\n            this.next = next;\n        }\n\n        public ListNode(int[] value) {\n            this.value = value;\n            this.next = null;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097504667","body":"# 思路\n树的最大深度，就是左子树和右子树中最大深度最大的那个+1。递归求解即可。\n\n# 代码\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null)\n            return 0;\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return 1 + Math.max(left, right);\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N)  N是树中的节点数量。\n- 空间复杂度：O(Height)  是树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098625885","body":"# 思路\n递归寻找，满足相同的两个树，左子树相同，右子树相同，根节点的元素相同。\n\n# 代码\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null)\n            return true;\n        if (p != null && q != null && p.val == q.val) {\n            boolean left = isSameTree(p.left, q.left);\n            boolean right = isSameTree(p.right, q.right);\n            return left && right;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度： O(N)  N是树的节点数量，每个节点都遍历一次\n- 空间复杂度： O(height) 是树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099795402","body":"# 思路\n深度搜索，到一个叶子节点的时候，记录路径结果。返回的时候，需要去掉当前节点的影响，还原到上一个路径状态。\n\n# 代码\n```\nclass Solution {\n    int sum = 0;\n    List<Integer> list = new ArrayList<>();\n    public int sumNumbers(TreeNode root) {\n        dfs(root);\n        int res = 0;\n        for (int i:list) {\n            res += i;\n        }\n        return res;\n    }\n\n    public void dfs(TreeNode root){\n        if(root==null)\n            return;\n        sum = sum * 10 + root.val;\n\n        if(root.left!=null){\n            dfs(root.left);\n        }\n        if(root.right!=null){\n            dfs(root.right);\n        }\n\n        if (root.left == null && root.right==null){\n            // root是叶子节点了\n            list.add(sum);\n        }\n        sum = (sum - root.val) / 10;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N)   N是树中的节点个数，每个节点需要遍历一次\n- 空间复杂度: O(h)   h是树的深度，也就是递归调用的深度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100512895","body":"# 思路\n层次遍历，从右向左输出即可，最后一个元素就是待求节点。\n\n# 代码\n```\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if (root == null)\n            return -1;\n        ArrayDeque<TreeNode> queue = new ArrayDeque<>();\n        int res = 0;\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode tmp = queue.poll();\n            if (tmp.right != null) {\n                queue.offer(tmp.right);\n            }\n            if (tmp.left != null) {\n                queue.offer(tmp.left);\n            }\n            res = tmp.val;\n        }\n        return res;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N)    N是树的节点个数\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100807628","body":"```\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101104748","body":"# 思路\n用hash表存下每一列的节点，并在插入的时候注意比较大小。\n\n# 代码\n```\nclass Solution {\n   TreeMap<Integer, TreeMap<Integer, List<Integer>>> map = new TreeMap<>();\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        preDFS(root, 0, 0);\n        List<List<Integer>> res = new ArrayList<>();\n        for (int col : map.keySet()) {\n            List<Integer> tmp = new ArrayList<>();\n            for (int row : map.get(col).keySet()) {\n                for (int val : map.get(col).get(row)) {\n                    tmp.add(val);\n                }\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n\n    private int findInsertLoc(List<Integer> list, int target) {\n        int n = list.size();\n        if (n == 0)\n            return 0;\n        int l = 0;\n        int r = n - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (list.get(mid) >= target) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n\n    private void preDFS(TreeNode root, int x, int y) {\n        if (root == null)\n            return;\n        if (!map.containsKey(y)) {\n            map.put(y, new TreeMap<>());\n        }\n        if (!map.get(y).containsKey(x)) {\n            map.get(y).put(x, new ArrayList<>());\n        }\n        int loc = findInsertLoc(map.get(y).get(x), root.val);\n        map.get(y).get(x).add(loc, root.val);\n\n        preDFS(root.left, x + 1, y - 1);\n        preDFS(root.right, x + 1, y + 1);\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(NlogN)； 遍历N个节点，每个节点都要插入到对应的位置上，用二分法优化为O（logN）\n- 空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101907442","body":"# 思路\n哈希表存储数值和对应的下标。在从前往后遍历的过程中，就可以检查是否前面的元素有target-nums[i]的值了\n\n# 代码\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        int n = nums.length;\n        for (int i=0 ; i < n; i++) {\n            if (map.containsKey(target - nums[i])) {\n                int[] res = new int[2];\n                res[0] = map.get(target-nums[i]);\n                res[1] = i;\n                return res;\n            }\n            map.put(nums[i],i);\n        }\n        return new int[2];\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N)\n- 时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103348553","body":"# 思路\r\n使用哈希表记录每个元素出现的次数。 topK问题可以使用堆，固定堆的大小为k,遍历哈希表，如果堆已经填满，需要和堆顶元素比较。\r\n\r\n# 代码\r\n```\r\nclass Solution {\r\n   public int[] topKFrequent(int[] nums, int k) {\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        int[] res = new int[k];\r\n        PriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\r\n            @Override\r\n            public int compare(int[] o1, int[] o2) {\r\n                return o1[1] - o2[1];\r\n            }\r\n        });\r\n\r\n        for (Integer key : map.keySet()) {\r\n            int[] tmp = new int[2];\r\n            tmp[0] = key;\r\n            tmp[1] = map.get(key);\r\n\r\n            if (q.size() >= k && q.peek()[1] < tmp[1]) {\r\n                q.remove();\r\n                q.offer(tmp);\r\n            } else if (q.size() < k) {\r\n                q.offer(tmp);\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < res.length; i++) {\r\n            res[i] = q.remove()[0];\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n- 时间复杂度： O(NlogK)\r\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104653524","body":"# 思路\r\n暴力枚举的方法。遍历点，以点作为中间点i。 并通过哈希表存储所有其他点到当前点的不同距离的点有多少个。根据排列原理，就可以通过遍历哈希表计算出能够得到回旋镖的数量。\r\n\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int res = 0;\r\n        for (int[] p : points) {\r\n            HashMap<Integer, Integer> map = new HashMap<>();\r\n            map.clear();\r\n            for (int[] q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                if (dis != 0) {\r\n                    map.put(dis, map.getOrDefault(dis, 0) + 1);\r\n                }\r\n            }\r\n\r\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n                int m = entry.getValue();\r\n                res += m * (m - 1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n- 时间复杂度：O（N2）\r\n- 空间复杂度：O（N）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105887855","body":"# 思路\r\n滑动窗口，并使用哈希表存储窗口内子串出现字母的次数。\r\n\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        if (s.length() == 0)\r\n            return 0;\r\n\r\n        HashMap<Character, Integer> map = new HashMap<>();\r\n        int maxLen = 0;\r\n        int l = 0;\r\n        for (int r = 0; r < s.length(); r++) {\r\n            while (map.containsKey(s.charAt(r))) {\r\n                map.put(s.charAt(l), map.get(s.charAt(l)) - 1);\r\n                if (map.get(s.charAt(l)) == 0) {\r\n                    map.remove(s.charAt(l));\r\n                }\r\n                l++;\r\n            }\r\n\r\n            map.put(s.charAt(r), map.getOrDefault(s.charAt(r), 0) + 1);\r\n            int len = r - l + 1;\r\n            if (maxLen < len) {\r\n                maxLen = len;\r\n            }\r\n        }\r\n        return maxLen;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n- 时间复杂度：O(N)  N是字符串长度\r\n- 空间复杂度：O(M) M是字符集的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107330623","body":"# 思路\n用哈希表保存words中字符串的出现次数。然后暴力枚举的s中的每个位置，看能否构成满足题意的字符串。\n\n# 代码\n```\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        int n = s.length();\n        int sl = words[0].length();\n        List<Integer> res = new ArrayList<>();\n\n        if (n < sl){\n            return new ArrayList<>();\n        }\n\n        for (String str : words) {\n            map.put(str,map.getOrDefault(str,0)+1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            int x = i;\n            if (i + sl * words.length > n)\n                break;\n            String str = s.substring(x,x+sl);\n            HashMap<String,Integer> tmp = new HashMap<>(map);\n            \n            while (!tmp.isEmpty() && tmp.containsKey(str)) {\n                x = x + sl;\n                tmp.put(str,tmp.get(str) - 1);\n                if (tmp.get(str) == 0){\n                    tmp.remove(str);\n                }\n                if (x + sl > n) {\n                    break;\n                }\n                str = s.substring(x,x+sl);\n            }\n            \n            if (tmp.isEmpty()){\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N2)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107674707","body":"# 思路\r\n用前缀和的思想，找到pre[j]和pre[i]之间的关系。为了方便在遍历到j的时候查找前面是否有满足要求的i，用哈希表存储i%k的值，并记录下标。\r\n\r\n# 代码\r\n```\r\nimport java.util.*;\r\n\r\nclass Solution {\r\n    public int solve(int[] nums, int k) {\r\n        int sum = 0;\r\n        int n = nums.length;\r\n        int[] pre = new int[n + 1];\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n\r\n        for (int i = 1; i <= n; i++) {\r\n            pre[i] = pre[i - 1] + nums[i - 1];\r\n            sum += nums[i - 1];\r\n        }\r\n        int mod = sum % k;\r\n\r\n        if (mod == 0)\r\n            return 0;\r\n\r\n        int res = Integer.MAX_VALUE;\r\n        map.put(0, 0);\r\n\r\n        for (int i = 1; i <= n; i++) {\r\n            int j = pre[i];\r\n            int t = j % k;\r\n            int q = (t + k - mod) % k;\r\n            if (map.containsKey(q) && i - map.get(q) != nums.length) {\r\n                res = Math.min(res, i - map.get(q));\r\n            }\r\n            map.put(t, i);\r\n        }\r\n\r\n        return res == Integer.MAX_VALUE ? -1 : res;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(min(N,K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107981901","body":"# 思路\n快慢指针，快指针走两步，慢指针走一步，当快指针到达链表尾巴的时候，慢指针指向的就是中间节点。\n\n# 代码\n```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head.next == null)\n            return head;\n        \n        ListNode slow = head;\n        ListNode quick = head;\n\n        while (quick != null && quick.next != null) {\n            slow = slow.next;\n            quick = quick.next.next;\n        }\n\n        return slow;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N)   N是链表长度。\n- 时间复杂度：O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109214490","body":"# 思路\n快慢指针，慢指针指示不重复的实际长度。快指针寻找下一个不重复的元素。原地修改是没问题的\n\n# 代码\n```\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        int s = 0;\n        int q = 0;\n        while (q < n) {\n            if (nums[q] == nums[s]) {\n                q++;\n                continue;\n            }\n            nums[++s] = nums[q];\n        }\n        return s + 1;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110591487","body":"# 思路\n二分查找\n\n# 代码\n```\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int l = 0;\n        int r = n - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (nums[mid] >= target)\n                r = mid - 1;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O（logN）\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111663219","body":"# 思路\n滑动窗口中的最值问题，用单调队列来解决。\n\n# 代码\n```\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int len = n - k + 1;\n        int[] res = new int[len];\n        int index = 0;\n\n        LinkedList<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < k; i++) {\n            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.addLast(i);\n        }\n\n        if (!queue.isEmpty()) {\n            res[index++] = nums[queue.peekFirst()];\n        }\n\n        for (int i = k; i < n; i++) {\n            while (!queue.isEmpty() && i - k >= queue.peekFirst()) {\n                queue.pollFirst();\n            }\n            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.addLast(i);\n            if (!queue.isEmpty()) {\n                res[index++] = nums[queue.peekFirst()];\n            }\n        }\n        return res;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O(N) N是数组长度，需要遍历一次数组，每次遍历最多是一次的入队和进队。\n- 空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112826017","body":"# 思路\n在图中寻找入度为n-1，出度为0的顶点\n\n# 代码\n```\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[][] graph = new int[n + 1][n + 1];\n        for (int[] edge : trust) {\n            int a = edge[0];\n            int b = edge[1];\n            graph[a][b] = 1;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            if (inDot(graph, i, n) == n - 1 && outDot(graph, i, n) == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private int inDot(int[][] graph, int k, int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (graph[i][k] == 1) {\n                res++;\n            }\n        }\n        return res;\n    }\n\n    private int outDot(int[][] graph, int k, int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (graph[k][i] == 1) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度：O（N2）\n- 空间复杂度：O（N2）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113899125","body":"# 思路\n二分图。首先构造图，深度遍历图，遍历的过程中给顶点涂色，相邻顶点需要涂不一样的颜色。如果这个逻辑能够一直进行下去，则返回true，中间发生冲突，则返回false。\n\n# 代码\n```\nclass Solution {\n    List<Integer>[] graph;\n    int[] colors;\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        graph = new ArrayList[n + 1];\n        colors = new int[n + 1];\n        for (int i = 0; i < n + 1; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] d : dislikes) {\n            int a = d[0];\n            int b = d[1];\n            graph[a].add(b);\n            graph[b].add(a);\n        }\n        for (int i = 1; i <= n; i++) {\n            if (colors[i] == 0) {\n                if (!dfs(i, 1))\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    boolean dfs(int x, int c) {\n        if (colors[x] != 0) {\n            return colors[x] == c;\n        }\n        colors[x] = c;\n        for (int i = 0; i < graph[x].size(); i++) {\n            int next = graph[x].get(i);\n            if (!dfs(next, -c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度 ：O(V+E)\n- 空间复杂度 ：O(V+E)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelving-611":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085375480","body":"### 思路\n\n思路1: 把A转化成数字. 再跟K求和. 最后把输出结果转化成数组. (这种方法感觉没什么意思, 就是来回调用几个函数)\n思路2: 双指针. 从A, K的\"尾巴\"开始, 从后往前移动, 然后每次把得到的和放进数组里(不要忘记carry). 返回数组颠倒过来之后的结果. 注意: 时刻要注意carry. 如果双指针最后走到头, 还需要考虑carry的情况. \n\n### 代码\n\n思路2\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        carry = 0\n        i, j = len(A) - 1, len(str(K)) - 1\n        res = []\n\n        while i >= 0 or j >= 0: \n            val_1 = A[i] if i >= 0 else 0\n            val_2 = int(str(K)[j]) if j >= 0 else 0\n            i -= 1\n            j -= 1\n            val = val_1 + val_2 + carry\n            carry = val // 10\n            val %= 10\n            res.append(val)\n\n        if carry: \n            res.append(carry)\n        return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(len(A), len(str(K)))) 也就是 O(A, str(K)之间较长的长度)\n- 空间复杂度：O(max(len(A), len(str(K)))) . 由于算法不是原地算法, 所以需要重新开辟空间. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658104","body":"# 思路\n分别记录两个数组: \n1. 当前位置到右边最近的c的距离\n2. 当前位置到左边最近的c的距离\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        occurrence = deque()\n        for idx, i in enumerate(s): \n            if i == c: \n                occurrence.append(idx)\n\n        # print(occurrence)\n        occ_1, occ_2 = copy.deepcopy(occurrence), copy.deepcopy(occurrence)\n\n        dis_right = []  # 当前距离右边最近的c的距离\n        right_pos = occurrence[0]\n        for idx, char in enumerate(s): \n            if char == c: \n                right_pos = occ_1.popleft()\n                dis_right.append(0)\n            else: \n                dis_right.append(abs(idx - occurrence[0]))\n        # print(dis_right)\n\n        dis_left = []  # 当前距离左边最近的c的距离\n        left_pos = inf\n        for idx, char in enumerate(s): \n            if char == c: \n                left_pos = occ_2.popleft()\n                dis_left.append(0)\n            else: \n                dis_left.append(abs(idx - left_pos))\n\n        res = []\n        for i in range(len(dis_left)): \n            res.append(min(dis_left[i], dis_right[i]))\n        # print(dis_left)\n        return res\n\n```\n# 复杂度\n时间. 空间复杂度: 都是O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086705756","body":"## 思路\r\n模拟栈操作. \r\n\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n```\r\n## 复杂度分析\r\n时间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(N)\r\n空间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(1). 由于是原地算法所以不占空间. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086957495","body":"## 思路\n用栈来解决. 思路: 从头到尾遍历s, 只要当前不是`]`, 就往stack里面放. 当遇到`]`时, 开始pop, 在遇见stack里面的数字之前, 一直往外弹并且记录下来. 碰到数字后, 把得到的结果重新stack里. 最后把stack里面的值转化成字符串. \n\n重点1 🔴 : 怎么想到用栈来解决这个问题? \nTODO: 没有一个方法论. 只是手动模拟的时候感觉用stack容易些. \n\n\n重点2 🔴 : 一说到用栈, 我们接下来就要想 **什么时候push?** **什么时候pop?**\n1.  **什么时候push?** : 只要当前不是`]`, 就往stack里面放 (细节: 需要处理类似`100[leetcode]`里面的`100`)\n2.  **什么时候pop?**: 当前遇到`]`. \n\n**这道题的思路不重要, 只要动手试一试. 人脑是怎么得出答案的, 我们只需要把人脑的步骤翻译成代码就好了**\n\n## 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        stack = []\n        for i in range(len(s)): \n            if s[i] == \"]\":\n                tmp = []\n                while not stack[-1].isnumeric(): \n                    cur = stack.pop()\n                    if cur == \"[\": \n                        continue\n                    else: \n                        tmp.append(cur)\n                times = stack.pop()\n                tmp_str = \"\".join(tmp[::-1])\n                for _ in range(int(times)): \n                    stack.append(tmp_str)\n            else: \n                # 专门处理 100[leetcode] 里面的\"100\"\n                if stack and s[i].isnumeric() and stack[-1].isnumeric(): \n                    tmp = stack.pop()\n                    stack.append(tmp + s[i])\n                else: \n                    stack.append(s[i])\n        return \"\".join(stack)\n```\n## 复杂度分析\n### 时间复杂度\n算法需要从头到尾遍历一遍. O(字符串长度)\n### 空间复杂度\n因为用了栈, 所以最差情况我们需要存全量的字符到stack中. 比如 `s = \"abcd\"`. O(字符串长度)\n\n## 反思\n1. 这个用例是真的绝了\"`100[leetcode]`\"! 🫡  学到了! 在push时不能无脑往里push. \n2. 栈操作push pop的逻辑中, 细节是魔鬼. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087814440","body":"## 思路\r\n> Tip: stack其实是一个**操作受限**的数据结构. 既只能对最后一个数(i.e.: 栈顶)进行pop, append操作. 如果我们解题用到list时, 操作stack[0]就有点不讲武德了. \r\n\r\n\r\n使用两个栈. 一个用来push `stack_push`, 一个用来pop `stack_pop`. \r\n\r\n\r\n1️⃣ push策略: 直接往stack_push里面append. 理论上, 你想怎么push都可以, 只要后面的pop, peek方法都正确就行. \r\n\r\n\r\n2️⃣ pop 策略: stack_pop里面的最后一个数 (也就是栈顶)一定是queue的第一个数. 所以我们需要确保`stack_pop`里面时刻\"有数可弹\". \r\n1. 如果`stack_pop`不为空, 我们就把最后一个(i.e.: 栈顶元素)取出来. \r\n2. 如果stack_pop为空, 我们就需要把stack_push里面的数一边弹出, 一边弹入. 操作结束后, 把`stack_pop`里面最后一个(i.e.: 栈顶元素)pop出来并且返回. \r\n\r\n\r\n3️⃣ peek策略: 核心理念跟pop相同. 我们需要确保`stack_pop`里面时刻\"有数可弹\". \r\n思路与`pop()`相同\r\n\r\n## 代码\r\n```python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        res = self.stack_pop.pop()\r\n        return res\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\npush - O(1)\r\npop  - max(O(1) or O(当前stack_push的大小)) = O(N)\r\npeek - 跟pop一样 O(N)\r\n### 空间复杂度\r\n用到了两个stack. O(最终队列的大小)\r\n\r\n## 反思\r\n🫡 不过不知道这道题的实际意义是什么? 没有办法把题目跟生产环境联系在一起. \r\n\r\n题解中有提到: \r\n>其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n\r\n> 当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n\r\nTODO: 可能需要改一下自己的code. 我的代码只有在pop, peek时, 才会进行\"倒腾\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089182175","body":"## 思路 \n思路来自于, 看到了\"前置知识\"里面的\"`单调栈`\"\n🤔 个人觉得难点是如何想到这道题需要使用\"单调栈\"\n\n举例: arr=[2,1,3,4,4]\n题目说,我们可以把arr分成两部分\nblock1: [2,1]\nblock2: [3,4,4] \n每个block排序 + 合并就变成 [1,2][3,4,4] 正好就是arr从大到小排好的顺序[1,2,3,4,4]\n\n根据上面, 我们\"很容易\"就能找到一个规律. 我们可以把一个arr分成两块, 当**前面的block的最大值 <= 后面紧接着的block的最小值**. \n于是, 我们就可以想到用两个stack. 来记录当前位置的最大值, 以及最小值\n`l_r_cur_max`: 从左到右看, 当前的最大值\n`r_l_cur_min`: 从右向左看, 当前最小值. \n所以上面的例子可以得到\n[2,1,3,4,4]\n`l_r_cur_max`: 2,2,3,4,4 其中, l_r_cur_max[1] = 1 代表从0到当前位置, 最大的值为1\n`r_l_cur_min`: 1,1,3,4,4  其中, r_l_cur_min[2] = 3 代表从数组最末尾到当前位置, 最小的值为3\n\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        l_r_cur_max, r_l_cur_min = [0 for _ in range(len(arr))], [0 for _ in range(len(arr))]\n        cur_max = -inf\n        for i in range(len(arr)): \n            if arr[i] > cur_max: \n                cur_max = arr[i]\n            l_r_cur_max[i] = cur_max\n\n        cur_min = inf\n        for j in range(len(arr) - 1, -1, -1): \n            if arr[j] < cur_min: \n                cur_min = arr[j]\n            r_l_cur_min[j] = cur_min\n        # print(l_r_cur_max, r_l_cur_min)\n\n        break_point_cnt = 0\n        for i in range(len(arr) - 1): \n            if l_r_cur_max[i] <= r_l_cur_min[i + 1]: \n                break_point_cnt += 1\n        # print(break_point_cnt)\n        return break_point_cnt + 1\n```\n## 复杂度分析\n### 时间复杂度\nO(n): 算法是从头到尾遍历两遍\n### 空间复杂度\nO(n): 算法是需要连个额外的栈空间来储存当前最大/最小值.\n\n## 反思\n**如何联系到生产环境**?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090685544","body":"## 思路\r\n> 被官方示例带节奏了. 以为要走一遍for循环,然后每次移动一个节点.谁知道只要保证最后结果对就行. \r\n\r\n实际上k代表的是将倒数第k个节点连根拔起, 然后接到最前面. \r\n注意: 如果k太大, 我们要取 k= (k mod 节点数)\r\n**例子** : 如果将1->2->3->4->5->NULL 翻转六次, 就相当于把最后一个放到最前面. \r\n\r\n那么我们就需要抓好两个重点: \r\n1. 谁是新的head? \r\n2. 谁是新的tail? \r\n\r\n在纸上画一画就能找到规律, 将头指针移动 节点数 - k % 节点数 - 1次 就能移动到新的tail. 那么新的tail.next就是新的head. \r\n另外为了确保不成环, 我们需要新的tail.next = None\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head: return None\r\n\r\n        tail = head\r\n        length = 1\r\n        while tail.next: \r\n            tail = tail.next\r\n            length += 1\r\n\r\n        tail.next = head\r\n\r\n        ptr = head\r\n        for _ in range(length - k % length - 1): \r\n            ptr = ptr.next\r\n\r\n        head = ptr.next\r\n        ptr.next = None\r\n        return head\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\nO(N). N是链表的长度. \r\n### 空间复杂度\r\nO(1)没有用到额外空间. \r\n\r\n## 反思\r\n1. 以后做题时要确定输出结果是什么. 同时思路不能被给出的例子带跑偏. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092088651","body":"## 思路\n需要实用虚拟节点. 然后画图模拟一遍就能有思路了. \n## 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        dummy.next = head\n        pre = dummy\n        cur = head\n\n        while cur and cur.next: \n            nxt = cur.next.next \n            pre.next = cur.next\n            cur.next.next = cur\n            cur.next = nxt\n\n            pre = cur\n            cur = nxt\n\n        return dummy.next\n```\n## 复杂度分析\n### 时间复杂度\nO(链表长度)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093540722","body":"## 思路\r\n线索: BST + 高度平衡. 意味着左右两边的节点个数一致. 自然想到用递归的解法, \r\n\r\n递归函数的定义: 返回一个高度平衡的BST. \r\n\r\n递归函数的思路: 先找到中间点, 递归地把中间点的左边 接到中间点的left. 把中间点的右边 接到中间点的right. \r\n\r\n易错点: 每次递归调用时, 左侧的部分需要\"剪断\". 既, 应该剪断左侧部分与当前中间点的联系. `pre.next = None` 不然会进入死循环. \r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: \r\n            return None\r\n        if not head.next: \r\n            return TreeNode(head.val)\r\n        # Find mid first\r\n        slow, fast = head, head\r\n        dummy = TreeNode()\r\n        dummy.next = head\r\n        pre = dummy\r\n        while fast and fast.next: \r\n            pre = pre.next\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        # Slow is mid or left_mid\r\n        root = TreeNode(slow.val)\r\n        pre.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n\r\n        return root\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\nO(NlogN) - 每一层是操作数N * 层数logN \r\n### 空间复杂度\r\nO(logN): 递归树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094111781","body":"## 思路\n简单思路就是走完自己的路去走别人的路. 可以想象成把两条路拼接在一起. 所以两个人走的路总是一样的. 如果不想交那么最后一定是走到None. \n## 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a or b: \n            if a and a == b: \n                return a\n            a = a.next if a else headB\n            b = b.next if b else headA\n            \n\n        return None\n```\n## 复杂度分析\n### 时间复杂度\nO(两个链表长度和)\n### 空间复杂度\nO(1)\n## 反思\n1. 最开始提交时, 把判断条件放在后面了, 导致只有1个节点的情况直接报错. 想想也对, 如果把判断条件放在后面, 就会把最最最开始的情况跳过. \n```python\nif a and a == b: \n  return a\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094455210","body":"## 思路\n一个典型的脑筋急转弯题目. 先用快慢指针找到相遇点, 再根据数学推导找到规律, 既, 再次用双指针, 从头再开一个指针, 同时跟当前相遇的指针同时走一步, 相遇点就是最终的答案. \n## 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head \n\n        while fast and fast.next: \n            slow = slow.next\n            fast = fast.next.next\n\n            if slow == fast: \n                break\n\n        if not fast or not fast.next: \n            return None\n\n        ptr = head\n        while True: \n            if ptr == slow: \n                return ptr\n            ptr = ptr.next\n            slow = slow.next\n```\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(1)\n## 反思\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095897087","body":"## 重点\n1. 为什么用双向链表? \n方便删除操作.有了双向链表, 删除操作为O(1). \n\n\n2. 为什么用哈希表? \n方便get操作. O(1). \n\n\n3. 为什么Node里面还存key? \n方便更新哈希表. 当删除最后一个entry时, 我们需要同时更新哈希表. \n\n\n4. 两个dummy nodes. 这样极大程度上方便了删除, 增加操作.\n\n\n5. 用时间换空间思想\n\n\n## 代码\n```python\n# 官方代码\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n\n```\n\n\n时间复杂度: O(1) put. get\n\n\n空间复杂度: O(capacity). ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097491768","body":"## 思路 1 - 递归\n### 递归\n递归定义: maxDepth返回最大深度\n递归逻辑: 递归地取左右子树, 取最大深度. + 1\n\n## 代码\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(树的高度 既logN) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098268194","body":"## 思路\n重点在递归结束的条件: \n如果p, q都为空. 返回True\n如果有一个为空, 返回False\n如果上面两个都满足, 比较根节点, 如果p.val != q.val, 返回False.\n\n如果都不满足上面的情况我们就可以确定, 两棵树至少当前的根节点相同, 我们就需要递归地比较两棵树的leftchild, rightchild\n## 代码\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q: \n            return True\n        elif not p or not q: \n            return False\n        elif p.val != q.val: \n            return False\n\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(logN) i.e.: O(树的高度)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099784790","body":"## 思路\n回溯: 用path记录走过的路线, 如果碰到叶子节点就将路径上经历的节点数存起来, 最后统一加在一起. \n## 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res, path = [], []\n        def backtrack(node): \n            nonlocal res, path\n            if not node.left and not node.right: \n                res.append(\"\".join(path))\n                return \n            \n            if node.left: \n                path.append(str(node.left.val))\n                backtrack(node.left)\n                path.pop()\n            if node.right: \n                path.append(str(node.right.val))\n                backtrack(node.right)\n                path.pop()\n\n        if root: \n            path.append(str(root.val))\n            backtrack(root)\n\n        return sum(map(int, res))\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100523502","body":"## 思路\nBFS. 检索每层时, 记录最左边的节点的值.\n这样可以保证取到最下面一层的最左边的值. \n## 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if not root: \n            return -1 \n        queue = deque()\n        queue.append(root)\n        res = None\n        while queue: \n            q_len = len(queue)\n            res = queue[0].val\n            for _ in range(q_len): \n                cur = queue.popleft()\n                if cur.left: \n                    queue.append(cur.left)\n                if cur.right: \n                    queue.append(cur.right)\n\n        return res\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(N) 高度 = logN. 第N层有 2 ^ (logN) = N\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100746123","body":"## 思路\nDFS\nserialize: 遇到空节点. 不是跳过而是存下一个特殊值, i.e.: X\n\n\ndeserialize: 调用辅助函数创建树\n\n\nbuildTree: 输入一个字符串, 得到一棵以最开始为根的树. \n\n\n## 代码\n```python\nfrom collections import deque\nclass Codec:\n    def serialize(self, root):\n        if root == None: return 'X,'\n        left_str = self.serialize(root.left)\n        right_str = self.serialize(root.right)\n        return str(root.val) + ',' + left_str + right_str\n\n    def deserialize(self, data):\n        data = data.split(',')\n        root = self.buildTree(data)\n        return root \n\n    def buildTree(self,data): # data是一个reference. 所以每次调用都是动态改变的. \n        val = data.pop(0)\n        if val == 'X': return None\n        node = TreeNode(val)\n        node.left = self.buildTree(data)\n        node.right = self.buildTree(data)\n        return node\n```\n\n## 复杂度分析\n### 时间复杂度\n### 空间复杂度\n\n## 反思\n1. 该题目可用于生产环境: 把一棵树转换成字符串便于网络传输, 存储. \n2. 之前以为想要反序列化一棵树, 必须知道至少两个list. pre-order + in-order 或者 pre-order + post-order. 通过这道题知道, 如果在遍历时, 把空节点也存下来也能实现反序列化. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100948294","body":"## 思路\r\n印象里有一个跟这道题差不多的题目, 但是需要写class的. \r\n\r\n\r\n思路很简单, print每一列的数实际上就是在dic里面记录一下列的信息 (可能为负数), 然后最后整体再\"整理\"一下. 放入最终结果中. \r\n\r\n\r\n### 难点\r\n题目里有这个要求: \r\n> 如果同行同列上有多个结点，则按结点的值从小到大进行排序。\r\n\r\n\r\n我们就需要在queue里面同时记录行的信息. \r\n## 代码\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        dic = defaultdict(list)\r\n\r\n        if not root: return []\r\n\r\n        queue = deque()\r\n        queue.append((0, 0, root)) # row, col, TreeNode\r\n        \r\n        while queue: \r\n            q_len = len(queue)\r\n            for _ in range(q_len): \r\n                row_idx, col_idx, cur_node = queue.popleft()\r\n                dic[col_idx].append((row_idx, cur_node.val))\r\n                if cur_node.left: \r\n                    queue.append((row_idx + 1, col_idx - 1, cur_node.left))\r\n                if cur_node.right: \r\n                    queue.append((row_idx + 1, col_idx + 1, cur_node.right))\r\n\r\n        res = [[] for _ in range(len(dic))]\r\n        # print(dic)\r\n        off_set = -min(dic.keys())\r\n        for k, v in dic.items(): \r\n            tmp = [x[1] for x in sorted(v, key=lambda t: (t[0], t[1]))]\r\n            res[k + off_set] = tmp\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n### 时间复杂度\r\nO(N) - N: 节点的数量\r\n### 空间复杂度\r\nO(N) - queue占的地方. 跟N是同一量级","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102641376","body":"## 思路\n题目要求我们返回数组下标, 这就导致我们不能直接排列再使用双指针. \n我们只能用hashmap把数存起来. \n\n## 代码\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dic = defaultdict(int) # diff: index\n        \n        for i in range(len(nums)): \n            if nums[i] in dic: \n                return [i, dic[nums[i]]]\n            dic[target - nums[i]] = i\n\n        return []\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103379292","body":"## 思路\nheap: 时刻保证heap里面有k个数. \n\n小细节: `heapq.heappush(heap, (occ, num))` 自动会根据occ大小排序. 同时pop的时候也会将当前occ最小的tuple弹出. \n\n\n## 代码\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        freq = Counter(nums)\n        heap = []\n\n        for num, occ in freq.items(): \n            if len(heap) < k: \n                heapq.heappush(heap, (occ, num))\n            else: \n                heapq.heappush(heap, (occ, num))\n                heapq.heappop(heap)\n                \n        res = []\n        for i in heap: \n            res.append(i[1])\n        return res\n```\n\n## 复杂度分析\n### 时间复杂度\nO(log(N))\n### 空间复杂度\nO(N)\n## 反思\n**如何联系到生产环境?**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104656920","body":"## 思路\n暴力枚举\n## 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N^2)\n### 空间复杂度\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105938691","body":"## 思路\n滑动窗口. 额外使用哈希表来记录每个字符出现的次数. \n## 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left, right = 0, 0\n        longest_len = 0\n        cur_dict = defaultdict(int)\n\n        while right < len(s): \n            right_char = s[right]\n            right += 1\n            cur_dict[right_char] += 1\n\n            while cur_dict[right_char] > 1: \n                left_char = s[left]\n                left += 1\n                cur_dict[left_char] -= 1\n                if cur_dict[left_char] == 0: \n                    del cur_dict[left_char]\n            longest_len = max(longest_len, right - left)\n        return longest_len\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107509331","body":"## 思路\n滑动窗口 + 哈希表\n## 代码\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:return []\n        one_word = len(words[0])\n        word_num = len(words)\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, one_word):\n            cur_cnt = 0\n            left = i\n            right = i\n            cur_Counter = Counter()\n            while right + one_word <= n:\n                w = s[right:right + one_word]\n                right += one_word\n                cur_Counter[w] += 1\n                cur_cnt += 1\n                while cur_Counter[w] > words[w]:\n                    left_w = s[left:left+one_word]\n                    left += one_word\n                    cur_Counter[left_w] -= 1\n                    cur_cnt -= 1\n                if cur_cnt == word_num :\n                    res.append(left)\n        return res\n\n```\n\n## 复杂度分析\n### 时间复杂度\nO(n)\n### 空间复杂度\nO(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108002698","body":"## 思路\n快慢指针. 画图就能找到规律. \n## 代码\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n\n        while fast and fast.next: \n            slow = slow.next\n            fast = fast.next.next\n\n        return slow \n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109231615","body":"## 思路\n双指针\n## 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i = j = 0\n        while j < len(nums): \n            if nums[i] == nums[j]: \n                j += 1\n            else: \n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n                j += 1\n\n        return i + 1\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110434099","body":"## 思路\n二分, 如果找到就返回, 没有找到就返回第一个>target的数. \n## 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # 返回第一个> target的数\n        l, r = 0, len(nums) - 1\n        while l <= r: \n            mid = (l + r) // 2\n            if nums[mid] == target: \n                return mid\n            elif nums[mid] > target: \n                r = mid - 1\n            else: \n                l = mid + 1\n\n        return l\n\n```\n\n## 复杂度分析\n### 时间复杂度\nO(logN)\n### 空间复杂度\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111669355","body":"## 思路\n单调队列 : 保证一直都是队列最尾巴是当前最大. \n每次循环都会保证\n1. 单调性\n2. 移除窗口外的元素\n## 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        queue = deque()\n        res = []\n        for i in range(len(nums)): \n            while queue and nums[queue[-1]] <= nums[i]: queue.pop() # 保证单调性. \n            while queue and i - queue[0] >= k: queue.popleft()  # 保证窗外的元素被移除. \n            queue.append(i)\n            if i >= k - 1: \n                res.append(nums[queue[0]])\n\n        return res\n```\n\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(N)\n## 反思\n1. 如何能够想出用单调队列来解决问题? ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112836318","body":"## 思路\n学习下官方代码 next函数的用法: 第二个参数是默认返回值. 既如果没有法官就返回-1\n## 代码\n```python\n# 自己代码\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        inDegrees = Counter(y for _, y in trust)\n        outDegrees = Counter(x for x, _ in trust)\n        res = -1\n        for i in range(1, n + 1): \n            if inDegrees[i] == n - 1 and outDegrees[i] == 0: \n                res = i\n        \n        return res \n```\n```python\n# 官方代码\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        inDegrees = Counter(y for _, y in trust)\n        outDegrees = Counter(x for x, _ in trust)\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)\n```\n\n## 复杂度分析\n### 时间复杂度\nO(len(trust))\n### 空间复杂度\nO(len(trust))\n## 反思\n1. 是find celebrity的前置问题. ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lqyt2012":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085378454","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\n```python\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086634529","body":"## 思路\n两次遍历字符串，取其中较短的距离作为返回值\n## 代码\n```python\nclass Solution:\n    def find_smallest_dist(self, s:str, c:str) -> List[int]:\n         nearest_dist = len(s)\n         result = [0]*len(s)\n         for i in range(len(s)):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = nearest_dist\n         nearest_dist = len(s)\n         for i in range(len(s)-1, -1, -1):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = min(nearest_dist, result[i])\n         return result\n```\n## 复杂分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086864051","body":"## 思路\n用数组来模拟栈，因为increment函数涉及到随机读取\n## 代码\n```python\nclass CustomStack:\n    def __init__(self, Max_Size=None):\n        self.stack = []\n        self.size = Max_Size\n        self.length = len(self.stack)\n    \n    def push(self, val:int) -> None:\n        if self.length < Max_Size:\n            self.stack.append(val)\n            self.length += 1\n        return None\n    \n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop(-1)\n        return -1\n    \n    def increment(self, k:int, val:int) -> None:\n        if self.length > 0:\n            for i in range(min(k,self.length)):\n                self.stack[i] += val\n        return None\n```\n## 负责度分析\n空间复杂度：O(N)  \n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087601018","body":"## 思路\n左边中括号之前出现的数字字符是倍数，因为括号可能嵌套，所以需要倍数栈，用于存储倍数。右边括号出现时，从倍数栈去除栈顶元素，用于重复字符串。\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        number_stack = []\n        encoded_string_stack = []\n        number_string = ''\n        result = ''\n        encoded_string = ''\n        for char in s:\n            if char in '0123456789':\n                number_string += char\n            elif 'a' <= char and char <= 'z':\n                encoded_string += char\n            elif char == '[':\n                number_stack.append(int(number_string))\n                number_string = ''\n                encoded_string_stack.append(encoded_string)\n                encoded_string = ''\n            else:\n                number = number_stack.pop()\n                temp_string = encoded_string_stack.pop()\n                encoded_string = temp_string + number * encoded_string\n        result += encoded_string\n        return result\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088693712","body":"## 思路\n用两个栈模拟队列，stack模拟队尾，进行push，在队尾添加元素。help_stack模拟队头，用于peek操作和pop操作，查看队头和队头出队。\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if self.help_stack:\n            return self.help_stack.pop()\n        else:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            return self.help_stack.pop()\n\n\n    def peek(self) -> int:\n        if self.help_stack:\n            return self.help_stack[-1]\n        else:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            return self.help_stack[-1]\n\n    def empty(self) -> bool:\n        if len(self.stack) == 0 and len(self.help_stack) == 0:\n            return True\n        else:\n            return False\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：push：O(1),pop：O(N),peek：O(N),empty：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090337383","body":"## 思路\n应用单调栈来存储每个区块的最大值\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        current_max, stack = arr[0], [arr[0]]\n        for num in arr[1:]:\n            if num >= current_max:\n                current_max = num\n                stack.append(num)\n            else:\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(current_max)\n        return len(stack)\n```\n## 复杂度分析\n时间复杂度：O(N)   \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091828031","body":"## 思路\n先求出链表长度，在用k对length求余。用快慢指针找出旋转位置。\n## 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        k = k % length\n        if k == 0: return head\n        # 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # newHead 是倒数第 k 个节点，即新链表的头\n        newHead = slow.next\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n```\n时间复杂度：O(N)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092906280","body":"## 思路\n链表问题最好用一个*哑节点*dummy_head指向头节点，这种技巧可以使得链表交换操作推广，而且新的头节点就是dummy_head.next。\n## 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head == None or head.next == None:\n            return head\n        dummy_head = ListNode(0)\n        dummy_head.next = head\n        cur = dummy_head\n        while cur.next and cur.next.next:\n            first_node, second_node = cur.next, cur.next.next\n            first_node.next = second_node.next\n            second_node.next = first_node\n            cur.next = second_node\n            cur = first_node\n        return dummy_head.next\n```\n```go\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    dummyHead := &ListNode{0,nil}\n    dummyHead.Next = head\n    cur := dummyHead\n    for cur.Next != nil && cur.Next.Next != nil {\n        firstNode, secondNode := cur.Next, cur.Next.Next\n        firstNode.Next = secondNode.Next\n        secondNode.Next = firstNode\n        cur.Next = secondNode\n        cur = firstNode\n    }\n    return dummyHead.Next\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094040873","body":"## 思路\n将链表转为数组，然后递归构建平衡二叉树。在数组找到中点，即为根节点。左边为左子树，右边为右子树。\n## 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head == None:\n            return None\n        lists = []\n        cur = head\n        while cur:\n            lists.append(cur.val)\n            cur = cur.next\n        return self.createBST(lists, 0, len(lists)-1)\n    \n\n    def createBST(self, lists, start, end):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        root = TreeNode(lists[mid])\n        root.left = self.createBST(lists, start, mid-1)\n        root.right = self.createBST(lists, mid+1, end)\n        return root\n```\n\n```go\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    if head == nil {\n        return nil\n    }\n    arrValue := []int{}\n    cur := head\n    for cur != nil {\n        arrValue = append(arrValue, cur.Val)\n        cur = cur.Next\n    }\n    return createBST(arrValue, 0, len(arrValue)-1)\n}\n\nfunc createBST(arrValue []int, start int, end int) *TreeNode {\n    if start > end {\n        return nil\n    }\n    mid := (start + end) / 2\n    root := &TreeNode{Val:arrValue[mid]}\n    root.Left = createBST(arrValue, start, mid-1)\n    root.Right = createBST(arrValue, mid+1, end)\n    return root\n}\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094272698","body":"## 思路\n假设公共链表长度为c，链表A在公共点之前的长度为a, 链表B在公共点之前的长度为b。a+c+b=b+c+a即当链表遍历到尾节点None时设置为对方的头节点接着遍历。两次遍历的相遇的地方为公共节点，没有交点的两个链表会在None处相遇。\n## 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        curA, curB = headA, headB\n        while curA != curB:\n            curA = curA.next if curA else headB\n            curB = curB.next if curB else headA\n        return curA\n```\n```go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    curA, curB := headA, headB\n    for curA != curB {\n        if curA != nil {\n            curA = curA.Next\n        } else {\n            curA = headB\n        }\n        if curB != nil {\n            curB = curB.Next\n        } else {\n            curB = headA\n        }\n    }\n    return curA\n}\n```\n## 复杂度分析\n空间复杂度：O(1)  \n时间复杂度：O(M+N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095102677","body":"## 思路\n利用快慢指针，快指针每一次走两步，慢指针每一次走一步。如果有环则快慢指针一定会相遇。此时，假设环之前的长度为a，环的长度为b。设快指针走过的路程为f，慢指针走过路程为s。有f=2s,f=s+nb。那么s=nb。那么，如果慢指针回到环的起点位置还需走a步。此时，可以将快指针重新设置为头节点，然后快慢指针每次都只向前走一步。那么快慢指针再次相遇时，即为环的入口。\n## 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while True:\n            if not (fast and fast.next): return None\n            fast, slow = fast.next.next, slow.next\n            if slow == fast:\n                break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n```go\nfunc detectCycle(head *ListNode) *ListNode {\n    fast, slow := head, head\n    for {\n        if fast == nil || fast.Next == nil {\n            return nil\n        } else {\n            fast, slow = fast.Next.Next, slow.Next\n        }\n        if fast == slow {\n            break\n        }\n    }\n    fast = head\n    for fast != slow {\n        fast, slow = fast.Next, slow.Next\n    }\n    return fast\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096815554","body":"## 思路\nhashmap加doublelinkedlist\n## 代码\n```python\ndef __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到头部(变成最新访问的)，所以定义一个方法\n    def move_node_to_header(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到头部节点前\n            #                   hashmap[key]                     hashmap[key]\n            #                       |                                 |\n            #                       V        -->                      V\n            # header <-> next  ... node                   header <-> node <-> next\n            node.prev = self.head\n            node.next = self.head.next\n            self.head.next.prev = node\n            self.head.next = node\n            \n    def add_node_to_header(self, key,value):\n        new = ListNode(key, value)\n        self.hashmap[key] = new\n        new.prev = self.head\n        new.next = self.head.next\n        self.head.next.prev = new\n        self.head.next = new\n        \n    def pop_tail(self):\n        last_node = self.tail.prev\n        # 去掉链表尾部的节点在哈希表的对应项\n        self.hashmap.pop(last_node.key)\n        # 去掉最久没有被访问过的节点，即尾部Tail之前的一个节点\n        last_node.prev.next = self.tail\n        self.tail.prev = last_node.prev\n        return last_node\n    \n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到头部（变成最新访问的）\n            self.move_node_to_header(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到链表头部\n            self.move_node_to_header(key)\n        else:\n            if len(self.hashmap) >= self.capacity:\n            # 若cache容量已满，删除cache中最不常用的节点 \n                self.pop_tail()\n            self.add_node_to_header(key,value)\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098031255","body":"## 思路\n递归求解，子树不空，二叉树的高度等于1加左右子树中的最大高度。\n## 代码\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root == None:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n```go\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    rightHeight := maxDepth(root.Right)\n    leftHeight := maxDepth(root.Left)\n    if rightHeight >= leftHeight {\n        return 1 + rightHeight\n    } else {\n        return 1 + leftHeight\n    }\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099179016","body":"## 思路\n判断当前节点是否相同，递归判断左子树和右子树。\n## 代码\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n```go\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p == nil && q == nil {\n        return true\n    }\n    if p == nil || q == nil {\n        return false\n    }\n    if p.Val != q.Val {\n        return false\n    }\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100118318","body":"## 思路\n深度优先搜索，计算当前节点的累计和preSum=preSum*10+currentnode.Val。递归搜索左子树和右子树。\n## 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        return self.dfs(root, 0)\n    \n    def dfs(self, root, preSum):\n        if not root:\n            return 0\n        preSum = preSum * 10 + root.val\n        if not root.left and not root.right:\n            return preSum\n        return self.dfs(root.left, preSum) + self.dfs(root.right, preSum)\n```\n```go\nfunc sumNumbers(root *TreeNode) int {\n    if root == nil {\n        return 0\n    }\n    return dfs(root, 0)\n}\n\nfunc dfs(root *TreeNode, preSum int) int {\n    if root == nil {\n        return 0\n    }\n    preSum = preSum * 10 + root.Val\n    if root.Left == nil && root.Right == nil {\n        return preSum\n    }\n    return dfs(root.Left, preSum) + dfs(root.Right, preSum)\n}\n```\n## 时间复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100658106","body":"## 思路\n层序遍历，每一层第一次出队的节点就是二叉树最左边的节点。\n## 代码\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque([root])\n        left_num = root.val\n        while queue:\n            n = len(queue)\n            for i in range(n):\n                if i == 0:\n                    node = queue.popleft()\n                    left_num = node.val\n                    if node.left:\n                        queue.append(node.left)\n                    if node.right:\n                        queue.append(node.right)\n                else:\n                    node = queue.popleft()\n                    if node.left:\n                        queue.append(node.left)\n                    if node.right:\n                        queue.append(node.right)\n        return left_num\n```\n```go\nfunc findBottomLeftValue(root *TreeNode) int {\n    queue := []*TreeNode{root}\n    leftNum := root.Val\n    for len(queue) != 0 {\n        n := len(queue)\n        for i:=0;i<n;i++ {\n            if i == 0{\n                node := queue[0]\n                queue = queue[1:]\n                leftNum = node.Val\n                if node.Left != nil {\n                    queue = append(queue, node.Left)\n                }\n                if node.Right != nil {\n                    queue = append(queue, node.Right)\n                }\n            } else {\n                node := queue[0]\n                queue = queue[1:]\n                if node.Left != nil {\n                    queue = append(queue, node.Left)\n                }\n                if node.Right != nil {\n                    queue = append(queue, node.Right)\n                }\n            }\n        }\n    }\n    return leftNum\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100884830","body":"## 思路\n深度优先遍历生成前序序列。\n## 代码\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return '#'\n        left_tree = self.serialize(root.left)\n        right_tree = self.serialize(root.right)\n        return str(root.val) + ',' + left_tree + ',' + right_tree\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        str_list = data.split(',')\n        tree_node = self.deser_dfs(str_list)\n        return tree_node\n    \n    def deser_dfs(self, lists):\n        node = lists.pop(0)\n        if node == '#':\n            return None\n        tree_node = TreeNode(int(node))\n        tree_node.left = self.deser_dfs(lists)\n        tree_node.right = self.deser_dfs(lists)\n        return tree_node\n```\n```go\nimport (\n    \"strconv\"\n    \"strings\"\n)\n\ntype Codec struct {\n    \n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {\n        return \"#\"\n    }\n    leftTree := this.serialize(root.Left)\n    rightTree := this.serialize(root.Right)\n    return strconv.Itoa(root.Val) + \",\" + leftTree + \",\" + rightTree\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {    \n    lists := strings.Split(data, \",\")\n    treeNode := deserDFS(&lists)\n    return treeNode\n}\n\nfunc deserDFS(lists *[]string) *TreeNode {\n    node := (*lists)[0]\n    *lists = (*lists)[1:]\n    if node == \"#\" {\n        return nil\n    }\n    val, _ := strconv.Atoi(node)\n    treeNode := &TreeNode{val, nil, nil}\n    treeNode.Left = deserDFS(lists)\n    treeNode.Right = deserDFS(lists)\n    return treeNode\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101431679","body":"## 思路\n深度优先遍历，用元组记录节点的数据，(行，列，节点值)。这也是排序的关键字\n## 代码\n```python\nclass Solution:\n    def __init__(self):\n        self.nodes = []\n\n\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.dfs(root, 0, 0)\n        self.nodes.sort()\n        ans, lastcol = list(), float(\"-inf\")\n\n        for col, row, value in self.nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n        \n        return ans\n\n\n    def dfs(self, node:TreeNode, row:int, col:int) -> None:\n        if not node:\n            return\n\n        self.nodes.append((col, row, node.val))\n        self.dfs(node.left, row + 1, col - 1)\n        self.dfs(node.right, row + 1, col + 1)\n```\n## 复杂度分析\n时间复杂度分析：O(NlogN)，遍历O(N),主要在排序的复杂度O(NlogN)\n空间复杂度分析：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102681658","body":"## 思路\nhashmap存储数值到下标的映射，边构建hashmap边搜索。\n## 代码\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        number_to_index = {}\n        for index, value in enumerate(nums):\n            residual = target - value\n            if residual in number_to_index:\n                return [number_to_index[residual], index]\n            number_to_index[value] = index\n```\n```go\nfunc twoSum(nums []int, target int) []int {\n    numberToIndex := map[int]int{}\n    for index, value := range nums {\n        residual := target - value\n        if ind, ok := numberToIndex[residual]; ok {\n            return []int{ind, index}\n        }\n        numberToIndex[value] = index\n    }\n    return []int{}\n}\n```\n## 时间复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103978831","body":"## 思路\nhashmap和小顶堆，对于前k个大小有序的元素都可以用堆来降低时间复杂度。\n## 代码\n```python\nfrom collections import defaultdict\nimport heapq\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        freq_map = defaultdict(int)\n        for key in nums:\n            freq_map[key] += 1\n        \n\n        k_most_freq = []\n        for key, val in freq_map.items():\n            if len(k_most_freq)==k:        \n\t\t\t\t\n                if val > k_most_freq[0][0]:\n                        heapq.heappop(k_most_freq)\n                        heapq.heappush(k_most_freq, (val, key))\n                else:\n                    continue\n\n            else:\n                heapq.heappush(k_most_freq, (val, key))\n\t\t\t\t\n        return [pair[1] for pair in k_most_freq]\n```\n```go\ntype IHeap [][2]int\n\nfunc (h IHeap) Len()int {\n    return len(h)\n}\n\nfunc (h IHeap) Less (i,j int) bool {\n    return h[i][1]<h[j][1]\n}\n\nfunc (h IHeap) Swap(i,j int) {\n    h[i],h[j]=h[j],h[i]\n}\n\nfunc (h *IHeap) Push(x interface{}){\n    *h=append(*h,x.([2]int))\n}\nfunc (h *IHeap) Pop() interface{}{\n    old:=*h\n    n:=len(old)\n    x:=old[n-1]\n    *h=old[0:n-1]\n    return x\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n    freq_map := map[int]int{}\n    for _, num := range nums {\n        freq_map[num] += 1\n    }\n    \n    h := &IHeap{}\n    for key,value:=range freq_map{\n        heap.Push(h,[2]int{key,value})\n        if h.Len()>k{\n            heap.Pop(h)\n        }\n    }\n    res:=make([]int,k)\n\n    for i:=0;i<k;i++{\n        res[k-i-1]=heap.Pop(h).([2]int)[0]\n    }\n    return res\n}\n```\n## 复杂度分析\n时间复杂度：O(NlogK)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104928148","body":"## 思路\n计算每一个点到其他点的距离，用map存储相同距离的点的个数。然后从距离相同的点计算排列数m*(m-1)\n## 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            dist_map = collections.defaultdict(int)\n            for q in points:\n                dist = (p[0]-q[0]) ** 2 + (p[1]-q[1]) ** 2\n                dist_map[dist] += 1\n            for m in dist_map.values():\n                ans += m*(m-1)\n        return ans\n```\n```go\nfunc numberOfBoomerangs(points [][]int) int {\n    ans := 0\n    for _, p := range points {\n        distMap := map[int]int{}\n        for _, q := range points {\n            dist := (p[0]-q[0]) * (p[0]-q[0]) + (p[1]-q[1]) * (p[1]-q[1])\n            distMap[dist]++\n        }\n        for _, val := range distMap {\n            ans += val*(val-1)\n        }\n    }\n    return ans\n}\n```\n## 复杂度分析\n时间复杂度：O(N*N)  \n空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106498020","body":"## 思路\n左右指针形成滑动窗口，map存储字符出现的下标。\n## 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_pos_dict = {}\n        left = 0\n        right = 0\n        max_length = 0\n        # 字符长度大于1\n        for index, char in enumerate(s):\n            # 新出现的字符\n            if char not in char_pos_dict:\n                char_pos_dict[char] = index\n                right += 1\n            # 重复出现的字符，但是重复的字符上一次出现的位置滑动窗口之外\n            elif char in char_pos_dict and char_pos_dict[char] < left:\n                char_pos_dict[char] = index\n                right += 1\n            # 重复出现的字符，且重复的字符上一次出现的位置再滑动窗口之内\n            else:\n                if right - left > max_length:\n                    max_length = right - left\n                left = char_pos_dict[char] + 1\n                char_pos_dict[char] = index\n                right += 1\n        if right - left > max_length:\n            max_length = right - left\n\n        return max_length\n```\n```go\nfunc lengthOfLongestSubstring(s string) int {\n    charPosMap := map[string]int{}\n    left, right, maxLength := 0, 0, 0\n    for index, char := range s {\n        val, ok := charPosMap[string(char)]\n        if !ok {\n            charPosMap[string(char)] = index\n            right += 1\n        } else if ok && val < left {\n            charPosMap[string(char)] = index\n            right += 1\n        } else {\n            if right - left > maxLength {\n                maxLength = right - left\n            }\n            left = val + 1 \n            charPosMap[string(char)] = index\n            right += 1\n        }\n    }\n    if right - left > maxLength {\n        maxLength = right - left\n    }\n    return maxLength\n}\n```\n## 复杂度分析\n时间复杂度分析：O(N)  \n空间复杂度分析：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107508357","body":"## 思路\nmap存储words的单词统计个数，然后再字符串寻找排列组合，由于words中的单词长度固定，每一个可以以固定长度增长左右指针。\n## 代码\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        word_length = len(words[0])\n        word_counts = len(words)\n        n = len(s)\n        if n < word_length:return []\n        words_map = Counter(words)\n        res = []\n        for i in range(0, word_length):\n            cur_cnt = 0\n            left = i\n            right = i\n            cur_Counter = Counter()\n            while right + word_length <= n:\n                w = s[right:right + word_length]\n                right += word_length\n                if w not in words_map:\n                    left = right\n                    cur_Counter.clear()\n                    cur_cnt = 0\n                else:\n                    cur_Counter[w] += 1\n                    cur_cnt += 1\n                    while cur_Counter[w] > words_map[w]:\n                        left_w = s[left:left+word_length]\n                        left += word_length\n                        cur_Counter[left_w] -= 1\n                        cur_cnt -= 1\n                    if cur_cnt == word_counts :\n                        res.append(left)\n        return res\n```\n## 复杂度分析：\n时间复杂度：O(N)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107849921","body":"## 思路\n前缀和与连续子序列相关。有了前缀和可以常数时间获取子序列的和。\n## 代码\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        pre_sum = list(accumulate(nums,add))\n        mod = pre_sum[-1] % p\n        if mod == 0:\n            return 0\n        mod_map = {0:-1}\n        ans = len(nums)\n        for i in range(len(nums)):\n            cur_mod = pre_sum[i] % p\n            tar_mod = (cur_mod + p - mod) % p\n            if tar_mod in mod_map:\n                dist = i - mod_map[tar_mod]\n                ans = dist if dist < ans else ans\n                if ans == 1 and len(nums) != 1:\n                    return ans\n            mod_map[cur_mod] = i\n        if ans == len(nums):\n            return -1\n        return ans\n```\n```go\nfunc minSubarray(nums []int, p int) int {\n    preSum := []int{}\n    for i, val := range nums {\n        if i == 0 {\n            preSum = append(preSum, val)\n        } else {\n            preSum = append(preSum, preSum[i-1]+val)\n        }\n    }\n    mod := preSum[len(nums)-1] % p\n    if mod == 0 {\n        return 0\n    }\n    modMap := map[int]int{0:-1}\n    ans := len(nums)\n    for i:=0; i<len(nums); i++ {\n        curMod := preSum[i] % p\n        tarMod := (curMod + p - mod) % p\n        if val, ok := modMap[tarMod]; ok {\n            dist := i - val\n            if dist < ans {\n                ans = dist\n            }\n        }\n        modMap[curMod] = i\n        if ans == 1 && len(nums) != 1 {\n            return ans\n        }\n    }\n    if ans == len(nums) {\n        return -1\n    }\n    return ans\n}\n```\n## 复杂度分析\n时间复杂度分析：O(N)  \n时间复杂度分析：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108520507","body":"## 思路\n快慢指针，当快指针每次走两步，慢指针每次走一步。\n## 代码\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast_point = head\n        slow_point = head\n        while fast_point.next != None:\n\n            if fast_point.next.next != None:\n                fast_point = fast_point.next.next\n                slow_point = slow_point.next\n            else:\n                fast_point = fast_point.next\n                slow_point = slow_point.next\n        return slow_point\n```\n```go\nfunc middleNode(head *ListNode) *ListNode {\n    fastNode, slowNode := head, head\n    for fastNode.Next != nil {\n        if fastNode.Next.Next != nil {\n            fastNode = fastNode.Next.Next\n            slowNode = slowNode.Next\n        } else {\n            fastNode = fastNode.Next\n            slowNode = slowNode.Next\n        }\n    }\n    return slowNode\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109824434","body":"## 思路\n类似选择排序，用两个指针，相同时cur前进，不同时更新diff。直接覆盖即可。\n## 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        length = len(nums)\n        if length == 0 or length == 1:\n            return length\n        cur = 1\n        diff = 0\n        while cur < length:\n            if nums[cur] == nums[diff]:\n                cur += 1\n            else:\n                nums[diff+1]=nums[cur]\n                diff += 1\n                cur += 1\n        return diff + 1\n```\n```go\nfunc removeDuplicates(nums []int) int {\n    if len(nums) == 0 || len(nums) == 1 {\n        return len(nums)\n    }\n    diff := 0\n    cur := 1\n    length := len(nums)\n    for cur < length {\n        if nums[cur] == nums[diff] {\n            cur++\n        } else {\n            nums[diff+1] = nums[cur]\n            diff++\n            cur++\n        }\n    }\n    return diff+1\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111017624","body":"## 思路\n二分查找，low，high指针。根据(low+high)>>2，来得到mid，然后与target比较。\n## 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        low = 0\n        high = len(nums) - 1\n        mid = (low + high) // 2\n        while low <= high:\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n                mid = (low + high) // 2\n            elif nums[mid] > target:\n                high = mid - 1\n                mid = (low + high) // 2\n        return low\n```\n```go\nfunc searchInsert(nums []int, target int) int {\n    low := 0\n    high := len(nums) - 1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return mid\n        }\n        if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n\n    }\n    return low\n}\n```\n## 复杂度分析\n时间复杂度：O(logN)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112232767","body":"## 思路\n双向单调队列维护滑动中的序列大小顺序，队首就是滑动窗口的最大值。right指针移动时，判断right指针是否比队尾大，如果大则队尾出队。left指针移动时，判断left是否为当前窗口最大值，如果是，队首出队。\n## 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        deque_index = collections.deque()\n        left = 0\n        right = 0\n        length = len(nums)\n        res = []\n        while right < length:\n            if right - left < k:\n                while len(deque_index) != 0 and nums[deque_index[-1]] <= nums[right]:\n                    deque_index.pop()\n                deque_index.append(right)\n                right += 1\n            else:\n                res.append(nums[deque_index[0]])\n                while len(deque_index) != 0 and nums[deque_index[-1]] <= nums[right]:\n                    deque_index.pop()\n                deque_index.append(right)\n                if left == deque_index[0]:\n                    deque_index.popleft()\n                left += 1\n                right += 1\n        res.append(nums[deque_index[0]])\n        return res\n```\n```go\nfunc maxSlidingWindow(nums []int, k int) []int {\n    left := 0\n    right := 0\n    length := len(nums)\n    queueIndex := []int{}\n    res := []int{}\n    for right < length {\n        if right - left < k {\n            for len(queueIndex) != 0 && nums[queueIndex[len(queueIndex)-1]] <= nums[right] {\n                queueIndex = queueIndex[:len(queueIndex)-1]\n            }\n            queueIndex = append(queueIndex, right)\n            right++\n        } else {\n            res = append(res, nums[queueIndex[0]])\n            for len(queueIndex) != 0 && nums[queueIndex[len(queueIndex)-1]] <= nums[right] {\n                queueIndex = queueIndex[:len(queueIndex)-1]\n            }\n            queueIndex = append(queueIndex, right)\n            if left == queueIndex[0] {\n                queueIndex = queueIndex[1:]\n            }\n            left++\n            right++\n        }\n    }\n    res = append(res, nums[queueIndex[0]])\n    return res\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113367328","body":"## 思路\n遍历信任数组即图的边，统计图中节点的度，最后如果有n-1的度节点则返回节点，否则返回-1。\n## 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # if n == 1 and len(trust) == 0:\n        #     return n\n        degree = collections.defaultdict(int)\n        if len(trust) == 0:\n            degree[1] = 0\n        for edge in trust:\n            degree[edge[0]] -= 1\n            degree[edge[1]] += 1\n        for key, value in degree.items():\n            if value == n-1:\n                return key\n        return -1\n```\n```go\nfunc findJudge(n int, trust [][]int) int {\n    degree := map[int]int{}\n    if len(trust) == 0 {\n        degree[1] = 0\n    }\n    for _, edge := range trust {\n        degree[edge[0]]--\n        degree[edge[1]]++\n    }\n    for key, value := range degree {\n        if value == n - 1 {\n            return key\n        }\n    }\n    return -1\n}\n```\n## 复杂度分析\n时间复杂度：O(N+E)  \n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yz3516":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085380660","body":"### **思路**\r\n把k当做carry，从后往前遍历，每次加k的个位数值进res的头部并更新k；\r\n\r\n### **代码**\r\n```java\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        List res = new LinkedList<>();\r\n        for (int i = nums.length - 1; i >= 0 || k > 0; --i) { //这里可以用三元运算符简化；\r\n\t        if(i >= 0){\r\n\t\t\tres.add(0, (nums[i] + k) % 10);\r\n\t\t\tk = (nums[i] + k) / 10;\r\n\t\t} else {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}   \r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### **复杂度**\r\nTime: O(n), n is the length of nums;\r\nSpace: O(n), the res List uses extra space ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086526568","body":"### 思路\n先从左边往右扫，记录每个字符离C的距离；\n然后从右边往左扫，如果比第一次扫的距离小则替换掉，这样最后剩下的就是每个字符距离C最短的距离；\n\n### 代码\n```java\n        int[] result = new int[S.length()];\n        int currDist = S.length(); \n        for (int i = 0; i < S.length(); ++i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = currDist;\n        }\n\n        currDist = S.length();\n        for (int i = S.length() - 1; i >= 0; --i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = Math.min(result[i], currDist);\n        }\n        return result;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)， N 为数组长度;\n- 空间复杂度：O(N)，创建了新的array result;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086734511","body":"### 思路\n一般思路下increment的时间复杂度很高，每次inc的时候都要遍历inc对应的值；\\\n优化思路：只有在pop出来的时候才increment历史inc的值，这样inc是O(1)时间；这样需要一个inc array来储存历史上inc的值；\\\ninc[i]对应是的栈顶需要在pop时候inc的值，每次pop的时候需要更新inc[i - 1] = inc[i];\n\n### 代码\n```java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() < n)\n            stack.push(x);\n    }\n\n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0)\n            inc[i] += val;\n    }\n}\n```\n**复杂度分析**\\\n初始化时空均为O(N)，push, pop, increment 时空均为 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086947266","body":"### 思路 & 复杂度\r\n1. 两个stack的做法，一个intStack存遇到的数字，一个strStack存需要decode的string，这样空间复杂度是O(m+n)，m为字母数n为数字数； \r\n2. Recursion的做法，base case是完成遍历整个string s 或者 遇到 ] 括号，空间复杂度是O(n)， n是string s 的长度；两个做法时间复杂度都是O(maxK*n), k是nested[]的数量；\r\n\r\n### 代码\r\ntwo stacks:\r\n```java\r\n    public String decodeString(String s) {\r\n        Stack<Integer> intStack = new Stack<>();\r\n        Stack<StringBuilder> strStack = new Stack<>();\r\n        StringBuilder cur = new StringBuilder();\r\n        int k = 0;\r\n        for (char ch : s.toCharArray()) {\r\n            if (Character.isDigit(ch)) {\r\n                k = k * 10 + ch - '0';\r\n            } else if ( ch == '[') {\r\n                intStack.push(k);\r\n                strStack.push(cur);\r\n                cur = new StringBuilder();\r\n                k = 0;\r\n            } else if (ch == ']') {\r\n                StringBuilder tmp = cur;\r\n                cur = strStack.pop();\r\n                for (k = intStack.pop(); k > 0; --k) cur.append(tmp);\r\n            } else cur.append(ch);\r\n        }\r\n        return cur.toString();\r\n    }\r\n```\r\nrecursion:\r\n```java\r\n    int index = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder result = new StringBuilder();\r\n        while(index < s.length() && s.charAt(index) != ']'){\r\n            if(!Character.isDigit(s.charAt(index)))\r\n                result.append(s.charAt(index++));\r\n            else {\r\n                int k = 0;\r\n                //build k while next character is a digit\r\n                while(index < s.length() && Character.isDigit(s.charAt(index)))\r\n                    k = k * 10 + s.charAt(index++) - '0';\r\n                \r\n                //ignore the opening bracket '['\r\n                index++;\r\n                String decodedString = decodeString(s);\r\n                //ignore the closing bracket ']'\r\n                index++;\r\n                //build k[decodedString] and append to the result\r\n                while(k-- > 0)\r\n                    result.append(decodedString);\r\n            }\r\n        }\r\n        return new String(result);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087982640","body":"### 思路\n用两个stack，一个inStack无脑存push进queue的element，另一个outStack负责pop和peek method；\n\n###代码\n```java\nclass MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n        \n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n###复杂度\n空间复杂度都是O(1)；\\\n时间：\\\npush: O(1), 只需要push到inStack里\\\npop: O(1), worst case O(n)，需要call一次peek然后return outStack栈顶的元素\\\npeek: O(1), worst case O(n)\\\nemptu：O(1), 查看两个stack是否都为空都是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089418588","body":"### 思路\r\n对单调栈还是不熟；用的是两个array的做法来实现O(n)复杂度\\\r\n遍历input array，每次遇到比的元素的左边所有元素比在其右边的所有都大即有一个新的chunk\r\n\r\n### 代码\r\n```java\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] maxOfLeft = new int[n];\r\n        int[] minOfRight = new int[n];\r\n\r\n        maxOfLeft[0] = arr[0];\r\n        for (int i = 1; i < n; i++) {\r\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minOfRight[n - 1] = arr[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int i = 0; i < n - 1; i++) {\r\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\r\n        }\r\n\r\n        return res + 1;\r\n    }\r\n```\r\n### 复杂度\r\n时间: O(n) \r\n空间: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090792975","body":"### Idea\n三步走：\n1. 连接尾结点到头结点\n2. 找到反转后的新头结点和新尾结点\n3. 断开新尾结点，返回新头结点\n\n### Code\n```java\n  public ListNode rotateRight(ListNode head, int k) {\n    // base cases\n    if (head == null) return null;\n    if (head.next == null) return head;\n\n    // close the linked list into the ring\n    ListNode old_tail = head;\n    int n;\n    for(n = 1; old_tail.next != null; n++)\n      old_tail = old_tail.next;\n    old_tail.next = head;\n\n    // find new tail : (n - k % n - 1)th node\n    // and new head : (n - k % n)th node\n    ListNode new_tail = head;\n    for (int i = 0; i < n - k % n - 1; i++)\n      new_tail = new_tail.next;\n    ListNode new_head = new_tail.next;\n\n    // break the ring\n    new_tail.next = null;\n\n    return new_head;\n  }\n```\n\n### Complexity\nTime: O(n) \\\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092172760","body":"### Idea\r\n可以iteration不断交换node，更简洁的做法是recursion，也是作为学习和理解recursion很好的题目\r\n\r\n### Code\r\n```java\r\n    //Recursion 解法 先recursion call then do something\r\n    public ListNode swapPairs(ListNode head) {\r\n        //Base Case\r\n        if(head == null || head.next == null) return head;\r\n        ListNode postHead = swapPairs(head.next.next);\r\n        //第一层，swapPairs(1)\r\n            //过了第一行的if，然后到line15\r\n            //ListNode postHead = swapPairs(1.next.next),传进去的是3\r\n            //第二层，swapPairs(3)\r\n                //3 != null && 3.next.next != null，继续往下\r\n                //swapPairs(3.next.next) 传进去的是nulll\r\n                    //此时第三层的'head' == null，return head，返回上一层执行\r\n                //执行第二层的head.next.next = head，此层head = 3\r\n                //3.next.next = 3, 此时链表为 3<->4\r\n                //ListNode newHead = head.next, newHead = 4\r\n                //head.next = postHead, postHead是第三层return的null，此时链表为 4->3->null\r\n                //执行完第二层，return newHead，也就是4\r\n            //回到第一层，执行head.next.next = head, 第一层的head是1，此时链表为 1<->2\r\n            //执行ListNode newHead = head.next, newHead = 2\r\n            //执行head.next = postHead, postHead是第二层return的4->3->null，此时链表为 2->1->4->3->null\r\n            //最后return newHead, 也是就头结点是2的此时链表，2->1->4->3->null\r\n        head.next.next = head;\r\n        ListNode newHead = head.next;\r\n        head.next = postHead;\r\n        \r\n        return newHead;\r\n    }\r\n```\r\n\r\n### Complexity\r\nTime: O(n) \\\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093715787","body":"### Idea\n用recursion来做，先找到中点，然后左半边和右半边都call自己来construct\n\n### Code\n```java\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return constructBST(0, checkLength(head) - 1, head);\n    }\n    \n    private int checkLength(ListNode head){\n        if(head == null) return 0;\n        return checkLength(head.next) + 1;\n    }\n    \n    private TreeNode constructBST(int start, int end, ListNode head){\n        if(start > end) return null;\n        \n        int mid = start + (end - start) / 2;\n        ListNode temp = head;\n        \n        for(int i = 0; i < mid; i++){\n            temp = temp.next;\n        }\n        TreeNode root = new TreeNode(temp.val);\n        root.left = constructBST(start, mid - 1, head);\n        root.right = constructBST(mid + 1, end, head);\n        return root;\n    }\n```\n\n#Complexity\nTime: O(n), 因为要遍历所有节点找到长度，再找到中点；\\\nSpace: O(logn), 每次同时call左右，recursion的次数是树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094121509","body":"### Idea\n        //a为短的不重复部分，b为长的不重复部分，c为共同部分；\n        //a + c + b = b + c + a\n        //p1先走完a然后走c再走b，p2先走完b然后走c再走a，一定会在connect处汇合；\n### Code\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode p1 = headA, p2 = headB;\n        while(p1 != p2){\n            p1 = p1 != null? p1.next : headB;\n            p2 = p2 != null? p2.next : headA;\n        }\n        return p1;\n    }\n```\n\n### Complexity\nTime: O(max(n,m)), 两个链表长度更长的一个\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094380265","body":"### Idea\r\n用的是lc官方解答第二种来实现O(1)空间复杂度\r\n\r\n### Code\r\n```java\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) return null;\r\n        ListNode dummy = new ListNode(-1);\r\n        dummy.next = head;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        \r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow == fast) break;\r\n        }\r\n        if(slow != fast) return null;\r\n        ListNode temp = head;\r\n        \r\n        while(temp != slow){\r\n            temp = temp.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n```\r\n\r\n### Complexity\r\nTime: O(n) \\\r\nSpace: O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095700685","body":"### Code\n```java\nclass Node {\n    public int key, val;\n    public Node next, prev;\n    public Node(int k, int v) {\n        this.key = k;\n        this.val = v;\n    }\n}\nclass DoubleList {\n\n    private Node head, tail;\n    private int size;\n\n    public void addFirst(Node node) {\n        if (head == null) {\n            head = tail = node;\n        } else {\n            Node n = head;\n            n.prev = node;\n            node.next = n;\n            head = node;\n        }\n        size++;\n    }\n\n    public void remove(Node node) {\n        if (head == node && tail == node) {\n            head = null;\n            tail = null;\n        } else if (tail == node) {\n            node.prev.next = null;\n            tail = node.prev;\n        } else if (head == node) {\n            node.next.prev = null;\n            head = node.next;\n        } else {\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n        }\n        size--;\n    }\n\n    public Node removeLast() {\n        Node node = tail;\n        remove(tail);\n        return node;\n    }\n\n    public int size() {\n        return size;\n    }\n}\n\nprivate HashMap<Integer, Node> map;\nprivate DoubleList cache;\nprivate int cap;\n\npublic LRUCache(int capacity) {\n    this.cap = capacity;\n    map = new HashMap<>();\n    cache = new DoubleList();\n}\n\npublic int get(int key) {\n    if(!map.containsKey(key)) return -1;\n    int val = map.get(key).val;\n    put(key, val);\n    return val;\n}\n\npublic void put(int key, int value) {\n    Node x = new Node(key, value);\n\n    if (map.containsKey(key)){\n        cache.remove(map.get(key));\n        cache.addFirst(x);\n        map.put(key,x);\n    } else {\n        if (cap == cache.size()) {\n            Node last = cache.removeLast();\n            map.remove(last.key);\n        }\n        cache.addFirst(x);\n        map.put(key,x);\n    }\n}   \n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098310801","body":"### Idea\nRecursion的方法check左右子树是否一样\n\n### Code\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```\n\n### Complexity\nTime: O(n), n 为tree node的个数\nSpace: O(logn), tree的高度；","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085383015","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))\nspace O(max(num和k的长度))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1088149983","body":"## 思路\n\n先标记有 char 的 idx 的值为 0， 再遍历一遍数组如果不为 0 的地方就左右扩散找，取最小值\n\n## 代码\n\n    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            n = len(s)\n            res = [n] * n\n            for i in range(n):\n                if s[i] == c:\n                    res[i] = 0\n\n            for i in range(n):\n                if res[i] == 0:\n                    idx = i\n                    idx2 = i\n                    while idx + 1 < n and res[idx + 1] != 0:\n                        res[idx + 1] = min(res[idx] + 1, res[idx + 1])\n                        idx += 1\n                    while idx2 - 1 >= 0 and res[idx2 - 1] != 0:\n                        res[idx2 - 1] = min(res[idx2] + 1, res[idx2 - 1])\n                        idx2 -= 1\n            return res\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1091019900","body":"## 思路\n\n最优解前缀和，用 increment 数组把要增加的前 k 个元素和存起来，pop 时为 stack.pop() + increment[cnt - 1]， 同时把 increment[cnt - 2] 加上 increment[cnt - 1], 把 increment[cnt - 1] = 0，防止影响后续 pop 操作，这样 increment 操作为 O(1)。\n\n## 代码\n\n    class CustomStack(object):\n\n        def __init__(self, maxSize):\n            \"\"\"\n            :type maxSize: int\n            \"\"\"\n            self.capacity = maxSize\n            self.stack = []\n            self.cnt = 0\n            self.increments = [0] * maxSize\n\n\n        def push(self, x):\n            \"\"\"\n            :type x: int\n            :rtype: None\n            \"\"\"\n            if self.cnt < self.capacity:\n                self.stack.append(x)\n                self.cnt += 1\n\n\n\n        def pop(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            if self.cnt == 0:\n                return -1\n            if self.cnt >= 2:\n                self.increments[self.cnt - 2]  += self.increments[self.cnt - 1]\n            val = self.stack.pop() + self.increments[self.cnt - 1]\n\n            self.increments[self.cnt - 1] = 0\n            self.cnt -= 1\n            return val\n\n\n\n        def increment(self, k, val):\n            \"\"\"\n            :type k: int\n            :type val: int\n            :rtype: None\n            \"\"\"\n            if self.cnt > 0:\n                self.increments[min(self.cnt, k) - 1] += val\n\n## 复杂度\n\ntime O(1)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1091087904","body":"## 思路\n\n如果不是']'，就把当前字符放入 stack 中，否则就把从 stack pop 出 string 和 repeat time，最后再把结果放在栈里面\n\n## 代码\n\n    class Solution:\n        def decodeString(self, s: str) -> str:\n            stack = []\n            for char in s:\n                if char != \"]\":\n                    stack.append(char)\n                else:\n                    temp = \"\"\n                    count = \"\"\n                    while len(stack) != 0 and stack[-1] != \"[\":\n                        temp = stack.pop() + temp\n                    stack.pop()\n                    while len(stack) != 0 and stack[-1].isdigit():\n                        count = stack.pop() + count\n                    stack.append(temp * int(count))\n            return  \"\".join(stack)\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1089831673","body":"## 思路\n\n队列 push 时，把元素都加入到第一个栈中；当 pop 或 peek 时，把元素倒着出栈加入到第二个栈中，此时的栈顶元素就是队列的头\n\n## 代码\n\n    class MyQueue(object):\n\n        def __init__(self):\n            self.stack1 = []\n            self.stack2 = []\n\n        def push(self, x):\n            \"\"\"\n            :type x: int\n            :rtype: None\n            \"\"\"\n            self.stack1.append(x)\n\n\n        def pop(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n\n            popOut = self.stack2.pop()\n\n            while len(self.stack2) != 0:\n                self.stack1.append(self.stack2.pop())\n            return popOut\n\n\n        def peek(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n\n            peekNum = self.stack2[-1]\n\n            while len(self.stack2) != 0:\n                self.stack1.append(self.stack2.pop())\n            return peekNum\n\n        def empty(self):\n            \"\"\"\n            :rtype: bool\n            \"\"\"\n            return len(self.stack1) == 0\n\n## 复杂度\n\npush time O(1)<br/>\npop time O(N)<br/>\npeek time O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1095857029","body":"## 思路\n\n前一个模块的 max 必须小于等于后面模块的 min，所以只要后面出现小于前面 max 的，要把前面的都踢出去，留下之前的 max\n最后返回栈的长度，栈存的是左边模块的分界点\n\"\"\"\n[2,1,3,4,4] => [2, 3, 4, 4]\n\"\"\"\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n\n    class Solution:\n        def maxChunksToSorted(self, arr: List[int]) -> int:\n            stack = []\n            for num in arr:\n                if stack and num < stack[-1]:\n                    curMax = stack[-1]\n                    while stack and num < stack[-1]:\n                        stack.pop()\n                    stack.append(curMax)\n                else:\n                    stack.append(num)\n            return len(stack)\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091030984","body":"## 思路\n\n注意 corner case，head 为空，head 为 1 个节点，k 为 0 时要直接 return；k 取模后如果为 0 也要直接 return\n\n## 代码\n\n    # Definition for singly-linked list.\n    # class ListNode(object):\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    class Solution(object):\n        def rotateRight(self, head, k):\n            \"\"\"\n            :type head: ListNode\n            :type k: int\n            :rtype: ListNode\n            \"\"\"\n            if not head or k == 0 or head.next == None:\n                return head\n\n            newTail= head\n            cur = head\n            length = 0\n            while cur != None:\n                cur = cur.next\n                length += 1\n\n            k %= length\n            if k == 0:\n                return head\n\n            cur = head\n            for i in range(k):\n                cur = cur.next\n\n            while cur.next != None:\n                cur = cur.next\n                newTail = newTail.next\n\n            newHead = newTail.next\n            newTail.next = None\n            cur.next = head\n            head = newHead\n            return head\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1094301520","body":"## 思路\n\n前驱节点获得要交换的两个节点，前驱节点先指向交换节点的后节点，交换的前节点指向后节点的next后，才能开始交换\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummy = ListNode(-1)\n        dummy.next = head\n        cur = dummy\n        while cur.next and cur.next.next:\n            p2 = cur.next\n            p3 = cur.next.next\n            cur.next = p3\n            p2.next = p3.next\n            p3.next = p2\n            \n            cur = p2\n        return dummy.next\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094299123","body":"## 思路\n\n注意当只有一个节点的时候要返回这个节点。获得中间节点的值，然后分别构建左右子树。\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            mid = self.findMid(head)\n            cur = mid.next\n            mid.next = None\n            root = TreeNode(cur.val)\n            root.left = self.sortedListToBST(head)\n            root.right = self.sortedListToBST(cur.next)\n            return root\n\n\n        def findMid(self, head):\n            if not head:\n                return None\n            p1, p2 = head,head\n            pre = None\n            while p2 and p2.next:\n                pre = p1\n                p1 = p1.next\n                p2 = p2.next.next\n            return pre\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094296130","body":"## 思路\n\nheadA, headB 分别指向链表 A, B 的头结点, 两个链表都分别遍历过，如果有交点就会返回。\n\n## 代码\n\n```python\n    class Solution:\n        def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n            p1, p2 = headA, headB\n            while p1 != p2:\n                p1 = p1.next if p1 != None else headB\n                p2 = p2.next if p2 != None else headA\n            return p1\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094309430","body":"## 思路\n\n先快慢指针直到相遇，相遇后把其中一指针放回起点，然后两指针同时向前走，直到相遇。相遇点就是环的开始点。否则不存在环\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (slow == fast) break;\n        }\n\n        if (fast == null || fast.next == null) return null;\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095920240","body":"## 思路\n\n用双向链表和哈希表实现，用 map 能在 O(1)时间内读取，双向链表不需要前驱节点删除，添加也是 O(1)\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n\n    class ListNode:\n        def __init__(self, key, val):\n            self.key = key\n            self.val = val\n            self.pre = None\n            self.next = None\n\n    class Linkedlist:\n        def __init__(self):\n            self.head = ListNode(0, 0)\n            self.tail = ListNode(0, 0)\n            self.head.next = self.tail\n            self.tail.pre = self.head\n\n\n        def addFirst(self, node):\n            node.pre = self.head\n            node.next = self.head.next\n    #         先写pre指向node！！\n            self.head.next.pre = node\n            self.head.next = node\n\n        def delete(self, node):\n            key = node.key\n            node.next.pre = node.pre\n            node.pre.next = node.next\n            return key\n\n        def deleteLast(self):\n            if self.head.next == self.tail:\n                return -1\n            return self.delete(self.tail.pre)\n\n\n\n\n    class LRUCache(object):\n\n        def __init__(self, capacity):\n            \"\"\"\n            :type capacity: int\n            \"\"\"\n            self.cache = Linkedlist()\n            self.map = {}\n            self.capacity = capacity\n\n        def get(self, key):\n            \"\"\"\n            :type key: int\n            :rtype: int\n            \"\"\"\n            if key not in self.map:\n                return -1\n            node = self.map[key]\n            val = node.val\n            self.cache.delete(node)\n            self.cache.addFirst(node)\n            return val\n\n\n        def put(self, key, value):\n            \"\"\"\n            :type key: int\n            :type value: int\n            :rtype: None\n            \"\"\"\n            newnode = ListNode(key, value)\n    #         如果遇到满了但是要改写key val的例子，优先改写key\n            if key in self.map:\n                node = self.map[key]\n                self.cache.delete(node)\n\n            elif len(self.map.keys()) == self.capacity:\n                k = self.cache.deleteLast()\n                self.map.pop(k)\n\n\n\n            self.map[key] = newnode\n            self.cache.addFirst(newnode)\n\n\n\n\n\n\n    # Your LRUCache object will be instantiated and called as such:\n    # obj = LRUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n```\n\n## 复杂度\n\ntime O(1)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1096921216","body":"## 思路\n\nroot 的最大深度等于 max(左子树的最大深度，右子树的最大深度) + 1\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution(object):\n        def maxDepth(self, root):\n            \"\"\"\n            :type root: TreeNode\n            :rtype: int\n            \"\"\"\n            if not root:\n                return 0\n            left = self.maxDepth(root.left)\n            right = self.maxDepth(root.right)\n            return max(left, right) + 1\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099322903","body":"## 思路\n\n两棵树每个节点遍历判断\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n            if not p and not q:\n                return True\n            if not p or not q:\n                return False\n            if p.val != q.val:\n                return False\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100351497","body":"## 思路\n\n注意其中一边子树为空的情况，要多加两个条件判断左子树为空或者右子树为空\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sumNumbers(self, root: Optional[TreeNode]) -> int:\n            if not root:\n                return 0\n            return self.helper(root, 0)\n\n\n        def helper(self, root, sumNum):\n            if not root.left and not root.right:\n                return sumNum * 10 + root.val\n            if not root.left:\n                return self.helper(root.right, sumNum * 10 + root.val)\n            if not root.right:\n                return self.helper(root.left, sumNum * 10 + root.val)\n            left = self.helper(root.left, sumNum * 10 + root.val)\n            right = self.helper(root.right, sumNum * 10 + root.val)\n            return left + right\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100321067","body":"## 思路\n\nBFS，然后返回最左边 bottom 的节点\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n            q = deque()\n            q.append(root)\n            res = []\n            while q:\n                size = len(q)\n                temp = []\n                for i in range(size):\n                    cur = q.popleft()\n                    temp.append(cur.val)\n                    if cur.left:\n                        q.append(cur.left)\n                    if cur.right:\n                        q.append(cur.right)\n                res.append(temp[:])\n            return res[-1][0]\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100754160","body":"## 思路\n\npreorder traversal transform the root data to a string, and use queue to store the data after transform it to array.\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, x):\n    #         self.val = x\n    #         self.left = None\n    #         self.right = None\n\n    class Codec:\n\n        def serialize(self, root):\n            \"\"\"Encodes a tree to a single string.\n            \n            :type root: TreeNode\n            :rtype: str\n            \"\"\"\n            if not root:\n                return \"#\"\n            return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\n            \n\n        def deserialize(self, data):\n            \"\"\"Decodes your encoded data to tree.\n            \n            :type data: str\n            :rtype: TreeNode\n            \"\"\"\n            temp = data.split(\",\")\n            q = deque(temp)\n            return self.helper(q)\n            \n        def helper(self, q):\n            if not q:\n                return None\n            \n            cur = q.popleft()\n            if cur == \"#\":\n                return None\n            root = TreeNode(cur)\n            root.left = self.helper(q)\n            root.right = self.helper(q)\n            return root\n            \n\n    # Your Codec object will be instantiated and called as such:\n    # ser = Codec()\n    # deser = Codec()\n    # ans = deser.deserialize(ser.serialize(root))\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1105684936","body":"## 思路\n\n用map记录每个坐标节点list的值，最后加进来的时候要把同坐标的list排序\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution(object):\n        def verticalTraversal(self, root):\n            \"\"\"\n            :type root: TreeNode\n            :rtype: List[List[int]]\n            \"\"\"\n            self.seen = collections.defaultdict(lambda: collections.defaultdict(list))\n            self.dfs(root, 0, 0)\n            \n            res = []\n            for col in sorted(self.seen):\n                level = []\n                for row in sorted(self.seen[col]):\n                    level += list(v for v in sorted(self.seen[col][row]))\n                res.append(level[:])\n            return res\n            \n        def dfs(self, root, row, col):\n            if not root:\n                return \n            self.seen[col][row].append(root.val)\n            self.dfs(root.left, row + 1, col - 1)\n            self.dfs(root.right, row + 1, col + 1)\n            \n```\n\n## 复杂度\n\ntime O(NlogN)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1104686710","body":"## 思路\n\n如果另一个数字的idx不等于当前idx，就返回结果数组，然后对遍历的每项都存到map中\n\n## 代码\n\n```python\n    class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        map = {}\n        for idx, val in enumerate(nums):\n            num2 = target - val\n            if map.get(num2) != None and map.get(num2) != idx:\n                return [map.get(num2), idx]\n            map[val] = idx\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1105495615","body":"## 思路\n\n与215类似，先用map统计数字频率，用set去重后再用heapq排序，建最大堆，然后取前k个元素即可。\n\n## 代码\n\n```python\n    class Solution(object):\n        def topKFrequent(self, nums, k):\n            \"\"\"\n            :type nums: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            m = collections.defaultdict(int)\n            for num in nums:\n                m[num] += 1\n            s = set(nums)\n            \n            pq = []\n            heapq.heapify(pq)\n            while s:\n                num = s.pop()\n                heapq.heappush(pq, (-m[num], num))\n                \n            res = []\n            for i in range(k):\n                count, num = heapq.heappop(pq)\n                res.append(num)\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105435367","body":"class Solution(object):\n    def numberOfBoomerangs(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        res = 0\n        for i in range(len(points)):\n            m = collections.defaultdict(int)\n            for j in range(len(points)):\n                dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                m[dis] += 1\n            for count in m.values():\n                res += count * (count - 1)\n        return res","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105477808","body":"## 思路\n\n只要set中有重复数字就移动左窗口，移动后求res。\n\n## 代码\n\n```python\n    class Solution:\n        def lengthOfLongestSubstring(self, s: str) -> int:\n            charSet = set()\n            left, res = 0, 0\n            for i in range(len(s)):\n                char = s[i]\n                while char in charSet:\n                    d = s[left]\n                    left += 1\n                    charSet.remove(d)\n                charSet.add(char)\n                res = max(res, i - left + 1)\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107876608","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        p1, p2 = head, head\n        \n        while p2 and p2.next:\n            p1 = p1.next\n            p2 = p2.next.next\n        return p1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109091807","body":"## 思路\n\ncur指针为当前待加入的idx\n\n## 代码\n\n```python\n    class Solution:\n        def removeDuplicates(self, nums: List[int]) -> int:\n            cur = 1\n            for i in range(1, len(nums)):\n                if nums[i] != nums[cur - 1]:\n                    nums[cur] = nums[i]\n                    cur += 1\n            return cur\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110063383","body":"## 思路\n\n二分模版\n\n## 代码\n\n```python\n    class Solution(object):\n        def searchInsert(self, nums, target):\n            \"\"\"\n            :type nums: List[int]\n            :type target: int\n            :rtype: int\n            \"\"\"\n            lo, hi = 0, len(nums) - 1\n            res = 0\n            while lo <= hi:\n                mid = (lo + hi) >> 1\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] > target:\n                    # res = mid\n                    hi = mid - 1\n                else:\n                    # res = mid\n                    lo = mid + 1\n            return lo\n```\n\n## 复杂度\n\ntime O(LogN)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111506650","body":"## 思路\n\n保持单调队列，每次更新队列的最大值，每次更新队列的最大值的时候，更新结果数组。\n\n## 代码\n\n```python\n    class Solution:\n        def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n            q = deque()\n            n = len(nums)\n            res = []\n            for i in range(n):\n                # print(q)\n                while q and i - q[0] >= k:\n                    q.popleft()\n                while q and nums[q[-1]] <= nums[i]:\n                    q.pop()\n                q.append(i)\n                if i - k + 1 >= 0:\n                    res.append(nums[q[0]])\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112486022","body":"## 思路\n\n建图，返回出度为0和入度为n-1的点。\n\n## 代码\n\n```python\n    class Solution(object):\n        def findJudge(self, n, trust):\n            \"\"\"\n            :type n: int\n            :type trust: List[List[int]]\n            :rtype: int\n            \"\"\"\n            if not trust and n == 1:\n                return 1\n            graph = collections.defaultdict(list)\n            outdegree = collections.defaultdict(int)\n            indegree = collections.defaultdict(int)\n            for item in trust:\n                graph[item[0]].append(item[1])\n                indegree[item[1]] += 1\n                outdegree[item[0]] += 1\n                if item[1] not in outdegree:\n                    outdegree[item[1]] = 0\n                    \n            for key in outdegree.keys():\n                if outdegree[key] == 0 and indegree[key] == n - 1:\n                    return key\n            return -1\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387672","body":"### 思路\n将k加到最后一位，取余放在当前位，接着/10继续向前加\n### 代码\n``` c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       //将K加到最后一位，依次向前\n       vector<int> res;\n       for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\n           //if(i>=0){\n           //    int sum=num[i]+k;\n           //    res.push_back(sum%10);\n           //}\n           //else{\n           //    res.push_back(k%10);\n          // }\n          //上面这一段还是没想清楚\n          if(i>=0){\n              k+=num[i];\n          }\n          res.push_back(k%10);\n       }\n       reverse(res.begin(),res.end());\n       return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）遍历一遍数组\n* 空间复杂度：O（n），建立了数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537714","body":"### 思路\n两次遍历，从左到右更新一遍，从右到左更新一遍\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res(s.size());\n        //方法二，只遍历两次，先从左到右，再从右到左\n        int prev=INT_MAX/2;//防止越界，所以除以2\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=i-prev;\n        }\n        prev=INT_MAX/2;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=min(abs(res[i]),prev-i);\n        }\n    return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）\n* 空间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767470","body":"### 思路\n利用数组，使用了三个参数，分别表示最大容量，当前栈顶位置和指向栈的指针\n### 代码\n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        size=maxSize;\n        arr=new int[size];\n        top=-1;\n    }\n    ~CustomStack(){//析构函数\n        delete [] arr;\n    }\n    void push(int x) {\n        if(top==size-1){//栈满\n            return ;\n        }\n        arr[++top]=x;\n    }\n    int pop() {\n        if(top==-1){//栈空\n            return -1;\n        }\n        return arr[top--];//弹出栈顶元素，并--\n    }\n    void increment(int k, int val) {\n        if(top+1<k){//所有元素都增加val\n            for(int i=0;i<=top;i++){\n                arr[i]+=val;\n            }\n        }\n        else{\n            for(int i=0;i<k;i++){\n                arr[i]+=val;\n            }\n        }\n    }\nprivate:\n    int size;//栈的最大容量\n    int top;//当前元素数量,栈顶\n    int* arr;//指向栈的指针\n};\n```\n### 复杂度分析\n* 时间复杂度：push,pop O(1)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087283863","body":"### 思路\n利用数组vector<string>构造栈，利用栈先进先出的结构来处理[],学习的leetcode题解\n### 代码\n``` C++\nclass Solution {\npublic:\n    string GetDigit(string& s,size_t& ptr){\n        string ret=\"\";\n        while(isdigit(s[ptr])){\n            ret.push_back(s[ptr++]);//此处要对Ptr做出改动，因此传入&\n        }\n        return ret;//将字符数字转化为字符串数字\n    }\n    string GetString(vector<string>& sub){\n        string tmp=\"\";\n        for(string& s:sub){\n            tmp+=s;\n        }\n        return tmp;\n    }\n    string decodeString(string s) {\n        //啊，好难啊，解法一，利用栈先进先出的特点来处理【】\n        //首先建立一个栈（使用数组）vector<string>\n        vector<string> stk;\n        size_t ptr=0;//size_t=unsigned_int\n        while(ptr<s.size()){//遍历字符串\n            char ch=s[ptr];\n            //1、处理数字\n            if(isdigit(ch)){\n                //取出的是字符，要压入的是string\n                stk.push_back(GetDigit(s,ptr));\n            }\n            //2、处理字母和\"[\",继续将字符转为string,压入栈中\n            else if(isalpha(ch) || ch=='['){\n                stk.push_back(string(1,s[ptr++]));\n            }\n            //3、处理‘]’开始弹栈\n            else{\n                ++ptr;\n                //建立处理子字符串的vector<string>\n                vector<string> sub;\n                while(stk.back()!=\"[\"){\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                //去掉\"[\"\n                stk.pop_back();\n                //逆转sub顺序\n                reverse(sub.begin(),sub.end());\n                //得到字符串\n                string tmp_0=GetString(sub);\n                //取出栈中数量,stoi函数将字符串转化为十进制\n                int repTime=stoi(stk.back());\n                stk.pop_back();//弹出数字\n                //新字符串\n                string tmp_1;\n                //构造字符串\n                while(repTime--){\n                    tmp_1+=tmp_0;\n                }\n                //将构造好的字符串压入栈中\n                stk.push_back(tmp_1);\n            }\n        }\n    return GetString(stk);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O(n)，遍历字符串+一些额外操作\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088273931","body":"### 思路\n两个栈，一个进，一个出\n### 代码\n```C++\nclass MyQueue {\nprivate:\n    stack<int> instack;\n    stack<int> outstack;\n    void inout(){\n        //此处不可以用pop，pop是删除栈顶元素，无返回值，使用top返回\n        while(!instack.empty()){//empty空返回true,不空返回false\n            outstack.push(instack.top());\n            instack.pop();//删除\n        }\n    }\npublic:\n    //使用两个栈，一个instack,一个outstack\n    MyQueue() {\n        //stack栈后进先出，队列先进先出\n    }\n    //析构可以省略，因为数据都是容器，只有析构函数；\n    void push(int x) {\n        instack.push(x); \n    }\n    \n    int pop() {\n        if(outstack.empty()){\n            inout();\n        }\n        int temp=outstack.top();//读取栈顶元素\n        outstack.pop();//删除栈顶\n        return temp;//返回元素\n    }\n    \n    int peek() {\n        //返回队列开头元素\n        if(outstack.empty()){\n            inout();\n        }\n        return (outstack.top());//读取栈顶元素\n    }\n    \n    bool empty() {\n        return (instack.empty() && outstack.empty());\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：push-o(1),pop-o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089857736","body":"### 思路\n单调栈，下一块的最小值大于等于上一块的最大值，以每块最大值代表一块\n### 代码\n``` C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        //使用单调栈\n        stack<int> stack_1;\n        int max=-1;\n        //遍历数组\n        for(int num:arr){\n            if(num>=max){\n                max=num;\n                stack_1.push(num);\n            }\n            else{\n                while(!stack_1.empty() && num<stack_1.top()){\n                    stack_1.pop();\n                }\n                stack_1.push(max);\n            }\n        }\n    return stack_1.size();\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091026256","body":"### 思路\n将链表连成环，之后再移动head\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n       //1、排除0情况\n       if(k==0 || head==nullptr || head->next==nullptr){\n           return head;\n       }\n       //2、找到尾结点，获取节点数量\n       ListNode* tmp=head;\n       int size=1;\n       while(tmp->next){\n           tmp=tmp->next;\n           size++;\n       }\n       //3、连接尾结点和头结点\n       tmp->next=head;\n       //4、移动头结点\n       int num=abs(size-k%size)-1;\n       while(num--){\n           head=head->next;\n       }\n       //5、断开连接的前一个节点\n       ListNode*tmp_1=head->next;\n       head->next=nullptr;\n       return tmp_1;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092398656","body":"### 思路一（迭代）\n迭代（两两交换）+虚拟节点\n### 代码\n``` C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n       //2022.4.8\n       //!!!!利用虚拟头结点，不需要单独处理头结点\n       //head就是virhead\n       //virhead要分配内存的\n       ListNode* virhead=new ListNode(0);\n       virhead->next=head;\n       ListNode* cur=virhead;//cur一定是在virhead的位置，而不能在virhead->next位置\n       //它要代表上一次迭代的尾结点\n       while(cur->next!=nullptr && cur->next->next!=nullptr){\n           ListNode* tmp_1=cur->next;\n           ListNode* tmp_2=cur->next->next;\n           tmp_1->next=cur->next->next->next;\n           tmp_2->next=tmp_1;\n           cur->next=tmp_2;\n           //移动cur到下一次迭代位置\n           cur=cur->next->next;\n       }\n       head=virhead->next;\n       delete virhead;\n       return head;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度为O(n)\n* 空间复杂度为O(1)\n### 思路二 （递归）\n每次交换两个节点内部的顺序，返回值为两个节点的头结点指针\n### 代码\n``` C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n       //2022.4.8\n       //递归,注意设立结束递归的条件\n       //每次处理两个节点，返回头结点\n       //没法用虚拟节点了\n       if(head==nullptr || head->next==nullptr){\n           return head;\n       }\n       ListNode* newhead=head->next;\n       head->next=swapPairs(newhead->next);\n       newhead->next=head;\n       return newhead;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度o(n)\n* 空间复杂度o(n),递归使用栈空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093665360","body":"### 思路\n快慢指针找中位数+递归建树；\n### 代码\n```C++\nclass Solution {\npublic:\n    //快慢指针找中位数，递归确定树的结构，从根节点开始\n    //左闭右开，因为链表，上一个节点不好找\n    //1、找中位数，在链表中,快慢指针\n    ListNode* findMid(ListNode* left,ListNode* right){\n        ListNode* low=left;\n        ListNode* fast=left;\n        while(fast!=right && fast->next!=right){\n            fast=fast->next->next;\n            low=low->next;\n        }\n        return low;\n    }\n    //2、形成递归，依次构建树节点\n    TreeNode* findRoot(ListNode* left,ListNode* right){\n        //递归结束条件\n        if(left==right){\n            return nullptr;\n        }\n        ListNode* mid=findMid(left,right);\n        TreeNode* root=new TreeNode(mid->val);//mid是链表节点指针，用值创建根节点\n        root->left=findRoot(left,mid);//左闭右开\n        root->right=findRoot(mid->next,right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return findRoot(head,nullptr);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：T(n)=2T(n/2)+o(n);=o(nlog(n));\n* 空间复杂度：o(log(n)),平衡二叉树的深度为这个，因此空间复杂度为o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094164837","body":"### 思路\n确定两个链表长度，较长链表指针后移对齐，两个链表指针一起后移寻找交点\n### 代码\n``` C++\nclass Solution {\npublic:\n    //判断链表长度\n    int getLen(ListNode* head){\n        int size=0;\n        while(head!=nullptr){\n            head=head->next;\n            size++;\n        }\n        return size;\n    }\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        //是否相交，重点在于地址判断，\n        ListNode* tmpA=headA;\n        ListNode* tmpB=headB;\n        //确定长度\n        int sizeA=getLen(headA);\n        int sizeB=getLen(headB);\n        int sub=abs(sizeA-sizeB);\n        //对其头指针\n        if(sizeA>sizeB){\n            while(sub--){\n                tmpA=tmpA->next;\n            }\n        }\n        else{\n            while(sub--){\n                tmpB=tmpB->next;\n            }\n        }\n        //比较节点地址\n        while(tmpA!=nullptr){\n            if(tmpA==tmpB){\n                return tmpA;\n            }\n            tmpA=tmpA->next;\n            tmpB=tmpB->next;\n        }\n        return nullptr;\n    }\n};\n```\n### 复杂度分析\n时间复杂度：2o(m+n)\n空间复杂度：o(1)\n### 改进\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        //改进，都走相同的长度a+b\n        if(headA==nullptr || headB==nullptr){\n            return nullptr;\n        }\n        ListNode* tmpA=headA,*tmpB=headB;\n        while(tmpA!=tmpB){\n            tmpA=tmpA==nullptr?headB:tmpA->next;\n            tmpB=tmpB==nullptr?headA:tmpB->next;\n        }\n        return tmpA;\n    }\n};\n//时间复杂度：o(n+m)\n//空间复杂度：o(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094508158","body":"### 思路（哈希表或者快慢指针）\n### 代码（快慢指针法）\n``` C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        //2、双指针，快慢指针\n        ListNode* fast=head,*slow=head;\n        while(slow!=nullptr && fast!=nullptr && fast->next!=nullptr){\n            fast=fast->next->next;\n            slow=slow->next;\n            if(fast==slow){\n                ListNode* tmp1=head;\n                ListNode* tmp2=fast;\n                while(tmp1!=tmp2){\n                    tmp1=tmp1->next;\n                    tmp2=tmp2->next;\n                }\n                return tmp2;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度分析：o(n)\n* 空间复杂度分析：o(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096236443","body":"### 思路\n使用哈希表查询，双向链表来记录，最新的在头部，\n### 代码\n```C++\n//双向链表实现\nstruct DLinkedNode{\n    int key;\n    int value;\n    DLinkedNode* next;\n    DLinkedNode* pre;\n    //默认构造函数\n    DLinkedNode():key(0),value(0),next(nullptr),pre(nullptr){}\n    //key,value构造函数\n    DLinkedNode(int k,int v):key(k),value(v),next(nullptr),pre(nullptr){}\n};\n\n//LRUCache由哈希表+双向链表组成\nclass LRUCache {\n//数据成员\nprivate:\n    unordered_map<int,DLinkedNode*> map;\n    //存放双向链表指针即可\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int capacity;//最大容量\n    int size;//目前数量\n\npublic:\n    //构造函数\n    LRUCache(int _capacity):capacity(_capacity),size(0) {\n        head=new DLinkedNode();//虚拟头结点\n        tail=new DLinkedNode();//虚拟尾结点\n        head->next=tail;\n        tail->pre=head;\n    }\n    //析构函数\n    ~LRUCache(){\n        while(head!=nullptr){\n            DLinkedNode* tmp=head;\n            head=head->next;\n            delete tmp;\n        }\n    }\n    int get(int key) {\n        //如果key存在，将其移动到双向链表头部，返回value\n        unordered_map<int,DLinkedNode*>::iterator it=map.find(key);\n        if(it!=map.end()){\n            MoveToHead(it->second);\n            return it->second->value;\n        }\n        //如果key不存在,返回-1\n        else{\n            return -1;\n        }\n    } \n    void put(int key, int value) {\n        //如果存在，变更数据值，移动到头部\n        unordered_map<int,DLinkedNode*>::iterator it=map.find(key);\n        if(it!=map.end()){\n            //移动到头部\n            MoveToHead(it->second);\n            //变更数据值\n            it->second->value=value;\n        }\n        //如果不存在，检查是否满，删除尾结点，插入到头部\n        else{\n            //检查容量，是否需要删除\n            if(size==capacity){\n                //删除尾部\n                DelteTail(); \n            }\n            //!!!!!!!!!!创建一个新节点插入头部；\n            DLinkedNode* tmp= new DLinkedNode(key,value);\n            //插入哈希表\n            map[key]=tmp;\n            AddToHead(tmp);            \n        }  \n    }\n\n//不存在，插入结点，插入到头部\nvoid AddToHead(DLinkedNode* tmp){\n//插入头结点\n    tmp->pre=head;\n    tmp->next=head->next;\n    head->next->pre=tmp;\n    head->next=tmp;\n    size++;\n}\n//已存在，移动到头部\nvoid MoveToHead(DLinkedNode* tmp){\n    //分离出来\n    tmp->pre->next=tmp->next;\n    tmp->next->pre=tmp->pre;\n    size--;\n    AddToHead(tmp);\n}\n//删除尾部\nvoid DelteTail(){\n    //还有哈希表需要删除\n    map.erase(tail->pre->key);\n    DLinkedNode* tmp=tail->pre;\n    tail->pre->pre->next=tail;\n    tail->pre=tail->pre->pre;\n    size--;\n    //！！！！！！！！！删除防止内存泄漏\n    delete tmp;\n}\n\n};\n```\n### 复杂度分析\n* 时间复杂度：o(1)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097507073","body":"### 思路（深度优先搜索）\n### 代码\n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        //DFS深度优先搜索\n        if(root==nullptr){\n            return 0;\n        }\n        return max(maxDepth(root->left),maxDepth(root->right))+1;\n    }\n};\n```\n###复杂度分析\n* 时间复杂度：o(n)每个节点遍历一遍\n* 空间复杂度：递归深度为树的深度，o(height)\n### 思路（广度优先搜索）\n### 代码\n```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        //广度优先搜索，使用队列\n        if(root==nullptr){\n            return 0;\n        }\n        queue<TreeNode*> res;\n        res.push(root);\n        int ans=0;\n        while(!res.empty()){\n            int size=res.size();\n            while(size){\n                TreeNode* tmp=res.front();\n                res.pop();\n                if(tmp->left!=nullptr){\n                    res.push(tmp->left);\n                }\n                if(tmp->right!=nullptr){\n                    res.push(tmp->right);\n                }\n                --size;\n            }\n            ++ans;\n        }\n        return ans;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：取决于队列中的元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098659794","body":"### 思路\n深度优先搜索（DFS），递归判断根节点和左右子树是否相等\n### 代码\n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        //深度优先搜索，就是递归遍历左右子树\n        if(p==nullptr && q==nullptr){\n            return true;\n        }\n        else if(p==nullptr || q==nullptr){\n            return false;\n        }\n        else if(p->val!=q->val){\n            return false;\n        }\n        else{//当前节点相同，递归判断左右子树\n            return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n        }\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099817007","body":"### 思路\n深度优先搜索，DFS，传递之前的值\n### 代码\n```C++\nclass Solution {\npublic:\n    int dfs(TreeNode* root,int pre){\n        if(root==nullptr){\n            return 0;\n        }\n        int sum=pre*10+(root->val);\n        if(root->left==nullptr && root->right==nullptr){\n            return sum;\n        }\n        else{\n            return dfs(root->left,sum)+dfs(root->right,sum);\n        }\n    }\n    int sumNumbers(TreeNode* root) {\n        //深度优先搜索，DFS\n        return dfs(root,0);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100524850","body":"### 思路\n深度优先搜索，DFS，利用全局变量，以及dfs递归传递当前深度，时间复杂度o(n),空间复杂度o(n)\n### 代码\n```C++\nclass Solution {\npublic:\n    int left=0,maxdepth=0;\n    //递归函数，结束条件\n    void dfs(TreeNode* root,int dpth){\n        if(root==nullptr){\n            return;\n        }\n        if(dpth>maxdepth){\n            left=root->val;\n            maxdepth++;\n        }\n        dfs(root->left,dpth+1);\n        dfs(root->right,dpth+1);\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        dfs(root,1);\n        return left;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)\n### 思路\n广度优先搜索，BFS，每次只记录每一层的头结点，处理一层\n### 代码\n```C++\nclass Solution {\npublic:\n    //广度优先搜索，队列\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> Q;\n        int left;\n        if(root==nullptr){\n            return 0;\n        }\n        Q.push(root);\n        while(!Q.empty()){\n            int size=Q.size();\n            left=Q.front()->val;//只保留每一层节点的头结点\n            while(size--){//每次处理一层节点\n                TreeNode* tmp=Q.front();\n                Q.pop();\n                if(tmp->left!=nullptr){\n                    Q.push(tmp->left);\n                }\n                if(tmp->right!=nullptr){\n                    Q.push(tmp->right);\n                }\n            } \n        }\n        return left;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100813084","body":"### 思路\n深度优先搜索，DFS，\n### 代码\n```C++\nclass Codec {\npublic:\n    void rserialize(TreeNode* root,string& ret){\n        if(root==nullptr){\n            ret+=\"None,\";\n        }\n        else{\n            //要以“，”作为分隔符，先序遍历，中左右\n            ret += to_string(root->val) + \",\";\n            rserialize(root->left,ret);\n            rserialize(root->right,ret);\n        }\n        \n    }\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        //序列化，将树变为字符串\n        string ret;\n        rserialize(root,ret);\n        return ret;\n    }\n    //此处传入引用\n    TreeNode* rdeserialize(list<string>& Lnode){\n        if(Lnode.front()==\"None\"){\n            Lnode.erase(Lnode.begin());\n            return nullptr;\n        }\n        TreeNode* root=new TreeNode(stoi(Lnode.front()));\n        Lnode.erase(Lnode.begin());\n        root->left=rdeserialize(Lnode);\n        root->right=rdeserialize(Lnode);\n        return root;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        //反序列化，将字符串，变成树\n        //将字符串进行分割\n        list<string> Lnode;\n        string str;\n        //要对其进行修改，因此用引用\n        for(char& ch:data){\n            if(ch==','){\n                Lnode.push_back(str);\n                str.clear();\n            }\n            else{\n                str.push_back(ch);\n            }\n        }\n        return rdeserialize(Lnode);    \n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101148494","body":"### 思路\n用DFS遍历树，自定义Node及其优先级，插入优先队列进行排序，然后输出目的数组\n### 代码\n```C++\nclass Solution {\npublic:\n        //采用DFS和优先队列，元素被赋予优先级\n        //优先队列三个参数，数据类型，容器（必须是以数组实现的），对比仿函数\n        //会按照优先级高的元素先出队\n        //1、定义排序规则,自定义元素类型并重载<\n        struct Node{\n            int val,x,y;\n            Node(int v,int a,int b):val(v),x(a),y(b){};\n            bool operator<(Node n)const{\n                if(y!=n.y)return y>n.y;\n                else if(x!=n.x)return x>n.x;\n                return val>n.val;\n            }\n        };\n        //2、使用unordered_map记录每个元素的行，列及元素值，DFS遍历\n        priority_queue<Node> myQueue;\n        //通过DFS遍历，填充map\n        void dfs(TreeNode* root,int x,int y){\n            if(root==nullptr){\n                return;\n            }\n            //插入优先队列，而且按照优先级排序\n            myQueue.push({root->val,x,y});\n            dfs(root->left,x+1,y-1);\n            dfs(root->right,x+1,y+1);      \n        }\n        //3、返回目标二维数组 \n        vector<vector<int>> verticalTraversal(TreeNode* root) {\n            vector<vector<int>> res{};\n            dfs(root,0,0);\n            int i=0;\n            while(!myQueue.empty()){\n                Node tmp=myQueue.top();//返回栈顶元素\n                int row=tmp.y;//当前行\n                //!!!!必须先插入一个空数组！！！\n                res.push_back(vector<int>());\n                while(row==tmp.y && !myQueue.empty()){\n                    res[i].push_back(tmp.val);\n                    myQueue.pop();\n                    tmp=myQueue.top();\n                }\n                i++;\n            }\n        return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(nlogn)，插入优先序列排序的时间复杂度\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101948795","body":"### 思路\n哈希表，unordered_map，数值为key,坐标为value\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n       //解法二，哈希表\n       unordered_map<int,int> myMap;\n       for(int i=0;i<nums.size();i++){\n           unordered_map<int,int>::iterator it=myMap.find(target-nums[i]);\n           if(it==myMap.end()){\n               myMap.insert(pair<int,int>(nums[i],i));\n           }\n           else{\n               return {it->second,i};\n           }\n       }\n       return {};\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n),因为unordered_map查找为o(1)\n* 空间复杂度：o(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104690011","body":"### 思路\n两层循环遍历计算之间的距离，将距离出现个数存储在unordered_map中，再使用排列组合\n### 代码\n```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans=0;\n        for(vector<int>num_0 : points){\n            unordered_map<int,int> myMap;\n            for(auto num_1 : points){\n                int distance=(num_0[0]-num_1[0])*(num_0[0]-num_1[0])+(num_0[1]-num_1[1])*(num_0[1]-num_1[1]);\n                myMap[distance]++;\n            }\n            for(auto &[_,m]:myMap){\n                ans+=m*(m-1);\n            }\n        }\n        return ans;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n^2)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106203724","body":"### 思路\n哈希表记录出现过的字符，双指针来确定当前字符串，取最大的值返回\n### 代码\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        //双指针+哈希表\n        int Max=0;\n        unordered_map<char,int> maMap;\n        int left=0,right=0;\n        while(right<s.size()){\n            unordered_map<char,int>::iterator it=maMap.find(s[right]);\n            if(it!=maMap.end()){\n                if((it->second)>=left){\n                    left=(it->second)+1;\n                }  \n            }\n            maMap[s[right]]=right;\n            right++;\n            Max=max(Max,right-left);\n        }\n        return Max;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(不同字符数)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107346354","body":"### 思路\n滑动窗口，两个哈希表，一个记录words，一个记录滑动子串\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        if(words.size()==0){\n            return {};\n        }\n        int word_len=words[0].size();\n        int word_num=words.size();\n        //滑动窗口长度\n        int win_len=word_len*word_num;\n        //哈希表m1记录words\n        unordered_map<string,int> m1;\n        for(string num:words){\n            m1[num]++;\n        }\n        for(int i=0;i<s.size()-win_len+1;i++){\n            //哈希表m2记录滑动子串\n            unordered_map<string,int> m2;\n            int j;\n            for(j=i;j<i+win_len;j+=word_len){\n                //利用string截取子字符串substr\n                string sub=s.substr(j,word_len);\n                m2[sub]++;\n                if(m1[sub]==0 || m1[sub]<m2[sub]){\n                    break;\n                }\n            }\n            if(j==i+win_len){\n                res.push_back(i);\n            }\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n*m),n为s长度，m为单词数量\n* 空间复杂度：o(m)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108104229","body":"### 思路\n快慢指针，fast移动两步，slow移动一步\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if(head->next==nullptr){\n            return head;\n        }\n        ListNode* fast=head,*slow=head;\n        while(fast->next!=nullptr && fast->next->next!=nullptr){\n            fast=fast->next->next;\n            slow=slow->next;\n        }\n        if(fast->next == nullptr){\n            return slow;\n        }\n        return slow->next;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109279467","body":"### 思路\n快慢指针\n### 代码\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        //双指针，升序排列，相同元素都在一起挨着\n        int slow=0,fast=0;\n        while(fast<nums.size()){\n            if(fast+1<nums.size() && nums[fast]==nums[fast+1]){\n                fast++;\n            }\n            else{\n                nums[slow++]=nums[fast++];\n            }\n        }\n        return slow;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110494216","body":"### 思路\n左闭右闭区间，二分查找\n### 代码\n```C++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n       //写一个左闭右开\n       int left=0,right=nums.size();//因为，右开，所以取不到\n       int mid;\n       while(left<right){//左闭右开，右边取不到\n            mid=left+(right-left)/2;\n            if(nums[mid]>target){\n                right=mid;//因为取不到\n            }\n            else if(nums[mid]<target){\n                left=mid+1;\n            }\n            else{\n                return mid;\n            }\n       }\n       return left;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(logn)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111791631","body":"### 思路\n双端队列，维护一个在k个窗口的单调递减序列，新来值与队尾值比较\n### 代码\n```C++\nclass Solution {\npublic:\n    //使用单调队列，双端队列\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> q;\n        for(int i=0;i<k;i++){\n            while(!q.empty() && nums[i]>=nums[q.back()]){\n                q.pop_back();\n            }\n            q.push_back(i);      \n        }\n        vector<int> res;\n        res.push_back(nums[q.front()]);\n        for(int i=k;i<nums.size();i++){\n            while(!q.empty() && nums[i]>=nums[q.back()]){\n                q.pop_back();\n            }\n            q.push_back(i);\n            while(q.front()<=i-k){\n                q.pop_front();\n            }\n            res.push_back(nums[q.front()]);\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112841284","body":"### 思路\n模拟图，出入度，使用一个数组，当存在==n-1就是法官\n### 代码\n```C++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> tmp(n+1);\n        for(auto num:trust){\n            --tmp[num[0]];\n            ++tmp[num[1]];\n        }\n        for(int i=1;i<=n;i++){\n            if(tmp[i]==n-1){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387840","body":"### 思路： \n模拟加法，从后往前逐位相加\n\n### 代码：\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length\n    for (let i = len-1;i>=0;i--) {\n        let sum = num[i] + k%10\n        k = Math.floor(k/10)\n        if (sum >=10) {\n            k++\n            sum = sum-10\n        }\n        res.unshift(sum)\n    }\n    // k > 0 往数组上继续添加高位\n    while(k>0) {\n        res.unshift(k%10)\n        k = Math.floor(k/10)\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086647422","body":"### 思路： \n两头遍历，取较小值\n\n### 代码：\n```js\nvar shortestToChar = function(s, c) {\n    let len = s.length\n    let left = []\n    let right = []\n    for (let i = 0;i <len;i++) {\n        if (s.indexOf(c,i)==-1) {\n            left.push(Infinity)\n        } else {\n            left.push(s.indexOf(c,i)-i)\n        }  \n    }\n    for (let i = len-1;i >= 0;i--) {\n        if (s.lastIndexOf(c,i)==-1) {\n            right.unshift(Infinity)\n        } else {\n            right.unshift(i-s.lastIndexOf(c,i))\n        }\n        \n    }\n    for (let i = 0;i < len;i++) {\n        left[i] = Math.min(left[i],right[i])\n    }\n    return left\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086772995","body":"### 思路： \n数组模拟栈\n\n### 代码：\n```js\nvar CustomStack = function(maxSize) {\n    this.size = maxSize\n    this.data = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.data.length < this.size) {\n        this.data.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.data.length!=0) {\n        return this.data.pop()\n    }else {\n        return -1\n    }\n\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.data.length)\n    for (let i = 0;i < len;i ++) {\n        this.data[i] = this.data[i] + val\n    }\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087215010","body":"### 思路： \n两个栈分别保存字符和倍数\n\n### 代码：\n```js\nvar decodeString = function(s) {\n    let numStack = []\n    let strStack = []\n    let res = '' // 当前字符串\n    let num = 0  // 倍数\n    for (let c of s ) {\n        if (!isNaN(c)) {\n            num = num*10 + (c-'0')\n         }\n        else if (c == '[') {\n            numStack.push(num)\n            strStack.push(res)\n            num = 0\n            res = ''\n        }\n        else if (c == ']') {\n            res = strStack.pop()+res.repeat(numStack.pop())\n        } else {\n            res +=c\n        }\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088383482","body":"### 思路： \n两个栈实现队列，辅助栈翻转主栈中的元素，获取队列首部的元素，实现pop\n\n### 代码：\n```js\nvar MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\n\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\nMyQueue.prototype.peek = function() {\n    return this.stack2[this.stack2.length-1] || this.stack1[0]\n};\n\nMyQueue.prototype.empty = function() {\n    return this.stack2.length == 0 && this.stack1.length == 0\n};\n\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090420049","body":"### 思路： \n原数组与排序数组中，同一分块中的和是相等的。\n### 代码：\n```js\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n\n    return count;\n};\n```\n### 复杂度：\n时间复杂度: O(n)    \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091247189","body":"### 思路： \n找到切割的节点，把后面接在前面，完成旋转。\n\n### 代码：\n```js\nvar rotateRight = function(head, k) {\n    if (!head) return null\n    let len = 0\n    let cur = head\n    while(cur) {\n        len++\n        cur=cur.next\n    }\n    k = k%len\n    if (k==0) return head\n    let cur2 = head\n    for (let i = 0;i < len-k-1;i++) {\n        cur2 = cur2.next\n    }\n    let node = cur2.next\n    let res = node\n    cur2.next = null\n    for (let i = 0;i < k-1;i++) {\n        node = node.next\n    }\n    node.next = head\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092411907","body":"### 思路： \n递归获取交换后需要连接的节点\n\n### 代码：\n```js\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let cur = head\n    let next = cur.next\n    cur.next = swapPairs(next.next)\n    next.next = cur\n    return next\n};\n```\n### 复杂度：\n时间复杂度: O(logN)    \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093669687","body":"### 思路： \n找到中间节点，构造二叉搜索树\n\n### 代码：\n```js\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { // 将链表节点的值逐个推入数组arr\n    arr.push(head.val);\n    head = head.next;\n  }\n  // 根据索引start到end的子数组构建子树\n  let buildBST = function(start,end) {\n      if (start>end) return null\n      let mid = (start+end) >>> 1\n      let root = new TreeNode(arr[mid])\n      root.left = buildBST(start,mid-1)\n      root.right = buildBST(mid+1,end)\n      return root\n  }\n  return buildBST(0,arr.length-1)\n};\n```\n### 复杂度：\n时间复杂度: O(nlogn)  \n空间复杂度: O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094175073","body":"### 思路： \n连接两个链表，双指针去遍历，最终两个指针相遇的节点必定是相交的点\n\n### 代码：\n```js\nvar getIntersectionNode = function(headA, headB) {\n    // 连接两个链表，双指针去遍历，最终两个指针相遇的节点必定是相交的点\n    if (!headA ||!headB) return null\n    let curA = headA\n    let curB = headB\n    while(curA!=curB) {\n        curA = curA!=null ? curA.next : headB\n        curB = curB!=null ? curB.next :headA\n    }\n    return curA\n};\n```\n### 复杂度：\n时间复杂度: O(m+n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094512254","body":"### 思路： \n快慢指针，从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。\n\n### 代码：\n```js\nvar detectCycle = function(head) {\n    if (head === null) {\n        return null;\n    }\n    let slow = head, fast = head;\n    while (fast !== null) {\n        slow = slow.next;\n        if (fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            return null;\n        }\n        if (fast === slow) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096413755","body":"### 思路： \n利用js Map 有序，维持map第一个值为最久未使用\n\n### 代码：\n```js\nvar LRUCache = function(capacity) {\n    this.capacity = capacity\n    this.cache = new Map()\n};\n\nLRUCache.prototype.get = function(key) {\n    if (this.cache.has(key)) {\n        // 将key放到cache最后，维持map第一位就是最久最少使用的\n        let value = this.cache.get(key)\n        this.cache.delete(key)\n        this.cache.set(key,value)\n        return value\n    }\n    return -1\n};\n\nLRUCache.prototype.put = function(key, value) {\n    if (this.cache.has(key)) {\n        this.cache.delete(key)\n        this.cache.set(key,value)\n    } else {\n        if (this.cache.size == this.capacity) {\n            // 空间满了，删除最久没使用的，新增新数据\n            this.cache.delete(this.cache.keys().next().value)\n            this.cache.set(key,value)\n        } else {\n            this.cache.set(key,value)\n        }\n    }\n};\n\n```\n### 复杂度：\n时间复杂度: O(1)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097484525","body":"\n### 思路： \n后序遍历\n\n### 代码：\n```js\n//后序遍历\nvar maxDepth = (root) => {\n    if(!root){\n        return 0;\n    }\n    var leftDeep = maxDepth(root.left);// 左边深度\n    var rightDeep = maxDepth(root.right);// 右边的深度\n    return Math.max(leftDeep,rightDeep) + 1;// 取两者的最大值，在+1(当前节点)\n}\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099096703","body":"### 思路： \nDFS 递归\n\n### 代码：\n```js\nvar isSameTree = function(p, q) {   \n    if (!p&&!q) return true\n    if (p&&!q || !p&&q || p.val!=q.val) return false\n    return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right) \n};\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100004117","body":"### 思路： \nDFS 先序遍历，将上一次的状态保留，到叶子节点时候，计算值得大小\n\n### 代码：\n```js\n// DFS 深度优先搜索 前序遍历\nvar sumNumbers = function(root) {\n    if(!root) return 0\n    if (!root.left&&!root.right) return root.val\n    let sum = 0\n    var dfs = function(root,str) {\n        if (!root.left&&!root.right) sum+= +(str+root.val)\n        root.left && dfs(root.left,str+root.val)\n        root.right && dfs(root.right,str+root.val)\n    }\n    dfs(root,'')\n    return sum\n}\n\n// BFS\n// var sumNumbers = function(root) {\n//   let sum = 0\n//   let queen = [[root,'']]\n//   while(queen.length) {\n//       let node = queen.pop()\n//       node[0].left&&queen.push([node[0].left,node[1]+node[0].val])\n//       node[0].right&&queen.push([node[0].right,node[1]+node[0].val])\n//       if (!node[0].left&&!node[0].right) {\n//           sum += (node[1]+node[0].val) | 0\n//       }\n//   }\n//   return sum\n// }\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100513926","body":"### 思路： \nDFS\n\n### 代码：\n```js\nvar findBottomLeftValue = function(root) {\n    let maxdepth = 1\n    let leftValue = root.val\n    let dfs = function(root,depth) {\n        if(depth>maxdepth&&!root.left&&!root.right) {\n            leftValue = root.val\n            maxdepth = depth\n        }\n        root.left&&dfs(root.left,depth+1)\n        root.right&&dfs(root.right,depth+1)\n    }\n    dfs(root,1)\n    return leftValue\n}\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100857477","body":"### 思路： \n前序遍历 将树转为字符串，再将字符串还原成树\n\n### 代码：\n```js\nconst serialize = (root) => {\n  if (root === null) return \"X\";\n  const left = serialize(root.left);\n  const right = serialize(root.right);\n  return root.val + \",\" + left + \",\" + right;\n};\n\nconst deserialize = (data) => {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list); // 构建的入口\n};\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101067493","body":"### 思路： \ndfs 二维数组保存节点坐标和对应的值，排序\n\n### 代码：\n```js\nvar verticalTraversal = function(root) {\n    if (!root) {\n        return [];\n    }\n\n    // 二维数组 存坐标和值，形式如 [[x, y, val], [...]]\n    let locationList = []; \n\n    // 先dfs前序遍历记录下节点坐标和值\n    const dfs = function(root, x, y) {\n        if (!root) {\n            return;\n        }\n        locationList.push([x, y, root.val]);\n        dfs(root.left, x - 1, y - 1);\n        dfs(root.right, x + 1, y - 1);\n    }\n    dfs(root, 0, 0);\n    // 节点按坐标中的值计算位置，根左子树x-1,y-1,右子树x+1 y-1\n    // 按照x升序，y降序，val升序，x不同优先x 什序，若x相同，则y其次，降序排列，若y也相同，则按照节点的值得什序排列\n    locationList = locationList.sort((a, b) => {\n        if(a[0] != b[0]) {\n            return a[0] - b[0];\n        }\n        if (a[1] != b[1]) {\n            return b[1] - a[1]\n        }\n        return a[2] - b[2];\n    });\n    \n    // curValOfX当前遍历的节点的x的值，默认先取第一个节点的x值\n    let curValOfX = locationList[0][0]; // 第一个节点的x坐标\n    let result = [[locationList[0][2]]];// 第一个节点的值\n\n    // 从第2个节点开始遍历坐标数组，把x相同的val分成一组\n    for (let i = 1; i < locationList.length; i++) {\n        let location = locationList[i];\n        let x = location[0];\n        if (x == curValOfX) { // x坐标相同，push到同一个数组中\n            let last = result[result.length - 1];\n            last.push(location[2]);\n        } else { // x坐标不同，直接push 一个新数组到result中。由于值已经是按什序排列了，所以进入遍历的顺利，就保证了值按升序排列\n            curValOfX = x;\n            result.push([location[2]]); \n        }\n    }\n    return result;\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102750967","body":"### 思路： \nMap\n\n### 代码：\n```js\n // 使用map 保存\nvar twoSum = function(nums, target) {\n    let map = new Map() \n    for (let i = 0;i < nums.length;i++) {\n        if (!map.has(target-nums[i])) {\n            map.set(nums[i],i)\n        } else {\n            return [i,map.get(target-nums[i])]\n        }\n    }\n    return []\n};\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104056117","body":"### 思路： \nMap  +  小顶堆\n\n### 代码：\n```js\nvar topKFrequent = function(nums, k) {\n    const cnt = new Map()\n    for (let i = 0; i < nums.length; i ++) {\n        cnt.set(nums[i], (cnt.get(nums[i]) || 0) + 1)\n    }\n    const mini = new MinPriorityQueue()\n    for (const [key, v] of cnt.entries()) {\n        if (mini.size() < k) {\n            mini.enqueue(key, v)\n        } else {\n            if (v > mini.front().priority) {\n                mini.dequeue()\n                mini.enqueue(key, v)\n            }\n        }\n    }\n    // console.log(mini.toArray())\n    return mini.toArray().map((item) => item.element)\n};\n```\n### 复杂度：\n时间复杂度: O(nlogn)   \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104640128","body":"### 思路： \nmap 保存每个拐点到其他节点的距离相等的个数，统计当前节点构成回旋镖的数量\n\n### 代码：\n```js\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n          // 距离为0的点有一个，m*(m-1) 后就会变成0,不影响\n          const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]); \n          cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        // 计算以这个点为拐点的回旋镖数量，在m中取两个的排列组合 m*（m-1）\n        for (const [_, m] of cnt.entries()) {\n          ans += m * (m - 1);\n        }\n        // console.log(cnt.entries())\n    }\n    \n    return ans;\n};\n```\n### 复杂度：\n时间复杂度: O(n^2)   \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106589876","body":"### 思路： \nMap 针对每个字符 查找，以该字符为起始点的 最长子串，\n\n### 代码：\n```js\nvar lengthOfLongestSubstring = function (s) {\n    if (s.length <= 1) return s.length\n    let max = 1\n    for (let i = 0; i < s.length; i++) {\n        \n        let map = new Map()\n        map.set(s[i], 1)\n        for (let j = i + 1; j < s.length; j++) {\n            if (!map.has(s[j])) {\n                map.set(s[j], 1)\n                // 没有重复，比较出，最大值Ï\n                max = Math.max(max, j - i + 1)\n            } else {\n                // 有重复，直接下一个\n                break\n            }\n        }\n    }\n    return max\n};\n```\n### 复杂度：\n时间复杂度: O(n^2)   \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107354303","body":"### 思路： \nhashmap + 暴力搜索\n\n### 代码：\n```js\nvar findSubstring = function(s, words) {\n    if (!s || !words || !words.length) return [];\n    let wordLen = words[0].length // 单个字符的长度\n    let len = words.length // 单词的个数\n    let allWordsLen = wordLen*len\n    let ans = [], wordMap = {};\n    // 哈希表记录每个字符出现的次数\n    for (let w of words) {\n        wordMap[w] ? wordMap[w]++ :wordMap[w] = 1\n    }\n    for (let i = 0; i < s.length - allWordsLen + 1; i++) {\n        let wm = Object.assign({}, wordMap);\n        for (let j = i; j < i + allWordsLen - wordLen + 1; j += wordLen) {\n            let w = s.slice(j, j + wordLen);\n            if (wm[w]) {\n                wm[w]--\n            } else {\n                break;\n            }\n        }\n        if (Object.values(wm).every(n => n === 0)) ans.push(i);\n    }\n    return ans;\n};\n```\n### 复杂度：\n时间复杂度: O(mn) m为s长度，n为words长度  \n空间复杂度: O(m+n) \n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108038908","body":"### 思路： \n快慢指针\n\n### 代码：\n```js\nvar middleNode = function(head) {\n    let fast = head\n    let slow = head\n    while(fast.next&&fast.next.next) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return fast.next ? slow.next : slow\n}\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109895270","body":"### 思路： \n双指针\n\n### 代码：\n```js\n // 把不相同的数字移动到数组前面\nvar removeDuplicates = function(nums) {\n    let len = nums.length\n    if(!len) return 0\n    let slow = 0\n    for (let fast = 1;fast < nums.length;fast++) {\n        if (nums[fast]!=nums[slow]) {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow+1\n};\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110680330","body":"### 思路： \n二分\n\n### 代码：\n```js\nvar searchInsert = function(nums, target) {\n    let len = nums.length\n    let left = 0\n    let right = len-1\n    while(left<=right) {\n        let mid = (left+right)>>1\n        if (nums[mid]==target) {\n            return mid\n        } else if (nums[mid]>target) {\n            right = mid-1\n        } else {\n            left = mid+1\n        }\n    }\n    return left\n}\n```\n### 复杂度：\n时间复杂度: O(logn)   \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112044772","body":"### 思路： \n双端队列 + 滑动窗口\n\n### 代码：\n```js\n // 保持一个滑动窗口，内部递减，且是一个双端队列\nvar maxSlidingWindow = function (nums, k) {\n    let res = []\n    let len = nums.length\n    let slidewindow = [] // 保存元素下标\n    for (let i = 0;i < len;i++) {\n        // 保证双端队列递减，每次取队列头\n        while(slidewindow.length&&nums[i]>=nums[slidewindow[slidewindow.length-1]]) {\n            slidewindow.pop()\n        }\n        slidewindow.push(i)\n        // 当队列首部元素不在窗口中时，需要移除掉\n        while(slidewindow[0]<=i-k) {\n            slidewindow.shift()\n        }\n        if (i>=k-1) res.push(nums[slidewindow[0]])\n    }\n    return res\n}\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113154725","body":"### 思路： \n求图中，入度为n-1,出度为0的值\n\n### 代码：\n```js\n // 求图中，入度为n-1,出度为0的值\nvar findJudge = function(n, trust) {\n    let indegree = new Array(n+1).fill(0)\n    let outdegree = new Array(n+1).fill(0)\n    for (let i = 0;i<trust.length;i++) {\n        let x = trust[i][0] // x出度+1\n        let y = trust[i][1] // y入度+1        \n        outdegree[x]++\n        indegree[y]++\n    }\n    // 查找符合条件\n    for (let i = 1;i <= n;i++) {\n        if (indegree[i]===n-1&&outdegree[i]===0) {\n            return i\n        }\n    }\n    return -1\n};\n```\n### 复杂度：\n时间复杂度: O(n)   \n空间复杂度: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085396374","body":"### 思路\r\n\r\n从最后一位开始模拟加法进位计算， 注意不可以直接转化成数字相加会溢出 - Integer\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = num.length - 1;\r\n        //先将最后一位加入list，此时list为倒序\r\n        int sum = num[len] + k;\r\n        result.add(sum % 10);\r\n        int carry = sum / 10;\r\n        \r\n        //从倒数第二位开始循环\r\n        for(int i = len - 1; i >= 0; i --) {\r\n            sum = num[i] + carry;\r\n            result.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        \r\n        //如果carry还有进位\r\n        while(carry > 0) {\r\n            result.add(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        \r\n        //反转数组\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, log k))，其中 N 为数组num长度。\r\n- 空间复杂度：O(max(N, log k)), 储存结果的新数组\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086552671","body":"### 思路\n\n前序遍历数组找出与左侧的字母的最短距离，后序遍历数组找出与右侧字母的最短距离，两者取其最小为最终结果。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] result = new int[len];\n        int max = len - 1;\n        \n        int cur = max;\n        for(int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                cur = 0;\n            } else {\n                result[i] = Math.min(max, ++cur);\n            }\n        }\n        \n        cur = max;\n        for(int i = len - 1; i >= 0 ; i--) {\n            if (s.charAt(i) == c) {\n                cur = 0;\n            } else {\n                result[i] = Math.min(result[i], ++cur);\n            }\n        }\n        \n        return result;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String的长度。\n- 空间复杂度：O(N), 其中 N 为String的长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086709764","body":"### 思路\n\n用数组模拟栈操作\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int[] arr;\n    private int top;\n    \n\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < arr.length - 1) {\n            arr[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : arr[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top ; i++) {\n            arr[i] += val; \n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(K)\n- 空间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087236725","body":"### 思路\n\n维护一个栈来进行括号匹配，当遇到右括号开始pop计算后形成新字符串，然后重新入栈。\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<String>();\n        int k = 0;\n        for(char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + Character.getNumericValue(c);\n            } else if (c == '[') {\n                stack.push(String.valueOf(k));\n                stack.push(\"[\");\n                k = 0;\n            } else if (c == ']') {\n                StringBuilder sb = new StringBuilder();\n                while(stack.peek() != \"[\") {\n                    sb.insert(0, stack.pop());\n                }\n                String str = sb.toString(); // Get string inside []\n                stack.pop(); // pop '['\n                int times = Integer.parseInt(stack.pop()); // Get times\n                \n                sb = new StringBuilder();\n                for(int i = 0; i < times; i++) {\n                    sb.append(str);\n                }\n                stack.push(sb.toString());// Push string: k[encoded_string] to stack\n            } else {\n                stack.push(String.valueOf(c));\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n        }\n        \n        return sb.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088333805","body":"### 思路\n\n用两个栈来实现队列。\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int pop = stack2.pop();\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return pop;\n    }\n    \n    public int peek() {\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int peek = stack2.peek();\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return peek;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：\n\t◦\tpush：O(1)\n\t◦\tpop：O(N)\n\t◦\tpeek：O(N)\n\t◦\tempty：O(1)\n\n- 空间复杂度：\n\t◦\tpush：O(1)\n\t◦\tpop：O(N)\n\t◦\tpeek：O(N)\n\t◦\tempty：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090015125","body":"###思路\n\n单调递增栈, 储存的元素为当块不能被分割成更小的块时，每个块中的最大值。\n\n###代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<Integer>();\n        for(int i: arr) {\n            if(stack.isEmpty() || i >= stack.peek()) {\n                stack.push(i);\n            } else {\n                int peek = stack.peek();\n                while(!stack.isEmpty() && i < stack.peek() ) {\n                    stack.pop();\n                }\n                stack.push(peek);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n\n- 空间复杂度：O(N)，单调栈的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091191819","body":"### 思路\n\n先将链表变成环形链表，找到倒数第k个node当作新head。\n\n### 代码\n\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0) {\n            return head;\n        }\n        int len = 0;\n        ListNode tail = head; \n        //找到linked list的尾部和长度\n        while(tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        len++; //还要后移一位才是总长度\n        tail.next = head; //让tail指向head，首尾相连\n        k %= len; //k可能比length大\n        ListNode newHead = null;\n        for(int i = 0; i < len - k - 1; i++) {\n            head = head.next;\n        }//此时head是第len-k个node，\n        newHead = head.next;\n        head.next = null;\n        return newHead;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092568774","body":"### 思路\n\n利用dummy记录head, 两两交换节点\n\n### 代码\n\n``` Java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode temp = dummy;\n        while(temp.next != null && temp.next.next != null) {\n            //temp -> n1 -> n2 ---> temp -> n2 -> n1 then move temp to n1\n            ListNode n1 = temp.next;\n            ListNode n2 = temp.next.next;\n            temp.next = n2;\n            n1.next = n2.next;\n            n2.next = n1;\n            temp = n1;\n        }\n        return dummy.next;\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：O(n)，其中 n 是链表的节点数量\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093744200","body":"### 思路\n\n快慢指针找链表中点，然后通过递归得到左子树和右子树。\n\n### 代码\n\n``` Java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) {\n            return null;\n        } \n        if(head != null && head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode dummy = head;\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null;\n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(dummy);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：O(nlogn)，其中 n 是链表的节点数量\n  - n + 2 * n/2 + 4 * n/4 + ... + n * n/n = n * logn (二叉树的高度为logn)\n- 空间复杂度：O(logn) 递归的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094153734","body":"### 思路\n\n1. 计算出a,b的长度差，让长一点的链表先移动到两者长度相同的位置然后开始找相同的node。\n2. 改进：假设链表A =  a + c, 链表B = b + c, 让两者都移动a + b + c次, 最后都会停在interact point。\n\n### 代码\n\n``` Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0;\n        int lenB = 0;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a.next != null) {\n            a = a.next;\n            lenA++;\n        }\n        while(b.next != null) {\n            b = b.next;\n            lenB++;\n        }\n        a = lenA > lenB ? headA : headB;\n        b = lenA > lenB ? headB : headA;\n        int n = Math.abs(lenA - lenB);\n        while(n > 0) {\n            a = a.next;\n            n--;\n        }\n        while(a != b) {\n            a = a.next;\n            b = b.next;\n        }\n        return a;\n    }\n}\n```\n\n改进：\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b) {\n            a = a != null ? a.next : headB; \n            b = b != null ? b.next : headA; \n        }\n        return a;\n    }\n}\n```\n\n\n\n**复杂度**\n\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094421866","body":"### 思路\n\n1. 用哈希表记录，遇到重复的就是环起点\n2. 双指针  - 快慢指针，相步遇时fast比slow多走了n * c（c为cycle的长度），并且fast是slow的两倍，可以推出slow此时走了n * c步, 此时只需再走从head到环起点的步数(计为a步) slow就可以停在环起点，所以此时用一个指针从头开始和slow一起走a步就可以在环起点相遇。\n\n### 代码\n\n1. HashSet\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode n = head;\n        Set<ListNode> set = new HashSet<>();\n        while(n != null) {\n            if(set.contains(n)) {\n                return n;\n            } else {\n                set.add(n);\n            }\n            n = n.next;\n        }\n        return null;\n    }\n}\n```\n\n\n\n2. 快慢指针\n\n``` Java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) { break; }\n        }\n        if(slow != fast) {\n            return null;\n        }\n        ListNode dummy = head;\n        while(dummy != slow) {\n            dummy = dummy.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：O(n)\n- 空间复杂度：HashSet: O(n), 快慢指针：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096490020","body":"### 思路\n\n用HashMap和DoubleLinkedList维护所有在cache中的key-value pair。\n\n- DoubleLinkedList按照使用的顺序存储，靠近head的是最近使用的，靠近tail的是最久未使用的。\n\n- HashMap通过key映射到其在双向链表中的node。\n\n### 代码\n\n```java\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode pre;\n        DLinkedNode post;\n    }\n    \n    //Create a dummy head and tail then we don't need to check the NULL node\n    // Add the new node right after head;\n    private void addNode(DLinkedNode node) {\n        node.pre = head;\n        node.post = head.post;\n        head.post.pre = node;\n        head.post = node;\n    }\n    \n    private void removeNode(DLinkedNode node) {\n        DLinkedNode pre = node.pre;\n        DLinkedNode post = node.post;\n        \n        pre.post = post;\n        post.pre = pre;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        this.removeNode(node);\n        this.addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode last = tail.pre;\n        this.removeNode(last);\n        return last;\n    }\n    \n    private Map<Integer, DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        \n        head = new DLinkedNode();\n        head.pre = null;\n        tail = new DLinkedNode();\n        tail.post = null;\n        \n        head.post = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        this.moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if(node != null) {\n            node.value = value;\n            this.moveToHead(node);\n        } else {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.value = value;\n            newNode.key = key;\n            this.cache.put(key, newNode);\n            this.addNode(newNode);\n            size++;\n            if(size > capacity) {\n                DLinkedNode last = this.popTail();\n                this.cache.remove(last.key);\n                size--;\n            }\n        }\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：put & get O(1)\n- 空间复杂度：O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097578604","body":"### 思路\n\n1. Recursion：DFS - 左子树和右子树的最大深度 *l* 和 *r*，那么该二叉树的最大深度即为max(*l*,*r*)+1\n2. BFS: 用Queue存放当前层的所有节点，然后根据当前队列的size来寻找下一层的子节点直到队列为空，寻找的次数就是深度\n\n### 代码\n\nDFS:\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        } else {\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n    }\n}\n```\n\nBFS:\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        int height = 0;\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            while(size > 0) {\n                TreeNode node = queue.poll();\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n                if(node.right != null) {\n                    queue.offer(node.right);\n                }\n                size--;\n            }\n            height++;\n        }\n        \n        return height;\n    }\n}\n```\n\n\n\n**复杂度**\n\nDFS:\n\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。\n- 空间复杂度：O(height)，其中height表示二叉树的高度。\n\nBFS:\n\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。\n- 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098825910","body":"### 思路\n\n1. Recursion：DFS \n2. Iteration: BFS\n\n### 代码\n\nDFS:\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        if(p == null || q == null) {\n            return false;\n        }\n        if(p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\nBFS:\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        if(p == null || q == null) {\n            return false;\n        }\n        Queue<TreeNode> q1 = new LinkedList<>();\n        Queue<TreeNode> q2 = new LinkedList<>();\n        q1.offer(p);\n        q2.offer(q);\n        \n        while(!q1.isEmpty() && !q2.isEmpty()) {\n            TreeNode n1 = q1.poll();\n            TreeNode n2 = q2.poll();\n            if(n1.val != n2.val) {\n                return false;\n            }\n            TreeNode left1 = n1.left, right1 = n1.right, left2 = n2.left, right2 = n2.right;\n            if(left1 != null && left2 != null) {\n                q1.offer(left1);\n                q2.offer(left2);\n            } else if(left1 == null ^ left2 == null) {\n                return false;\n            }\n            if(right1 != null && right2 != null) {\n                q1.offer(right1);\n                q2.offer(right2);\n            } else if(right1 == null ^ right2 == null) {\n                return false;\n            }\n        }\n        return q1.isEmpty() && q2.isEmpty();\n    }\n}\n]\n```\n\n\n\n**复杂度**\n\nDFS:\n\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。\n- 空间复杂度：O(logn)\n\nBFS:\n\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。\n- 空间复杂度：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099924619","body":"### Idea\n1. DFS：use DFS preorder recursive traversals to find all the numbers and add to the global variable sum. (preorder: node -> left -> right)\n2. BFS: iterations with queue, use one queue to record the node in current level and one queue to record the current number util there is no node in the queue.\n\n### Code\n- DFS:\n```java\nclass Solution {\n    int sum = 0;\n    \n    public int sumNumbers(TreeNode root) {\n        findPathNumber(root, 0);\n        return sum;\n    }\n    \n    private void findPathNumber(TreeNode root, int cur) {\n        if(root != null) {\n            cur = cur * 10 + root.val;\n            if(root.left == null && root.right == null) {\n                sum += cur;\n            }\n            findPathNumber(root.left, cur);\n            findPathNumber(root.right, cur);\n        }\n    }\n}\n```\n- BFS\n``` java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        int sum = 0;\n        Queue<TreeNode> q = new LinkedList<>();\n        Queue<Integer> i = new LinkedList<>();\n        q.offer(root);\n        i.offer(root.val);\n        while(!q.isEmpty()) {\n            TreeNode node = q.poll();\n            int num = i.poll();\n            TreeNode left = node.left, right = node.right;\n            if(left == null && right == null) {\n                sum += num;\n            } else {\n                if(left != null) {\n                    q.offer(left);\n                    i.offer(num * 10 + left.val );\n                }\n                if(right != null) {\n                    q.offer(right);\n                    i.offer(num * 10 + right.val);\n                }\n            }\n        }\n        \n        return sum;\n    }\n}\n```\n\n**Complexity Analysis**\n1. DFS\n- Time complexity: O(N), N is the number of the nodes\n- Space complexity: O(height) to keep the recursion stack\n2. BFS\n- Time complexity: O(N), N is the number of the nodes\n- Space complexity: O(N), queue size is no bigger than N\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100533854","body":"### Idea\n\nDFS(preorder) / BFS(from right to left)\n\n### Code\n\nDFS\n\n```java\nclass Solution {\n    int bottom = 0;\n    int val;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 1);\n        return val;\n    }\n    \n    private void dfs(TreeNode root, int level) {\n            if(root != null) {\n                if(root.left == null && root.right == null) {\n                    if(level > bottom) {\n                        val = root.val;\n                        bottom = level;\n                    }\n                }\n                dfs(root.left, level + 1);\n                dfs(root.right, level + 1);\n            }\n        }\n}\n```\n\nBFS\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        TreeNode node = new TreeNode();\n        while(!q.isEmpty()) {\n            node = q.poll();\n            if(node.right != null) {\n                q.offer(node.right);\n            }\n            if(node.left != null) {\n                q.offer(node.left);\n            }\n        }\n        return node.val;\n    }\n}\n```\n\n**Complexity**\n\nDFS:\n\n- Time：O(N)\n- Space：O(height)\n\nBFS\n\n- Time：O(N)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100826167","body":"### Idea\n1. DFS + prorder\n2. BFS\n\n### Code\n- DFS:\n```java\npublic class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) {\n            return \"null\";\n        }\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    int index = 0;\n    String[] nodes;\n    public TreeNode deserialize(String data) {\n        if(data == null || data.length() == 0) {\n            return null;\n        }\n        nodes = data.split(\",\");\n        return dfs();\n    }\n\n    private TreeNode dfs() {\n        if(nodes[index++].equals(\"null\")) {\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.valueOf(nodes[index - 1]));\n        node.left = dfs();\n        node.right = dfs();\n        return node;\n    }\n}\n```\n- BFS\n``` java\npublic class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) {\n            return \"\";\n        }\n        StringBuilder str = new StringBuilder();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 1; i <= size; i++) {\n                TreeNode node = q.poll();\n                if(node != null) {\n                    str.append(node.val);\n                    q.offer(node.left);\n                    q.offer(node.right);\n                } else {\n                    str.append(\"null\");\n                }\n                str.append(',');\n            }\n        }\n        str.setLength(str.length() - 1);\n        return str.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data == null || data.length() == 0) {\n            return null;\n        }\n        String[] nodes = data.split(\",\");\n        TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        int index = 0;\n        while(!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                if(node != null) {\n                    node.left = null;\n                    node.right = null;\n                    if(index < nodes.length) {\n                        if(!nodes[++index].equals(\"null\")) {\n                            node.left = new TreeNode(Integer.valueOf(nodes[index]));\n                        }\n                        if(!nodes[++index].equals(\"null\")) {\n                            node.right = new TreeNode(Integer.valueOf(nodes[index]));\n                        }\n                    }\n                    q.offer(node.left);\n                    q.offer(node.right);\n                }\n            }\n        }\n        \n        return root;\n    }\n}\n```\n\n**Complexity Analysis**\n1. DFS\n- Time complexity: O(N), N is the number of the nodes\n- Space complexity: O(height) to keep the recursion stack\n2. BFS\n- Time complexity: O(N), N is the number of the nodes\n- Space complexity: O(N), queue size is no bigger than N\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100978422","body":"### Idea\nDFS: use DFS preorder traversal to get the (x, y, val) for each node and create a customized class NodePoint to save it. After get the coordinates for all the nodes then sort it by the order of y -> x -> val, then loop once to get the result list.\n\n### Code\n- DFS:\n```java\nclass Solution {\n    class NodePoint {\n        int x;\n        int y;\n        int val;\n        \n        public NodePoint(int x, int y, int val) {\n            this.x = x;\n            this.y = y;\n            this.val = val;\n        }\n        \n        public int getX() {\n            return x;\n        }\n        \n        public int getY() {\n            return y;\n        }\n        \n        public int getVal() {\n            return val;\n        }\n    }\n    \n    Map<TreeNode, NodePoint> map = new HashMap<>();\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new NodePoint(0, 0, root.val));\n        dfs(root);\n        List<List<Integer>> res = new ArrayList<>();\n        List<NodePoint> points = new ArrayList<>(map.values());\n        Collections.sort(points, Comparator.comparing(NodePoint::getY).thenComparing(NodePoint::getX).thenComparing(NodePoint::getVal));\n        int y = points.get(0).y;\n        int len = points.size();\n        for(int i = 0; i < len;) {\n            List<Integer> v = new ArrayList<>();\n            while(i < len && points.get(i).y == y) {\n                v.add(points.get(i++).val);\n            }\n            if(i < len) {\n                y = points.get(i).y;\n            }\n            res.add(v);\n        }\n        return res;\n    }\n    \n    private void dfs(TreeNode root) {\n        if(root == null) {\n            return;\n        }\n        NodePoint p = map.get(root);\n        if(root.left != null) {\n            map.put(root.left, new NodePoint(p.x + 1, p.y - 1, root.left.val));\n            dfs(root.left);\n        }\n        if(root.right != null) {\n            map.put(root.right, new NodePoint(p.x + 1, p.y + 1, root.right.val));\n            dfs(root.right);\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(NlogN), N is the number of the nodes\n- Space complexity: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101960893","body":"### Idea\nIterate and check if current element's complement already exists in the hash table, if it exists return the result, otherwise insert elements into the hash table.\n\n### Code\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++) {\n            int remain = target - nums[i];\n            if(map.containsKey(remain)) {\n                return new int[]{map.get(remain), i};\n            } else {\n                map.put(nums[i], i);\n            }\n        }\n        return null;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(N)\n- Space complexity: O(N), hash table stores at most n elements.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103427861","body":"### Idea\n1. Min Heap: use min heap to record the most freq k numbers\n2. Bucket Sort: Build a array of list to be buckets with length + 1 and use freq as index to put each key into buckets. And get first k elements from the end of array.\n\n### Code\n- Min Heap\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        if(k == nums.length) {\n            return nums;\n        }\n        \n        //build hash map: O(N)\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        \n        // keep k top frequent elements in the heap\n        // O(N log k) = O(klogk) + O((N - k)logk)\n        //The time complexity of heap push/pop is O(logk)\n        Queue<Integer> heap = new PriorityQueue<>((n1, n2) -> map.get(n1) - map.get(n2));\n        for(int key : map.keySet()) {\n            heap.offer(key);\n            if(heap.size() > k) {\n                heap.poll();\n            }\n        }\n        \n        int[] result = new int[k];\n        //O(klogk)\n        for(int i = k - 1; i >= 0; i--) {\n            result[i] = heap.poll();\n        }\n        \n        return result;\n    }\n}\n```\n- Bucket Sort\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        if(k == nums.length) {\n            return nums;\n        }\n        \n        //Map the freq into a hashtable\n        //O(N)\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        \n        //Use freq as the index of bucket\n        //O(N)\n        List<Integer>[] bucket = new List[nums.length + 1];\n        for(int key : map.keySet()) {\n            int freq = map.get(key);\n            if(bucket[freq] == null) {\n                bucket[freq] = new ArrayList<Integer>();\n            }\n            bucket[freq].add(key);\n        }\n        \n        //Start from the most freq and add all the key in each bucket until total reachs k\n        //worst O(N)\n        List<Integer> res = new ArrayList<>();\n        for(int i = nums.length, j = 0; j < k && i > 0; i--) {\n            if(bucket[i] != null) {\n                res.addAll(bucket[i]);\n                j += bucket[i].size();\n            }\n        }\n        \n        return res.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: Heap - O(NlogK); Bucket - O(N)\n\n- Space complexity: Heap - O(N); Bucket - O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104615922","body":"### Idea\nFor each point i, map<distance d, count of all points at distance d from i>. Given that count, choose 2 (with permutation) from it, to form a boomerang with point i.\n\n### Code\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for(int i = 0; i < points.length; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for(int j = 0; j < points.length; j++) {\n                if(i == j) { continue; }\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            \n            for(int num : map.values()) {\n            \t/*\n                 * for all the groups of points, \n                 * number of ways to select 2 from n = \n                 * nP2 = n!/(n - 2)! = n * (n - 1)\n                 */\n                res += num * (num - 1);\n            }\n        }\n        \n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n^2)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105802380","body":"### Idea\nUsing HashSet as a sliding window. \n\n### Code\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        char[] str = s.toCharArray();\n        Map<Character, Integer> map = new HashMap<>();\n        int res = 0;\n        int i = 0, j = 0;\n        \n        while(j < str.length) {\n            char r = str[j];\n            map.put(r, map.getOrDefault(r, 0) + 1);\n            j++;\n            while(map.get(r) > 1) {\n                char l = str[i];\n                map.put(l, map.get(l) - 1);\n                i++;\n            }\n            res = Math.max(res, j - i);\n        }\n        return res;\n    }\n}\n```\nOptimized: loop once\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int res = 0;\n        \n        for(int i = 0, j = 0; j < s.length(); j++) {\n            char c = s.charAt(j);\n            if(map.containsKey(c)) {\n                i = Math.max(map.get(c), i);\n            }\n            res = Math.max(res, j - i + 1);\n            map.put(c, j + 1);\n        }\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(2n)=O(n). In the worst case each character will be visited twice by i and j; Optimized: O(n).\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107441218","body":"### Idea\nSliding window. \n\n### Code\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        if (s == null || s.length() == 0 || words == null || words.length == 0) return res;\n        HashMap<String, Integer> map = new HashMap<>();\n        int wordLen = words[0].length();\n        int size = words.length;\n        int len = wordLen * size;\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        for (int i = 0; i < wordLen; i++) {\n            int left = i, right = i, count = 0;\n            HashMap<String, Integer> window = new HashMap<>();\n            while (right + wordLen <= s.length()) {\n                String r = s.substring(right, right + wordLen);\n                right += wordLen;\n                if (!map.containsKey(r)) {\n                    count = 0;\n                    left = right;\n                    window.clear();\n                } else {\n                    window.put(r, window.getOrDefault(r, 0) + 1);\n                    count++;\n                    while (window.getOrDefault(r, 0) > map.getOrDefault(r, 0)) {\n                        String l = s.substring(left, left + wordLen);\n                        count--;\n                        window.put(l, window.getOrDefault(l, 0) - 1);\n                        left += wordLen;\n                    }\n                    if (count == size) {\n                        res.add(left);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: Given n as the length of s, a as the length of words, and b as the length of each word: O(a + n * b)\n- Space complexity: O(a + b)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107704339","body":"### Idea\n1. Find the remainder of the sum(nums) % k;\n2. Use a HashMap to store the mods (prefix-sum % k == last index) bindings;\n3. Traverse the input array to compute the prefix sum and seach for reminder - mod in the HashMap; Update the minimum length of the subarray if found;\n4. If the minimum length is still the initial value after traversal, return -1; otherwise, return the minimun.\n\n\n### Code\n```java\nclass Solution {\n    public int minSubarray(int[] nums, int k) {\n        int len = nums.length;\n        int res = len;\n        int mod = 0, cur = 0;\n        for(int num: nums) {\n            mod = (mod + num) % k;\n        }\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        for(int i = 0; i < len; i++) {\n            cur = (cur + nums[i]) % k;\n            map.put(cur, i);\n            int need = (cur - mod + k) % k;\n            res = Math.min(res, i - map.getOrDefault(need, -len));\n        }\n        \n        return res < len ? res : -1;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108074140","body":"### Idea\nfast & slow two pointers.\n\n### Code\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        return fast.next == null ? slow : slow.next;\n        \n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109491844","body":"### Idea\nTwo pointers.\n\n### Code\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0) {\n            return 0;\n        }\n        \n        int count =1;\n        for(int i = 1; i < nums.length; i++) {\n            if(nums[i] != nums[i - 1]) {\n                nums[count] = nums[i];\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110764624","body":"### Idea\nBinary search\n\n\n### Code\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length - 1, mid;\n        while(l <= r) {\n            mid = l + (r - l) / 2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] > target) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        \n        return l;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(logN)\n- Space complexity: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112841820","body":"### Idea\nFor this graph, the outdegree of a person represents the number of other people trust. The indegree of a person represents the number of people trusted by that person.\n\n### Code\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        if(trust.length < n - 1) {\n            return -1;\n        }\n        int[] indegrees = new int[n + 1];\n        int[] outdegrees = new int[n + 1];\n        \n        for(int[] relation: trust) {\n            outdegrees[relation[0]]++;\n            indegrees[relation[1]]++;\n        }\n        \n        for(int i = 1; i <= n; i++) {\n            if(indegrees[i] == n - 1 && outdegrees[i] == 0) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(E), E is the number of edges;\n- Space complexity: O(N), N is the number of people.\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407589","body":"从尾到头 一位一位计算。 可以另开list 倒叙存 ｜｜ 直接修改原数组，多位的从头插入。\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # brute force, convert to int then to list\r\n        carry, i = 0, len(num) -1\r\n        while carry or i >= 0 or k:\r\n            temp = (num[i] if i >= 0 else 0) + (k % 10 if k else 0) +  carry            \r\n            carry = temp // 10\r\n            \r\n            if i >= 0:\r\n                num[i] = temp % 10\r\n            else:\r\n                num.insert(0,temp % 10)\r\n            \r\n            k //= 10\r\n            i -= 1\r\n\r\n        return num\r\n```\r\ntime complexity: O(N)   \r\nspace complexity: O(N) （不考虑返回值，额外使用O(1))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1090690554","body":"思路其实是从左向右扫一遍，再右向左扫一遍， 用stack 存单方向遇到的第一个 c.  其实可以用一个prev 来指代上一次遇到的index, 这样只要扫一次就够了。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left = [float('inf') ] * len(s)\r\n        \r\n        stack = []\r\n        for i, char in enumerate(s):\r\n            if char == c:\r\n                left[i] = 0\r\n                while stack:\r\n                    top = stack.pop()\r\n                    left[top] = i - top\r\n            else:\r\n                stack.append(i)\r\n            \r\n        stack2 = []\r\n        for j in range(len(s)-1,-1,-1):\r\n            if s[j] == c:\r\n                left[j] = 0\r\n                while stack2:\r\n                    top = stack2.pop()\r\n                    left[top] = min(top - j, left[top])\r\n            else:\r\n                stack2.append(j)\r\n                \r\n        return left\r\n```\r\ntime complexity: O(N)   \r\nspace complexity: O(N) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1090778622","body":"模拟题。 python用list可以直接操作前k个 ele += val 就可以。  \r\n但是如果用stack 无法直接操作的话，可以借用一个helper stack 来倒一倒。\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.size = 0\r\n        self.list = []\r\n        self.helperList = []\r\n        \r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.size < self.max_size:\r\n            self.list.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            self.size -= 1\r\n            return self.list.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None: \r\n        while self.list:\r\n            self.helperList.append(self.list.pop())\r\n        for i in range(min(k,self.size)):\r\n            self.list.append(self.helperList.pop() + val)  \r\n        while self.helperList:\r\n            self.list.append(self.helperList.pop())\r\n\r\n        # if use list\r\n        # for i in range(min(k,self.size)):\r\n        #     self.stack[i] += val\r\n            \r\n        \r\n```\r\ntime complexity: push O(1) 放在尾巴,  pop O(1), increment O(min(k,len(list))) 如果直接对前k个元素操作。 如果是倒一倒， O(N)  \r\nspace complexity: O(N) 考虑自身self.list ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1090807316","body":"遇到'[' 就把之前得到的str， int 放进stack。 遇到']' 就pop出来操作。\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, cur_str = 0, ''\r\n        stack = []\r\n        \r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n                \r\n            elif c == ']':\r\n                pre_str = stack.pop()\r\n                pre_num = stack.pop()\r\n                cur_str = pre_str + cur_str * pre_num\r\n            \r\n            elif c == '[':\r\n                stack.append(num)\r\n                stack.append(cur_str)\r\n                num, cur_str = 0, ''\r\n                \r\n            else: # c == letter\r\n                cur_str += c\r\n    \r\n        return cur_str\r\n        \r\n```\r\ntime complexity:  O(N)  \r\nspace complexity: O(N) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1090829501","body":"push 的时候正常append, 当需要pop的时候， 借用另一个stack 使得 内容reversed.  在peek()的时候可以重复pop 倒出的思路，但是可以 init self.front 在每一次 第一次append 进self.inStack的时候 赋值self.front.  \r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n        self.front = None\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if not self.inStack:\r\n            self.front = x\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        \r\n        while self.inStack:\r\n            self.outStack.append(self.inStack.pop())\r\n            return self.outStack.pop()\r\n    \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        return self.front\r\n        \r\n        \r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n        \r\n```\r\ntime complexity:  push O(1), pop O(N), peek O(1), empty O(1)    \r\nspace complexity: O(N) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1091070643","body":"可以分块的条件就是前一块的最大值 <=  后一块的最小。  \r\n左扫一次，右扫一次来找到每一个index 对应的最大值， 最小值，然后遍历判断能否成块。\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # 前一段的 max(chunk) <= 后 min(chunk)， 那么就可以分开  \r\n        max_v, min_v = [0] * len(arr), [0] * len(arr)\r\n        max_v[0], min_v[-1] = arr[0], arr[-1]\r\n        for i in range(1,len(arr)):\r\n            max_v[i] = max(max_v[i-1], arr[i])\r\n            \r\n        for j in range(len(arr)-2,-1,-1):\r\n            min_v[j] =  min(min_v[j+1], arr[j])\r\n            \r\n        chunk = 1\r\n        for i in range(1,len(max_v)):\r\n            if max_v[i-1] <= min_v[i]:\r\n                chunk += 1\r\n                \r\n        return chunk\r\n\r\n        \r\n```\r\ntime complexity:  O(N)   遍历了三遍  \r\nspace complexity: O(N) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091047670","body":"1. 先求出正确的k， 因为k可能大于size of linked list.  \r\n2. fast 先走k步， 然后slow， fast 同步开始走。\r\n3. 截断 拼接组成新的linkedlist. \r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head: return head\r\n        count, cur = 0, head\r\n        while cur:\r\n            count += 1\r\n            cur = cur.next\r\n            \r\n        k %= count\r\n        if k == 0: return head\r\n        \r\n        fast, slow = head, head \r\n        while k > 0:\r\n            fast = fast.next\r\n            k -= 1\r\n              \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n       \r\n        new_head = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        return new_head\r\n\r\n        \r\n```\r\ntime complexity:  O(N)   遍历了两遍  \r\nspace complexity: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092466544","body":"iteration 改变.next 就行了\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head: return head\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        \r\n        cur = dummy\r\n        while head and head.next:\r\n            node1, node2 = head, head.next\r\n            cur.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            \r\n            cur, head = node1, node1.next\r\n        return dummy.next\r\n        \r\n\r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(1) 不考虑答案\r\n\r\nrecursion\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next: return head\r\n        \r\n        first_node, second_node = head, head.next\r\n        first_node.next = self.swapPairs(second_node.next)\r\n        \r\n        second_node.next = first_node\r\n        return second_node\r\n        \r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(N) call stack ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094379657","body":"recursion.  \r\n每一次中中点作为root，然后再调用本函数 找left linked list, right linked list 的中点 作为sub tree 的root 节点。  \r\n其实有大量重复操作。   \r\n可以更简便把 linkedlist  convert to list then build tree. 时间复杂度会降到O(N).\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        # break linked list \r\n        if not head: return None\r\n        if head and not head.next: return TreeNode(head.val)\r\n        \r\n        fast, slow, prev = head, head, None       \r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            \r\n        # slow is the root  \r\n        prev.next = None\r\n       \r\n        \r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n        \r\n```\r\ntime complexity:  O(N logN),每一次recurion 切一半.   \r\nspace complexity: O(log N) call stack.","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094380508","body":"依旧还是双指针思路。一根走完走另一根。 如果交点不为None， 说明有intersection. \r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ha, hb = headA, headB\r\n        while ha != hb:\r\n            ha = ha.next if ha else headB\r\n            hb = hb.next if hb else headA\r\n            \r\n        return ha\r\n        \r\n```\r\ntime complexity:  O(M + N)    \r\nspace complexity: O(1) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094527624","body":"先判断是否有环，可以用141那道题的思路。  \r\n如果有环， 重置一个点回到头节点， 再同步运动，再一次相交的点就是第一个交点。\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            \r\n            if slow == fast:\r\n                break\r\n        \r\n        if not fast or not fast.next:\r\n            return None\r\n        \r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n            \r\n        return slow\r\n            \r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(1) ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098685772","body":"recursion, 判断两个 tree node 存在且value相等。\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        # brute force, in/post/pre order flat into a list, then compare\r\n        \r\n        if not q and not p: return True\r\n        elif (not q and p) or (not p and q): return False\r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(log N) worst case O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1102017908","body":"补卡。 stack的做法   \r\n在leaf节点直接加就好了\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        stack = []\r\n        num = 0\r\n        res = 0\r\n        while root or stack:\r\n            if root:\r\n                num = num * 10 + root.val\r\n                stack.append([root,num])\r\n                if root and (not root.left) and (not root.right):\r\n                    res += num\r\n                root = root.left\r\n                \r\n            else:\r\n                root, num = stack.pop()\r\n                root = root.right\r\n        return res\r\n    \r\n        \r\n```\r\ntime complexity:  O(N) \r\nspace complexity: O(N) \r\n\r\n\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        return self.dfs(root,0)\r\n        \r\n    def dfs(self,root,res):\r\n        if not root: return 0    \r\n        res = res * 10 + root.val\r\n        if root and (not root.left) and (not root.right):\r\n            return res\r\n        \r\n        return self.dfs(root.left,res) + self.dfs(root.right,res)\r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(log N) worst case O(N) linked list  ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100566457","body":"BFS level traversal. 保留每一层第一个node.val 就是最左边的leaf.val\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        # bfs\r\n        if not root: return None\r\n        \r\n        queue = collections.deque([root])\r\n        res = root.val\r\n        while queue:\r\n            res = queue[0].val\r\n            for _ in range(len(queue)):\r\n                node = queue.popleft()\r\n                    \r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n                    \r\n        return res\r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(width)  \r\n\r\nDFS stack 做法， 缺点就是保存了所有node.val。 蹲一个明天的官方答案\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n       # stack\r\n        stack = []\r\n        depth = -1\r\n        res = []\r\n        \r\n        while root or stack:\r\n            if root:\r\n                depth += 1\r\n                stack.append([root,depth])\r\n                if len(res) == depth:\r\n                    res.append([])\r\n                res[depth].append(root.val)\r\n                root = root.left\r\n            else:\r\n                root, depth = stack.pop()\r\n                root = root.right\r\n        \r\n        return res[-1][0]\r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(N)  ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101109702","body":"3 个要求，column, row(depth), value  \r\n按着这个规律排列就好了。 \r\n\r\n\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        # col first, then value\r\n        # because top can botton, level traversal is better\r\n        d = collections.defaultdict(list)\r\n        #col :val[depth]\r\n        minn = float('inf')\r\n        res = []\r\n        \r\n               \r\n        queue = collections.deque([[root,0,0]])\r\n        while queue:\r\n            for _ in range(len(queue)):\r\n                node,col,depth = queue.popleft()\r\n                d[col].append([node.val,depth])\r\n                minn = min(minn,col)\r\n                \r\n                if node.left:\r\n                    queue.append([node.left,col-1,depth+1])\r\n                if node.right:\r\n                    queue.append([node.right,col+1,depth+1])\r\n        \r\n      \r\n        while minn in d:\r\n            new = sorted(d[minn], key = lambda x:(x[1],x[0]))\r\n            res.append([x[0] for x in new])\r\n            minn += 1\r\n        return res\r\n    \r\n        \r\n```\r\ntime complexity:  O(N) 遍历 tree， O(N logN) for sorting \r\nspace complexity: O(width) for queue, O(N) for result  \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101976170","body":"two sum 太经典了。  \r\nkey: target - nums[i], value:i \r\n\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n\r\n        # key: target- nums[i], value: i\r\n        d = {}   #d[key] => value\r\n        for i in range(len(nums)):\r\n            if nums[i] in d:\r\n                return [i,d[nums[i]]]\r\n            else:\r\n                d[target-nums[i]] = i\r\n                \r\n        return [-1,-1]\r\n    \r\n        \r\n```\r\ntime complexity:  O(N) \r\nspace complexity: O(1) ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108074817","body":"快慢指针，如果偶数size 直接返回第二个 middle node, 那么直接快慢指针就解决了。\r\n\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            \r\n            \r\n        return slow\r\n        \r\n```\r\ntime complexity:  O(N) \r\nspace complexity: O(1) \r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113919071","body":"非常类似于上色graph 使之成为bipartite graph. 第一个dislike 的两个人进去不同颜色圈。  如果后面的某个人又在红色圈，又在蓝色圈，无法成为bipartite graph。 如果成功分成two set of different colors, 那么代表分类成功了。 \r\n```python\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        graph = collections.defaultdict(list)\r\n        for di, dj in dislikes:\r\n            graph[di-1].append(dj-1)\r\n            graph[dj-1].append(di-1)\r\n        \r\n        colors = [0] * n\r\n        \r\n        for i in range(len(graph)):\r\n            if colors[i] != 0: continue # visited\r\n    \r\n            queue = collections.deque()\r\n            queue.append(i)\r\n            colors[i] = 1\r\n            while queue:\r\n                person = queue.popleft()\r\n                for p in graph[person]:\r\n                    if colors[p] == 0:\r\n                        colors[p] = -colors[person]\r\n                        # bipartite 只有两个色， dislike 就把p 放在 另一个 set\r\n                        queue.append(p)\r\n                    elif colors[p] == colors[person]:\r\n                        return False\r\n    \r\n    \r\n        return True\r\n    \r\n\r\n```\r\ntime complexity:  O(V+E) \r\nspace complexity: O(V+E) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ballerjay":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407797","body":"### 解题思路\n\n默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n\n还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n\n\n\n```JavaScript\nfunction solution(num,k) {\n  // 默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n  // 还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n  const res = []\n  const len = num.length\n  for(let i = len - 1;i >= 0 || k > 0;i --, k = Math.floor(k / 10)) {\n    if(i >= 0) {\n      k += num[i]\n    }\n    res.unshift(k % 10)\n  }\n  return res\n}\n```\n\n### 时间复杂度\n\nO(max(n,k)),n为数组的长度,k为数字的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658551","body":"``` js\nvar shortestToChar = function(s, c) {\n    // 中心扩散法，从当前元素为中心，寻找左右两边的c值，然后找出最短距离\n    const res = [] \n    for(let i = 0;i < s.length;i ++) {\n    let l = r = i\n    while(l >= 0) {\n        if(s[l] == c) break\n        l--\n    }\n    while(r < s.length) {\n        if(s[r] == c) break\n        r++\n    }\n    if(l < 0) l = -10000\n    if(r === s.length) r = 10000\n    res.push(Math.min(i - l, r - i))\n    }\n    return res\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088609608","body":"### 思路\n在js中利用数组的方法实现队列\n### 代码\nfunction MyQueue() {\n  this.items = [];\n  this.push = function (x) {\n    this.items.push(x);\n  };\n  this.pop = function () {\n    this.items.shift();\n  };\n  this.peek = function () {\n    return this.items[0];\n  };\n  this.empty = function () {\n    return this.items.length == 0 ? true : false;\n  };\n}\n\nlet queue = new MyQueue();\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // 返回 1\nqueue.pop(); // 返回 1\nqueue.empty(); // 返回 false","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091067462","body":"### 代码\nvar rotateRight = function (head,k) {\n  if(k == 0 || !head || !head.next) {\n    return head\n  }\n  let n = 1;\n  let cur = head\n  while(cur.next) {\n    // 计算链表的长度\n    cur = cur.next\n    n ++\n  }\n  let add = n - k % n\n  if(add === n) {\n    // 当k是链表的长度n的倍数时，直接返回原始链表\n    return head\n  }\n  cur.next = head // 此操作就是把链表连成一个环\n  while(add) {\n    cur = cur.next\n    add --\n  }\n\n  // 移动了k位之后，断开形成的环，并记录当前的next值，也就是返回链表中的head\n  const resHead = cur.next\n  cur.next = null\n  return resHead\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092400216","body":"## 思想\n用 head  表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead\n```javascript\n   var swapPairs = function(head) {\n  // 当链表为空或者只有一个元素时\n  if(!head || !head.next) {\n    return head\n  }\n  const newHead = head.next\n  head.next = swapPairs(newHead.next)\n  newHead.next = head\n  return newHead\n};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094819620","body":"## 思路\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现\n-- -\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    const set = new Set()\n    while(head !== null) {\n    if(set.has(head)) {\n        return head\n    }\n    set.add(head)\n    head = head.next\n    }\n\n    return null\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"magua-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085412418","body":"思路\n模拟加法，本质上是以到高精度加法。先把数组翻转，从最后一位开始加，最后在翻转过来\n\n代码实现\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n\n        for(auto& x : num) {\n            k += x;\n            x = k % 10;\n            k /= 10;\n        }\n\n        while(k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086550335","body":"思路\n分析一下可知，只有两种情况，即c在这个数的左边或者右边，所以我们遍历两次，一次从前向后，一次从后向前，最后把两次遍历的结果取min\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for(int i = 0, j = -1; i < n;  i ++){\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = i - j;\n        }\n        for(int i = n , j = -1; i >= 0; i --) {\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n\n    }\n};\n```\n复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)结果数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086762515","body":"思路\n使用数组实现栈\n\n代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int mx;\n    CustomStack(int maxSize) {\n       // stk.resize(maxSize);\n        mx = maxSize;\n    }\n    \n    void push(int x) {\n        if(stk.size() < mx)\n            stk.push_back(x);\n    }\n    \n    int pop() {\n        if(!stk.empty()){\n            int val = stk.back();\n            stk.pop_back();\n            return val;\n        }else {\n            return -1;\n        }\n        \n        \n    }\n    \n    void increment(int k, int val) {\n        if(stk.size() < k) {\n            for(int i = 0; i < stk.size(); i ++)\n                stk[i] += val;\n        }else if(stk.size() >= k){\n            for(int i = 0; i < k; i ++)\n                stk[i] += val;\n        }\n    }\n};\n\n\n复杂度分析\n时间复杂度： push:O(1)、pop：O(1)\n空间复杂度 O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087041845","body":"思路\n使用递归，遇见数字就递归进去，遇见字母就加到res后面\n\n代码\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while(u < s.size() && s[u] != ']') {\n            if(s[u] >= 'a' && s[u] <= 'z' || s[u] >= 'A' && s[u] <= 'Z') res += s[u ++];//\n            else if(s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while(s[k] >= '0' && s[k] <= '9') k ++;\n                int x = stoi(s.substr(u, k - u));//stoi string转换成int类型\n                u = k + 1;//去掉左括号\n                string y = dfs(s, u);//进一步递归，确认括号里的字符串\n                u ++;\n                while(x --) res += y;\n            }\n        }\n        return res;\n    }\n};\n\n复杂度\n空间：O(2^n) ?指数级别，具体表达式不清楚\n时间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088198934","body":"思路\n用两个stack模拟\n\n代码\n```C++\nclass MyQueue {\npublic:\n    stack<int> stk, num;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    \n    int pop() {\n        if(!stk.empty() && num.empty()) {\n            while(!stk.empty()) {\n                num.push(stk.top());\n                stk.pop();\n            }\n        }\n        int res = num.top();\n            num.pop();\n            return res;\n    }\n    \n    int peek() {\n        if(!stk.empty() && num.empty()) {\n            while(!stk.empty()) {\n                num.push(stk.top());\n                stk.pop();\n            } \n        }\n        int res = num.top();\n\n            return res;\n    }\n    \n    bool empty() {\n        if(stk.empty() && num.empty()) \n            return true;\n        else return false;\n    }\n};\n复杂度\n空间复杂度都是O(n)；\n时间：\npush: O(1),\npop: O(n) \npeek: O(n)\nemptu：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090296298","body":"```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& a) {\n        auto b = a;\n        sort(b.begin(), b.end());\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0, s = 0; i < a.size(); i ++ ) {\n            if (cnt[a[i]] == 1) s -- ;\n            else if (cnt[a[i]] == 0) s ++ ;\n            cnt[a[i]] -- ;\n            if (cnt[b[i]] == -1) s -- ;\n            else if (cnt[b[i]] == 0) s ++ ;\n            cnt[b[i]] ++ ;\n            if (!s) res ++ ;\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091090221","body":"思路\n求size, tail，假设size的大小为n，那么找到第n- k个位置，将其指向空，tail指向head\n\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head) return head;\n        ListNode* tail = new ListNode();\n        int n = 0;\n        for(auto p = head; p; p = p->next){\n            tail = p;\n            n ++;\n        }\n        k %= n;//如果k过大，对n取余\n        auto p = head;\n        for(int i = 0; i < n - k - 1; i ++) p = p->next;\n        tail->next = head;\n        head = p->next;\n        p->next = nullptr;\n        return head;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092356509","body":"思路\n简历虚拟头节点模拟\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        for(auto p = dummy; p->next && p->next->next;) {//从dymmy开始\n            auto a = p->next, b = a->next;\n            p->next = b;\n            a->next = b->next;\n            b->next = a;\n            p = a;\n        }\n        return dummy->next;\n    }\n};\n复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093589421","body":"思路\n找中点后递归 + 中序遍历\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode* h; \n    TreeNode* sortedListToBST(ListNode* head) {\n        //if(!head ) return head;\n        h = head;\n        int n = 0;\n        for(auto p = head; p; p = p->next) n ++;\n        return build(0, n - 1);\n\n    }\n\n    TreeNode* build(int l, int r) {\n        if(l > r) return nullptr;\n        TreeNode *root = new TreeNode();\n        int mid = (l + r  +1) >> 1;\n        root->left = build(l, mid - 1);\n        root->val = h->val;   \n        h = h->next; \n        root->right = build(mid + 1, r);\n        return root;\n    }\n};\n复杂度\n时间复杂度：O(nlogn)\n空间复杂度： O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094152790","body":"思路\n使用双指针，遍历两个分支，当为空时，就指向另一条链表的头节点，相遇时即为相交点\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA == NULL || headB == NULL)  return NULL;\n        auto p = headA, q = headB;\n        while(p != q) {\n            p = p == NULL ? headB : p->next;\n            q = q == NULL ? headA : q->next;\n        }\n        return q;\n    }\n};\n复杂度分析\n时间复杂度 O(m + n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094511377","body":"```C++\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head || !head->next) return NULL;\n        auto s = head, f = head;\n        while(true){\n            if(f == NULL || f->next == NULL) return NULL;\n            s = s->next, f = f->next->next;\n            if(s == f) break;\n        }\n\n        f = head;\n        while(s != f){\n            s = s->next, f = f->next;\n        }\n        return f;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095704058","body":"```C++\nclass LRUCache {\npublic:\n    struct Node{\n        int key, val;\n        Node *left, *right;\n        Node(int _key, int _val) : key(_key), val(_val), right(NULL), left(NULL) {}\n    }*L, *R;\n    unordered_map<int, Node*> hash;\n    int n;\n\n    void remove(Node* p){\n        p->left->right = p->right;\n        p->right->left = p->left;\n    }\n\n    void insert(Node* p){\n        p->right = L->right;\n        p->left = L;\n        L->right->left = p;\n        L->right = p;\n    } \n\n    LRUCache(int capacity) {\n        n = capacity;\n        L = new Node(-1, -1), R = new Node(-1, -1);\n        L->right = R, R->left = L;\n    }\n    \n    int get(int key) {\n        if(hash.count(key) == 0) return -1;\n        auto p = hash[key];\n        remove(p);\n        insert(p);\n        return p->val;\n    }\n    \n    void put(int key, int value) {\n        if(hash.count(key)){\n            auto p = hash[key];\n            p->val = value;\n            remove(p);\n            insert(p);\n        }else{\n            if(hash.size() == n){\n                auto p = R->left;\n                remove(p);\n                hash.erase(p->key);\n                delete(p);\n            }\n            auto p = new Node(key, value);\n            hash[key] = p;\n            insert(p);\n        }\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097471683","body":"```C++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        int res = 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(q.size()) {\n            int n = q.size();\n            while(n --) {\n                auto t = q.front();\n                q.pop();\n                if(t->left) q.push(t->left);\n                if(t->right) q.push(t->right); \n            }\n            res ++;\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098645472","body":"```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p== nullptr && q == nullptr) return true;\n        if(p == nullptr || q == nullptr) return false;\n        if(p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        \n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100516583","body":"```C++\nclass Solution {\npublic:\n    int maxLevel = 0, res = 0;\n    int findBottomLeftValue(TreeNode* root) {\n        return dfs(root, 1);\n    }\n\n    int dfs(TreeNode* root, int u) {\n        if(!root) return root->val;\n        if(u > maxLevel) {\n            res = root->val;\n            maxLevel = u;\n        }\n        if(root->left) dfs(root->left, u + 1);\n        if(root->right) dfs(root->right, u + 1);\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100789416","body":"```C++\nclass Codec {\npublic:\n    string path;\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        dfs_s(root);\n        return path;\n    }\n    void dfs_s(TreeNode* root){//空结点也一定要保存下来，否则只靠一次先序遍历无法唯一确定二叉树\n        if(!root) path += \"#,\";//如果root为空，则在那个位置加上一个#\n        else{\n            path += to_string(root->val) + ',';//否则先遍历根节点\n            dfs_s(root->left);//遍历左右子树\n            dfs_s(root->right);\n        }\n    }\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {//反序列化\n        int u = 0;//从0遍历\n        return dfs_d(data, u);\n    }\n    TreeNode* dfs_d(string& data, int& u){//都加引用，第一个引用时为了避免复制data，加第二个表示所有的都共用一个u\n        if (data[u] == '#') {//当前是#，即表示当前是空\n            u += 2;//跳过当前节点，'#'和','\n            return NULL;\n        } else {\n            int k = u;//先序遍历，先求第一个点的值\n            while (data[u] != ',') u ++ ;\n            auto root = new TreeNode(stoi(data.substr(k, u - k)));\n            u ++ ;\n            root->left = dfs_d(data, u);\n            root->right = dfs_d(data, u);\n            return root;\n        }\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101032843","body":"```C++\nclass Solution {\npublic:\n    map<int, vector<vector<int>>> S;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);\n        vector<vector<int>> res;\n        for(auto& [k, v] : S) {\n            sort(v.begin(), v.end());\n            vector<int> col;\n            for(auto& p : v) col.push_back(p[1]);\n            res.push_back(col);\n        }\n        return res;\n    }\n\n    void dfs(TreeNode* root, int x, int y) {\n        if(!root) return;\n        S[y].push_back({x, root->val});\n        dfs(root->left, x + 1, y - 1);\n        dfs(root->right, x + 1, y + 1);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101917634","body":"```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> heap;\n        for(int i = 0; i < nums.size(); i ++)\n        {\n            int r = target - nums[i];\n            if(heap.count(r))\n                return {heap[r], i};\n            heap[nums[i]] = i;\n        }\n        return {};\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103387471","body":"```C++\nclass Solution {\npublic:\n    \n    vector<int> topKFrequent(vector<int>& nums, int k) {\n    unordered_map<int, int> cnt;\n    for(auto x : nums) cnt[x] ++;//统计每个元素的出现次数\n    int n = nums.size();\n    vector<int> s(n + 1);//记录出现每种次数的元素个数是多少\n    for(auto[x, c] : cnt) s[c] ++;//元素x出现c次，所以在c处++,s数组的下标是出现的次数\n    int i = n, t = 0;//找分界点，t记录的是从大到小元素出现次数的累加\n    while(t < k) t += s[i --];//while。这一步的目的主要是确定分界点，循环结束后，分界点是i和i + 1，i代表的是出现次数\n    vector<int> res;\n    for(auto[x, c] : cnt)//循环哈希表，如果出现次数大于i，即说明出现次数是前k个的\n        if(c > i)//i是分界点\n            res.push_back(x);\n    \n    return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104656959","body":"```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& p) {\n        \n        int res = 0;\n        for (int i = 0; i < p.size(); i ++ ) {\n            unordered_map<int, int> cnt;\n            for (int j = 0; j < p.size(); j ++ )\n                if (i != j) {\n                    int dx = p[i][0] - p[j][0];\n                    int dy = p[i][1] - p[j][1];\n                    int dist = dx * dx + dy * dy;\n                    cnt[dist] ++ ;\n                }\n            for (auto [d, c]: cnt) res += c * (c - 1);\n        }\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105968131","body":"```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int res = 0;\n        unordered_map<int, int> hash;\n        for(int i = 0, j = 0; j < s.size(); j ++) {\n           hash[s[j]] ++;\n           while(hash[s[j]] > 1) {//\n               hash[s[i ++]] --;\n           }\n           res = max(res, j - i + 1);\n         }\n         return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107517795","body":"```C++\n\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        if (words.empty()) return res;\n        int n = s.size(), m = words.size(), w = words[0].size();\n        unordered_map<string, int> tot;\n        for (auto& word : words) tot[word] ++ ;\n\n        for (int i = 0; i < w; i ++ ) {\n            unordered_map<string, int> wd;\n            int cnt = 0;\n            for (int j = i; j + w <= n; j += w) {\n                if (j >= i + m * w) {\n                    auto word = s.substr(j - m * w, w);\n                    wd[word] -- ;\n                    if (wd[word] < tot[word]) cnt -- ;\n                }\n                auto word = s.substr(j, w);\n                wd[word] ++ ;\n                if (wd[word] <= tot[word]) cnt ++ ;\n                if (cnt == m) res.push_back(j - (m - 1) * w);\n            }\n        }\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107695014","body":"```C++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> s(n + 1);\n        for(int i = 1; i <= nums.size(); i ++)\n            s[i] = s[i - 1] + nums[i - 1];\n        \n        unordered_map<int, int> cnt;//表示每一个前缀和除以k余数的数量\n        cnt[0] ++;\n        int res = 0;\n        for(int i = 1; i <= n; i ++) {\n            int r = (s[i] % k + k) % k;\n            res += cnt[r];\n            cnt[r] ++;\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107987744","body":"```C++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n    int n = 0;\n    for(ListNode *p = head; p; p = p->next) n ++;\n    if(n <= 1) return head;\n    \n        ListNode *ans = head;\n        int t = n / 2 ;\n        while(t --) {\n            ans = ans->next;\n        }\n        return ans;\n    \n    return head;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109375913","body":"```C++\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n         for(int i = 0; i < nums.size(); i ++) {\n             if(!i || nums[i] != nums[i - 1])\n                nums[k ++] = nums[i];\n         }\n         return k;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110477821","body":"```C++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l  = 0, r = nums.size() - 1;\n        for(int i = 0; i < nums.size(); i ++) {\n            int mid = l + r >> 1;\n            if(nums[mid] >= target) r = mid;\n            else l = mid + 1;\n        }\n        if(r == nums.size() - 1 && target > nums[r]) r ++;\n        return r;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111913433","body":"```C++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n    deque<int> q;\n    vector<int> res;\n\n    for(int i = 0; i < nums.size(); i ++ ) {\n        if(q.size() && i - k + 1 > q.front()) q.pop_front();//自然出队，大于滑动窗口大小\n        while(q.size() && nums[i] >= nums[q.back()]) q.pop_back();//把当前元素加进去,如果要加入的元素大于队列中的值，把队列中小于该值的值全部删除\n        q.push_back(i);\n        if(i >= k - 1) res.push_back(nums[q.front()]);//表示当前窗口中至少右k个元素\n    }\n\n    return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112840093","body":"```C++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n    vector<int> din(n + 1),  dout(n + 1);\n    for(auto p : trust) {\n        int a = p[0], b = p[1];\n        din[b] ++;\n        dout[a] ++;\n    }\n\n    int res = -1;\n    for(int i = 1; i <= n; i ++) {\n        if(!dout[i] && din[i] == n - 1) {\n            if(res != -1) res = -1;\n            res = i;\n        }\n    }\n    return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085420206","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int resLen = fmax(numSize + 1, 5); // k 的取值范围 [1, 10^4]，加上进位最多是 5 位数\n    int* res = malloc(sizeof(int) * resLen);\n    int r, w;\n\n    w = resLen - 1;\n    r = numSize - 1;\n\n    while (k || r >= 0) {\n        if (r >= 0) k += num[r--];\n        res[w--] = k % 10;\n        k /= 10;\n    }\n\n    int realStart = w + 1;\n    *returnSize = resLen - realStart;\n    return res + realStart;\n}\n```\n- ****Time:**** $O(max(N,logk))$\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086484326","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* shortestToChar(char * s, char c, int* returnSize) {\n    int len = strlen(s);\n    int* res = malloc(sizeof(int) * len);\n\n    res[0] = s[0] == c ? 0 : len;\n\n    for (int i = 1; i < len; ++i)\n        res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n    for (int i = len - 2; i >= 0; --i)\n        res[i] = fmin(res[i], res[i + 1] + 1);\n\n    *returnSize = len;\n    return res;\n}\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ****Space:**** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883763","body":"```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : maxSize_(maxSize), top_(-1) {\n        stack_.resize(maxSize);\n        inc_.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top_ < maxSize_ - 1) stack_[++top_] = x;\n    }\n    \n    int pop() {\n        if (top_ == -1) return -1;\n        if (top_ > 0) inc_[top_ - 1] += inc_[top_];\n        int val = stack_[top_] + inc_[top_];\n        inc_[top_--] = 0;\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        int idx = min(k - 1, top_);\n        if (idx >= 0) inc_[idx] += val;\n    }\nprivate:\n    vector<int> stack_;\n    vector<int> inc_;\n    int maxSize_;\n    int top_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087473885","body":"```cpp\nclass Solution {\npublic:\n    bool isNumber(const string& str) {\n        for (char const &c : str) {\n            if (std::isdigit(c) == 0) return false;\n        }\n        return true;\n    }\n\n    string repeat(const string& s, int t) {\n        string res;\n        while (t-- > 0) res += s;\n        return res;\n    }\n\n    string decodeString(string s) {\n        string res;\n        stack<string> stk;\n\n        for (char c : s) {\n            if (c != ']') {\n                stk.push(string(1, c));\n                continue;\n            }\n\n            string p = \"\";\n            while (!stk.empty() && stk.top() != \"[\") {\n                p = stk.top() + p; stk.pop();\n            }\n            stk.pop(); // pop out '['\n\n            string t = \"\";\n            while (!stk.empty() && isNumber(stk.top())) {\n                t = stk.top() + t; stk.pop();\n            }\n            stk.push(repeat(p, stoi(t)));\n        }\n\n        while (!stk.empty()) {\n            res = stk.top() + res; stk.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1089675885","body":"```cpp\nclass MyQueue {\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        write_.push(x);\n    }\n    \n    int pop() {\n        if (read_.empty()) pour();\n        int val = read_.top();\n        read_.pop();\n        return val;\n    }\n    \n    int peek() {\n        if (read_.empty()) pour();\n        return read_.top();\n    }\n    \n    bool empty() {\n        return write_.empty() && read_.empty();\n    }\nprivate:\n    void pour() {\n        while (!write_.empty()) {\n            read_.push(write_.top());\n            write_.pop();\n        }\n    }\n\n    stack<int> read_;\n    stack<int> write_;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089692923","body":"```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        for (auto n : arr) {\n            if (stk.empty() || n >= stk.top())\n                stk.push(n); // new chunk\n            else {\n                int temp = stk.top(); stk.pop();\n                // combine chunks\n                while (!stk.empty() && stk.top() > n)\n                    stk.pop();\n                stk.push(temp);\n            }\n        }\n        return stk.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091730222","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0) return head;\n\n        int n = 1;\n        ListNode* p = head;\n        while (p->next != nullptr) {\n            p = p->next;\n            n++;\n        }\n        // 首尾相连\n        p->next = head;\n        k = n - k % n;\n        // 走 n-k 步，断开\n        while (k-- > 0) {\n            p = p->next;\n        }\n        ListNode* newHead = p->next;\n        p->next = nullptr;\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092392992","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) return head;\n        auto nextPair = swapPairs(head->next->next);\n        auto p1 = head, p2 = head->next;\n        p2->next = p1;\n        p1->next = nextPair;\n        return p2;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dzwhh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085428758","body":"### 思路\n逐位相加,当数组不为空或者k不为0，从末位数字开始，加k当前位(k%10)+进位(carry初始是0),加和后push到开辟的数组去同时只push当前位，循环结束最后判断一次是否还有进位，如果有再push一次，最后反转数组得到最终结果\n\n### 关键点\n- 处理当前位是 num % 10\n- 处理进位是 num / 10\n- 需要判断数组是空，或者k是0的情况\n\n### 代码\n- js版本\n```js\nconst addToArrayForm = (num, k) => {\n  let res = []; // 最终输出结果数组\n  let carry = 0; // 标记进位\n  let tail = num.length - 1; // 数组末位元素，代表各个位的数字\n  let sum = 0; // 各个位加和的结果\n\n  while(tail >= 0 || k != 0) {\n    let x = tail >= 0 ? num[tail] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    sum = x + y + carry; //num数组当前位+k当前位+进位\n    res.push(sum % 10); //sum 可能有进位 取模 10 剔除掉进位数字\n    tail--; //数组向前挪动\n    k = Math.floor(k/10);  // k向高位数字挪动\n    carry = Math.floor(sum / 10); //记录进位数字\n  }\n  if(carry === 1)\n    res.push(carry); //最后一次加和如果有进位最后的1push到数组\n  return res.reverse(); // 从后往前添加的数组，需要反转得到最终结果\n}\n\n```\n### 复杂度分析\n时间复杂度: O(max(n,k))\n空间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086588218","body":"### 思路\n先把字符串中等于c字符的对应下标存到数组res中，作为对比项使用，同时设置指向c字符下标数组的指针p，然后在遍历字符串每个字符，把每个字符的下标数值与res的c字符下标相减，得到距离，每次只比较c字符下标当前值和后继值，如果发现当前值的差值比后继值的差值大，那就把p指针向后挪一位，因为这时候当前值不需要在以后的判断中使用，因为肯定比后面的c字符位置要远,同时把字符串当前字符位置和c字符下标数组对应位置的差异存到dist最终结果数组中\n\n### 关键点\n- 下标差值的比较\n- 当前字符位置与c字符前后2个位置的距离比较，大的代表距离远，需要移动指针\n\n### 代码\n\n- js 版本\n\n```js\nconst shortestToChar = (s, c) => {\n  let res = []; // c字符下标数组\n  let p = 0; // 指向c字符下标数组的指针\n  let dist = []; // 最终结果\n\n  // 把字符串中等于c字符的对应下标存在res数组中\n  for(let i = 0; i < s.length; i++) {\n    if (s[i] ===  c)\n      res.push(i)\n  }\n  \n  // 遍历字符串字符，比较每个字符下标与对应c字符下标的差值\n  for(let j = 0; j < s.length; j++) {\n    // 数组元素和c下标数组前后两个值对比,如果前一个比较值比后一个比较值大，p指针向后挪一位\n    if (p < res.length && Math.abs(j - res[p]) > Math.abs(j - res[p+1])) \n      p++; \n    dist.push(Math.abs(j - res[p]));\n  }\n  return dist;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(m+n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839940","body":"## 1381. Design a Stack With Increment Operation「设计一个支持增量操作的栈」\n- 题目地址: https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n### 题目描述\n请你设计一个支持下述操作的栈。\n实现自定义栈类 CustomStack ：\n- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n### 前置知识\n- 数组、栈\n\n### 思路\n用数组模拟栈操作，maxSize 数组容量也是栈容量，设置一个top指针，作为指向栈顶的指针，每次向栈增加一个元素就是向top位置下标添加一个元素，同时top向后挪一位,pop栈顶操作就是返回top前一位元素; inc 操作可以判断k和top谁小，就遍历范围定到谁作为边界添加val\n\n### 关键点\n- top指针的前后移动，如果初始值为0，那push是先添加元素在挪动top，pop是返回top-1位置的元素\n\n### 代码\n- js 版本\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.stack = new Array(maxSize);\n  this.top = 0;\n};\n\n/** \n* @param {number} x\n* @return {void}\n*/\nCustomStack.prototype.push = function(x) {\n  if (this.top === this.stack.length)\n      return;\n  else   \n      this.stack[this.top++] = x;\n};\n\n/**\n* @return {number}\n*/\nCustomStack.prototype.pop = function() {\n  if (this.top === 0)\n    return -1\n  return this.stack[--this.top];\n  \n};\n\n/** \n* @param {number} k \n* @param {number} val\n* @return {void}\n*/\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(k,this.top)\n  for(let i = 0; i < len; i++){\n      this.stack[i] += val\n  }\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087652609","body":"## 394.Decode String「字符串解码」\n- 题目地址: https://leetcode-cn.com/problems/decode-string/\n\n### 题目描述\n> 给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n**示例 1:**\n>输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n**示例 2:**\n>输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n**示例 3:**\n>输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n### 前置知识\n- 栈\n\n### 思路\n从左往右遍历，遇到\"[\"代码前面如果有数字就是重复次数，把数字压入数字栈， 如果遍历到是字符，把字符压入字符栈中，直到遇到“[”, 把数字和字符临时变量清零，最后遇到\"]\"时，先出栈数字栈，得到要repeat字符串的次数，然后构建子字符串\n\n\n\n### 代码\n- js 版本\n```js\nconst decodeString = s => {\n  let numStack = [];\n  let strStack = [];\n  let num = 0;\n  let res = '';\n\n  for(let c of s) {\n    if (!isNaN(c)){\n      num = num * 10 + Number(c);\n    } else if(c === '[') {\n      strStack.push(res);\n      res = '';\n      numStack.push(num);\n      num = 0;\n    }else if (c === ']') {\n      let repeatTimes = numStack.pop();\n      res = strStack.pop() + res.repeat(repeatTimes);\n\n  }else {\n    res += c;\n  }\n}\nreturn res;\n```\n\n### 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(n)\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088543061","body":"## DAY 5 232. Implement Queue using Stacks「用栈生成队列」\n\n- 题目地址: https://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n### 题目描述\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n> 实现 MyQueue 类：\n> void push(int x) 将元素 x 推到队列的末尾\n> int pop() 从队列的开头移除并返回元素\n> int peek() 返回队列开头的元素\n> boolean empty() 如果队列为空，返回 true ；否则，返回 false\n> 说明：\n> 你 只能 使用标准的栈操作 —— 也就是只有  push to top, peek/pop from top, size, 和  is empty  操作是合法的。\n> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n**示例 1:**\n\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n\n### 前置知识\n\n- 栈\n\n### 思路\n\n使用两个栈，通过组合使用 FIFO 的特征，从第一个栈 push 进去，然后 pop 出第一个栈的元素，再 push 到第二栈，最后从第二个栈 pop 出去所有元素，这样就实现了先进先出的逻辑\n\n### 关键点\n\n- pop 需要判断第二个栈是否是空，如果是空需要先进行栈 1 导入栈 2 的操作\n\n### 代码\n\n- js 版本\n\n```js\nvar MyQueue = function () {\n  this.inStack = [];\n  this.outStack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (this.outStack.length === 0) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  return this.outStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (this.outStack.length === 0) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return this.inStack.length === 0 && this.outStack.length === 0;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090249026","body":"## DAY6 768. Max Chunks To Make Sorted II「最多能完成排序的块 II」\n- 题目地址: https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n### 题目描述\n>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n我们最多能将数组分成多少块？\n\n**示例1**\n>输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n\n**示例2**\n>输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数\n\n### 前置知识\n- 单调栈\n\n### 思路\n根据题目描述，块与块之间一定是单调递增的，如果出现了比之前块小的元素，那就需要合并到前面的块中去，通过单调递增栈的方式，把每块的最大值压入栈，最后统计栈中元素个数，就是排序块\n\n### 代码\n- js 版本\n\n```js\nconst maxChunksToSorted = arr => {\n  const stack = [];\n\n  for(let i = 0; i < arr.length; i++){\n    if(stack.length === 0 || stack[stack.length - 1] <= arr[i]){\n      stack.push(arr[i]);\n    } else {\n      const maxTemp = stack.pop();\n      while(stack[stack.length - 1] < arr[i]){\n        stack.pop();\n      }\n      stack.push(maxTemp);\n    }\n  }\n  return stack.length;\n}\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091389048","body":"## DAY7 Rotate List「旋转链表」\n- 题目地址: https://leetcode-cn.com/problems/rotate-list/\n\n### 题目描述\n> 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置\n\n**示例1**\n>输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n**示例2**\n>输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n### 前置知识\n- 求单链表的倒数第 N 个节点\n\n### 思路\n先遍历链表得出节点个数，然后通过快慢指针，先让快指针遍历k步，接着快慢指针同时开始遍历，直到快指针走到尾部时，把快指针的后继指针指向head，形成环，然后head指针指向慢指针的后续指针，最后把慢指针的后继指针置null断开环，完成旋转的过程\n\n### 代码\n- js版本\n```js\nconst rotateRight = (head, k) => {\n  if(head === null || head.next === null) return head;\n  let len = 0,tail = head;\n  // 遍历链表获得链表长度\n  while(tail){\n    tail = tail.next;\n    len++;\n  }\n  // 需要移动的步数，由于可能出现k大于len的情况所以取模获取步数\n  k = k % len;\n\n  // 定义快慢指针都指向head初始化\n  let slow = head;\n  let fast = head;\n\n  // 快指针先向前移动k步\n  for(let i = 0; i < k; i++){\n    fast = fast.next;\n  }\n\n  // 快慢指针同时移动，直到快指针移动到tail\n  while(fast.next != null){\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  fast.next = head; // 快指针后续节点指向head形成环\n  head = slow.next; // 慢指针后续节点变成head\n  slow.next = null; // 断开慢指针的后续节点\n  return head;\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092587250","body":"## 【Day 8】24.Swap Nodes in Pairs「两两交换链表中的节点」\n- 题目地址: https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n### 题目描述\n\n> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n**示例 1**\n\n> 输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n**示例 2**\n\n> 输入：head = []\n输出：[]\n\n**示例 3**\n\n> 输入：head = [1]\n输出：[]\n\n### 前置知识\n\n- 链表\n\n### 思路\n通过迭代的方式，构建虚拟指针，先预存第二个节点和第三个节点指针，每次迭代过程是第二个节点next指向第一个节点，第一个节点next指向，第三个节点也就是head.next.next，虚拟指针prev的next指向第二个节点，完成节点交换，同时更新指针把prev 变为当前指针，当前指针指向下一个交换节点\n\n### 代码\n\n- js 版本\n\n```js\nconst swapPairs = head => {\n  if (head === null || head.next === null) \n    return head;\n\n  let dummyNode = new ListNode(0,head);\n  let prev = dummyNode, cur = head;\n\n  while(cur !== null && cur.next != null){\n    // 保存下一次反转节点指针\n    let nextPair = cur.next.next \n    let second = cur.next;\n\n    // 开始反转节点\n    second.next = cur;\n    cur.next = nextPair;\n    prev.next = second;\n\n    // 更新指针\n    prev = cur;\n    cur = nextPair;\n  }\n\n  return dummyNode.next;\n}\n```\n\n### 复杂度分析\n\n时间复杂度: O(n)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094034907","body":"## 【Day 9】109. Convert Sorted List to Binary Search Tree「有序链表转换二叉搜索树」\n- 题目地址: https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n### 题目描述\n> 给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n**示例1**\n> 输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n**示例2**\n> 输入: head = []\n输出: []\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n### 前置知识\n- 链表\n- 二叉树\n\n### 思路\n先把有序链表转成有序数组，由于题目中描述元素是按升序排序，那意味着中间值天然左边小，右边大，所以只要每次找中间点进行左右递归进行BST构建即可\n\n\n### 代码\n\n- js 版本\n\n```js\nconst sortedListToBST = head => {\n  let arr = [];\n  while(head){\n    arr.push(head.val);\n    head = head.next;\n  }\n\n  // 通过索引start 和 end 构建子树\n  const buildBST = (start, end) => {\n    if(start > end) \n      return null;\n    const mid = (start + end) >>> 1;\n    const root = new TreeNode(arr[mid]);\n    root.left = buildBST(start, mid - 1);\n    root.right = buildBST(mid + 1, end);\n    return root;  \n  };\n\n  return buildBST(0, arr.length - 1);\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094278427","body":"## 【Day 10】160. Intersection of Two Linked Lists「相交链表」\n- 题目地址: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n### 题目描述\n>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n自定义评测：\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n\n**示例1**\n![pic](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)\n>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n**示例2**\n![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\n)\n\n>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n### 前置知识\n\n- 链表\n\n### 思路\n遍历A链表节点，同时把节点放入集合, 再遍历B链表判断是否节点在集合中存在，存在即代表两个链表相交，返回该节点，否在返回null\n\n### 关键点\n- 相交节点后面的链表节点都相同\n\n\n### 代码\n\n- js 版本\n\n```js\nconst getIntersectionNode = (headA, headB) => {\n  const visited = new Set();\n  let tmp = headA;\n  while(tmp != null){\n    visited.add(tmp);\n    tmp = tmp.next;\n  }\n  tmp = headB;\n  while(tmp != null){\n    if(visited.has(tmp))\n      return tmp;\n    tmp = tmp.next;\n  }\n\n  return null;\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度:O(m+n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094659376","body":"## 【Day 11】142. Linked List Cycle II 「环形链表 II」\n\n- 题目地址: https://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n### 题目描述\n\n> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n\n**示例 1**\n![pic](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n### 前置知识\n\n- 链表\n\n### 思路\n#### 方法1-哈希表\n遍历每个节点，如果该节点不在哈希表，就先放入哈希表，然后继续向后遍历，如果遇到当前节点已经在哈希表，就证明出现环入口了，随即返回该节点\n\n\n### 代码\n\n- js 版本\n\n```js\nconst detectCycle = head => {\n    const visited = new Set();\n    while(head != null){\n      if(visited.has(head))\n        return head;\n      visited.add(head);\n      head = head.next;\n    }\n    return null;\n};\n```\n\n### 复杂度分析\n\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096404954","body":"## 【Day 12】146. LRU Cache 「LRU 缓存机制」\n- 题目地址: https://leetcode-cn.com/problems/lru-cache/\n\n### 题目描述\n\n>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\n实现 LRUCache 类：\n- LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\n- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n- void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n\n**示例 1**\n>输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n\n### 前置知识\n\n- 哈希表\n- 链表\n\n### 思路\n数据被读取了，就是被使用了，所在的位置要刷新，浮到“顶部”。\n写入数据时：\n之前就存在的：更新数据，刷新位置。\n之前不存在的：有位置就直接写入，没有位置，就删掉最久没有使用的条目，再写入。\n要求 get 和 put 为 O(1)O(1)，这俩操作都可能导致条目的移动(有删除操作)，所以删除操作也要是 O(1)O(1)\n### 代码\n\n- js 版本\n\n```js\nclass ListNode {\n  constructor(key, value) {\n    this.key = key\n    this.value = value\n    this.next = null\n    this.prev = null\n  }\n}\n\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity\n    this.hash = {}\n    this.count = 0\n    this.dummyHead = new ListNode()\n    this.dummyTail = new ListNode()\n    this.dummyHead.next = this.dummyTail\n    this.dummyTail.prev = this.dummyHead\n  }\n\n  get(key) {\n    let node = this.hash[key]\n    if (node == null) return -1\n    this.moveToHead(node)\n    return node.value\n  }\n\n  put(key, value) {\n    let node = this.hash[key]\n    if (node == null) {\n      if (this.count == this.capacity) {\n        this.removeLRUItem()\n      }\n      let newNode = new ListNode(key, value)\n      this.hash[key] = newNode\n      this.addToHead(newNode)\n      this.count++\n    } else {\n      node.value = value\n      this.moveToHead(node)\n    }\n  }\n\n  moveToHead(node) {\n    this.removeFromList(node)\n    this.addToHead(node)\n  }\n  \n  removeFromList(node) {\n    let temp1 = node.prev\n    let temp2 = node.next\n    temp1.next = temp2\n    temp2.prev = temp1\n  }\n\n  addToHead(node) {\n    node.prev = this.dummyHead\n    node.next = this.dummyHead.next\n    this.dummyHead.next.prev = node\n    this.dummyHead.next = node\n  }\n\n  removeLRUItem() {\n    let tail = this.popTail()\n    delete this.hash[tail.key]\n    this.count--\n  }\n\n  popTail() {\n    let tail = this.dummyTail.prev\n    this.removeFromList(tail)\n    return tail\n  }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度:O(1)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097376764","body":"\n## 【Day 13】104. Maximum Depth of Binary Tree 「二叉树的最大深度」\n\n- 题目地址: https://leetcode-cn.com/problems/maximum-depth-of-binary-tree\n\n### 题目描述\n\n> 给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n\n**示例 1**\n给定二叉树 [3,9,20,null,null,15,7]，\n>   3\n   / \\\\\n  9  20\n    /  \\\\\n   15   7\n\n### 前置知识\n\n- 二叉树\n- 递归\n\n\n### 思路\n从宏观的角度，先确定最基本问题，也就是终止条件是什么，然后把原问题转化成更小的问题，递归本身还是调用子函数的过程，只是这个子函数是自身，可想象成调用了一个功能相同的函数\n从微观的角度，每次调用子函数就是调用程序栈把子函数压入栈，直到满足终止条件后层层pop出去，把最小问题的结果返回上层函数\n\n### 代码\n\n- js 版本\n\n```js\nconst maxDepth = root => {\n  if(root === null)\n  \treturn 0;\n  return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098658236","body":"## 【Day 14】100.Same Tree「相同的树」\n\n- 题目地址: https://leetcode-cn.com/problems/same-tree/\n\n### 题目描述\n\n>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n**示例 1**\n>Input: p = [1,2,3], q = [1,2,3]\nOutput: true\n\n### 前置知识\n\n- 树\n\n### 思路\n左右子树递归的方式进行两树值的对比\n### 代码\n\n- js 版本\n\n```js\nconst isSameTree = (p,q) => {\n  if (p === null && q === null)\n    return true;\n  else if (p === null || q === null)\n    return false;\n  else if (p.val != q.val)\n    return false;\n  else\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099816811","body":"## 【Day 15】129.Sum Root to Leaf Numbers 「求根到叶子节点数字之和」\n\n- 题目地址: https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n### 题目描述\n\n> 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n每条从根节点到叶节点的路径都代表一个数字：\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n计算从根节点到叶节点生成的 所有数字之和 。\n叶节点 是指没有子节点的节点。\n\n\n**示例 1**\n>Input: root = [1,2,3]\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.\n\n**示例 2**\n>Input: root = [4,9,0,5,1]\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.\n\n### 前置知识\n\n- DFS\n\n### 思路\n递归左右子树，同时记录每个节点的数字，由于题目要求是路径和，所以上层节点是下层节点的10倍，再往下递归的过程中，传入当一层数字*10的值，最后左右递归和相加\n\n### 代码\n\n- js 版本\n\n```js\nconst dfs = (root,prevSum) => {\n   if(root === null)\n     return 0;\n\n   const sum = prevSum * 10 + root.val;\n\n   if(root.left === null && root.right === null)\n     return sum;\n   else\n     return dfs(root.left, sum) + dfs(root.right, sum);\n};\n\nconst sumNumbers = root =>{\n  \n return dfs(root, 0)\n\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100642502","body":"## 【Day 16】513.Find Bottom Left Tree Value「找树左下角的值」\n\n- 题目地址: https://leetcode-cn.com/problems/find-bottom-left-tree-value/\n\n### 题目描述\n\n> 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n假设二叉树中至少有一个节点。\n\n**示例 1**\n>输入: root = [2,1,3]\n输出: 1\n\n**示例 2**\n>输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n\n### 前置知识\n\n- 树\n- DFS\n\n### 思路\n通过DFS递归找出深度最深的左叶子节点的值\n\n\n### 代码\n\n- js 版本\n\n```js\nconst findBottomLeftValue = root => {\n  let maxDepth = 0;\n  let res = root.val;\n\n  dfs(root.left, 0);\n  dfs(root.right, 0);\n\n  return res;\n\n  function dfs(cur, depth) {\n  if(cur === null)\n    return null;\n\n  const curDepth = depth + 1;\n  if(curDepth > maxDepth){\n    maxDepth = curDepth;\n    res = cur.val;\n  }\n  dfs(cur.left, curDepth);\n  dfs(cur.right, curDepth);\n}\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100848044","body":"## 【Day 17】297. Serialize and Deserialize Binary Tree「二叉树的序列化与反序列化」\n\n- 题目地址: https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\n\n### 题目描述\n\n> 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n> 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n> 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅  LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n**示例 1**\n![pic](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\n\n> 输入：root = [1,2,3,null,null,4,5]\n> 输出：[1,2,3,null,null,4,5]\n\n### 前置知识\n\n- DFS\n- BFS\n\n### 思路\n\nDFS（递归）前序遍历序列化二叉树\n\n### 代码\n\n- js 版本\n\n```js\nconst serialize = (root) => {\n  if (root === null) return \"x\";\n  const left = serialize(root.left);\n  const right = serialize(root.right);\n  return root.val + \",\" + left + \",\" + right;\n};\n\nconst deserialize = (data) => {\n  const list = data.split(\",\"); // split成数组\n\n  const buildTree = (list) => {\n    // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"x\") {\n      // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list); // 递归构建左子树\n    root.right = buildTree(list); // 递归构建右子树\n    return root; // 返回当前构建好的root\n  };\n\n  return buildTree(list);\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101217070","body":"\n## 【Day 18】987. Vertical Order Traversal of a Binary Tree「二叉树的垂序遍历」\n\n- 题目地址: https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/\n\n### 题目描述\n\n>给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\n对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)` 。树的根结点位于 `(0, 0)` 。\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n返回二叉树的 垂序遍历 序列。\n\n\n**示例 1**\n![pic](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)\n>输入：root = [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n**示例 2**\n![pic](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)\n>输入：root = [1,2,3,4,5,6,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n\n### 前置知识\n\n- dfs\n- 哈希表\n\n### 思路\n从根节点开始遍历一次整颗树，在遍历过程中使用数组 nodes 记录每个节点的行号 row， 列号 col以及节点值，遍历完成后对节点进行排序，然后在进行一次遍历，将行号相等的value放在同一个数组\n\n### 代码\n\n- js 版本\n\n```js\nconst verticalTraversal = root => {\n  const nodes = [];\n  dfs(root,0,0,nodes);\n\n  nodes.sort((a, b) => {\n    if(a[0] != b[0])\n      return a[0] - b[0];\n    else if (a[1] != b[1])\n      return a[1] - b[1];\n    else\n      return a[2] - b[2];\n  });\n\n  const ret = [];\n  let min = -Number.MAX_VALUE;\n  for(const x of nodes){\n    if(min != x[0]){\n      min = x[0];\n      ret.push([]);\n    }\n    ret[ret.length - 1].push(x[2]);\n  }\n  return ret;\n\n  function dfs(node, row, col, nodes){\n    if(node === null)\n      return;\n    \n    nodes.push([col,row,node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1,nodes);\n  }\n}\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(h)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102155641","body":"## 1. 两数之和\n\n- 题目地址：https://leetcode-cn.com/problems/two-sum\n\n### 题目描述\n\n> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n> 给定 nums = [2, 7, 11, 15], target = 9\n> 因为 nums[0] + nums[1] = 2 + 7 = 9\n> 所以返回 [0, 1]\n\n---\n\n### 前置知识\n\n- 哈希表\n\n### 思路\n\n#### 方法 1: 暴力枚举\n\n我们可以利用两层 for 循环来遍历每个元素，两两相加查找满足条件的目标元素，本质上用求和的思路来解\n**代码**\n\n```js\nconst twoSum = (nums, target) => {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = 0; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n  return [];\n};\n```\n\n但是双层循环时间复杂度为 O(N^2)，空间复杂度为 O(1)，时间复杂度较高，我们要想办法进行优化\n\n#### 方法 2: 哈希表\n\n通过求差的方式，每次遍历数组都让目标值减去数组元素 `target-num[i]` ，得到一个 diff 值，然后应用哈希表「Map」这样的数据结构，去记录这个 diff 差值是否已经在 map 里存在了，如果存在表示 diff + 当前数 = target，我们找到了答案，如果不存在就把当前数及其对应的索引值`[num[i],i]`，放入 map，继续遍历下一个数字\n\n### 关键点\n\n- 求和转换为求差\n- 借助 Map 结构将数组中每个元素及其索引相互对应\n- 以空间换时间，将查找时间从 O(N) 降低到 O(1)\n- 思维逻辑上 x + y = target，先遍历到 x 得不到答案，当把 x 放入 map 后，在遍历到 y 的时候去 check 到 x，才能得到答案\n\n### 代码\n\n- Js 版本\n\n```Js\nconst twoSum = (nums,target) => {\n  let map = new Map();\n  for(let i = 0; i < nums.length; i++) {\n    let diff = target - nums[i];\n    if(map.has(diff))\n      return [map.get(diff),i]\n    else\n      map.set(nums[i],i) // 把可能是其中一个减数放进map\n  }\n}\n```\n\n- Java 版本\n\n```java\nclass Solution {\n  public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (hashtable.containsKey(target - nums[i])) {\n            return new int[]{hashtable.get(target - nums[i]), i};\n        }\n        hashtable.put(nums[i], i);\n    }\n    return new int[0];\n  }\n}\n```\n\n- Python 版本\n\n```python\nclass Solution:\n  def twoSum(self, nums: List[int], target: int) -> List[int]:\n    hashtable = dict()\n    for i, num in enumerate(nums):\n      if target - num in hashtable:\n          return [hashtable[target - num], i]\n      hashtable[nums[i]] = i\n    return []\n```\n\n### 复杂度分析\n\n时间复杂度: O(n),N 是遍历数组的开销；查找匹配是 O(1)\n空间复杂度: O(n), 其中 N 是数组中的元素数量,主要为哈希表的开销\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103425026","body":"## 【Day 20】347.Top K Frequent Elements「前 K 个高频元素」\n\n- 题目地址: https://leetcode-cn.com/problems/top-k-frequent-elements/\n\n### 题目描述\n\n> 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n**示例 1**\n>输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n\n### 前置知识\n\n- 哈希表\n\n### 思路\n先遍历元素把元素和其个数放入哈希表，然后再对哈系表中的value进行排序，最后把前K个元素存入结果输出\n\n### 代码\n\n- js 版本\n\n```js\nconst topKFrequent = (nums, k) => {\n  let map = new Map();\n\n  for(let itm of nums){\n    map.set(itm,(map.get(itm) || 0) + 1);\n  }\n\n  const arr = [...map].sort((a,b) => b[1] - a[1]);\n  const res = [];\n\n  for(let i = 0; i < k; i++){\n    res.push(arr[i][0])\n  }\n\n  return res;\n\n}\n```\n\n### 复杂度分析\n\n时间复杂度:O(nlogn)\n空间复杂度:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104663563","body":"## 【Day 21】447.Number of Boomerangs「回旋镖的数量」\n\n- 题目地址: https://leetcode-cn.com/problems/number-of-boomerangs/\n\n### 题目描述\n\n>给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。\n返回平面上所有回旋镖的数量。\n\n\n**示例 1**\n>输入：points = [[0,0],[1,0],[2,0]]\n输出：2\n解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n\n**示例 2**\n>输入：points = [[1,1],[2,2],[3,3]]\n输出：2\n\n**示例 3**\n>输入：points = [[1,1]]\n输出：0\n\n### 前置知识\n\n- 哈希表\n\n### 思路\n我们可以遍历 points，计算并统计所有点到 points[i] 的距离，将每个距离的出现次数记录在哈希表中，然后遍历哈希表，并用上述公式计算并累加回旋镖的个数。\n\n### 代码\n\n- js 版本\n\n```js\nconst numberOfBoomerangs = points => {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n\n```\n\n### 复杂度分析\n\n时间复杂度:O(n2)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106653107","body":"## 【Day 22】3.Longest Substring Without Repeating Characters 「无重复字符的最长子串」\n\n- 题目地址:https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n### 题目描述\n\n> 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度\n\n**示例 1**\n>输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n**示例 2**\n>输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n**示例 3**\n>输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n### 前置知识\n\n- 哈希表\n- 滑动窗口\n\n### 思路\n通过哈希set存放每次非重复字符，同时用滑动窗口start和end两个指针进行窗口滑动，滑动右指针进行判重滑动，遇到重复则记录则记录非重复的长度，同时左侧指针向左挪一步\n\n\n### 代码\n\n- js 版本\n\n```js\nconst lengthOfLongestSubstring = s => {\n  const hashSet = new Set();\n  let end = -1,maxLen = 0;\n  for(let i = 0; i < s.length; i++){\n    if(i != 0){\n      // 左指针向左挪一步\n      hashSet.delete(s.charAt(i-1));\n    }\n    while(end + 1 < s.length && !hashSet.has(s.charAt(end + 1))){\n      hashSet.add(s.charAt(end + 1));\n      end++;\n    }\n    maxLen = Math.max(maxLen, end - i + 1)\n  }\n  return maxLen;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107525137","body":"## 【Day 23】30.Substring with Concatenation of All Words「串联所有单词的子串」\n\n- 题目地址: https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/\n\n### 题目描述\n\n> 给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑words 中单词串联的顺序。\n\n\n**示例 1**\n>输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n**示例 2**\n>输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n\n**示例 3**\n>输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n\n### 前置知识\n\n- 哈希表\n- 双指针\n\n\n\n- js 版本\n\n```js\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    let correct = {};\n    for (let i = 0 ; i < words.length; i++) {\n        correct[words[i]] = correct[words[i]] || 0;\n        correct[words[i]] ++;\n    }\n\n    let ret = [];\n\n    for (let start = 0; start < words[0].length; start ++) {\n        let map = {};\n        let len = words[0].length;\n        for (let i = start; i < s.length;) {\n            if (i + len > s.length) break;\n\n            let tmp = s.slice(i, i + len);\n            map[tmp] = map[tmp] || 0;\n            map[tmp] ++;\n\n            if (i - len * words.length >= 0) {\n                let prev = s.slice(i - len * words.length, i - len * words.length + len);\n                map[prev] = map[prev] || 0;\n                map[prev] --;\n            }\n\n\n            let flag = true;\n            for (let key in correct) {\n                if (correct[key] !== map[key]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ret.push(i - (words.length - 1) * len);\n            }\n            i = i + len;\n        }\n    }\n\n    return ret;\n};\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108029147","body":"## 【Day25】876. Middle of the Linked List「链表的中间结点」\n\n- 题目地址: https://leetcode-cn.com/problems/middle-of-the-linked-list/\n\n### 题目描述\n\n> 给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n如果有两个中间结点，则返回第二个中间结点。\n\n**示例 1**\n>Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/middle-of-the-linked-list\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n### 前置知识\n\n- 链表\n- 双指针\n\n### 思路\n用快慢指针，快指针走2步，慢指针走1步，当快指针走到尾(刚好走到尾部是奇数)或者超过尾(超过1位是偶数)，慢指针指向的位置就是中间，因为快指针比慢指针快一倍\n### 代码\n\n- js 版本\n\n```js\nconst middleNode = head => {\n  if(head === null || head.next === null)\n    return head;\n\n  let slow = (fast = head);\n\n  while(fast != null && fast.next != null){\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109411331","body":"\n## 【Day 26】26.Remove Duplicates from Sorted Array「删除排序数组中的重复项」\n\n- 题目地址: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n### 题目描述\n\n> 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n\n**示例 1**\n\n### 前置知识\n\n- 双指针\n\n### 思路\n通过快慢指针，起始位置为第二个元素，由快指针先走判断前后元素是否相等，相等往后走，遇到不相等的元素，把fast指针覆盖slow指针，接着slow++，如果前后元素相等fast++,如此往复直到fast越界，返回slow\n\n### 代码\n\n- js 版本\n\n```js\nconst removeDuplicates = nums => {\n  let len = nums.length;\n  if(len === 0) return 0;\n  let slow = (fast = 1); // 从第二个元素开始比较\n  while(fast < len){\n    if(nums[fast] != nums[fast - 1]){\n      nums[slow] = nums[fast];\n      slow++;\n    }\n      fast++; \n  }\n  return slow;\n}\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112355474","body":"\n## 【Day 28】239.Sliding Window Maximum 「滑动窗口最大值」\n\n- 题目地址: https://leetcode-cn.com/problems/sliding-window-maximum/\n\n### 题目描述\n\n> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n\n\n**示例 1**\n> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                | 最大值\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n### 前置知识\n\n- 单调队列\n\n### 关键点\n- (i - k + 1) 等于窗口最左边的一个元素的下标\n- \n\n### 思路\n遍历给定数组中的元素，如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。直到，队列为空或当前考察元素小于新的队尾元素；\n当队首元素的下标小于滑动窗口左侧边界left时，表示队首元素已经不再滑动窗口内，因此将其从队首移除。\n由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时，意味着窗口形成。此时，队首元素就是该窗口内的最大值。\n\n\n### 代码\n\n- java 版本\n\n```java\nclass Solution {\n        public int[] maxSlidingWindow(int[] nums, int k) {\n        // 窗口个数\n        int[] res = new int[nums.length - k + 1];\n        LinkedList<Integer> queue = new LinkedList<>();\n\n        // 遍历数组中元素，right表示滑动窗口右边界\n        for(int right = 0; right < nums.length; right++) {\n            // 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。\n            // 直到，队列为空或当前考察元素小于新的队尾元素\n            while (!queue.isEmpty() && nums[right] >= nums[queue.peekLast()]) {\n                queue.removeLast();\n            }\n\n            // 存储元素下标\n            queue.addLast(right);\n\n            // 计算窗口左侧边界\n            int left = right - k +1;\n            // 当队首元素的下标小于滑动窗口左侧边界left时\n            // 表示队首元素已经不再滑动窗口内，因此将其从队首移除\n            if (queue.peekFirst() < left) {\n                queue.removeFirst();\n            }\n\n            // 由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时\n            // 意味着窗口形成。此时，队首元素就是该窗口内的最大值\n            if (right +1 >= k) {\n                res[left] = nums[queue.peekFirst()];\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lyuliangliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085434802","body":"\n### 思路\nAdding from rear to front until both num and k are exhausted.\n### Code\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int digitFromK = k % 10;\n            int currentDigit = digitFromK + (i >= 0 ? num[i] : 0) + carry;\n            if (currentDigit >= 10) {\n                carry = 1;\n                currentDigit -= 10;\n            } else {\n                carry = 0;\n            }\n            result.add(0, currentDigit);\n            k /= 10;\n            i--;\n        }\n        if (carry == 1) {\n            result.add(0, 1);\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n* Time: O(N) \n* Space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086543333","body":"### Idea\n* Go forward: record the distance between each letter and the latest c in its left;\n* Go backward: update the distance if a letter is closer to the latest c in its right\n### Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int lastIndexC = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                lastIndexC = i;\n            } else if (lastIndexC == Integer.MAX_VALUE) {\n                ans[i] = Integer.MAX_VALUE;\n            } else {\n                ans[i] = i - lastIndexC;\n            }\n        }\n        lastIndexC = Integer.MAX_VALUE;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                lastIndexC = i;\n            } else if (lastIndexC - i < ans[i]) {\n                ans[i] = lastIndexC - i;\n            }\n        }\n        return ans;\n    }\n}\n```\n### Complexity\n* Time: 2N\n* Space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086707378","body":"###Idea\nInitialize an array of size maxSize. Use a pointer top to indicate current stack top.\n### Code\n```\nclass CustomStack {\n    \n    int[] stack;\n    int top;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < this.maxSize - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i <= top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\nComplexity:\n* Time: push/pop O(1), inc O(K)\n* Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087235208","body":"### Idea\nUse one stack. Push both number and string. When meets ']', pop and calculate. Always push the results back to the stack. If the next peek is a string, append to it and put it at the top.\n### Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        \n        StringBuilder result = new StringBuilder();\n        Stack<String> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i ++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                int end = i;\n                while (end < s.length() && s.charAt(end) >= '0' && s.charAt(end) <= '9') {\n                    end ++;\n                }\n                stack.push(s.substring(i, end));\n                i = end - 1;\n            } else if (c >= 'a' && c <= 'z') {\n                int end = i;\n                while (end < s.length() && s.charAt(end) >= 'a' && s.charAt(end) <= 'z') {\n                    end ++;\n                }\n                if (!stack.isEmpty() && isLetterSeq(stack.peek())) {\n                    stack.push(stack.pop() + s.substring(i, end));\n                } else {\n                    stack.push(s.substring(i, end));\n                }\n                i = end - 1;\n            } else if (c == '[') {\n                continue;\n            } else if (c == ']') {\n                String top = stack.pop();\n                int count = Integer.valueOf(stack.pop());\n                String cur = \"\";\n                for (int j = 0; j < count; j ++) {\n                    cur += top;\n                }\n                if (!stack.isEmpty() && isLetterSeq(stack.peek())) {\n                    stack.push(stack.pop() + cur);\n                } else {\n                    stack.push(cur);\n                }\n            }\n        }\n        return stack.pop();\n    }\n    \n    private boolean isLetterSeq(String s) {\n        if (s.charAt(0) >= 'a' && s.charAt(0) <= 'z') {\n            return true;\n        }\n        return false;\n    }\n}\n```\n### Complexity\n* time: 2N\n* space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088344631","body":"### Idea\nPush to stack1: O(1); Pop: reversely move all from stack1 to stack2. For every n pops, only the first takes O(N), the rest take O(1) each.\n### Code\n```\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    \n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n### Complexity\n* push: O(1)\n* pop: amortized O(1)\n* empty(): O(1)\n* peek(): If use another variable to keep track of the front: O(1); Otherwise amortized O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091125806","body":"### Idea\nStraight forward. Get size, k%size = offset. Then just find the new head by moving size - offset.\n### Code\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        int size = 1;\n        ListNode tail;\n        for (tail = head; tail.next != null; tail = tail.next) {\n            size++;\n        }\n        int move = k % size;\n        if (move == 0) {\n            return head;\n        }\n        ListNode newTail = head;\n        for (int i = 0; i < size - move - 1; i ++) {\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        tail.next = head;\n        return newHead;\n    }\n}\n```\n### Complexity\nTime: O(N); Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092333435","body":"```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        ListNode pre = newHead;\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode toSwap = cur.next;\n            cur.next = toSwap.next;\n            pre.next = toSwap;\n            toSwap.next = cur;\n            pre = cur;\n            cur = cur.next;\n        }\n        return newHead;\n    }\n}\n```\n### Complexity\n* Time: O(N)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093707393","body":"### Idea\nRecursive. For every list, use fast-slow pointers to find the mid one as root. Do the same for left half of the list; Do the same for the right half.\n### Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode preMid = null;\n        while (fast != null && fast.next != null) {\n            fast = fast.next;\n            fast = fast.next;\n            preMid = slow;\n            slow = slow.next;\n        }\n        preMid.next = null;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```\n### Complexity\nTime: O(NlogN)\nSpace: O(logN) for recursion.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094148637","body":"### Idea\nUse 2 pointers. First go through both lists to know the size difference. Then move the pointer for the longer list so that 2 pointers are at the same start. Then move 2 pointers together until they are pointing to the same node.\n### Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int sizeA = 0;\n        int sizeB = 0;\n        ListNode pA = headA;\n        ListNode pB = headB;\n        while (pA != null) {\n            pA = pA.next;\n            sizeA++;\n        }\n        while (pB != null) {\n            pB = pB.next;\n            sizeB++;\n        }\n        pA = headA;\n        pB = headB;\n        for (int i = 0; i < Math.abs(sizeA - sizeB); i++) {\n            if (sizeA > sizeB) {\n                pA = pA.next;\n            } else {\n                pB = pB.next;\n            }\n        }\n        while (pA != null && pA != pB) {\n            pA = pA.next;\n            pB = pB.next;\n        }\n        return pA;\n    }\n}\n```\n### Complexity\n* Time: O(M+N)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094423283","body":"### Idea\n1. Fast and Slow will meet in circle: If when slow enters circle, fast is K past the circle entrance, it means fast is behind slow by C - K, when C is circle length. Then after diff(distance) / diff(speed) = (C - K) / (2-1) = C-K iterations, fast will catch slow. Thus, they will meet within 1 circle after slow enters circle, at C-K past entrance.\n2. a+n*C+b = 2(a+b) => a+b = n*C. Therefore, when fast and slow meet at b past circle entrance, fast continues to go a, it will be a+b = n*C, which means fast will be at the circle entrance. At the same time slow goes a from head, it will also be at circle entrance.\n### Code\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        if (fast != slow) {\n            return null;\n        }\n        slow = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n### Complexity\n* Time: O(N)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096355961","body":"### Idea\n自定义双向Node. Node包含key和value。Map是key->Node. 记得put的时候如果key已经存在，也要把该node移到最后。\n\n定义dummy的head和tail节点，会避免null issue。\n### Code\n```\nclass LRUCache {\n\n    Node head;\n    Node tail;\n    Map<Integer, Node> map;\n    int size;\n    int capacity;\n    \n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node curNode = map.get(key);\n            moveToTail(curNode);\n            return curNode.val;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (!map.containsKey(key)) {\n            size++;\n        }\n        Node curNode = map.getOrDefault(key, new Node(key, value));\n        curNode.val = value;\n        map.put(key, curNode);\n        moveToTail(curNode);\n        \n        if (size > capacity) {\n            Node evict = head.next;\n            head.next = evict.next;\n            evict.next.pre = head;\n            map.remove(evict.key);\n            size--;\n        }  \n        // for (Map.Entry<Integer, Node> e : map.entrySet()) {\n        //     System.out.print(e.getKey()+\" \"+e.getValue().val+\"; \");\n        // }\n        // for (Node p = head; p != null; p = p.next) {\n        //     System.out.print(p.key+\"|\"+p.val+\" \");\n        // }\n        // System.out.println();\n    }\n    \n    private void moveToTail(Node curNode) {\n        if (curNode.next != null) {\n            curNode.pre.next = curNode.next;\n            curNode.next.pre = curNode.pre;\n        }\n        curNode.next = tail;\n        curNode.pre = tail.pre;\n        tail.pre.next = curNode;\n        tail.pre = curNode;\n    }\n    \n    class Node {\n        Node next;\n        Node pre;\n        int key;\n        int val;\n        public Node(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n        public String toString() {\n            return key+ \" \"+val;\n        }\n    }\n}\n```\n### Complexity\nTime: O(1); Space: O(N).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097570555","body":"### Idea\n1. recursion\n2. bfs\n### Code\n1.\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n```\n2.\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        int depth = 0;\n        q.add(root);\n        while (!q.isEmpty()) {\n            depth++;\n            int curLevel = q.size();\n            for (int i = 0; i < curLevel; i++) {\n                TreeNode cur = q.poll();\n                if (cur.left != null) {\n                    q.add(cur.left);\n                }\n                if (cur.right != null) {\n                    q.add(cur.right);\n                }\n            }\n        }\n        return depth;\n    }\n}\n```\n### Complexity\nTime: O(N). Space: best O(logn), worst O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098630173","body":"### Idea\nRecursion\n### Code\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p != null && q != null && p.val == q.val) {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        return false;\n    }\n}\n```\n### Complexity\n* TIme: O(N)\n* Space: best O(logN), worst O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100809411","body":"### Idea\nBFS. Both encoding and decoding need a queue of nodes.\n\n### Code\n```\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        Queue<TreeNode> q = new LinkedList<>();\n        if (root == null) {\n            return \"null\";\n        }\n        StringBuilder sb = new StringBuilder();\n        q.add(root);\n        sb.append(root.val);\n        while (!q.isEmpty()) {\n            int curLevelSize = q.size();\n            for (int i = 0; i < curLevelSize; i++) {\n                TreeNode cur = q.poll();\n                sb.append(\",\");\n                if (cur.left == null) {\n                    sb.append(\"null\");\n                } else {\n                    sb.append(cur.left.val);\n                    q.add(cur.left);\n                }\n                sb.append(\",\");\n                if (cur.right == null) {\n                    sb.append(\"null\");\n                } else {\n                    sb.append(cur.right.val);\n                    q.add(cur.right);\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] arr = data.split(\",\");\n        if (arr[0].equals(\"null\")) {\n            return null;\n        }\n        Queue<TreeNode> q = new LinkedList<>();\n        TreeNode root = new TreeNode(Integer.valueOf(arr[0]));\n        q.add(root);\n        int index = 1;\n        while (!q.isEmpty()) {\n            int curLevelSize = q.size();\n            for (int i = 0; i < curLevelSize; i++) {\n                TreeNode cur = q.poll();\n                if (arr[index].equals(\"null\")) {\n                    cur.left = null;\n                } else {\n                    TreeNode left = new TreeNode(Integer.valueOf(arr[index]));\n                    cur.left = left;\n                    q.add(left);\n                }\n                index++;\n                if (arr[index].equals(\"null\")) {\n                    cur.right = null;\n                } else {\n                    TreeNode right = new TreeNode(Integer.valueOf(arr[index]));\n                    cur.right = right;\n                    q.add(right);\n                }\n                index++;\n            }\n        }\n        return root;\n    }\n}\n```\n### Complexity\nTime: O(N), Space: O(N).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100971588","body":"### Idea\nKeep global TreeMap<columnIndex, TreeMap<rowIndex, PriorityQueue<Integer>>. DFS to traverse and add to map. Do a final pass to add to result list.\n### Code\n```\nclass Solution {\n    Map<Integer, Map<Integer, List<Integer>>> map = new TreeMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        tranverse(root, 0, 0);\n        List<List<Integer>> results = new ArrayList<>();\n        for (int col : map.keySet()) {\n            Map<Integer, List<Integer>> curColMap = map.get(col);\n            List<Integer> newList = new ArrayList<>();\n            for (int row : curColMap.keySet()) {\n                Collections.sort(curColMap.get(row));\n                newList.addAll(curColMap.get(row));\n            }\n            results.add(newList);\n        }\n        return results;\n    }\n    private void tranverse(TreeNode root, int column, int row) {\n        if (root == null) {\n            return;\n        }\n        map.putIfAbsent(column, new TreeMap<>());\n        Map<Integer, List<Integer>> curCol = map.get(column);\n        curCol.putIfAbsent(row, new ArrayList<>());\n        curCol.get(row).add(root.val);\n        tranverse(root.left, column - 1, row + 1);\n        tranverse(root.right, column + 1, row + 1);\n    }\n}\n```\n### Complexity\n* Time: N*[logk + logm + log(N/(k*m))] = NlogN, k is the number of columns, m the number of rows, therefore N/(k*m) is the average size of every cell. If we use a global var minColIndex, maxColIndex, then there will be no logk, and time will be N*[log(N/k)].\n* Space: N + m (递归深度，worst N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103511920","body":"### Idea\n* 用PriorityQueue，排序基于map里的freq从小到大，每当size>k时把最小的poll。先遍历nums全加到map里，再遍历map往pq里加。\n### Code\n```\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>((n1, n2) -> \n                                                      map.get(n1) - map.get(n2));\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        map.forEach((num, freq) -> {\n            pq.offer(num);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        });\n        \n        int[] result = new int[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = pq.poll();\n        }\n        return result;\n    }\n}\n```\n### Complexity\n* Time: nlogk\n* Space: n+k\n* 用空间换时间：bucket[nums.length+1]. 每个slot代表一个freq。每个slot是一个list of 这个freq的nums。time: n; space: n+n.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104666585","body":"### Idea\nFor every point, have a map<Distance, Count>.  Count -> A(Count, 2) = count * (count - 1).\n\n### Code\n```\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int result = 0;\n        for (int i = 0; i < points.length; i++) {\n            Map<Integer, Integer> distToCount = new HashMap<>();\n            for (int j = 0; j < points.length; j++) {\n                int xDiff = points[i][0] - points[j][0];\n                int yDiff = points[i][1] - points[j][1];\n                int dist = xDiff * xDiff + yDiff * yDiff;\n                int count = distToCount.getOrDefault(dist, 0);\n                distToCount.put(dist, count + 1);\n            }\n            for (int count : distToCount.values()) {\n                if (count > 1) {\n                    result += count * (count - 1);\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n### Complexity\n* Time: n2\n* Space: n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107922564","body":"```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (head != null && head.next != null) {\n            head = head.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111953509","body":"### Idea\nDeque, poll smaller numbers from rear. Make it a decreasing queue. Deque should store index, because can get number from the nums[] with the index.\n### Code\n```\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> q = new LinkedList<>();\n        Deque<Integer> index = new LinkedList<>();\n        int i = 0;\n        int[] max = new int[nums.length - k + 1];\n        for (; i < k; i++) {\n            while (!q.isEmpty() && q.peekLast() <= nums[i]) {\n                q.pollLast();\n                index.pollLast();\n            }\n            q.offerLast(nums[i]);\n            index.offerLast(i);\n        }\n        while (i < nums.length) {\n            max[i - k] = q.peekFirst();\n            if (index.peekFirst() <= i - k) {\n                index.pollFirst();\n                q.pollFirst();\n            }\n            while (!q.isEmpty() && q.peekLast() <= nums[i]) {\n                q.pollLast();\n                index.pollLast();\n            }\n            q.offerLast(nums[i]);\n            index.offerLast(i);\n            i++;\n        }\n        max[nums.length - k] = q.poll();\n        return max;\n    }\n}\n```\n### Complexity\nTime: O(n). Space: O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085443568","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\r\n\r\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\r\n\r\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：num = [1,2,0,0], k = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：num = [2,7,4], k = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：num = [2,1,5], k = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum 不包含任何前导零，除了零本身\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n数组 取模 取余 列表相加\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  见代码\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        # 从低位到高位进行加法\r\n        # 判断是否需要进位\r\n        # 如果num比k大 就可以结束了\r\n        for i in range(len(num)-1,-1,-1):\r\n            num[i],carry  = (num[i] + k%10 + carry)%10,(num[i] + k%10 + carry)//10\r\n            k //= 10\r\n        # 如果num比k小 考虑继续进位\r\n        high = []\r\n        k = k + carry\r\n        if k:\r\n            high = [int(i) for i in str(k)]\r\n        return high + num\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086516918","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n窗口的左右边界\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n将字符c作为窗口的边界 每次记录窗口的左右边界 然后开始计算距离\r\n\r\n## 关键点\r\n\r\n-  如何确定第一个窗口？\\\r\n  由于第一个窗口可能不存在左边界，因此先从索引位置0开始判断左边界是否存在，如果不存在可以将左边界置为n，那么第一个窗口可以不考虑左边界\r\n- 如何更换窗口？\\\r\n  随着对字符串的遍历，一定会遍历到窗口右边界，那么新窗口的左边界就是当前索引i\r\n- 如何使用字符串查找函数？ \\\r\n  s.find(c,beg=i,end=n)，该函数会从字符串s中查找字符c，然后beg表示开始的索引，end表示结束的索引（左闭右开）；如果找不到返回-1\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \"\"\"寻找距离最近的字符的长度 \r\n\r\n        Args:\r\n            s(str):字符串\r\n            c(str):字符\r\n        \r\n        Returns:\r\n            ans(List[int]):返回结果列表\r\n\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n        \r\n        # 寻找左边界 如果没有左边界 那么直接将左边界设置为字符串长度\r\n        l = 0 if s[0] == c else n\r\n        # 从索引位置1开始搜索字符c\r\n        r = s.find(c,1) \r\n\r\n        for i in range(n):\r\n            # 取距离两个边界的最小距离\r\n            ans[i] = min(abs(i-l),abs(r-i))\r\n            # 考虑移动边界的问题\r\n            if i == r:\r\n                l = i\r\n                r = s.find(c,i+1)\r\n        return ans\r\n        \r\n\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086815684","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n设置三个类的成员变量，分别存储栈，栈的最大长度以及栈的当前长度，然后实现push、pop以及inc操作\r\n\r\n## 关键点\r\n\r\n-  用到列表的append函数，向后添加元素\r\n-  用到列表的pop()函数，可以返回列表中对应索引的元素\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = maxSize\r\n        self.len = len(self.stack)\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.size:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len > 0:\r\n            self.len -= 1\r\n            return self.stack.pop(-1)\r\n        else:\r\n            return -1 \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.len < k:\r\n            self.stack = [i+val for i in self.stack]\r\n        else:\r\n            self.stack[:k] = [i+val for i in self.stack[:k]]\r\n        \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$ O(1) $\r\n- 空间复杂度：$ O(n) $ \r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087051498","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= s.length <= 30\r\ns 由小写英文字母、数字和方括号 '[]' 组成\r\ns 保证是一个 有效 的输入。\r\ns 中所有整数的取值范围为 [1, 300] \r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n解码时会遇到四种情况，'[',']','数字','字符'  \r\n遇到右括号就去匹配左括号   \r\n匹配左括号过程中，就需要维护两个变量，一个是重复字符串，另一个是重复次数\r\n## 关键点\r\n\r\n-  注意判断重复的字符串以及重复次数的条件\r\n- 得到重复子字符串后，可以加入栈，然后继续处理后面的']'\r\n- ''.join() 列表拼接成字符串的用法\r\n- list[-1].isnumeric()判断当前元素是否是数字类型\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \"\"\"解码字符串\r\n        Args:\r\n            s(str):编码后的字符串\r\n        Returns:\r\n            res(str):解码后的字符串\r\n        \"\"\"\r\n        stack = []\r\n        for char in s:\r\n            if char == ']':\r\n                # 进行括号匹配\r\n                reapetStr = ''\r\n                reapetCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    reapetStr = stack.pop() + reapetStr\r\n                # 找到左括号\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    reapetCount = stack.pop() + reapetCount\r\n                # 匹配好字符串后 重新入栈\r\n                stack.append(reapetStr * int(reapetCount))\r\n            else:\r\n                stack.append(char)\r\n        return ''.join(stack)\r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n## 思路\r\n\r\n采用递归的解法  \r\n遇到数字开始计算重复次数；  \r\n遇到左括号开始新的递归；  \r\n遇到右括号开始结束一次递归；  \r\n遇到字符添加在重复字符子串  \r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \"\"\"解码字符串\r\n        Args:\r\n            s(str):编码后的字符串\r\n        Returns:\r\n            res(str):解码后的字符串\r\n        \"\"\"\r\n        def dfs(start):\r\n            reapteStr,reapteCount = '',''\r\n            while start < len(s):\r\n                if s[start].isnumeric():\r\n                    reapteCount += s[start]\r\n                elif s[start] == '[':\r\n                    start, t_str = dfs(start+1)\r\n                    reapteStr += t_str * int(reapteCount)\r\n                    reapteCount = ''\r\n                elif s[start] == ']':\r\n                    return start, reapteStr\r\n                else:\r\n                    reapteStr += s[start]\r\n                start += 1\r\n            return reapteStr\r\n        return dfs(0)\r\n        \r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088273433","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n说明：\r\n\r\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n```\r\n\r\n\r\n\r\n## 思路\r\n由于栈是先进后出的特性，一个栈无法实现队列操作，因此需要两个栈。  \r\n其中一个栈用于进入队列，栈依然保持了入队的顺序  \r\n出队时，如果出栈为空，将入栈的元素反向放入出栈；如果出栈不为空，输入出栈的栈顶元素  \r\n判空条件就是两个栈同时为空  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n    \"\"\"\r\n    使用两个栈来实现队列的操作，将两个栈分为输入栈和输出栈\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None \r\n        if self.outstack:\r\n            return self.outstack.pop()\r\n        else:\r\n            self.outstack = self.instack[::-1]\r\n            self.instack = []\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            return self.instack[0]\r\n        else:\r\n            return self.outstack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.instack and not self.outstack:\r\n            return True\r\n        return False \r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089814987","body":"\r\n## 前置知识\r\n\r\n- 单调栈\r\n\r\n## 思路\r\n采用单调栈存储每个块的最大值，如果新的块的最小值小于栈中最大值，那么就出栈进行块的合并\r\n\r\n## 关键点\r\n\r\n-  单调栈的使用\r\n- 块的合并\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \"\"\"\r\n        使用单调栈来完成，栈中每个元素对应每个块的最大值，找到最大值的个数，就找到最多的块的个数\r\n\r\n        Args:\r\n            arr(List[int]):数组\r\n        Returns:\r\n            n(int):单调栈长度\r\n        \"\"\"\r\n        stack =[]\r\n        for element in arr:\r\n            if not stack:\r\n                stack.append(element)\r\n                continue\r\n            # 首先判断这个元素时候可以入栈\r\n            if stack and stack[-1] <= element:\r\n                stack.append(element)\r\n            else:\r\n                cur = stack[-1] # 需要保留栈中的最大值，然后才能合并块\r\n                while stack and stack[-1] > element: stack.pop()\r\n                stack.append(cur)\r\n        return len(stack)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(k)$ \r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091136329","body":"## 思路\r\n  如果k<n，只要找到倒数第k+1个元素(顺着数n-k)，然后从这里断开成两个链表，并将前面的链表拼接到后面的链表；  \r\n  如果k==n，那么不需要改变  \r\n  如果k>n,k=k%n，继续第一种情况  \r\n## 关键点\r\n\r\n-  链表遍历\r\n- 虚拟头\r\n- 链表拼接\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        \"\"\"旋转链表\r\n        链表中最后一个元素向链表头移动，链表其他元素向后移动\r\n\r\n        Args:\r\n            head(Optional[ListNode]):链表头\r\n            k(int):移动k个位置\r\n        \r\n        Returns:\r\n            new_head(Optional[ListNonde]):新的链表头\r\n        \"\"\"\r\n        n,pre = 0,head\r\n        while pre: n,pre = n+1,pre.next\r\n        # 边界判断\r\n        if not n:\r\n            return \r\n        k = k%n\r\n        if not k:\r\n            return head\r\n        else:\r\n            dummy_node = ListNode(-1,head)\r\n            for _ in range(n-k):\r\n                dummy_node = dummy_node.next\r\n            new_head = start = dummy_node.next\r\n            dummy_node.next = None\r\n            while start:\r\n                if start.next:\r\n                    start = start.next\r\n                else:\r\n                    break\r\n            start.next = head\r\n            return new_head\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092350120","body":"## 思路\r\n\r\n如果链表中节点大于等于2，维护两个变量，pre(ListNode)指向交换后链表的尾部，cur(ListNode)指向未交换链表头部;  \r\n那么  \r\npre.next = cur.next  \r\ncur.next = cur.next.next  \r\ncur.next.next = cur  \r\n## 关键点\r\n\r\n-  虚拟头\r\n- 节点修改\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        两两交换链表中相邻的节点\r\n\r\n        Args:\r\n            head(ListNode):链表头节点\r\n        \r\n        Returns:\r\n            new_head(ListNode):虚拟链表头节点\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        pre,cur = ListNode(-1,head),head\r\n        new_head = pre\r\n        while cur:\r\n            if cur.next:\r\n                pre.next = cur.next\r\n                if cur.next.next:\r\n                    next = cur.next\r\n                    cur.next = next.next\r\n                    next.next = cur\r\n                    pre = cur \r\n                    cur = cur.next\r\n                else:\r\n                    cur.next.next = cur \r\n                    cur.next = None\r\n                    cur = cur.next \r\n            else:\r\n                pre.next = cur\r\n                cur = cur.next\r\n        return new_head.next \r\n            \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093830302","body":"## 前置知识\r\n\r\n- 快慢指针\r\n- 二叉搜索树，左子树小于根节点小于右子树，而且是平衡的\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n使用快慢指针，找到链表的中点，那么这就是树的根节点；    \r\n该节点左边就是左子树，对于左子树，再使用快慢指针，就能发现左子树根节点；    \r\n右子树同理；    \r\n\r\n## 关键点\r\n\r\n- 快慢指针，三个指针pre,slow,fast\r\n- 树的递归\r\n- 边界判断\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \"\"\"\r\n        将有序链表变换为二叉搜索树\r\n\r\n        Args:\r\n            head(ListNode):头节点\r\n        Returns:\r\n            new_head(ListNode):返回新的头节点\r\n        \"\"\"\r\n        \"\"\"\r\n        使用快慢指针，找到链表的中点，那么这就是树的根节点；  \r\n        该节点左边就是左子树，对于左子树，再使用快慢指针，就能发现左子树根节点；  \r\n        右子树同理；  \r\n        \"\"\"\r\n        if not head:\r\n            return head\r\n        pre,slow,fast = None,head,head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n## 思路\r\n因为在链表中，找到中间节点的时间复杂度为O(n),如果换成数组，就可以在O(1)时间复杂度内找到中点；  \r\n这也是一种空间换时间的方法  \r\n\r\n\r\n## 关键点\r\n\r\n-  递归函数调用时，边界要保持一直，左闭右开、左闭右闭、左开右闭\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \"\"\"\r\n        将有序链表变换为二叉搜索树\r\n\r\n        Args:\r\n            head(ListNode):头节点\r\n        Returns:\r\n            new_head(ListNode):返回新的头节点\r\n        \"\"\"\r\n        def dfs(nodeList,l,r):\r\n            # 这里设计一个递归的边界问题，\r\n            # 例如：这里规定的区间是左闭右开的，那么l一定要小于r；\r\n            # 而且每次递归调用时，都是遵循左闭右开的原则\r\n            if l>=r:\r\n                return \r\n            mid = int((r+l)/2)\r\n            root = TreeNode(nodeList[mid])\r\n            root.left = dfs(nodeList,l,mid)\r\n            root.right =dfs(nodeList,mid+1,r)\r\n            return root \r\n        nodeList = []\r\n        while head:\r\n            nodeList.append(head.val)\r\n            head = head.next\r\n        return dfs(nodeList,0,len(nodeList))\r\n        \r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(nlogn)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094162902","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\r\n\r\n图示两个链表在节点 c1 开始相交：\r\n\r\n题目数据 保证 整个链式结构中不存在环。\r\n\r\n注意，函数返回结果后，链表必须 保持其原始结构 。\r\n\r\n自定义评测：\r\n\r\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\r\n\r\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\r\nlistA - 第一个链表\r\nlistB - 第二个链表\r\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\r\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\r\n\r\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Intersected at '8'\r\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\r\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n\r\n\r\n示例 2：\r\n\r\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\n输出：Intersected at '2'\r\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\r\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r\n\r\n\r\n示例 3：\r\n\r\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\n输出：null\r\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\r\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r\n这两个链表不相交，因此返回 null 。\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\nlistA 中节点数目为 m\r\nlistB 中节点数目为 n\r\n1 <= m, n <= 3 * 104\r\n1 <= Node.val <= 105\r\n0 <= skipA <= m\r\n0 <= skipB <= n\r\n如果 listA 和 listB 没有交点，intersectVal 为 0\r\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\r\n\r\n \r\n\r\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        \"\"\"\r\n        通过两个链表的头节点，判断两个链表是否相交\r\n\r\n        Args:\r\n            headA(ListNode):链表A头节点\r\n            headB(ListNode):链表B头节点\r\n        \r\n        Returns:\r\n            overlap(ListNode):相交的初始节点\r\n            或者 null\r\n        \"\"\"\r\n        # 将链表转为列表，然后从列表逆序一一比较\r\n        nodeListA ,nodeListB = [],[]\r\n        while headA:\r\n            nodeListA.append(headA)\r\n            headA = headA.next \r\n        while headB:\r\n            nodeListB.append(headB)\r\n            headB = headB.next\r\n        overlap = None\r\n        for nodeA,nodeB in zip(nodeListA[::-1],nodeListB[::-1]):\r\n            if nodeA == nodeB:\r\n                overlap = nodeA\r\n            else:\r\n                break \r\n        return overlap\r\n            \r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n## 前置知识\r\n\r\n- 双指针\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n如果两个链表相交，那么可以将整个链表看成三部分，将链表从相交节点分开  \r\n链表A的长度就是A+C  \r\n链表B的长度就是B+C  \r\n采用双指针的方法，两个指针分别指向两个链表头，然后分别以相同的速度向后遍历，直到遍历到链表尾部；  \r\n如果链表A上指针遍历到尾部后，开始重置到链表B的头节点，同理链表B上的指针也是如此；  \r\n那么当这两个指针首次相遇时，它们的行程就是A+B+C  \r\n\r\n## 关键点\r\n\r\n-  双指针处理相遇问题\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        \"\"\"\r\n        通过两个链表的头节点，判断两个链表是否相交\r\n\r\n        Args:\r\n            headA(ListNode):链表A头节点\r\n            headB(ListNode):链表B头节点\r\n        \r\n        Returns:\r\n            overlap(ListNode):相交的初始节点\r\n            或者 null\r\n        \"\"\"\r\n        nodeA,nodeB = headA, headB\r\n        for _ in range(2):\r\n            while nodeA and nodeB:\r\n                nodeA = nodeA.next\r\n                nodeB = nodeB.next\r\n            if not nodeA:\r\n                nodeA = headB\r\n            elif not nodeB:\r\n                nodeB = headA\r\n        while nodeA!= nodeB:\r\n            nodeA,nodeB = nodeA.next,nodeB.next\r\n        return nodeA if nodeA == nodeB else None \r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094476663","body":"## 前置知识\r\n\r\n- 链表的遍历\r\n- 快慢指针\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n如果链表有环，假设环前长度为a，环的长度为b；  \r\n那么采用快慢指针，就会存在以下关系式子：  \r\nfast = 2 * slow;  slow = nb;如果两个指针相遇一定是在环内相遇，而且是fast指针领先n圈  \r\n相遇后，再将fast指针置为头节点，和slow指针同时移动a，那么两个指针就会相遇，相遇点就是入环口(slow = a + nb)    \r\n或者说如果两个指针同时移动，再次相遇时，就是入环口\r\n\r\n\r\n## 关键点\r\n\r\n-  快慢指针\r\n-  链表中的环\r\n-  判断环的方法\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        判断是否环形链表， 如果是，则返回开始入环的第一个节点；如果不是，则返回None\r\n\r\n        Args:\r\n            head(ListNode):头节点\r\n        Returns:\r\n            loop_node(ListNode):入环第一个节点\r\n            或者None\r\n        \"\"\"\r\n        # 边界判断，如果只有一个节点，那么就是无环的\r\n        if not head or not head.next:\r\n            return None \r\n        # 由于存在整个链表就是一个环的时候 可以采用一个虚拟头\r\n        fast = slow = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                break\r\n        if not fast or not fast.next:\r\n            return None \r\n        fast = head\r\n        while fast!=slow:\r\n            fast,slow = fast.next,slow.next\r\n        return fast if fast==slow else None \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095867209","body":"## 前置知识\r\n\r\n-  双向链表\r\n-  哈希表\r\n\r\n\r\n## 思路\r\n\r\nLRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。  \r\n\r\n- 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。  \r\n\r\n- 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。  \r\n\r\n\r\n## 关键点\r\n\r\n- 定义双向链表类\r\n- 使用虚拟头、虚拟尾\r\n- 使用哈希表\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass DLinkNode:\r\n    def __init__(self,key=0,value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None \r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        # 添加虚拟头部和尾部 可以直接定位到头尾节点\r\n        self.head = DLinkNode()\r\n        self.tail = DLinkNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1 \r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = DLinkNode(key,value)\r\n            self.cache[key] = node \r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size-=1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value \r\n            self.moveToHead(node)\r\n\r\n    def addToHead(self,node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node \r\n    \r\n    def removeNode(self,node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev \r\n    \r\n    def moveToHead(self,node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node \r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097467627","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        \"\"\"\r\n        找出二叉树的最大深度\r\n\r\n        Args:\r\n            root(Optiona[TreeNode]):根节点\r\n        \r\n        Returns:\r\n            depth(int):树的深度\r\n        \"\"\"\r\n        \"\"\"\r\n        采用迭代的方法，如果知道左子树深度、左子树深度，那么当前树的深度就是max(左子树深度，右子树深度)+1\r\n        \"\"\"\r\n        if not root:\r\n            return 0\r\n        left_depth = self.maxDepth(root.left)\r\n        right_depth = self.maxDepth(root.right)\r\n        return max(left_depth,right_depth)+1\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098652555","body":"\r\n## 前置知识\r\n\r\n- 树的递归\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n从根节点同时迭代两颗树\r\n\r\n\r\n## 关键点\r\n\r\n-  判断两个节点相等条件\r\n- 递归的用法\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        \"\"\"\r\n        给定两颗二叉树的根节点p和q,检验这两课树是否相同（结构相同，值相同）\r\n\r\n        Args:\r\n            p(TreeNode):根节点1\r\n            q(TreeNode):根节点2\r\n        Returns:\r\n            True/False\r\n        \"\"\"\r\n        # 两个节点都为空\r\n        if not p and not q:\r\n            return True\r\n        # 其中一个节点为空 \r\n        if not p or not q:\r\n            return False \r\n        # 根节点、左右子树全部相等 \r\n        return q.val == p.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n## 思路\r\n前序遍历和中序遍历可以确定一棵树，但是注意需要保持树的结构\r\n## 关键点\r\n\r\n-  对于空节点，也需要加入遍历列表中\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def PreOrder(self,root:TreeNode)->List:\r\n        PreList = []\r\n        def dfs(root):\r\n\r\n            \"\"\"\r\n            实现前序遍历\r\n            \"\"\"\r\n            if not root:\r\n                PreList.append(' ')\r\n                return root \r\n            PreList.append(root.val) \r\n            dfs(root.left)\r\n            dfs(root.right)\r\n        dfs(root)\r\n        return PreList\r\n\r\n\r\n    def InOrder(self, root:TreeNode)->List:\r\n        InList = []\r\n        def dfs(root):\r\n            \"\"\"\r\n            实现中序遍历\r\n            \"\"\"\r\n            if not root:\r\n                InList.append(' ')\r\n                return root \r\n            dfs(root.left)\r\n            InList.append(root.val) \r\n            dfs(root.right)  \r\n        dfs(root)\r\n        return InList    \r\n\r\n\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        \"\"\"\r\n        给定两颗二叉树的根节点p和q,检验这两课树是否相同（结构相同，值相同）\r\n\r\n        Args:\r\n            p(TreeNode):根节点1\r\n            q(TreeNode):根节点2\r\n        Returns:\r\n            True/False\r\n        \"\"\"\r\n        \"\"\"\r\n        前序和中序确定一棵树\r\n        \"\"\"\r\n        if self.PreOrder(p) == self.PreOrder(q) and self.InOrder(p) == self.InOrder(q):\r\n            return True\r\n        else:\r\n            return False\r\n    \r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099781199","body":"## 前置知识\r\n\r\n- DFS\r\n- BFS\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n 采用前序遍历的方法，根左右，只要到了叶子节点就生成一个数字\r\n## 关键点\r\n\r\n- 递归的基础边界条件 not root,返回值根据题目来定 可以是None或者是0\r\n- 根据题目的思想来定条件 not root.left and not root.right\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        \"\"\"\r\n        求根节点到叶子节点数字之和\r\n        \"\"\"\r\n        def dfs(root:TreeNode,tmp:int):\r\n            if not root:\r\n                return 0\r\n            if not root.left and not root.right: return tmp*10 + root.val\r\n            return dfs(root.left,tmp*10+root.val) + dfs(root.right,tmp*10+root.val)\r\n        return dfs(root,0)\r\n         \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n## 思路\r\n层次遍历，直到叶子节点开始计算最后结果\r\n\r\n## 关键点\r\n\r\n-  队列的使用\r\n- res的相交条件\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        res = 0 \r\n        q = deque()\r\n        q.append((root,0))\r\n        while q:\r\n            node,value = q.popleft()\r\n            if node.left:\r\n                q.append((node.left,value*10+node.val))\r\n            if node.right:\r\n                q.append((node.right,value*10+node.val))\r\n            if not node.left and not node.right:\r\n                res += value*10 + node.val\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100588156","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        \"\"\"\r\n        给定一个二叉树的根节点root，找出该二叉树最底层最左边节点的值\r\n        \"\"\"\r\n        \"\"\"\r\n        采用层次遍历，然后选择最后一层的最左边的一个\r\n        \"\"\"\r\n        if not root:\r\n            return \r\n        q = deque()\r\n        q.append((root,0))\r\n        max_level = 0\r\n        value = root.val\r\n        while q:\r\n            node,level = q.popleft()\r\n            if not node.left and not node.right:\r\n                if max_level < level:\r\n                    max_level = level\r\n                    value = node.val\r\n            if node.left:\r\n                q.append((node.left,level+1))\r\n            if node.right:\r\n                q.append((node.right,level+1))\r\n        return value\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100795710","body":"## 思路\r\n将二叉树视为完全二叉树，将空节点处理一下\r\n## 关键点\r\n\r\n-  序列化时，前序遍历如何处理空节点\r\n- 反序列化时，前序遍历的边界条件（超出nodes索引，当前节点为空）；如何找到当前节点的左子树和右子树，脑海中需要脑补出前序遍历的路径，斜着一条条的遍历，从左上到右下。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        def preoder(root):\r\n            if not root:\r\n                return 'null,'\r\n            return str(root.val)+',' + preoder(root.left) + preoder(root.right)\r\n        print(preoder(root)[:-1])\r\n        return preoder(root)[:-1]\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        nodes = data.split(',')\r\n\r\n        def preoder(i):\r\n            if i >= len(nodes) or nodes[i] == 'null':\r\n                return i,None\r\n            root = TreeNode(nodes[i])\r\n            j,root.left = preoder(i+1)\r\n            k,root.right = preoder(j+1)\r\n            return k,root\r\n        return preoder(0)[1]\r\n\r\n        \r\n\r\n        \r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n## 思路\r\n采用层次遍历的方法，将二叉树视为完全二叉树保存下来\r\n\r\n## 关键点\r\n\r\n-  序列化时，对空节点的编码\r\n- 反序列化时，对如何一起移动当前节点以及找到它的左右子树 (i+=2)\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        ans = ''\r\n        queue = [root]\r\n        while queue:\r\n            node = queue.pop(0)\r\n            if node :\r\n                ans += str(node.val) + ','\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                ans += '#,'\r\n        # print(ans[:-1])\r\n        return ans[:-1]\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data =='#':return None\r\n        nodes = data.split(',')\r\n        root = TreeNode(nodes[0])\r\n        queue = [root]\r\n        i = 1\r\n        while i < len(nodes)-1:\r\n            node = queue.pop(0)\r\n            lv = nodes[i]\r\n            rv = nodes[i+1]\r\n            i+=2 \r\n            if lv != '#':\r\n                l = TreeNode(lv)\r\n                node.left = l\r\n                queue.append(l)\r\n            if rv !='#':\r\n                r = TreeNode(rv)\r\n                node.right = r \r\n                queue.append(r)\r\n        return root \r\n\r\n\r\n        \r\n\r\n        \r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101023929","body":"## 前置知识\r\n\r\n- 树的遍历\r\n- 哈希表的哈希表的定义 `seen = collections.defaultdict(lambda: collections.defaultdict(list)); seen[x][y] = List`\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n- 首先使用二位哈希表，将行列信息以及val值都存储下来\r\n- 然后依次对列、行进行遍历，将每列的值按照层级关系、值大小关系进行排序\r\n\r\n## 关键点\r\n\r\n-  哈希表的哈希表的定义\r\n-  逐层排序\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        \"\"\"\r\n        二叉树的垂序遍历，从左到右，从上到下进行输出（上下位置相同时，对值进行排序）\r\n        \"\"\"\r\n        seen = collections.defaultdict(lambda : collections.defaultdict(list))\r\n        def dfs(root,x,y):\r\n            if not root:\r\n                return \r\n            seen[x][y].append(root.val)\r\n            dfs(root.left,x-1,y+1)\r\n            dfs(root.right,x+1,y+1)\r\n        \r\n        dfs(root,0,0)\r\n        ans = []\r\n        # 按照前序遍历 将节点的行列信息以及val值都存储在一个二维的哈希表中\r\n        # 首先按照列来排序\r\n        for x in sorted(seen):\r\n            level = []\r\n            # 再按照行来排序\r\n            for y in sorted(seen[x]):\r\n                level += sorted(seen[x][y])\r\n            ans.append(level)\r\n        return ans \r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101929469","body":"## 思路\r\n排序后，使用双指针;然后找到目标值在原来数组中的索引\r\n\r\n## 关键点\r\n\r\n-  双指针\r\n-  list.index()查找对应元素的下标，但是只会查找一个\r\n-  面对两个相同值组成的答案，需要查找到第一个值后，修改值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        \"\"\"\r\n        找出和为目标值的target的那两个整数，返回它们的数组下标(数组中同一个元素在答案中不能重复出现)\r\n        \"\"\"\r\n        i,j = 0,len(nums)-1\r\n        sorted_nums = sorted(nums)\r\n        while i<j:\r\n            sum = sorted_nums[i] + sorted_nums[j]\r\n            if sum < target:\r\n                i += 1\r\n            elif sum > target:\r\n                j -= 1\r\n            else:\r\n                i = nums.index(sorted_nums[i])\r\n                nums[i] = float('inf') # 可以索引到相同值的下一个元素\r\n                return i,nums.index(sorted_nums[j])\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$\r\n\r\n## 思路\r\n使用哈希表\r\n\r\n## 关键点\r\n\r\n-  哈希表\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        \"\"\"\r\n        找出和为目标值的target的那两个整数，返回它们的数组下标(数组中同一个元素在答案中不能重复出现)\r\n        \"\"\"\r\n        hashmap = {}\r\n        for i,num in enumerate(nums):\r\n            if hashmap.get(target-num) is not None:\r\n                return i,hashmap.get(target-num)\r\n            hashmap[num] = i \r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103449605","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        \"\"\"\r\n        返回前k个频率最高的元素\r\n        \"\"\"\r\n        # 方法一 调用Counter\r\n        from collections import Counter \r\n        num_counter = Counter(nums)\r\n        return [ele for ele,_ in num_counter.most_common(k)]\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        \"\"\"\r\n        返回前k个频率最高的元素\r\n        \"\"\"\r\n        # 方法二 使用哈希表\r\n        hashmap = dict()\r\n        for num in nums:\r\n            if num in hashmap:\r\n                hashmap[num] += 1\r\n            else:\r\n                hashmap[num] = 1\r\n        sort_map = sorted(hashmap.items(),key=lambda x:(-x[1],x[0]))\r\n        return [key for key,_ in sort_map][:k]\r\n\r\n\r\n        \r\n\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104649708","body":"## 思路\r\n采用双重循环，第一重循环确定一个点p_i\r\n第二重循环确定第二个点p_j，计算两个点之间的距离dist，将dist作为key，dist数量为value，那么回旋镖数量为value * (value-1)\r\n\r\n\r\n## 关键点\r\n\r\n-  哈希表\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        \"\"\"\r\n        计算回旋镖的数量\r\n        回旋镖定义：元组(i,j,k)，其中点i与点j和点k的距离相等（需要考虑元组顺序）\r\n        \"\"\"\r\n        # 边界判断\r\n        if len(points) < 3:\r\n            return 0\r\n        ans = 0 \r\n        for i in range(len(points)):\r\n            dist_map = collections.defaultdict(int)\r\n            for j in range(len(points)):\r\n                dx = points[i][0]-points[j][0]\r\n                dy = points[i][1]-points[j][1]\r\n                dist = dx*dx + dy*dy\r\n                dist_map[dist] += 1\r\n            for val in dist_map.values():\r\n                ans += val * (val-1)\r\n        return ans \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105953992","body":"## 思路\r\n采用滑动窗口和哈希表\r\n1. 如何使用滑动窗口找到一个无重复子串？\r\n滑动窗口左边界初始化为0，有边界初始化为1，采用set保存字符，然后移动右边界，直到遇到set中存在的字符结束\r\n2. 如何移动滑动窗口？\r\n上面已经找到了一个当前的最大无重复子串，现在去找全局的最大无重复子串；那么就去移动滑动窗口左边界，\r\n由于左边界元素被移除了，那么可以继续向右探索，找到新的最大无重复子串\r\n\r\n## 关键点\r\n\r\n-  哈希表的add方法和remove方法\r\n-  如何移动滑动窗口\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        \"\"\"\r\n        找出不含有重复字符的最长子串的长度\r\n        \"\"\"\r\n        ans = 0\r\n        hashmap = set()\r\n        left = 0\r\n        for right in range(len(s)):\r\n            if s[right] not in hashmap:\r\n                hashmap.add(s[right])\r\n            else:\r\n                ans = max(ans,len(hashmap))\r\n                # 去除最左边的元素\r\n                while True:\r\n                    hashmap.remove(s[left])\r\n                    left += 1\r\n                    if s[right] not in hashmap:\r\n                        hashmap.add(s[right])\r\n                        break\r\n        # 注意全部无重复元素的子串\r\n        return max(ans,len(hashmap)) \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107354561","body":"## 前置知识\r\n\r\n- 滑动窗口\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n1. 找到子串 \r\n  1.1 找到子词\r\n  1.2 确定子词集合==目标words\r\n2. 移动子串\r\n  2.2 比较第一个单词和紧跟在后面的一个单词\r\n3. 移动索引\r\n  3.1 寻找新的子串\r\n## 关键点\r\n\r\n-  寻找并迭代子串\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    import copy \r\n    def Iterative_string(self,s:str,words,start,word_len):\r\n        res = []\r\n        tmp_words = copy.deepcopy(words)\r\n        if start+len(''.join(words)) > len(s):\r\n            return res\r\n        i = start\r\n        while s[start:start+word_len] in tmp_words:\r\n                tmp_words.remove(s[start:start+word_len])\r\n                start += word_len\r\n        if not tmp_words:\r\n            res.append(i)\r\n            while start + word_len <= len(s) and s[start:start+word_len] == s[i:i+word_len]:\r\n                res.append(i)\r\n                i += word_len\r\n                start += word_len\r\n        return res\r\n        \r\n\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        \"\"\"\r\n        串联所有单词的子串\r\n        \"\"\"\r\n        res  = []\r\n        left = 0\r\n        word_len = len(words[0])\r\n        for i in range(len(s)):\r\n            if i+word_len*len(words) <= len(s) and s[i:i+word_len] in words:\r\n                res.extend(self.Iterative_string(s,words,i,word_len))\r\n            else:\r\n                continue\r\n        return list(set(res))\r\n                        \r\n                    \r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n## 思路\r\n思路和上面相似 但是实现时采用了哈希表来确定子串 \r\n## 关键点\r\n\r\n-  对子串进行单词计数，如果出现单词个数和words中单词个数相同，那么任务这个子串是符合条件的\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        allWords = collections.Counter(words)\r\n        wordNum = len(words)\r\n        wordLen = len(words[0])\r\n        res = []\r\n        for i in range(len(s) - wordNum * wordLen + 1):\r\n            subWords = collections.defaultdict(int)\r\n            index = i\r\n            while index < i + wordNum * wordLen:\r\n                curWord = s[index: index + wordLen]\r\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\r\n                    break\r\n                subWords[curWord] += 1\r\n                index += wordLen\r\n            if index == i + wordNum * wordLen:\r\n                res.append(i)\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107848190","body":"```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        \"\"\"\r\n        使用同余定理+前缀和\r\n        两个模 k 余数相同的数字相减，得到的值定可以被 k 整除\r\n        \"\"\"\r\n        total = sum(nums)\r\n        mod = total % k\r\n        if total % k == 0:\r\n            return 0\r\n       # key为0 删除全部数字\r\n        mapping = {0: -1}\r\n        total = 0\r\n        ans = len(nums)\r\n        for i in range(len(nums)):\r\n            total += nums[i]\r\n            curr_mod = total % k\r\n            target = (curr_mod - mod + k) % k\r\n            if target in mapping:\r\n                ans = min(ans, i - mapping[target])\r\n            mapping[curr_mod] = i\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108002900","body":"\r\n## 关键点\r\n\r\n-  快慢指针\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        使用快慢节点 寻找中间结点\r\n        \"\"\"\r\n        slow = fast = head\r\n        while  fast and  fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109208019","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        \"\"\"\r\n        给定一个升序排列的数组nums,原地删除重复出现地元素，是每个元素只出现一次 \r\n        返回删除后数组的新长度\r\n        \"\"\"\r\n        # 由于题目给定的数字是升序的，那么重复出现的元素必然相邻\r\n        # 采用双指针的方法 第一个指针指向非重复数组的下一个位置，另一个指针进行数组遍历\r\n        end = 0\r\n        for i in range(len(nums)):\r\n            if nums[end] == nums[i]:\r\n                continue\r\n            else:\r\n                end += 1\r\n                nums[end] = nums[i]\r\n        return end+1\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110435641","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        \"\"\"\r\n        采用二分法，双指针的方法\r\n        \"\"\"\r\n        start,end = 0,len(nums)-1\r\n        while start <= end:\r\n            mid = (start+end)//2\r\n            if nums[mid] < target:\r\n                start = mid + 1\r\n            elif nums[mid] > target:\r\n                end = mid -1 \r\n            else:\r\n                return mid\r\n        return start\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111682854","body":"## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        \"\"\"\r\n        每次输出滑动窗口的最大值\r\n        滑动窗口中的值使用一个单调队列(双端队列实现)维护\r\n        如果k大于等于len(nums)，输出数组最大值\r\n        如果k小于len(nums)，输出值个数为len(nums)-k+1\r\n        \"\"\"\r\n        if k >= len(nums):\r\n            return [max(nums)]\r\n        q = collections.deque()\r\n        ans = []\r\n        for i in range(len(nums)):\r\n            # 保证队列是单调递减的\r\n            while q and nums[q[-1]] <= nums[i]: q.pop() \r\n            # 保证单调栈长度<=k\r\n            while q and i - q[0] >= k: q.popleft()\r\n            q.append(i)\r\n            if i >= k - 1: ans.append(nums[q[0]])\r\n        return ans\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度,k为双端队列长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(k)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112829674","body":"## 思路\r\n- 计算图的入度和出度\r\n\r\n## 关键点\r\n\r\n-  如何存储每个节点的入度和出度\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        \"\"\"\r\n        寻找法官 也就是在图中需按照入度为n-1,出度为0的节点是否存在\r\n        \"\"\"\r\n        in_degree = [0] * (n+1)\r\n        out_degree = [0] * (n+1)\r\n\r\n        for a,b in trust:\r\n            out_degree[a] += 1\r\n            in_degree[b] += 1\r\n        for in_,out_ in zip(in_degree,out_degree):\r\n            if in_ == n-1 and out_ == 0:\r\n                return in_degree[1:].index(in_)+1\r\n        return -1\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085447103","body":"## 思路\n    将数组的最后一位加到k上，然后k对10取余，得到的结果放到linkedList的第一位。数组长度不足时则只操作k。直到k小于0并且数组遍历结束。\n## 复杂度分析\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```\npublic List<Integer> addToArrayForm2(int[] num, int k) {\n    LinkedList<Integer> ans = new LinkedList<>();\n    int i = num.length - 1;\n    while (k >= 1 || i >= 0) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        i--;\n        ans.addFirst(k % 10);\n        k /= 10;\n    }\n    return ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086581512","body":"##   思路\r\n    预设一个初始为0的k来记录上一次c出现的下标，循环将i-k当做答案。\r\n    当c再次出现的时候 只需要将(i+k)/2到i的下标重新赋值即可。\r\n    使用flag标记来解决当0下标为c的时候只会对0到下一个下标之前的全部数据赋值的错误\r\n##   复杂度\r\n    时间复杂度O(n) 空间复杂度O(n)\r\n##  代码\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n    int k = 0;\r\n    int[] ans = new int[s.length()];\r\n    boolean flag = false;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        if (s.charAt(i) == c) {\r\n            for (int j = i; flag && j > (i + k) >> 1 || !flag && j >= k; j--) {\r\n                ans[j] = i - j;\r\n            }\r\n            k = i;\r\n            flag = true;\r\n        }\r\n        ans[i] = i - k;\r\n    }\r\n    return ans;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764486","body":"##   思路\n      数组实现，使用两个值分别保存最大长度和当前长度，添加和移除的时候就从当前长度位上操作\n##  代码\n```\nclass CustomStack {\n    int[] value;\n    int maxSize;\n    int current = 0;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.value = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(current==maxSize){\n            return;\n        }\n        value[current++]=x;\n    }\n    \n    public int pop() {\n        if(current==0){\n            return -1;\n        }\n        return value[--current];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<current;i++){\n            value[i]+=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087232122","body":"## 思路\n    双栈思路，将倍数放入倍数栈内，对应层级的字符串放在对应的字符串栈中，当遇到]时处理这一对中括号之间的数据，从倍数栈中取出倍数，将当前的字符串扩展到倍数长，再讲对应的字符串栈中的字符串拼接到扩展之后的字符串之前。\n\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```\npublic String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088295111","body":"##  思路\n    向其中一个栈推数据会出现在栈顶，如果需要读取的时候，需要读取最后一个，这时候只需要将栈翻转即可。\n    在队列的先进先出规则上，只会操作栈的最后一个，所以将栈翻转之后保存即时队列的操作顺序。\n    当用于输出的栈数据为空的时候，将用于保存的栈的数据翻转给输出栈。\n\n##  复杂度\n    时间复杂度O(1) 对于双栈中的每个数据 均进行两次入栈 两次出栈的操作  空间复杂度O(1)除双栈外不需要额外的空间 \n\n##  代码\n```\nclass MyQueue {\n        private Stack<Integer> headStack = new Stack<>();\n        private Stack<Integer> tailStack = new Stack<>();\n        \n        public MyQueue() {\n        }\n\n        public void push(int x) {\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090402641","body":"## 思路\n\n    分块，当循环时当前的值大于等于栈中最大的值的时候，即证明这个值可以被单独分成一块，如果这个值小于栈顶的值时，记录栈顶的值，向栈下面遍历直到找到小于等于这个值的栈中值，并将记录的栈顶值再次插入栈，最后栈的长度即为结果\n\n## 复杂度\n\n    时间复杂度O(n*n) 最坏的情况是每个值都要重新重新遍历一次栈  空间复杂度O(n)额外的栈保存数据\n\n## 代码\n\n```\npublic int maxChunksToSorted(int[] arr) {\n    Deque<Integer> stack = new LinkedList<>();\n    stack.push(arr[0]);\n    int head;\n    for (int i = 1; i < arr.length; i++) {\n    if (arr[i] >= stack.peek()) {\n        stack.push(arr[i]);\n    } else {\n    head = stack.pop();\n    while (!stack.isEmpty() && stack.peek() > arr[i]) {\n        stack.pop();\n    }\n    stack.push(head);\n    }\n}\nreturn stack.size();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091836216","body":"## 思路\n\n    将链表首尾相接形成环，再后移n-k对n的余数-1位 在新的接口处断开环\n## 复杂度\n\n    时间复杂度O(n)  空间复杂度O(n)\n\n## 代码\n\n```\npublic ListNode rotateRight(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0) {\n        return head;\n    }\n    ListNode tail = head, newtail = head;\n    ListNode newhead;\n    int n = 1;\n    while (tail.next != null) {\n        tail = tail.next;\n        n++;\n    }\n    tail.next = head;\n    for (int i = 0; i < (n - k % n - 1); i++) {\n        newtail = newtail.next;\n    }\n    newhead = newtail.next;\n    newtail.next = null;\n    return newhead;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092382467","body":"\n\n\n##  思路\n    采用虚拟头接点，将虚拟头接点之后的接点两两交换，直到下两个节点出现null\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n##   代码\n```\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ans = new ListNode(0, head);\n        ListNode temp = ans;\n        ListNode next;\n        ListNode node2;\n        while (temp.next != null && temp.next.next != null) {\n            //保留1\n            next = temp.next;\n            //保留2\n            node2 = next.next;\n            //pre-->2\n            temp.next = node2;\n            //1-->3\n            next.next = node2.next;\n            //2-->1\n            node2.next = next;\n            temp = next;\n        }\n        return ans.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094074164","body":"## 思路\n\n    分治\n\n## 复杂度\n    时间复杂度：O(n log n) 空间复杂度：O(log n)\n\n## 代码\n```\npublic TreeNode sortedListToBST(ListNode head) {\nreturn buildTree(head, null);\n}\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094284948","body":"\n## 思路\n\n    双指针:一个指针从遍历A->B 另一个指针遍历B->A 这样无论AB那个更长，总会在二次遍历的时候相遇(如果有交点)\n\n## 复杂度\n\n    时间复杂度：O(n+m) 空间复杂度：O(1)\n\n## 代码\n\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode tailA = headA;\n    ListNode tailB = headB;\n    while(tailA!=tailB){\n        tailA = tailA==null?headB:tailA.next;\n        tailB = tailB == null? headA:tailB.next;\n    }\n    return tailA;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094439989","body":"##  思路\r\n    双指针 快指针比慢指针快两倍速，如果链表内有环则必然相遇。当快慢指针相遇时，快指针走过非环部分+慢指针走过的部分*2 + 自己走的剩余的环的部分 \r\n    慢指针走过 非环部分 + 慢指针走过的部分  快指针 = 慢指针的两倍 可以得出  快指针多走的部分(即从相遇点到环起点) = 非环部门\r\n    这是启用一个新指针 指向头指针 新指针和慢指针一起移动  这两个指针相遇的点即为环起点\r\n##  复杂度\r\n    时间复杂度O(n) 空间复杂度O(1)\r\n##  代码\r\n\r\n```\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast!=null&&fast.next!=null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(fast == slow){\r\n                ListNode pre = head;\r\n                while(pre!=slow){\r\n                    slow = slow.next;\r\n                    pre = pre.next;\r\n                }\r\n                return pre;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096912642","body":"##   思路\n\n    map + 双向链表 新增链表的时候 将key - 链表放入map\n    存取数据的时候 将改节点提到头结点上\n    当容量达到上限之后 将链表最后的节点删除 并从mao中删除\n\n##   复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(n)\n\n##   代码\n```\n    class LRUCache {\n        class LinkedNode {\n        int key;\n        int value;\n        LinkedNode pre;\n        LinkedNode next;\n\n            public LinkedNode() {\n\n            }\n\n            public LinkedNode(int _key, int _value) {\n                key = _key;\n                value = _value;\n            }\n        }\n\n        private int size;\n        int current;\n        private Map<Integer, LinkedNode> keyValue;\n        private LinkedNode head, tail;\n\n        public LRUCache(int capacity) {\n            size = capacity;\n            current = 0;\n            keyValue = new HashMap<>();\n            head = new LinkedNode();\n            tail = new LinkedNode();\n            head.next = tail;\n            tail.pre = head;\n        }\n\n        public int get(int key) {\n            final LinkedNode orDefault = keyValue.getOrDefault(key, null);\n            if (orDefault == null) {\n                return -1;\n            }\n            removeNode(orDefault);\n            addToHead(orDefault);\n            return orDefault.value;\n        }\n\n        public void put(int key, int value) {\n            LinkedNode valueNode = keyValue.get(key);\n            if (keyValue.containsKey(key)) {\n                valueNode.value = value;\n                removeNode(valueNode);\n                addToHead(valueNode);\n                return;\n            } else {\n                valueNode = new LinkedNode(key, value);\n                addToHead(valueNode);\n                current++;\n                if (current > size) {\n                    int removeKey = tail.pre.key;\n                    tail = tail.pre;\n                    keyValue.remove(removeKey);\n                    current--;\n                }\n            }\n            keyValue.put(key, valueNode);\n        }\n\n        void removeNode(LinkedNode node) {\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n        }\n\n        void addToHead(LinkedNode node) {\n            node.next = head.next;\n            head.next.pre = node;\n            head.next = node;\n            node.pre = head;\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1096926209","body":"\n## 思路\n    递归 获取左右支树的长度，取较大值 \n    对于每个左右树 继续获取长度的较大值\n\n## 复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(1)\n\n## 代码\n\n```\n    public int maxDepth(TreeNode root) {\n    if(root == null){\n    return 0;\n    }\n    return getHigh(0,root);\n    }\n\n    int getHigh(int high,TreeNode tree){\n        if(tree==null){\n            return high;\n        }\n        if(tree.left == null){\n            return getHigh(high+1,tree.right);\n        }\n        if(tree.right == null){\n            return getHigh(high+1,tree.left);\n        }\n        return Math.max(getHigh(high+1,tree.left),getHigh(high+1,tree.right));\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098734628","body":"##  思路\n    递归 两颗树全为空则相等 只有其中一颗不为空则不等 如果都不为空则判断值是否相等  相等则再递归判断左右子树的相等情况\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(1)\n##   代码\n\n```java\n    class Solution {\n        public boolean isSameTree(TreeNode p, TreeNode q) {\n            if (p == null && q == null) {\n                return true;\n            }\n            if (p == null || q == null) {\n                return false;\n            }\n            if (p.val != q.val) {\n                return false;\n            }\n            return isSameTree(p.left, q.left) && isSameTree(q.right, p.right);\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099784344","body":"\n##  思路\n    深度优先遍历  优先搜索某一支树到叶子节点,使用一个标记值去记录上层的数据，当到达下一层节点的时候k*10并加上当前节点的值，\n    当到达叶子节点的时候将此时的值加到最终结果上\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(1)\n##   代码\n```java\n    public int sumNumbers(TreeNode root) {\n        int sum = 0;\n        sum = getNumber(root, 0, sum);\n        return sum;\n    }\n\n    int getNumber(TreeNode root, int number, Integer sum) {\n        if (root.left == null && root.right == null) {\n            sum += number * 10 + root.val;\n            return sum;\n        }\n        if (root.left != null) {\n            sum = getNumber(root.left, number * 10 + root.val, sum);\n        }\n        if (root.right != null) {\n            sum =  getNumber(root.right, number * 10 + root.val, sum);\n        }\n        return sum;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100692189","body":"## 思路\n    BFS  使用先进先出队列替代递归 将每层的节点放入队列 在下一层出队 记录每一层的第一个左支树 循环结束后的记录值即为结果\n\n## 复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(n)\n\n## 代码\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> nodeQueue = new LinkedList<>();\n        nodeQueue.add(root);\n        int firstVal = root.val;\n        while (nodeQueue.size() > 0) {\n            boolean flg = false;\n            int size = nodeQueue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = nodeQueue.poll();\n                if (node.left != null) {\n                    nodeQueue.add(node.left);\n                    if (!flg) {\n                        firstVal = node.left.val;\n                        flg = true;\n                    }\n                }\n                if (node.right != null) {\n                    nodeQueue.add(node.right);\n                    if (!flg) {\n                        firstVal = node.right.val;\n                        flg = true;\n                    }\n                }\n            }\n        }\n        return firstVal;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100898153","body":"## 思路\n\n    深度优先搜索 使用深度优先搜索来序列化和反序列化  当遇空的时候不再向下查找 或者继续将左右子树放大字符串中 反序列的时候遇见null则生成的树节点到此为止\n## 复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(n)\n\n## 代码\n\n```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n\n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n\n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n\n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101453967","body":"## 思路\n\n    对树进行遍历并记录 值 x y 记录， 将记录之后的数值排序\n\n## 复杂度\n\n    时间复杂度：O(n log n) 空间复杂度：O(n)\n\n## 代码\n\n```java\nclass Solution {\n    Map<TreeNode, int[]> map = new HashMap<>(); // col, row, val\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b)->{\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            }\n            if (a[1] != b[1]) {\n                return a[1] - b[1];\n            }\n            return a[2] - b[2];\n        });\n        int n = list.size();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) {\n                tmp.add(list.get(j++)[2]);\n            }\n            ans.add(tmp);\n            i = j;\n        }\n        return ans;\n    }\n    void dfs(TreeNode root) {\n        if (root == null) return ;\n        int[] info = map.get(root);\n        int col = info[0], row = info[1], val = info[2];\n        if (root.left != null) {\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102806623","body":"## 思路\n\n    循环并判断target和当前下表的值的差值是否在哈希表中出现，出现则返回，不出现则将当前的值和下表放入哈希表中\n\n## 复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(n)\n\n## 代码\n```java\npublic int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target - nums[i])){\n                return new int[]{i,map.get(target-nums[i])};\n            }\n            map.put(nums[i],i);\n        }\n        return new int[]{0,0};\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103369312","body":"##  思路\n    优先队列 将数组中的全部数出现的次数做次数统计并放入hash表 循环hash表 将值，出现的次数放入以次数为比较对象的有点队列中，\n    如果队列已满 判断下一元素的出现次数是否大于队列中最小的出现次数 大于则替换\n##  复杂度\n    时间复杂度O(n log n) 空间复杂度O(n)\n##   代码\n``` java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        //Comparator.comparingInt(o -> o[1]) 返回一个比较器 该比较器以int排序lambda表达式中是如何获取这个用于比较的int\n        //PriorityQueue 优先队列 以构造器中的比较器参数为排序规则排序\n        PriorityQueue<int[]> queue = new PriorityQueue<>((Comparator.comparingInt(o -> o[1])));\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (queue.size() == k) {\n                final int[] peek = queue.peek();\n                if (peek[1] < entry.getValue()) {\n                    queue.poll();\n                    queue.offer(new int[]{entry.getKey(), entry.getValue()});\n                }\n            } else {\n                queue.offer(new int[]{entry.getKey(), entry.getValue()});\n            }\n        }\n        int[] ans = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ans[i] = queue.poll()[0];\n        }\n        return ans;\n    }\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105071728","body":"\n## 思路\n\n    双重循环遍历  将循环外层坐标点和内层坐标点的距离的平方作为key存入map中 \n    当这个长度再次出现的时候 将出现的次数作为value存入hash表 并将之前出现的次数*2加给总的出现次数\n\n## 复杂度\n\n    时间复杂度：O(n*n) 空间复杂度：O(n)\n\n## 代码\n\n```java\n    public int numberOfBoomerangs(int[][] points) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int ans = 0;\n        for (int i = 0; i < points.length; i++) {\n            map = new HashMap<>();\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) continue;\n                int len = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n                 (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                if (map.containsKey(len)) {\n                    ans += map.get(len) * 2;\n                }\n                map.put(len, map.getOrDefault(len, 0) + 1);\n            }\n        }\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105942162","body":"##  思路\n    hash表+双指针 将一个指针向后移动，并将遇到的char放入map 如果char已存在 \n    则取此时的长度和之前的长度最大的值的最大值 将开始节点移动到上一次出现该值的下标  并将这个下标之前的char移出hash表\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n##   代码\n\n```java\n    public int lengthOfLongestSubstring(String s) {\n        int start = 0, end = 0, sum = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (map.containsKey(c)) {\n                sum = Math.max(sum, map.size());\n                for (; start < end; start++) {\n                    if (c == s.charAt(start)) {\n                        start++;\n                        end++;\n                        break;\n                    } else {\n                        map.remove(s.charAt(start));\n                    }\n                }\n            } else {\n                end++;\n                map.put(c, 1);\n            }\n\n        }\n        return Math.max(sum, map.size());\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107523218","body":"## 思路\n\n    滑动窗口 每次从s上截取数组中所有word总长度的字符串 从截取的字符串上再截取一个个word长度的字符串 使用map判断所有的字符是否都存在且次数一样 一样 则将下表记录到ans中\n\n## 复杂度\n\n    时间复杂度：O(n*m) 空间复杂度：O(n*n)\n## 代码\n```java\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList<>();\n        Map<String, Integer> keyValue = new HashMap<>();\n        for (String word : words) {\n            keyValue.put(word, keyValue.getOrDefault(word, 0) + 1);\n        }\n        int lenOfWord = words[0].length();\n        int lenOfAllWords = lenOfWord * words.length;\n        for (int i = 0; i < s.length() - lenOfAllWords + 1; i++) {\n            String temp = s.substring(i, i + lenOfAllWords);\n            Map<String, Integer> tempMap = new HashMap<>();\n            for (int j = 0; j < lenOfAllWords; j += lenOfWord) {\n                String tempj = temp.substring(j, j + lenOfWord);\n                if (!keyValue.containsKey(tempj) || keyValue.get(tempj) <= tempMap.getOrDefault(tempj,0)) {\n                    break;\n                }\n                tempMap.put(tempj, tempMap.getOrDefault(tempj, 0) + 1);\n            }\n            if (tempMap.equals(keyValue)) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107957788","body":"##  思路\n    双指针 快慢指针 快指针存在next的时候将慢指针后移确保取到中间节点的第二个\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(1)\n##   代码\n\n```java\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head,low = head;\n        while(fast.next!=null){\n            low = low.next;\n            if(fast.next.next!=null){\n                fast = fast.next.next;\n            }else{\n                break;\n            }\n        }\n        return low;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109190458","body":"##  思路\n    双指针 在保存的数据和当前下标数据不同的时候交换慢指针和当前下标的数据 并将慢指针前移\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(1)\n##   代码\n\n```java\n    public int removeDuplicates(int[] nums) {\n        if (nums.length < 2) {\n            return nums.length;\n        }\n        int start = 1, temp = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            if (temp != nums[i]) {\n                temp = nums[i];\n                nums[start] = temp;\n                start++;\n            }\n        }\n        return start;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110448576","body":"\n##  思路\n    双指针 前后指针 每次取两个指针的中间值 如果大于目标值 则右指针移动到中间位置 反之则移动左指针\n    如果当前下标的值相当返回下标  左指针大于右指针或者左指针与右指针差距1的时候 返回数据\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(1)\n##   代码\n\n```java\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length;\n        int temp = 0;\n        while (left < right) {\n            temp = (right - left >> 1) + left;\n            if (nums[temp] == target) {\n                return temp;\n            }\n            if (nums[temp] < target) {\n                if (right - left == 1) {\n                    return right;\n                }\n                left = temp;\n                continue;\n            }\n            right = temp;\n        }\n        return temp;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112378044","body":"\n## 思路\n\n   双端队列    保证双端队列中的数据是递减 窗口移动时 将下一个元素和队列中的元素比较 如果前者大于等于后者，那么队尾的元素就可以被永久地移除\n\n## 复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(k)\n\n## 代码\n\n```java\n\npublic int[] maxSlidingWindow(int[] nums, int k) {\n    int n = nums.length;\n    Deque<Integer> deque = new LinkedList<Integer>();\n    for (int i = 0; i < k; ++i) {\n        while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n            deque.pollLast();\n        }\n        deque.offerLast(i);\n    }\n\n    int[] ans = new int[n - k + 1];\n    ans[0] = nums[deque.peekFirst()];\n    for (int i = k; i < n; ++i) {\n         while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n             deque.pollLast();\n        }\n        deque.offerLast(i);\n        while (deque.peekFirst() <= i - k) {\n            deque.pollFirst();\n        }\n        ans[i - k + 1] = nums[deque.peekFirst()];\n    }\n    return ans;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113463582","body":"## 思路\n\n    统计这个人被别人信任的次数 并排去他信任其他人的情况\n\n## 复杂度\n\n    时间复杂度：O(n) 空间复杂度：O(n)\n\n## 代码\n\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] ans = new int[n];\n        for(int i=0;i<trust.length;i++){\n            ans[trust[i][1]-1]++;\n            ans[trust[i][0]-1] = Integer.MIN_VALUE;\n        }\n        for(int i =0;i<n;i++){\n            if(ans[i]==(n-1)){\n                return i+1;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085449145","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- 数组遍历、逐位相加的方法\n\n\n## 思路\n1、数组输出，需要通过for循环将数组输出\n2、将数组和整数依次相加，整数获取位数上的数可通过依次进行求余运算\n\n## 关键点\n\n-  熟悉整数获取位数上的方法\n- 熟悉数组的API，push（）、reverse（）\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    let n = num.length;\n    for(let i = n -1; i >= 0; i--)\n    {\n        let sum = num[i] + k%10;\n        k = Math.floor(k/10);\n        if(sum>=10)\n        {\n            k++;\n            sum = sum -10;\n        }\n        res.push(sum);\n    }\n    for(;k>0;k = Math.floor(k/10))\n    {\n        res.push(k%10);\n    }\n    res.reverse();\n    return res;\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，\n- 空间复杂度：$O(1)$，没有额外增加空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086657535","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- 数组的API\n- 双指针\n\n\n## 思路\n（本题参考了其他人的代码）\n- 主要需要解决的问题是取离c最小的距离\n\n## 关键点\n\n-  判断离c最小的距离\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let num = [];\n    num.length === s.length;\n    let indexNext=s.indexOf(c);//indexNext表示下一个c的下标， \n    let index=indexNext;//index表示前一个c的坐标\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(let i = 0; i < s.length; i++){\n            if(s[i] == c){//每当遍历到C就更新index和indexNext\n                num[i] = 0;\n                index = i;\n                indexNext = s.indexOf(c, i+1);\n            }else{\n                num[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n    return num;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888061","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- 栈\n\n\n## 思路\n主要难点在于void inc(int k, int val)，但暂时只会使用for循环进行完成，但复杂度较高\n\n## 关键点\n\n-  需要考虑个数需求以及栈的元素是否为0\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.Stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.Stack.length >= this.maxSize)\n    {\n        return;\n    }\n    this.Stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.Stack.length == 0)\n    {\n        return -1;\n    }\n    return this.Stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.Stack.length <= k)\n    {\n        for(let i = 0; i < this.Stack.length ;i++)\n    {\n            this.Stack[i] += val;\n    }\n    }\n    else\n    {\n        for(let j = 0; j < k ; j++)\n        {\n            this.Stack[j] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087727938","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n \n\n提示：\n\n1 <= s.length <= 30\ns 由小写英文字母、数字和方括号 '[]' 组成\ns 保证是一个 有效 的输入。\ns 中所有整数的取值范围为 [1, 300] \n```\n\n## 前置知识\n\n- 栈前后匹配的运行\n\n\n## 思路\n- 本题最初的思路仅有本题与栈有关，而其余毫无思路，通过讲义知道应该使用栈的匹配方法将此题目进行完成\n\n## 关键点\n\n-  数字只运用于重复的倍数，而字符串则代表重复的字符串内容\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let numStack = [];        // 存倍数的栈\n    let strStack = [];        // 存 待拼接的str 的栈\n    let num = 0;              // 倍数\n    let result = '';          // 字符串\n    for (const char of s) {   // 逐字符扫描\n        if (!isNaN(char)) {   // 遇到数字\n            num = num * 10 + Number(char); // 算出倍数\n        } else if (char == '[') {  // 遇到 [\n            strStack.push(result); // result串入栈\n            result = '';           // 入栈后清零\n            numStack.push(num);    // 倍数num进入栈等待\n            num = 0;               // 入栈后清零\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n        } else {                   \n            result += char;        // 遇到字母，追加给result串\n        }\n    }\n    return result;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088860064","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n示例 1：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n```\n\n## 前置知识\n\n- 栈（先进后出）、队列（先进先出）\n\n\n## 思路\n通过两个栈进行实现队列，解决的关键在于数据进与出的问题\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function() {\n    //使用两个栈实现队列，创建栈\n    this.stack1 = [];//将一个栈当作输入栈，用于push操作，通过push 传入数据\n    this.stack2 = [];//将一个栈当作输出栈，用于pop 和peek操作\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\n //将元素x推到队列的末尾\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\n //从队列的开头移除并返回元素\n //碰到pop/peek，把所有输入栈的内容放到输出栈去\nMyQueue.prototype.pop = function() {\n    if(!this.stack2.length)\n    {\n        while(this.stack1.length)\n        {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\n //返回队列开头的元素\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length)\n    {\n        while(this.stack1.length)\n        {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function(){\n    if(this.stack1.length == 0 && this.stack2.length == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push-O（1）pop-O（n） peek-O（n）empty-O（1）\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090430264","body":"\n## 题目地址(768. 最多能完成排序的块 II)\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n\n\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n- 数组排序\n- 滑动窗口算法\n\n## 思路\n构建新的数组，新数组为原数组排序后的结果，而后对比之和数来判断分块的结果\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    //将arr浅拷贝复制给sorted\n    const sorted = [...arr];\n    //将sorted进行排序\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        //比较之和数的大小进行判断分块结果\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n            sum1 = sum2 = 0;\n        }\n    }\n\n    return count;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，运用了for循环\n- 空间复杂度：$O(n)$，创建了新的数组sorted","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091908577","body":"## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094071851","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n \n\n示例 1:\n\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n\n示例 2:\n\n输入: head = []\n输出: []\n\n\n \n\n提示:\n\nhead 中的节点数在[0, 2 * 104] 范围内\n-105 <= Node.val <= 105\n```\n\n## 前置知识\n\n- 链表、树、递归\n\n\n## 思路\n通过判断当前节点处于左指针还是右指针\n\n## 关键点\n\n-  构建树的要求\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { // 将链表节点的值逐个推入数组arr\n    arr.push(head.val);\n    head = head.next;\n  }\n  // 根据索引start到end的子数组构建子树\n  const buildBST = (start, end) => {\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\n    const mid = Math.floor((start+end)/2);     // 求中间索引 中间元素是根节点的值\n    const root = new TreeNode(arr[mid]); // 创建根节点\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\n    return root;                          // 返回当前子树\n  };\n\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，while循环\n- 空间复杂度：$O(n)$，构建了新的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294672","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 链表，哈希表\n\n\n## 思路\n1、A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表\n2、遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let data = new Set();\n    while (headA !== null) {\n    data.add(headA);\n    headA = headA.next;\n}\n    while (headB !== null) {\n    if (data.has(headB)) \n    return headB;\n    headB = headB.next;\n}\nreturn null;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095231435","body":"\n## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n## 前置知识\n\n- 双指针、链表\n\n\n## 思路\n使用快慢指针进行解决此问题，当快慢指针第二次相遇时则找到该节点\n## 关键点\n\n-  快慢指针相遇的问题\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null)\n    {\n        return null;\n    }\n    let fast = (slow = head);\n    do{\n        if(fast != null && fast.next != null)\n        {\n            fast = fast.next.next;\n        }\n        else{\n            fast = null;\n        }\n        slow = slow.next;\n    }\n    while(fast!=slow);\n    if(fast == null)\n    return null;\n    fast = head;\n    while(fast != slow){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098068871","body":"\n## 题目地址(104. 二叉树的最大深度)\n\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n## 题目描述\n\n```\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n```\n\n## 前置知识\n\n- 深度优先遍历\n\n\n\n## 思路\n左右子树进行深度优先遍历来获得最后树的深度\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) {\n        return 0;\n    } else {\n        const left = maxDepth(root.left);\n        const right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1100907122","body":"\n## 题目地址(100. 相同的树)\n\nhttps://leetcode-cn.com/problems/same-tree/\n\n## 题目描述\n\n```\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n示例 1：\n\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n\n\n示例 2：\n\n输入：p = [1,2], q = [1,null,2]\n输出：false\n\n\n示例 3：\n\n输入：p = [1,2,1], q = [1,1,2]\n输出：false\n\n\n \n\n提示：\n\n两棵树上的节点数目都在范围 [0, 100] 内\n-104 <= Node.val <= 104\n```\n\n## 前置知识\n\n- 深度优先遍历\n\n## 思路\n两两进行比较，相同则返回true，根结点的左子树以及右子树也依次进行对比\n\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if( p == null && q == null)\n    return true;\n    if ( p == null || q == null)\n    return false;\n    if(p.val !== q.val)\n    return false;\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(h)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100192418","body":"\n## 题目地址(129. 求根节点到叶节点数字之和)\n\nhttps://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n## 题目描述\n\n```\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n\n示例 2：\n\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n\n\n \n\n提示：\n\n树中节点的数目在范围 [1, 1000] 内\n0 <= Node.val <= 9\n树的深度不超过 10\n```\n\n## 前置知识\n\n- s深度优先遍历，树\n\n\n\n## 思路\n使用深度优先遍历将用一支路进行计算\n\n## 关键点\n\n-  数值相加\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nconst dfs = (root,prenum) => {\n        if(root === null)\n        {\n            return 0;\n        }\n        const sum = prenum * 10 + root.val;\n        if(root.left == null && root.right == null)\n        {\n            return sum;\n        }\n        else\n        {\n            return dfs(root.left,sum) + dfs(root.right,sum);\n        }\n    }\nvar sumNumbers = function(root) {\n    return dfs(root,0); \n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100695920","body":"\n## 题目地址(513. 找树左下角的值)\n\nhttps://leetcode-cn.com/problems/find-bottom-left-tree-value/\n\n## 题目描述\n\n```\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n\n假设二叉树中至少有一个节点。\n\n \n\n示例 1:\n\n输入: root = [2,1,3]\n输出: 1\n\n\n示例 2:\n\n输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n\n\n \n\n提示:\n\n二叉树的节点个数的范围是 [1,104]\n-231 <= Node.val <= 231 - 1 \n```\n\n## 前置知识\n\n- 深度优先遍历\n\n\n\n## 思路\n先判断最大的深度，后获取节点值\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n\n  let curMaxDepth = -1, curVal = 0;\n\n  var dfs = function(root, curDepth){\n    if(!root) return null;\n    if(curDepth > curMaxDepth){\n      curMaxDepth = curDepth;\n      curVal = root.val;\n    }\n\n    dfs(root.left, curDepth+1)\n    dfs(root.right, curDepth + 1)\n  }\n\n  dfs(root, 0)\n  return curVal;\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102669141","body":"\n## 题目地址(1. 两数之和)\n\nhttps://leetcode-cn.com/problems/two-sum/\n\n## 题目描述\n\n```\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n \n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n \n\n提示：\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n只会存在一个有效答案\n\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n```\n\n## 前置知识\n\n- 哈希表思想、JS中的Map的API\n\n## 思路\n在数组中找出两个之和等于target，每一个出现的 num 判断其另一半 target - num 是否也出现在数组中\n\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0;i < nums.length;i++)\n    {\n        if(map.has(target - nums[i]))\n        {\n            return [map.get(target - nums[i]),i];\n        }\n        else\n        {\n            map.set(nums[i],i);\n        }\n    }\n    return null;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105319464","body":"\n## 题目地址(447. 回旋镖的数量)\n\nhttps://leetcode-cn.com/problems/number-of-boomerangs/\n\n## 题目描述\n\n```\n给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。\n\n返回平面上所有回旋镖的数量。\n\n \n\n示例 1：\n\n输入：points = [[0,0],[1,0],[2,0]]\n输出：2\n解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n\n\n示例 2：\n\n输入：points = [[1,1],[2,2],[3,3]]\n输出：2\n\n\n示例 3：\n\n输入：points = [[1,1]]\n输出：0\n\n\n \n\n提示：\n\nn == points.length\n1 <= n <= 500\npoints[i].length == 2\n-104 <= xi, yi <= 104\n所有点都 互不相同\n```\n\n## 前置知识\n\n- 哈希表\n- 两点之间的距离之和\n- 排列组合\n\n\n## 关键点\n\n-  判断距离相等以及计算组合数\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;//所有回旋镖的数量\n    for (const p of points){\n        const m = new Map();\n        for(const q of points){\n        const dis = (p[0]-q[0])*(p[0]-q[0]) + (p[1]-q[1])*(p[1]-q[1]);//计算两点的距离\n        m.set(dis,(m.get(dis)|| 0) +1);//统计距离当前点相同距离的数量加入到map中\n    }\n    //map.entires()返回 Map 对象中键/值对的数组\n    for(const [_,item] of m.entries()){//从相同距离的点的数量中选取两个\n        ans += item * (item -1);\n        }\n    } \n    return ans;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107514087","body":"\n## 题目地址(30. 串联所有单词的子串)\n\nhttps://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/\n\n## 题目描述\n\n```\n给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。\n\n \n\n示例 1：\n\n输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n\n示例 2：\n\n输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n\n\n示例 3：\n\n输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n\n\n \n\n提示：\n\n1 <= s.length <= 104\ns 由小写英文字母组成\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] 由小写英文字母组成\n```\n\n## 前置知识\n\n- 哈希表\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    const wordSize = words[0].length;\n    const substringLen = wordSize * words.length;\n\n    const wordsCount = {};\n    words.forEach(w => (wordsCount[w] = (wordsCount[w] || 0) + 1))\n\n    const res = []\n    for (let i = 0; i <= s.length - substringLen; i++) {\n        const tempCount = {...wordsCount};\n        let count = words.length;\n\n        for (let j = i; j < i + substringLen; j += wordSize) {\n            const word = s.slice(j, j + wordSize);\n\n            if (!(word in tempCount) || tempCount[word] <= 0) \n            break;\n\n            tempCount[word]--;\n            count--;\n        }\n\n        if (count === 0) \n        res.push(i);\n    }\n    return res;\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(（n-k）*k)$，n是字符串s的长度，k是单词的长度\n- 空间复杂度：$O(m)$，m为words数组的长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108688071","body":"\n## 题目地址(876. 链表的中间结点)\n\nhttps://leetcode-cn.com/problems/middle-of-the-linked-list/\n\n## 题目描述\n\n```\n给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n \n\n示例 1：\n\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n\n\n示例 2：\n\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n\n\n \n\n提示：\n\n给定链表的结点数介于 1 和 100 之间。\n```\n\n## 前置知识\n\n- 快慢指针\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    slow = fast = head;\n    while(fast&&fast.next)\n    {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109886538","body":"\n## 题目地址(26. 删除有序数组中的重复项)\n\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n## 题目描述\n\n```\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n判题标准:\n\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n如果所有断言都通过，那么您的题解将被 通过。\n\n \n\n示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n0 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums 已按 升序 排列\n```\n\n## 前置知识\n\n- 快慢指针\n\n## 思路\n通过快慢指针去查询相同值\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    const n = nums.length;\n    if(n == 0)\n    return 0;\n    let fast = 0,slow = 0;\n    while(fast <n)\n    {\n        if(nums[fast]!=nums[fast-1])\n        {\n            nums[slow] =nums[fast];\n            ++slow;\n        }\n        ++fast;\n    }\n    return slow;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112368385","body":"\n## 题目地址(239. 滑动窗口最大值)\n\nhttps://leetcode-cn.com/problems/sliding-window-maximum/\n\n## 题目描述\n\n```\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回 滑动窗口中的最大值 。\n\n \n\n示例 1：\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n输入：nums = [1], k = 1\n输出：[1]\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n1 <= k <= nums.length\n```\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    const c = [];\n    const ans = [];\n    for(let i = 0; i <nums.length;i++){\n        while(c.length&&nums[i]>=nums[c[c.length-1]]){\n            c.pop();\n        }\n        c.push(i);\n        while(c[0] <= i -k){\n            c.shift();\n        }\n        if(i >=k-1)\n        ans.push(nums[c[0]]);\n    }\n    return ans;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454092","body":"### 思路\n\n- 将整型列表拼接为字符串后，再转为int型与k相加\n- 将相加后的结果转为字符串后遍历，生成整型列表\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = int(\"\".join(list(map(str, num))))\n        return [int(i) for i in str(num + k)]\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650955","body":"### 思路\n\n1. 先遍历列表s，找到每一个元素c的索引位置，并添加到一个c_pos列表中\n2. for循环len(s)，如果当前位置的索引i小于c_pos[0]，即在c_pos[0]的左侧， 那么就往ans列表中添加“c_pos[0] - i“\n3. 如果当前的位置索引i大于c_pos[-1]，机在c_pos[-1]的右侧，那么就往ans列表中添加“i - c_pos[-1]”\n4. 如果当前的位置索引等于c_pos[p], p=0, 即当前的索引对于的就是元素c，那么就往ans列表中添加“0”, 同时p+=1\n5. 否则，如果恰巧当前位置前后都有元素c的索引，那么就判断离着谁更近，就往ans列表中“min(c_pos[p]-i, i-c_pos[p-1])”\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086763675","body":"### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.length = 0\n        \n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        \n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(self.length, k)):\n            self.stack[i] += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1) / O(K)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087687918","body":"### 思路\n1. 遇到的元素不是]，那么就先压入栈中\n2. 遇到 ] 时，逐个弹栈，直到遇到 [\n3. 继续弹出 [ 前的数字\n4. 将 string 重复 num次压入栈中\n5. 重复上述过程，直到栈空\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \n        stack = []\n        \n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                string = \"\"\n                while len(stack) > 0 and stack[-1] != '[':\n                    string = stack.pop() + string\n                # 弹出左括号\n                stack.pop()\n                \n                # 弹出重复数字\n                num_string = \"\"\n                while len(stack) > 0 and stack[-1].isdigit():\n                    num_string = stack.pop() + num_string\n                    \n                num = int(num_string)\n                stack.append(string * num)\n        return \"\".join(stack)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088850661","body":"### 思路\n- 用两个堆栈 stack1 和 stack2 来模拟队列\n- 入队列时：向 stack1 中压入元素\n- 出队列时：将 stack1 中的元素依次弹出堆栈，并压入 stack2 中，最后弹出 stack2 的栈顶元素\n\n### 代码\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n            return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if len(self.stack1)==0 and len(self.stack2)==0:\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089849941","body":"### 思路\n参考的官方解说的栈思路\n### 代码\n\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        \n        for i in arr:\n            if not stack:\n                max_num = i\n                stack.append(i)\n            else:\n                if i < stack[-1]:\n                    tmp = stack[-1]\n                    while stack and stack[-1] > i:\n                        stack.pop()\n                    stack.append(tmp)\n                else:\n                    stack.append(i)\n                    \n        return len(stack)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091880808","body":"### 思路\n使用双指针\n\n### 代码\n\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        if head is None:\n            return None\n    \n        tmp = head\n        length = 0\n        while tmp.next is not None:\n            length += 1\n            tmp = tmp.next\n        tail = tmp\n        length += 1\n        \n        k %= length\n        # 不需要移动\n        if k == 0:\n            return head\n\n        i = head\n        j = head\n\n        for l in range(k):\n            j = j.next\n\n        while j.next is not None:\n            j = j.next\n            i = i.next\n        i_next = i.next\n        tail.next = head\n        i.next = None\n\n        return i_next\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092971875","body":"### 思路\n- 添加一个头结点，方便操作\n- 遍历链表，调整指针指向\n- 返回头结点\n\n### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 创建头结点\n        cur = ListNode(0)\n        cur.next = head\n        \n        first = cur\n        while cur.next and cur.next.next:\n            n1 = cur.next\n            n2 = n1.next\n            n3 = n2.next\n            \n            cur.next = n2\n            n2.next = n1\n            n1.next = n3\n            \n            cur = n1\n        return first.next\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094068556","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094300324","body":"### 思路\n核心思想就是消除长度差。\n\n### 代码\n\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        length_a = 0\n        length_b = 0\n        \n        a = headA\n        b = headB\n        \n        while a:\n            a = a.next\n            length_a += 1\n        while b:\n            b = b.next\n            length_b += 1\n        \n        step = abs(length_a - length_b)\n        \n        a = headA\n        b = headB\n        \n        if length_a > length_b:\n            while step > 0:\n                a = a.next\n                step -= 1\n                \n        if length_a < length_b:\n            while step > 0:\n                b = b.next\n                step -= 1\n                \n        while a != b:\n            a = a.next\n            b = b.next\n            \n        return a\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095241582","body":"```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096902677","body":"### 思路\n\npython自带的OrderedDict\n\n### 代码\n\n\n```python\nclass LRUCache(collections.OrderedDict):\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self:\n            return -1\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last=False)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098203265","body":"### 思路\n递归\n\n### 代码\n\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(H)，树高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099312068","body":"### 思路\n递归\n\n### 代码\n\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100175942","body":"### 思路\n深度优先遍历\n\n###代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        \n        def dfs(root, cur):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return cur * 10 + root.val\n            \n            return dfs(root.left, cur*10+root.val) + dfs(root.right, cur*10+root.val)\n        \n        return dfs(root, 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100692164","body":"### 思路\n层次遍历，用队列来存储\n\n### 代码\n```python\nfrom collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.right:\n                q.append(node.right)\n            if node.left:\n                q.append(node.left)\n        return node.val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100902713","body":"```python\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        str_list = []\n        queue = []\n        queue.append(root)\n        while len(queue) > 0:\n            q_length = len(queue)\n            for i in range(q_length):\n                # 取出队列头部节点\n                first = queue[0]\n                del queue[0]\n                if first is None:\n                    str_list.append(\"N\")\n                    continue\n                str_list.append(str(first.val))\n                # 左右节点入队列\n                queue.append(first.left)\n                queue.append(first.right)\n        # print(str_list)\n        return ','.join(str_list)\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        str_list = data.split(',')\n        # 取出第一个节点\n        first = str_list[0]\n        root = self.get_node(first)\n        queue = []\n        queue.append(root)\n        del str_list[0]\n        while len(queue) > 0:\n            q_length = len(queue)\n            for i in range(q_length):\n                first = queue[0]\n                del queue[0]\n                if first is None:\n                    continue\n                # 构造它的左右节点\n                str_list_length = len(str_list)\n                if str_list_length >= 2:\n                    left_node = self.get_node(str_list[0])\n                    del str_list[0]\n                    right_node = self.get_node(str_list[0])\n                    del str_list[0]\n                elif str_list_length == 1:\n                    left_node = self.get_node(str_list[0])\n                    right_node = None\n                    del str_list[0]\n                else:\n                    left_node = None\n                    right_node = None\n                first.left = left_node\n                first.right = right_node\n                if left_node is not None:\n                    queue.append(left_node)\n                if right_node is not None:\n                    queue.append(right_node)\n\n        return root\n        \n    def get_node(self, root_val):\n        if root_val == 'N':\n            return None\n        else:\n            return TreeNode(int(root_val))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101493138","body":"```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        hashmap = defaultdict(list)\n        def dfs(node, x, y):\n            if not node:\n                return\n            hashmap[y].append((x,node.val))\n            dfs(node.left, x+1, y-1)\n            dfs(node.right,x+1, y+1)\n        \n        dfs(root, 0, 0)\n        return [list(zip(*sorted(hashmap[i])))[1] for i in sorted(hashmap.keys())]\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102806212","body":"### 思路\n排序+双指针\n\n### 代码\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        left = 0\n        right = len(nums) - 1\n        sort_nums = sorted(nums)\n        \n        while left < right:\n            totoal = sort_nums[left] + sort_nums[right]\n            if totoal == target:\n                break\n            elif totoal < target:\n                left += 1\n            elif totoal > target:\n                right -= 1\n        result = []   \n        for i in range(len(nums)):\n            if nums[i] == sort_nums[left]:\n                result.append(i)\n            elif nums[i] == sort_nums[right]:\n                result.append(i)\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104091942","body":"### 思路\n哈希表\n\n### 代码\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for i in range(len(nums)):\n            if nums[i] in dic:\n                dic[nums[i]] += 1\n            else:\n                dic[nums[i]] = 1\n                \n        dic = sorted(dic.items(), key=lambda x:x[1], reverse=True)\n        res = []\n        for i in range(k):\n            res.append(dic[i][0])\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105408913","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n=len(points)\n        dist=collections.defaultdict(dict)\n        for i in range(n):\n            for j in range(n):\n                if i==j: continue\n                d=(points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2\n                if i not in dist[d]:\n                    dist[d][i]=[j]\n                else:\n                    dist[d][i].append(j)\n        cnt=0\n        for d in dist:\n            for i in dist[d]:\n                if len(dist[d][i])>1:\n                    cnt+=len(dist[d][i])*(len(dist[d][i])-1)\n        return cnt","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106649082","body":"### 思路\n滑动窗口\n\n### 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s: return 0\n        n=len(s)\n        i,j,res=0,0,0\n        dic={}\n        while i<n and j<n:\n            if s[j] not in dic:\n                dic[s[j]]=1\n                j+=1\n                res=max(res,j-i)\n            else:\n                dic.pop(s[i])\n                i+=1\n        return res\n\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107520225","body":"### 思路\n使用两个哈希表\n\n### 代码\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        \n        if not s or not words: return []\n        word_len = len(words[0])\n        all_len = len(words) * word_len\n        n = len(s)\n        \n        words = Counter(words)\n        res = []\n        for i in range(0, n-all_len+1):\n            tmp = s[i: i+all_len]\n            c_tmp = []\n            for j in range(0, all_len, word_len):\n                c_tmp.append(tmp[j: j+word_len])\n            \n            if Counter(c_tmp) == words:\n                res.append(i)\n        return res","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108703390","body":"### 思路\n快慢指针\n\n### 代码\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n\n### 复杂度\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109944578","body":"### 思路\n快慢指针\n\n### 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow = 0\n        fast = 0\n        \n        while fast < len(nums):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                nums[slow] = nums[fast]\n            fast += 1\n        return slow+1\n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111118855","body":"### 思路\n二分查找\n\n### 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left\n```\n### 复杂度\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112356313","body":"```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        length = len(nums)\n        if length == 0 or k == 0:\n            return []\n        \n        # 构造 left\n        left = [0 for _ in range(length)]\n        for i in range(length):\n            if i % k == 0:\n                left[i] = nums[i]\n            else:\n                left[i] = max(left[i - 1], nums[i])\n                                \n        # 构造 right\n        right = [0 for _ in range(length)]\n        for i in range(length - 1, -1, -1):\n            if i % k == 0 or i == length - 1:\n                right[i] = nums[i]\n            else:\n                right[i] = max(right[i + 1], nums[i])\n                                        \n        for i in range(length - k + 1):\n            res.append(max(right[i], left[i + k - 1]))\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113456236","body":"### 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree, out_degree = [0] * (n + 1), [0] * (n + 1)\n        \n        for tr in trust:\n            in_degree[tr[1]] += 1\n            out_degree[tr[0]] += 1\n        \n        for i in range(1, n + 1):\n            if in_degree[i] == n - 1 and out_degree[i] == 0:\n                return i\n        \n        return -1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maggiexie00":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454513","body":"### 思路\r\n\r\n从尾部开始，原地更新num中的数值，k处理完则break\r\n\r\n***把k当作carry\r\n***题目已知num长度最多10^4，k最多5位数，若开辟新数组，则极大增加时间复杂度（遍历num），因而选择原地更新num数组，最坏情况是进行6次操作。\r\n*** key point 是k处理完就停止，无需遍历num。\r\n\r\n### 代码\r\n\r\n\r\n    def addToArrayForm(self, num, k) :\r\n\r\n        p=len(num)-1\r\n        while p>-1 and k!=0:\r\n            tmp=num[p]+k%10\r\n            num[p]=tmp%10\r\n            k=k//10+tmp//10\r\n            p-=1    \r\n\r\n        while k:\r\n            num=[k%10]+num\r\n            k//=10\r\n\r\n        return num\r\n\r\n### 复杂度\r\n空间复杂度 O(1)\r\n时间复杂度 O(N）其中N为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642755","body":"### 思路\r\n\r\n两次遍历\r\n\r\n记录上一个字符c出现的位置，从头走一遍，计算距离，再从尾部走一遍，更新距离为两次计算中的较小值。\r\n\r\n### 代码\r\n\r\n\r\n    def shortestToChar(self, s, c):\r\n        last=-10000\r\n        ans=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                last=i\r\n            ans.append(i-last)\r\n        last=10000\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                last=i\r\n            ans[i]=min(ans[i],last-i)\r\n        return ans\r\n            \r\n\r\n\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086716724","body":"### 思路\r\n一句话总结：只有pop操作时才真正进行增量操作，使得increment操作时间复杂度也是O(1)。\r\n\r\npush操作时，用[x，y]代替x。y用于increment操作，初始值均为0。\r\nincrement操作时，找到最后一个需要更新数值的位置，将该数值对应的y加上val。\r\npop操作时，返回x+y，并更新栈顶元素的y。\r\n### 代码\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[]\r\n        self.size=0\r\n        self.maxSize=maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.stack.append([x,0])\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        self.size-=1\r\n        a,b=self.stack.pop(-1)\r\n        if self.stack:\r\n            self.stack[-1][1]+=b\r\n        return a+b\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        idx=min(k,self.size)-1\r\n        if idx>-1:\r\n            self.stack[idx][1]+=val\r\n\r\n### 复杂度\r\n时间 O(1)\r\n空间 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087126743","body":"### 思路\r\nkey point: 栈中保存的是last_res（上个 [ 与当前 [ 之间的字符串）与cur_multi（当前 [ 与 ] 中字符串的重复次数）\r\n\r\ndetail：\r\n遇到字母，直接加到res后；\r\n遇到数字，计算multi；\r\n遇到左括号，将[multi，res]入栈，并重置multi，res；\r\n遇到右括号，出栈并进行拼接：将当前字符串乘上multi，拼接至之前字符串后。\r\n\r\nthinking: 因为遇到括号嵌套时，需要从内向外解码，即需要先入后出，因而想到用栈。值得注意的是，并非无脑入栈。手动解码的过程是先乘再拼接，因此入栈也是保存 [ 当前的倍数，待拼接的之前字符串 ]。\r\n\r\n### 代码\r\n    def decodeString(self, s: str) -> str:\r\n        stack,multi,res=[],0,''\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi=10*multi+int(c)\r\n            elif c=='[':\r\n                stack.append([multi,res])\r\n                multi,res=0,''\r\n            elif c==']':\r\n                curr_multi,last_res=stack.pop()\r\n                res=last_res+curr_multi*res\r\n            else:\r\n                res+=c\r\n        return res\r\n### 复杂度\r\n时间 O(N) \r\n空间 O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088870974","body":"### 思路\r\n入队：新的元素总是压入stack1栈顶，第一个进入的元素赋值给记录队首元素的front变量。\r\n出队：当stack2为空，将stack1内元素全部弹出，再压入stack2。若非空，则直接返回stack2栈顶元素。\r\n取队首元素：若stack2非空，返回stack2栈顶元素值。否则返回front变量值。\r\n### 代码\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n        self.front=None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.stack1:\r\n            self.front=x\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            return self.front\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n### 复杂度\r\n入队：时间O(1)    空间O(N)\r\n出队：平均时间复杂度O(1)    空间O(1)\r\n判空：时间O(1)    空间O(1)\r\n队首：时间O(1)    空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089631067","body":"### 思路    \r\nkey point: 每一段的最大值代表当前段。\r\n\r\n观察可得：每个“块”中max_val小于下一个“块”中min_val。\r\n因此我们可以想到维护一个单调递增栈，栈内存储每个“块”的max_val，最后栈的长度即为“块“的个数。\r\n\r\ndetail：当前元素大于等于栈顶元素，则入栈（暂时找到一个新分段），\r\n当前元素小于栈顶元素，则保留栈顶元素，将剩余元素中大于当前值的出栈。\r\n### 代码\r\n\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s=[]\r\n        for c in arr:\r\n            if s and c<s[-1]:\r\n                while len(s)>1 and s[-2]>c:\r\n                    s.pop(-2)\r\n            else:\r\n                s.append(c)\r\n        return len(s)\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091035172","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k==0 or not head or not head.next:\n            return head\n        p=head\n        n=1\n        while p.next:\n            p=p.next\n            n+=1\n        k%=n\n        if k==0:\n            return head\n        slow,fast=head,head\n        for _ in range(k):\n            fast=fast.next\n        while fast.next:\n            slow,fast=slow.next,fast.next\n        newHead=slow.next\n        slow.next=None\n        fast.next=head\n        return newHead","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092471974","body":"\r\n    def swapPairs(self, head) :\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        newhead=head.next\r\n        head.next=self.swapPairs(newhead.next)\r\n        newhead.next=head\r\n        \r\n        return newhead","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072035","body":"\r\n    def sortedListToBST(self, head):\r\n        def findmid(head,tail):\r\n            slow,fast=head,head\r\n            while fast!=tail and fast.next!=tail:\r\n                fast=fast.next.next\r\n                slow=slow.next\r\n            return slow\r\n        def helper(head,tail):\r\n            if head==tail:return\r\n            node=findmid(head,tail)\r\n            root=TreeNode(node.val)\r\n            root.left=helper(head,node)\r\n            root.right=helper(node.next,tail)\r\n            return root\r\n        return helper(head,None)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094179996","body":"### 思路\r\n设链表A长度为a，链表B长度为b，假设相交部分长度为c，则a+b-c==b+a-c，所以只需同时移动两个指针，移到链表结束则到另一个链表头。如果不存在相交部分，则a+b==b+a，同样在经过指针移动后，最后都到达空节点，返回空节点。\r\n\r\n***注意点：只需p1不为空节点就移到下一个节点（不要求p1.next非空），这样两个链表没有相交部分时，才能最终同时到达空节点。\r\n### 代码\r\n    def getIntersectionNode(self, headA, headB):\r\n        p1, p2=headA, headB\r\n        while p1!= p2:\r\n            p1= p1.next if p1 else headB\r\n            p2= p2.next if p2 else headA\r\n        return p1\r\n### 复杂度\r\n时间 o(n) 其中n为链表长度\r\n空间 o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095223253","body":"\r\n    def detectCycle(self, head):\r\n        if not head or not head.next:\r\n            return None\r\n            \r\n        slow,fast=head,head\r\n        flag=True\r\n        while flag or fast!=slow:\r\n            if fast and fast.next:\r\n                flag=False                \r\n                slow,fast=slow.next,fast.next.next\r\n            else:\r\n                return None\r\n\r\n        fast=head\r\n        while fast!=slow:\r\n            fast,slow=fast.next,slow.next\r\n        return slow\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096907955","body":"    class DLinkedNode:\r\n        def __init__(self,key=0,value=0):\r\n            self.key=key\r\n            self.value=value\r\n            self.prev=None\r\n            self.next=None\r\n\r\n    class LRUCache:\r\n        def __init__(self, capacity: int):\r\n            self.cache=dict()\r\n            self.head=DLinkedNode()\r\n            self.tail=DLinkedNode()\r\n            self.head.next=self.tail\r\n            self.tail.prev=self.head\r\n            self.size=0\r\n            self.capacity=capacity\r\n\r\n        def get(self, key: int) -> int:\r\n            if key not in self.cache:\r\n                return -1\r\n            node=self.cache[key]\r\n            self.movetohead(node)\r\n            return node.value\r\n\r\n        def put(self, key: int, value: int) -> None:\r\n            if key in self.cache:\r\n                node=self.cache[key]\r\n                node.value=value\r\n                self.movetohead(node)\r\n            else:\r\n                if self.size==self.capacity:\r\n                    removed=self.removetail()\r\n                    self.cache.pop(removed.key)\r\n                    self.size-=1\r\n                newNode=DLinkedNode(key,value)\r\n                self.cache[key]=newNode\r\n                self.addtohead(newNode)\r\n                self.size+=1\r\n\r\n        def removetail(self):\r\n            last=self.tail.prev\r\n            self.removenode(last)\r\n            return last\r\n\r\n        def movetohead(self,node):\r\n            self.removenode(node)\r\n            self.addtohead(node)\r\n\r\n        def addtohead(self,node):\r\n            node.next=self.head.next\r\n            self.head.next=node\r\n            node.prev=self.head\r\n            node.next.prev=node\r\n\r\n        def removenode(self,node):\r\n            node.prev.next=node.next\r\n            node.next.prev=node.prev","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098214498","body":"\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        left_depth=self.maxDepth(root.left)\n        right_depth=self.maxDepth(root.right)\n        return max(left_depth,right_depth)+1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098774404","body":"### 思路\r\n递归比较p,q的值，ans为false的两种情况：其中一个为空，另一个非空；p,q值不等。\r\n### 代码\r\n    class Solution:\r\n        ans=True\r\n        def isSameTree(self, p, q) :\r\n            def helper(p,q):\r\n                if not p and not q:\r\n                    return\r\n                if not p or not q:\r\n                    self.ans=False\r\n                    return\r\n                if p.val==q.val:\r\n                    helper(p.left,q.left)\r\n                    helper(p.right,q.right)            \r\n                else:\r\n                    self.ans=False\r\n\r\n            helper(p,q)\r\n            return self.ans\r\n### 复杂度\r\n时间 o(n)\r\n空间o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099816817","body":"\n    def sumNumbers(self, root) :\n        ans=[]\n        tmp=0\n        def dfs(root, tmp):\n            if not (root.left or root.right):\n                ans.append(10* tmp+ root.val)\n                return\n\n            if root.left:\n                dfs(root.left,10* tmp+ root.val)\n\n            if root.right:\n                dfs(root.right,10* tmp+ root.val)\n\n        dfs(root, tmp)\n        return sum( ans )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100202358","body":"### 思路 \r\nbfs，唯一特殊一些的地方在于，入队顺序是先右孩子再左孩子。\r\n\r\n### 代码\r\n        def findBottomLeftValue(self, root):\r\n\r\n            queue=deque()\r\n            queue.append(root)\r\n            n=len(queue)\r\n\r\n            while queue:\r\n                for _ in range(n):\r\n                    node=queue.popleft()\r\n                    tmp=node.val\r\n\r\n                    if node.right:\r\n                        queue.append(node.right)\r\n                    if node.left:\r\n                        queue.append(node.left)\r\n                    \r\n        return tmp\r\n### 复杂度\r\n时间o(n) \r\n空间 o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100905949","body":"\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return 'None'\n        return str(root.val) + ',' + str(self.serialize(root.left)) + ',' + str(self.serialize(root.right))\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs(dataList):\n            val = dataList.pop(0)\n            if val == 'None':\n                return None\n            root = TreeNode(int(val))\n            root.left = dfs(dataList)\n            root.right = dfs(dataList)\n            return root\n\n        dataList = data.split(',')\n        return dfs(dataList)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101518759","body":"\n    def verticalTraversal(self, root) :\n        nodes = list()\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node:\n                return\n\n            nodes.append((col, row, node.val))\n            dfs(node.left, row + 1, col - 1)\n            dfs(node.right, row + 1, col + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = list(), float(\"-inf\")\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n        \n        return ans\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102039168","body":"### 思路\r\n构造哈希表，key是数值，value是数值的位置。遍历数组，如果target- num已经在哈希表中，则return。若不在，放入哈希表。\r\n### 代码\r\n    def twoSum(self, nums, target):\r\n\r\n        map=dict()\r\n        for i in range(len(nums)):\r\n            rest=target-nums[i]\r\n            if rest in map:\r\n                return [map[rest],i]\r\n            else:\r\n                map[nums[i]]=i\r\n### 复杂度\r\n时间 o(n) 遍历数组一次\r\n空间 o(n) 哈希表占用o(n)空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104081182","body":"### 思路\r\n首先建立每个数值与出现频次的哈希表，接着建立大小为k+1的小顶堆（为了方便位操作，有一个占位节点）。然后遍历剩余元素，若频次大于堆顶，则入堆并调整堆，使堆始终满足小顶堆。最后返回堆内元素的数值。\r\n### 代码\r\n    def topKFrequent(self, nums, k):\r\n        def sift_up(arr,child):\r\n            val=arr[child]\r\n            while child>>1>0 and arr[child>>1][1]>val[1]:\r\n                arr[child]=arr[child>>1]\r\n                child>>=1\r\n            arr[child]=val\r\n\r\n        def sift_down(heap,root,heap_len):\r\n            \r\n            val=heap[root]\r\n            while root<<1<heap_len:\r\n                child=root<<1\r\n                if child|1<heap_len and heap[child|1][1]<heap[child][1]:\r\n                    child|=1\r\n                if val[1]>heap[child][1]:\r\n                    heap[root]=heap[child]\r\n                    root=child\r\n                else:break\r\n            heap[root]=val\r\n        map=collections.Counter(nums)\r\n        arr=list(map.items())\r\n        heap=[(0,0)]\r\n        for i in range(k):\r\n            heap.append(arr[i])\r\n            sift_up(heap,len(heap)-1)\r\n        for i in range(k,len(arr)):\r\n            if arr[i][1]>heap[1][1]:\r\n                heap[1]=arr[i]\r\n                sift_down(heap,1,k+1)\r\n        return [item[0] for item in heap[1:]]\r\n### 复杂度\r\n时间 o(nlogk)\r\n空间 o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105405288","body":"\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106643112","body":"\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen=set()\n        cur_length,max_length=0,0\n        left=0\n        for i in range(len(s)):\n            while s[i] in seen:\n                seen.remove(s[left])\n                left+=1\n                cur_length-=1\n            seen.add(s[i])\n            cur_length+=1\n            max_length=max(cur_length,max_length)\n        return max_length","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107525609","body":"\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        all_len = sum(map(len, words))\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, n - all_len + 1):\n            tmp = s[i:i+all_len]\n            flag = True\n            for key in words:\n                if words[key] != tmp.count(key):\n                    flag = False\n                    break\n            if flag:res.append(i)\n        return res\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108751455","body":"\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow,fast=head,head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109949374","body":"\n    def removeDuplicates(self, nums: List[int]) -> int:\n        left=0\n        right=1\n        while right<len(nums):\n            if nums[left]==nums[right]:\n                right+=1\n            else:\n                nums[left+1]=nums[right]\n                left+=1\n                right+=1\n        return left+1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111170066","body":"\n    def searchInsert(self, nums, target):\n\n        left=0\n        right=len(nums)-1\n        \n        while left<=right:\n            mid=(left+right)//2\n            if nums[mid]==target:\n                return mid\n            elif nums[mid]<target:\n                left=mid+1\n            else:\n                right=mid-1\n\n        return left","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112369069","body":"\n    def maxSlidingWindow(self, nums, k) :\n        n = len(nums)\n        q = collections.deque()\n        for i in range(k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n\n        ans = [nums[q[0]]]\n        for i in range(k, n):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            while q[0] <= i - k:\n                q.popleft()\n            ans.append(nums[q[0]])\n        \n        return ans\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113469499","body":"\n    def findJudge(self, n, trust) :\n        inDegrees = Counter(y for _, y in trust)\n        outDegrees = Counter(x for x, _ in trust)\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085464204","body":"## 思路\n低位往高位加。\n进位放到k里处理。\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resultSta = new ArrayList<>();\n        \n        //进位放到k里处理\n        for(int i=num.length-1; i>=0;i--){\n\n            int sum =  num[i] +k%10;\n            k = k/10;\n\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n\n\n            resultSta.add(sum);\n        }\n\n        while(k!=0){\n            resultSta.add(k%10);\n            k = k/10;\n        }\n\n        Collections.reverse(resultSta);\n        return resultSta;\n    }\n}\n```\n\n## 复杂度\n时间：o(n+k)\n控件：o(n+k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558958","body":"## 思路\n同时正向和反向遍历\n## code\n```java\nclass Solution {\n    //同时正向和反向遍历\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        for(int i=0;i<s.length();i++){\n            int head = i;\n            int tail = i;\n            while(true){\n                if(head>=0 && s.charAt(head) == c) break;\n                if(tail<s.length() && s.charAt(tail) == c) break;\n                head--;\n                tail++;\n            }\n            result[i] = (i-head)<(tail-i)?(i-head):(tail-i);\n        }\n        return result; \n\n    }\n}\n```\n\n## 复杂度\n时间：o(n^2)\n空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885319","body":"```java\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087732939","body":"##思路  \n\n双栈，存放数组和字符串\n\n\n##code\n```java\npublic String decodeString(String s) {\n    Deque<Integer> stack_digit = new LinkedList<>();\n    Deque<StringBuilder> stack_string = new LinkedList<>();\n    int digit = 0;\n    StringBuilder res = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n        char ch = s.charAt(i);\n        if (ch == '[') {\n            stack_digit.push(digit);\n            stack_string.push(res);\n            digit = 0;\n            res = new StringBuilder();\n        }else if (ch == ']') {\n            StringBuilder temp = stack_string.poll();\n            int count = stack_digit.poll();\n            for (int j = 0; j < count; j++) {\n                temp.append(res.toString());\n            }\n            res = temp;\n        }else if (Character.isDigit(ch)) {\n            digit = digit*10 + ch - '0';\n        }else {\n            res.append(ch);\n        }\n    }\n    return res.toString();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088814153","body":"## 思路 \n双栈  \npush：先检查pop栈中是否有元素，如果有，先倒到push栈再进行新元素的push操作  \npop：先检查push栈中是否有元素，如果有，先倒到pop栈再进行新元素的pop操作  \n\n## 代码\n```java\nclass MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}\n```\n\n## 复杂度  \n空间：O(n)  \n时间：O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090425231","body":"## 思路  \n单调栈，记录每个区块的最大值\n\n## code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n## 复杂度  \n时间：O(N)   \n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1092444456","body":"## 思路  \n- 遍历链表得出节点数listNum  \n- 首尾相接，在第listNum - k%listNum 处断开\n## code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        //遍历链表得出节点数listNum\n        //首尾相接，在第listNum - k%listNum 处断开\n        if(head == null) return null;\n        int listNum = 1;\n        ListNode temp = head;\n        while(temp.next != null){\n            temp = temp.next;\n            listNum++;\n        }\n        //System.out.println(\"listNum: \" + listNum);\n\n        temp.next = head;\n\n        int newHeadIndex = listNum - k%listNum;\n        //System.out.println(\"newHeadIndex: \" + newHeadIndex);\n        temp = head;\n        for(int i=1; i<newHeadIndex; i++){\n            temp = temp.next;\n        }\n        head = temp.next;\n        temp.next = null;\n        //System.out.println(\"newHeadValue: \" + head.val);\n        return head;\n    }\n}\n```   \n## 复杂度  \n时间：O(N)  \n空间：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092714169","body":"## 思路\n虚拟头，遍历，指针操作  \n\n## code\n```java \npublic ListNode swapPairs(ListNode head) {\n    //三个节点ABC之间的指针操作(涉及四个节点，但是最后一个节点只是被指,可以用C.next替代)\n    //算法专注三个节点间的操作，补充虚拟头节点\n\n    if(head==null || head.next == null) return head;\n\n    //构造虚拟头\n    ListNode preHead = new ListNode(-1,head);\n\n    //init A B C\n    ListNode A,B,C;\n    A = preHead;\n    B = A.next;\n    C = B.next;\n\n    while(true){\n        //System.out.println(\"B: \"+B.val+\", C: \"+C.val);\n        //BC交换\n        B.next = C.next;\n        C.next = B;\n        A.next = C;\n\n        //指针后移\n        A = B;\n        if(A.next !=null && A.next.next !=null){\n            B = A.next;\n            C = B.next;\n        }else{\n            break;\n        }\n    }\n    return preHead.next;\n}\n```\n\n## 复杂度  \n空间：O(1)  \n时间：O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072957","body":"## 思路  \n快慢指针，分割，递归\n\n## Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        ListNode fast = head, slow = head, pre = null;\n        while(fast != null && fast.next != null){\n            fast =  fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        pre.next = null;\n        ListNode rightList = slow.next;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rightList);\n        return root;\n    }\n}\n```   \n\n## 复杂度  \n时间：O(nlogn)     \n空间：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094299698","body":"## 思路\nHashMap，两个链表同时遍历，put时key如果相同就返回此节点\n## code\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        HashMap<ListNode,Integer> map = new HashMap<>();\n        while(headA != null || headB != null){\n            if(headA != null && map.put(headA,0)!=null){\n                return headA;\n            }else if(headB != null && map.put(headB,0)!=null){\n                return headB;\n            }else {\n                headA = headA==null?null: headA.next;\n                headB = headB==null?null: headB.next;\n                if(headA==null && headB==null){\n                    break;\n                }\n            }\n            \n        }\n        return null;\n    }\n}\n```\n## 复杂度\n时间：O(n)  \n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095231353","body":"## 思路\n快慢指针，相遇后快指针从头开始\n\n## code\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098716331","body":"## 思路\n同时DFS\n## code\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null){\n            return true;\n        }else if((p!=null && q!=null)&&p.val == q.val) {\n            return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n        }else{ \n            return false;\n        }\n    }\n}\n```\n## 复杂度\n时间：O(logn)  \n空间：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101519936","body":"## 思路\nDFS + 排序\n\n## code\n```java\nclass Solution {\n    Map<Integer, Map<Integer, List<Integer>>> hashmap;\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        hashmap = new HashMap<>();\n        dfs(root, 0, 0);\n\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> tmp = new ArrayList<>();\n        List<Integer> js = new ArrayList(hashmap.keySet());\n        Collections.sort(js);\n        for(Integer j : js){\n            tmp = new ArrayList<>();\n            Map<Integer, List<Integer>> map = hashmap.get(j);\n            List<Integer> is = new ArrayList(map.keySet());\n            Collections.sort(is);\n            for(Integer i : is){\n                List<Integer> values = map.get(i);\n                Collections.sort(values);\n                tmp.addAll(values);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n    private void dfs(TreeNode node, int j, int i){\n        if(node == null){\n            return;\n        }\n        if(!hashmap.containsKey(j)){\n            hashmap.put(j, new HashMap<>());\n        }\n        if(!hashmap.get(j).containsKey(i)){\n            hashmap.get(j).put(i, new ArrayList<>());\n        }\n        hashmap.get(j).get(i).add(node.val);\n        dfs(node.left, j - 1, i + 1);\n        dfs(node.right, j + 1, i + 1);\n    }\n}\n```\n\n## 复杂度\n时间：O(NlogN)  \n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102057593","body":"## 思路\nhashMap\n## code\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map = new HashMap<Integer,Integer>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{map.get(target-nums[i]),i};\n            }else{\n                map.put(nums[i],i);\n            }\n        }\n        return null;\n    }\n}\n```\n## 复杂度\n时间：O(n)  \n空间：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105410320","body":"## 思路\nhashmap存表，A(n,2)计算个数\n\n## code\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int result = 0;\n        for (int i = 0; i < points.length; i++) {\n            Set<Integer> set = new HashSet<>();\n            Map<Integer,Integer> map = new HashMap<>();\n            for (int j = 0;j< points.length;j++){\n                if (i==j){\n                    continue;\n                }\n                int x = points[j][0] - points[i][0];\n                int y = points[j][1] - points[i][1];\n                if (!set.add((x*x)+(y*y))){\n                    if (map.get((x*x)+(y*y))==null){\n                        map.put((x*x)+(y*y),2);\n                    }else {\n                        map.put((x*x)+(y*y),map.get((x*x)+(y*y))+1);\n                    }\n                }\n            }\n            for (Integer value : map.values()) {\n                result += (value*(value-1));\n            }\n        }\n        return result;\n    }\n}\n```\n\n## 复杂度\n时间：O(n^2)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105464287","body":"## 思路\n滑动窗口，但是deque表示\n\n## code\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Deque<Character> deque = new  LinkedList<Character>();\n        int length = 0;\n        for(int i=0;i<s.length();i++){\n            char c  = s.charAt(i);\n            //System.out.println(\"c = \" + c + \", deque = \" + deque);\n            while(deque.contains(c)){\n                if(deque.size()>length){length = deque.size();}\n                deque.removeFirst();\n            }\n            deque.addLast(c);\n        }\n        if(deque.size()>length){length = deque.size();}\n        return length;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107524237","body":"## 思路\n滑动窗口\n## code\n```java\nclass Solution {\n    //滑动窗口\n    //滑动窗口的窗长：数组中字串的长度和\n    //针对一个窗口内的字串，以word的长度分割。分割出的字串如果和word数组里的完全匹配则找到一个index\n    public List<Integer> findSubstring(String s, String[] words) {\n        int windowLength = words.length * words[0].length() ;\n        List<String> list = new ArrayList<>(Arrays.asList(words));\n        //System.out.println(\"list: \" + list);\n        List<Integer> result  = new ArrayList<Integer>();\n        for(int index = 0; (index + windowLength) <= s.length(); index++){\n            for(int i = 0 ;i<words.length;i++){\n                int start = index + i*words[0].length();\n                int end = index + i*words[0].length() + words[0].length();\n                String temp = s.substring(start, end);\n                //System.out.println(\"[\"+start+\",\"+end+\"), : \" + temp);\n                if(!list.remove(temp)){\n                    //System.out.println(\"not contain,break! \");\n                    break;\n                }\n            }\n            if(list.isEmpty()){\n                result.add(index);\n            }\n            list.clear();\n            list.addAll(Arrays.asList(words));\n        }\n        return result;\n    }\n}\n```\n## 复杂度\n时间：O(N*M)  \n空间：O(M)   \nM为wrod数组长度","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109348556","body":"## 思路\n双指针 \n## code\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int size = nums.length;\n        int i=0,j =0;\n\n        for (j=1;j<=size-1;j++){\n            if(nums[i]<nums[j]){\n                nums[i+1]=nums[j];\n                i= i+1;\n            }\n        }\n        return i+1;\n\n    }\n}\n```\n## 复杂度\n时间：O(n)    \n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carrieyqzhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085470672","body":"### 思路\r\n从个位数求两数之和，carry= 1 如果sum大于10.\r\nsum % 10 得到的结果就是当位数的值\r\nwhile 结束loop如果num[]里没有元素，而且k 等于0\r\n\r\n### 代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length -1;\r\n        while (l1 >= 0 || k != 0){\r\n            int a = l1 < 0 ? 0 : num[l1]; //get last element in num[]\r\n            int b = k <= 0 ? 0 : k % 10; //get last digit in k            \r\n            int sum = a + b + carry;\r\n            res.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            l1--;\r\n            k /= 10;\r\n        }\r\n        if (carry != 0) res.add(0,carry);\r\n    \r\n        return res;     \r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667323","body":"### 思路\n左右遍历一遍\n\n### 代码\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] out_arr = new int[n];\n        int cPos = -n;\n        \n        for(int i =0; i <n; i++){\n            if(s.charAt(i) == c){\n                cPos = i;\n            }\n            out_arr[i] = i - cPos;\n        }\n        for(int i = n-1; i >=0; i--){\n            if(s.charAt(i) == c){\n                cPos = i;\n                \n            }\n            out_arr[i] = Math.min(out_arr[i], Math.abs(i-cPos));\n        }\n        return out_arr;\n        \n    }\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086790288","body":"### 思路\n用stack实现CustomStack\ninc[] 用来存储increment value,每pop一个值，加上inc[i]的值返回，inc[i-1]=inc[i],以便后面pop时可以加上increment value值\n\n### 代码\n\n```Java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        if( stack.size() < n){\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0 )return -1;\n        if(i > 0){\n            inc[i-1] += inc[i]; //store the increment value for bottom use\n        }\n        int res = stack.pop() + inc[i];\n        inc[i] = 0; //set current increment to 0 since its poped\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val; //inc[i] means increment val for all stack[0]-> stack[i]\n        \n    }\n}\n\n```\n\n时间/空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087146894","body":"### 思路\n用栈存所有不是】的character， 等遇到后括号开始pop存在栈里characters, 遇到数字就append multiple times of substr\n\n### code\n\n``` python\ndef decodeString(self, s: str) -> str:\n        stack = []\n        \n        for i in range(len(s)):\n            if s[i] != \"]\":\n                stack.append(s[i])\n            else:\n                substr = \"\"\n                while stack[-1] != \"[\":\n                    substr = stack.pop() + substr\n                stack.pop()\n                    \n                k = \"\"\n                while stack and stack[-1].isdigit():\n                    k = stack.pop() + k\n                stack.append(int(k) * substr)\n                    \n        return \"\".join(stack)\n```\n\n时间空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088282981","body":"### 思路\n\n用两个栈来实现，push的时候用input stack, pop的时候如果output栈有元素，直接pop,如果为空，把input栈所有元素push到output栈再pop\npeek()也先检查output栈是否为空，不为空直接peek,空的话把input栈所有元素push到output栈再peek\n如果两个栈都为空的话那么empty（）返回空\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Stack<Integer> input;\n    Stack<Integer> output;\n\n    public MyQueue() {\n        input = new Stack<>();\n        output = new Stack<>();\n        \n    }\n    \n    public void push(int x) {\n        input.push(x);\n        \n    }\n    \n    public int pop() {\n        if(output.isEmpty()){   //must check if it's empty   \n            while(!input.isEmpty()){\n                output.push(input.pop());\n            }     \n        }\n          return output.pop();\n        \n    }\n    \n    public int peek() {\n        if(output.isEmpty()){//must check empty\n            while(!input.isEmpty()){\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return output.isEmpty() && input.isEmpty();\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089838566","body":"### 思路\n\n//在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块。\n//如果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块(保持栈的单调递增)。\n\n### 代码\n\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n         LinkedList<Integer> stack = new LinkedList<>();\n        for(int i = 0; i < arr.length; i++){\n            if(!stack.isEmpty() && arr[i] < stack.getLast()){\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && arr[i] < stack.getLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            }else{\n                stack.addLast(arr[i]);\n            }\n            \n        }\n        return stack.size();\n\n        \n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091086383","body":"### 思路\n1.求size, tail\n2.找到cutoff节点，用curr node标记第一段最后一个node\n3. swap 两段位置： \n        tail.next = head; \n        head = curr.next; //new head \n        curr.next = null;\n\n### 代码\n\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        //edge case check\n        if(head == null) return head;\n\n        ListNode tail = head;\n        int size = 1;\n        while(tail.next != null){\n            tail = tail.next;\n            size++;\n        }\n\n        //k might be greater than size\n        k = k % size;\n\n        ListNode curr = head;\n        int n = 0;\n        while(n < size-k-1){\n            curr = curr.next;\n            n++;\n        }\n       \n        tail.next = head; \n        head = curr.next; //new head \n        curr.next = null;\n\n        return head;\n   \n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092474755","body":"### 思路\n两两swap，用while循环\n\n### 代码\n\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n\n        //add a dummyhead\n        ListNode dummyhead = new ListNode();\n        dummyhead.next = head;\n\n        //create a temp node to traverse the list\n        ListNode temp = dummyhead;\n\n        //at least two nodes in the list to start with\n        while(temp.next != null && temp.next.next != null){\n            //swap temp.next and temp.next.next\n            //step 1: find the two nodes\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n\n            //step 2: start swap\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n\n            //step 3: now temp points to temp.next.next\n            temp = node1;\n        \n        }\n\n        return dummyhead.next;\n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093725398","body":"### 思路\n    recursive method to create tree -> sortedListBST(ListNode head)\n        - if head = null, return null\n        - find mid Node: call getMid(head)\n        - create root with value of mid.val\n        - if head = mid, just return root\n        - root.left = recursive call sortedListToBST(head)\n        - root.right = recursive call sortedListToBST(mid.next)\n\n    Find mid and break previous links ->getMid(ListNode head)\n        - initialize slow, fast, prev to head\n        - while (fast not null && fast.next not null)\n            - prev = slow;\n            -slow = slow.next;\n            - fast = fast.next.next;\n        -break the link if prev != null\n        -return slow    \n\n### 代码\n\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n\n        if(head == null) return null;\n\n        ListNode mid = getMid(head);\n        TreeNode root = new TreeNode(mid.val);\n\n        if(head == mid)\n            return root;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(mid.next);\n        return root;       \n    }\n\n    public ListNode getMid(ListNode head){\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode prev = head;\n        while(fast != null && fast.next != null){\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        //break the link before the mid point\n        if(prev != null)\n            prev.next = null;\n        return slow;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094186296","body":"### 思路\n\n定义两个指针l1, l2,分别指向headA, headB\n     - while l1, l2的值不等，既没有焦点：\n           1. l1 not null, go to next node, else go to the other list head\n           2. l1 not null, go to next node, else go to the other list head\n    - loop breaks, return l1\nlogic: nodes of headA + nodes of headB = nodes of headB + nodes of headA, 所以注定会相遇，要么在末尾null, 要么在中途某个node\n\n\n\n### 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n\n        ListNode l1 = headA;\n        ListNode l2 = headB;\n\n        while( l1 != l2){\n            l1 = l1 == null ? headB : l1.next;\n            l2 = l2 == null ? headA : l2.next;\n        }\n        return l1;      \n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N + M),  两个链表的长度\n- 空间复杂度：O(1)， 只有指针移动","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094609100","body":"```Java\npublic ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096093999","body":"```Java\r\npublic class LRUCache {\r\n    HashMap<Integer, Node> map;\r\n    DoubleLinkedList cache;\r\n    int cap;\r\n    public LRUCache(int capacity){\r\n        map   = new HashMap<>();\r\n        cache = new DoubleLinkedList();\r\n        cap   = capacity;\r\n    }\r\n    \r\n    public void put(int key, int val){\r\n        Node newNode = new Node(key, val);\r\n        \r\n        if(map.containsKey(key)){\r\n            cache.delete(map.get(key));\r\n            cache.addFirst(newNode);\r\n            map.put(key, newNode);\r\n        }else{\r\n            if(map.size() == cap){\r\n                int k = cache.deleteLast();\r\n                map.remove(k);\r\n            }\r\n            cache.addFirst(newNode);\r\n            map.put(key, newNode);\r\n            \r\n        }\r\n    }\r\n    \r\n    public int get(int key){\r\n        if(!map.containsKey(key))   return -1;\r\n        \r\n        int val = map.get(key).val;\r\n        put(key, val);\r\n        \r\n        return val;\r\n    }\r\n}\r\n\r\n/**\r\n *  head: recently used\r\n *  tail: LRU\r\n */\r\nclass DoubleLinkedList{\r\n    Node head;\r\n    Node tail;\r\n\r\n    public DoubleLinkedList(){\r\n        head = new Node(0,0);\r\n        tail = new Node(0,0);\r\n\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public void addFirst(Node node){\r\n\r\n        node.next   = head.next;\r\n        node.prev   = head;\r\n\r\n        head.next.prev = node;\r\n        head.next      = node;\r\n    }\r\n\r\n    public int delete(Node n){\r\n        int key = n.key;\r\n        n.next.prev = n.prev;\r\n        n.prev.next = n.next;\r\n        \r\n        return key;\r\n    }\r\n\r\n    public int deleteLast(){\r\n        if(head.next == tail)   return -1;\r\n\r\n        return delete(tail.prev);\r\n    }\r\n}\r\n\r\nclass Node{\r\n    public int key;\r\n    public int val;\r\n    public Node prev;\r\n    public Node next;\r\n\r\n    public Node(int key, int val){\r\n        this.key = key;\r\n        this.val = val;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097577437","body":"### \nrecursion: keep searching left and right child, if null, retun null; else compare left and right return max + 1\n\n### code\n``` Java\npublic int maxDepth(TreeNode root) {\n        if(root == null)\n            return 0;\n\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n\n        return Math.max(left, right)+1;\n    }\n```\ntime complexity: O(n)\nspace complexity: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098755272","body":"``` Java\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if(q == null && p == null) {\n            return true;\n        }else if(q == null || p == null){\n            return false;\n        }else if(q.val != p.val) {\n            return false;\n        }else{\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n        \n    }\n```\ntime/space complexity: O(min(m,n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099864312","body":"``` Java\npublic int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int preSum){\n        if(root == null) return 0;\n        int sum = preSum * 10 + root.val;\n        if(root.left == null && root.right == null){\n            return sum;\n        }else{\n            return dfs(root.left, sum) + dfs(root.right,sum);\n        }\n    }\n```\ntime/space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100575935","body":"``` Java\nint left = 0;\n    int maxDepth = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 1);\n        return left;\n    }\n\n    public void dfs(TreeNode root, int curDepth)\n    {\n        if(root == null)\n            return;\n        left = curDepth > maxDepth ? root.val : left;\n        maxDepth = Math.max(curDepth, maxDepth); \n        dfs(root.left, curDepth + 1);\n        dfs(root.right, curDepth + 1);\n    }\n```\ntime/space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100815578","body":"```Java\n// Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null)\n            return \"N\";\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n\n\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n         Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return helper(queue);\n\n\n    }\n     private TreeNode helper(Queue<String> queue) {\n        //出队\n        String sVal = queue.poll();\n        //如果是\"N\"表示空节点\n        if (\"N\".equals(sVal))\n            return null;\n        //否则创建当前节点\n        TreeNode root = new TreeNode(Integer.valueOf(sVal));\n        //分别创建左子树和右子树\n        root.left = helper(queue);\n        root.right = helper(queue);\n        return root;\n    }\n```\ntime/space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101092690","body":"``` Java\npublic List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n```\ntime complexity: O(nlogn)\nspace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102116531","body":"``` Java\n  public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n```\ntime/space complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103532150","body":"``` Java\npublic int[] topKFrequent(int[] nums, int k) {\n        //特判\n        if(nums==null||nums.length==0){\n            return null;\n        }\n        Map<Integer,Integer> map =new HashMap<>( );\n        for(int i=0;i<nums.length;i++){\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\n        }\n        PriorityQueue <Map.Entry<Integer,Integer>> queue =new PriorityQueue<>(k,(x1,x2)->x2.getValue().compareTo(x1.getValue()));//大顶堆\n        for(Map.Entry entry:map.entrySet()){\n            queue.add(entry);\n        }\n        int []res=new int [k];\n        for(int i=0;i<k;i++){\n            res[i]=queue.poll().getKey();\n        }\n        return res;\n    }\n```\ntime complexity: O(nlogk)\nspace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104689889","body":"``` Java\npublic int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0], y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for (int dist : map.keySet()) {\n                int cnt = map.get(dist);\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n```\ntime complexity: O(N^2)\nspace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106062366","body":"``` Java\npublic int lengthOfLongestSubstring(String s) {\n        if (s.length()==0) return 0;\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n        int max = 0;\n        int left = 0;\n        for(int i = 0; i < s.length(); i ++){\n            if(map.containsKey(s.charAt(i))){\n                left = Math.max(left,map.get(s.charAt(i)) + 1);\n            }\n            map.put(s.charAt(i),i);\n            max = Math.max(max,i-left+1);\n        }\n        return max;\n        \n    }\n\n```\ntime/space complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107388337","body":"``` Java\npublic List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        if (s == null || s.length() == 0 || words == null || words.length == 0) return res;\n        HashMap<String, Integer> map = new HashMap<>();\n        int one_word = words[0].length();\n        int word_num = words.length;\n        int all_len = one_word * word_num;\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        for (int i = 0; i < s.length() - all_len + 1; i++) {\n            String tmp = s.substring(i, i + all_len);\n            HashMap<String, Integer> tmp_map = new HashMap<>();\n            for (int j = 0; j < all_len; j += one_word) {\n                String w = tmp.substring(j, j + one_word);\n                tmp_map.put(w, tmp_map.getOrDefault(w, 0) + 1);\n            }\n            if (map.equals(tmp_map)) res.add(i);\n        }\n        return res;\n    }\n```\ntime/space complexity: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085485310","body":"/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let len = num.length-1;\n    while(len>=0&&k>0){\n        const sum = k+num[len]\n        num[len] = sum%10\n        k=~~(sum/10)\n        len--\n    }\n    if(k>0) return [...k.toString().split(''),...num]\n    return num\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770679","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.queue = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.queue.length<this.maxSize) this.queue.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.queue.length==0) return -1;\n    return this.queue.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<this.queue.length;i++)this.queue[i] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090157685","body":"```js\r\n/**\r\n\r\n@param {number[]} arr\r\n\r\n@return {number}\r\n*/\r\nvar maxChunksToSorted = function (arr) {\r\nconst sorted = [...arr];\r\nsorted.sort((a, b) => a - b);\r\n\r\nlet count = 0,\r\nsum1 = 0,\r\nsum2 = 0;\r\n\r\nfor (let i = 0; i < arr.length; i++) {\r\nsum1 += arr[i];\r\nsum2 += sorted[i];\r\n\r\n if (sum1 === sum2) {\r\n     count++;\r\n }\r\n}\r\n\r\nreturn count;\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091164409","body":"```js\n\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092441241","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let node = new ListNode('head')\n    node.next = head\n    let prev = node\n    let curr = node.next\n    let next = node.next.next\n    while(next) {\n        let nextNode = next.next\n        curr.next = nextNode\n        next.next = curr\n        prev.next = next\n        if(!nextNode) break\n        prev = curr\n        curr = nextNode\n        next = nextNode.next\n    }\n    return node.next\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094165256","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let left = headA,right=headB;\n    while(left||right){\n        if(left == right) return left;\n        if(!left) left=headB\n        else left=left.next\n        if(!right) right=headA\n        else right = right.next\n    }\n    return null\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094737266","body":"```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(!head) return null\n    let prev = head\n    let curr = head\n    while(curr) {\n        prev = prev.next\n        if(curr.next!=null){\n            curr = curr.next.next\n        }else{\n            return null\n        }\n        if(prev==curr){\n            let ptr = head;\n            while (ptr !== prev) {\n                ptr = ptr.next;\n                prev = prev.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096255793","body":"```js\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.max = capacity\n    this.cache = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let flag = this.cache.has(key)\n    if (flag) {\n        let value = this.cache.get(key)\n        this.cache.delete(key)\n        this.cache.set(key,value)\n    }\n    return flag?this.cache.get(key):-1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    let size = this.cache.size\n    let max = this.max\n    if(this.cache.has(key)) {\n        this.cache.delete(key)\n    }\n    this.cache.set(key,value)\n    while (this.cache.size>max) {\n        this.cache.delete(this.cache.keys().next().value)\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097626820","body":"```js\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(!root) return 0\n    let res = 0;\n    let deep = (root,index)=> {\n        if(!root.left && !root.right) {\n            res=Math.max(res,index)\n            return\n        }\n        if(root.left) deep(root.left,index+1)\n        if(root.right) deep(root.right,index+1)\n    }\n    deep(root,1)\n    return res\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098700707","body":"```js\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    let res = true;\n    let inorder = (p,q)=>{\n        if(!res) return\n        if(!p && q || p&&!q) {\n            res=false;\n            return;\n        }\n        else if(!p && !q){\n            return;\n        }else{\n            if(p.val!=q.val){\n                res=false;\n                return;\n            }\n            inorder(p.left,q.left);\n            inorder(p.right,q.right);\n        }\n    }\n    inorder(p,q)\n    return res\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099843200","body":"```js\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    let arr=[];\n    let source = (root,str)=>{\n        if(!root) return\n        str+=root.val\n        if(!root.left&&!root.right){\n            arr.push(str)\n        }else{\n            source(root.right,str)\n            source(root.left,str)\n        }\n    }\n    source(root,'')\n    let res = 0;\n    arr.forEach(item=>res+=1*item)\n    return res\n};\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101310504","body":"```js\n\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    const nodes = [];\n    dfs(root, 0, 0, nodes);\n    nodes.sort((tuple1, tuple2) => {\n        if (tuple1[0] !== tuple2[0]) {\n            return tuple1[0] - tuple2[0];\n        } else if (tuple1[1] !== tuple2[1]) {\n            return tuple1[1] - tuple2[1];\n        } else {\n            return tuple1[2] - tuple2[2];\n        }\n    });\n\n    const ans = [];\n    let lastcol = -Number.MAX_VALUE;\n    for (const tuple of nodes) {\n        let col = tuple[0], row = tuple[1], value = tuple[2];\n        if (col !== lastcol) {\n            lastcol = col;\n            ans.push([]);\n        }\n        ans[ans.length - 1].push(value);\n    }\n    return ans;\n}\n\nconst dfs = (node, row, col, nodes) => {\n    if (node === null) {\n        return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102029795","body":"```js\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let map = {}\n    let i =0\n    while(i<nums.length) {\n        let current = nums[i]\n        let sum = target-current\n        if(map[sum]>=0){\n            return [map[sum],i]\n        }else{\n           map[current] = i\n        }\n        i++\n    }\n    return\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103435974","body":"····js\n\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let map = {}\n    for (let i = 0; i < nums.length;i++) {\n        if(map[nums[i]]) {\n            map[nums[i]]++\n        }else {\n            map[nums[i]] = 1;\n        }\n    }\n    let arr = []\n    let keys = Object.keys(map)\n    for (let i = 0; i < keys.length;i++) {\n        arr.push({\n            key: keys[i],\n            value: map[keys[i]]\n        })\n    }\n    arr.sort((a,b) =>b.value-a.value)\n    console.log(arr)\n    return arr.map((item,index)=>{\n        if(index<k) { \n            return 1*item.key\n        }\n    }).slice(0,k)\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105131902","body":"```js\n\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (const p of points) {\n        const cnt = new Map();\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n        }\n    }\n    return ans;\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106369313","body":"```js\n\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    const length = s.length\n    const map = new Map();\n    let i=0,\n        j=0;\n    let ans = 0;\n    while (i<length && j<length) {\n        if (map.has(s[j]) && map.get(s[j])>=i) {\n            i=map.get(s[j])+1\n        }\n        ans = Math.max(j-i+1,ans)\n        map.set(s[j],j);\n        ++j;\n    }\n    return ans\n};\n\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108479782","body":"```js\n\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let A = [head];\n    while (A[A.length - 1].next != null)\n        A.push(A[A.length - 1].next);\n    return A[Math.trunc(A.length / 2)];\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109820703","body":"```js\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    let slow = 0;\n    let fast = 0;\n    let len = nums.length\n    while(++fast<len){\n        if(nums[slow]!=nums[fast]){\n            slow++\n            [nums[slow],nums[fast]]=[nums[fast],nums[slow]]\n        }\n    }\n    return slow+1\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110893503","body":"```js\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let i = 0\n    let len = nums.length-1\n    let res =nums.length;\n    while(i<=len) {\n        let mid = Math.floor((len-i)/2)+i\n        if(target<=nums[mid]){\n            res = mid;\n            len = mid-1;\n        }else {\n            i = mid+1;\n        }\n    }\n    return res;\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112342421","body":"```js\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    const n = nums.length;\n    const prefixMax = new Array(n).fill(0);\n    const suffixMax = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        if (i % k === 0) {\n            prefixMax[i] = nums[i];\n        } else {\n            prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);\n        }\n    }\n    for (let i = n - 1; i >= 0; --i) {\n        if (i === n || (i + 1) % k === 0) {\n            suffixMax[i] = nums[i];\n        } else {\n            suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);\n        }\n    }\n    const ans = [];\n    for (let i = 0; i < n - k + 1; i++) {\n        ans.push(Math.max(suffixMax[i], prefixMax[i + k - 1]));\n    }\n    return ans;\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113137619","body":"```js\n\n\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const inDegrees = new Array(n + 1).fill(0);\n    const outDegrees = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0], y = edge[1];\n        ++inDegrees[y];\n        ++outDegrees[x];\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n            return i;\n        }\n    }\n    return -1;\n};\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491089","body":"思路: 先把数组转换为正数,然后再把两个数相加，最后再把得到的整数转换为数组。 时间复杂度o(n), 空间复杂度O(n) , n取决于num 和结果数组的最大值。 \r\n```\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        number = self.convert_array_to_integer(num);\r\n        print(number)\r\n        sum_two_numbers = number + k\r\n        res = [];\r\n        while sum_two_numbers >= 10:\r\n            res.append(sum_two_numbers % 10);\r\n            sum_two_numbers = sum_two_numbers // 10; \r\n        res.append(sum_two_numbers)\r\n        return res[::-1]; \r\n        \r\n            \r\n    \r\n    def convert_array_to_integer (self, arr):\r\n        result = 0;\r\n        for i in range(len(arr)):\r\n            if arr[i] == '0': \r\n                result - result * 10;\r\n            else:\r\n                result = result * 10 + arr[i]; \r\n            \r\n        return result; \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086540900","body":"```\r\nclass Solution(object):\r\n    #数组的遍历(正向遍历和反向遍历)\r\n    #思路： 遍历两次，每次遍历，更新target到i的距离， 取两次遍历的最小值，也就是查看，左右target哪一个离i更近，更新result（返回数组）\r\n    #result[target] = 0\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        result = [float('inf')] * len(s); \r\n        target = -len(s);\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i)); \r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i));\r\n        return result;\r\n```\r\n时间复杂度： o(n)\r\n空间复杂度： o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086776798","body":"```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize; \r\n        self.stack = []; \r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x);\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack) != 0:\r\n            temp = self.stack[-1];\r\n            self.stack.pop(); \r\n            return temp;\r\n        else:\r\n            return -1; \r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        i = 0; \r\n        while i < k and i < len(self.stack):\r\n            self.stack[i] += val;\r\n            i+=1; \r\n    \r\n        \r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086938297","body":"使用栈， 对于给定的数组，把元素依次入栈，遇到 \"]”， 则将元素依次出栈直到遇到\"[\"， 把得到的string放回栈，然后处理\"[\"前的数字。 在处理数字（重复的次数时），要注意多位数的情况(>=10). 时间复杂度： O(n). 空间复杂度:O(n)\r\n```\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []; \r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                temp = []; \r\n                while stack[-1] != '[':\r\n                    temp.append(stack.pop());\r\n                stack.pop(); \r\n                counter = 0\r\n                base = 1\r\n                while stack and stack[-1].isdigit():\r\n                    counter += (ord(stack.pop()) - ord('0')) * base\r\n                    base *= 10\r\n                print('counter is', counter)\r\n                str = ''.join(temp[::-1])\r\n                stack.append(str * counter); \r\n            else:\r\n                stack.append(s[i]); \r\n        return ''.join(stack);\r\n                    \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088316192","body":"思路： 使用两个栈，栈A正常操作，在pop的时候，看栈B是否为空，如果为空，则将元素依次pop出，然后加入栈B， 这样栈B的元素就是先进先出\n\n···\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = [];\n        self.stack2 = [];\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x); \n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek(); #check if self.stack2 is empty \n        return self.stack2.pop(); \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2) == 0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop()); \n        return self.stack2[-1]; \n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1)==0 and len(self.stack2)==0; \n  ···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090357090","body":"```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        count_first = collections.defaultdict(int); \r\n        count_second = collections.defaultdict(int);\r\n        arr_sorted = sorted(arr); \r\n        ans = 0; \r\n        for a, b in zip(arr, arr_sorted):\r\n            count_first[a] += 1;\r\n            count_second[b] += 1; \r\n            if count_first == count_second:\r\n                ans+=1; \r\n        return ans; \r\n```\r\n**#time complexity: o(n^2)**\r\n\r\n优化： 使用一个counter，来记录arr和arr_sorted的区别\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        count = collections.defaultdict(int); \r\n        arr_sorted = sorted(arr); \r\n        counter = 0; \r\n        ans = 0; \r\n        for a, b in zip(arr, arr_sorted):\r\n            if count[a] == -1: #diff 减小\r\n                counter -= 1;\r\n            if count[a] == 0: #diff 增大\r\n                counter +=1; \r\n            count[a] +=1;\r\n            if count[b] == 1: #diff 减小\r\n                counter -= 1;\r\n            if count[b] == 0:#diff 增大\r\n                counter += 1;\r\n            count[b] -= 1;\r\n            if counter == 0: #遇到当arr, arr_sorted的数组全部相等是，ans++\r\n                ans += 1\r\n        return ans;\r\n```\r\n**#time complexity: o(nlogn) time for sorting**\r\n\r\n使用单调栈(单调递增）， 只用单调递增是，才能拆开，如果遇到比栈顶元素小的，则需要\r\n把栈里比该元素大的都pop出来，然后加入原来栈顶的元素。 \r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = [];\r\n        stack.append(arr[0]);\r\n        for i in range(1, len(arr)):\r\n            if stack and stack[-1] > arr[i]:\r\n                temp = stack[-1]; \r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop();\r\n                stack.append(temp); \r\n            else:\r\n                stack.append(arr[i]); \r\n        return len(stack)\r\n```\r\n**time complexity: o(n)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091842111","body":"\r\n思路： 让快指针先走k步，然后慢指针和快指针一起走走到尾部，此时慢指针就是在倒数K的位置。然后让快指针\r\n指向head，慢指针指向None. 返回倒数第k个点\r\n```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return head\r\n        length = 0; \r\n        curr = head; \r\n        slow = head;\r\n        fast = head; \r\n        while curr:\r\n            curr = curr.next;\r\n            length += 1;\r\n        k = k % length;\r\n        while fast.next:\r\n            fast = fast.next;\r\n            k -= 1;\r\n            if k < 0:\r\n                slow = slow.next; \r\n            \r\n        fast.next = head;\r\n        ans = slow.next;\r\n        slow.next = None;\r\n        return ans;\r\n\r\n```\r\ntime complexity: O(n)\r\nspace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092972337","body":"```\r\n Definition for singly-linked list.\r\n class ListNode(object):\r\n   def __init__(self, val=0, next=None):\r\n         self.val = val\r\n         self.next = next\r\n```\r\n思路： 指针的两辆交换，pre- A- B- next; \r\n交换过后为 pre-B-A-next,经过如下操作\r\nA.next = next; B.next = A, pre.next = B. \r\n时间复杂度： O(n)\r\n\r\n```\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head;\r\n        dummy = ListNode();\r\n        dummy.next = head\r\n        pre = dummy; \r\n        while head and head.next:\r\n            first_node = head;\r\n            second_node = head.next;\r\n            first_node.next = second_node.next;\r\n            second_node.next = first_node;\r\n            pre.next = second_node;\r\n            pre = first_node;\r\n            head = first_node.next;\r\n        return dummy.next;\r\n```\r\n\r\n\r\n```\r\n#recursive\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head;\r\n        first_node = head;\r\n        second_node = head.next;\r\n        first_node.next = self.swapPairs(second_node.next); \r\n        second_node.next = first_node;\r\n        print(second_node.val)\r\n        \r\n        return second_node; #returning second node in the original list \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094079832","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n```\r\n\r\n1. 找到链表的中心节点，然后用同样的方法递归建立左子树和右子树。时间复杂度 O(nlogn)。找到中心节点\r\n花费了O(n)时间，一共递归logn \r\n```\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: Optional[ListNode]\r\n        :rtype: Optional[TreeNode]\r\n        \"\"\"\r\n        if not head:\r\n            return head; \r\n        return self.helper(head, None)\r\n    \r\n    def helper(self, head,tail):\r\n        \r\n        if head == tail:\r\n            return None; \r\n       \r\n        slow, fast = head, head; \r\n        \r\n        while fast != tail and fast.next != tail:\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        node = TreeNode(slow.val);\r\n        node.left = self.helper(head, slow);\r\n        node.right = self.helper(slow.next, tail);\r\n        return node;\r\n```\r\n    \r\n2. 优化时间复杂度， 把链表转换为数组，这样查询mid的时间复杂度为O(1)，\r\n总共有n个节点，时间复杂度为O（n)。 空间复杂度O(n)\r\n```\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: Optional[ListNode]\r\n        :rtype: Optional[TreeNode]\r\n        \"\"\"\r\n        arr = self.transform_into_array(head); \r\n        return self.helper(arr, 0, len(arr)-1); \r\n    \r\n    def transform_into_array(self, head):\r\n        res = [];\r\n        while head:\r\n            res.append(head.val);\r\n            head = head.next;\r\n        return res; \r\n    \r\n    def helper(self,arr,left, right):\r\n        if left > right:\r\n            return None;\r\n        mid = (left + right) // 2; \r\n        node = TreeNode(arr[mid]);\r\n        if left == right:\r\n            return node;\r\n        node.left = self.helper(arr,left, mid-1);\r\n        node.right = self.helper(arr,mid+1,right);\r\n        return node;\r\n  \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094194845","body":"```\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        node_list = set();\r\n        while headA:\r\n          node_list.add(headA);\r\n          headA = headA.next;\r\n        while headB:\r\n          if headB in node_list:\r\n            return headB; \r\n          headB = headB.next;\r\n        return None; \r\n```\r\n时间复杂度: O(n)\r\n\r\n\r\n```\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        a = headA;\r\n        b = headB;\r\n        while a != b:\r\n          a = a.next if a else headB;\r\n          b = b.next if b else headA;\r\n        return a; \r\n```\r\n时间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095164477","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        slow = fast = head;\r\n        while fast and fast.next:\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if fast == slow:\r\n                break;\r\n        if fast is None or fast.next is None:\r\n            return None; \r\n        fast = head; \r\n        while slow != fast:\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        return fast; \r\n```\r\n                \r\n#时间复杂度: O(n)， 空间复杂度: O(1)\r\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096861059","body":"\r\n```\r\nclass Node:\r\n    def __init__(self): \r\n      \r\n        self.key = 0;\r\n        self.value = 0; \r\n        self.prev = None;\r\n        self.next = None; \r\n        \r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = {};\r\n        self.size = 0; \r\n        self.capacity = capacity; \r\n        self.head = Node();\r\n        self.tail = Node(); \r\n        self.head.next = self.tail;\r\n        self.tail.prev = self.head; \r\n       \r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key in self.cache:\r\n            node = self.cache[key]; \r\n            self.move_to_head(node); \r\n            return self.cache[key].value;\r\n        else:\r\n            return -1; \r\n       \r\n        \r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key in self.cache:\r\n            node = self.cache[key]; \r\n            node.value = value;\r\n            self.move_to_head(node);\r\n        \r\n        else: \r\n            new_node = Node(); \r\n            new_node.key = key;\r\n            new_node.value = value; \r\n            self.cache[key] = new_node;\r\n            self.add_node(new_node); \r\n            self.size += 1; \r\n            if self.size > self.capacity:\r\n                tail = self.pop_tail(); \r\n                del self.cache[tail.key]; \r\n                self.size -= 1; \r\n            \r\n        \r\n    \r\n    def add_node(self,node):\r\n        node.prev = self.head;\r\n        node.next = self.head.next; \r\n        self.head.next.prev = node;\r\n        self.head.next = node; \r\n        \r\n    def remove_node(self,node):\r\n        prev = node.prev;\r\n        next = node.next; \r\n        prev.next = next; \r\n        next.prev = prev; \r\n        \r\n    def move_to_head (self,node):\r\n        self.remove_node(node); \r\n        self.add_node(node);\r\n    \r\n    def pop_tail (self):\r\n        res = self.tail.prev;\r\n        self.remove_node(res); \r\n        return res; \r\n            \r\n            \r\n        \r\n```\r\n\r\n时间复杂度： O(1)\r\n空间复杂度：O(capcaity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098134496","body":"```\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if root is None: \r\n            return 0; \r\n        left_max = self.maxDepth(root.left); \r\n        right_max = self.maxDepth(root.right);\r\n        return 1 + max(left_max, right_max);\r\n\r\n```\r\n    \r\n    **time complexity: O(n), visit n node\r\n    space complexity: worst case O(n) unbalanced , best case O(logn) balanced**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099247350","body":"```\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        if p is None and q is None:\r\n            return True; \r\n        if p is None or q is None:\r\n            return False;\r\n        if p.val != q.val:\r\n            return False;\r\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n时间复杂度：O(n)，需要遍历每一个节点\r\n空间复杂度： O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100256845","body":"```\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def sumNumbers(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        def helper(root, curr):\r\n            if not root:\r\n                return 0; \r\n            if not root.left and not root.right:\r\n                return curr * 10 + root.val; \r\n            left_sum = helper(root.left, curr*10+root.val); \r\n            right_sum = helper(root.right, curr * 10 + root.val);\r\n            return left_sum + right_sum;\r\n        return helper(root,0)\r\n        \r\n```\r\n    #时间复杂度： O(N)\r\n    #空间复杂：O(h)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100269209","body":"```\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def findBottomLeftValue(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        res = 0; \r\n        queue = collections.deque(); \r\n        queue.append(root); \r\n        while queue:\r\n            res = queue[0].val; \r\n            for _ in range(len(queue)):\r\n                curr = queue.popleft(); \r\n                if curr.left:\r\n                    queue.append(curr.left); \r\n                if curr.right:\r\n                    queue.append(curr.right); \r\n        return res; \r\n\r\n```\r\n\r\n#时间复杂度： O(N)\r\n#空间复杂度： O(N); worst case \r\n       ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100807428","body":"```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = ''; \n        queue = collections.deque([root]); \n        while queue:\n            curr = queue.popleft();\n            if curr:\n                res += str(curr.val) + \",\";\n                queue.append(curr.left); \n                queue.append(curr.right); \n            else:\n                res += '#,';\n        return res[:-1];\n            \n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == '#': \n            return None;\n        nodes = data.split(',')\n        if not nodes:return None;\n        root = TreeNode(nodes[0]);\n        queue = collections.deque([root]); \n        i = 1\n        while i < len(nodes) - 1:\n            curr = queue.popleft();\n            left = nodes[i]; \n            right = nodes[i+1];\n            i += 2;\n            if left != '#':\n                left_node = TreeNode(left);\n                curr.left = left_node;\n                queue.append(left_node);\n            if right != '#':\n                right_node = TreeNode(right); \n                curr.right = right_node;\n                queue.append(right_node); \n        return root; \n```            \n time complexity:O(n)\nspace complexity:  O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101500026","body":"```\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []; \n        queue = collections.deque(); \n        queue.append((root,0,0));\n        while queue:\n            curr, x, y = queue.popleft();\n            if curr:\n                res.append([curr.val, x,y]);     \n                queue.append((curr.left, x+1,y-1));\n                queue.append((curr.right,x+1,y+1)); \n\n        ans = [];\n        res = sorted(res, key = lambda x : (x[2], x[1], x[0]));\n        print(res)\n        ans = OrderedDict();\n        for value,row, column  in res:\n            if column in ans:\n                ans[column].append(value); \n            else:\n                ans[column] = [value]; \n        \n        return ans.values();\n    ```       \n#time complexity: O(nlogn), visited every node of the tree and sorting takes o(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102738559","body":"```\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        mapping = {};\n        for i in range(len(nums)):\n            if target-nums[i] in mapping:\n                return [mapping[target-nums[i]], i]; \n            else:\n                mapping[nums[i]] = i; \n```\ntime complexity: O(n)\nspace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104101120","body":"```\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k == len(nums):\n            return nums; \n        counter = collections.defaultdict(int)\n        for num in nums:\n            counter[num]+=1;\n        counter = sorted(counter.items(), key = lambda x : x[1], reverse = True); \n        res = [];\n        for i in range(k):\n            res.append(counter[i][0]);\n        return res; \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105313158","body":"```\r\nclass Solution(object):\r\n    def numberOfBoomerangs(self, points):\r\n        \"\"\"\r\n        :type points: List[List[int]]\r\n        :rtype: int\r\n        \"\"\"\r\n        #思路：pin i, then there are n options for i and n-1 options for k. time complexity: O(n^2)\r\n        ans = 0; \r\n        m = len(points); \r\n        for i in range(m):\r\n          temp = collections.defaultdict(int); \r\n          for j in range(m):\r\n            distance = (points[j][0]-points[i][0])**2 + (points[j][1]-points[i][1])**2;\r\n            temp[distance] += 1;\r\n          for value in temp.values(): \r\n            ans += value * (value-1); \r\n        return ans; \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106612759","body":"```\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        res = 0;\n        left, right = 0, 0;\n        counter = collections.defaultdict(int); \n        while right < len(s):\n            c = s[right]; \n            counter[c] += 1;\n            while counter[c] > 1:\n                counter[s[left]] -= 1; \n                left += 1;\n            res = max(res, right-left+1); \n            right += 1; \n        return res; \n     ```           \n                \n#time complexity: O(n)\n#space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107529799","body":"···\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        n = len (s);\n        k = len (words);\n        word_length = len(words[0]); \n        substring_size = k * word_length; \n        counter = collections.Counter(words); \n        #hexlper function to determine whether starting index i can find a valid substring\n        def helper(start):\n            copy = counter.copy(); \n            used = 0;\n            for j in range(start, start+substring_size, word_length):\n                str = s[j:j+word_length];\n                if copy[str] > 0: \n                    copy[str] -= 1;\n                    used += 1;\n                else:\n                    break;\n            return used == k; \n        \n        res = []; \n        for i in range(n-substring_size+1):\n            if helper(i):\n                res.append(i);\n        return res; \n···\n    #time complexity: for helper, creating a hash table needs O(k) and needs to check k * word_length times (b). the total time complexity for helper is O(k+k*b) => O(k *b); overal, we need to call the hleper function for n - k*b time => O(n*k*b-(k*b)^2); \n    #space complexity: O(K+b)\n            ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107536809","body":"```\nclass Solution:\n    def solve(self, nums, k):\n        #prefix sum first \n        #由同余定理我们知道两个模 k 余数相同的数字相减，得到的值定可以被 k 整除\n        #目标就是找到一段模 k 等于 target 的子数组\n        total = sum(nums); \n        mod = total % k; \n        if total % k == 0:\n            return 0; \n        mapping = {0:-1}; \n        total = 0; \n        ans = len(nums); \n        for i in range(len(nums)):\n            total += nums[i]; #sum of first i\n            curr_mod = total % k; \n            target = (curr_mod - mod + k) % k; \n            if target in mapping:\n                ans = min(ans, i - mapping[target]); \n            mapping[curr_mod] = i; \n\n        if ans == len(nums):\n            return -1; \n        return ans; \n```\n#time complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108655240","body":"```\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head; \n        slow, fast = head, head;\n        while fast and fast.next:\n            fast = fast.next.next;\n            slow = slow.next;\n        return slow; \n        ```\ntime complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109902490","body":"```\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: \n            return 0.\n        if len(nums) == 1:\n            return 1;\n        left = 0; \n        for right in range(1, len(nums)):\n            if nums[left] != nums[right]:\n                left += 1;\n                nums[left] = nums[right];\n        return left+1;\n    ```            \n    #time complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111089113","body":"```\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        #使用双指针，注意target大于最大值和小于最小值得情况\n        left = 0; \n        right = len(nums)-1;\n        if target > nums[-1]:\n            return len(nums);\n        if target < nums[0]:\n            return 0; \n        while left + 1 < right:\n            mid = (left + right) // 2;\n            if nums[mid] > target:\n                right = mid; \n            if nums[mid] < target:\n                left = mid;\n            if nums[mid] == target:\n                return mid; \n        if nums[left] == target:\n            return left; \n        if nums[right] == target:\n            return right;\n        if nums[left] < target < nums[right]:\n            return left + 1;\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112324067","body":"```\nimport heapq; \nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        heap = [];\n        res = [];\n        for i in range(k):\n            heapq.heappush(heap, (-nums[i],i)); \n        res.append(-heap[0][0]); \n\n        for i in range(k, len(nums)):\n            heapq.heappush(heap,(-nums[i],i)); \n            while heap[0][1] < i-k+1:\n                heapq.heappop(heap); \n            res.append(-heap[0][0]); \n        return res;\n#time complexity: O(nlogk)\n\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        res = []; \n        queue = collections.deque(); \n        for i in range(len(nums)):\n            while queue and nums[queue[-1]] < nums[i]:  #保持单调递减， 队首需要是最大的\n                queue.pop(); \n            while queue and nums[queue[0]] < i-k+1: #超过K个数就\n                queue.popleft();\n            queue.append(i); \n            if i >= k-1: #开始计算最大值\n                res.append(nums[queue[0]]);\n        return res; \n#time complexity: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113397281","body":"```\nclass Solution(object):\n    def findJudge(self, n, trust):\n        \"\"\"\n        :type n: int\n        :type trust: List[List[int]]\n        :rtype: int\n        \"\"\"\n\n        in_degree = [0] * (n+1);\n        out_degree = [0] * (n+1);\n        for item in trust:\n            in_degree[item[1]]+= 1;\n            out_degree[item[0]]+=1;\n        for i in range(1,n+1):\n            if in_degree[i] == n-1 and out_degree[i] == 0:\n                return i; \n        return -1;\n```\n#time complexity: O(N);\n#space complexity: O(N); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113921446","body":"```\nclass Solution(object):\n    def possibleBipartition(self, n, dislikes):\n        \"\"\"\n        :type n: int\n        :type dislikes: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        graph = [[0] * n for i in range(n)]\n        colors = [0] * n\n        for a, b in dislikes:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n        for i in range(n):\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, n):\n                return False\n        return True\n    \n    def dfs(self, graph, colors, i, color, n):\n        colors[i] = color\n        for j in range(n):\n            # dislike eachother\n            if graph[i][j] == 1:\n                if colors[j] == color:\n                    return False\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, n):\n                    return False\n        return True\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491869","body":"/* 求和的方法始终会溢出，故不可采取\r\n        size_t sum = 0, max_size = num.size();\r\n        // get the sum\r\n        for(int i(0); i < max_size; ++i)\r\n            // sum += num[i] * pow(10, max_size-i-1);\r\n            sum  = sum * 10 + num[i];\r\n        sum += k;\r\n        // int count(1), level(0);\r\n        // while(sum % count) {\r\n        //     level++;\r\n        //     count *= 10;\r\n        // }\r\n        // vector<int> tmp_vec[level];\r\n        // int i(0);\r\n        // while(level){\r\n        //     tmp_vec.push_back(sum / power(10, level-1));\r\n            \r\n        //     --level;\r\n        // }\r\n\r\n        // 对于数值的位的操作有：移位操作，不过基于十进制的移位可能需要重新设计；\r\n        // 转化为string类型；\r\n        // 通过for循环取余或除提取\r\n\r\n        string str_sum = to_string(sum);  //将int型转化为string，从而可以单独操作每一位；\r\n        const size_t length = str_sum.size();\r\n        vector<int> tmp_vec;\r\n        for(int i(0); i < length; ++i)\r\n            tmp_vec.push_back(str_sum[i]-48);\r\n\r\n        return tmp_vec;\r\n        */\r\n\r\n        string str_k = to_string(k);\r\n        size_t length_num = num.size();\r\n        size_t length_k = str_k.size();\r\n        int i = length_num-1;\r\n        int j = length_k-1;\r\n        int carry = 0;\r\n        while((i+1) && (j+1)){\r\n            num[i] = num[i] + str_k[j] - 48 + carry;\r\n            carry = 0;\r\n            if(num[i] >= 10){\r\n                carry = 1;\r\n                num[i] %= 10;\r\n            }\r\n            --i;\r\n            --j;\r\n        }\r\n\r\n        if(carry){\r\n            \r\n        }\r\n    }\r\n\r\n只能说 尝试了相加的方法，但是用了size_t后还是溢出，又采取了逐位相加，结果在判断上理解还是不够到位，对情况的分析很卡。最后没忍住看了官方题解，那么这题也就作废了。留此记录。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pfyyh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085499940","body":"### 思路\r\n\r\n模拟加法\r\n\r\n按照低位求和，大于等于十则进一。\r\n\r\n\r\n\r\n存储结构，使用的是LinkedList。底层是链表结构，往链表头插入元素。低位先进入链表，高位最后。减少一次反转\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //以num数组为基准\r\n        LinkedList<Integer> deque = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            //计算当前位\r\n            int value = num[i] + k % 10;\r\n            //丢弃最低位\r\n            k /= 10;\r\n            //如果结果大于10，k进1\r\n            if (value >= 10) {\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            deque.addFirst(value);\r\n        }\r\n        //如果数组用完了，将K剩下的高位放进去\r\n        for (; k > 0; k /= 10) {\r\n            deque.addFirst(k % 10);\r\n        }\r\n        return deque;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(N+M,N))，其中 N 为数组长度,M=K长度-N长度。\r\n- 空间复杂度：O(max(N+M,N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086630219","body":"### 思路\n\n借鉴了滑动窗口算法，找到第一个和第二个出现字符的位置。\n\n比较下标-头的距离和尾巴-下标的距离，填入数组。\n\n当下标到达尾巴的时候，说明已经\n\n当S字符串只有一个符合的c的时候，从符合位置点往两边填充距离。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //存储结果\n        int[] result = new int[s.length()];\n        //判断滑动窗口\n        int head = s.indexOf(c);\n        int tail = s.indexOf(c, head + 1);\n        //说明没有窗口，直接填充两边值即可\n        if(tail==-1){\n            int absLength = 0;\n            int lP = head;\n            int rP = head;\n            //从唯一的下标开始往两边扩展\n            while(lP>=0||rP<s.length()){\n                if(lP>=0){\n                    result[lP]=absLength;\n                    lP--;\n                }\n                if(rP<s.length()){\n                    result[rP]=absLength;\n                    rP++;\n                }\n                absLength++;\n            }\n            return result;\n\n        }\n        char[] chars = s.toCharArray();\n        \n        for (int i = 0; i < chars.length; i++) {\n            result[i] = Math.min(Math.abs(head - i), Math.abs(tail - i));\n            //遍历到了尾巴，尾巴变头，找下一个尾巴。\n            if (i == tail) {\n                head = tail;\n                //如果尾巴没了，tail = -1 tail-i的绝对值永远大于head-i的绝对值,永远是head-i\n                tail = s.indexOf(c, tail + 1);\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086863323","body":"### 思路\n\n最开始想的是直接使用LinkedList，用着用着越不对劲。\n\n用数组重写，重要的就是当前栈顶所在位置的管理。\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int iPoint;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        iPoint = -1;\n    }\n    \n    public void push(int x) {\n        //如果到了最后\n        if (iPoint == stack.length-1) {\n            return;\n        }\n        //向右偏移一位\n        iPoint++;\n        //存值\n        stack[iPoint] = x;\n    }\n    \n    public int pop() {\n        //栈底\n        if (iPoint == -1) {\n            return iPoint;\n        }\n        --iPoint;\n        //直接返回即可，后面直接覆盖\n        return stack[iPoint + 1];\n    }\n    \n    public void increment(int k, int val) {\n        //影响数量\n        int num = Math.min(k, iPoint + 1);\n        //修改值\n        for (int i = 0; i < num; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 时间复杂度\n\npush和pop都是栈顶直接操作，O(1)\n\nincrement遍历的数组O(num),num为临时的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087376958","body":"### 思路\n\n使用一个LinkedList作为栈，依次遍历S\n\n情况1：数字，如果是数字，有可能接下来几位都是数字，遍历到不是数字为止。\n\n情况2：字母和\"[\",直接入栈即可。\n\n情况3：\"]\",出栈到临时栈，直到出现\"[\"。然后再出一次必定是数字n。把栈转字符串循环n次。然后在放进linkedList。\n\n### 代码\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            //如果是数字接下来几位都有可能是数字\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：解析后的字符串长度O(n)\n\n空间复杂度：没有多余的空间，存储解析后的字符串长度。O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088657676","body":"### 思路\n\n就有点类似于最开始学编程的时候，两个塔，左边塔321，右边空。然后依次取出放到右边的塔就是123。\n\n### 代码\n\n```java\nimport java.util.LinkedList;\nimport java.util.List;\n\nclass MyQueue {\n\n\n    int head = -1;\n    LinkedList<Integer> result;\n\n    public MyQueue() {\n        result = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (result.isEmpty()) {\n            head = x;\n        }\n        LinkedList<Integer> integers = new LinkedList<>();\n        while (!result.isEmpty()) {\n            integers.push(result.pop());\n        }\n        integers.push(x);\n        while (!integers.isEmpty()) {\n            result.push(integers.pop());\n        }\n    }\n\n    public int pop() {\n        int value = result.pop();\n        if (!result.isEmpty()) {\n            head = result.peek();\n        }\n        return value;\n    }\n\n    public int peek() {\n//        不能使用 result.getFirst();\n        return head;\n    }\n\n    public boolean empty() {\n        return result.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n### 复杂度分析\n\n时间复杂度：\n\n1. push:O(n)\n2. pop:O(1)\n3. peek:O(1)\n4. empty:(1)\n\n空间复杂度：\n\n1. push用了额外空间，*O*(*n*)\n2. pop:O(1)\n3. peek:O(1)\n4. empty:(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090395075","body":"### 思路\r\n\r\n想了排序块想了半天，才理解题解里面的while。\r\n32132     5\r\n3,5\r\n\r\n##### 排序块定义\r\n\r\n当某块后面的元素都大于此块内的元素，那么此块为排序块\r\n\r\n每块长度最少为 1，即每个元素可单独成块.\r\n\r\n###### 前提\r\n\r\n前一个块的最大值，小于后一个块的最小值\r\n\r\n如果当前值 num 大于等于 前面块的最大值，那么 num 就可以单独成块\r\n\r\n如果当前值 num 小于 前面块的最大值，那么我们需要往前一直找，直到找到一个块 block 的最大值小于等于当前值\r\n\r\n作者：suan-tou-wang-ba\r\n链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/leetcode-768-wo-gan-jio-jiang-de-ying-gai-xiang-xi/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for (int num : arr) {\r\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if(!stack.isEmpty()){\r\n                stack.addFirst(num);\r\n            }else if (!stack.isEmpty() && num < stack.getFirst()) {\r\n                //栈里面的元素都是块里面的最大值，获取最大值。\r\n                int cur = stack.removeFirst();\r\n                // 一直获取栈整\r\n                while (!stack.isEmpty() && num < stack.getFirst()) {\r\n                    stack.removeFirst();\r\n                }\r\n                stack.addFirst(cur);\r\n            } else {\r\n                stack.addFirst(num);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stack.size();\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)O(N)，其中 N 为数组长度。\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091640700","body":"### 思路\n\n今天比昨天好多了。首位相连，然后当k为0,就相当于尾巴在length的地方，刚好转一圈。其余时间遍历到length-(k%length)即可。k%length表示最后一圈，偏移位置。\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode cur = head;\n        int length = 1;\n        //找到末尾\n        while(cur.next!=null){\n            length++;\n            cur = cur.next;\n        }\n        //成环\n        cur.next = head;\n        //遍历次数 length -(k%length),k%length表示一圈内\n        //从头开始\n        for(int i=0;i<length-(k%length);i++){\n            cur = cur.next;\n        }\n        head = cur.next;\n        cur.next = null;\n        return head;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(n+(length-(k%length))),n为链表长度，length-(k%length),最坏情况O(2n)\n\n空间复杂度：没有额外空间，O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093026145","body":"## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n\r\n\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n最小单位两个节点。两个节点为一组，进行交换，通过递归的方式获取每组的开头，并交换每组的顺序。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode firstNode) {\r\n        //如果只有一个节点，直接返回\r\n        if (firstNode == null || firstNode.next == null) {\r\n            return firstNode;\r\n        }\r\n        //获取第下个节点如果只有1 ，2 。值为2\r\n        ListNode secondNode = firstNode.next;\r\n        //通过方法获取第三个节点，如果只有1，2。返回结果null,如果有1，2，3，4。当前层交换了，1和2。通过方法获取下两个节点交换数据。\r\n        firstNode.next = swapPairs(secondNode.next);\r\n        //下个节点指向第一个节点\r\n        secondNode.next = firstNode;\r\n        //返回下个节点就是头\r\n        return secondNode;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094080381","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n \n\n示例 1:\n\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n\n示例 2:\n\n输入: head = []\n输出: []\n\n\n \n\n提示:\n\nhead 中的节点数在[0, 2 * 104] 范围内\n-105 <= Node.val <= 105\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head==null){\n            return null;\n        }\n        return getMid(head,null);\n    }\n    //获取二叉树\n    TreeNode getMid(ListNode head,ListNode tail){\n        //边界\n        if(head==tail){\n            return null;\n        }\n        \n        //中间节点，快慢指针\n        ListNode fast=head;\n        ListNode slow =head;\n        //快指针到尾部，或者为他后面为链表结束\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        //慢指针就是中点\n        TreeNode root = new TreeNode(slow.val);\n        root.left = getMid(head, slow);\n        root.right = getMid(slow.next, tail);\n        return root;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。（算不来。。）\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(logn)$\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094250692","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 链表的遍历\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  链表A = 链表A独特节点长度+AB重合节点长度。链表B = 链表B独特节点长度+AB重合节点长度，可以得出A+AB+B = B+AB+A。\n描述就是两个指针分别指向两个头。然后同速度跑，其中一个到了尾部（假设A链表跑完了，说明A短于B）以后，切换到另一个链表(B)进行奔跑。因为是同速，都跑了已经跑了A+AB的距离。还差B(B链表独特节点终点位置)就能到达相交点。\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null||headB==null){\n            return null;\n        }\n        ListNode pA = headA;\n        ListNode pB = headB;\n        //同速度前进\n        while(pA!=pB){\n            //换条跑道,追pB，独特A距离+相同距离C+独特B距离\n            if(pA==null){\n                pA=headB;\n            }else{\n                //没到跑到终点,继续跑\n                pA = pA.next;\n            }\n            //换条跑道,追pA，独特A距离+相同距离C+独特B距离\n            if(pB==null){\n                pB=headA;\n            }else{\n                //没到跑到终点,继续跑\n                pB = pB.next;\n            }\n        }\n        return pA;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\nm为A链表长度，n为B链表长度\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095132510","body":"\n## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  哈希表\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n         //如果没有节点或者只有一个节点，不构成环直接返回。\n        if (head == null || head.next == null) {\n            return null;\n        }\n        HashSet<Integer> set = new HashSet<>();\n        ListNode cur = head;\n        while (cur!=null){\n            boolean result = set.add(cur.hashCode());\n            //说明存在环\n            if (!result){\n                return cur;\n            }\n            cur = cur.next;\n        }\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096908738","body":"\n## 题目地址(146. LRU 缓存)\n\nhttps://leetcode-cn.com/problems/lru-cache/\n\n## 题目描述\n\n```\n请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\n实现 LRUCache 类：\nLRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n \n\n示例：\n\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n\n\n \n\n提示：\n\n1 <= capacity <= 3000\n0 <= key <= 10000\n0 <= value <= 105\n最多调用 2 * 105 次 get 和 put\n```\n\n## 前置知识\n\n- 哈希表\n- 链表\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n- 哈希表存储常用队列，以达到时间复杂度O(1)\n- 双向链表，解决节点移动。定义虚假头和虚假尾部。解决空指针问题。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n\n\npublic class LRUCache {\n\n    class Node {\n        int key;\n        int value;\n        Node next;\n        Node pre;\n\n        public Node() {\n        }\n\n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    private Node head;\n\n    private Node tail;\n\n    private Map<Integer, Node> map = new HashMap<>();\n\n    private int capacity;\n\n    /**\n     * 获取当前长度\n     *\n     * @return 缓存长度\n     */\n    private int size() {\n        return map.size();\n    }\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        //创建假头和假尾巴\n        head = new Node();\n        tail = new Node();\n        head.next = tail;\n        tail.next = null;\n        tail.pre = head;\n        head.pre = null;\n    }\n\n    /**\n     * 根据键获取value值\n     *\n     * @param key 键\n     * @return 值\n     */\n    public int get(int key) {\n        //先从缓存获取\n        Node node = map.get(key);\n        if (node != null) {\n            //将节点移动到头部\n            //1.将当前节点移除原来的位置,因为存在虚假头和尾巴，不会存在null异常。\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n            //2.将节点放入头\n            node.next = head.next;\n            node.pre = head;\n            head.next.pre = node;\n            head.next = node;\n            //返回value值\n            return node.value;\n        } else {\n            //直接返回-1\n            return -1;\n        }\n    }\n\n    public void put(int key, int value) {\n        //如果存在值直接更新\n        Node node = map.get(key);\n        if (node != null) {\n            node.value = value;\n            //移动节点到头\n            //1.撤销原来的节点的前后\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n            //2.移动到头部\n            node.next = head.next;\n            node.pre = head;\n            head.next.pre = node;\n            head.next = node;\n            //如果缓存满了，那么就要移除最后的节点\n        } else if (size() >= capacity) {\n            map.remove(tail.pre.key);\n            //新尾部\n            Node newTailNode = tail.pre.pre;\n            newTailNode.next = tail;\n            tail.pre = newTailNode;\n            //添加新的到缓存\n            Node newHeadNode = new Node(key, value);\n            map.put(key, newHeadNode);\n            //将当前节点加入到头\n            Node newSecondNode = head.next;\n            newSecondNode.pre = newHeadNode;\n            newHeadNode.next = newSecondNode;\n            head.next = newHeadNode;\n            newHeadNode.pre = head;\n        }else{\n            Node newHeadNode = new Node(key, value);\n            map.put(key,newHeadNode);\n            //然后将节点放到头部\n            Node newSecondNode = head.next;\n            newSecondNode.pre = newHeadNode;\n            newHeadNode.next = newSecondNode;\n            head.next = newHeadNode;\n            newHeadNode.pre = head;\n        }\n    }\n\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097907953","body":"\n## 题目地址(104. 二叉树的最大深度)\n\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n## 题目描述\n\n```\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  递归\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root==null){\n            return 0;\n        }else{\n            int leftLength = maxDepth(root.left);\n            int rightLength = maxDepth(root.right);\n            return Math.max(leftLength,rightLength)+1;\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$每个节点都要尝试\n- 空间复杂度：$O(n)$完全就是链表\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099083047","body":"\n## 题目地址(100. 相同的树)\n\nhttps://leetcode-cn.com/problems/same-tree/\n\n## 题目描述\n\n```\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n示例 1：\n\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n\n\n示例 2：\n\n输入：p = [1,2], q = [1,null,2]\n输出：false\n\n\n示例 3：\n\n输入：p = [1,2,1], q = [1,1,2]\n输出：false\n\n\n \n\n提示：\n\n两棵树上的节点数目都在范围 [0, 100] 内\n-104 <= Node.val <= 104\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  递归，经理法\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null&&q==null){\n            return true;\n        }\n        if((p==null&&q!=null)||(q==null&&p!=null)){\n            return false;\n        }\n        //判断根节点\n        if(p.val==q.val){\n            if(isSameTree(p.left,q.left)){\n                return isSameTree(p.right,q.right);\n            }else{\n                return false;\n            }\n            \n        }else{\n            return false;\n        }\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(min(n,m))$ 节点数\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100053457","body":"\n## 题目地址(129. 求根节点到叶节点数字之和)\n\nhttps://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n## 题目描述\n\n```\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n\n示例 2：\n\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n\n\n \n\n提示：\n\n树中节点的数目在范围 [1, 1000] 内\n0 <= Node.val <= 9\n树的深度不超过 10\n```\n\n## 前置知识\n\n- 遍历二叉树\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  深度遍历。当前节点和=前置节点值*10+当前节点值，然后当前节点和作为子节点的前置节点进行递归。边界就是当前节点为空，两边都为空就可以返回结果了。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if(root==null){\n            return -1;\n        }\n\n        return dfs(root,0);\n\n    }\n    public int dfs(TreeNode root,int sum){\n        //则代表叶子节点\n        if(root==null){\n            return 0;\n        }\n        \n        //计算当前节点,每次进10,然后求当前值\n        sum = sum*10+root.val;\n        //如果是叶子节点，就返回值\n        if(root.left==null&&root.right==null){\n            return sum;\n        }else{\n            return dfs(root.left,sum)+dfs(root.right,sum);\n        }\n            \n    }\n\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(节点数)$\n- 空间复杂度：$O(树高度)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100519722","body":"\n## 题目地址(513. 找树左下角的值)\n\nhttps://leetcode-cn.com/problems/find-bottom-left-tree-value/\n\n## 题目描述\n\n```\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n\n假设二叉树中至少有一个节点。\n\n \n\n示例 1:\n\n输入: root = [2,1,3]\n输出: 1\n\n\n示例 2:\n\n输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n\n\n \n\n提示:\n\n二叉树的节点个数的范围是 [1,104]\n-231 <= Node.val <= 231 - 1 \n```\n\n## 前置知识\n\n- 二叉树的广度遍历\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n- 背广度遍历模板，定义一个List，存储没有遍历的节点。获取每层的节点数，将值存入List（改下模板，从右到左遍历，就不用存）。最后一个list的第一个元素就是最深层的最左元素。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n    //如果没值，直接返回\n       if (root==null){\n           return 0;\n       }\n       //创建List,存储每层节点元素\n        List<List<Integer>> values = new LinkedList<>();\n       //创建List，存储待遍历节点\n        LinkedList<TreeNode> needShowList = new LinkedList<>();\n       //第一次把根节点加入其中\n        needShowList.add(root);\n        //遍历知道List没有值为止\n        while (needShowList.size()>0){\n            //获取当前层，节点个数\n            int size = needShowList.size();\n            //获取当前层第一个元素\n            //创建当前层List\n            LinkedList<Integer> list = new LinkedList<>();\n            //遍历当前节点\n            for (int i = 0; i < size; i++) {\n                TreeNode index = needShowList.pollFirst();\n                list.add(index.val);\n                if (index.left!=null){\n                    needShowList.add(index.left);\n                }\n                if (index.right!=null){\n                    needShowList.add(index.right);\n                }\n            }\n            values.add(list);\n        }\n        return values.get(values.size()-1).get(0);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(N)$，N是节点数目\n- 空间复杂度：$O(Q)$，最多能存满二叉树,Q是队列长度\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100787472","body":"\n## 题目地址(297. 二叉树的序列化与反序列化)\n\nhttps://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\n\n## 题目描述\n\n```\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n \n\n示例 1：\n\n输入：root = [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]\n\n\n示例 2：\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n输入：root = [1,2]\n输出：[1,2]\n\n\n \n\n提示：\n\n树中结点数在范围 [0, 104] 内\n-1000 <= Node.val <= 1000\n```\n\n## 前置知识\n\n- 二叉树遍历，前置遍历\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。我一直在看例子一误导了很久。其实叶子节点只需要两个null追加在后面就行了。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n  public String serialize(TreeNode root) {\n        return addStr(root, new StringBuilder()).toString();\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] strings = data.split(\",\");\n        LinkedList<String> strings1 = new LinkedList<>(Arrays.asList(strings));\n        return rdeserialize(strings1);\n    }\n\n    public StringBuilder addStr(TreeNode root, StringBuilder str) {\n        if(root==null){\n            return str.append(\"NULL,\");\n        }else{\n            str.append(root.val).append(\",\");\n            str = addStr(root.left,str);\n            str = addStr(root.right,str);\n            return str;\n        }\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        //如果当前节点为NULL,表示空树\n        String node = dataList.remove(0);\n        if (\"NULL\".equals(node)){\n            return null;\n        }\n        TreeNode treeNode = new TreeNode(Integer.valueOf(node));\n        treeNode.left = rdeserialize(dataList);\n        treeNode.right = rdeserialize(dataList);\n        return treeNode;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$ n为节点数量\n- 空间复杂度：$O(n)$ n为节点数量\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100980597","body":"\n## 题目地址(987. 二叉树的垂序遍历)\n\nhttps://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/\n\n## 题目描述\n\n```\n给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\n\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\n\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n\n返回二叉树的 垂序遍历 序列。\n\n \n\n示例 1：\n\n输入：root = [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n示例 2：\n\n输入：root = [1,2,3,4,5,6,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n\n示例 3：\n\n输入：root = [1,2,3,4,6,5,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。\n\n \n\n提示：\n\n树中结点数目总数在范围 [1, 1000] 内\n0 <= Node.val <= 1000\n```\n\n## 前置知识\n\n- 深度遍历\n- 数组比较\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  第一维度是列，第二维度是行，第三维度是值。首先通过深度遍历所有节点，并根据前面的要求排序。\n- 然后进行遍历即可。 \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        ArrayList<Node> nodes = new ArrayList<>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes);\n        int maxRow = Integer.MAX_VALUE;\n        List<List<Integer>> arrayLists = new ArrayList<>();\n        int curIndex = -1;\n        int lastCol = Integer.MIN_VALUE;\n        for (Node node : nodes) {\n            //判断当前是否同列，如果不同列，说明\n            if (node.col != lastCol) {\n                lastCol = node.col;\n                arrayLists.add(new ArrayList<>());\n                curIndex++;\n            }\n            //在同列的基础上，上层在前，下层在后，可以保障\n            arrayLists.get(curIndex).add(node.val);\n        }\n        return arrayLists;\n    }\n\n    public void dfs(TreeNode root, int row, int col, List<Node> nodes) {\n        if (root == null) {\n            return;\n        }\n        nodes.add(new Node(row, col, root.val));\n        if (root.left != null) {\n            dfs(root.left, row + 1, col - 1, nodes);\n        }\n        if (root.right != null) {\n            dfs(root.right, row + 1, col + 1, nodes);\n        }\n\n    }\n\n}\n\nclass Node implements Comparable<Node> {\n    int row;\n    int col;\n    int val;\n\n    public Node(int x, int y, int val) {\n        this.row = x;\n        this.col = y;\n        this.val = val;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        //首先保障同列\n        if (this.col != o.col) {\n            return this.col - o.col;\n            //同列的基础上同行\n        } else if (this.row != o.row) {\n            return this.row - o.row;\n            //同行基础上比较值\n        } else {\n            return this.val - o.val;\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\nn是节点长度，第一次深度遍历，后来一次排序，底层使用二进制插入排序，nlogn,最后还需要遍历一次list\n- 时间复杂度：$O(n+nlogn+n)$ \n- 空间复杂度：$O(2n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102545675","body":"\n## 题目地址(1. 两数之和)\n\nhttps://leetcode-cn.com/problems/two-sum/\n\n## 题目描述\n\n```\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n \n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n \n\n提示：\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n只会存在一个有效答案\n\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  哈希表，键存计算值，值存数组下标。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target-nums[i])) {\n                return new int[]{i,map.get(target-nums[i])};\n            }else {\n                map.put(nums[i],i);\n            }\n        }\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105121586","body":"## 题目地址(447. 回旋镖的数量)\r\n\r\nhttps://leetcode-cn.com/problems/number-of-boomerangs/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。\r\n\r\n返回平面上所有回旋镖的数量。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：points = [[0,0],[1,0],[2,0]]\r\n输出：2\r\n解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\r\n\r\n\r\n示例 2：\r\n\r\n输入：points = [[1,1],[2,2],[3,3]]\r\n输出：2\r\n\r\n\r\n示例 3：\r\n\r\n输入：points = [[1,1]]\r\n输出：0\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\nn == points.length\r\n1 <= n <= 500\r\npoints[i].length == 2\r\n-104 <= xi, yi <= 104\r\n所有点都 互不相同\r\n```\r\n\r\n## 前置知识\r\n\r\n- 哈希表\r\n- 两点距离\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n- 应该存  KV = 距离,个数\r\n- 组合可能为n(n-1)\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        //判断数组长度是否小于等于二，如果是则返回\r\n        if(points.length<=2){\r\n            return 0;\r\n        }\r\n        int sum = 0;\r\n\r\n        //定义哈希表 key存储距离，value存储数量。最后返回的key的数量就是sum = value*(value-1)\r\n        Map<Integer,Integer> map = new HashMap<>();\r\n        for(int i=0;i<points.length;i++){\r\n            for(int j=0;j<points.length;j++){\r\n                int x = points[j][0]-points[i][0];\r\n                int y = points[j][1]-points[i][1];\r\n                int dist =x*x+y*y;\r\n                 map.put(dist, map.getOrDefault(dist, 0) + 1);\r\n            }\r\n            for(int value : map.values()){\r\n                sum+=value*(value-1);\r\n            }\r\n            map.clear();\r\n        }\r\n        \r\n        return  sum;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106368416","body":"\n## 题目地址(3. 无重复字符的最长子串)\n\nhttps://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n## 题目描述\n\n```\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n \n\n示例 1:\n\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n\n示例 2:\n\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n\n示例 3:\n\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n\n \n\n提示：\n\n0 <= s.length <= 5 * 104\ns 由英文字母、数字、符号和空格组成\n```\n\n## 前置知识\n\n- 哈希表\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  滑动窗口\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        //最大长度\n        if (s.length() == 0) return 0;\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\n        //存储最大长度\n        int maxLength = 0;\n        //滑动窗口最左便\n        int left = 0;\n        //滑动右边框\n        for (int right = 0; right < s.length(); right++) {\n            //如果abca情况，遍历到了第二个a,则将窗口右移。\n            if (map.containsKey(s.charAt(right))) {\n                //左窗口的位置=老的左窗口位置和该字符上一次出现的位置比较，两者取较大值。如abb情况，a->0,b->1 left = Math.max(0,b的上一次出现位置加1),直接跳过第二个b，继续遍历。\n                left = Math.max(left, map.get(s.charAt(right)) + 1);\n            }\n            //如果map里面没有，就把当前位置放进map。表示每个字符最近的出现的下标位置\n            // abc    就被装成 a->0 b->1 c->2\n            map.put(s.charAt(right), right);\n            //right-left+1，窗口长度=右边窗口-左边窗口下标+1。其中如果出现abb情况，right=2 left=2（上面的if满足）,当前的窗口就会只有1，因为左右重叠\n            int curWindowLength = right - left + 1;\n            //取较大值\n            maxLength = Math.max(maxLength, curWindowLength);\n        }\n        return maxLength;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为字符串长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107456127","body":"### 思路\n\n定义一个map,存储单词和出现个数。遍历字符串s，只能一位一位的移动。左窗口遍历的下标，右窗口为i+目标字符串数组的字符长度。然后在里面再裁剪，并存储到临时map,这是为了记录单词出现个数，防止单词超出需要的个数。结束以后，当左窗口能到达右边时，则表示该部分是目标字符串。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        if (s == null || s.length() == 0 || words.length == 0) {\n            return result;\n        }\n        //单个单词长度\n        int oneWordLength = words[0].length();\n        //单词个数\n        int wordNum = words.length;\n        //总长度\n        int allWordsLength = oneWordLength * wordNum;\n        HashMap<String, Integer> wordMap = new HashMap<>();\n        //记录每个单词出现次数\n        for (String word : words) {\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\n        }\n        //开始遍历\n        for (int i = 0; i < s.length() - allWordsLength + 1; i++) {\n            //建立临时map\n            HashMap<String, Integer> tmp = new HashMap<>();\n            //定义左指针\n            int leftSide = i;\n            int rightSide = leftSide + allWordsLength;\n            //判断窗口内\n            while (leftSide < rightSide) {\n                //裁剪单词\n                String compareWord = s.substring(leftSide, leftSide + oneWordLength);\n                //如果不存在，右移窗口\n                if (!wordMap.containsKey(compareWord)) {\n                    break;\n                }\n                //如果单词超过了，抛弃\n                if (tmp.get(compareWord)==wordMap.get(compareWord)) {\n                    break;\n                }\n                //存储到临时map,这里记录个数是为了比较单词数是否超出\n                tmp.put(compareWord, tmp.getOrDefault(compareWord, 0) + 1);\n                //窗口移动一个单词长度\n                leftSide+=oneWordLength;\n            }\n            //如果窗口能够移动到右边界（整段都符合）\n            if (leftSide==i+allWordsLength){\n                result.add(i);\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度\n\n时间复杂度O(n^2)\n\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107829530","body":"### 思路\n\n头秃，看答案了。感觉哈希表，好多数学特性题TT.\n\n### 代码\n\n```java\nimport java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108428780","body":"\n## 题目地址(876. 链表的中间结点)\n\nhttps://leetcode-cn.com/problems/middle-of-the-linked-list/\n\n## 题目描述\n\n```\n给定一个头结点为 head 的非空单链表，返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n \n\n示例 1：\n\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n\n\n示例 2：\n\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n\n\n \n\n提示：\n\n给定链表的结点数介于 1 和 100 之间。\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n- 双指针\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next!=null&&fast.next.next!=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        //如果该节点是最后，则表示奇数。slow就是答案。\n        if(fast.next==null){\n            return slow;\n        }\n        //这说明偶数\n        return slow.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109710266","body":"\n## 题目地址(26. 删除有序数组中的重复项)\n\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n## 题目描述\n\n```\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n判题标准:\n\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n如果所有断言都通过，那么您的题解将被 通过。\n\n \n\n示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n0 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums 已按 升序 排列\n```\n\n## 前置知识\n\n- 遍历数组，双指针\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  定义新数组下标，从第二个元素开始，和前一个元素比较。两个一样，丢弃，不处理。如果不一样，新数组新数组下标右移。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int index = 1;\n        for(int i=1;i<nums.length;i++){\n            if(nums[i-1]==nums[i]){\n\n            }else{\n                nums[index++]=nums[i];\n            }\n        }\n        return index;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112113170","body":"\n## 题目地址(239. 滑动窗口最大值)\n\nhttps://leetcode-cn.com/problems/sliding-window-maximum/\n\n## 题目描述\n\n```\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回 滑动窗口中的最大值 。\n\n \n\n示例 1：\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n输入：nums = [1], k = 1\n输出：[1]\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n1 <= k <= nums.length\n```\n\n## 前置知识\n\n- 单调栈\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  定义滑动窗口的大小的队列，队首是滑动窗口的最大元素。存值的时候，取出比自己小的元素，保持单调减。（看题解，大顶堆，又学了一手API妙用）\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        //结果\n        int[] ans = new int[nums.length - k + 1];\n        //定义队列，存储下标\n        Deque<Integer> deque = new ArrayDeque<>();\n        //开始遍历\n        for (int i = 0; i < nums.length; i++){\n            //获取队首的下标+窗口大小是否小于了i,如果小了。说明已经目前的最大值不能用了。\n            if (!deque.isEmpty() && deque.peekFirst() + k <= i) deque.pollFirst();\n            //判断栈顶元素是否小于当前元素，如果小于则丢弃（没有价值了）\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            //将当前元素放入栈顶\n            deque.offerLast(i);\n            //当前元素所在位置大于等于了窗口大小，则一定存在最大值，查询队首元素，（不能弹出）\n            if (i  >= k - 1) ans[i - k + 1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。k是滑动窗口大小\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(k)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085515819","body":"```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        p = len(num) - 1\n        while k:\n            k += num[p]            \n            v = k % 10    \n            num[p] = v\n            \n            k //=10\n            p -= 1\n        \n            if p < 0:\n                break\n        \n        while k:\n            v = k % 10\n            num = [v] + num\n            k //= 10\n        \n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086570363","body":"```python\nclass Solution:\n    def shortestToChar(self, S, C):\n        def letter_get(letter, dr):\n            n = len(S)\n            res, cur = [0]*n, -n\n            for i in range(n)[::dr]:\n                if S[i] == letter: cur = i\n                res[i] = abs(i - cur)\n            return res\n        \n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797319","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:        \n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087138877","body":"1. recursion\n\n``` python\n\nclass Solution:\n    \n    def decodeString(self, s: str) -> str:  \n        closePos = {}   \n        stack = []\n        for i, c in enumerate(s):\n            if c == '[':\n                stack.append(i)\n            elif c == ']':\n                closePos[stack.pop()] = i\n\n        def solve(l, r):\n            num = 0\n            ans = []\n\n            while l <= r:\n                c = s[l]\n                if c.isdigit():\n                    num = num * 10 + int(c)\n                elif c == '[':\n                    ans.append(num * solve(l + 1, closePos[l] - 1))\n                    num = 0\n                    l = closePos[l]\n                else:\n                    ans.append(c)\n                l += 1\n            return \"\".join(ans)\n        return solve(0, len(s) - 1)\n\n```\n\n2. stack\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:        \n        stack = []\n        num = 0\n    \n        stack.append(\"\")\n        \n        for c in s:\n            #print(c)\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append(num)\n                num = 0\n                stack.append(\"\")\n            elif c == ']':\n                str2 = stack.pop()\n                n = stack.pop()\n                str1 = stack.pop()                \n                stack.append(str1 + n * str2)                \n                \n            else:               \n                stack[-1] += c\n            \n            #print(tmp)\n            #print(stack)\n        return stack[0]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088258264","body":"### Analysis\nUse two stacks to reverse output order. Only move elements from input stack to output stack when previous elements in output are all popped out. \n### Code\n``` Python\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []\n        self.output = []\n\n    def push(self, x: int) -> None:\n        self.input.append(x)\n    \n    def pop(self) -> int:\n        self.move()\n        return self.output.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.output[-1]\n        \n    def empty(self) -> bool:\n        return not self.input and not self.output\n    def move(self):\n        if not self.output:\n            while self.input:\n                self.output.append(self.input.pop())\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### Complexity:\nTime Complexity: O(1) \nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089928397","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:        \n        stack = []\n        \n        for a in arr:\n            if stack and stack[-1] > a:\n                curr = stack[-1]\n                \n                while stack and stack[-1] > a:\n                    stack.pop()\n                \n                stack.append(curr)\n            \n            else:\n                stack.append(a)\n                \n        return len(stack)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091155478","body":"### Analysis:\nconnect head with tail, move l-k%l steps, then break\n\n### code\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0:\n            return head\n        \n        dummy = ListNode()\n        \n        dummy.next = head\n        l = 0\n        while dummy.next:\n            dummy = dummy.next\n            l += 1\n        \n        k = k % l\n        m = l - k\n        \n        dummy.next = head\n        \n        for i in range(m):\n            head = head.next\n            dummy = dummy.next\n        \n        dummy.next = None\n        \n        return head\n```\n\n### Complexity\nTime: O(N)\nSpace:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093074662","body":"```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        new_head = head.next\n        next_head = new_head.next\n        \n        new_head.next = head\n        head.next = self.swapPairs(next_head)\n        \n        return new_head\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094171768","body":"``` python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \n        def length(node):\n            cnt = 0            \n            while node:\n                cnt += 1\n                node = node.next               \n            return cnt\n        \n        def inorder(l, r):\n            if l > r:\n                return None\n            \n            mid = (l + r) // 2\n            left = inorder(l, mid - 1)\n            root = TreeNode(self.head.val)\n            self.head = self.head.next\n            \n            root.left = left\n            root.right = inorder(mid + 1, r)\n            \n            return root\n        \n        self.head = head\n        \n        n = length(head)\n        \n        return inorder(0, n - 1)\n            \n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094167922","body":"``` python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        node_in_B = set()\n        \n        while headB:\n            node_in_B.add(headB)\n            headB = headB.next\n        \n        while headA:\n            if headA in node_in_B:\n                return headA\n            else:\n                headA = headA.next\n        \n        return None\n```\n\n```python\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        \n        pA = headA\n        pB = headB\n        \n        while pA != pB:\n            if not pA:\n                pA = headB\n            else:\n                pA = pA.next\n            if not pB:\n                pB = headA\n            else:            \n                pB = pB.next\n        \n        return pA\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095208146","body":"```python \nclass Solution:\n \n    \"\"\"\n    def detectCycle(self, head: ListNode) -> ListNode:\n        visited = set()\n        \n        while head:\n            if head in visited:\n                return head\n            visited.add(head)\n            head = head.next\n        return None\n    \"\"\"\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                break\n        else:\n            return None\n        \n        while head != slow:\n            head = head.next\n            slow = slow.next\n            \n        return head\n    \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096835630","body":"\n```python\nclass ListNode:\n    def __init__(self, key = 0, value = 0):\n        self.key = key\n        self.value = value\n        self.next = None\n        self.prev = None\n\nclass DoubleLinkedList:\n    \"\"\"\n    tail: recent nodes\n    head: older nodes\n    add to tail\n    remove from head\n    \"\"\"\n    def __init__(self):\n        self.head = ListNode()\n        self.tail = ListNode()\n        \n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def add(self, node):\n        prev_tail = self.tail.prev\n        prev_tail.next = node\n        node.prev = prev_tail\n        \n        node.next = self.tail\n        self.tail.prev = node\n    \n    def delete(self, node):\n        prev_node = node.prev\n        after_node = node.next\n        \n        prev_node.next = after_node\n        after_node.prev = prev_node\n    \n    def move_to_tail(self, node):\n        self.delete(node)\n        self.add(node)\n    \n    def delete_from_head(self):\n        old_node = self.head.next\n        self.delete(old_node)\n        return old_node\n        \nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = dict()\n        self.list = DoubleLinkedList()\n        \n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.list.move_to_tail(node)\n            return node.value\n        else:\n            return -1\n        \n    def put(self, key: int, value: int) -> None:        \n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.list.move_to_tail(node)\n        \n        else:\n            if len(self.cache) == self.capacity:\n                old_node = self.list.delete_from_head()\n                old_key = old_node.key\n                del self.cache[old_key]\n            \n            new_node = ListNode(key, value)\n            self.cache[key] = new_node\n            self.list.add(new_node)\n            \n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098105966","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        \n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        \n        return max(left, right) + 1\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098436925","body":"```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif p and not q:\n            return False\n        elif not p and q:\n            return False\n        \n        left = self.isSameTree(p.left, q.left)\n        right = self.isSameTree(p.right, q.right)\n        cur = p.val == q.val\n        \n        return left and right and cur\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102124205","body":"``` python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_table = dict()\n        \n        for i, n in enumerate(nums):\n            if target-n in num_table:\n                return[num_table[target-n], i]\n            \n            num_table[n] = i\n                \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1106037783","body":"```python\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        freq = Counter(nums)\n        \n        max_heap = []\n        \n        for key, val in freq.items():\n            max_heap.append((-val, key))\n        \n        heapq.heapify(max_heap)\n        \n        for i in range(k):\n            res.append(heapq.heappop(max_heap)[1])\n        \n        return res\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1106026137","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        \n        for i in points:\n            dic = {}\n            for j in points:\n                if i == j:\n                    continue\n                d = (i[0]-j[0])**2 + (i[1]-j[1])**2\n                if d not in dic:\n                    dic[d] = 1\n                else:\n                    dic[d] += 1\n            for k,v in dic.items():\n                res += v*(v-1)\n        return res\n                \n                \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106022579","body":"```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_index = dict()\n        res = 0\n        l = 0\n        for r in range(len(s)):            \n            if s[r] in char_index:\n                l = max(l, char_index[s[r]] + 1)\n            \n            char_index[s[r]] = r\n            res = max(res, r - l + 1)\n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1109207033","body":"```python\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        slow = fast = head\n        while fast.next:\n            slow = slow.next\n            if fast.next.next:\n                fast = fast.next.next\n            else:\n                break\n                \n        return slow\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109202969","body":"```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \n        prev = nums[0] - 1\n        write = 0\n        \n        for read in range(len(nums)):\n            if nums[read] != prev:\n                nums[write] = nums[read]\n                write += 1\n            \n            prev = nums[read]\n        \n        \n        return write\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110557298","body":"```python\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # the left most one which is larger than or equal to \n        l = 0\n        r = len(nums) - 1\n        \n        while l <= r:\n            mid = l + (r-l)//2\n            \n            if nums[mid] >= target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n            \n            \n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085517916","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] =divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry \r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\nspace `O(M+N)` time `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086793949","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # cal the distane from the left c\r\n        l_ans = []\r\n        l_c = -float(\"inf\")\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                l_c = i\r\n            l_ans.append(abs(i-l_c))\r\n        \r\n        r_ans = [float(\"inf\") for _ in range(len(s))]\r\n        r_c = -float(\"inf\")\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                r_c = i\r\n            r_ans[i] = abs(i-r_c)\r\n        \r\n        ans = []\r\n        for r, l in zip(l_ans, r_ans):\r\n            ans.append(min(l, r))\r\n        return ans\r\n```\r\ntime `O(N)` space `O(N)`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086798751","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.add = []\r\n        self.size = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.stack.pop()\r\n            i = self.add.pop()\r\n            self.size -= 1\r\n            if self.size > 0:\r\n                self.add[-1] += i\r\n            return v+i\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        if n >= 1:\r\n            self.add[n-1] += val\r\n```\r\ntime `O(1)`, space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086969087","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c != ']':\r\n                stack.append(c)\r\n            else:\r\n                seg = \"\"\r\n                while True:\r\n                    if stack:\r\n                        val = stack.pop()\r\n                        if val != \"[\":\r\n                            seg += val\r\n                        else:\r\n                            break\r\n                k = \"\"\r\n                while True:\r\n                    if stack and stack[-1] in \"0123456789\":\r\n                        k += stack.pop()\r\n                    else:\r\n                        break\r\n                for i in range(int(k[::-1])):\r\n                    for s in seg[::-1]:\r\n                        stack.append(s)\r\n        return \"\".join(stack)\r\n```\r\ntime `O(N)` space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087904031","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        self.push_stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.pop_stack.pop()\r\n        \r\n        \r\n\r\n    def peek(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if self.pop_stack or self.push_stack:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\ntime `O(1)` space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089927561","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        chunk = []\r\n        for val in arr:\r\n            if chunk:\r\n                if chunk[-1] <= val:\r\n                    chunk.append(val)\r\n                else:\r\n                    max = chunk[-1]\r\n                    while len(chunk)>0 and chunk[-1] > val:\r\n                        chunk.pop()\r\n                    chunk.append(max)\r\n            else:\r\n                chunk.append(val)\r\n        return len(chunk)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091162606","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        head_copy = head\r\n        n = 1\r\n        while head_copy.next:\r\n            head_copy = head_copy.next\r\n            n += 1\r\n            \r\n        if k%n == 0:\r\n            return head\r\n        \r\n        head_copy = head\r\n        acc = 1\r\n        while head_copy.next:\r\n            if acc == n-k%n:\r\n                new_head = head_copy.next\r\n                head_copy.next = None\r\n            else: \r\n                head_copy = head_copy.next\r\n                acc += 1\r\n        help_head = new_head\r\n        while help_head.next:\r\n            help_head = help_head.next\r\n        help_head.next = head\r\n        return new_head\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092541360","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        old_head = head\r\n        acc = 1\r\n        while old_head.next:\r\n            if acc % 2 != 0:\r\n                # need swap\r\n                if acc == 1:\r\n                    next_node = old_head.next\r\n                    old_head.next = next_node.next\r\n                    next_node.next = old_head\r\n                    result = next_node\r\n                    pre_node = next_node\r\n                else:\r\n                    next_node = old_head.next\r\n                    old_head.next = next_node.next\r\n                    next_node.next = old_head\r\n                    pre_node.next = next_node\r\n                    pre_node = next_node\r\n            else:\r\n                pre_node = old_head\r\n                old_head = old_head.next\r\n            acc += 1\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093801416","body":"```\r\nclass Solution:\r\n    \r\n    def tolist(self, head):\r\n        val = []\r\n        while head:\r\n            val.append(head.val)\r\n            head = head.next\r\n        return val\r\n    \r\n    def genTree(self, vals, start, end):\r\n        \r\n        if start > end:\r\n            return None\r\n        mid = (start + end)//2\r\n        node = TreeNode(val=vals[mid])\r\n        if start == end:\r\n            return node\r\n        node.left = self.genTree(vals, start, mid-1)\r\n        node.right = self.genTree(vals, mid+1, end)\r\n        return node\r\n        \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        vals = self.tolist(head)\r\n        return self.genTree(vals, 0, len(vals)-1)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094650913","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pa = headA\r\n        pb = headB\r\n        while pa != pb:\r\n            pa = headB if pa is None else pa.next\r\n            pb = headA if pb is None else pb.next\r\n        return pa\r\n```\r\ntime `O(A+B)` space `O(1)`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094662719","body":"```\r\nclass Solution:\r\n    \r\n    def getIntersect(self, head):\r\n        fast, slow = head, head\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return None\r\n        \r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if not slow or not fast:\r\n                return None\r\n            if slow == fast:\r\n                return slow\r\n        return None\r\n        \r\n        \r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        slow = self.getIntersect(head)\r\n        fast = head\r\n        if slow == None:\r\n            return None\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095548789","body":"```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        self.s = capacity\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n            return self[key]\r\n        else:\r\n            return -1\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.s:\r\n            self.popitem(last=False)\r\n```\r\ntime `O(1)` space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097360832","body":"```\r\nclass Solution:\r\n        \r\n    def helper(self, root, d):\r\n        if not root:\r\n            return d\r\n        d_l = self.helper(root.left, d+1)\r\n        d_r = self.helper(root.right, d+1)\r\n        return max(d_l, d_r)\r\n        \r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return self.helper(root, 0)\r\n```\r\ntime `O(N)` space `O(logN)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1100968340","body":"```\r\nclass Solution:\r\n        \r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if p is None and q is None:\r\n            return True\r\n        elif p is None and q is not None:\r\n            return False\r\n        elif p is not None and q is None:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return True and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\ntime `O(N)` space `logN`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099922459","body":"```\r\nclass Solution:\r\n    def __init__(self):\r\n        self.ans = 0\r\n        \r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        \r\n        def dfs(root, num):\r\n            if not root:\r\n                return\r\n            num += root.val\r\n            if not root.left and not root.right:\r\n                self.ans += num\r\n            dfs(root.left, num*10)\r\n            dfs(root.right, num*10)\r\n            \r\n        dfs(root, 0)\r\n        return self.ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1101052069","body":"```\r\nfrom collections import deque\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        s = deque()\r\n        s.append(root)\r\n        while s:\r\n            res = s[0].val\r\n            length = len(s)\r\n            for _ in range(length):\r\n                cur = s.popleft()\r\n                if cur.left:\r\n                    s.append(cur.left)\r\n                if cur.right:\r\n                    s.append(cur.right)\r\n        return res\r\n```\r\ntime `O(N)` space `# of nodes in most widest layer`","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100804937","body":"```\r\nclass Codec:\r\n        \r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        # BFS\r\n        # if not root:\r\n        #     return self.code\r\n        # self.q.append(root)\r\n        # while len(self.q):\r\n        #     node = self.q.popleft()\r\n        #     if not node:\r\n        #         self.code.append(\"null\")\r\n        #     else:\r\n        #         self.code.append(node.val)\r\n        #         self.q.append(node.left)\r\n        #         self.q.append(node.right)\r\n        # return self.code\r\n        \r\n        # DFS\r\n        def dfs(node, code):\r\n            if not node:\r\n                code.append(\"null\")\r\n                return\r\n            code.append(str(node.val))\r\n            dfs(node.left, code)\r\n            dfs(node.right, code)\r\n        code = [] \r\n        if not root:\r\n            return \"\"\r\n        dfs(root, code)\r\n        return \" \".join(code)\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        def build(data):\r\n            \r\n            if not data:\r\n                return None\r\n            val = data.popleft()\r\n            if val == \"null\":\r\n                return None\r\n            node = TreeNode(int(val))\r\n            node.left = build(data)\r\n            node.right = build(data)\r\n            return node\r\n        if not data:\r\n            return None\r\n        data = data.split()\r\n        data = collections.deque(data)\r\n        root = build(data)\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101244336","body":"```\r\nclass Solution:\r\n    def verticalTraversalHelper(self, root, vals, col, row):\r\n        if root:\r\n            vals.append((col, row, root.val))\r\n            self.verticalTraversalHelper(root.left, vals, col-1, row+1)\r\n            self.verticalTraversalHelper(root.right, vals, col+1, row+1)\r\n        \r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        vals = []\r\n        results = {}\r\n        if root:\r\n            self.verticalTraversalHelper(root, vals, 0, 0)\r\n            vals.sort()\r\n            for comb in vals:\r\n                if comb[0] not in results:\r\n                    results[comb[0]] = [comb[2]]\r\n                else:\r\n                    results[comb[0]].append(comb[2])\r\n            return list(results.values())\r\n        else:\r\n            return []\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102165079","body":"```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        pool = {}\r\n        for i, val in enumerate(nums):\r\n            if val not in pool:\r\n                pool[target-val] = i\r\n            else:\r\n                return i, pool[val]\r\n```\r\ntime `O(N)` space `O(N)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105989239","body":"```\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if len(s) <= 1:\r\n            return len(s)\r\n        l = 0\r\n        pool = set()\r\n        ans = 0\r\n        for r in s:\r\n            if r not in pool:\r\n                pool.add(r)\r\n            else:\r\n                while r in pool:\r\n                    if s[l] in pool:\r\n                        pool.remove(s[l])\r\n                    l += 1\r\n                pool.add(r)\r\n            ans = max(ans, len(pool))\r\n        return ans\r\n```\r\ntime `O(N)` space `O(K)` k=# of chars","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107968072","body":"```\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        s, f = head, head\r\n        while f and f.next:\r\n            s = s.next\r\n            f = f.next.next\r\n        return s\r\n```\r\ntime `O(N/2)` space `O(1)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109354539","body":"```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if len(nums) <= 1:\r\n            return len(nums)\r\n        l = 0\r\n        k = 1\r\n        for r in range(1, len(nums)):\r\n            if nums[r] != nums[l]:\r\n                l += 1\r\n                nums[l] = nums[r]\r\n                k += 1\r\n        return k\r\n```\r\ntime `O(N)` space `O(1)`","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112897706","body":"```\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        in_degree, out_degree = [0]*(n+1), [0]*(n+1)\r\n        for f, t in trust:\r\n            in_degree[t] += 1\r\n            out_degree[f] += 1\r\n        for i in range(1, n+1):\r\n            if in_degree[i] == n-1 and out_degree[i] == 0:\r\n                return i\r\n        return -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113924074","body":"```\r\nclass Solution:\r\n    def dfs(self, g, colors, n, i, c):\r\n        \"\"\"\r\n        g: graph\r\n        colors: color list\r\n        n: # of v\r\n        i: v\r\n        c: group, -1 or 1\r\n        \"\"\"\r\n        # we color i as c\r\n        colors[i] = c\r\n        # for every dislikes, we try to assign -c, if success, then we can assign c to current v, else false\r\n        for j in range(n):\r\n            # for each dislike v, we color -c\r\n            if g[i][j] != 0:\r\n                # if disliked v has already been colored as same color c, then failed\r\n                if colors[j] == c:\r\n                    return False\r\n                # if disliked v has not been colored, then we try to color it as -c, if success, continue to color the next \r\n                # dislike v, else False\r\n                if colors[j] == 0 and not self.dfs(g, colors, n, j, -1*c):\r\n                    return False\r\n        return True\r\n                \r\n        \r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        # create a graph\r\n        g = [[0]*n for _ in range(n)]\r\n        for i, j in dislikes:\r\n            g[i-1][j-1] = 1\r\n            g[j-1][i-1] = 1\r\n        # create colors, -1 group1, 1 group2\r\n        colors = [0]*n\r\n        for i in range(n):\r\n            # if not colored, we assign it 1\r\n            if colors[i] == 0 and not self.dfs(g, colors, n, i, 1):\r\n                return False\r\n        return True\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085528745","body":"## 代码\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086470126","body":"## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const sArr = s.split('');\r\n    const keyArr = [];\r\n    const ans = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        if(ele === c){\r\n            keyArr.push(i);\r\n        }\r\n    }\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        let minLen = sArr.length;\r\n        for (let j = 0; j < keyArr.length; j++) {\r\n            const keyEle = keyArr[j];\r\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\r\n        }\r\n        ans.push(minLen);\r\n    }\r\n    return ans;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839680","body":"## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.length = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.length) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  return this.stack.pop() || -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (let i = 0; i < k; i++) {\n    if (!this.stack[i]) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087183681","body":"## code\n```js\nvar decodeString = function(s) {\n    const stack = [];\n    const strArr = s.split('');\n    while(strArr.length){\n        if (strArr[strArr.length-1] !== '[') {\n            stack.push(strArr.pop());\n        }else {\n            strArr.pop() // 去除 '['\n            let num = '';\n            while(!Number.isNaN(Number(strArr[strArr.length-1]))){\n                num = strArr.pop() + num;\n            }\n            let str = '';\n            while(stack[stack.length-1] !== ']'){\n                str = str + stack.pop();\n            }\n            stack.pop() // 去除 ']'\n            stack.push(str.repeat(Number(num)));\n        }\n    }\n    return stack.reverse().join('');\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088634322","body":"## code\n\n```js\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089926902","body":"## 思路\r\n值得思考的题目，看了答案半天，才懂\r\n## code\r\n```js\r\nclass Stack {\r\n    constructor() {\r\n        this.list = [];\r\n    }\r\n    push(val) {\r\n        this.list.push(val);\r\n    }\r\n    pop() {\r\n        return this.list.pop();\r\n    }\r\n    empty() {\r\n        return this.list.length === 0;\r\n    }\r\n    peek() {\r\n        return this.list[this.list.length - 1];\r\n    }\r\n    size() {\r\n        return this.list.length;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    const stack = new Stack();\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (stack.empty() || stack.peek() <= arr[i]) {\r\n            stack.push(arr[i]);\r\n        } else {\r\n            const temp = stack.pop();\r\n\r\n            while (stack.peek() > arr[i]) {\r\n                stack.pop();\r\n            }\r\n\r\n            stack.push(temp);\r\n        }\r\n    }\r\n    return stack.size();\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091003058","body":"## code\n```js\nvar rotateRight = function(head, k) {\n    let length = 1;\n    let cur = head;\n    if(cur === null) return null\n    while(cur.next){\n        length ++;\n        cur = cur.next; \n    }\n    cur.next = head; // 尾部续接\n    let node = {\n        val:head.val,\n        next:null,\n    }\n    let cur2 = head;\n    for(let i = 0;i<length-(k%length)-1;i++){\n        cur2 = cur2.next;\n    } \n    node.val = cur2.next.val;\n    node.next = cur2.next;\n    cur2.next = null;\n    \n    // head.val = node.val;\n    // head.next = node.next;\n    return node.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092348328","body":"## code\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {return head;}\r\n    let cur = head;\r\n    while(cur && cur.next){\r\n        let temp;\r\n        temp = cur.val;\r\n        cur.val = cur.next.val;\r\n        cur.next.val = temp;\r\n        cur = cur.next.next;\r\n    }\r\n    return head;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093744104","body":"## code\n```js\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094287436","body":"## code\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  let a = headA,\r\n    b = headB;\r\n  while (a != b) {\r\n    a = a === null ? headB : a.next;\r\n    b = b === null ? headA : b.next;\r\n  }\r\n  return a;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094447229","body":"## code\n```js\n var detectCycle = function(head) {\n     if (!head || !head.next) {\n         return null;\n     }\n     let node = head;\n     const nodeSet = new Set();\n     while (node) {\n        if (nodeSet.has(node)) {\n            return node;\n        }else{\n            nodeSet.add(node);\n            node = node.next;\n        }\n     }\n     return null;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096838744","body":"## code\r\n```js\r\nclass DoubleLinkedListNode {\r\n    constructor(key, value) {\r\n        this.key = key\r\n        this.value = value\r\n        this.prev = null\r\n        this.next = null\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity\r\n        this.usedSpace = 0\r\n        // Mappings of key->node.\r\n        this.hashmap = {}\r\n        this.dummyHead = new DoubleLinkedListNode(null, null)\r\n        this.dummyTail = new DoubleLinkedListNode(null, null)\r\n        this.dummyHead.next = this.dummyTail\r\n        this.dummyTail.prev = this.dummyHead\r\n    }\r\n\r\n    _isFull() {\r\n        return this.usedSpace === this.capacity\r\n    }\r\n\r\n    _removeNode(node) {\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        node.prev = null\r\n        node.next = null\r\n        return node\r\n    }\r\n\r\n    _addToHead(node) {\r\n        const head = this.dummyHead.next\r\n        node.next = head\r\n        head.prev = node\r\n        node.prev = this.dummyHead\r\n        this.dummyHead.next = node\r\n    }\r\n\r\n    get(key) {\r\n        if (key in this.hashmap) {\r\n            const node = this.hashmap[key]\r\n            this._addToHead(this._removeNode(node))\r\n            return node.value\r\n        }\r\n        else {\r\n            return -1\r\n        }\r\n    }\r\n\r\n    put(key, value) {\r\n        if (key in this.hashmap) {\r\n            // If key exists, update the corresponding node and move it to the head.\r\n            const node = this.hashmap[key]\r\n            node.value = value\r\n            this._addToHead(this._removeNode(node))\r\n        }\r\n        else {\r\n        // If it's a new key.\r\n            if (this._isFull()) {\r\n                // If the cache is full, remove the tail node.\r\n                const node = this.dummyTail.prev\r\n                delete this.hashmap[node.key]\r\n                this._removeNode(node)\r\n                this.usedSpace--\r\n            }\r\n            // Create a new node and add it to the head.\r\n            const node = new DoubleLinkedListNode(key, value)\r\n            this.hashmap[key] = node\r\n            this._addToHead(node)\r\n            this.usedSpace++\r\n        }\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097453744","body":"## code\r\n```js\r\nvar maxDepth = function (root) {\r\n  if (!root) {\r\n    return 0;\r\n  }\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098788851","body":"## code\r\n```js\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) {\r\n    return true;\r\n  }\r\n  return p?.val === q?.val && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100153906","body":"## code\r\n```js\r\nvar sumNumbers = function (root) {\r\n  let sum = 0;\r\n  function dfs(root, cur) {\r\n    if (!root) {\r\n      return;\r\n    }\r\n    let curSum = root.val + cur * 10;\r\n    if (!root.left && !root.right) {\r\n      sum += curSum;\r\n      return;\r\n    }\r\n    dfs(root.left, curSum);\r\n    dfs(root.right, curSum);\r\n  }\r\n  dfs(root, 0);\r\n  return sum;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100696410","body":"## code \r\n```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findBottomLeftValue = function (root) {\r\n  let res = 0;\r\n  const queue = [root];\r\n  while (queue.length !== 0) {\r\n    let currentLen = queue.length;\r\n    const arr = [];\r\n    while (currentLen--) {\r\n      let node = queue.shift();\r\n      arr.push(node.val);\r\n      node.left && queue.push(node.left);\r\n      node.right && queue.push(node.right);\r\n    }\r\n    res = arr[0];\r\n  }\r\n  return res;\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109841553","body":"```js\nvar removeDuplicates = function(nums) {\n    let resNum = 1\n    nums.forEach((val, ind) => {\n        if (ind != 0 && val != nums[ind - 1]) {\n            resNum++\n            nums[resNum-1] = val\n        }\n    })\n    return resNum\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111023357","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right){\n        const mid = Math.floor(left+(right - left)/2);\n        if(nums[mid] === target){\n            return mid;\n        }\n        if(nums[mid] > target){\n            right = mid - 1;\n        }\n        if(nums[mid] < target){\n            left = mid + 1;\n        }\n    }\n    return left;\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085530541","body":"## 思路\n1. 比较intuitive的想法就是先转换成字符串-> 数字+k ->字符串 \n2.  \n## 代码\n1. \n’‘’\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n                \n        int_str = ''\n\n        for i in num:\n            int_str += str(i)\n        \n        int_str = str(int(int_str) + k)\n\n        res=[int(i) for i in int_str]\n\n        return res\n‘’‘\n## 复杂度分析\n1. Time complexity: On; Space complexity On.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086603805","body":"## 思路\n先建造一个index list 存储target character相应的index\n\n在用index list 里面的值分别减去字符串单个的index，取最小值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        index = [i for i, j in enumerate(s) if j==c]\n\n        result = []\n        for i in range(len(s)):\n            a=[]\n            for ind in index:\n                b = abs(ind - i)\n                a.append(b)\n            min_num = min(a)\n            result.append(min_num)\n\n        return result\n\n```\n\n## 复杂度分析\n时间：最差On^2, 正常O(mn)    m 为index list 长度(最差m=n)  \\\n空间： On, index list 的worst case, On, result index 也是On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086742469","body":"## 思路一：暴力求解\n\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            stack[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\nTIME COMPLEXITY:  push 和 pop 都为O(1)，increment 为O(k),最差为O1 \\\nSPACE COMPLEXITY: O(maxSize)\n\n## 思路二：优化思路一的increment\n这里是参考了答案和评论区\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        if len(self.inc)>1:\n            self.inc[-2] +=self.inc[-1]\n           \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.inc))-1] += val\n```\n## 复杂度分析\nTIME COMPLEXITY: 都为O1 \\\nSPACE COMPLEXITY:  O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086937390","body":"## 思路 使用Stack和匹配括号的思想\npush value 进stack 直到碰到 ']', pop出value 进行相应数字的操作\n需要注意k的大小，不一定是个位数\n\n主要是string的需要很多细节处理，append pop出来的值什么时候需要reverse，pop出来的数字是以string形式出现，怎么转换成数字，reversed 不能和数字直接相乘，需要‘’。join()等等\n## 代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n\n        for char in s:\n            if char !=']':\n                stack.append(char)\n                continue\n\n            string = []\n            # 把 需要重复的值 pop出来，这个while循环结束之后stack.peek()是'['\n            while stack and stack[-1]!='[':\n                string.append(stack.pop())\n\n            # 去掉 '['    \n            stack.pop()\n\n\n            #这里我们要考虑k的值是多位数的情况, 第一个pop出来的的是个位数，再是十位数，百位数\n            #用repeat记录最终要repeat的次数\n            #用base记录有几位数，第一个数字 + 10 * 第二个数字 + 100* 第三个数字.....\n            repeat = 0\n            base = 1\n\n\n            #stack.pop()出来是数字的string形式，所以用ord()方法得到相应的数字\n            # ‘’join() 之后才能以string的形式进行运算\n            while stack and stack[-1].isdigit():\n                repeat = repeat + (ord(stack.pop())-ord('0')) * base\n                base = base * 10\n            stack.append(''.join(reversed(string))*repeat)\n\n            #现在得到的stack是 分开的 string element 例如 ['aaa', 'bcbc']\n\n\n        return ''.join(stack)\n        \n```\n## 复杂度分析\n不怎么会算复杂度，这里猜的 \\\n时间：O(n)\\\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087948715","body":"## 思路：第一次只用了一个stack，不符合题目要求两个stack\n还是先把想法留下\n\n## 代码\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        return self.queue.pop(0)\n\n    def peek(self) -> int:\n        return self.queue[0]\n\n    def empty(self) -> bool:\n        return self.queue ==[]\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n\n## 思路二：两个stack\noutqueue stack 直接 append inqueue pop 出来的值\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.inqueue = []\n        self.outqueue =[]\n\n    def push(self, x: int) -> None:\n        self.inqueue.append(x)\n        self.outqueue.append(self.inqueue.pop())\n\n    def pop(self) -> int:\n        return self.outqueue.pop(0)\n\n    def peek(self) -> int:\n        return self.outqueue[0]\n\n\n    def empty(self) -> bool:\n        return (not self.inqueue) and (not self.outqueue)\n        \n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## 复杂度分析 \n时间：\\\nPush - On \\\nPop - On \\\nPeek - O1 \\\nempty -O1 \\\n空间： \\\nPush - On \\\nPop - O1 \\\nPeek - O1 \\\nempty -O1 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089835794","body":"## 思路一： 先sorted，比较 sum\narr =              [2,2,1,3,4,4]\nsorted=\t\t\t\t\t[1,2,2,3,4,4]\n\n我们可以看出 \n* 2+2+1 = 1+2+3\n* 3 = 3\n* 4 = 4\n\n另一个例子\n\narr =            [1,1,2,1,1,3,4,5,1,6]\nsorted =      [1,1,1,1,1,2,3,4,5,6]\n\n* 1=1\n* 1=1\n* 2+1+1+3+4+5+1 = 1+1+1+2+3+4+5\n* 6=6\n\n只要到目前index的和是一样的话，就可以当成一个块\n\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sor = arr.copy()\n        sor.sort()\n        sum1= 0\n        sum2 =0\n\n        j=0\n        for i in range(len(arr)):\n            sum1 += arr[i]\n            sum2 += sor[i]\n\n            if sum1==sum2:\n                j+=1\n                sum1 = 0\n               #print(f'sum1: {sum1}')\n                sum2 = 0\n               # print(f'sum2: {sum2}')\n             \n        return j\n```\n## 复杂度分析\n时间：Onlogn \\\n空间：On\n\n## 思路二：左边chunk的最大值肯定小于等于右边chunk的最大值\n\n\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        res = 1\n        \n        max_ = arr[0]\n        \n        \n        for i in range(1,n,1):\n            min_ = arr[i]\n            for j in range(i+1 ,n ,1):\n                min_ = min(min_,arr[j])\n            if max_ <= min_:\n                res+=1\n            max_ = max(arr[i],max_)\n        \n        return res\n```\n## 复杂度分析\n时间：O(n^2), for every i loop 都会遍历 j:n 来找最小值 \\\n空间：O1\n\n\n## 思路三:  用Stack\n一开始先去做了 769\n没想到用stack， 看了tag 有monotonic stack，才意识到要这么做\n以后要记住 这种单调递增的想到栈\n\n-_-  没写出来，看了官方题解的。。。还是要多加练习\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # [1,1,2,1,1,3,4,5,1,6]\n        # [1,1,5,6]\n        \n        stack = []\n        \n        for num in arr:\n            if stack and stack[-1] > num:\n                curr_max = stack[-1]\n                \n                while stack and stack[-1]>num:\n                    stack.pop()\n                stack.append(curr_max)\n            else:\n                stack.append(num)\n                \n        return len(stack)\n            \n```\n## 复杂度分析\n时间：On \\\n空间：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091303058","body":"## 思路\n尾结点连到头结点，并在相应的cutoff位置，让cutoff.next指向None\n\n## 代码\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n\n        \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        tail = head \n        n = 1\n        \n        while tail.next:\n            tail = tail.next\n            n+=1 # 找到尾结点\n        \n        # 尾结点连到头部\n        tail.next = head\n        \n        # 接下来找新的断点\n        \n        cut_off = head\n        for i in range(n-k%n-1):\n            cut_off = cut_off.next\n            \n        # 断掉之前记录下新head的值\n        head = cut_off.next\n        \n        cut_off.next = None\n            \n        return head\n        \n```\n\n## 复杂度分析\n时间：On，这里的小优化就是当k很大的时候，旋转的次数 = k%长度 \\\n空间：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092512534","body":"## 思路：Iterative\n关键是要记录好指针的位置\n## 代码\n```\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        # [1] [2] [3] [4]\n        # [2] [1] [4] [3]\n        dummy = ListNode(0,head)\n        \n        # [dummy]   [1]   [2]   [3]   [4]\n        #  temp    node1 node2\n        temp = dummy\n        \n        # 因为是两两交换，所以是 while temp.next and temp.next.next:\n        while temp.next and temp.next.next:\n            \n            #[dummy] 指向[2]的时候，会丢掉[1]的位置，所以要记住\n            # node_1 为 [1]\n            node_1 = temp.next\n            # node_2 为 [2]\n            node_2 = temp.next.next\n            \n            # [temp] 指向 [2]\n            temp.next = node_2\n            # [2] 指向 [1] 的时候， 会丢掉 [3] 的位置，所以要先让[1] 指向 [3]\n            node_1.next = node_2.next\n            # 把 [2] 指向 [1]\n            node_2.next = node_1\n            \n            # 现在是这样\n            #[dummy] [2] [1] [3] [4]\n            \n            # 把 temp 移动到 [1]\n            # [dummy] [2] [1]   [3]     [4]\n            #             temp node1 node2\n            temp = node_1\n            \n        return dummy.next\n\n```\n## 复杂度\nTime Complexity : O(N) where N is the size of the linked list. /\n\nSpace Complexity : O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093349206","body":"## 思路一： linked list换成sorted list\n先去做了108  Convert Sorted Array to Binary Search Tree\n## 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n          \n        def buildBSTfromList(nums,l,r) -> TreeNode:\n\n            if l>r:\n                return None\n            m = l + (r-l)//2\n            root = TreeNode(nums[m])\n            root.left = buildBSTfromList(nums,l,m-1)\n            root.right = buildBSTfromList(nums,m+1,r)\n\n            return root\n        \n        res = []\n        while head:\n            res.append(head.val)\n            head = head.next\n        \n        return buildBSTfromList(res,0,len(res)-1)\n        \n```\n\n## 复杂度\n时间：On /\n空间：On\n\n## 思路二：双指针\n思路我有了，但是代码一直没搞明白 /\n答案参考了评论区，官方题解 /\n还是要多多学习 /\n## 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n          \n        if not head:\n            return head\n        \n        pre = None\n        slow = head\n        fast = head\n      \n        # 找中间节点\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n            \n            \n        # 如果slow = head的情况：\n        if pre:\n            pre.next = None\n        \n        node = TreeNode(slow.val)\n        \n        if slow == fast:\n            return node\n        \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        \n        return node\n```\n## 复杂度分析\n令 n 为链表长度。 /\n\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)O /\n\n空间复杂度：空间复杂度为O(logn)O\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094215958","body":"## 思路一：hash table\n把b出现过的node存到set里面，遍历a，如果出现相同的node，那个node就是交点，如果没有返回None\n\n## 代码\n\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \n        b_nodes = set()\n        \n        while headB:\n            b_nodes.add(headB)\n            headB = headB.next\n            \n        while headA:\n            \n            if headA in b_nodes:\n                return headA\n            headA = headA.next\n        \n        return None\n```\n\n## 复杂度分析\n时间：O（m+n） \\\n空间：O（m) / O（n） 看哪个链表更长\n\n## 思路二：two pointers\n假设 Linked List， A，B 有相交点\n\na = Linked List A 在相交点之前的长度\nb = Linked List B 在相交点之前的长度\nc = 相交点之后的长度\n\n那么\n\na + b + c = b + a + c\n\n我们用两个指针分别指向A,B，在遍历完A,B之后，交换遍历，相遇的node就是相交的node，要是没有的话说明不相交。\n\n这里我们就不需要占用额外space去存储出现过的值了\n## 代码\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \n        dummy_a = headA\n        dummy_b = headB\n        \n        while dummy_a != dummy_b:\n            \n            dummy_a = headB if dummy_a is None else dummy_a.next\n            dummy_b = headA if dummy_b is None else dummy_b.next\n            \n                \n        return dummy_a\n```\n## 复杂度\n时间: O(n+m) \\\n空间：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094353120","body":"## 思路一：Hash Table\n\n## 代码\n```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return None\n        \n        memo = set()\n        \n        p = head\n        \n        while p:\n            if p in memo:\n                return p\n            else:\n                memo.add(p)\n                p = p.next\n```\n\n## 复杂度分析\n时间：On \\\n空间：On\n\n## 思路二：双指针\n快慢双指针\n一开始快指针每次前进两步，慢指针前进一步。当两个指针相遇之后，把快指针放回head，并以一步的速度前进。直到下次相交的地方就是入口\n\n1. 首先要判断环存不存在\n\t\t* \t有环的话，快慢指针必然相遇\n\t\t* \t没有环的时候，快指针会visit None，会catch error\n\t\t\n2. 知道有环之后，判定entry point\n    *   假设 a 是链表开始到entry point的距离\n    *   假设 b 是entry point到快慢指针第一次相遇的距离\n    *   假设 c 是 快慢指针第一次相遇到entry point的距离，也就是周长-b\n\n* \t\t慢指针 的 路程为 a+b\n* \t\t快指针 的 路程为 2（a+b），也可以写成 a + b + c + a\n\n\n2(a+b) = 2a + b + c\n\n2b = b + c\n\nb = c\n\n因此当快慢指针相遇之后，我们把快指针放回head，每次走一步，下一次和慢指针相交的时候就是entry point\n\n## 代码：\n```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return None\n        \n        slow = head\n        fast = head\n        \n        while fast is not None and fast.next is not None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        else:\n            return None\n            \n        fast = head\n        \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        \n        return fast\n```\n## 复杂度：\n时间：On \\\n空间：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095338909","body":"## 哈希表+双向链表\n看到O1的get和put时间就想到Hash Table\n移动新建的和删除最不常使用的想到 linked list\n这道题之前没写过双向链表\n所以看了答案写的。。\n\n## 代码\n```\nclass DoubleLinkedListNode():\n    # 创建一个双向链表\n    def __init__(self,key=None,value=None):\n        self.key = key\n        self.value = value\n        self.prev= None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 初始化链表\n        self.head = DoubleLinkedListNode()\n        self.tail = DoubleLinkedListNode()\n        \n        self.head.next = self.tail\n        self.tail.prev= self.head\n        \n    def move_node_to_head(self,key):\n        # 先把哈希表指向的node提出来\n        node = self.hashmap[key]\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        # 把这个node插入头结点前面\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n        \n    def add_node_to_head(self,key,value):\n        new = DoubleLinkedListNode(key,value)\n        self.hashmap[key] = new\n        new.prev = self.head\n        new.next = self.head.next\n        self.head.next.prev = new\n        self.head.next = new\n        \n    def pop_tail(self):\n        # 哈希表去掉最后一个节点\n        last_node = self.tail.prev\n        self.hashmap.pop(last_node.key)\n        # 去掉节点\n        last_node.prev.next = self.tail\n        self.tail.prev= last_node.prev\n        return last_node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            self.move_node_to_head(key)\n        res = self.hashmap.get(key,-1)\n        if res ==-1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            self.hashmap[key].value = value\n            self.move_node_to_head(key)\n        else:\n            if self.capacity <= len(self.hashmap):\n                self.pop_tail()\n            self.add_node_to_head(key,value)\n```\n\n## 复杂度分析\n时间：O1 for put，get \\\n空间复杂度： O（capacity）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097462671","body":"## 思路：recursive\n\n二叉树的深度 是 root 子树高度+1 （root自己）所以可以用递归\n\n```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        else:\n            left_max = self.maxDepth(root.left)\n            right_max = self.maxDepth(root.right)\n            \n        return max(left_max,right_max)+1\n```\n\n## 复杂度分析\n时间：我们只遍历一遍 所以是On \\\n空间：如果这个tree是相对平衡的二叉树，我们可以实现 Ologn，最差的情况是On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098777691","body":"## 思路：递归\n\n## 代码\n```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```\n\n## 复杂度\n时间：On \\\n空间：On，最好的情况是Ologn 如果树比较平衡的情况下","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099814249","body":"## DFS preorder\n\n## 代码\n\n```\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        total = 0\n        stack = [(root,0)]\n        \n        while stack:\n            root, curr_num = stack.pop()\n            if root is not None:\n                curr_num = curr_num * 10 + root.val\n                if root.left is None and root.right is None:\n                    total += curr_num\n                else:\n                    stack.append((root.left, curr_num))\n                    stack.append((root.right,curr_num))\n        return total\n```\n\n## 复杂度\n\n\n时间复杂度：O(n) \\\n\n空间复杂度：O(h) h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100583441","body":"## 思路：双向队列\n从右往左bfs遍历，不断leftpop\n最后剩下的是答案\n## 代码\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return None\n        queue = collections.deque([root])\n        ans = None\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                ans = node = queue.popleft()\n                if node.right:\n                    queue.append(node.right)\n                if node.left:\n                    queue.append(node.left)\n        return ans.val\n```\n\n## 复杂度分析\n时间 On？\n空间 Oh?\n不确定。。。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100828540","body":"## 思路 BFS\n参考答案以及评论区\n## 代码\n```\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = ''\n        queue = collections.deque([root])\n\n        while queue:\n            root = queue.popleft()\n            if root:\n                res += str(root.val)\n                queue.append(root.left)\n                queue.append(root.right)\n            else:\n                res += \"_\"\n            res += \" \"\n        return res\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        dt = data.split()\n        if dt[0] ==\"_\":\n            return None\n        queue = []\n        root = TreeNode(dt[0])\n        queue.append(root)\n        i = 1\n        while queue:\n            curr = queue.pop(0)\n            if curr == None:\n                continue\n            curr.left = TreeNode(dt[i]) if dt[i] != \"_\" else None\n            curr.right = TreeNode(dt[i+1]) if dt[i+1] !=\"_\" else None\n            i+=2\n            queue.append(curr.left)\n            queue.append(curr.right)\n        return root\n```\n\n## 复杂度\n时间：On\n空间：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101171779","body":"## 思路一 BFS\n根据column，row来记录坐标\n然后再sort value\n学会了ordereddict：\nOrderedDict preserves the order in which the keys are inserted. A regular dict doesn’t track the insertion order and iterating it gives the values in an arbitrary order. By contrast, the order the items are inserted is remembered by OrderedDict.\n## 代码\n```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        node_list = []\n\n        def BFS(root):\n            queue = deque([(root, 0, 0)])\n            while queue:\n                node, row, column = queue.popleft()\n                if node is not None:\n                    node_list.append((column, row, node.val))\n                    queue.append((node.left, row + 1, column - 1))\n                    queue.append((node.right, row + 1, column + 1))\n\n        # step 1). construct the global node list, with the coordinates\n        BFS(root)\n\n        # step 2). sort the global node list, according to the coordinates\n        node_list.sort()\n\n        # step 3). retrieve the sorted results partitioned by the column index\n        ret = OrderedDict()\n        for column, row, value in node_list:\n            if column in ret:\n                ret[column].append(value)\n            else:\n                ret[column] = [value]\n\n        return ret.values()\n```\n## 复杂度分析\n时间 Onlogn \\\n空间 On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102061623","body":"## 思路一：暴力求解\n\n## 代码\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        pos = 0\n        \n        is_target = False\n        \n        while pos < len(nums) and not is_target:\n            new_pos = pos+1\n            while new_pos< len(nums) and not is_target:\n                if nums[pos]+nums[new_pos] ==target:\n                    is_target = True\n                    return [pos,new_pos]\n                else:\n                    new_pos = new_pos +1\n                    \n            pos= pos+1\n            \n```\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i] + nums[j] ==target:\n                    return [i,j]\n```\n\n\n## 思路二 hashmap\n\n## 代码\n```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \n        memo = {}\n        \n        for i, val in enumerate(nums):\n            other_num = target - val\n            if other_num in memo:\n                return [i,memo[other_num]]\n            memo[val] = i\n        return None\n        \n```\n## 复杂度分析\nTime complexity: O(n).\n\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103677380","body":"## 思路一：count the frequency and sort the frequency to value list, trturn top k item\n\n## 代码\n```\nfrom collections import Counter\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \n        if k ==len(nums):\n            return nums\n        \n        count = Counter(nums)\n        \n        new_count = sorted([(freq,key) for key,freq in count.items()],reverse=True)[:k]\n        \n        return [key for freq,key in new_count]\n```\n## 复杂度\n时间：Onlogn\n空间：On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104952904","body":"## 思路二：Hash Table\n看题解的，每次做哈希表的时候都不清楚存的内容是什么？ 是value，index，距离等等。。。还需要多练习\n## 代码\n```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) <=2:\n            return 0\n        \n        n = len(points)\n        res = 0\n        \n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                distance = abs(points[i][1]-points[j][1])**2+abs(points[i][0]-points[j][0])**2 \n                m[distance] +=1\n            \n            for count in m.values():\n                res += count*(count-1)\n                \n        return res\n    \n```\n## 复杂度\n时间 On^2 \\\n空间 On","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107434511","body":"## 思路 HashTable，Pointer\n参考CSDN答案\n先使用一个字典统计一下words中每个单词的数量。由于每个单词的长度一样，以题中给的例子而言，可以3个字母3个字母的检查，如果不在字典中，则break出循环。有一个技巧是建立一个临时字典curr，用来统计S中那些在L中的单词的数量，必须和L中单词的数量相等，否则同样break\n\n## 代码\n```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res, dict = [] ,{}\n        n_word = len(words)\n        n_s = len(s)\n        \n        \n        if words:\n            word_length = len(words[0])\n        else:\n            return res\n        # 统计单词出现的次数\n        for i in range(n_word):\n            if words[i] in dict:\n                dict[words[i]] +=1\n            else:\n                dict[words[i]] = 1\n        #关于这个for里面的+1，你可以假设length_s与word_num * length_word一样那么很明显应该进入循环判断\n        for i in range(n_s - n_word*word_length + 1):\n            #curr用来统计小循环内出现相同单词次数，如果大于单词组内该单词出现数直接break\n            curr,j = {},0\n            #小循环，j相当于指向一个单词，每次移动一个单词，截取s内一个单词的长度判断是都在dict中\n            while j < n_word:\n                word = s[i+j*word_length : i+j*word_length + word_length]\n                if not word in dict: break\n                if not word in curr: \n                    curr[word] = 1\n                else:\n                    curr[word] +=1\n                if curr[word] > dict[word]:\n                    break\n                j+=1\n            #出小循环后j（单词数）等于单词数组数那就是刚好匹配，保存i\n            if j == n_word:\n                res.append(i)\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107811673","body":"思路是看官方题解，literally看答案写了一遍，但是还需要更多理解\n'''\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n\n        dict = {0:-1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dict:\n                ans = min(ans,j-dict[target])\n            dict[cur] = j\n\n        if ans ==len(nums):\n            return -1\n\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107930329","body":"```\n快慢指针\n快指针的速度是慢指针的两倍\n当快指针走到最后的时候，慢指针就会停在middle的地方\nTime Complexity: O(N)\nSpace Complexity: O(1), the space used by slow and fast.\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        i= head\n        j=head\n        \n        while j != None and j.next !=None:\n            i= i.next\n            j= j.next.next\n            \n        return i\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109218702","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # left and right pointers 都设成1，因为第一个value肯定会是第一个\n        l =1\n        \n        \n        for r in range(1,len(nums)):\n            if nums[r] != nums[r-1]:\n                nums[l] = nums[r]\n                \n                l+=1\n        \n        return l\n       \n```\n两个指针\n都从 1 开始\n因为第一个值 肯定是unique 会被place\n\nleft 指针计算多少个unique值\nright 遍历后面的值，因为是sorted array 所以比大小就可以知道是不是unique\n\t\t\t\t\t要是前后不相等，说明数值不一样\n\t\t\t\t\tnum[l] = num[r]\n\t\t\t\t\tleft +1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110814336","body":"## 思路：二分查找\n\n## 代码\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \n        left = 0\n        right = len(nums)-1\n        \n        while left <= right:\n            mid = (left+right)//2\n            if nums[mid] ==target:\n                return mid\n            if target < nums[mid]:\n                right = mid-1\n            else :\n                left =mid+1\n                \n        return left\n\t\t\t\n```\n\n## 复杂度分析\n\n时间：O（logn）\n空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111878569","body":"## 思路一：暴力求解\n\n```\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if k==1:\n            return nums\n        \n        n = len(nums)\n        \n        ans = [None]*(n-k+1)\n        \n        i = 0\n        j = k\n        \n        while j<=n:\n            temp = nums[i:j]\n            ans[i] = max(temp)\n            i+=1\n            j+=1\n            \n        return ans\n```\n\n## 超时 \n\n## 单调递增队列\n\n## 代码\n```\nclass maxQueue:\n    \n    def __init__(self):\n        self.queue = collections.deque()\n    def push(self, val):\n        # 每次push进value的时候，把比他更小的都pop出去\n        while self.queue and val>self.queue[-1]:\n            self.queue.pop()\n        self.queue.append(val)\n    def pop(self):\n        # 因为是monotonic max queue，所以popleft就是最大值\n        self.queue.popleft()\n    def max(self):\n        return self.queue[0]\n        \n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if k==1:\n            return nums\n        \n        n = len(nums)\n        ans= []\n        q = maxQueue()\n        \n        for i in range(n):\n            q.push(nums[i])\n            # 到达sliding window size 的 maximum\n            if i-k+1>=0:\n                ans.append(q.max())\n                # 如果queue的最大值等于接下来push进来的值，pop掉他，append新值可以和后面的比较\n                if nums[i-k+1] == q.max(): q.pop()\n                    \n        return ans\n```\n## 复杂度\n时间：On\n空间：On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112921616","body":"## 思路：Graph\n学习graph的第一天，没写过任何题目所以看题解写的\n学习了indegree 和 outdegree\n## 代码\n```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = [0] * (n+1)\n        out_degree = [0] * (n+1)\n        \n        for a, b in trust:\n            in_degree[b] +=1\n            out_degree[a] +=1\n            \n        for i in range(1,n+1):\n            if in_degree[i] == n-1 and out_degree[i] ==0:\n                return i\n            \n        return -1\n```\n\n## 复杂度分析：\n时间：On\n空间：On","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuyingliu2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085533007","body":"三种方法\n```\n暴力\n时间复杂度O(n)\n空间复杂度O(n)\n先把k转为字符串 然后转成int 和k相加再慢慢转回来\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,num))) + k)))\n```\n\n```\n模拟\n时间复杂度O(n)\n空间复杂度O(n)\n模板真好用hh\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lstk = list(int(i) for i in str(k))\n        i = len(num) -1\n        j = len(lstk) -1\n        carry = 0\n        \n        res = []\n        while i >=0 or j >=0:\n            x = num[i] if i >=0 else 0\n            y = lstk[j] if j >=0 else 0\n            \n            sum = x + y + carry  \n            \n            keep = sum % 10\n            carry = sum // 10\n    \n            res.append(keep)\n               \n            i = i -1\n            j = j -1\n            \n        if carry != 0:\n            res.append(carry)\n        return res[::-1]\n```\n\n```\n把k加进去 这个和模拟差不多 \n看了别人的答案 感觉也不错\n```\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086542553","body":"两种方法\r\n```\r\n暴力\r\n把s中和c相等的index取出来 之后一个个和s中的index相减 max(abs(差))\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lst = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lst.append(i)\r\n        res= []\r\n        for i in range(len(s)):\r\n            dis = [] \r\n            for j in lst:\r\n                dis.append(abs(i-j))\r\n            res.append(min(dis)) \r\n        return res \r\n```\r\n\r\n```\r\n一个指针\r\n当满足两个条件p+=1\r\n1. p还没有走完\r\n2. i 到  p 的绝对距离 > 到p + 1的绝对距离\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        p = 0\r\n        lst = list(i for i in range(len(s)) if s[i] == c)\r\n\r\n        for i, j in enumerate(s):\r\n            if p < len(lst) -1 and abs(lst[p] -i) > abs((lst[p+1]) -i):\r\n                p+=1\r\n            res.append(abs(lst[p]-i))\r\n            \r\n        return res\r\n        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086744260","body":"```\r\n时间复杂度：O(1)\r\n空间复杂度：O(maxSize)\r\n```\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.stack.append(x)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            self.length -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.length)):\r\n            self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087213701","body":"```\r\n#时间复杂度 O(N)\r\n#空间复杂度 O(N)\r\n```\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        #注意可能有嵌套的中括号\r\n        stack = []\r\n        res = \"\"\r\n        mul = 0\r\n        \r\n        for ch in s:\r\n            if ch == \"[\":\r\n                stack.append([mul, res])\r\n                mul, res = 0, \"\"\r\n            elif ch == \"]\":\r\n                cur_mul, last_res = stack.pop()\r\n                res = last_res + cur_mul *res\r\n            elif \"0\" <= ch <= \"9\":\r\n                mul = mul * 10 + int(ch)\r\n            else:\r\n                res += ch\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088171826","body":"```\r\n时间复杂度:  O(N)\r\n空间复杂度:  O(N)\r\n```\r\n```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.outstack) == 0:\r\n            while len(self.instack) !=0:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n            \r\n    def peek(self) -> int:\r\n        if len(self.outstack) == 0:\r\n            while len(self.instack) !=0:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n        \r\n    def empty(self) -> bool:\r\n        if len(self.instack) == 0 and len(self.outstack) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089834866","body":"两种方法\r\n```\r\n前缀和\r\narr 和 sorted(arr) 如果如果两个数组的前缀和相等，说明到此可以划分为一段\r\n时间复杂度：O(NlogN) \r\n空间复杂度：O(N)\r\n\r\n```\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        presum1 = 0\r\n        presum2 = 0\r\n        res = 0\r\n        for a,b in zip(arr,sorted(arr)):\r\n            presum1 += a\r\n            presum2 += b\r\n            if presum1 == presum2:\r\n                res+=1\r\n        return res\r\n```\r\n```\r\n指针+滑动窗口 思路和前缀和一样\r\n\r\n```\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        left = 0\r\n        res = 0\r\n        nums = sorted(arr)\r\n        for right in range(1, len(arr) + 1):\r\n            if sum(nums[left:right]) == sum(arr[left:right]):\r\n                res +=1\r\n                left = right\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091124147","body":"``` \r\n#先形成环，再移动，再断开\r\n#时间复杂度：O(n)\r\n#空间复杂度：O(1)\r\n```\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        tail = head\r\n        length = 1\r\n        while tail.next:\r\n            length += 1\r\n            tail = tail.next\r\n        tail.next = head\r\n\r\n        k = k % length\r\n        for _ in range(length - k):\r\n            tail = tail.next\r\n\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092341986","body":"```\r\n看了答案明白了\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(1)\r\n```\r\n```\r\n\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        dummy = ListNode()\r\n        dummy.next = head\r\n        cur = head\r\n        pre = dummy\r\n \r\n        \r\n        while cur and cur.next:\r\n            nex = cur.next\r\n\r\n            cur.next = nex.next\r\n            nex.next = cur\r\n            pre.next = nex\r\n\r\n            pre = cur\r\n            cur = cur.next\r\n        return dummy.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093641484","body":"```\r\n先找出链表的中点 然后再建树 （中点就是树的根）\r\n时间复杂度: O(NlogN) \r\n空间复杂度: O(logN) \r\n```\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n\r\n        def findmid(start, end):\r\n            slow = start\r\n            fast = start\r\n            \r\n            while fast != end and fast.next != end:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        \r\n        \r\n        def buildtree(start, end):\r\n            if start == end:\r\n                return\r\n            \r\n            mid = findmid(start, end)\r\n            \r\n            root = TreeNode(mid.val) #root = TreeNode(findmid(start, end).val)\r\n            root.left = buildtree(start, mid)\r\n            root.right = buildtree(mid.next, end)\r\n            \r\n            return root\r\n        return buildtree(head, None)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094165704","body":"```\r\n#solution 1\r\n#要用到哈希表 先将其中一个链表存到哈希表中，此时再遍历另外一个链表查找重复结点\r\n#尝试用列表但是超时了 因为列表判断元素是否存在比集合慢很多\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N)\r\n```\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        s = set()\r\n        p,q = headA, headB\r\n        while p:\r\n            s.add(p)\r\n            p= p.next\r\n        while q:\r\n            if q in s:\r\n                return q\r\n            q= q.next\r\n        return None\r\n```\r\n```\r\n\r\n#solution2  栈\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N)\r\n#注意 这里比的是内存地址 不仅仅是node里的数字 is/==\r\n#最后== 是从后往前找直到找到最后一个相同的点\r\n```\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        s1, s2 = [], []\r\n        p, q = headA, headB\r\n        while p:\r\n            s1.append(p)\r\n            p = p.next\r\n        while q:\r\n            s2.append(q)\r\n            q = q.next\r\n        ans = None\r\n        i, j = len(s1) - 1, len(s2) - 1\r\n        while i >= 0 and j >= 0 and s1[i] == s2[j]:\r\n            ans = s1[i]\r\n            i, j = i - 1, j - 1\r\n        return ans\r\n```\r\n```    \r\n#solution 3 计算长度\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(1)\r\n```\r\n```\r\n        s1, s2 = 0, 0\r\n        p, q = headA, headB\r\n        # 计算长度\r\n        while p:\r\n            p = p.next\r\n            s1 += 1\r\n        while q:\r\n            q = q.next\r\n            s2 += 1\r\n        # 长链表先走，但不确定AB谁长，所以有两个循环，但实际上有至少一个循环不会执行\r\n        p, q = headA, headB\r\n        for i in range(s1 - s2):\r\n            p = p.next\r\n        for i in range(s2 - s1):\r\n            q = q.next\r\n        while p and q and p != q:\r\n            p = p.next\r\n            q = q.next\r\n        return p\r\n```\r\n```\r\nsolution4 走过你来时的路 \r\n```\r\n```\r\n         A, B = headA, headB\r\n         while A != B:\r\n             A = A.next if A else headB\r\n            B = B.next if B else headA\r\n         return A\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094577876","body":"```\r\nSolution1: 用set\r\n时间复杂度: O(N)\r\n空间复杂度: O(N) 和题目要求不符合了 题目想要用O(1) 就是下面的方法\r\n```\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        seen = set()\r\n        while head:\r\n            if head in seen:\r\n                return head\r\n            seen.add(head)\r\n            head= head.next\r\n        return head\r\n\r\n```\r\n```\r\nSolution 2:\r\n先用两个指针 快慢指针找相遇的点\r\n再定义第二个慢指针从头开始走和前一个慢指针一起走 相遇的点就是入环的点\r\n时间复杂度: O(N)\r\n空间复杂度: O(1)\r\n```\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = head\r\n        fast = head\r\n        slow2 = head\r\n        \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                while slow2 != slow:\r\n                    slow2 = slow2.next\r\n                    slow = slow.next\r\n                return slow\r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096505227","body":"```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self: return -1 \r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        self[key] = value\r\n        self.move_to_end(key)\r\n        if len(self) > self.size:\r\n            self.popitem(last=False)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097428237","body":"```\r\n#solution1 深度优先搜索(DFS)\r\n\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N) / O(height) 树的高度\r\n```\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        ldepth = self.maxDepth(root.left)\r\n        rdepth = self.maxDepth(root.right)\r\n        if ldepth > rdepth: #或者直接一句：return max(rdepth, rdepth) +1\r\n            return ldepth+1\r\n        return rdepth +1 #要加上根节点的1\r\n```\r\n\r\n```\r\n#solution2 ：宽度优先遍历(BFS) + Queue\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N) / O(weight) 树的宽度\r\n```\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        height = 0\r\n        if not root:\r\n            return height\r\n        \r\n        queue = [root]\r\n        while queue:\r\n            size = len(queue)\r\n            for i in range(size):\r\n                cur_node = queue.pop(0)\r\n                if cur_node.left:\r\n                    queue.append(cur_node.left)\r\n                if cur_node.right:\r\n                    queue.append(cur_node.right)\r\n            height += 1\r\n        return height\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098698352","body":"```\r\n#solution1 DFS 用递归\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N)\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        if p.val != q.val:\r\n            return False\r\n        leftnode = self.isSameTree(p.left, q.left)\r\n        rightnode = self.isSameTree(p.right, q.right)\r\n        return leftnode and rightnode\r\n```\r\n```\r\n#solution 1.2 DFS 用迭代\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N)\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        \r\n        queue = [p,q]      \r\n        while queue:   \r\n            pnode = queue.pop() \r\n            qnode = queue.pop()\r\n            if not pnode and not qnode:\r\n                continue\r\n            if not pnode or not qnode:\r\n                return False\r\n            if pnode.val != qnode.val:\r\n                return False\r\n        \r\n            queue.append(pnode.left)\r\n            queue.append(qnode.left)\r\n            queue.append(pnode.right)\r\n            queue.append(qnode.right)      \r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100021614","body":"```\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n            if not node.left and not node.right:\r\n                self.que.append(node.val)\r\n                self.res.append(int(''.join([str(i) for i in self.que])))\r\n                self.que.pop()\r\n                return\r\n            self.que.append(node.val)\r\n            dfs(node.left)\r\n            dfs(node.right)\r\n            self.que.pop()\r\n\r\n        self.res = []\r\n        self.que = []\r\n        dfs(root)\r\n        return sum(self.res)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100618378","body":"```\r\n#BFS遍\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        #时间复杂度: O(N)\r\n        #空间复杂度: O(N)\r\n        queue = [root]\r\n        res = root.val\r\n        \r\n        while queue:\r\n            res = queue[0].val\r\n            n =len(queue)\r\n            for i in range(n):\r\n                node = queue[0]\r\n                del queue[0]\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n        return res\r\n ```\r\n```   \r\n#优化一下\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        queue = [root]\r\n        while queue:\r\n            node = queue.pop(0) \r\n            if node.right:#先右后左\r\n                queue.append(node.right)\r\n            if node.left:\r\n                queue.append(node.left)\r\n        return node.val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100778446","body":"```\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"[]\"\r\n\r\n\r\n        queue = collections.deque([root])\r\n\r\n        res = []\r\n        \r\n        while queue:\r\n            node = queue.popleft()\r\n            if node:\r\n                res.append(str(node.val))\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else: \r\n                res.append(\"null\")\r\n        res = '[' + ','.join(res) + ']'\r\n        #print(res)\r\n        return res\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data=='[]':\r\n            return None\r\n        vals, i = data[1:-1].split(','), 1\r\n        root = TreeNode(int(vals[0]))\r\n        queue = collections.deque()\r\n        queue.append(root)\r\n        while queue:\r\n            node = queue.popleft()\r\n            if vals[i] != \"null\":\r\n                node.left = TreeNode(int(vals[i]))\r\n                queue.append(node.left)\r\n            i += 1\r\n            if vals[i] != \"null\":\r\n                node.right = TreeNode(int(vals[i]))\r\n                queue.append(node.right)\r\n            i += 1\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101142263","body":"```\r\n# 时间复杂度：O(NlogN)\r\n# 空间复杂度：O(N)\r\n```\r\n```\r\nclass Solution:\r\n    #def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:     \r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        #先用dfs进行遍历 得出每个node的坐标，col，row，val（三元组）\r\n        arr = []\r\n        def dfs(root, row, col):\r\n            if not root:\r\n                return \r\n            arr.append([col, row, root.val])\r\n            dfs(root.left, row + 1, col - 1)\r\n            dfs(root.right, row + 1, col + 1)\r\n        dfs(root, 0, 0)\r\n        \r\n        #col 为第一关键字升序， row为第二关键字升序，value为第三关键字升序\r\n        arr = sorted(arr, key=lambda x: (x[0], x[1], x[2]), reverse = False)\r\n        \r\n        hash_ = defaultdict(list)\r\n        #相同的列存到同一字典里，key为col，value为val\r\n        for i in arr:\r\n            hash_[i[0]].append(i[2])\r\n            \r\n        res = []\r\n        for i in hash_.values():\r\n            res.append(i)\r\n            \r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101909244","body":"```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n         #Solution 1: 暴力求解 两个for循环\r\n         for i in range(len(nums)):\r\n             for j in range(i+1, len(nums)):\r\n                 if nums[i] + nums[j] == target:\r\n                     return i, j\r\n#时间复杂度： O(N^2)\r\n#空间复杂度： O(1)\r\n\r\n         #Solution 2: Hash\r\n         hashset={}\r\n         for i in range(len(nums)):\r\n             if hashset.get(target-nums[i]) is not None:\r\n                 return [hashset.get(target-nums[i]), i]\r\n             hashset[nums[i]]=i\r\n#时间复杂度： O(N)\r\n#空间复杂度： O(N)\r\n  \r\n        #Solution 3: 排序+双指针\r\n        temp=nums.copy()\r\n        temp.sort()\r\n        i=0\r\n        j=len(nums)-1\r\n        while i<j:\r\n            if (temp[i] + temp[j])>target:\r\n                j = j-1\r\n            elif (temp[i] + temp[j])<target:\r\n                i = i+1\r\n            else:\r\n                break\r\n        p=nums.index(temp[i])\r\n        nums.pop(p)\r\n        k=nums.index(temp[j])\r\n        if k>=p:\r\n            k=k+1\r\n        return p,k\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103508732","body":"```\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        if len(nums) == 0:\r\n            return None\r\n        if len(nums) == 1:\r\n            return nums\r\n\r\n        res = {}\r\n        for num in nums:\r\n            if num not in res:\r\n                res[num] = 0\r\n            else:\r\n                res[num] += 1\r\n        res = sorted(res.items(), key=lambda item:item[1], reverse=True)\r\n        \r\n        coun = 0\r\n        ans = []\r\n        while coun < k:\r\n            ans.append(res[coun][0])\r\n            coun += 1\r\n\r\n        return ans\r\n\r\nsolution2  暴力 \r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        res=[]\r\n        couter=collections.Counter(nums)\r\n        for i in range(k):\r\n            a=max(couter.keys(),key=couter.get)\r\n            res+=[a]\r\n            del couter[a]\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104653181","body":"```\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        #把每一个点作为一个中点，分别计算别的点和这个点的距离，如果距离都相等的话 就是一个回旋镖\r\n        #写一个dist的helper function 然后直接算\r\n        n = len(points)\r\n        if n < 3:\r\n            return 0\r\n        \r\n        def dist(p1, p2):\r\n            return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])\r\n        #计算每两点之间的距离\r\n        \r\n        ans = 0\r\n        for i in range(n):\r\n            cnt = collections.Counter()\r\n            for j in range(n):\r\n                dis = dist(points[i] , points[j])\r\n                cnt[dis] += 1\r\n                \r\n            for x in cnt.values():\r\n                ans +=math.perm(x, 2)#math库中的排列函数\r\n                \r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106149953","body":"```\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        dic, res, left = {}, 0, -1  \r\n        for right in range(len(s)):\r\n            if s[right] in dic:    \r\n                left = max(left, dic[s[right]]) \r\n            dic[s[right]] = right   \r\n            res = max(res, right - left)   \r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107425258","body":"```\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        if len(words) == 0 or len(s) == 0:\r\n            return []\r\n\r\n        len_word = len(words[0])\r\n        res = []\r\n        for i in range(len(s) - len_word * len(words) + 1):\r\n            copy_words = words.copy()\r\n            k = i\r\n            while len(copy_words) != 0:\r\n                if s[k : k+len_word] in copy_words:\r\n                    copy_words.remove(s[k : k+len_word])\r\n                    k += len_word\r\n                else:\r\n                    break\r\n            if len(copy_words) == 0:\r\n                res.append(i)\r\n        \r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107796467","body":"```\r\n#solution 1 \r\n#时间复杂度: O(N)\r\n#空间复杂度: O(1)\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        dummy = ListNode()\r\n        dummy.next = head\r\n        cur = head\r\n        pre = dummy\r\n        while cur and cur.next:\r\n            nex = cur.next\r\n            # 滑窗内三次opeartions\r\n            cur.next = nex.next\r\n            nex.next = cur\r\n            pre.next = nex\r\n            # 设置新滑窗\r\n            pre = cur\r\n            cur = cur.next\r\n        return dummy.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107924994","body":"```\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        \r\n      \r\n        temp = []\r\n        cur = head\r\n        while head.next:\r\n            temp.append(head.val)\r\n            head = head.next\r\n        temp.append(head.val)\r\n        for i in range(len(temp)//2):\r\n            cur = cur.next\r\n        return cur\r\n    \r\n\r\n        # solution 2 双指针\r\n        # 首先初始化left和right都位于列表的第一项, right走两步，left走一步，这样的话left始终位于起始元素到right指向元素的中间位置。\r\n        left = right = head\r\n\r\n        while right.next and right.next.next:\r\n            right = right.next.next\r\n            left = left.next\r\n        if not right.next:\r\n            return left\r\n        else:\r\n            return left.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109330997","body":"```\r\n#solution 1\r\n#set本来就可以去重 然后要sorted一下排列\r\n#时间复杂度:O(N)\r\n#空间复杂度:O(N)\r\n# class Solution:\r\n#     def removeDuplicates(self, nums: List[int]) -> int:\r\n#         nums[:] = sorted(set(nums))\r\n#         return len(nums)\r\n```\r\n```   \r\n#solution 2    \r\n# class Solution:\r\n#     def removeDuplicates(self, nums: List[int]) -> int:   \r\n#         for i in nums[:]:\r\n#             if nums.count(i) > 1:\r\n#                 nums.remove(i)\r\n#         return len(nums)\r\n```\r\n```    \r\n#solution 3 双指针\r\n\r\n#时间复杂度:O(N)\r\n#空间复杂度:O(1)\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int: \r\n        j, i = 1, 1\r\n        while i < len(nums):\r\n            if nums[i] !=nums [j-1]:\r\n                j +=1\r\n                nums[j-1] = nums[i]\r\n            else:\r\n                i = i+1\r\n        return j\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110439275","body":"```\r\n#solution 0\r\n#先插入 仔sorted 再找出target的index\r\n#时间复杂度: O(1)\r\n#空间复杂度: O(1)\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        nums.append(target)\r\n        nums.sort()\r\n        return nums.index(target)\r\n```\r\n```\r\n#solution 1 思路 比较 如果刚好大于i 插入到i+1的位置 返回i+1 \r\n#时间复杂度: O(N)\r\n#空间复杂度: O(1)\r\n#也分析对了hh\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        if nums[0] > target:\r\n            return 0\r\n        elif nums[-1] < target:\r\n            return len(nums)\r\n        else:\r\n            for i in range(len(nums)):\r\n                if nums[i] >= target:\r\n                        return i\r\n```\r\n```\r\n#solution 3 二分法 一半一半的算 怎么有点递归的感觉 但又不是递归\r\n#时间复杂度: O(logN)\r\n#空间复杂度: O(1) \r\n#分析对了哈哈哈\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        if nums[0] > target:\r\n            return 0\r\n        if nums[-1] < target:\r\n            return len(nums)\r\n        \r\n        low = 0\r\n        high = len(nums) -1\r\n        while low < high:\r\n            mid = (high -low) // 2 + low #画图就明白了\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] < target:\r\n                low = mid +1 #左闭\r\n            else: \r\n                high = mid #右开\r\n        return low\r\n                \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111776696","body":"```\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n\r\n        if len(nums) ==1:            \r\n            return nums         \r\n        res = []\r\n        queue = collections.deque()\r\n        #https://zhuanlan.zhihu.com/p/46462831\r\n        #deque：类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)\r\n        for i, num in enumerate(nums):\r\n            if queue and queue[0] == i - k: #判断一个元素是否从右界变成了左届，并将要pop出去\r\n                queue.popleft()\r\n            while queue and nums[queue[-1]] < num:\r\n                queue.pop()\r\n            queue.append(i)\r\n            if i >= k - 1:\r\n                res.append(nums[queue[0]])\r\n        return res\r\n\r\n        \r\n#         #solution 2 heap\r\n# \t\t# nums = [1, 3, -1, -3, 5, 3, 6, 7]\r\n# \t\t# how to get max value among the window\r\n# \t\t# use maximum heap (-value, index) \r\n\r\n# \t\t# Time complexity : O(NlogN)\r\n# \t\t# Space complexity: O(N)\r\n\r\n\t\t# res, heap = [], []\r\n\t\t# for i in range(len(nums)):\r\n\t\t# \theapq.heappush(heap, ( -nums[i], i))\r\n\t\t# #https://blog.csdn.net/brucewong0516/article/details/79042839\r\n\t\t# \tif i + 1 >= k:\r\n\t\t# \t\twhile heap and heap[0][1] <  i + 1 - k:\r\n\t\t# \t\t\theapq.heappop(heap)\r\n\t\t# \t\tres.append(-heap[0][0])\r\n\t\t# return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113042295","body":"```\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        count = [0] * (n + 1)\r\n        for i, j in trust:\r\n            count[i] -= 1\r\n            count[j] += 1\r\n        for i in range(1, n + 1):\r\n            if count[i] == n - 1:\r\n                return i\r\n        return -1\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113938606","body":"```\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        self.graph = [[] for _ in range(n)]\r\n        for i in range(len(dislikes)):\r\n            self.graph[dislikes[i][0]-1].append(dislikes[i][1]-1)\r\n            self.graph[dislikes[i][1]-1].append(dislikes[i][0]-1)\r\n        \r\n        self.visited = [False for _ in range(n)]\r\n        self.color = [False for _ in range(n)]\r\n        self.res = True\r\n        for i in range(n):\r\n            if self.visited[i] is False:\r\n                self.dfs(i)\r\n        return self.res\r\n\r\n    def dfs(self, node):\r\n        if self.res is False:\r\n            return \r\n        self.visited[node] = True\r\n        for i in self.graph[node]:\r\n            if self.visited[i]:\r\n                if self.color[i] == self.color[node]:\r\n                    self.res = False\r\n                    return \r\n            else:\r\n                self.color[i] = not self.color[node]\r\n                self.dfs(i)\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"futurefields":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085538554","body":"Idea:high precision addition\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n    reverse(num.begin(), num.end());\n        for(auto&t : num){\n            k+= t;\n            t= k % 10;\n            k/= 10;\n        }\n        while(k) num.push_back(k % 10), k/= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\nSpace O(n) Time O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086576973","body":"Idea: scan from left to right, and reverse\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> answer(s.size());\r\n        int prev = -100000;\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                prev = i;\r\n            }\r\n            answer[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        for (int i = s.size() - 1; i >= 0; i--) {\r\n            if (s[i] == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = min(answer[i], prev - i);\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n\r\nspace O(N), time O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087047463","body":"Idea: Stack\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int len = s.size();\r\n        int num = 0;\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        string cur = \"\";\r\n        string result = \"\";\r\n        for(int i=0; i<len; ++i)\r\n        {\r\n            if(s[i]>='0' && s[i]<='9')\r\n            {\r\n                num = 10*num + s[i] - '0';\r\n            }\r\n            else if(s[i] == '[')\r\n            {\r\n                numstack.push(num);\r\n                strstack.push(cur);\r\n                num = 0;\r\n                cur.clear();\r\n            }\r\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\r\n                cur += s[i];\r\n            else if(s[i] == ']')\r\n            {\r\n                int k = numstack.top();\r\n                numstack.pop();\r\n                for(int j=0; j<k; ++j)\r\n                    strstack.top() += cur;\r\n                cur = strstack.top();\r\n                strstack.pop();\r\n            }\r\n        }\r\n        result = result + cur;\r\n        return result;     \r\n    }\r\n};\r\nSpace: O(n), Time: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088206006","body":"Idea: Stack push and pop\r\n\r\n\r\nclass MyQueue {\r\n    private:\r\n    stack<int> a;\r\n    stack<int> b;\r\npublic:\r\n    MyQueue() {\r\n    }\r\n   void push(int x) {\r\n        a.push(x);\r\n    }\r\n    int pop() {\r\n        int num = 0;\r\n        if (b.empty())\r\n        {\r\n            while(!a.empty())\r\n            {\r\n                b.push(a.top());\r\n                a.pop();\r\n            }\r\n        }\r\n        if (!b.empty())\r\n        {\r\n            num = b.top();\r\n            b.pop();\r\n        }\r\n        return num;\r\n    }    \r\n int peek() {\r\n        int num = 0;\r\n        if (b.empty())\r\n        {\r\n            while(!a.empty())\r\n            {\r\n                b.push(a.top());\r\n                a.pop();\r\n            }\r\n        }\r\n        if (!b.empty())\r\n            num = b.top();\r\n         return num;\r\n    }  \r\nbool empty() {\r\n        if (a.empty() && b.empty())\r\n            return true;\r\n        return false;\r\n    }\r\n};\r\n\r\nspace: O(1), time: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094260636","body":"Idea: May revise the data\n\n'''\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *ans=NULL;\n        ListNode *p;\n        p=headA;\n        while(p!=NULL){\n            p->val=-p->val;\n            p=p->next;\n            }\n            p=headB;\n        while(p!=NULL){\n            // cout<<p->val<<\" \";\n            if (p->val<0){\n                ans=p;\n                break;\n            }\n            p=p->next;\n        }\n        p=headA;\n        while(p!=NULL){\n            p->val=-p->val;\n            p=p->next;\n        }\n        return ans;\n\n    }\n};\n\"'\n\nSpace: O(m+n), Time: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094462898","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      if(head==nullptr) return nullptr;\n        unordered_set<ListNode*> visited;\n        ListNode* n1=head;\n        while(n1!=nullptr)\n        {\n            if(visited.count(n1)) return n1;\n            visited.insert(n1);\n            n1=n1->next;\n        }\n        return nullptr;   \n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100501922","body":"Idea: DFS\r\n\r\nclass Solution {\r\npublic:\r\n    TreeNode *targetNode;\r\n    int maxHeight = 0;\r\n    void dfs( TreeNode *node, int curHeight){\r\n        if( !node->left && !node->right ){\r\n            if( curHeight > maxHeight) {\r\n                 targetNode = node;\r\n                 maxHeight = curHeight;\r\n            }\r\n            return;\r\n        }\r\n        if( node->left )    dfs( node->left, curHeight+1 );\r\n        if( node->right )   dfs( node->right, curHeight+1 );\r\n    }\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        dfs( root, 1 );\r\n        return targetNode->val;\r\n    }\r\n};\r\n\r\nSpace: O(n), Time:O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107472608","body":"class Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\nif (s.empty() || words.empty()) return {};\r\n        int n = words.size(), m = words[0].size(), j = 0;\r\n        if (s.size() < m * n) return {};\r\n        vector<int> res;\r\n        unordered_map<string, int> mp, tmp;\r\n        for (auto str : words) {\r\n            ++mp[str];\r\n        }\r\n        string str = \"\";\r\n        for (int i = 0; i + m * n <= s.size(); ++i) {\r\n            for (j = i; j < i + m * n; j += m) {\r\n                str = s.substr(j, m);\r\n                if (mp.find(str) == mp.end()) break;\r\n                ++tmp[str];\r\n            }\r\n            if (j == i + m * n && tmp == mp) res.push_back(i);\r\n            tmp.clear();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nSpace:O(n), Time:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwang4768":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085550862","body":"***Idea***  \nTo convert the int k to string, and then can leverage math functions to add. Finally converting the result back to list. However this is very brute force. \n\n***Code***\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        numInt = int(''.join((str(i) for i in num)))\n       \n        temp = numInt + k\n        result = [int(j) for j in str(temp)]\n        \n        return result\n```\n\n***Complexity***  \nTime: O(n)  \nMemory usage: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665384","body":"***Idea***\n1) Loop through the string s and note down and note down the index of occurance of target char c \n2) Loop through s and array of all c occurance index again, create a temp int that stores the distance between current digit and each c occurance. If there is a shorter distance, update temp ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1089578548","body":"***Idea***  \nUse list to implement the stack but not the best solution. \n\n***Code***  \n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.list = []\n\n    def push(self, x: int) -> None:\n        if len(self.list)<self.maxSize:\n            self.list.append(x)\n        return None\n    \n    def pop(self) -> int:\n        if self.list == []:\n            return -1\n        else:\n            popped = self.list[-1]\n            self.list = self.list[:-1]\n            return popped\n\n    def increment(self, k: int, val: int) -> None:\n        \n        minLength = min(k,len(self.list))\n        for i in range(minLength):\n            self.list[i]=self.list[i]+val\n        \n        return None\n\n \n\n        # Your CustomStack object will be instantiated and called as such:\n        # obj = CustomStack(maxSize)\n        # obj.push(x)\n        # param_2 = obj.pop()\n        # obj.increment(k,val)\n```\n\n***Complexity***  \nTime: O(n)  \nMemory: O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088816676","body":"***Idea***  \nTo use the two helper functions to implement pop() and push()\n\n***Code***  \n\n***Complexity***  \nTime complexity:   \nMemory complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090025745","body":"***Idea***  \nTo leverage hash table and stack to implement \n\n***Code***  \n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count=0\n        minarr=[]\n        prev=999999999\n        for item in arr[::-1]:\n            minarr.append(min(prev,item))\n            prev=min(prev,item)\n        minarr.reverse()\n        temp=0\n        for i in range(0,len(arr)-1):\n            temp=max(temp,arr[i])\n            if temp<=minarr[i+1]:\n                temp=0\n                count+=1\n        return  count+1\n```\n\n***Complexity***  \nTime: O(n)  \nMemory: O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093723639","body":"***Idea***  \nUse vector to facilitate calculations in left and right branches via a mid point  \n\n***Code***  \n```\nclass Solution {\npublic:\n    vector<int>v;\n    TreeNode*balance(vector<int>v){\n        if(v.size()==0){\n            return NULL;\n        }\n        if(v.size()==1){\n            return new TreeNode(v[0]);\n        }\n        int mid = v.size()/2;\n        TreeNode* node = new TreeNode(v[mid]);\n        vector<int>lnode(v.begin(), v.begin()+mid);\n        vector<int>rnode(v.begin()+mid+1, v.end());\n        node->left = balance(lnode);\n        node->right = balance(rnode);\n        return node;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        while(head){\n            v.push_back(head->val);\n            head=head->next;\n        }\n        return balance(v);\n        \n    }\n};\n```\n\n***Complexity***  \nTime: \nMemory: ","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100485671","body":"***Idea***    \r\nDepth-firs search general strategy + recursion\r\n\r\n***Code***    \r\n```\r\nint highest=0,res;\r\nvoid calc(TreeNode* root,int level){\r\n    if(!root)\r\n        return;\r\n    if(highest<level){     //store first value of each level\r\n       res=root->val;\r\n        highest=level;    //update level\r\n    }\r\n    calc(root->left,level+1);    //recursive call for next level\r\n    calc(root->right,level+1);  \r\n}\r\nint findBottomLeftValue(TreeNode* root) {\r\n    calc(root,1);\r\n    return res;\r\n}\r\n```   \r\n***Complexity***   \r\nO(n)    \r\nO(n)","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107857058","body":"***Strategy***   \nLeverage hash table and map\n\n***Code***\n```\nint subarraysDivByK(vector<int>& nums, int k) {        \n    map<int, int> m;\n    int cnt = 0, currSum = 0;\n\n    for (int i : nums)\n    {\n        currSum += i;\n        int temp = currSum % k;\n        if (temp < 0)\n            temp += k;\n        \n        if (temp == 0)\n            cnt++;\n        \n        if (m.find(temp) != m.end())\n            cnt += m[temp];\n        \n        m[temp]++;\n    }\n    return cnt;\n}\n```\n\n***Complexity***   \nTime: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085553826","body":"- ### 思路\n\t- 将数组转换成字符串，然后转换成整数\n\t- 然后做加法\n\t- 然后再将结果转换成数组\n- ### Code\n\t  ```python\t  \t  \n              class Solution:\n\t  \t      def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t  \t          str1 = ''.join([str(x) for x in num])\n\t  \t          number = int(str1)\n\t  \t          newNumber = number + k\n\t  \t          newList = list(map(int,str(newNumber)))\n\t  \t          return newList\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 O(n)\n\t- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086648516","body":"- Name: Leetcode No.821 字符的最短距离\n- ### 题目描述\n  ```\n  对给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n  \n  返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n  \n  两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n  \n  \n  示例 1：\n  输入：s = \"loveleetcode\", c = \"e\"\n  输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n  解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n  距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n  距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n  对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n  距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n  \n  \n  示例 2：\n  输入：s = \"aaab\", c = \"b\"\n  输出：[3,2,1,0]\n  \n  提示：\n  \t1 <= s.length <= 104\n  \ts[i] 和 c 均为小写英文字母\t\n  \t题目数据保证 c 在 s 中至少出现一次\n  ```\n- ### 思路\n\t- 遍历字符串，双指针，同时计算正反两个方向的字符的距离\n\t- 然后将得到的两个数组，对应位置进行比较，选择小的留下来\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**字符的遍历**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def shortestToChar(self, s: str, c: str) -> List[int]:\n\t  \t          prev1, prev2 = 2*len(s), 2*len(s)\n\t  \t          ans1,ans2 = [len(s)]*len(s), [len(s)]*len(s)\n\t  \t          j = len(s)-1\n\t  \t          for i in range(len(s)):\n\t  \t              if s[i] == c:\n\t  \t                  prev1 = i\n\t  \t              ans1[i] = abs(i - prev1)\n\t  \t              if s[j] == c:\n\t  \t                  prev2 = j\n\t  \t              ans2[j] = abs(j - prev2)\n\t  \t              j -= 1\n\t  \t          for i in range(len(s)):\n\t  \t              ans1[i] = min(ans1[i],ans2[i])\n\t  \t          return ans1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `min`\n\t\t- min选两个数中小的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086830285","body":"- ### 题目描述\n- 请你设计一个支持下述操作的栈。\n 实现自定义栈类`CustomStack`  ：\n `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\n  `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 x 添加到栈顶。\n  `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  `void inc(int k, int val)`：栈底的 k 个元素的值都增加 `val` 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 `val` 。\n 请你设计一个支持下述操作的栈。\n    \n  实现自定义栈类 CustomStack ：\n    \n  CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n  void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n  int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n    \n    \n  示例 1：\n  输入：\n  [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n  [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n  输出：\n  [null,null,null,2,null,null,null,null,null,103,202,201,-1]\n  解释：\n  - CustomStack customStack = new CustomStack(3); // 栈是空的 []\n  - customStack.push(1);                          // 栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.push(3);                          // 栈变为 [1, 2, 3]\n  - customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\n  - customStack.increment(5, 100);                // 栈变为 [101, 102, 103]\n  - customStack.increment(2, 100);                // 栈变为 [201, 202, 103]\n  - customStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\n  - customStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\n  - customStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\n  - customStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n    \n    \n    \n  提示：\n  1 <= maxSize <= 1000;\n  1 <= x <= 1000;\n  1 <= k <= 1000;\n  0 <= val <= 100;\n  每种方法 increment，push 以及 pop 分别最多调用 1000 次\n- ### 思路\n\t- 设计初始函数，传入所需的变量数组的`maxSize`\n\t- 然后写入入栈，出栈，对栈中元素进行操作的函数\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈**这种数据结构的相关概念。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class CustomStack:\n\t  \t  \n\t  \t      def __init__(self, maxSize: int):\n\t  \t          self.maxSize = maxSize\n\t  \t          self.customStack = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          if len(self.customStack) < self.maxSize:\n\t  \t              self.customStack.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if self.customStack == []:\n\t  \t              return -1\n\t  \t          else:\n\t  \t              return self.customStack.pop(-1)\n\t  \t  \n\t  \t      def increment(self, k: int, val: int) -> None:\n\t  \t          for i in range(min(len(self.customStack), k)):\n\t  \t              self.customStack[i] += val\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your CustomStack object will be instantiated and called as such:\n\t  \t  # obj = CustomStack(maxSize)\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # obj.increment(k,val)\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: `push`: O(1); `pop`: O(1); `increment`: $O(min(k, maxSize))$\n\t- 空间复杂度 $O(maxSize)$ 我们产生了一个额外的 $maxSize$ 维的空间\n- ### 知识汇总\n\t- #### `类`\n\t\t- 类是抽象的概念，是一类东西的抽象化表述\n\t\t- 类的具体化实例化就是具体对象\n\t\t- 实例化对象可以调用类中所有函数\n\t\t- 在类中还有一个初始化函数，将一些特殊的属性值（变量），传入类","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087717362","body":"- ### 题目描述\n\t- 给定一个经过编码的字符串，返回它解码后的字符串。\n\t  编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n\t  你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n\t  此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n- ### 思路\n\t- 在字符串编码的过程中因为[]中的运算是先算里后外，也就是先进去的后出来。因此，可以利用**栈**这种数据结构。\n\t- 题目中的字符串，可以分成四种类型：数字，左中括号, 右中括号，字母\n\t- 遍历字符串\n\t\t- 如果字母存在临时变量res中\n\t\t- 数字存在Multi变量中\n\t\t- 如果遇到左中括号，将Multi和res入栈\n\t\t- 如果遇到右中括号，将顶端的数据出栈\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈-先入后出**，**子组合-递归**。\n- ### Code\n\t\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def decodeString(self, s: str) -> str:\n\t  \t          stack, res, multi = [], \"\", 0\n\t  \t          for c in s:\n\t  \t              if c == '[':\n\t  \t                  stack.append([multi, res])\n\t  \t                  res, multi = \"\", 0\n\t  \t              elif c == ']':\n\t  \t                  cur_multi, last_res = stack.pop()\n\t  \t                  res = last_res + cur_multi * res\n\t  \t              elif '0' <= c <= '9':\n\t  \t                  multi = multi * 10 + int(c)            \n\t  \t              else:\n\t  \t                  res += c\n\t  \t          return res\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `栈`\n\t\t- 栈是实现深度遍历的基础，栈在实例中有很多应用：\n\t\t\t- 函数调用栈\n\t\t\t- 浏览器前进后退\n\t\t\t- 匹配括号\n\t\t\t- 单调栈用来寻找下一个更大（更小）元素 推荐题目：Every-Sublist-Min-Sum","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088903262","body":"- ### 题目描述\n\t- 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\t  实现 MyQueue 类：\n\t  void push(int x) 将元素 x 推到队列的末尾\n\t  int pop() 从队列的开头移除并返回元素\n\t  int peek() 返回队列开头的元素\n\t  boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n\t  说明：\n\t  你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n\t  你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n- ### 思路\n\t- 这个题必修要用两个栈，来构造一个队列的结构。\n\t- 想法就是将第一个栈，出栈进入到第二个栈。这样的话第一个栈的栈顶就变成了第二个栈的栈底，此时，我们让第二个栈的数据出栈，就能达到整体数据先进先出的效果。\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈-先入后出**，**队列-先进先出**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class MyQueue:\n\t  \t  \n\t  \t      def __init__(self):\n\t  \t          self.stack1 = []\n\t  \t          self.stack2 = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          self.stack1.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if len(self.stack2) == 0:\n\t  \t              for i in range(len(self.stack1)):\n\t  \t                  self.stack2.append(self.stack1.pop(-1))\n\t  \t          pop_number = self.stack2.pop(-1)\n\t  \t          return pop_number\n\t  \t  \n\t  \t      def peek(self) -> int:\n\t  \t          if len(self.stack2) == 0:\n\t  \t              for i in range(len(self.stack1)):\n\t  \t                  self.stack2.append(self.stack1.pop(-1))\n\t  \t          peek_number = self.stack2[-1]\n\t  \t          return peek_number\n\t  \t  \n\t  \t      def empty(self) -> bool:\n\t  \t          return  len(self.stack1)==0 and len(self.stack2)==0\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your MyQueue object will be instantiated and called as such:\n\t  \t  # obj = MyQueue()\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # param_3 = obj.peek()\n\t  \t  # param_4 = obj.empty()\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(2n)$ ，n是push的次数\n\t- 空间复杂度 $O(2n)$\n- ### 知识汇总\n\t- #### `栈`\n\t\t- 栈是实现深度遍历的基础\n\t\t\t- 函数调用栈\n\t\t\t- 浏览器前进后退\n\t\t\t- 匹配括号\n\t\t\t- 单调栈用来寻找下一个更大（更小）元素 推荐题目：Every-Sublist-Min-Sum\n\t\t- 对栈的操作\n\t\t\t- push\n\t\t\t- pop\n\t\t\t- top\n\t\t\t- 读取栈内元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090390783","body":"- ### 题目描述\n\t- 这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\t  arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。我们最多能将数组分成多少块？\n\n\t  示例 1:\n\t  输入: arr = [5,4,3,2,1]\n\t  输出: 1\n\t  解释:\n\t  将数组分成2块或者更多块，都无法得到所需的结果。\n\t  例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n\n\t  示例 2:\n\t  输入: arr = [2,1,3,4,4]\n\t  输出: 4\n\t  解释:\n\t  我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n\t  然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\n\n\t  注意:\n\t  arr的长度在[1, 2000]之间。\n\t  arr[i]的大小在[0, 10**8]之间。\n- ### 思路\n\t- #### 思路1\n\t\t- 用字典（ `collections.defaultdict(int)`）记录key数及出现的次数。\n\t\t- arr经过这个函数之后会编程排序了的arr(sorted(arr))\n\t\t- 如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的。\n\t- #### 思路2\n\t\t- 遍历数组\n\t\t- 将数组分成左右两个子数组，左边的数组的最大值，小于等于右边数组的最小值，就是一个子数组。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class Solution(object):\n\t  \t      def maxChunksToSorted(self, arr):\n\t  \t          count_a = collections.defaultdict(int)\n\t  \t          count_b = collections.defaultdict(int)\n\t  \t          ans = 0\n\t  \t  \n\t  \t          for a, b in zip(arr, sorted(arr)):\n\t  \t              count_a[a] += 1\n\t  \t              count_b[b] += 1\n\t  \t              if count_a == count_b: ans += 1\n\t  \t  \n\t  \t          return ans\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n^2)$ ，\n\t- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091911659","body":"- ### 思路\n\t- 链表跟数组差别还是蛮大的\n\t- 将链表的最后一个节点指向头节点\n\t- 找到切断的位置，(l-k%l)处指向`None`\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  #class ListNode:\n\t  \t  #    def __init__(self, val, next):\n\t  \t  #        self.val = val\n\t  \t  #        self.next = next\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def rotateRight(self, head, k):\n\t  \t          if k == 0 or not head  or not head.next: \n\t  \t              return head\n\t  \t          \n\t  \t          l = 1\n\t  \t          tail_node = head\n\t  \t          while tail_node.next:\n\t  \t              l += 1\n\t  \t              tail_node = tail_node.next\n\t  \t  \n\t  \t          \n\t  \t          cut = l - k%l\n\t  \t          if cut == l:\n\t  \t              return head \n\t  \t          cut_node = head\n\t  \t          for _ in range(cut-1):\n\t  \t              cut_node = cut_node.next\n\t  \t          \n\t  \t          re_headNode = cut_node.next\n\t  \t          cut_node.next = None\n\t  \t          tail_node.next = head\n\t  \t  \n\t  \t          return re_headNode\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，\n\t- 空间复杂度 $O(1)$ ，没有使用额外的空间资源","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093032970","body":"- ### 题目描述\n\t- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\t  \n\t  示例 1：\n\n\t  ```\n\t  输入：head = [1,2,3,4]\n\t  输出：[2,1,4,3]\n\t  ```\n\t  示例 2：\n\t  ```\n\t  输入：head = []\n\t  输出：[]\n\t  ```\n\t  \n\t  示例 3：\n\t  ```\n\t  输入：head = [1]\n\t  输出：[1]\n\t  ```\n- ### 思路\n\t- 两两交换的操作是可以分解求每一个子组合的问题，所以可以用递归的思想来做这个题\n\t- 比如前两个节点，作为一组组合两两交换。\n\t- 首先需要将第二个节点指向第一个节点，第二个节点作为新的头节点\n\t- 然后第一个节点指向第二组交换完了之后的头节点（这里用到了递归的思想）\n- ### Code\n\t- ``` python\n\t  # Definition for singly-linked list.\n\t  #class ListNode:\n\t  #    def __init__(self, val, next):\n\t  #        self.val = val\n\t  #        self.next = next\n\t  \n\t  class Solution:\n\t      def swapPairs(self, head: ListNode) -> ListNode:\n\t          if not head or not head.next:\n\t              return head\n\t          subResult = self.swapPairs(head.next.next)\n\t          newHead = head.next \n\t          newHead.next = head\n\t          head.next = subResult\n\t          return newHead\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$，每个栈的节点都需要更新。\n\t- 空间复杂度 $O(n)$，栈空间的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094074315","body":"### 解题思路\r\n用快慢指针和递归\r\n\r\n### 代码\r\n```\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n＃\r\ndef\r\ninit (self, val=0, next=None) :\r\n＃\r\nself. val = val\r\n＃self.next = next\r\n# Definition for a binary tree node .\r\n# class TreeNode :\r\n＃def init_ (self, val=0, left=None, right=None) \r\n＃self.val = val\r\n#self.left = left\r\n＃self. right = right\r\nclass Solution:\r\ndef sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\nif not head:\r\nreturn head\r\nfast, slow, pre = head, head, None\r\nwhile fast and fast.next:\r\nfast = fast.next.next\r\npre = slow\r\nslow = slow.next\r\nif pre:\r\npre.next = None\r\nnode = TreeNode(slow,val)\r\nif slow == fast:\r\nreturn node\r\nnode. left = self.sortedListToBST (head)\r\nnode.right = self.sortedListToBST(slow.next)\r\nreturn node\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094300351","body":"- ### 题目描述\n\t- 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\t- 图示两个链表在节点 c1 开始相交：\n\t- 题目数据 保证 整个链式结构中不存在环。\n\t- 注意，函数返回结果后，链表必须 保持其原始结构 。\n- ### 思路\n\t- 利用双指针思想，一个指针从链表A出发，一个指针从链表B出发，当他们到达尾部的时候将指针指向彼此的头部，继续遍历，如果能相遇就是他们相交的位置，就是他们的头节点，如果不能相遇，那么就是没有相交\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  #class ListNode:\n\t  \t  #    def __init__(self, x):\n\t  \t  #        self.val = x\n\t  \t  #        self.next = None\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\t  \t          if not headA or not headB:\n\t  \t              return None\n\t  \t          pointer1 = headA \n\t  \t          pointer2 = headB\n\t  \t          while(pointer1 != pointer2):\n\t  \t              pointer1 = pointer1.next if pointer1 else headB\n\t  \t              pointer2 = pointer2.next if pointer2 else headA\n\t  \t          return pointer1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(m+n)$ ，m,n 分别是两个链表的节点数。\n\t- 空间复杂度 $O(1)$ ，没有使用额外的空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095238273","body":"- ### 题目描述\n\t- 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\t- 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\t- 不允许修改 链表。\n\t- ![image.png](../assets/image_1649691428068_0.png)\n\t-\n- ### 思路\n\t- 利用双指针思想，快慢指针，快指针如果没遇到None，那么他和慢指针总是会在环上相遇\n\t- 但是相遇的点不一定是环的起始点，所以我们接下来还需要确定环的起始点\n\t\t- ![image.png](../assets/image_1649691529960_0.png)\n\t- 我们将指针走过的路程分为三段\n\t\t- 头到环的起始点，环的起始点到快慢指针相遇点m，相遇点到环的起始点\n\t\t- 快指针的节点数 = 2*慢指针的节点数(k)\n\t\t- 那么头到起始环点：k-m\n\t\t- 相遇点到起始环点：k-m\n\t\t- （都是以顺时针的顺序来计算）\n\t\t- 画图，找到等式关系\n\t\t- ![image.png](../assets/image_1649691939346_0.png)\n\t-\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  # class ListNode:\n\t  \t  #     def __init__(self, x):\n\t  \t  #         self.val = x\n\t  \t  #         self.next = None\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def detectCycle(self, head: ListNode) -> ListNode:\n\t  \t          if not head or not head.next:\n\t  \t              return None\n\t  \t          Pointer1 = head\n\t  \t          Pointer2 = head.next.next\n\t  \t          if Pointer1 == Pointer2:\n\t  \t              return Pointer1\n\t  \t          if not Pointer1 or not Pointer2:\n\t  \t              return None\n\t  \t          while Pointer1 != Pointer2:\n\t  \t              if not Pointer1 or not Pointer2:\n\t  \t                  return None\n\t  \t                  break\n\t  \t              Pointer1 = Pointer1.next\n\t  \t              Pointer2 = Pointer2.next.next\n\t  \t              if Pointer1 == Pointer2:\n\t  \t                  return Pointer1\n\t  \t                  break\n\t  \t          return None\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(2k-m)$ ，k是慢指针的步数, m是其实环点到相遇点的位置。\n\t- 空间复杂度 $O(1)$ ，没有使用额外的空间\n- ### 知识点汇总\n\t- #### 双指针解决链表问题题型汇总\n\t\t- https://labuladong.github.io/algo/2/17/16/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096893607","body":"- ### 思路\n\t- 1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。\n\t- 2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；\n\t- 3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。\n\t- 那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 LinkedHashMap。\n\t- LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样\n\t- ![image.png](../assets/image_1649777563309_0.png)\n\t-\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class ListNode:\n\t  \t      def __init__(self, key=None, value=None):\n\t  \t          self.key = key\n\t  \t          self.value = value\n\t  \t          self.prev = None\n\t  \t          self.next = None\n\t  \t  \n\t  \t  \n\t  \t  class LRUCache:\n\t  \t      def __init__(self, capacity: int):\n\t  \t          self.capacity = capacity\n\t  \t          self.hashmap = {}\n\t  \t          # 新建两个节点 head 和 tail\n\t  \t          self.head = ListNode()\n\t  \t          self.tail = ListNode()\n\t  \t          # 初始化链表为 head <-> tail\n\t  \t          self.head.next = self.tail\n\t  \t          self.tail.prev = self.head\n\t  \t  \n\t  \t      # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n\t  \t      def move_node_to_tail(self, key):\n\t  \t              # 先将哈希表key指向的节点拎出来，为了简洁起名node\n\t  \t              #      hashmap[key]                               hashmap[key]\n\t  \t              #           |                                          |\n\t  \t              #           V              -->                         V\n\t  \t              # prev <-> node <-> next         pre <-> next   ...   node\n\t  \t              node = self.hashmap[key]\n\t  \t              node.prev.next = node.next\n\t  \t              node.next.prev = node.prev\n\t  \t              # 之后将node插入到尾节点前\n\t  \t              #                 hashmap[key]                 hashmap[key]\n\t  \t              #                      |                            |\n\t  \t              #                      V        -->                 V\n\t  \t              # prev <-> tail  ...  node                prev <-> node <-> tail\n\t  \t              node.prev = self.tail.prev\n\t  \t              node.next = self.tail\n\t  \t              self.tail.prev.next = node\n\t  \t              self.tail.prev = node\n\t  \t  \n\t  \t      def get(self, key: int) -> int:\n\t  \t          if key in self.hashmap:\n\t  \t              # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n\t  \t              self.move_node_to_tail(key)\n\t  \t          res = self.hashmap.get(key, -1)\n\t  \t          if res == -1:\n\t  \t              return res\n\t  \t          else:\n\t  \t              return res.value\n\t  \t  \n\t  \t      def put(self, key: int, value: int) -> None:\n\t  \t          if key in self.hashmap:\n\t  \t              # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n\t  \t              # 但是需要更新字典该值对应节点的value\n\t  \t              self.hashmap[key].value = value\n\t  \t              # 之后将该节点移到末尾\n\t  \t              self.move_node_to_tail(key)\n\t  \t          else:\n\t  \t              if len(self.hashmap) == self.capacity:\n\t  \t                  # 去掉哈希表对应项\n\t  \t                  self.hashmap.pop(self.head.next.key)\n\t  \t                  # 去掉最久没有被访问过的节点，即头节点之后的节点\n\t  \t                  self.head.next = self.head.next.next\n\t  \t                  self.head.next.prev = self.head\n\t  \t              # 如果不在的话就插入到尾节点前\n\t  \t              new = ListNode(key, value)\n\t  \t              self.hashmap[key] = new\n\t  \t              new.prev = self.tail.prev\n\t  \t              new.next = self.tail\n\t  \t              self.tail.prev.next = new\n\t  \t              self.tail.prev = new\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your LRUCache object will be instantiated and called as such:\n\t  \t  # obj = LRUCache(capacity)\n\t  \t  # param_1 = obj.get(key)\n\t  \t  # obj.put(key,value)\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(1)$\n\t- 空间复杂度 $O(N)$ ，N为哈希表的容量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098133660","body":"- ### 题目描述\n\t-\n\t  ```\n\t  \t  给定一个二叉树，找出其最大深度。\n\t  \t  \n\t  \t  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\t  \t  \n\t  \t  说明: 叶子节点是指没有子节点的节点。\n\t  \t  \n\t  \t  示例：\n\t  \t  给定二叉树 [3,9,20,null,null,15,7]，\n\t  \t  \n\t  \t      3\n\t  \t     / \\\n\t  \t    9  20\n\t  \t      /  \\\n\t  \t     15   7\n\t  \t  \n\t  \t  返回它的最大深度 3 。\n\t  ```\n- ### 思路\n\t- 二叉树首选看能否用递归解决，以为二叉树就是一种非常标准的递归结构，每一个单元都是总的树结构的一个子树，所以可以使用递归来思考这个问题\n\t- 一个基本单元：root，root.left，root.right\n\t- 那么树的深度就等于 1 + max(根的左节点，根的右节点)\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode:\n\t  \t  #     def __init__(self, val=0, left=None, right=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.left = left\n\t  \t  #         self.right = right\n\t  \t  class Solution:\n\t  \t      def maxDepth(self, root: Optional[TreeNode]) -> int:\n\t  \t          if not root:\n\t  \t              return 0\n\t  \t          return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，\n\t- 空间复杂度 $O(height)$ ，深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099215111","body":"- ### 思路\n\t- 二叉树首选看能否用递归解决，以为二叉树就是一种非常标准的递归结构，每一个单元都是总的树结构的一个子树，所以可以使用递归来思考这个问题\n\t- 一个基本单元：root，root.left，root.right\n\t- 在一个基本单元中，我们需要判断的情况\n\t\t- 1. 如果两个树，根节点都是`None`, 那么是相同的，返回`True`\n\t\t- 2. 如果两个数，只有一个是`None`,那么是不相同的，返回`False`\n\t\t- 3. 如果两个树，都是非空的\n\t\t\t- 看他们的根节点的值是否相同，如果不同，返回`False`\n\t\t\t- 如果根节点相同，那么看他们的左右子节点是否相同，如果相同返回`True`\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode:\n\t  \t  #     def __init__(self, val=0, left=None, right=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.left = left\n\t  \t  #         self.right = right\n\t  \t  class Solution:\n\t  \t      def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n\t  \t          if not q and not p:\n\t  \t              return True\n\t  \t          if not p and q:\n\t  \t              return False\n\t  \t          if not q and p:\n\t  \t              return False\n\t  \t          if p.val != q.val:\n\t  \t              return False\n\t  \t          else:\n\t  \t              return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，\n\t- 空间复杂度 $O(height)$ , 深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100166535","body":"- ### 题目描述\n\t-\n\t  ```\n\t  \t  给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。\n\t  \t  \n\t  \t  例如，从根到叶子节点路径 1->2->3 代表数字 123。\n\t  \t  \n\t  \t  计算从根到叶子节点生成的所有数字之和。\n\t  \t  \n\t  \t  说明: 叶子节点是指没有子节点的节点。\n\t  \t  \n\t  \t  示例 1:\n\t  \t  \n\t  \t  输入: [1,2,3]\n\t  \t      1\n\t  \t     / \\\n\t  \t    2   3\n\t  \t  输出: 25\n\t  \t  解释:\n\t  \t  从根到叶子节点路径 1->2 代表数字 12.\n\t  \t  从根到叶子节点路径 1->3 代表数字 13.\n\t  \t  因此，数字总和 = 12 + 13 = 25.\n\t  \t  示例 2:\n\t  \t  \n\t  \t  输入: [4,9,0,5,1]\n\t  \t      4\n\t  \t     / \\\n\t  \t    9   0\n\t  \t   / \\\n\t  \t  5   1\n\t  \t  输出: 1026\n\t  \t  解释:\n\t  \t  从根到叶子节点路径 4->9->5 代表数字 495.\n\t  \t  从根到叶子节点路径 4->9->1 代表数字 491.\n\t  \t  从根到叶子节点路径 4->0 代表数字 40.\n\t  \t  因此，数字总和 = 495 + 491 + 40 = 1026.\n\t  ```\n- ### 思路\n\t- 见到二叉树，首选使用递归，然后这个题是需要遍历所有结点的，所以我们可以考虑深度优先遍历DFS或者广度优先遍历BFS\n\t- DFS：考虑二叉树的基本单元，root 和 root.left 和 root.right计算数的相同的规律\n\t\t- 之前的总数*10 + 当前节点的数\n\t- BFS：需要两个队列（先进先出），一个存节点，一个存节点对应的数\n\t\t- 每次取出队列里的一个节点，及对应的数\n\t\t- 如果这个节点没有子节点了，那么就把这个数加上，如果还有子节点\n\t\t- 如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列。\n- ### Code - DFS\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode:\n\t  \t  #     def __init__(self, val=0, left=None, right=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.left = left\n\t  \t  #         self.right = right\n\t  \t  class Solution:\n\t  \t      def sumNumbers(self, root: TreeNode) -> int:\n\t  \t          total = 0\n\t  \t          def totalNum(root: TreeNode, total):\n\t  \t              if not root:\n\t  \t                  return 0\n\t  \t              total = total*10 + root.val\n\t  \t              if not root.left and not root.right:\n\t  \t                  return total\n\t  \t              else:\n\t  \t                  return totalNum(root.left,total) + totalNum(root.right,total)\n\t  \t          return totalNum(root,0)\n\t  ```\n- ### Code - BFS\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def sumNumbers(self, root: TreeNode) -> int:\n\t  \t          if not root:\n\t  \t              return 0\n\t  \t  \n\t  \t          total = 0\n\t  \t          nodeQueue = collections.deque([root])\n\t  \t          numQueue = collections.deque([root.val])\n\t  \t          \n\t  \t          while nodeQueue:\n\t  \t              node = nodeQueue.popleft()\n\t  \t              num = numQueue.popleft()\n\t  \t              left, right = node.left, node.right\n\t  \t              if not left and not right:\n\t  \t                  total += num\n\t  \t              else:\n\t  \t                  if left:\n\t  \t                      nodeQueue.append(left)\n\t  \t                      numQueue.append(num * 10 + left.val)\n\t  \t                  if right:\n\t  \t                      nodeQueue.append(right)\n\t  \t                      numQueue.append(num * 10 + right.val)\n\t  \t  \n\t  \t          return total\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- DFS\n\t\t- 时间复杂度: $O(n)$ ，n是节点数\n\t\t- 空间复杂度 $O(height)$ , 深度\n\t- BFS\n\t\t- 时间复杂度: $O(n)$ ，n是节点数\n\t\t- 空间复杂度 $O(n)$ ,\n- ### 知识点汇总\n\t- #### 二叉树\n\t- #### 递归\n\t- #### DFS(深度优先遍历)\n\t\t- 求从根到叶子的路径之和，那我们只需要把每条根到叶子的路径找出来，并求和即可，这里用 DFS 去解，DFS 也是最容易想到的。\n\t- #### BFS(广度优先遍历)\n\t\t- 要求根到的叶子的路径的和，那我们把中间每一层对应的值都求出来，当前层的节点是叶子节点，把对应值相加即可。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100676796","body":"- ### 思路\n\t- 见到二叉树，首选使用递归，然后这个题是需要遍历所有结点的，所以我们可以考虑深度优先遍历DFS或者广度优先遍历BFS\n\t- DFS：考虑二叉树的基本单元，root 和 root.left 和 root.right计算数的相同的规律\n\t\t- 遍历所有的节点，计算深度最大的靠左的节点\n\t- BFS：需要两个队列（先进先出），一个存节点，一个存节点对应的数\n\t\t- 一般的层序遍历是每层从左到右，遍历到最后的元素就是右下角元素。\n\t\t- 如果反过来，每层从右到左进行层序遍历，最后一个就是左下角元素，直接输出即可，不需要记录深度。\n- ### Code - DFS\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode:\n\t  \t  #     def __init__(self, val=0, left=None, right=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.left = left\n\t  \t  #         self.right = right\n\t  \t  class Solution:\n\t  \t      def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n\t  \t          if not root:\n\t  \t              return 0\n\t  \t              num = 0\n\t  \t          def leftDownNum(root, num):\n\t  \t              num += 1\n\t  \t              if not root.right and not root.left:\n\t  \t                  if num > res[1]:\n\t  \t                      res[0] = root.val\n\t  \t                      res[1] = num\n\t  \t                  return\n\t  \t              if root.left:\n\t  \t                  leftDownNum(root.left,num+1)\n\t  \t              if root.right:\n\t  \t                  leftDownNum(root.right,num+1)\n\t  \t          res = [0, -1]\n\t  \t          leftDownNum(root,0)\n\t  \t          return res[0]\n\t  ```\n- ### Code - BFS\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode:\n\t  \t  #     def __init__(self, x):\n\t  \t  #         self.val = x\n\t  \t  #         self.left = None\n\t  \t  #         self.right = None\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def findBottomLeftValue(self, root: TreeNode) -> int:\n\t  \t          if not root:\n\t  \t              return -1\n\t  \t          queue = collections.deque()\n\t  \t          queue.append(root)\n\t  \t          while queue:\n\t  \t              cur = queue.popleft()\n\t  \t              if cur.right:   # 先右\n\t  \t                  queue.append(cur.right)\n\t  \t              if cur.left:    # 后左\n\t  \t                  queue.append(cur.left)\n\t  \t          return cur.val\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- DFS\n\t\t- 时间复杂度: $O(n)$ ，n是节点数\n\t\t- 空间复杂度 $O(height)$ , 深度\n\t- BFS\n\t\t- 时间复杂度: $O(n)$ ，n是节点数\n\t\t- 空间复杂度 $O(Q)$ , Q是队列的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100903083","body":"- ### 思路\n\t- 见到二叉树，首选使用递归，然后这个题是需要遍历所有结点的，所以我们可以考虑深度优先遍历DFS或者广度优先遍历BFS\n\t- DFS（递归）\n\t\t- 序列化：递归遍历一棵树，重点关注当前节点，它的子树的遍历交给递归完成：\n\t\t  “serialize函数，请帮我分别序列化我的左右子树，我等你返回的结果，再拼接一下。”\n\t\t  选择前序遍历，是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。\n\t\t  遇到 null 节点也要翻译成特定符号，反序列化时才知道这里是 null。\n\t\t- 反序列化：\n\t\t\t- 定义函数 buildTree 用于还原二叉树，传入由序列化字符串转成的 list 数组。\n\t\t\t  逐个 pop 出 list 的首项，构建当前子树的根节点，顺着 list，构建顺序是根节点，左子树，右子树。\n\t\t\t  如果弹出的字符为 \"X\"，则返回 null 节点。\n\t\t\t  如果弹出的字符是数值，则创建root节点，并递归构建root的左右子树，最后返回root。\n- ### Code - DFS\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode(object):\n\t  \t  #     def __init__(self, x):\n\t  \t  #         self.val = x\n\t  \t  #         self.left = None\n\t  \t  #         self.right = None\n\t  \t  \n\t  \t  class Codec:\n\t  \t  \n\t  \t      def serialize(self, root):\n\t  \t          \"\"\"Encodes a tree to a single string.\n\t  \t          \n\t  \t          :type root: TreeNode\n\t  \t          :rtype: str\n\t  \t          \"\"\"\n\t  \t          if not root:                  # 遍历到 null 节点\n\t  \t              return 'X'\n\t  \t          left = self.serialize(root.left)   # 左子树的序列化结果\n\t  \t          right = self.serialize(root.right) # 右子树的序列化结果\n\t  \t          return str(root.val) + ',' + str(left) + ','+ str(right) # 按  根,左,右  拼接字符串\n\t  \t  \n\t  \t  \n\t  \t      def deserialize(self, data):\n\t  \t          \"\"\"Decodes your encoded data to tree.\n\t  \t          \n\t  \t          :type data: str\n\t  \t          :rtype: TreeNode\n\t  \t          \"\"\"\n\t  \t          list = data.split(',');   # split成数组\n\t  \t          def buildTree(list):  # 基于list构建当前子树\n\t  \t              rootVal = list.pop(0) # 弹出首项，获取它的“数据”\n\t  \t              if (rootVal == \"X\"):          # 是X，返回null节点\n\t  \t                  return None\n\t  \t              root = TreeNode(rootVal) # 不是X，则创建节点\n\t  \t              root.left = buildTree(list);        # 递归构建左子树\n\t  \t              root.right = buildTree(list);       # 递归构建右子树\n\t  \t              return root;                        # 返回当前构建好的root\n\t  \t          \n\t  \t          return buildTree(list);  # 构建的入口\n\t  \t  \n\t  \t          \n\t  \t  \n\t  \t  # Your Codec object will be instantiated and called as such:\n\t  \t  # ser = Codec()\n\t  \t  # deser = Codec()\n\t  \t  # ans = deser.deserialize(ser.serialize(root))\n\t  ```\n- ### 复杂度\n\t- DFS\n\t\t- 时间复杂度: $O(n)$ ，n是节点数\n\t\t- 空间复杂度 $O(height)$ , 深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101083056","body":"- ### 思路\n\t- 见到二叉树，首选使用递归，然后这个题是需要遍历所有结点的，所以我们可以考虑深度优先遍历DFS或者广度优先遍历BFS\n\t- DFS（递归）\n\t\t- 递归，写一个函数，`root`, `root.left`, `root.right`同时满足的规律，用函数`dfs`来描述\n\t\t- 遍历一遍所有节点，遍历的同时记录列表`(col,row,value)`\n\t\t- 遍历完之后，按照col的大小，从小到大排列\n\t\t- 然后写一个循环，判断如果col值相等的时候，把值放在相同的列表下，如果不相等，创建一个新列表存入`value`\n- ### Code - DFS\n\t-\n\t  ``` python\n\t  \t  # Definition for a binary tree node.\n\t  \t  # class TreeNode:\n\t  \t  #     def __init__(self, val=0, left=None, right=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.left = left\n\t  \t  #         self.right = right\n\t  \t  class Solution:\n\t  \t      def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n\t  \t          nodes = list()\n\t  \t          def dfs(node,row,col):\n\t  \t              if not node:\n\t  \t                  return\n\t  \t              nodes.append((col, row, node.val))\n\t  \t              dfs(node.left, row + 1, col - 1)\n\t  \t              dfs(node.right, row + 1, col + 1)\n\t  \t          dfs(root,0,0)\n\t  \t          nodes.sort()\n\t  \t          ans = list()\n\t  \t          lastcol = float(\"-inf\")\n\t  \t          for col, row, value in nodes:\n\t  \t              if col != lastcol:\n\t  \t                  lastcol = col\n\t  \t                  ans.append(list())\n\t  \t              ans[-1].append(value)\n\t  \t          \n\t  \t          return ans\n\t  ```\n- ### 复杂度\n\t- DFS\n\t\t- 时间复杂度: $O(nlogn)$ ，n是节点数，排序的复杂度`nlogn`\n\t\t- 空间复杂度 $O(height)$ , 深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102808339","body":"- ### 题目描述\n\t-\n\t  ```\n\t  \t  给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\t  \t  \n\t  \t  你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\t  \t  \n\t  \t  你可以按任意顺序返回答案。\n\t  \t  \n\t  \t   \n\t  \t  \n\t  \t  示例 1：\n\t  \t  输入：nums = [2,7,11,15], target = 9\n\t  \t  输出：[0,1]\n\t  \t  解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\t  \t  \n\t  \t  示例 2：\n\t  \t  输入：nums = [3,2,4], target = 6\n\t  \t  输出：[1,2]\n\t  \t  \n\t  \t  示例 3：\n\t  \t  输入：nums = [3,3], target = 6\n\t  \t  输出：[0,1]\n\t  \t  \n\t  \t  来源：力扣（LeetCode）\n\t  \t  链接：https://leetcode-cn.com/problems/two-sum\n\t  \t  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\t  \t  \n\t  ```\n- ### 思路\n\t- 最直接的思路是写for循环，经过两次遍历，\n- ### Code - 暴力枚举\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def twoSum(self, nums: List[int], target: int) -> List[int]:\n\t  \t          n = len(nums)\n\t  \t          for i in range(n):\n\t  \t              for j in range(i+1,len(nums)):\n\t  \t                  if nums[i] + nums[j] == target and i != j:\n\t  \t                      return [i,j]\n\t  \t          return []\n\t  ```\n- ### Code - Hash Table\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def twoSum(self, nums: List[int], target: int) -> List[int]:\n\t  \t          hashtable = dict()\n\t  \t          for i,num in enumerate(nums):\n\t  \t              if target - num in hashtable:\n\t  \t                  return [hashtable[target-num],i]\n\t  \t              hashtable[nums[i]] = i\n\t  \t          return []\n\t  ```\n- ### 复杂度\n\t- 暴力枚举\n\t\t- 时间复杂度: $O(n^2)$ ，时间复杂度高，不是一个好的算法\n\t\t- 空间复杂度 $O(1)$\n\t- Hash Table\n\t\t- 时间复杂度: $O(n)$\n\t\t- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104064249","body":"- ### 思路\r\n\t- #### 暴力排序算法\r\n\t\t- 这个题目中首先需要遍历一遍数组，记录数组中的数字-数字出现的次数作为哈希表\r\n\t\t- 然后将哈希表从大到小的排序，取出前k个次数，然后对应的值组成数组返回结果\r\n\t- #### 最小堆\r\n\t\t- 题目最终需要返回的是前 `k` 个频率最大的元素，可以想到借助堆这种数据结构，对于 `k` 频率之后的元素不用再去处理，进一步优化时间复杂度。\r\n\t\t- ![image.png](../assets/image_1650464913139_0.png)\r\n\t\t- 具体操作为：\r\n\t\t\t- 借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率\r\n\t\t\t- 维护一个元素数目为 k的最小堆\r\n\t\t\t- 每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较\r\n\t\t\t- 如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中\r\n\t\t\t- 最终，堆中的 kk 个元素即为前 kk 个高频元素\r\n\t- #### 桶排序\r\n\t\t- https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/\r\n\t\t- 首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。\r\n\t\t- ![image.png](../assets/image_1650466728981_0.png)\r\n- ### Code - 暴力枚举\r\n\t-\r\n\t  ``` python\r\n\t  \t  class Solution:\r\n\t  \t      def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n\t  \t          hashtable = dict()\r\n\t  \t          for i in nums:\r\n\t  \t              if i in hashtable:\r\n\t  \t                  hashtable[i] += 1\r\n\t  \t              else:\r\n\t  \t                  hashtable[i] = 1\r\n\t  \t          result = list()\r\n\t  \t          times = list()\r\n\t  \t          for key,value in hashtable.items():  #key表示数组中的某个元素；value: 这个元素在数组中出现的次数\r\n\t  \t              if len(times) < k:\r\n\t  \t                  times.append(value)\r\n\t  \t                  result.append(key)\r\n\t  \t              else:\r\n\t  \t                  if value > min(times):\r\n\t  \t                      result.pop(times.index(min(times))) \r\n\t  \t                      result.append(key)\r\n\t  \t                      times.pop(times.index(min(times))) \r\n\t  \t                      times.append(value)\r\n\t  \t          return result\r\n\t  ```\r\n- ### Code - 堆排序\r\n\t-\r\n\t  ``` python\r\n\t  \t  cclass Solution:\r\n\t  \t      def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n\t  \t          def sift_down(arr, root, k):\r\n\t  \t              \"\"\"下沉log(k),如果新的根节点>子节点就一直下沉\"\"\"\r\n\t  \t              val = arr[root] # 用类似插入排序的赋值交换\r\n\t  \t              while root<<1 < k:\r\n\t  \t                  child = root << 1\r\n\t  \t                  # 选取左右孩子中小的与父节点交换\r\n\t  \t                  if child|1 < k and arr[child|1][1] < arr[child][1]:\r\n\t  \t                      child |= 1 # (child = child|1)\r\n\t  \t                  # 如果子节点<新节点,交换,如果已经有序break\r\n\t  \t                  if arr[child][1] < val[1]:\r\n\t  \t                      arr[root] = arr[child]\r\n\t  \t                      root = child\r\n\t  \t                  else:\r\n\t  \t                      break\r\n\t  \t              arr[root] = val\r\n\t  \t  \r\n\t  \t          def sift_up(arr, child):\r\n\t  \t              \"\"\"上浮log(k),如果新加入的节点<父节点就一直上浮\"\"\"\r\n\t  \t              val = arr[child]\r\n\t  \t              while child>>1 > 0 and val[1] < arr[child>>1][1]:\r\n\t  \t                  arr[child] = arr[child>>1]\r\n\t  \t                  child >>= 1\r\n\t  \t              arr[child] = val\r\n\t  \t  \r\n\t  \t          stat = collections.Counter(nums)\r\n\t  \t          stat = list(stat.items())\r\n\t  \t          heap = [(0,0)]\r\n\t  \t  \r\n\t  \t          # 构建规模为k+1的堆,新元素加入堆尾,上浮\r\n\t  \t          for i in range(k):\r\n\t  \t              heap.append(stat[i])\r\n\t  \t              sift_up(heap, len(heap)-1) \r\n\t  \t          # 维护规模为k+1的堆,如果新元素大于堆顶,入堆,并下沉\r\n\t  \t          for i in range(k, len(stat)):\r\n\t  \t              if stat[i][1] > heap[1][1]:\r\n\t  \t                  heap[1] = stat[i]\r\n\t  \t                  sift_down(heap, 1, k+1) \r\n\t  \t          return [item[0] for item in heap[1:]]\r\n\t  \t  \r\n\t  \t        \r\n\t  ```\r\n- ### 复杂度\r\n\t- #### 暴力排序\r\n\t\t- 时间复杂度: $O(nlogn)$\r\n\t\t- 空间复杂度 $O(1)$\r\n\t\t- 看到这样的复杂度的组合，我们希望用空间换时间，来继续优化这个问题。\r\n\t- #### 堆排序\r\n\t\t- 时间复杂度: $O(nlogk)$\r\n\t\t- 空间复杂度 $O(n)$\r\n\t- #### 桶排序\r\n\t\t- 时间复杂度: $O(n)$\r\n\t\t- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105390061","body":"- ### 题目描述\r\n\t-\r\n\t  ```\r\n\t  \t  给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。\r\n\t  \t  \r\n\t  \t  返回平面上所有回旋镖的数量。\r\n\t  \t  \r\n\t  \t   \r\n\t  \t  示例 1：\r\n\t  \t  \r\n\t  \t  输入：points = [[0,0],[1,0],[2,0]]\r\n\t  \t  输出：2\r\n\t  \t  解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\r\n\t  \t  示例 2：\r\n\t  \t  \r\n\t  \t  输入：points = [[1,1],[2,2],[3,3]]\r\n\t  \t  输出：2\r\n\t  \t  示例 3：\r\n\t  \t  \r\n\t  \t  输入：points = [[1,1]]\r\n\t  \t  输出：0\r\n\t  \t   \r\n\t  \t  \r\n\t  \t  提示：\r\n\t  \t  \r\n\t  \t  n == points.length\r\n\t  \t  1 <= n <= 500\r\n\t  \t  points[i].length == 2\r\n\t  \t  -104 <= xi, yi <= 104\r\n\t  \t  所有点都 互不相同\r\n\t  \t  \r\n\t  \t  来源：力扣（LeetCode）\r\n\t  \t  链接：https://leetcode-cn.com/problems/number-of-boomerangs\r\n\t  \t  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\t  \t  \r\n\t  ```\r\n- ### 思路\r\n\t- #### 枚举+哈希\r\n\t\t- 我们可以将点到其他两个点的距离和个数存到哈希表中，如果这个距离对应的点的个数`cnt[dis]`大于1，那么就增加了从这些数中任选两个就可以组成一个回旋镖。\r\n\t\t- 每一个距离相等的点的回旋镖个数可以写成`n(n-1)`\r\n\t\t- 联系前n项和的公式构造一个等价关系\r\n\t\t\t- $[(0+(n-1))*n]/2$\r\n\t\t\t- n(n-1) = 2*(0+1+...+(n-1))\r\n\t\t\t- 所以，我们也可以每次判断`cnt[dis]`大于1时，就增加`cnt[dis]-1`个相同距离的对数，然后最后再乘以2，也可以得到结果，同时可以少用一个for循环。\r\n- ### Code - 枚举+哈希表\r\n\t-\r\n\t  ``` python\r\n\t  \t  class Solution:\r\n\t  \t      def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n\t  \t          ans = 0\r\n\t  \t          for p in points:\r\n\t  \t              cnt = defaultdict(int) # defaultdict()用在，要生成一个字典，但是又没有默认值的情况，可以使用它来生成一个默认值，而不发生keyerror报错。\r\n\t  \t              for q in points:\r\n\t  \t                  dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\r\n\t  \t                  cnt[dis] += 1\r\n\t  \t                  if cnt[dis] > 1:\r\n\t  \t                      ans += cnt[dis]-1\r\n\t  \t          return ans*2\r\n\t  ```\r\n- ### 复杂度\r\n\t- #### 枚举+哈希表\r\n\t\t- 时间复杂度: $O(n^2)$\r\n\t\t- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106647779","body":"- ### 思路\n\t- #### 涉及出现次数，要用哈希表\n\t- #### 涉及子串，考虑滑动窗口\n\t\t- 设置两个指针，表示滑动窗口的左边界和有边界\n\t\t- 如果当前字符不在子串里，滑动右指针\n\t\t- 如果字符在子串里\n\t\t\t- 比较最大子串的长度和当前子串的长度，留下长的最为最大子串的长度\n\t\t\t- 滑动左指针到当前的字符，也就是重复的字符\n\t\t- 最后返回最大子串长度\n\t\t-\n- ### Code - 滑动窗口\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def lengthOfLongestSubstring(self, s: str) -> int:\n\t  \t          # 哈希集合，记录每个字符是否出现过\n\t  \t          occ = set()\n\t  \t          n = len(s)\n\t  \t          # 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n\t  \t          rk, ans = -1, 0\n\t  \t          for i in range(n):\n\t  \t              if i != 0:\n\t  \t                  # 左指针向右移动一格，移除一个字符\n\t  \t                  occ.remove(s[i - 1])\n\t  \t              while rk + 1 < n and s[rk + 1] not in occ:\n\t  \t                  # 不断地移动右指针\n\t  \t                  occ.add(s[rk + 1])\n\t  \t                  rk += 1\n\t  \t              # 第 i 到 rk 个字符是一个极长的无重复字符子串\n\t  \t              ans = max(ans, rk - i + 1)\n\t  \t          return ans\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- #### 滑动窗口\n\t\t- 时间复杂度: $O(n)$ ，字符串的长度\n\t\t- 空间复杂度 $O(m)$ , 最大子串的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107525124","body":"- ### 思路\n\t- #### 涉及出现次数，要用哈希表\n\t- #### 涉及子串，考虑滑动窗口\n\t\t- 设置两个指针，表示滑动窗口的左边界和有边界\n\t\t- 如果当前字符不在子串里，滑动右指针\n\t\t- 因为单词长度固定的，我们可以计算出截取字符串的单词个数是否和 words 里相等，所以我们可以借用哈希表。\n\t\t- 一个是哈希表是 words，一个哈希表是截取的字符串，比较两个哈希是否相等！\n- ### Code - 滑动窗口+哈希表比较\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def findSubstring(self, s: str, words: List[str]) -> List[int]:\n\t  \t          from collections import Counter\n\t  \t          # 主串s中没有这个单词，直接返回空\n\t  \t          if not s or not words:return []  \n\t  \t          # 每个单词的长度， words总长度\n\t  \t          one_word = len(words[0])\n\t  \t          word_num = len(words)\n\t  \t          n = len(s)\n\t  \t          # 主串s长度小于单词总和，返回空\n\t  \t          if n < one_word:return []\n\t  \t          words = Counter(words)\n\t  \t          res = []\n\t  \t          # 只讨论从0，1，...， one_word-1 开始的子串情况，\n\t  \t          # 每次进行匹配的窗口大小为 word_num，每次后移一个单词长度，由左右窗口维持当前窗口位置\n\t  \t          for i in range(0, one_word):\n\t  \t              cur_cnt = 0\n\t  \t              #  设置左右窗口\n\t  \t              left = i\n\t  \t              right = i\n\t  \t              # 统计每个符合要求的word\n\t  \t              cur_Counter = Counter()\n\t  \t              # 右窗口不能超出主串长度\n\t  \t              while right + one_word <= n:\n\t  \t                  # 得到一个单词\n\t  \t                  w = s[right:right + one_word]\n\t  \t                  # 右窗口往右移动一个单词的长度 word_num\n\t  \t                  right += one_word\n\t  \t                  # 判断如果words中没有这个单词，那么当前窗口肯定匹配失败，左指针直接右移到这个单词后面\n\t  \t                  if w not in words:\n\t  \t                      left = right\n\t  \t                      # 窗口内单词统计map清空，重新统计\n\t  \t                      cur_Counter.clear()\n\t  \t                      # 符合要求的单词数清0\n\t  \t                      cur_cnt = 0\n\t  \t                  else:\n\t  \t                      # 统计当前子串中这个单词出现的次数\n\t  \t                      cur_Counter[w] += 1\n\t  \t                      cur_cnt += 1\n\t  \t                      # 如果这个单词出现的次数大于words[]中它对应的次数，又由于每次匹配和words长度相等的子串\n\t  \t                      # 如 [\"foo\",\"bar\",\"foo\",\"the\"]  \"| foobarfoobar| foothe\"\n\t  \t                      # 第二个bar虽然是words[]中的单词，但是次数超了，那么右移一个单词长度后 \"|barfoobarfoo|the\"\n\t  \t                      # bar还是不符合，所以直接从这个不符合的bar之后开始匹配，\n\t  \t                      # 也就是将这个不符合的bar和它之前的单词(串)全移出去\n\t  \t                      while cur_Counter[w] > words[w]:\n\t  \t                          # 从当前窗口字符统计map中删除从左窗口开始到数量超限的所有单词(次数减一)\n\t  \t                          left_w = s[left:left+one_word]\n\t  \t                          # 左窗口位置右移一个单词长度\n\t  \t                          left += one_word\n\t  \t                          # 符合的单词数减一\n\t  \t                          cur_Counter[left_w] -= 1\n\t  \t                          cur_cnt -= 1\n\t  \t                      # 当前窗口字符串满足要求\n\t  \t                      if cur_cnt == word_num :\n\t  \t                          res.append(left)\n\t  \t          return res\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- #### 滑动窗口\n\t\t- 时间复杂度: $O(n)$ ，字符串的长度\n\t\t- 空间复杂度 $O(n)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108703293","body":"- ### 思路\n\t- 快慢指针，遍历链表，快指针每次走两个节点，慢指针每次一个节点。快指针到达链表尾部的时候，慢指针正好到达中间。\n- ### Code - 快慢指针\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  # class ListNode:\n\t  \t  #     def __init__(self, val=0, next=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.next = next\n\t  \t  class Solution:\n\t  \t      def middleNode(self, head: ListNode) -> ListNode:\n\t  \t          # 如果listNode只有一个节点, 则直接返回head\n\t  \t          if head.next == None:\n\t  \t              return head\n\t  \t          # 定义两个指针\n\t  \t          r = l = head\n\t  \t          while r:\n\t  \t              if r.next.next:\n\t  \t                  r = r.next.next\n\t  \t                  l = l.next\n\t  \t              if r.next and not r.next.next:\n\t  \t                  r = r.next\n\t  \t                  l = l.next\n\t  \t                  break \n\t  \t              if not r.next:\n\t  \t                  break\n\t  \t          return l\n\t  \t        \n\t  ```\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  # class ListNode:\n\t  \t  #     def __init__(self, val=0, next=None):\n\t  \t  #         self.val = val\n\t  \t  #         self.next = next\n\t  \t  class Solution:\n\t  \t      def middleNode(self, head: ListNode) -> ListNode:\n\t  \t          l = r = head\n\t  \t          while r.next and r.next.next:\n\t  \t              r = r.next.next\n\t  \t              l = l.next\n\t  \t          if not r.next: return l\n\t  \t          if not r.next.next: return l.next\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，n是链表的长度\n\t- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109953001","body":"- ### 思路\n\t- 要求不同的数值，也就是将不重复的元素移动到最左边，然后返回最左边的最后一个不重复元素的（索引+1）就是不重复数字的个数。\n\t- 双指针，遍历链表，`P1`指针先走，如果两个指针对应的数组元素相等那么`P1`继续向前走，如果两个指针对应的元素不相等，将`p1`指针的元素移动到`p2指针+1`的位置。\n\t- 最终返回`p2+1`，就是不重复数组的长度\n- ### Code - 双指针\n\t- 一开始，我在循环中使用了`remove`函数，没有考虑到这个的时间复杂度是 $O(n)$ ，导致运行的速度很慢，有1000ms左右。\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def removeDuplicates(self, nums: List[int]) -> int:\n\t  \t          if len(nums) == 0: return 0\n\t  \t          if len(nums) == 1: return len(nums)\n\t  \t          p1, p2 = 0, 1\n\t  \t          while p2 < len(nums):\n\t  \t              if nums[p1] == nums[p2]:\n\t  \t                  nums.remove(nums[p2])\n\t  \t              else:\n\t  \t                  p1 = p2\n\t  \t                  p2 += 1\n\t  \t          return len(nums)\n\t  \t        \n\t  ```\n\t- 后来，参考题解中的方法，其实和我的思路大致一致，没有进行删除操作\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def removeDuplicates(self, nums: List[int]) -> int:\n\t  \t          if len(nums) == 0: return 0\n\t  \t          if len(nums) == 1: return len(nums)\n\t  \t          p1, p2 = 0, 1\n\t  \t          while p2 < len(nums):\n\t  \t              if nums[p1] != nums[p2]:\n\t  \t                  p1 += 1\n\t  \t                  nums[p1] = nums[p2]\n\t  \t              else:\n\t  \t                  p2 += 1\n\t  \t          return p1+1\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，n是数组的长度\n\t- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111171039","body":"- ### 思路\n\t- 标签：二分查找\n\t  如果该题目暴力解决的话需要 O(n)O(n) 的时间复杂度，但是如果二分的话则可以降低到 O(logn)O(logn) 的时间复杂度\n\t  整体思路和普通的二分查找几乎没有区别，先设定左侧下标 left 和右侧下标 right，再计算中间下标 mid\n\t  每次根据 nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标，nums[mid] < target 则 left 右移，nums[mid] > target 则 right 左移\n\t  查找结束如果没有相等值则返回 left，该值为插入位置\n\t  时间复杂度：O(logn)O(logn)\n\t  二分查找的思路不难理解，但是边界条件容易出错，比如 循环结束条件中 left 和 right 的关系，更新 left 和 right 位置时要不要加 1 减 1。\n- ### Code - 双指针+二分\n\t- 一开始，我在循环中使用了`remove`函数，没有考虑到这个的时间复杂度是 $O(n)$ ，导致运行的速度很慢，有1000ms左右。\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def searchInsert(self, nums: List[int], target: int) -> int:\n\t  \t          n = len(nums)\n\t  \t          left = 0;\n\t  \t          right = n-1;\n\t  \t          while left < right:\n\t  \t              mid = (left + right)//2\n\t  \t              if nums[mid] == target:\n\t  \t                  return mid\n\t  \t              if nums[mid] > target:\n\t  \t                  right = max(mid,0)\n\t  \t              if nums[mid] < target:\n\t  \t                  left = min(mid+1,n)\n\t  \t          if left == right:\n\t  \t              if target > nums[left]:\n\t  \t                  return min(left+1,n)\n\t  \t              if target < nums[left]:\n\t  \t                  return max(left,0)\n\t  \t              if target == nums[left]:\n\t  \t                  return left\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(logn)$ ，n是数组的长度\n\t- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112382159","body":"- 思路\n\t- 其实，我们没必须存储窗口内的所有元素。 如果新进入的元素比前面的大，那么前面的元素就不再有利用价值，可以直接移除。这提示我们使用一个单调递增栈[1]来完成。\n\t- 但由于窗口每次向右移动的时候，位于窗口最左侧的元素是需要被擦除的，而栈只能在一端进行操作。而如果你使用普通的数组实现，就是可以在另一端操作了，但是时间复杂度仍然是 O(k)O(k)，和上面的暴力算法时间复杂度一样。\n\t- 因此，我们考虑使用链表来实现，维护两个指针分别指向头部和尾部即可，这样做的时间复杂度是 O(1)O(1)，这就是双端队列。\n\t- 因此思路就是用一个双端队列来保存接下来的滑动窗口可能成为最大值的数。\n\t- 具体做法：\n\t- 入队列\n\t- 移除失效元素，失效元素有两种\n\t  一种是已经超出窗口范围了，比如我遍历到第 4 个元素，k = 3，那么 i = 0 的元素就不应该出现在双端队列中了。具体就是索引大于 i - k + 1的元素都应该被清除\n\t- 小于当前元素都没有利用价值了，具体就是从后往前遍历（双端队列是一个递减队列）双端队列，如果小于当前元素就出队列\n\t- 经过上面的分析，不难知道双端队列其实是一个递减的一个队列，因此队首的元素一定是最大的。\n\t- ![image.png](../assets/image_1651161355344_0.png)\n- Code - 单调队列\n\t- 一开始，暴力解法，导致时间超出了限制时间。\n\t-\n\t  ``` python\n\t  class Solution:\n\t      def searchInsert(self, nums: List[int], target: int) -> int:\n\t          n = len(nums)\n\t          left = 0;\n\t          right = n-1;\n\t          while left < right:\n\t              mid = (left + right)//2\n\t              if nums[mid] == target:\n\t                  return mid\n\t              if nums[mid] > target:\n\t                  right = max(mid,0)\n\t              if nums[mid] < target:\n\t                  left = min(mid+1,n)\n\t          if left == right:\n\t              if target > nums[left]:\n\t                  return min(left+1,n)\n\t              if target < nums[left]:\n\t                  return max(left,0)\n\t              if target == nums[left]:\n\t                  return left\n\t  ```\n- 复杂度\n\t- 时间复杂度: $O(n)$ ，n是数组的长度\n\t- 空间复杂度 $O(k)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113396921","body":"- ### 思路\n\t- 题目两个条件\n\t\t- 条件1：除了法官，都信任法官\n\t\t- 条件2：法官不信任法官\n\t- 那么可以利用图数据结构，看图中每个元素的出度和入度。\n\t\t- 如果出度是0（条件2），入度是N-1（条件1），那么返回这个元素。\n\t\t- 如果不存在，则返回-1\n- ### Code - 图，出度，入度\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def findJudge(self, n: int, trust: List[List[int]]) -> int:\n\t  \t          if not trust: \n\t  \t              if n == 1: return n  \n\t  \t              else: return -1\n\t  \t          # 存放要维护的（入度-出度）的差值\n\t  \t          count = [0]*(n+1)\n\t  \t          for i,j in trust:\n\t  \t              # 被信任的元素，入度加1\n\t  \t              count[i] -= 1\n\t  \t              # 信任法官的元素，出度减去1\n\t  \t              count[j] += 1\n\t  \t          print(count)\n\t  \t          # 遍历一遍记录出入度差值的数组，找到满足（N-1）的位置。\n\t  \t          for i in range(len(count)):\n\t  \t              if count[i] == n-1:\n\t  \t                  return i\n\t  \t          return -1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，n是数组的长度\n\t- 空间复杂度 $O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085579178","body":"* ### 思路\n\n最开始想着将num数组变为数字，再加K，但是数组的长度最大为1w，变量接收不了这么大的数。\n\n最后用数组从后向前遍历，加上k的值，注意进位与整除。\n\n* ### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for (int i=num.size()-1; i>=0 ;i--){\n            int temp = 0;\n            temp = (num[i] + k)%10;\n            k = (num[i] + k)/10;\n            res.insert(res.begin(), temp);\n        }\n        while (0 != k){\n            res.insert(res.begin(), k%10);\n            k /= 10;\n        }\n        return res;\n    }\n};\n```\n\n* ### 复杂度\n    * 时间复杂度O(max(n,c)) n为num的长度，c为k的位数\n    * 空间复杂度O(max(n,c)) n为num的长度，c为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086519518","body":"### 思路\n先从左向右遍历，再从右向左遍历取最小值\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int pre = INT32_MIN/2;\n        for (int i = 0; i < s.size() ; i++){\n            if (s[i] == c) pre = i;\n            answer[i] = i - pre;\n        }\n        pre = INT32_MAX;\n        for (int i = s.size()-1 ; i >= 0 ; i--){\n            if (s[i] == c) pre = i;\n            if (answer[i] > (pre - i))\n                answer[i] = pre - i;\n        }\n        return answer;\n    }\n};\n```\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086890399","body":"```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        top = maxSize;\r\n        now = -1;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (now < top-1){\r\n            ++now;\r\n            stack[now] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (-1 == now) return -1;\r\n        int popNum = stack[now];\r\n        --now;\r\n        return popNum;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, now+1);\r\n        for (int i = 0; i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> stack;\r\n    int top;\r\n    int now;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087652562","body":"### 思路\n递归\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string r;\n        for (int i = 0; i < s.size(); i++){\n            int move = 0;\n            if (isdigit(s[i])){\n                i += cString(&s[i],r);\n            }else if(']' != s[i]){\n                r.push_back(s[i]);\n            }\n        }\n        return r;\n    }\n\n    int cString(string s, string &r){\n        int count = 0;\n        int num = 0;\n        int renum = 0;\n        while (isdigit(s[count])){\n            num = num*10 + (s[count] - '0');\n            count++;\n        }\n        count++;//'['计数加一\n        for (int i = 0; i < num; i++){\n            renum = count;\n            while (']' != s[renum]){\n                if (isdigit(s[renum])) {\n                    renum += cString(&s[renum],r);\n                }else{\n                    r.push_back(s[renum]);\n                }\n                renum++;\n            }\n        }\n        return renum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088806024","body":"### 思路\r\n使用两个栈，一个进栈一个出栈，push时直接放入进栈，pop时若出栈为空，就将进栈全部push进入出栈。\r\n\r\n### 代码\r\n```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> stkin,stkout;\r\n    void in2out(){\r\n        while (!stkin.empty())\r\n        {\r\n            int a = stkin.top();\r\n            stkout.push(a);\r\n            stkin.pop();\r\n        }\r\n    }\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        stkin.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int topNum = 0;\r\n        if (stkout.empty()) in2out();\r\n        topNum = stkout.top();\r\n        stkout.pop();\r\n        return topNum;\r\n    }\r\n    \r\n    int peek() {\r\n        int topNum = 0;\r\n        if (stkout.empty()) in2out();\r\n        topNum = stkout.top();\r\n        return topNum;\r\n    }\r\n    \r\n    bool empty() {\r\n        return ((stkin.empty()) & (stkout.empty()));\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090361196","body":"### 思路\r\n使用哈希计数排序\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n//哈希解法\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        map<int,int> a;\r\n        map<int,int> b;\r\n        vector <int> sortArr = arr;\r\n        int renum = 0;\r\n        sort(sortArr.begin(), sortArr.end());\r\n        for (int i = 0; i <arr.size(); i++){\r\n            a[arr[i]] += 1;\r\n            b[sortArr[i]] += 1;\r\n            if (a == b) renum++;\r\n        }\r\n        return renum;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091811824","body":"### 思路\r\n* 旋转闭环链表\r\n* 快慢指针\r\n\r\n### 代码\r\n```c++\r\nclass Solution{\r\n//环形链表\r\n/* \r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k){\r\n        int size = 0;\r\n        if (nullptr == head) return head;\r\n        ListNode *ptr = head;\r\n        while (nullptr != ptr->next){\r\n            size++;\r\n            ptr = ptr->next;\r\n        }\r\n        size++;\r\n\r\n        int num = size - (k%size);\r\n\r\n        ptr->next = head;\r\n\r\n        for (int i = 0;i < num; i++){\r\n            ptr = ptr->next;\r\n        }\r\n        head = ptr->next;\r\n        ptr->next = nullptr;\r\n        return head;\r\n    } */\r\n//双指针快慢指针\r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k){\r\n        ListNode *fastPtr = head;\r\n        ListNode *lowPtr = head;\r\n        ListNode *tmp = head;\r\n        int size = 0;\r\n        if (nullptr == head) return head;\r\n        \r\n        while (nullptr != tmp){\r\n            size++;\r\n            tmp = tmp->next;\r\n        }\r\n        k = k%size;\r\n        while(nullptr != fastPtr->next){\r\n            if(k-- <=0) lowPtr = lowPtr->next;\r\n            fastPtr = fastPtr->next;\r\n        }\r\n        fastPtr->next = head;\r\n        head = lowPtr->next;\r\n        lowPtr->next = nullptr;\r\n        return head;\r\n    } \r\n};\r\n```\r\n### 复杂度\r\n* 时间复杂度On\r\n* 空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092919323","body":"### 思路\r\n在链表前面加上一个pre节点，然后进行交换\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (nullptr == head || nullptr == head->next) return head;\r\n        ListNode* preHead = new ListNode(-1,head);\r\n        ListNode* tmpPtr = preHead;\r\n        ListNode *cur = preHead->next;\r\n        while (nullptr != cur && nullptr != cur->next){\r\n            ListNode *second = cur->next;\r\n            cur->next = second->next;\r\n            second->next = cur;\r\n            tmpPtr->next = second;\r\n            tmpPtr = cur;\r\n            cur = cur->next;\r\n        }\r\n        return preHead->next;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094059006","body":"### 思路\r\n快慢指针递归\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (nullptr == head) return nullptr;\r\n        return getTree(head, nullptr);\r\n    }\r\n    TreeNode* getTree(ListNode* startPtr, ListNode* endPtr){\r\n        if (startPtr == endPtr) return nullptr;\r\n        ListNode* lowPtr = startPtr;\r\n        ListNode* fastPtr = startPtr;\r\n        while(endPtr != fastPtr && endPtr != fastPtr->next){\r\n            lowPtr = lowPtr->next;\r\n            fastPtr = fastPtr->next->next;\r\n        }\r\n        TreeNode* root = new TreeNode(lowPtr->val);\r\n        root->left = getTree(startPtr,lowPtr);\r\n        root->right = getTree(lowPtr->next,endPtr);\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094298690","body":"### 思路\r\n双指针，分别遍历两张表，两张表的总路程是一定的\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (nullptr == headA || nullptr == headB) return nullptr;\r\n        ListNode *ptrA = headA;\r\n        ListNode *ptrB = headB;\r\n        while (ptrA != ptrB){\r\n            ptrA = ptrA==nullptr?headB:ptrA->next;\r\n            ptrB = ptrB==nullptr?headA:ptrB->next;\r\n        }\r\n        return ptrA;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095124333","body":"### 思路\r\n使用快慢指针，快指针两步，慢指针一步，若链表有环，则快慢指针在环中相遇后，快指针重新指向head，一步一步的走，在快慢再次相遇时，就为环的入口。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slowPtr = head;\r\n        ListNode *fastPtr = head;\r\n        while(1){\r\n            if (nullptr == fastPtr || nullptr == fastPtr->next) return nullptr;\r\n            slowPtr = slowPtr->next;\r\n            fastPtr = fastPtr->next->next;\r\n            if (slowPtr == fastPtr) break;\r\n        }\r\n        fastPtr = head;\r\n        while(fastPtr != slowPtr){\r\n            slowPtr = slowPtr->next;\r\n            fastPtr = fastPtr->next;\r\n        }\r\n        return fastPtr;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096837497","body":"### 思路\r\n使用链表+哈希表实现，链表用来存储key和value，哈希表用来存储对应key的链表节点的地址。\r\n\r\n### 代码\r\n```c++\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n        capacitys = capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!hash[key]) return -1;\r\n        DLinkedNode *ptr = hash[key];\r\n        moveTohead(ptr);\r\n        return ptr->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (hash[key]){\r\n            DLinkedNode *ptr = hash[key];\r\n            ptr->value = value;\r\n            moveTohead(ptr);\r\n        }else{\r\n            DLinkedNode *ptr = new DLinkedNode(key,value);\r\n            hash[key] = ptr;\r\n            addToHead(ptr);\r\n            size++;\r\n            if (size > capacitys){\r\n                DLinkedNode *tmpptr = removeTail();\r\n                hash.erase(tmpptr->key);\r\n                size--;\r\n            }\r\n        }\r\n    }\r\n    void addToHead(DLinkedNode *node){\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    void removeNode(DLinkedNode *node){\r\n        node->next->prev = node->prev;\r\n        node->prev->next = node->next;\r\n    }\r\n    void moveTohead(DLinkedNode *node){\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n    DLinkedNode *removeTail(){\r\n        DLinkedNode *ptr = tail->prev;\r\n        removeNode(ptr);\r\n        return ptr;\r\n    }\r\nprivate:\r\n    unordered_map<int,DLinkedNode*>hash;\r\n    DLinkedNode *head;\r\n    DLinkedNode *tail;\r\n    int size = 0;\r\n    int capacitys = 0;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098106469","body":"### 思路\r\n使用递归\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) return 0;\r\n        int leftMaxDepth = maxDepth(root->left);\r\n        int rightMaxDepth = maxDepth(root->right);\r\n        return max(leftMaxDepth, rightMaxDepth)+1;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099209577","body":"### 思路\r\n递归\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p == nullptr && q == nullptr) return true;\r\n        if(p == nullptr || q == nullptr) return false;\r\n        if(p->val!=q->val) return false;\r\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100151764","body":"### 思路\r\n使用DFS遍历节点，递归。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        return mySumNumbers(root, 0);\r\n    }\r\n    int mySumNumbers(TreeNode* root, int num){\r\n        if (nullptr == root) return 0;\r\n        num = num * 10 +root->val;\r\n        if (nullptr == root->left && nullptr == root->right){\r\n            return num;\r\n        }else{\r\n            return mySumNumbers(root->left, num) + mySumNumbers(root->right, num);\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100675644","body":"### 思路\r\n使用BFS广度优先，把最后一行的第一个节点返回。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n        TreeNode * res = nullptr;\r\n        while (!q.empty())\r\n        {\r\n            res = q.front();\r\n            int size = q.size();\r\n            q.pop();\r\n            while (size--)\r\n            {\r\n                TreeNode *cur = q.front();\r\n                if (cur->left)\r\n                    q.push(cur->left);\r\n                if (cur->right)\r\n                    q.push(cur->right);\r\n            }\r\n        }\r\n        return res->val;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100885602","body":"### 思路\r\nBFS前序遍历\r\n\r\n### 代码\r\n```c++\r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        string str = \"\";\r\n        rserialize(root, str);\r\n        return str;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.pop_front();\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str+=ch;\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101455349","body":"### 思路\r\n使用DFS遍历，用node结构体存储x,y,val。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    struct node{\r\n        int val;\r\n        int x;\r\n        int y;\r\n        node(int v,int X,int Y):val(v),x(X),y(Y){};\r\n    };\r\n    static bool cmp(node a, node b){\r\n        if (a.x^b.x)\r\n            return a.x<b.x;\r\n        if (a.y^b.y)\r\n            return a.y<b.y;\r\n        return a.val<b.val;\r\n    }\r\n    vector<node> a;\r\n    int minx=1000,maxx=-1000;\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(a.begin(),a.end(),cmp);\r\n        vector<vector<int>>ans(maxx-minx+1);\r\n        for (auto i : a){\r\n            ans[i.x - minx].push_back(i.val);\r\n        }\r\n        return ans;\r\n    }\r\n    void dfs(TreeNode* root, int x, int y){\r\n        if (root == nullptr)\r\n            return;\r\n        if (x < minx)\r\n            minx = x;\r\n        if (x > maxx)\r\n            maxx = x;\r\n        a.push_back(node(root->val,x,y));\r\n        dfs(root->left, x-1, y+1);\r\n        dfs(root->right, x+1, y+1);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102698748","body":"### 思路\r\n哈希表\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        map<int,int>a;\r\n        for(int i = 0; i < nums.size(); i++){\r\n            auto it = a.find(target - nums[i]);\r\n            if(it != a.end()){\r\n                return {it->second, i};\r\n            }\r\n            a[nums[i]] = i;\r\n        }\r\n        return {};\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104016825","body":"### 思路\r\n首先遍历一遍数组，用哈希表存储每个value出现的次数，再用存入最小堆。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        map<int,int>mp;\r\n        for (auto &num : nums){\r\n            mp[num]++;\r\n        }\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\r\n        for(auto a:mp){\r\n            if(q.size() == k){\r\n                if (q.top().first<a.second){\r\n                    q.pop();\r\n                    q.push(make_pair(a.second,a.first));\r\n                }\r\n            }else{\r\n                q.push(make_pair(a.second,a.first));\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while(!q.empty()){\r\n            ret.push_back(q.top().second);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105205564","body":"### 思路\r\n枚举和哈希表\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int ans = 0;\r\n        for(auto &it : points){\r\n            map<int,int>mp;\r\n            for(auto &q:points){\r\n                int dist = (it[0] - q[0])*(it[0] - q[0]) + (it[1] - q[1])*(it[1] - q[1]);\r\n                mp[dist]++;\r\n            }\r\n            for(auto &res : mp){\r\n            ans += res.second*(res.second - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106535239","body":"### 思路\r\n使用哈希表，双指针，滑动窗口\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int ansMax = 0;\r\n        int l = 0, r = 0;\r\n        unordered_map<char,int>map;\r\n        while(r < s.size()){\r\n            if(map.count(s[r]) > 0){\r\n                int lastPost = map[s[r]];\r\n                if(lastPost>=l && lastPost<=r)\r\n                    l = lastPost +1;\r\n            }\r\n            ansMax = max(ansMax,r-l+1);\r\n            map[s[r]] = r;\r\n            r++;\r\n        }\r\n        return ansMax;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107519244","body":"```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        vector<int> res;\r\n        if (words.size() == 0)\r\n            return res;\r\n        int wlen = words[0].size();\r\n        int slen = s.size();\r\n        int count = words.size();\r\n        map<string, int>mp;\r\n        for(auto it : words)\r\n            mp[it]++;\r\n        \r\n        for (int i=0;i<slen-(wlen*count)+1;i++){\r\n            string cur=s.substr(i,wlen*count);\r\n            map<string,int>tmp;\r\n            int j=0;\r\n            for (;j<cur.length();j+=wlen){\r\n                string word = cur.substr(j,wlen);\r\n                if (0 == mp.count(word))\r\n                    break;\r\n                tmp[word]++;\r\n                if(tmp[word] > mp[word]){\r\n                    break;\r\n                }\r\n            }\r\n            if(j == cur.length())\r\n                res.push_back(i);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107852290","body":"```c++\r\nint floorMod(const int& a, const int& b)\r\n{\r\n    return (a % b + b) % b;\r\n}\r\nint solve(vector<int>& nums, int k) {\r\n    int allSum = 0;\r\n    for (int& num : nums)\r\n        allSum += num;\r\n\r\n    allSum = floorMod(allSum, k);\r\n    unordered_map<int, int> dict;\r\n    dict[0] = -1;\r\n\r\n    int preSum = 0;\r\n    int minLen = nums.size();\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        preSum += nums[i];\r\n        int mod = floorMod(preSum, k);\r\n        dict[mod] = i;\r\n\r\n        if (dict.count(floorMod(preSum - allSum, k)))\r\n            minLen = min(minLen, i - dict[floorMod(preSum - allSum, k)]);\r\n    }\r\n    return minLen == nums.size() ? -1 : minLen;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108649209","body":"### 思路\r\n快慢指针，慢指针走一步，快指针两步\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* low = head;\r\n        ListNode* fast = head;\r\n        while(fast && fast->next){\r\n            low = low->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return low;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109858118","body":"### 思路\r\n使用双指针，一个读一个写。\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int len = nums.size();\r\n        if (len == 0) return len;\r\n        int low = 1,fast = 1;\r\n        while(fast < len){\r\n            if(nums[fast] != nums[fast-1]){\r\n                nums[low] = nums[fast];\r\n                low++;\r\n            }\r\n            fast++;\r\n        }\r\n        return low;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111049800","body":"### 思路\r\n二分法\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int left = 0;\r\n        int right = nums.size()-1;\r\n        while (left <= right)\r\n        {\r\n            int mid = (right - left)/2 + left;\r\n            if (nums[mid] == target) return mid;\r\n            if (nums[mid] < target){\r\n                left = mid + 1;\r\n            }else{\r\n                right = mid - 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112251096","body":"### 思路\r\n双端递减队列+双指针\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        int len = nums.size();\r\n        deque<int>q;\r\n         for (int i = 0; i < k; ++i) {\r\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n        }\r\n        vector<int> ans = {nums[q.front()]};\r\n        for (int i = k; i < len; ++i) {\r\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n            while (q.front() <= i - k) {\r\n                q.pop_front();\r\n            }\r\n            ans.push_back(nums[q.front()]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113096653","body":"### 思路\r\n入度为n-1出度为0的点是法官\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        if (trust.empty() && n == 1) return 1;\r\n        unordered_map<int,int>mp;\r\n        for (auto it : trust){\r\n            mp[it[0]]--;\r\n            mp[it[1]]++;\r\n        }\r\n        for (auto it : mp){\r\n            if (it.second == n-1)\r\n                return it.first;\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085584434","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n## 复杂度分析\n空间复杂度：O(N) 时间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566322","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        Stack<Integer> stack = new Stack<>();\n        int[] ans = new int[s.length()];\n        int pre = - 1;\n        for (int i = 0 ; i < s.length(); i ++) {\n            if (s.charAt(i) == c) {\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\n                    int p = stack.pop();\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\n                }\n                pre = i;\n            }\n            stack.push(i);\n        }\n        while (!stack.isEmpty()) {\n            int p = stack.pop();\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085594873","body":"```\r\nimport java.util.*;\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n      List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum =sum% 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(N) 时间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087227648","body":"```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n         String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = 10 * count + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            }\r\n            else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            }\r\n            else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder (resStack.pop());\r\n                int repeatTimes = countStack.pop();\r\n                for (int i = 0; i < repeatTimes; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            }\r\n            else {\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088300622","body":"```\r\nclass MyQueue {\r\n    private Stack<Integer> s1 = new Stack<>();\r\n    private Stack<Integer> s2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!s2.isEmpty()) {\r\n            s1.push(s2.pop());\r\n        }\r\n        s1.push(x);           \r\n    }\r\n    \r\n    public int pop() {   \r\n        while (!s1.isEmpty()) {\r\n       s2.push(s1.pop());\r\n       }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while(!s1.empty())\r\n       { s2.push(s1.pop());} \r\n        \r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s2.empty()&&s1.empty();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094034854","body":"参考官方题解\r\n```\r\nif(head == null) return null;\r\n      return dfs(head,null);\r\n  }\r\n  private TreeNode dfs(ListNode head, ListNode tail){\r\n      if(head == tail) return null;\r\n      ListNode fast = head, slow = head;\r\n      while(fast != tail && fast.next != tail){\r\n          fast = fast.next.next;\r\n          slow = slow.next;\r\n      }\r\n      TreeNode root = new TreeNode(slow.val);\r\n      root.left = dfs(head, slow);\r\n      root.right = dfs(slow.next, tail);\r\n      return root;\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095927550","body":"```\r\nclass LRUCache {\r\n    int cap;\r\n     LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\r\n    \r\n    private void makeRecently(int key) {\r\n        int val = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key, val);\r\n    }\r\n\r\n    public LRUCache(int capacity) {\r\n        this.cap = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!cache.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        makeRecently(key);\r\n        return cache.get(key);\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            // modify the old val\r\n            cache.put(key, value);\r\n            // promote to the recently (delete and add)\r\n            makeRecently(key);\r\n            return;\r\n        } else {\r\n            if (cache.size() >= cap) {\r\n                // delete the least used\r\n                int leastKey = cache.keySet().iterator().next();\r\n                cache.remove(leastKey);\r\n            }\r\n            cache.put(key, value);\r\n        }\r\n        \r\n    }\r\n}\r\n```\r\ntime complexity: O(1)\r\nspace complexity: O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101609189","body":"```\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        HashMap<Integer, Integer> map = new HashMap<Integer,Integer>();\r\n       for (int i = 0; i < nums.length; i++) {\r\n            \r\n            if(map.containsKey(target-nums[i]))\r\n                return new int[]{map.get(target - nums[i]), i};\r\n            map.put(nums[i], i);\r\n        }\r\n    return null;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103549745","body":"```\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        int[] result = new int[k];\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for (int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        Set<Map.Entry<Integer, Integer>> entries = map.entrySet();\r\n        // 根据map的value值正序排，相当于一个小顶堆\r\n        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());\r\n        for (Map.Entry<Integer, Integer> entry : entries) {\r\n            queue.offer(entry);\r\n            if (queue.size() > k) {\r\n                queue.poll();\r\n            }\r\n        }\r\n        for (int i = k - 1; i >= 0; i--) {\r\n            result[i] = queue.poll().getKey();\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110674970","body":"```\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int left = 0;\r\n        int right = nums.length-1;\r\n        int mid = 0;\r\n        while(left <= right){\r\n         mid = left + (right-left)/2;   \r\n            if(nums[mid] == target)\r\n                return mid;\r\n            if(nums[mid] < target)\r\n                left = mid + 1;\r\n            if(nums[mid] > target)\r\n                right = mid - 1;\r\n        }\r\n        if(nums[mid] < target)\r\n            return mid + 1;\r\n        else\r\n            return mid;\r\n    }\r\n}\r\n```\r\n时间复杂度： O(long)\r\n空间复杂度： O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wychmod":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085602602","body":"### 思路\n大体上是先将数组遍历一遍，将其转换为数字，然后与k相加，再将数字转换为数组\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = ''.join([str(n) for i, n in enumerate(num)])\n        sum = int(sum) + k\n        return [int(i) for i in str(sum)]\n```\n### 时间复杂度\n空间复杂度：O(n) 在将数字转换为数组的时候创建了数组\n\n时间复杂度：O(n) 遍历了有限次的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086544108","body":"### 思路\n（比较暴力）先把所有的e找出来下标放入数组中，然后将原数组的每一个点与所有e的下标对比取最小的那个。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        el = []\n        for i, n in enumerate(s):\n            if n == c:\n                el.append(i)\n        res = [0]*len(s)\n        for i in range(len(s)):\n            less = abs(i-el[0])\n            for j in el:\n                less = min(abs(i-j), less)\n            res[i] = less\n        return res\n```\n### 复杂度分析\n时间复杂度：O(n*目标字符在数组中出现的次数)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888495","body":"### 思路\n数组进行模拟，同时设置两个变量当前长度（不设也行）和最大长度，然后数组天生有pop函数\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = 0\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(self.length, k)\n        for i in range(k):\n            self.stack[i] += val\n```\n### 复杂度分析\n时间复杂度：push O1 popO1 incOk\n\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087070949","body":"### 思路\n使用栈来进行括号匹配，遇到右括号将数字字母弹出，然后形成字符串，然后重新入栈。\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = ''\n        for i in s:\n            if i == ']':\n                tmp = stack.pop()\n                sem = ''\n                while tmp != '[':\n                    sem = tmp + sem\n                    tmp = stack.pop()\n                \n                num = ''\n                while stack and stack[-1].isdigit():\n                     tmp = stack.pop()\n                     num = tmp + num\n\n                res = int(num) * sem\n                stack.append(res)\n                \n            else:\n                stack.append(i)\n\n        return ''.join(stack)\n```\n### 复杂度分析\n时间复杂度：On\n\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088196794","body":"### 思路\n两个栈来回倒\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        self.stack2 = self.stack1[::-1]\n        res = self.stack2.pop()\n        self.stack1 = self.stack2[::-1]\n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return True if len(self.stack1) == 0 else False\n```\n### 复杂度分析\n时间复杂度pop On 其他O1\n空间复杂度 On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089739793","body":"### 思路\n单调栈，融合栈，一开始有这个思路想不到这么实现，就想到左边比右边大的要放一块，可是出现了新的小的不知道怎么写，单调栈立马实现。\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and stack[-1] > i:\n                m = stack[-1]\n                while stack and stack[-1] > i:\n                    stack.pop()\n                stack.append(m)\n            else:\n                stack.append(i)\n        return len(stack)    \n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091031084","body":"### 思路\n先算出链表的长度n，然后将尾部与头部相连，然后走n-（k%n）步，将尾部断开，然后将断开的尾部当头返回。\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        pre = dummy = cur = ListNode(-1, head)\n        n = 0\n        while pre.next:\n            n += 1\n            pre = pre.next\n        pre.next = head\n        k = k%n\n        for _ in range(n-k):\n            dummy = dummy.next\n        cur.next = dummy.next\n        dummy.next = None\n        return cur.next\n\n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092392211","body":"### 思路\n每次将两个原地交换，遍历一次\n### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = pre = ListNode(-1, head)\n        while pre.next and pre.next.next:\n            tmp = pre.next.next\n            pre.next.next = tmp.next\n            tmp.next = pre.next\n            pre.next = tmp\n            pre = pre.next.next\n        return dummy.next\n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：O1（始终只有交换时产生了一个中间变量）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094058945","body":"### 思路\n找到每次中间的节点，然后断开链接，两边选中点，递归。\n### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def process(head):\n            if not head:\n                return head\n            if not head.next:\n                return TreeNode(head.val)\n            fast = slow = head\n            pre = None\n            while fast and fast.next:\n                fast = fast.next.next\n                pre = slow\n                slow = slow.next\n            pre.next = None\n            tree = TreeNode(slow.val)\n            tree.right = process(slow.next)\n            tree.left = process(head)\n            return tree\n        return process(head)\n```\n### 复杂度\n空间复杂度 Ologn\n时间复杂度 Onlogn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094158000","body":"### 思路\na和b在节点相交之前的路径长度是不一样的，只要让a和b都走相同长度，那么最后相同的就是交点。\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        a, b = headA, headB\n        while a!=b:\n            a = headB if a==None else a.next\n            b = headA if b== None else b.next\n        return a\n```\n### 复杂度分析\n时间复杂度 On\n空间复杂度 O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094485523","body":"### 思路\n快慢指针，当两个相遇时，说明有环，然后让其中一个指针回到起点，两个同样速度走，再次相遇就是那个节点。\n### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head or not head.next or not head.next.next:\n            return None\n        fast = head.next.next\n        slow = head.next\n        while slow != fast:\n            if not fast.next or not fast.next.next:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\n### 复杂度\n时间复杂度On\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096763708","body":"### 思路\n使用双向链表和哈希表来进行，get 用key在哈希表查，有就返回并移到链表开头,没有就创建，并放在链表开头。put 有就改值，移动到开头。没有就看是否满了，满了就删除然后加入新的，没满直接加。\n### 代码\n```python\nclass DLinkListNode:\n    def __init__(self, key=0, val=0, pre=None, next=None):\n        self.key = key\n        self.val = val\n        self.pre = pre\n        self.next = next\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.map = dict()\n        self.head = DLinkListNode(-1, -1)\n        self.tail = DLinkListNode(-1, -1)\n        self.cap = capacity\n        self.size = 0\n        self.head.next = self.tail\n        self.tail.pre = self.head\n\n\n    def get(self, key: int) -> int:\n        node = self.map.get(key, None)\n        if node:\n            node.next.pre = node.pre\n            node.pre.next = node.next\n            node.pre = self.head\n            self.head.next.pre = node\n            node.next = self.head.next\n            self.head.next = node\n            return node.val\n        else:\n            return -1\n\n\n\n    def put(self, key: int, value: int) -> None:\n        node = self.map.get(key, None)\n        if node:\n            node.val = value\n            node.next.pre = node.pre\n            node.pre.next = node.next\n\n            node.pre = self.head\n            self.head.next.pre = node\n            node.next = self.head.next\n            self.head.next = node\n\n        else:\n            if self.size == self.cap:\n                del_node = self.tail.pre\n                self.tail.pre = del_node.pre\n                del_node.pre.next = self.tail\n                self.map.pop(del_node.key)\n                del_node.pre = None\n                del_node.next = None\n                self.size -= 1\n\n            cur =  DLinkListNode(key, value)\n            cur.pre = self.head\n            self.head.next.pre = cur\n            cur.next = self.head.next\n            self.head.next = cur\n            self.map[key] = cur\n            self.size += 1\n```\n### 复杂度分析\n时间复杂度 O1\n空间复杂度 On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097531184","body":"### 思路\n递归遍历左右子树，返回深度。取max\n### 代码\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1\n```\n### 复杂度分析\n时间复杂度 On\n空间复杂度 Odeep","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098788574","body":"### 思路\n递归传入相同的节点\n### 代码\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def process(one, two):\n            if not one and not two:\n                return True\n            if not one or not two:\n                return False\n            if one.val == two.val:\n                left_same = process(one.left, two.left)\n                right_same = process(one.right, two.right)\n                return left_same and right_same\n            else:\n                return False\n\n        return process(p, q)\n```\n### 复杂度\n时间复杂度On\n空间复杂度Ologn / On 树平衡就是logn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099821580","body":"### 思路\n先序遍历，传递当前值。\n### 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = []\n        def process(root, num):\n            num = num*10+root.val\n            if not root.right and not root.left:\n                res.append(num)\n                return\n            if root.left:\n                process(root.left, num)\n            if root.right:\n                process(root.right, num)\n\n        process(root, 0)\n        return sum(res)\n```\n### 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100662137","body":"### 思路\ndfs 返回深度和值来判断\n### 代码\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n\n        def process(root):\n            if not root:\n                return 0, None\n            left_height, left_val = process(root.left)\n            right_height, right_val = process(root.right)\n\n            if left_height >= right_height:\n                val = left_val if left_val != None else root.val\n                return left_height+1, val\n            else:\n                val = right_val if right_val != None else root.val\n                return right_height+1, val\n        \n        height, val = process(root)\n        return val\n```\n### 复杂度\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100828716","body":"### 思路\n先序遍历\n### 代码\n```python\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        arr = []\n        def ser(root):\n            if root:\n                arr.append(root.val)\n                ser(root.left)\n                ser(root.right)\n            else:\n                arr.append(None)\n        ser(root)\n        return str(arr)\n\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        data_list = eval(data)\n        def des(data_l):\n            val = data_list.pop(0)\n            if val == None:\n                return None\n            root = TreeNode(int(val))\n            root.left = des(data_l)\n            root.right = des(data_list)\n            return root\n        return des(data_list)\n```\n### 复杂度\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101083195","body":"### 思路\ndict{dict{list[]}} 两个哈希表嵌套，底层是list实现，同时最后用排序dict来实现顺序 第一个键是col，第二个键是row\n### 代码\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        from collections import OrderedDict\n        dic = dict()\n        def process(root, row, col):\n            if not root:\n                return\n            dic_row = dic.get(col, dict())\n            arr = dic_row.get(row, [])\n            arr.append(root.val)\n            arr.sort()\n            dic_row[row] = arr\n            dic[col] = dic_row\n            process(root.left, row+1, col-1)\n            process(root.right, row+1, col+1)\n\n        process(root, 0, 0)\n        dic = collections.OrderedDict(sorted(dic.items(), key=lambda t: t[0]))\n        res = []\n        for key, value in dic.items():\n            arr = []\n            value = collections.OrderedDict(sorted(value.items(), key=lambda t: t[0]))\n            for i, val in value.items():\n                arr += val\n            res.append(arr)\n        return res\n```\n### 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101944946","body":"### 思路\n时间换空间，用哈希表记录选过的数字，如果当前数字可以和哈希表里的数字组成target就回返。\n### 代码\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dic = {}\n        for i, num in enumerate(nums):\n            if target-num in dic:\n                return [dic[target-nums[i]], i]\n            else:\n                dic[num] = i\n```\n### 复杂度\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103555781","body":"### 思路\n先使用dic储存数组中每个数的频次，然后将dic排序。\n### 代码\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for num in nums:\n            dic[num] = dic.get(num, 0) + 1\n\n        result = sorted(dic.items(), key=lambda x:x[1], reverse=True)\n        ans = []\n        for i in range(k):\n            ans.append(result[i][0])\n        return ans \n```\n### 复杂度分析\n时间复杂度 Onlogn （n为数组种类）\n空间复杂度 On（n为数组种类）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104699833","body":"### 思路\n暴力解法是三层循环遍历，用空间换时间，用哈希表，将距离都存进去，然后数量可以表示为当前距离有的数量n，n*（n-1），这样两层循环就ok了。\n### 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) < 3:\n            return 0\n        res = 0\n        for i in range(len(points)):\n            dic = {}\n            for j in range(len(points)):\n                if j == i:\n                    continue\n                dis = (points[j][0]-points[i][0])**2 + (points[j][1]-points[i][1])**2\n                dic[dis] = dic.get(dis, 0)+1\n            for val in dic.values():\n                res += val*(val-1)\n                \n\n        return res\n```\n### 复杂度\n时间复杂度On^2\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105955086","body":"### 思路\n哈希表+双指针 把每个元素的最后一个位置存在哈希表中，start 和 end指针不断的走，当遇到重复的则让start变成哈希表中的位置加一。\n### 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res = start = end = 0\n        n = len(s)\n        dic = dict()\n        while end < n:\n            i = dic.get(s[end], -1)\n            if i != -1:\n                start = max(i + 1, start)\n            dic[s[end]] = end\n            res = max(end - start + 1, res)\n            end += 1\n        return res\n```\n### 复杂度\n时间复杂度：On\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107519254","body":"### 思路\n两个哈希表来控制， 在遍历words数组填满第一个哈希表，在遍历字符串的过程中填满第二个哈希表，然后判断两个哈希表是否相等。\n### 代码\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n = len(words[0])\n        ans = []\n        dic = {}\n        for i, word in enumerate(words):\n            dic[word] = dic.get(word, 0) + 1\n\n        for i in range(len(s)-n*len(words)+1):\n            tmp = {}\n            for j in range(len(words)):\n                char = s[i + j * n:i + n + j * n]\n                if dic.get(char, -1) == -1:\n                    break\n                tmp[char] = tmp.get(char, 0) + 1\n                if tmp.get(char) > dic.get(char):\n                    break\n            if tmp == dic:\n                ans.append(i)\n        return ans\n```\n### 复杂度\n时间复杂度 On*m\n空间复杂度 Om","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107844580","body":"### 思路\n暴力解法超时。前置知识为前缀和和同余定理，运用(pres[j]-pres[i])%k = sum(nums)%k, i<k所以i可以放入哈希表中，类似于两数之和了。\n### 代码\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        s = sum(nums)\n        if s < p:\n            return -1\n        target = s % p\n        if target == 0:\n            return 0\n        dic = {0:-1}\n        pres = 0\n        ans = len(nums)\n        for i in range(len(nums)):\n            pres += nums[i]\n            cur = (pres-target)%p\n            if cur in dic:\n                ans = min(ans, i-dic[cur])\n            dic[pres%p] = i\n        return ans if ans != len(nums) else -1\n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108073834","body":"### 思路\n快慢指针走路，这个要求中间节点奇数为中间，偶数为后一个，注意好边界就行\n### 代码\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        fast = head.next\n        slow = head.next\n        while fast.next and fast.next.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n### 复杂度\n时间复杂度On\n空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109845949","body":"### 思路\n找不同的覆盖前index个位置。\n### 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        index = 1\n        for i in range(len(nums)):\n            if i > 0 and nums[i] != nums[i-1]:\n                nums[index] = nums[i]\n                index += 1\n        return index\n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110477291","body":"### 思路\n二分搜索\n### 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        L = 0\n        index = 0\n        R = len(nums) -1\n        if nums[len(nums) - 1] < target:\n            return len(nums)\n        while L <= R:\n            m = L + ((R-L) >>1)\n            if nums[m] >= target:\n                index = m\n                R = m-1\n            else:\n                L = m+1\n        return index\n```\n### 复杂度\n时间复杂度：Ologn\n空间复杂度：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112262542","body":"### 思路\n双端递减队列：假如一个新的数字进入窗口，当它大于的时候会弹出他前面小于的位置，当它小于的时候直接加入后面，这样在它前面因为出了窗口，这个相对较小的就变为最大的值。同时要保证队列里的数量不能超过k。\n### 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        que = collections.deque() \n        ans = []\n        for i in range(len(nums)):\n            while que and nums[que[-1]] < nums[i]:\n                que.pop()\n            while que and i-que[0] >= k:\n                que.popleft()\n            que.append(i)\n            if i+1>=k:\n                ans.append(nums[que[0]])\n        return ans\n```\n### 复杂度分析\n时间复杂度On\n空间复杂度Ok","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113331472","body":"### 思路\n创建一个哈希表，创建一个数组，哈希表记录每个人有没有被相信过，数组记录，那个人最被相信。之后找出被n-1相信过的人和这个人有没有相信过其他人。\n### 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if n == 1:\n            return 1\n        dic = {}\n        arr = [0] * (n+1)\n        for i in trust:\n            arr[i[1]] += 1\n            dic[i[0]] = 1\n        for i in range(len(arr)):\n            if arr[i] == n-1 and dic.get(i, 0) == 0:\n                return i\n        return -1\n\n```\n### 复杂度\n时间复杂度On\n空间复杂度On","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085608090","body":"\n### 题目：\n\n【Day 1】989. 数组形式的整数加法 \n\n[力扣地址：989](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路：\n\n用的 python 语言\n\n- 用 c 作为进位记录值，用当前的 num 作为结果数组\n- 当 num 和 k 都没有结束的时候，进行 num[i] + 个位数 + 进位值\n- 当 k 没有结束的时候，进行将 k 剩下的转为 数组进行想加\n- 当 num 没有结束的时候，将当前的 i 和进位值加起来然后前面数组保留\n- 当 进位值 还未归 0 的时候，将 进位值增加到 数组最前面\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0  #进位\n        i = len(num) - 1 #数组位置\n\n       # 当num没结束 and k 没结束\n        while(k and i > -1):\n            n = num[i] + (k % 10) + c \n            k //= 10\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1\n        \n        # 当 k 没有结束的时候\n        while(k): \n            num = [(k % 10 +c)%10] + num \n            c = (k % 10 +c) // 10   \n            k = k // 10 \n           \n        # 当 数组没有结束的时候\n        while(i > -1):\n            n = c + num[i]\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1  \n        # 当进位没有结束的时候\n        while(c):\n            num = [c] + num \n            c = 0\n\n        return num\n```\n\n\n\n### 时间复杂度：O（N）\n\n### 空间复杂度：O（N）\n\n反思：我可太笨了，思维不够缜密，最终还是写出垃圾冗长的代码，还得再学习一下...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665920","body":"### 题目：【Day 2】821. 字符的最短距离\n[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路1\n1. 新建列表存放字符 c 存在的位置\n2. 在 result 列表中，存放两次循环找出的最小 diff 距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        L = []\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                L.append(i)\n        for i in range(len(s)):\n            diff = 10000\n            for j in L:\n                if (abs(j - i)) < diff:\n                    diff = abs(j - i)\n            result.append(diff)\n        return result\n```\n### 复杂度\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n\n\n### 思路2\n1. 循环找到字符 c 存在的位置\n2. 前后循环找到最短的距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = [99999 for i in s]\n        n = len(s)\n        for i in range(n):\n            if s[i] != c:\n                continue\n            result[i] = 0\n            for j in range(i-1, -1, -1):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n            if i == n-1:\n                break\n            for j in range(i+1, n):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n        return result\n```\n\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086780406","body":"### 题目：【Day 3】1381. 设计一个支持增量操作的栈\n\n[1381.设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 思路：\n\n用列表模拟栈的操作\n\n### 代码：\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.L = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if(len(self.L)<self.maxSize):\n            self.L.append(x)\n\n    def pop(self) -> int:\n        if(len(self.L) > 0):\n            return self.L.pop(-1)\n        else:\n            return -1\n        \n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i >= len(self.L):\n                break\n            self.L[i] += val\n```\n\n### 复杂度\n\n时间复杂度：O(N)  主要是在 increment()中用了一次循环\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087676518","body":"### 394.字符串的解码\n\n[394.字符串的解码](https://leetcode-cn.com/problems/decode-string/)\n\n### 思路\n\n用栈来模拟，首先除了 ] 都全部入栈，遇到 ] ，查找直到 [ ，之间需要重复的字符串，然后进行重复，重复变量 k（此处有坑，数字不一定是个位数）。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        for i in s:\n            if i == ']':\n                # 重复的字符串\n                s = ''\n                # 重复变量\n                k = '' \n                while(res[-1] != '['):\n                    s = res.pop() + s\n                res.pop()\n                while(res and res[-1].isdigit()):\n                    k = res.pop() + k\n                res.append(int(k) * s) #此处有坑\n                continue\n            res.append(i)\n        return ''.join(res)\n     \n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N) 遍历一遍，但是里面重复次数的时间不太确定\n\n空间复杂度：O(N) 列表\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088738141","body":"### 232. 用栈实现队列\n\n[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n### 思路\n\n用列表模拟栈，再模拟队列\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.L = []\n\n    def push(self, x: int) -> None:\n        self.L.append(x)\n\n    def pop(self) -> int:\n        print(self.L)\n        return self.L.pop(0)\n\n    def peek(self) -> int:\n        return self.L[0]\n\n\n    def empty(self) -> bool:\n        if(len(self.L) == 0):\n            return True\n        else:\n            return False\n\n```\n\n\n\n### 复杂度\n\n时间：O(1)\n\n空间：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090390665","body":"### 题目 ： 768. 最多能完成排序的块 II\n\n#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n### 思路\n\n单调栈，单调增加栈\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = []\n        # 单调增栈\n        for i in arr:\n            if not res or i >= res[-1]:\n                res.append(i)\n            else:\n                max = res.pop()\n                while res and i< res[-1]:\n                    res.pop()\n                res.append(max)\n        return len(res)\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091836132","body":"### 题目： **【Day 7】61. 旋转链表** \n\n#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n### 思路\n\n1. 循环将最后一个节点和头节点连起来，顺便计算链表长度\n2. 计算边界值，k%长度，head为空和只有head一个节点\n3. 右边 l-k%l 长度后的节点断掉，头节点为下一个，返回头节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        p = head\n        l = 1\n        if not head or not head.next:\n            return head\n        while p.next:\n            l += 1\n            p = p.next\n        k %= l\n        if k == 0:\n            return head\n        p.next = head\n        for i in range(l - k):\n            p = p.next\n        head = p.next\n        #print(head.val)\n        p.next = None\n        return head\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092470808","body":"### 题目\n\n### 【Day 8】24. 两两交换链表中的节点 \n\n### 思路\n\n循环，每两个间隔的节点交换，使用递归，将子链递归，继续计算，直到节点为空或者只有一个节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        while not head or not head.next:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next\n```\n\n\n\n### 复杂度\n\n时间复杂度: O(N)\n\n空间复杂度: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094036432","body":"### 题目\n\n【Day 9】109. 有序链表转换二叉搜索树 \n\n[109. 有序链表转换二叉搜索树 ](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/submissions/)\n\n### 思路\n\n快慢指针\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294694","body":"### 题目\n\n【Day 10】160. 相交链表 \n\n[【Day 10】160. 相交链表 ](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n### 思路\n\n1. 判断是否相交\n\n如果两个链表相交，则最后一个结点一定 是共有的，可以分别遍历2个链表，记录其最后一个 结点和链表长度。\n\n若2个链表最后一个结点相等，则 相交，否则不相交。\n\n2. 找相交结点\n\n用指针pA指向较长的那个链表，pB指向 较短的那个链表，pA先向后移动|L1-L2|步，然后pA 和pB同时向后移动，每移动一步比较pA和pB是否相 等，当二者相等时，其指向的结点即为交点。\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        while not headA or not headB:\n            return None\n        pA = headA\n        countA = 1\n        pB = headB\n        countB = 1\n        while pA.next:\n            pA = pA.next\n            countA += 1\n        while pB.next:\n            pB = pB.next\n            countB += 1\n        if pB != pA:\n            return None\n        if countA >= countB:\n            pA = headA \n            pB = headB\n        else:\n            pA = headB\n            pB = headA\n        for i in range(abs(countB - countA)):\n            pA = pA.next\n        while pA != pB:\n            pA = pA.next\n            pB = pB.next\n        return pA\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095177939","body":"### 题目\n\n **【Day 11】142. 环形链表 II** \n\n[ **【Day 11】142. 环形链表 II** ]( [61. 旋转链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rotate-list/submissions/) )\n\n### 思路\n\n快慢指针\n\n1. 判断是否是环\n2. 找到入环的第一个节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n\n\n### 复杂度\n\n时间复杂度：O（N）\n\n空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096840066","body":"### 题目:**【Day 12】146. LRU 缓存机制** \r\n\r\n#### [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n### 思路\r\n\r\n本来用字典实现，但是无法解决怎么取最少用的node，因此参考了题解。\r\n\r\n双指针+字典\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def move_node_to_tail(self, key):\r\n            node = self.hashmap[key]\r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n            node.prev = self.tail.prev\r\n            node.next = self.tail\r\n            self.tail.prev.next = node\r\n            self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            self.hashmap[key].value = value\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                self.hashmap.pop(self.head.next.key)\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间复杂度： O(1)\r\n\r\n空间复杂度：O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097501088","body":"### 题目\n\n#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n### 思路\n\n递归，终止条件：root为None 循环体：分别计算左右子树的深度，最后算出深度\n\n\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left,right)+1\n        \n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098838519","body":"### 题目\n\n[【Day 14】100. 相同的树 ](https://leetcode-cn.com/problems/same-tree/)\n\n### 思路\n\n递归\n\n- 终止条件：当节点都不存在的时候就返回 true\n- 循环体：当节点存在并且 val 值一样，递归看左右节点是否相同\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if  p and  q and p.val == q.val:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n        else:\n            return False\n\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(logN) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100174243","body":"### 题目：\r\n\r\n129. 求根到叶子节点数字之和\r\n\r\n### 思路\r\n\r\nDFS\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        def dfs(root: TreeNode, prevTotal: int) -> int:\r\n            if not root:\r\n                return 0\r\n            total = prevTotal * 10 + root.val\r\n            if not root.left and not root.right:\r\n                return total\r\n            else:\r\n                return dfs(root.left, total) + dfs(root.right, total)\r\n\r\n        return dfs(root, 0) \r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100683634","body":"### 思路\r\n\r\nBFS\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        queue = [root]\r\n        ans = root.val\r\n        while queue:\r\n            ans = queue[0].val\r\n            n = len(queue)\r\n            for i in range(n):\r\n                node = queue[0]\r\n                del queue[0]\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n        return ans\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100828357","body":"```python \r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        def recur(root, ans):\r\n            if not root:\r\n                ans.append(\"N\")\r\n                return\r\n            ans.append(str(root.val))\r\n            recur(root.left, ans)\r\n            recur(root.right, ans)\r\n        ans =[]\r\n        recur(root, ans)\r\n        return \"/\".join(ans)\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data = data.split(\"/\")\r\n        data = data[::-1]\r\n        def recur(data):\r\n            popped = data.pop()\r\n            if popped == \"N\":\r\n                return None\r\n            node = TreeNode(popped)\r\n            node.left = recur(data)\r\n            node.right = recur(data)\r\n            return node\r\n        return recur(data)\r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n\r\n```\r\n\r\n时间复杂度 O(N)\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101466514","body":"### 思路\r\ndfs\r\n从根节点开始，对整棵树进行一次遍历，并在遍历过程中使用数组记录信息\r\n\r\n### 代码\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        \r\n        return ans\r\n```\r\n### 复杂度分析\r\n\r\n时间：O(nlogn)\r\n空间：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103912807","body":"### 思路\n\n字典排序\n\n### 代码\n\n```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        if len(nums) == 1:\n            return [k]\n        v1_dict = {}\n        for i in nums:\n            v1_dict[i] = v1_dict.get(i, 0) + 1\n        data = (sorted(v1_dict.items(), key = lambda x:x[1], reverse=True))[:k]\n        return [v[0] for v in data]\n\n\n```\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105271403","body":"### 思路\r\n\r\n暴力枚举\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for p in points:\r\n            cnt = defaultdict(int)\r\n            for q in points:\r\n                dis = (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2\r\n                cnt[dis] += 1\r\n            for m in cnt.values():\r\n                ans += m * (m - 1)\r\n        return ans\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度 O(N^2)\r\n\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106638616","body":"### 代码\r\n```python\r\n\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s: return 0\r\n        charFreq = defaultdict(int)\r\n        longestStrLen, left, right = 0, 0, 0\r\n        \r\n        while right < len(s):\r\n            ch = s[right]\r\n            charFreq[ch] += 1\r\n            \r\n            while charFreq[ch] > 1:\r\n                chRemoved = s[left]\r\n                charFreq[chRemoved] -= 1\r\n                left += 1\r\n                \r\n            longestStrLen = max(longestStrLen, right - left + 1)\r\n            right += 1\r\n        \r\n        return longestStrLen\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107858612","body":"```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        s = sum(nums)\r\n        if s%k==0:\r\n            return 0\r\n        dic = {0:-1}\r\n        mod = s%k\r\n        total = 0\r\n        ans = len(nums)\r\n        for i in range(len(nums)):\r\n            total += nums[i]\r\n            cur = total % k\r\n            target = (cur -mod +k)%k\r\n            if target in dic:\r\n                ans = min(ans, i - dic[target])\r\n            dic[cur] = i\r\n        return -1 if ans == len(nums) else ans\r\n```\r\nComplexity:\r\nTime: O(N)\r\nSpace: O(min(N, k))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109862991","body":"### 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        index = 1\n        for i in range(len(nums)):\n            if i > 0 and nums[i] != nums[i-1]:\n                nums[index] = nums[i]\n                index += 1\n        return index\n```\n### 复杂度分析\n\n时间复杂度：On\n空间复杂度：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111072126","body":"### 思路\n\n二分\n\n### 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(logn)\n- 空间复杂度: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113446716","body":"```python\r\ndef findJudge(self, N: int, trust: List[List[int]]) -> int:\r\n    \r\n    if len(trust) < N - 1:\r\n        return -1\r\n    \r\n    indegree = [0] * (N + 1)\r\n    outdegree = [0] * (N + 1)\r\n    \r\n    for a, b in trust:\r\n        outdegree[a] += 1\r\n        indegree[b] += 1\r\n        \r\n    for i in range(1, N + 1):\r\n        if indegree[i] == N - 1 and outdegree[i] == 0:\r\n            return i\r\n    return -1\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tensorstart":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085612304","body":"### 思路\n类似于第二题，按位倒叙相加，注意进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    res=[];\n    l=num.length;\n    for (let i = l-1; i >=0 ; i--) {\n        let pos_num=0;\n        pos_num=num[i]+k%10;\n        k=Math.floor(k/10);\n        if (pos_num>=10){\n            pos_num-=10;\n            k+=1;\n        }\n        res.push(pos_num);\n    }\n    while (k){\n        res.push(k%10);\n        k=Math.floor(k/10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n**复杂度分析**\n- 时间复杂度：$O(k,n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664861","body":"### 思路\n用的双指针循环部分有待优化\n### 代码\n\n\n```javascript\n\nvar shortestToChar = function(s, c) {\n    const res=[];\n    let l=0,r=0,pos=0;\n    let length=s.length;\n    for (let i = 0; i < length; i++) {\n        let array_abs=0;\n        l=r=pos=i;\n        for (let j = r; j < length; j++) {\n            if (s[j]===c) {\n                r=j;\n                break;\n            }\n        }\n        for (let j = l; j >=0 ; j--) {\n            if (s[j]===c){\n                l=j;\n                break;\n            }\n        }\n        if (s[l]===c && s[r]===c)\n            array_abs=Math.min(Math.abs(l-pos),Math.abs(r-pos));\n        else if (s[l]===c && s[r]!==c)\n            array_abs=Math.min(Math.abs(l-pos));\n        else\n            array_abs=Math.min(Math.abs(r-pos));\n        res.push(array_abs);\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N^2)$\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086892427","body":"### 思路\njs刚开始学，还是用的不好，java的思路写的\n### 代码\n\n\n```javascript\n/**\n * @param {number} maxSize\n */\nlet stack;//创建栈\nlet pos;//创建指针\nvar CustomStack = function(maxSize) {\n    stack=new Array(maxSize);\n    pos=-1;\n};\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (pos!==stack.length-1){\n        pos++;\n        stack[pos]=x;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (pos !== -1) {\n        let pos_value = stack[pos];\n        stack[pos] = undefined;\n        pos--;\n        return pos_value;\n    } else return -1;\n}\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if (k>pos+1){\n        for (let i = 0; i <=pos; i++) {\n            stack[i]+=val;\n        }\n    }else {\n        for (let i = 0; i < k; i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087454057","body":"### 思路\n使用栈往里存数，使用正则判断数字和字母是不是连续，遇到]弹出来做拼接，最后将栈里面的数据倒出来拼接\n\n### 代码\n\n\n```java（此处换成你的语言，比如js，py 等）\nclass Solution {\n    public static String decodeString(String s) {\n    String res = \"\";\n    Stack<String> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n    String middle = s.substring(i, i + 1);\n    if (middle.matches(\"[0-9]\")) {\n    String num = middle;\n    while (i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[0-9]\")) {//判断是不是个连续的数\n    num += s.substring(i + 1, i + 2);\n    i++;\n}\nstack.add(num);\n\n} else if (middle.matches(\"[a-z]\") || middle.equals(\"[\") || middle.matches(\"[A-Z]\")) {//使用正则表达式\n    if (middle.equals(\"[\"))\n        stack.add(middle);\n    else {\n        String ele = middle;\n        while (i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[a-z]\") ||\n        i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[A-Z]\")) {//判断是不是个连续的数\n            ele += s.substring(i + 1, i + 2);\n            i++;\n        }\n        stack.add(ele);\n    }\n\n} else if (middle.equals(\"]\")) {\n    String temp = \"\";//中间变量\n    while (!stack.peek().equals(\"[\"))\n        temp = stack.pop()+temp;\n    stack.pop();\n    int count = Integer.parseInt(stack.pop());\n    String mid = temp;\n    for (int j = 0; j < count - 1; j++) {\n        temp += mid;\n    }\n    stack.add(temp);\n\n}\n}\nwhile (!stack.empty()) { //最后把栈里的东西倒出来\n    String middle2 = \"\";\n    middle2 = stack.pop() + middle2;\n    res = middle2 + res;\n}\n\nreturn res;\n}\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N)$\n- 空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088741684","body":"## 思路\n使用两个栈，一个存，一个取\n## 代码\n```javascript\nvar MyQueue = function() {\n    this.in_stack=[];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.in_stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.out_stack=[];\n    while (this.in_stack.length>0){\n        this.out_stack.push(this.in_stack.pop());\n    }\n    for (let i = this.out_stack.length-2; i >-1; i--) {\n        this.in_stack.push(this.out_stack[i]);\n    }\n    return this.out_stack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.in_stack[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.in_stack.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n复杂度分析\n时间$O(n)$\n空间$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090368342","body":"\n## 思路 暴力解法\n没想出啥好方法来，只会暴力硬解\n根据排序块定义，排序块的左边部分的最大值要小于右边部分的最小值。\n## 代码\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\n//暴力\nvar maxChunksToSorted = function(arr) {\n    let length=arr.length;\n    let res=0;\n    let max_l=arr[0];\n    for (let i = 0; i < length; i++) {\n        max_l=Math.max(max_l,arr[i]);\n        let min_r=Infinity;\n        for (let j = i+1; j < length; j++) {\n            min_r=Math.min(arr[j],min_r);\n        }\n        if (max_l<=min_r){\n            res++;\n        }\n    }\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度$O(n^2)$\n空间复杂度$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091669179","body":"先打个卡\n## 思路\n暴力硬解，每次找到链表最后一个值，将这个值移到队首，k-1，判断k>0\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n    if (!head||!head.next) return head;\n    while (k) {\n        let temp=head.next;\n        let pre=head;\n        while (temp.next){\n            temp=temp.next;\n            pre=pre.next\n        }\n        temp.next=head;\n        pre.next=null;\n        head=temp;\n        k--;\n    }\n    return head;\n};\n```\n## 复杂度分析\n时间复杂度$O(n^2)$\n空间复杂度$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093016452","body":"## 思路\n分奇偶讨论，前后交换\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if (!head||!head.next) return head;\n    let length=1;\n    let temp=head;\n    while (temp.next){\n        length++;\n        temp=temp.next;\n    }\n    let rear=head;\n    let pre=head.next;\n    let times=Math.floor(length/2);\n    head=pre;\n    //长度为偶数\n    if (length%2===0){\n        while (times){\n            temp=pre.next\n            if (!pre.next){\n                pre.next=rear;\n                rear.next=null;\n                return head;\n            }else {\n                pre.next=rear;\n                rear.next=temp.next;\n            }\n            rear=temp;\n            pre=temp.next;\n            times--;\n        }\n    }else {\n        while (times){\n            temp=pre.next\n            if (!temp.next){\n                pre.next=rear;\n                rear.next=temp;\n                return head;\n            }else {\n                pre.next=rear;\n                rear.next=temp.next;\n            }\n            rear=temp;\n            pre=temp.next;\n            times--;\n        }\n    }\n};\n```\n## 复杂度分析\n时间复杂度$O(n)$\n空间复杂度$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094073606","body":"## 思路\n参考第108，先把链表的值拷贝到数组中，再对数组进行递归。\n##代码\n```javascript\nvar sortedListToBST = function(head) {\n    let arr=[];\n    let temp=head;\n    while (temp){\n        arr.push(temp.val);\n        temp=temp.next;\n    }\n    return dfs(0,arr.length-1,arr);\n};\nfunction dfs(l,r,arr){\n    //let mid=Math.floor(l+(r-l)/2);\n    let mid=parseInt(r+(l-r)/2);\n    if (l>r) return null;\n    let root=new TreeNode(arr[mid]);\n    root.left=dfs(l,mid-1,arr);\n    root.right=dfs(mid+1,r,arr);\n    return root;\n}\n```\n## 复杂度\n空间复杂度O{n}\n时间复杂度O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094279379","body":"## 思路\n将链表a或者链表b的值放到集合中，遍历另一个链表，检验集合中有没有这个结点\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let tempA=headA;\n    let set=new Set();\n    while (tempA){\n        set.add(tempA);\n        tempA=tempA.next;\n    }\n    let tempB=headB;\n    while (headB){\n        if (set.has(headB))\n            return headB;\n        headB=headB.next;\n    }\n    return null;\n};\n```\n# 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095096984","body":"## 思路\n哈希，遍历一遍链表，并将结果存入集合，如果集合中再次出现存入的集合，返回这个结点，否则返回空\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    if (!head||!head.next) return null;\n    let temp=head;\n    let set =new Set();\n    while (temp){\n        if (set.has(temp)){\n            return temp;\n        }\n        set.add(temp);\n        temp=temp.next;\n    }\n    return null;\n};\n```\n## 复杂度分析\n时间复杂度$O(n)$\n空间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096907887","body":"## 思路\n使用有序哈希表，存的时候判断是否有这个键。在操作了键之后将这个结点放到链表的最后面。添加结点如果超过了长度，就将第一个结点删除\n## 代码\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity=capacity;\n    this.map=new Map();\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map.has(key)){\n        this.remakemap(key);\n        return this.map.get(key);\n    }else return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)){\n        this.map.set(key,value);\n        this.remakemap(key);\n        return;\n    }\n    if (this.map.size<this.capacity) this.map.set(key,value);\n    else {\n        this.map.delete(this.map.keys().next().value);// Map.prototype.keys()返回一个iterator。一旦size超过限度，iterator.next()可以按照顺序获取到最早插入的key。\n        this.map.set(key,value);\n    }\n};\nLRUCache.prototype.remakemap=function (key){\n    let value=this.map.get(key);\n    this.map.delete(key);\n    this.map.set(key,value);\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```\n## 复杂度分析\n时间复杂度O(1)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098215732","body":"## 思路\ndfs遍历，每次传入当前所在的层和结点，回溯时deep--，进入新一层deep++，返回deep和max的较大值\n## 代码\n```javascript\nvar max=0;\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    let deep=0;\n    dfs(root,deep);\n    let res=max;\n     max=0;\n    return res;\n};\nvar dfs=function (root,deep){\n    deep++;\n    if (!root){\n        deep--;\n        return;\n    }\n    max=Math.max(deep,max);\n    dfs(root.left,deep);\n    dfs(root.right,deep);\n}\n```\n## 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099149153","body":"## 思路\ndfs，设置一个flag，如果两数左、右或者值不同，就置为false，如果flag为false，就连续退出递归\n## 代码\n```javascript\nvar flag=true;\nvar isSameTree = function(p, q) {\n    if (!p&&!q) return true;\n    dfs(p, q);\n    let res=flag;\n    flag=true\n    return res;\n};\nvar dfs=function (p,q){\n    if (flag===false) return false;\n    if (!p && q || !q && p) {\n        flag=false;\n        return ;\n    }\n    if (!p && !q) return ;\n    if (p.val===q.val){\n        dfs(p.left,q.left);\n        dfs(p.right,q.right);\n    }else {\n        flag=false;\n        return ;\n    }\n    return flag;\n};\n```\n复杂度分析\n时间复杂度O(longn)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100190567","body":"## 思路\ndfs\n## 代码\n```java\nclass Solution {\n    List<Integer> list=new ArrayList<>();\n    public int sumNumbers(TreeNode root) {\n        if (root==null) return 0;\n        int num=root.val;\n        int res=0;\n        leafnum(num, root);\n        for (Integer integer : list) {\n            res+=integer;\n        }\n        return res;\n    }\n    public void leafnum(int num,TreeNode node){\n        if (node.left==null&&node.right==null){\n            list.add(num);\n            num/=10;\n            return;\n        }\n        if (node.left!=null){\n            leafnum(num*10+node.left.val,node.left);\n        }\n        if (node.right!=null)\n            leafnum(num*10+node.right.val,node.right);\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100679226","body":"## 思路\nbfs，注意js数组的深拷贝\n## 代码\n```javascript\nvar findBottomLeftValue = function(root) {\n    let layerArr=[];\n    let lastArr=[];\n    layerArr.push(root);\n    while (layerArr.length){\n        let curLayer=layerArr.concat();\n        layerArr=[];\n        for (let i = 0; i < curLayer.length; i++) {\n            if (curLayer[i].left)\n                layerArr.push(curLayer[i].left);\n            if (curLayer[i].right)\n                layerArr.push(curLayer[i].right);\n        }\n        lastArr=curLayer;\n    }\n    return lastArr[0].val;\n};\n```\n## 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100874121","body":"## 思路\ndfs\n## 代码\n```javascript\nvar serialize = function(root) {\n    if(!root) return '#';\n    // 先序遍历\n    const value = root.val;\n    const leftValue = serialize(root.left);\n    const rightValue = serialize(root.right);\n    const str =  `${value},${leftValue},${rightValue}`;\n    return str;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    // 这个有一个小技巧，数组翻转一下，就不用再取数组最前面的一个值了，\n    // 翻转前执行1000ms+,翻转后100ms-\n    const dataArray = data.split(',').reverse();\n    const transform = (nodes) =>{\n        if(nodes.length === 0) return null;\n        const value = nodes.pop();\n        if(value === '#') return null;\n        let root = new TreeNode(parseInt(value));\n        root.left = transform(nodes);\n        root.right = transform(nodes);\n        return root;\n    };\n    return transform(dataArray);\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101520312","body":"## 思路\n先dfs遍历存储坐标数组，然后按照题目要求进行输出\n## 代码\n```javascript\nvar verticalTraversal = function(root) {\n    if (!root) return [];\n    let treenodeArr=[];\n    let dfs=function (root,x,y){\n        if (!root) return;\n        treenodeArr.push([x,y,root.val]);\n        dfs(root.left,x-1,y+1)\n        dfs(root.right,x+1,y+1);\n    };\n    dfs(root,0,0);\n    treenodeArr=treenodeArr.sort((a,b)=>{\n        if (a[0]!==b[0]) return a[0]-b[0];\n        else if (a[1]!==b[1]) return a[1]-b[1];\n        else return a[2]-b[2];\n    })\n\n    let curValOfX = treenodeArr[0][0]; \n    let res = [[treenodeArr[0][2]]];\n    for (let i = 1; i < treenodeArr.length; i++) {\n        let location = treenodeArr[i];\n        let x = location[0];\n        if (x === curValOfX) { \n            let last = res[res.length - 1];\n            last.push(location[2]);\n        } else { \n            res.push([location[2]]);\n        }\n    }\n\n    return res;\n\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102772688","body":"## 思路\n哈希，将数组以(值，下标)的格式存入哈希表，如果表中存在已经添加的key，说明有相同的元素，返回两者下标，遍历哈希，寻找匹配的元素\n## 代码\n```javascript\nvar twoSum = function(nums, target) {\n    let map=new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(target-nums[i])) return [map.get(target-nums[i]),i];\n        map.set(nums[i],i);\n    }\n    for(let entry of map){\n        if (map.has(target-entry.values()))\n            return [entry[0],map.get(target-entry.values())];\n    }\n};\n## 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103751027","body":"## 思路\n哈希表+sort\n## 代码\n```javascript\nvar topKFrequent = function(nums,k) {\n    let map=new Map;\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(nums[i])) {\n            let curValue=map.get(nums[i]);\n            map.set(nums[i],++curValue);\n        }else {\n            map.set(nums[i],1);\n        }\n    }\n    let mapArr=[];\n    for(let entry of map){\n        mapArr.push(entry)\n    }\n    mapArr=mapArr.sort((a,b)=>{\n        return b[1]-a[1];\n    })\n    let res=[];\n    for (let i = 0; i < k; i++) {\n        res.push(mapArr[i][0]);\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105367773","body":"## 思路\n用哈希表先固定点i，然后循环遍历j、k，检验是否有相等的距离，利用排列数计算结果\n## 代码\n```javascript\nvar numberOfBoomerangs = function(points) {\n    if (points.length<=1) return 0;\n    let res=0;\n    for (let i = 0; i < points.length; i++) {\n        let map = new Map();\n        for (let j = 0; j < points.length; j++) {\n            if (i===j) continue;\n            let key=getDistance(points[i],points[j]);\n            if (map.has(key)) map.set(key,map.get(key)+1);\n            else map.set(key,1);\n        }\n        for(let value of map.values()){\n            res+=value*(value-1);\n        }\n    }\n    return res;\n};\nvar getDistance=function (x,y){\n    let a=y[0]-x[0];\n    let b=y[1]-x[1];\n    return a*a+b*b;\n}\n```\n## 复杂度分析\n时间复杂度$O(n^2)$\n空间复杂度$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106413622","body":"## 思路\n滑动窗口\n## 代码\n```javascript\nvar lengthOfLongestSubstring = function(s) {\n    if (s.length<=1) return s.length;\n    let res=1;\n    let l=0,r=1;\n    while (r<s.length){\n        let win=s.slice(l,r);\n        if (win.includes(s[r])){\n            for (let i = l; i < r; i++) {\n                if (s[i]===s[r]){\n                    l=i+1;\n                    break;\n                }\n            }\n            r++;\n        }else {\n            r++;\n            res=Math.max(res,r-l);\n        }\n    }\n    return res;\n\n};\n```\n## 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107516561","body":"## 思路\n滑动窗口\n## 代码\n```javascript\nvar findSubstring = function(s, words) {\n    let left = 0,right = 0,wordsLen = words.length;\n    if(wordsLen == 0) return [];\n    let res = [];\n    let gapLen = words[0].length;\n    let needs = {};\n    let windows = {};\n    for(let i = 0;i < wordsLen;i++){\n        needs[words[i]] ? needs[words[i]]++ : needs[words[i]] = 1;\n    }\n    let needsLen = Object.keys(needs).length;\n    let match = 0;\n    for(let i = 0;i < gapLen;i++){\n        right = left = i;\n        match = 0;\n        while(right <= s.length - gapLen){\n            let c1 = s.substring(right,right + gapLen);\n            right += gapLen;\n            windows[c1] ? windows[c1]++ : windows[c1] = 1;\n            if(windows[c1] === needs[c1]){\n                ++match;\n            }\n            while(left < right && match == needsLen){\n                if(Math.floor((right - left) / gapLen) == wordsLen){\n                    res.push(left);\n                }\n                let c2 = s.substring(left,left + gapLen);\n                left += gapLen;\n                windows[c2]-- ;\n                if(needs[c2] && windows[c2] < needs[c2]){\n                    match--;\n                }\n            }\n        }\n        windows = {};\n    }\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108621341","body":"## 思路\n快慢指针\n## 代码\n```javascript\nvar middleNode = function(head) {\n    let pre=head,post=head;\n    while (post.next&&post.next.next){\n        pre=pre.next;\n        post=post.next.next\n    }\n    return !post.next?pre:pre.next;\n};\n```\n## 复杂度分析\n时间O(n)\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109915892","body":"## 思路\n快慢指针，相同就删了，不同一起前移\n## 代码\n```javascript\nvar removeDuplicates = function(nums) {\n    if (nums.length<2) return nums.length;\n    let l=0,r=1;\n    while (r<nums.length){\n        while (nums[l]===nums[r]){\n            nums.splice(r,1);\n        }\n        l++;\n        r++;\n    }\n    return nums.length;\n};\n```\n## 复杂度分析\n时间O(n)\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111071538","body":"## 思路\n二分法\n## 代码\n```javascript\nvar searchInsert = function(nums, target) {\n    let l=0,r=nums.length-1;\n    let mid;\n    while (l<=r){\n        mid=l+Math.floor((r-l)/2);\n        if (nums[mid]===target) return mid;\n        nums[mid]<target?l=mid+1:r=mid-1;\n\n    }\n    return l;\n};\n## 复杂度分析\n时间O(logn)\n空间O(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111829240","body":"## 思路\n最开始暴力勉强过了，看了题解用的双端队列，js嫌麻烦没有自己造轮子，直接用数组写的\n## 代码\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n    let l=0,r=0;\n    let queue=[];\n    let res=[];\n    while (r<nums.length){\n        //空队列直接push\n        if (queue.length===0) queue.push(nums[r]);\n        //否则比较\n        else {\n            //队尾大于待插入元素，将待插入元素放入队尾\n            if (queue[queue.length-1]>=nums[r]) queue.push(nums[r]);\n            //否则，循环判断弹出\n            else {\n                queue.pop();\n                while (queue.length){\n                    if (queue[queue.length-1]>=nums[r]){\n                        queue.push(nums[r]);\n                        break;\n                    }\n                    queue.pop();\n                }\n                //如果队列空了，就把nums[r]插入\n                if (queue.length===0) queue.push(nums[r]);\n            }\n\n        }\n        if (r-l+1===k){\n            nums[l]===queue[0]?res.push(queue.shift()):res.push(queue[0]);\n            r++;l++;\n\n        }else r++;\n    }\n    return res;\n};\n```\n## 复杂度分析\n时间O(n)\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113454098","body":"## 思路\n有向图，a->b，a为出度，b是入度，遍历trust进行出度入度统计，最后找入度为n-1出度为0的点\n## 代码\n```javascript\nvar findJudge = function(n, trust) {\n    let inDegree=new Array(n+1).fill(0);\n    let outDegree=new Array(n+1).fill(0);\n    for (let i = 0; i < trust.length; i++) {\n        inDegree[trust[i][1]]++;\n        outDegree[trust[i][0]]++;\n    }\n    for (let i = 1; i < n+1; i++) {\n        if (inDegree[i]===n-1&&outDegree[i]===0) return i;\n    }\n    return -1\n};\n```\n\n## 复杂度分析\n空间O(n)\n时间O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085682784","body":"## 思路\n按位求和，用flag保存进位，加到下一轮\n## 代码\n```js\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  let order = num.length - 1;\n  // 进位\n  let flag = 0;\n  while (order >= 0 || k != 0) {\n    let x = order >= 0 ? num[order] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    let sum = x + y + flag;\n    // 保存余数\n    res.push(sum % 10);\n    flag = Math.floor(sum / 10);\n    k = Math.floor(k / 10);\n    order--;\n  }\n  if (flag) res.push(flag);\n  return res.reverse();\n};\n```\n## 复杂度\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665965","body":"## 思路\r\n中心扩展\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    const res=Array(s.length).fill(0);\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i]===c) continue\r\n        let l=i,r=i,shortest=Infinity;\r\n        while (l>=0){\r\n            if(s[l]===c){\r\n                shortest=Math.min(shortest,i-l)\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest=Math.min(shortest,r-i);\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res\r\n};\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086823118","body":"## 思路\r\n\r\n直接按着题意即可。\r\n\r\n## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.stack = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length === this.maxSize) {\r\n    return null;\r\n  }\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  var x = this.stack.pop();\r\n  return x === undefined ? -1 : x;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.stack.length; i++) {\r\n    this.stack[i] = this.stack[i] + val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087098004","body":"## 思路 \n维护一个栈，遍历判断\n## 代码\n```js\n// 维护一个栈\nvar decodeString = function (s) {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] != \"]\") {\n      stack.push(s[i]);\n      continue;\n    }\n    let str = \"\";\n    let cur = stack.pop();\n    while (cur != \"[\") {\n      // 加在当前的后面\n      str = cur + str;\n      cur = stack.pop();\n    }\n    let num = \"\";\n    // 排除 \"[\"\n    cur = stack.pop();\n    // 对于数字\n    while (!isNaN(cur)) {\n      // 字符串相加\n      num = cur + num;\n      cur = stack.pop();\n    }\n    // 字母 或者 \"[\"\n    stack.push(cur);\n    stack.push(str.repeat(num));\n  }\n  return stack.join(\"\");\n};\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087800339","body":"## 思路\nrust 双栈实现队列\n## 代码\n```rust\nstruct MyQueue {\n    input: Vec<i32>,\n    output: Vec<i32>,\n}\n\n\nimpl MyQueue {\n\n    fn new() -> Self {\n        Self {\n            input: vec![],\n            output: vec![],\n        }\n    }\n    \n    fn push(&mut self, x: i32) {\n        self.input.push(x);\n    }\n    \n    fn pop(&mut self) -> i32 {\n        self.peek();\n        self.output.pop().unwrap()\n    }\n    \n    fn peek(&mut self) -> i32 {\n        if self.output.is_empty() {\n            while self.input.len() > 0 {\n                self.output.push(self.input.pop().unwrap());\n            }\n\n        }\n        self.output.last().cloned().unwrap()\n    }\n    \n    fn empty(&mut self) -> bool {\n        self.input.is_empty() && self.output.is_empty()\n    }\n}\n```\n## 复杂度\npush ：\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n\npop ：\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n\npeek：\n- 时间复杂度：最好的情况O(1) 最坏的情况O(n)\n- 空间复杂度：O(1)\n\nempty：\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089877763","body":"## 思路\n\n前缀和\n\n## 代码\n```rust\nimpl Solution {\n    pub fn max_chunks_to_sorted(arr: Vec<i32>) -> i32 {\n        let mut sum1 = 0;\n        let mut sum2 = 0;\n        let mut ans = 0;\n        let mut arr_sorted = arr.to_vec();\n        arr_sorted.sort();\n        for i in 0..arr.len(){\n            sum1 = sum1 + arr[i];\n            sum2 = sum2 + arr_sorted[i];\n            if sum1 == sum2 {\n                ans +=1;\n                sum1 = 0;\n                sum2 = 0;\n            }\n        }\n        ans\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091049318","body":"## 思路\nrust 实现，每个节点向右移动 k%n个位置\n## 代码\n\n```rust\nimpl Solution {\n    pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        let mut v: Vec<i32> = Vec::new();\n        let mut node = &head;\n        // 获取总长度\n        while let Some(n) = node {\n            v.push(n.val);\n            node = &n.next;\n        }\n        // 缓存新链表\n        let mut answer = None;\n        // 构建链表\n        for i in (0..v.len()).rev() {\n            let j = k as usize % v.len();\n            answer = Some(Box::new(ListNode {\n                val: v[(v.len() + i - j) % v.len()],\n                next: answer,\n            }))\n        }\n        answer\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092422509","body":"## 思路\n\nrust写链表题很不方便，同一时刻，只能拥有一个可变引用，所以下面的代码没办法编译通过：\n```rust\nlet mut prev = head;\nlet mut current = prev.next.unwrap();\n```\n所以需要利用take() 取出Option<T>后在原来位置放入None来“打断”链表，这样就能获得两个拥有所有权的变量，一个是前面部分，一个是后面部分\n\n## 代码\n\n```rust\nimpl Solution {\n  pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n    let mut list = ListNode::new(0);\n    let mut tail = &mut list.next;\n    let mut temp = None;\n    while let Some(mut node) = head.take() {\n        head = node.next.take();\n        \n        match temp.take() {\n            None => temp = Some(node),\n            Some(temp) => {\n                node.next = Some(temp);\n                *tail = Some(node);\n                tail = &mut tail.as_mut().unwrap().next.as_mut().unwrap().next;\n            }\n        }\n    }\n    *tail = temp;\n    list.next.take()\n  }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093697673","body":"## 思路\n\nrust版本，递归数组，取中间节点，构建bst\n\n## 代码\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn sorted_list_to_bst(mut head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut stack = Vec::new();\n        // 收集链表节点值\n        while let Some(node) = head {\n            stack.push(node.val);\n            head = node.next;\n        }\n        Solution::s(&stack[..])\n    }\n    pub fn s(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut n = nums.len();\n        if n == 0 {\n            return None;\n        }\n        let mid = n / 2;\n        let mut node = TreeNode::new(nums[mid]);\n        // 递归创建左子树\n        node.left = Solution::s(&nums[..mid]);\n        // 递归创建右子树\n        node.right = Solution::s(&nums[mid + 1..]);\n        Some(Rc::new(RefCell::new(node)))\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094252581","body":"## 思路\n\n双指针，两个指针的遍历总长度是一样的\n\n## 代码\n```js\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a !== b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n```\n## 复杂度\n- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次\n- 空间复杂度：0(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094587731","body":"## 思路\n\n快慢指针，slow走1步，fast走2步，假设最终相遇slow走了k步，则fast走了2k步，从head到入环点是k-m，从入环点到相遇点是m，所以fast从相遇点再到入环点走了k-m\n\n## 代码\n```js\nvar detectCycle = function (head) {\n  let slow = head;\n  let fast = head;\n  while (fast) {\n    if (fast.next == null) {\n      // fast.next走出链表了，说明无环\n      return null;\n    }\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow == fast) {\n      fast = head;\n      while (true) {\n        if (slow == fast) {\n          return slow;\n        }\n        slow = slow.next;\n        fast = fast.next;\n      }\n    }\n  }\n  return null;\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096141759","body":"## 思路\n\n利用Map来做，新的k-v放到末尾，头部就是最近最久使用的值，可以利用map.keys()拿到头部的k\n\n## 代码\n\n```js\nvar LRUCache = function (capacity) {\n  this.capacity = capacity;\n  this.map = new Map();\n};\n\nLRUCache.prototype.get = function (key) {\n  if (this.map.has(key)) {\n    const temp = this.map.get(key);\n    this.map.delete(key);\n    this.map.set(key, temp);\n    return temp;\n  }\n  return -1;\n};\n\nLRUCache.prototype.put = function (key, value) {\n  if (this.map.has(key)) this.map.delete(key);\n  this.map.set(key, value);\n  if (this.map.size > this.capacity) {\n    this.map.delete(this.map.keys().next().value);\n  }\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097993570","body":"## 思路\n\nDFS 和 BFS\n\n## 代码\n\n```js\nvar maxDepth = function (root) {\n  if (!root) return 0;\n  const queue = [root];\n  let depth = 1;\n  while (queue.length) {\n    let len = queue.length;\n    for (let i = 0; i < len; i++) {\n      const top = queue.shift();\n      if (top.left) {\n        queue.push(top.left);\n      }\n      if (top.right) {\n        queue.push(top.right);\n      }\n    }\n    queue.length && depth++;\n  }\n  return depth;\n};\n```\n\n## 复杂度\n\n对于 dfs：\n\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次\n- 空间复杂度：O(maxHeight)，其中 maxHeight 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度\n\n对于 bfs：\n\n- 时间复杂度：O(n)，其中 n 为二叉树的节点个数。每个节点只会被访问一次\n- 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)\n\n## rust 版本\n\n```rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::cmp::max;\nimpl Solution {\n    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut max_val = 0;\n\n        if let Some(node) = root {\n            let left = 1 + Solution::max_depth(node.borrow_mut().left.take());\n            let right = 1 + Solution::max_depth(node.borrow_mut().right.take());\n\n            max_val = max(left, right);\n        }\n\n        max_val\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098694727","body":"## 思路\n\ndfs\n\n## 代码\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn is_same_tree(\n        p: Option<Rc<RefCell<TreeNode>>>,\n        q: Option<Rc<RefCell<TreeNode>>>,\n    ) -> bool {\n        Solution::is_same_tree_impl(&p, &q)\n    }\n    pub fn is_same_tree_impl(\n        p: &Option<Rc<RefCell<TreeNode>>>,\n        q: &Option<Rc<RefCell<TreeNode>>>,\n    ) -> bool {\n        if p.is_none() && q.is_none() {\n            return true;\n        }\n        if p.is_none() || q.is_none() {\n            return false;\n        }\n        let a: &TreeNode = &p.as_ref().unwrap().borrow();\n        let b: &TreeNode = &q.as_ref().unwrap().borrow();\n\n        if a.val != b.val {\n            return false;\n        }\n        Solution::is_same_tree_impl(&a.left, &b.left)\n            && Solution::is_same_tree_impl(&a.right, &b.right)\n    }\n}\n```\n\n## 复杂度\n\nm 和 n 分别是两个二叉树的节点数\n\n- 时间复杂度：O(min(m,n))\n- 空间复杂度：O(min(m,n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099995147","body":"## 思路\n\nDFS\n\n## 代码\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut res = 0;\n        let mut stack = vec![(root, 0)];\n\n        while let Some(node_sum) = stack.pop() {\n            if let Some(node) = node_sum.0 {\n                let node = node.borrow();\n                let cur_sum = 10 * node_sum.1 + node.val;\n\n                if node.left.is_none() && node.right.is_none() {\n                    res += cur_sum;\n                    continue;\n                }\n\n                stack.push((node.left.clone(), cur_sum));\n                stack.push((node.right.clone(), cur_sum));\n            }\n        }\n        res\n    }\n}\n```\n\n## 复杂度\n\nn是节点的个数\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100636551","body":"## 思路\n\nbfs\n\n## 代码\n\n```js\nvar findBottomLeftValue = function (root) {\n  if (!root) return null;\n  const queue = [root];\n  let Left;\n  while (queue.length) {\n    let curLevel = queue.length;\n    Left = queue[0];\n    for (let i = 0; i < curLevel; i++) {\n      let curNode = queue.shift();\n\n      curNode.left && queue.push(curNode.left);\n      curNode.right && queue.push(curNode.right);\n    }\n  }\n  return Left.val;\n};\n```\n\n## 复杂度\n- 时间复杂度：O(n)，节点个数，对每个节点访问一次\n- 空间复杂度：O(max_size)，层最大宽度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100853450","body":"## 思路\n\ndfs\n\n## 代码\n```js\nvar serialize = function (root) {\n  if (root == null) {\n    return \"X\";\n  }\n  let left = serialize(root.left);\n  let right = serialize(root.right);\n  return root.val + \",\" + left + \",\" + right;\n};\n\nvar deserialize = function (data) {\n  const arr = data.split(\",\");\n  const builtTree = (node) => {\n    let front = arr.shift();\n    if (front == \"X\") {\n      return null;\n    }\n    let root = new TreeNode(front);\n    root.left = builtTree(root);\n    root.right = builtTree(root);\n    return root;\n  };\n  return builtTree(arr);\n};\n```\n## 复杂度\n\nn为节点的数量\n- 时间复杂度：O(n)，每个节点访问一次\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101418185","body":"## 思路\n\n这个题的重点在于排序，观察题目可知，坐标反映的是 `(depth,order)`，我们需要对 order 升序，order 一样的（是一组）按 depth 升序，depth 一样的按 `node.val` 升序\n\n## 代码\n\n```js\n// 坐标是 (depth,order)\nvar verticalTraversal = function (root) {\n  if (!root) return [];\n  let queue = [[root, 0, 0]];\n  // map缓存的是 order, [[node, depth],[node, depth]]\n  let map = new Map();\n  let min = Infinity;\n  let max = -Infinity;\n  let finalArr = [];\n  while (queue.length > 0) {\n    let first = queue.pop();\n    let node = first[0];\n    let order = first[2];\n    let depth = first[1];\n    min = Math.min(order, min);\n    max = Math.max(order, max);\n    if (map.has(order)) {\n      let arr = map.get(order);\n      arr.push([node, depth]);\n      map.set(order, arr);\n    } else {\n      map.set(order, [[node, depth]]);\n    }\n    if (node.left) {\n      queue.unshift([node.left, depth + 1, order - 1]);\n    }\n    if (node.right) {\n      queue.unshift([node.right, depth + 1, order + 1]);\n    }\n  }\n  for (let i = min; i <= max; i++) {\n    let arr = map.get(i);\n    arr.sort((a, b) => {\n      // 如果depth相同，就按照 node.val 升序排列\n      if (a[1] === b[1]) {\n        return a[0].val - b[0].val;\n      }\n      // 否则就按着 depth 升序排列\n      return a[1] - b[1];\n    });\n    // 我们最后要缓存的只是 node.val\n    arr = arr.map((elem) => elem[0].val);\n    finalArr.push(arr);\n  }\n  return finalArr;\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(nlogn) 考虑到sort操作 O(n) < O(nlogn) \n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102065805","body":"## 思路\n\n- 暴力 （后面可以优化成 排序+双指针 时间复杂度就是O(nlogn)）\n- HashMap\n\n## 代码\n\n```rust\n// 暴力\nimpl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let len = nums.len();\n        for i in 0..len {\n            let mut left = i;\n            let mut right = len - 1;\n            while left < right {\n                if nums[left] + nums[right] == target {\n                    return vec![left as i32, right as i32];\n                }\n                right = right - 1;\n            }\n        }\n        Vec::new()\n    }\n}\n\n// hashmap\nuse std::collections::HashMap;\n\nimpl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut map = HashMap::new();\n\n        for i in 0..nums.len() {\n            if let Some(val) = map.get(&(target - nums[i])) {\n                if i != *val {\n                    return vec![i as i32, *val as i32];\n                }\n            }\n            map.insert(nums[i], i);\n        }\n        Vec::new()\n    }\n}\n```\n\n## 复杂度\n\n暴力解法：\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n\nHashMap解法：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104803822","body":"## 思路\r\n\r\nhashmap\r\n\r\n## 代码\r\n\r\n```rust\r\nuse std::collections::HashMap;\r\n\r\nimpl Solution {\r\n    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\r\n        let mut map = HashMap::new();\r\n        for num in nums {\r\n            *map.entry(num).or_insert(0) += 1;\r\n        }\r\n        let mut vec: Vec<(i32, i32)> = map.into_iter().collect();\r\n        vec.sort_by(|(_, x), (_, y)| y.cmp(x));\r\n        let mut res = vec![];\r\n        for index in 0..k as usize {\r\n            res.push(vec[index].0);\r\n        }\r\n        res\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104958891","body":"## 思路\r\n\r\nRust 和 JS\r\n\r\nhashmap，对每一个点，求剩下的点到该点的距离，缓存距离，缓存距离会作为边，有两个及以上相同的，就可以作为一个回旋镖，求其组合数就是从该点出发构成的回旋镖数\r\n\r\n## 代码\r\n\r\n```js\r\nvar numberOfBoomerangs = function (points) {\r\n  let count = 0;\r\n  function calcDist(a, b) {\r\n    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2;\r\n  }\r\n  for (let i = 0; i < points.length; i++) {\r\n    const map = {};\r\n    for (let j = 0; j < points.length; j++) {\r\n      if (points[i] != points[j]) {\r\n        let dist = calcDist(points[i], points[j]);\r\n        map[dist] = (map[dist] || 0) + 1;\r\n      }\r\n    }\r\n    for (let d in map) {\r\n      let num = map[d];\r\n      if (num > 1) {\r\n        count += num * (num - 1);\r\n      }\r\n    }\r\n  }\r\n  return count;\r\n};\r\n```\r\n\r\n```rust\r\nuse std::collections::HashMap;\r\n\r\nimpl Solution {\r\n    pub fn calaDist(x: &Vec<i32>, y: &Vec<i32>) -> i32 {\r\n        let distx = x[0] - y[0];\r\n        let disty = x[1] - y[1];\r\n        distx * distx + disty * disty\r\n    }\r\n    pub fn number_of_boomerangs(points: Vec<Vec<i32>>) -> i32 {\r\n        let mut count: i32 = 0;\r\n        for (i, ival) in points.iter().enumerate() {\r\n            let mut map = HashMap::new();\r\n            for (j, jval) in points.iter().enumerate() {\r\n                if i == j {\r\n                    continue;\r\n                }\r\n                let dist = Self::calaDist(ival, jval);\r\n                *map.entry(dist).or_insert(0) += 1;\r\n            }\r\n            for (_, num) in map.iter() {\r\n                if *num > 1 {\r\n                    count += num * (num - 1);\r\n                }\r\n            }\r\n        }\r\n        count\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106559943","body":"## 思路\n滑动窗口\n## 代码\n```js\nvar lengthOfLongestSubstring = function (s) {\n  let l = 0;\n  let res = 0;\n  const map = new Map();\n  for (let j = 0; j < s.length; j++) {\n    // map.get(s[j]) >= l 保证重复元素在区间里\n    if (map.has(s[j]) && map.get(s[j]) >= l) {\n      // 以重复位置+1作为左边界\n      l = map.get(s[j]) + 1;\n    }\n    res = Math.max(res, j - l + 1);\n    map.set(s[j], j);\n  }\n  return res;\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107452548","body":"## 思路\n\n计算 words 段的总长度，根据 words 维护 hash 表，需要在目标 string 里按着 words 总长度去遍历子串，判断子串里是否存在 hash 表的字段，若存在，hash 表中对应字段值减 1，直到对应字段值为 0，表示该字段已经用完；若不存在，则放弃该子串，右移遍历下一个子串\n\n## 代码\n\n```js\nvar findSubstring = function (s, words) {\n  const wordSize = words[0].length;\n  const substringLen = wordSize * words.length;\n\n  const wordsCount = {};\n  words.forEach((w) => (wordsCount[w] = (wordsCount[w] || 0) + 1));\n\n  const res = [];\n  for (let i = 0; i <= s.length - substringLen; i++) {\n    const tempCount = { ...wordsCount };\n    let count = words.length;\n\n    for (let j = i; j < i + substringLen; j += wordSize) {\n      const word = s.slice(j, j + wordSize);\n\n      if (!(word in tempCount) || tempCount[word] <= 0) break;\n\n      tempCount[word]--;\n      count--;\n    }\n\n    if (count === 0) res.push(i);\n  }\n  return res;\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(mn)，m 是字符串的长度，n 是数组的长度\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107846738","body":"## 思路\n\n`前缀和+hashtable`\n\n根据同余定理，我们要找一个子区间，该子区间满足 `subSum%p = mod = sum%p`，这样除去该子区间剩下的 arrSum 就可以整除 p\n\n`subSum = preSum[j]-preSub[i]` 满足 `preSum[j]%p - preSum[i]%p = mod`\n\n维护一个 hash 表，记录 `preSum[i]%p` 和 `i`，这样根据之后的 `preSum[j]%p - mod` 就可以找到 subSum 也就是 j-i\n\n- 有一个特殊情况 `preSub[i]%p = 0`，这时 `(preSum[i]%p - mod + p)%p = mod`，区间长度` i-(-1)=i+1 = 0`，放一个哨兵节点 `(0,-1)` 方便直接求区间长度\n\n## 代码\n\n```js\nvar minSubarray = function (nums, p) {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  let mod = sum % p;\n  if (mod == 0) {\n    return 0;\n  }\n  const map = new Map();\n  let preSum = 0;\n  let res = Infinity;\n  map.set(0, -1);\n  for (let i = 0; i < nums.length; i++) {\n    preSum += nums[i];\n    // 考虑到可能当前的preSum%p小于mod 所以 +p 之后再取余数\n    if (map.has(((preSum % p) - mod + p) % p)) {\n      res = Math.min(res, i - map.get(((preSum % p) - mod + p) % p));\n    }\n    map.set(preSum % p, i);\n  }\n  res >= nums.length && (res = Infinity);\n  return res == Infinity ? -1 : res;\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108671404","body":"## 思路\n\n快慢指针\n\n## 代码\n\n```js\n// 快慢指针\nvar middleNode = function (head) {\n  let dummy = new ListNode(0);\n  dummy.next = head;\n  let slow = dummy,\n    fast = dummy;\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  // 对于偶数个，中间节点有两个，返回靠后的节点\n  return fast == null ? slow : slow.next;\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n)，链表中的节点数目\n- 空间复杂度：O(1)，只需要常数空间存放 slow 和 fast 两个指针\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110979135","body":"## 思路\r\n\r\n二分法\r\n\r\n## 代码\r\n\r\n```js\r\nvar searchInsert = function (nums, target) {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n  while (left <= right) {\r\n    let mid = (left + right) >>> 1;\r\n    if (nums[mid] === target) {\r\n      return mid;\r\n    }\r\n    if (nums[mid] < target) {\r\n      left = mid + 1;\r\n    }\r\n    if (nums[mid] > target) {\r\n      right = mid - 1;\r\n    }\r\n  }\r\n  return left;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111867429","body":"## 思路\n\n- 单调递减队列\n- 利用单调队列存下标， 头部是区间最大值 max 对应的下标\n- 根据当前下标对应值的大小，把当前下标放到队列合适的位置\n- 只要构成了滑动窗口，就可以把队列最大值（头部）对应的值 放到结果数组中\n\n## 代码\n\n```js\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const queue = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (i - queue[0] >= k) queue.shift();\n    while (nums[queue[queue.length - 1]] <= nums[i]) {\n      queue.pop();\n    }\n    queue.push(i);\n    if (i >= k - 1) {\n      res.push(nums[queue[0]]);\n    }\n  }\n  return res;\n};\n```\n\n## 复杂度\n\n- 时间复杂度：O(n)，n 是 nums 的长度，每个元素入队一次\n- 空间复杂度：O(k)，定义了一个辅助队列 queue，最多存放 k 大小的元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113207200","body":"## 思路\n\n图，n 个节点，求其他节点都入度，但是该节点不出度\n\n## 代码\n\n```rust\nimpl Solution {\n    pub fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {\n        let n = n as usize;\n        let mut trusted = vec![0; n + 1];\n        let mut trusts = vec![0; n + 1];\n\n        for pair in trust {\n            let (a, b) = (pair[0] as usize, pair[1] as usize);\n            trusts[a] += 1;\n            trusted[b] += 1;\n        }\n\n        for i in 1..n + 1 {\n            if trusts[i] == 0 && trusted[i] == n - 1 {\n                return i as i32;\n            }\n        }\n\n        -1\n    }\n}\n```\n\n## 复杂度\n\n- 时间复杂度：O(n+m)，其中 mm 是 trust 的长度。首先需要遍历 trust 计算出 inDegrees 和 outDegrees，然后需要遍历 inDegrees 和 outDegrees 来确定法官\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m908":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085689040","body":"### 思路\n从后往前遍历数组，按位与K相加\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        for(int i = num.size() - 1; i >= 0; i--)\n        {\n            int curNumber = num[i] + k % 10;\n            k /= 10;\n            if(curNumber >= 10)\n            {\n                curNumber -= 10;\n                k += 1;\n            }\n            result.push_back(curNumber);\n        }\n        \n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597840","body":"### 思路\r\n\r\n先保存目标字符出现的所有位置，逐个与字符串比对距离\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> result(s.size());\r\n        vector<int> targetChars;\r\n\r\n        for(int i = 0; i < s.size(); i++)\r\n        {\r\n            if(s[i] == c)\r\n                targetChars.push_back(i);\r\n        }\r\n\r\n        for(int i=0; i < result.size(); i++)\r\n        {\r\n            int minDistance = INT_MAX;\r\n            for(int j=0; j < targetChars.size(); j++)\r\n            {\r\n                if(minDistance > abs(i - targetChars[j]))\r\n                    minDistance = abs(i - targetChars[j]);\r\n            }\r\n            result[i] = minDistance;\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：O(m * n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086887598","body":"```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        mMaxSize=maxSize;\n    }\n    \n    void push(int x) {\n        if(mNumbers.size()<mMaxSize)\n        {\n            mNumbers.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(!mNumbers.empty())\n        {\n        int result=mNumbers.back();\n        mNumbers.pop_back();\n        return result;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(mNumbers.size()<k)\n        {\n            for(int i=0;i<mNumbers.size();i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i=0;i<k;i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n    }\n    \nprivate:\n    vector<int> mNumbers;\n    int mMaxSize;     \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087651573","body":"```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string result;\n        int num;\n        stack<int> numbers;\n        stack<string> strs; \n        for(int i=0;i<s.size();i++)\n        {\n            if(s[i] <= '9' && s[i] >= '0')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                result += s[i];\n            }\n            else if(s[i] == '[')\n            {\n                numbers.push(num);\n                num = 0;\n                strs.push(result);\n                result = \"\";\n            }\n            else\n            {\n                int loop = numbers.top();\n                numbers.pop();\n                for(int j = 0; j<loop; j++)\n                {\n                    strs.top() += result;\n                }\n                result = strs.top();\n                strs.pop();\n            }\n        }\n        return result;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088345808","body":"### 思路\n一个栈保存输入数据，一个栈作为输出，当需要输出时判断输出栈是否为空，不为空直接输出栈顶，为空则从输入栈中获取数据\n### 代码\n``` c++\nclass MyQueue {\npublic:\n    MyQueue() {    \n    }\n    \n    void readFromInput() {\n        int index = mStackInput.size();\n        for(int i = 0; i < index; i++)\n        {\n            mStackOutput.push(mStackInput.top());\n            mStackInput.pop();\n        }\n    }\n\n    void push(int x) {\n        mStackInput.push(x);\n    }\n    \n    int pop() {\n        int result = -1;\n        if(!mStackOutput.empty())\n        {\n            result = mStackOutput.top();\n            mStackOutput.pop();\n        }\n        else if(mStackOutput.empty() && !mStackInput.empty())\n        {\n            readFromInput();\n            result = mStackOutput.top();\n            mStackOutput.pop();\n        }\n        return result;\n    }\n    \n    int peek() {\n        if(!mStackOutput.empty())\n        {\n            return mStackOutput.top();\n        }\n        else if(mStackOutput.empty() && !mStackInput.empty())\n        {\n            readFromInput();\n            return mStackOutput.top();\n        }\n        else\n            return -1;\n    }\n    \n    bool empty() {\n        if(mStackOutput.empty() && mStackInput.empty())\n            return true;\n        else\n            return false;\n    }\n\nprivate:\n    stack<int> mStackInput;\n    stack<int> mStackOutput;\n};\n```\n### 复杂度\n#### 时间复杂度\n- push() :O(1)\n- pop():O(n)\n- peek():O(n)\n- empty():O(1)\n#### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090246358","body":"``` c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> addStack;\n        addStack.push(arr[0]);\n        for(int i = 1; i < arr.size(); i++)\n        {\n            if(arr[i] >= addStack.top())\n            {\n                addStack.push(arr[i]);\n            }\n            else\n            {\n              int maxNumber = addStack.top();\n              while(!addStack.empty() && arr[i] < addStack.top())\n              {\n              addStack.pop();\n              }\n              addStack.push(maxNumber);\n            }\n        }\n        return addStack.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091429226","body":"``` c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr)\n            return head;\n        \n        if(head->next == nullptr)\n            return head;\n        \n        if(k == 0)\n            return head;\n\n        vector<ListNode *> nodes;\n        while(head != nullptr)\n        {\n            nodes.push_back(head);\n            head = head->next;\n        }\n        if(nodes.size() == k)\n        {\n            return nodes[0];\n        }\n        else\n        {\n            while(nodes.size() <= k)\n                k -= nodes.size();\n\n            if(k == 0)\n                return nodes[0];\n\n            if(nodes.size() > k)\n            {\n                nodes[nodes.size() - 1]->next = nodes[0];\n                head = nodes[nodes.size() - k];\n                nodes[nodes.size() - k - 1]->next = nullptr;\n            }\n        }\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092777188","body":"### 思路\n两两交换节点\n### 代码\n``` c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head)\n            return head;\n\n        if(!head->next)\n            return head;\n        \n        int n = 0;\n        ListNode *iter = head;\n        while(iter->next != nullptr){\n            iter = iter->next;\n            n++;\n        }\n\n        ListNode* node = new ListNode();\n        node = head;\n        head = head->next;\n        node->next = head->next;\n        head->next = node;\n        ListNode* result = new ListNode();\n        result = head;\n        head = node->next;\n\n        ListNode* preNode = new ListNode();\n        preNode = node;\n        \n        for(int i = 0; i<n; i++)\n        {\n            if(!head)\n                return result;\n            if(!head->next)\n                return result;\n            ListNode* node = new ListNode();\n            node = head;\n            head = head->next;\n            node->next = head->next;\n            head->next = node;\n            preNode->next = head;\n            preNode = node;\n            if(node->next)\n                head = node->next;\n            else\n                break;\n        }\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093827888","body":"``` c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n\n        if (head->next == nullptr) \n        {\n            return new TreeNode(head->val);\n        }\n\n        ListNode *p = head, *q = head, *pre = nullptr;\n        while (q != nullptr && q->next != nullptr) \n        {\n            pre = p;\n            p = p->next;\n            q = q->next->next;\n        }\n        pre->next = nullptr;\n       \n        TreeNode *root = new TreeNode(p->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(p->next);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094299755","body":"``` c++\nclass Solution {\npublic:\n\tListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n\n\t\tif (!headA || !headB)\n            return NULL;\n\n\t\tstd::unordered_set<ListNode*> set;\n\t\tListNode* node = headA;\n\t\twhile (node)\n\t\t{\n\t\t\tset.insert(node);\n\t\t\tnode = node->next;\n\t\t}\n\t\tnode = headB;\n\t\twhile (node)\n\t\t{\n\t\t\tif (set.count(node))\n\t\t\t\treturn node;\n\t\t\tnode = node->next;\n\t\t}\n\n\t\treturn NULL;\n\n\t}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094488758","body":"``` c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head)\n            return head;\n\n        std::unordered_set<ListNode*> set;\n        ListNode* node = head;\n\t\twhile (node)\n\t\t{\n            if(set.count(node))\n                return node;\n\t\t\tset.insert(node);\n\t\t\tnode = node->next;\n\t\t}\n\n        return nullptr;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096308539","body":"``` c++\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        mCapacity = capacity;\n    }\n    \n    int get(int key) {\n        auto iter = mHash.find(key);\n        if(iter == mHash.end())\n            return -1;\n\n        mCache.splice(mCache.begin(), mCache, iter->second);\n        return iter->second->second;\n    }\n    \n    void put(int key, int value) {\n        auto iter = mHash.find(key);\n        if(iter != mHash.end())\n        {\n            iter->second->second = value;\n            mCache.splice(mCache.begin(), mCache, iter->second);\n            return;\n        }\n        else\n        {\n            mCache.push_front({key, value});\n            mHash[key] = mCache.begin();\n\n            if(mHash.size() > mCapacity)\n            {\n                mHash.erase(mCache.back().first);\n                mCache.pop_back();\n            }\n        }\n    }\n\nprivate:\n    std::unordered_map<int, list<pair<int, int>>::iterator> mHash;\n    list<pair<int,int>> mCache;\n    int mCapacity;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097605982","body":"``` c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root)\n            return 1 + max(maxDepth(root->left), maxDepth(root->right));\n        else\n            return 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099181907","body":"``` c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q == nullptr)\n            return true;\n        else if(p == nullptr || q == nullptr)\n            return false;\n        else if(p->val != q->val)\n            return false;\n\n        return (isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100136748","body":"``` c++\nclass Solution \n{\npublic:\n    int compute(TreeNode* root, int sum)\n    {\n        if(!root)\n            return 0;\n        else if(!root->right && !root->left)\n            return 10 * sum + root->val;\n        else \n            return compute(root->left, 10 * sum + root->val) + compute(root->right, 10 * sum + root->val);\n    }\n\n    int sumNumbers(TreeNode* root) \n    {\n        return compute(root, 0);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100677659","body":"``` c++\nclass Solution {\npublic:\n    void compute(TreeNode *node, int depth)\n    {\n        if(!node->left && !node->right)\n        {\n            if(depth > mCurDepth)\n            {\n                mCurDepth = depth;\n                mTargetNode = node;\n            }\n            return;\n        }\n        if(node->left)\n            compute(node->left, depth + 1);\n        if(node->right)\n            compute(node->right, depth + 1);\n    }\n\n    int findBottomLeftValue(TreeNode* root)\n    {\n        compute(root, 1);\n        return mTargetNode->val;\n    }\n\nprivate:\n    TreeNode *mTargetNode;\n    int mCurDepth = 0;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100897294","body":"``` c++\nclass Codec \n{\npublic:\n    TreeNode*dfs(stringstream& ss)\n    {\n        string tmp;\n        ss >> tmp;\n        if(tmp == \"null\")\n            return nullptr;\n        TreeNode* root = new TreeNode(stoi(tmp));\n        root->left = dfs(ss);\n        root->right = dfs(ss);\n        return root;\n    }\n\n    string serialize(TreeNode* root)\n    {\n        if(!root)\n            return \"null\";\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right);\n    }\n\n    TreeNode* deserialize(string data) \n    {\n        stringstream ss(data);\n        return dfs(ss);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101506006","body":"``` c++\nclass Solution {\npublic:\n    void helper(TreeNode* p, int x, int y){\n        if(!p) return;\n        map[x].insert(y * 10000 + p->val);\n        helper(p->left, x-1, y+1);\n        helper(p->right, x+1, y+1);\n        return;\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        helper(root, 0, 0);\n        vector<vector<int>> result;\n        for(auto x:map){\n            vector<int> curr;\n            for(auto y:x.second) curr.push_back(y % 10000);\n            result.push_back(curr);\n        }\n        return result;\n    }\n\nprivate:\n     map<int,set<int>> map;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102794350","body":"``` c++\nclass Solution \n{\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) \n    {\n        std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); i++) \n        {\n            auto iter = map.find(target - nums[i]);\n            if(iter != map.end()) \n            {\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i));\n        }\n        return {};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104093444","body":"``` c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int>hashmap;\n        vector<int> ret;\n\n        for(int i : nums) hashmap[i]++;\n        \n        int maxtimes = 0;   \n        for (auto i : hashmap) {\n            if (i.second > maxtimes) {\n                maxtimes = i.second;\n            }\n        }\n            \n        while (k > 0){\n            for (auto i : hashmap){\n                if (i.second == maxtimes) {\n                    ret.push_back(i.first);\n                    k--;\n                } \n            }\n            maxtimes--;\n        }\n        return ret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105368949","body":"``` c++\n#include<unordered_map>\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        for(int i = 0; i < points.size(); i ++){\n            unordered_map<int,int> mp;\n            for(int j = 0; j < points.size(); j ++){\n                int dx = points[i][0] - points[j][0];\n                int dy = points[i][1] - points[j][1];\n                mp[ dx * dx + dy * dy ]  ++;\n            }\n            for(auto x:mp){\n                ans += x.second * (x.second - 1);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106585529","body":"``` c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int len = s.length(), i = 0, j = 0;\n        int max = (len == 0 ? 0 : 1), k = 0;\n\n        for (i = k + 1; i < len; i++)\n        {\n            int flag = 0;\n            for (j = k; j < i; j++)\n            {\n                if(s[j] == s[i])\n                {\n                    k = j + 1;\n                    flag = 1;\n                    break;\n                }\n            }\n            if(i - k + 1> max && flag == 0)\n                max = i - k + 1;\n        }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107513210","body":"``` c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int sn = s.size(), n = words.size(), m = words[0].size();\n        unordered_map<string, int> wc;\n        vector<int> ans;\n        for(auto& w : words) wc[w]++;\n        for(int i = 0; i < m; ++i){\n            int l = i, r = i, num = 0;\n            unordered_map<string, int> wc0;\n            while(r + m <= sn){\n                auto back = s.substr(r, m);\n                r += m;\n                if(!wc.count(back)){\n                    l = r;\n                    num = 0;\n                    wc0.clear();\n                } else {\n                    num++;\n                    wc0[back]++;\n                    while(wc[back] < wc0[back]){\n                        auto front = s.substr(l, m);\n                        wc0[front]--;\n                        num--;\n                        l += m;\n                    }\n                    if(num == n) ans.push_back(l);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108737528","body":"``` c++\nclass Solution \n{\npublic:\n    ListNode* middleNode(ListNode* head) \n    {\n        ListNode* p = head;\n        ListNode* q = head;\n        while (q != nullptr && q->next != nullptr) \n        {\n            q = q->next->next;\n            p = p->next;\n        }\n        return p;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109703837","body":"``` c++\nclass Solution \n{\npublic:\n    int removeDuplicates(vector<int>& nums) \n    {\n        if (nums.size() == 0) \n        {\n            return 0;\n        }\n        int j = 0;\n        int i = 1;\n        while (i < nums.size()) \n        {\n            if (nums[i] != nums[j]) \n            {\n                j++;\n                nums[j] = nums[i];\n            }\n            i++;\n        }\n        return j + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111037394","body":"``` c++\nclass Solution\n{\npublic:\n    int searchInsert(vector<int>& nums, int target) \n    {\n        auto beg = nums.begin(), end = nums.end();\n        auto mid = beg + (end - beg) / 2;\n        while(mid != end)\n        {\n            if(*mid == target)\n                return mid - nums.begin();\n            else if(*mid < target)\n                beg = mid + 1;\n            else\n                end = mid;\n            mid = beg + (end - beg) / 2;\n        }\n        return mid - nums.begin();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112310274","body":"``` c++\nclass Solution {\npublic:\n    const static int MAXN = 100005;\n    int tree[MAXN<<2];\n    int N;\n    void build(vector<int>* p,int v,int l,int r) {\n        if(l == r) tree[v] = (*p)[l];\n        else {\n            int mid = (l+r) >>1;\n            build(p,v<<1,l,mid),build(p,v<<1 | 1,mid+1,r);\n            tree[v] = max(tree[v<<1],tree[v<<1 | 1]);\n        }\n    }\n    int query(int v,int lb,int rb,int ql,int qr) {\n        if(ql > qr) return INT32_MIN;\n        if(ql == lb && qr == rb) return tree[v];\n        int mid = (lb+rb) >> 1;\n        return max(query(v<<1,lb,mid,ql,min(qr,mid)),\n            query(v<<1 | 1, mid+1,rb, max(mid+1,ql),qr)\n        );\n    }\n\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        if(k == 1) return nums;\n        N = nums.size();\n        if(k >= N) return {*max_element(begin(nums),end(nums))};\n        int lim = N-k+1;\n        vector<int> ans(lim);\n        build(&nums,1,0,N-1);\n        for(int i=0;i<lim;i++) {\n            ans[i] = query(1,0,N-1, i,i+k-1);\n        }        \n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113006153","body":"``` C++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegree(n + 1), outDegree(n + 1);\n        for (auto &_trust: trust) {\n            ++inDegree[_trust[1]];\n            ++outDegree[_trust[0]];\n        }\n        for (int i = 1; i <= n; ++i)\n            if (inDegree[i] == n - 1 && !outDegree[i])    return i;\n        return -1;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085691561","body":"思路\n\n    二者从低位相加，满10进位即可\n\n代码\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0; --i) {\n                int sum = num[i] + k % 10;\n                k /= 10;\n                if (sum >= 10) {\n                    k++;\n                    sum -= 10;\n                }\n                res.add(sum);\n            }\n            for (; k > 0; k /= 10) {\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086620620","body":"思路\n\n    左右两次遍历，找出最小值即可\n\n代码\n\n    class Solution {\n        public int[] shortestToChar(String S, char C) {\n            int N = S.length();\n            int[] ans = new int[N];\n            int prev = Integer.MIN_VALUE / 2;\n    \n            for (int i = 0; i < N; ++i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = i - prev;\n            }\n    \n            prev = Integer.MAX_VALUE / 2;\n            for (int i = N-1; i >= 0; --i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = Math.min(ans[i], prev - i);\n            }\n    \n            return ans;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090066080","body":"思路\n\n    遍历整个数组，将块进行融合，比栈顶小的就移走，其它的进\n\n代码\n\n    class Solution {\n        public int maxChunksToSorted(int[] arr) {\n            LinkedList<Integer> stack = new LinkedList<Integer>();\n            for (int num : arr) {\n                if (!stack.isEmpty() && num < stack.getLast()) {\n                    int cur = stack.removeLast();\n                    while (!stack.isEmpty() && num < stack.getLast()) {\n                        stack.removeLast();\n                    }\n                    stack.addLast(cur);\n                } else {\n                    stack.addLast(num);\n                }\n            }\n            return stack.size();\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085696335","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 思路\n\n- 从后向前逐位相加\n\n## 关键点\n\n-  不能直接把num转成数字相加，数字过大时会越界被截取\n-  考虑进位\n-  考虑k的长度大于num\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let add = k\n    for (let i=num.length-1;i>=0;i--) {\n        if(!add) {\n          break;\n        }\n        let sum = num[i] + add%10\n        add = Math.floor(add/10)\n        if (sum >= 10) {\n            add++\n            num[i] = sum%10\n        } else {\n          num[i] = sum\n        }\n    }\n    while(add > 0) {\n        num.unshift(add%10)\n        add = Math.floor(add/10)\n    }\n    return num\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090199811","body":"## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n\r\n## 关键点\r\n\r\n-  块中数字相同，块中数字和相同\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    const sort = [...arr].sort((a,b)=>a-b)\r\n    \r\n    let num = 0\r\n    let sum1 = 0\r\n    let sum2 = 0\r\n    \r\n    for(let i = 0; i < sort.length; i++) {\r\n        sum1 += arr[i]\r\n        sum2 += sort[i]\r\n        if (sum1 === sum2) {\r\n            num++\r\n        }\r\n    }\r\n\r\n    return num\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091836661","body":"## 思路\n把链表改成环形链表，再从length - k % length 处切开\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || !k) {\n        return head\n    }\n    let length = 1\n    let cur = head\n    \n    while(cur.next) {\n        length++\n        cur = cur.next  // 最后cur指向最后一个node\n    }\n    \n    if(k % length === 0) {\n        return head\n    }\n    cur.next = head // 形成环形链表\n    let index = length - (k % length)\n    \n    while(index) {\n        cur = cur.next\n        index--\n    }\n    let head2 = cur.next\n    cur.next = null\n    return head2\n    \n};\n```\n### 复杂度分析\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099296105","body":"/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(p == null && q == null) \n        return true;\n    if(p == null || q == null) \n        return false;\n    if(p.val != q.val) \n        return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085699745","body":"## 思路\r\n从低位相加，`num`结束后继续判断`k`即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for digit in num[::-1]:\r\n            if k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = digit + add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n            else:\r\n                digit += carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if k > 0:\r\n            while k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if carry == 1:\r\n            res.append(1)\r\n        return res[::-1]\r\n```\r\n## 复杂度\r\n时间：O(n)，n为数组长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086534623","body":"### 思路\r\n\r\n正反两次遍历，分别记录当前字符是`c`的index，初始值使用`inf`。第二次遍历时比较存入最小值。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        idx = -float('inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = min(res[i], idx - i)\r\n        return res \r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`s`长度\r\n\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086850004","body":"## 方法一\r\n\r\n### 思路\r\n\r\n直观做法，定义`self.stack`来作为这个栈。每次增加时index为0～min(k, len(self.stack))的元素增加`val`.\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return\r\n        self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else: \r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        for i in range(n):\r\n            self.stack[i] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：初始，push, pop 为O(1)；increment为O(k)\r\n\r\n空间复杂度：O(maxSize)\r\n\r\n## 方法二\r\n\r\n### 思路\r\n\r\n为了减小方法一中的increment的时间复杂度，设计一个增量数组，只记录增加值的边界，在pop时一并加上作为返回值，之后将增量向栈底进行传递。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        res = self.stack[self.top] + self.add[self.top]\r\n        self.stack[self.top] = 0\r\n        if self.top > 0:\r\n            self.add[self.top-1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1 \r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        tmp = min(k-1, self.top)\r\n        if tmp > -1:\r\n            self.add[tmp] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：全部操作都为O(1)\r\n\r\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087078688","body":"### 思路\r\n\r\n数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        i = 0\r\n        while i < len(s):\r\n            if s[i] != ']':\r\n                stack.append(s[i])\r\n                i += 1\r\n            else:\r\n                tmp = ''\r\n                mul = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp\r\n                if stack:\r\n                    stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul\r\n                tmp *= int(mul)\r\n                stack.append(tmp)\r\n                i += 1\r\n        return ''.join(stack)\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为解码出来后的字符串长度\r\n\r\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089781613","body":"### 思路\r\n\r\n使用单调栈来记录`arr`从后往前的最小值，当再次从头遍历时，维护一个当前最大值变量`maximum`，每次比较栈顶元素与`maximum`，如果栈顶元素大于等于`maximum`，说明后面的最小值已经大于等于了前面的最大值，此时可以切分，`res`增加1。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        res = 0\r\n        stack = []\r\n        minimum = float('inf')\r\n        maximum = -float('inf')\r\n        for num in arr[::-1]:\r\n            minimum = min(minimum, num)\r\n            stack.append(minimum)\r\n        for num in arr:\r\n            if maximum <= stack[-1]:\r\n                res += 1\r\n            maximum = max(maximum, num)\r\n            stack.pop()\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`arr`长度\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091597217","body":"### 思路\r\n\r\n遍历一遍链表得到总长度，将尾节点和头节点连起来成环。利用长度和k算出环形链表断开的位置，找到该位置断开即可。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        length = 1\r\n        node = head\r\n        while node.next:\r\n            length += 1\r\n            node = node.next\r\n        cut = length - k % length\r\n        node.next = head\r\n        while cut > 0:\r\n            node = node.next\r\n            cut -= 1\r\n        head = node.next\r\n        node.next = None\r\n        return head\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)，n为链表长度。\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097893407","body":"## 方法一：DFS\r\n\r\n### 思路\r\n\r\n使用`depth`记录每次进入新的节点的深度，在当前节点下，得到左右子树的深度后，取最大值作为最大深度。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        def dfs(node, depth):\r\n            if not node:\r\n                return depth\r\n            left_depth = dfs(node.left, depth + 1)\r\n            right_depth = dfs(node.right, depth + 1)\r\n            cur_depth = max(left_depth, right_depth)\r\n            return cur_depth\r\n            \r\n        max_depth = dfs(root, 0)\r\n        return max_depth\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(N)，N为树的节点数量，计算树的深度需要遍历所有节点。\r\n\r\n空间复杂度：O(N)，最差情况下，二叉树退化成链表，递归深度为N。\r\n\r\n## **方法二：层序遍历**\r\n\r\n### 思路\r\n\r\n使用层序遍历遍历每一层，每到新的一层深度加一。\r\n\r\n### 代码\r\n\r\n```Python\r\n# 层序遍历\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        stack = []\r\n        res = 0\r\n        stack.append([root])\r\n        while stack[0]:\r\n            node_list = stack.pop()\r\n            if node_list: res += 1\r\n            new_list = []\r\n            for node in node_list:\r\n                if node.left: new_list.append(node.left)\r\n                if node.right: new_list.append(node.right)\r\n            stack.append(new_list) \r\n        return res\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(N), N为树的节点数量，计算树的深度需要遍历所有节点。\r\n\r\n空间复杂度：O(N)最差情况下（当树平衡时）， `stack` 同时存储 N/2 个节点。","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103503284","body":"### 思路\r\n\r\n暴力法，使用字典统计nums的元素个数，然后按照频次排序。最后取出前k个高频元素并返回。s s\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        dic = {}\r\n        for num in nums:\r\n            if num not in dic:\r\n                dic[num] = 1\r\n            else:\r\n                dic[num] += 1\r\n        dic = sorted(dic.items(), key=lambda x: x[1], reverse=True)\r\n        res = []\r\n        for key, value in dic:\r\n            res.append(key)\r\n            k -= 1\r\n            if k == 0:\r\n                break\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(nlogn), n为nums长度\r\n\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104655830","body":"### 思路\r\n\r\n枚举+哈希统计每个点到剩余点的距离频次。最后对于freq频次大于等于2时就满足条件。结果为$2C_{freq}^2$，即freq * (freq - 1).\r\n\r\n### 代码\r\n\r\n```Python\r\nfrom collections import Counter\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        def distance(p1, p2):\r\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\r\n        \r\n        res = 0\r\n        for point1 in points:\r\n            d = []\r\n            for point2 in points:\r\n                d.append(distance(point1, point2))\r\n            count = Counter(d)\r\n            for dist, freq in count.items():\r\n                if freq > 1:\r\n                    res += freq * (freq - 1)\r\n        return res \r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n^2)，n为points个数\r\n\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105940273","body":"### 思路\r\n\r\n使用双指针记录子串的左右边界，右指针不断向后遍历，将没有进入集合的字符加入集合。一旦有已经加入集合的字符，移动删除左指针的字符并不断移动左指针，在每次移动时判断最大长度。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        letters = set()\r\n        l = r = 0\r\n        res = 0\r\n        while l < len(s) and r < len(s):\r\n            if s[r] not in letters:\r\n                letters.add(s[r])\r\n                r += 1\r\n            else:\r\n                letters.remove(s[l])\r\n                l += 1\r\n            res = max(res, len(letters))\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)，n为字符串长度\r\n空间复杂度：O(1)，因为字符集的大小是有限的","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112963382","body":"### 思路\r\n\r\n将人作为图的节点统计出入度。如果一个节点的出度为0入度为n-1则返回结果。\r\n\r\n### 代码\r\n\r\n```Python\r\nfrom collections import Counter\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        l1 = Counter(x for x,y in trust)\r\n        l2 = Counter(y for x,y in trust)\r\n        for i in range(1, n+1):\r\n            if l1[i] == 0 and l2[i] == n-1:\r\n                return i\r\n        return -1\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n+m)，m为`trust`长度\r\n\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085702964","body":"## 思路\r\n转换为字符串后再进行处理\r\n![image](https://user-images.githubusercontent.com/30134501/161241442-d66bc6e2-aaee-41a4-ba25-072de0f524be.png)\r\n\r\n## 代码（python）\r\n\r\n```python\r\nclass Solution:\r\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n      return list(map(int, list(str(int(''.join(list(map(str, num))))+k))))\r\n```\r\n**复杂度分析**\r\n- 时间复杂度： O(n) , n 为数组长度。\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086539562","body":"## 思路\r\n暴力解法，遍历找到index；将`answer`里的值设置很大，循环`range(0, len(s))`+循环`index`，作差求绝对值，跟`answer[i]`比较大小\r\n\r\n## 代码 （python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index = [i for i,si in enumerate(s) if si==c]\r\n        answer = [len(s)]*len(s)\r\n        for i in range(0, len(s)):\r\n            for j in index:\r\n                if abs(i-j)<answer[i]:\r\n                    answer[i] = abs(i-j) \r\n        return answer\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n^2)， n为`s`长度, 套了两个循环\r\n- 空间复杂度： O(n)，n为`answer`数组长度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792048","body":"- ## 思路\r\n\t- 正常list操作，push对应append()，pop对应pop()\r\n- ### 代码（python3）\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > 0: \r\n            for i in range(min(k, len(self.stack))):\r\n                self.stack[i] += val\r\n```\r\n- ### 复杂度分析\r\n  - 时间复杂度：O(n), n是`stack`长度\r\n  - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087685866","body":"### 思路\r\n- 遍历`s`，往栈内不断push\r\n  * 如果遇到`]`，就开始一直pop，直到遇到`[`（用一个数组来存pop出来的字母）\r\n  * pop出`[`后，再继续pop，直到遇到非数字 or 栈为空 （用一个数组来存pop出来的数字）\r\n  * 解码这部分字符串，然后放入栈内\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n        stemp = []\r\n        ntemp = []\r\n        for si in s:\r\n            if si != ']':\r\n                stk.append(si)\r\n            else:\r\n                while True:\r\n                    # get letters in []\r\n                    if stk[-1] == '[':\r\n                        # remove [\r\n                        stk.pop()\r\n                        break\r\n                    else:\r\n                        # append letters\r\n                        stemp.append(stk.pop())\r\n                while True:\r\n                    # get numbers before [\r\n                    if stk:\r\n                        if not stk[-1].isnumeric():\r\n                            break\r\n                        else:\r\n                            # append numbers\r\n                            ntemp.append(stk.pop())\r\n                    else:\r\n                        break\r\n                stk.extend(list(reversed(stemp)) * int(''.join(reversed(ntemp))))\r\n                stemp = []\r\n                ntemp = []\r\n        return ''.join(stk)\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n^2), n为`s`长度，外循环遍历一遍`s`push到栈内，内循环又pop出来\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088251957","body":"### 思路\r\n- push: 新数据来了就 push 到 栈1，\r\n- pop: 需要 pop 的时候（如果 栈2 不为空），就把 栈1 反转（等价于pop后再append）存到 栈2，从栈2 pop\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack2 == []:\r\n            self.stack2 = list(reversed(self.stack1))\r\n            self.stack1 = []\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2 == []:\r\n            return self.stack1[0]\r\n        else:\r\n            return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return self.stack2 == [] and self.stack1 == []\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1), python中reversed的时间复杂度好像是O(1)\r\n- 空间复杂度：O(n), n为stack长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089908758","body":"### 思路\r\n- 遍历一遍`arr`，如果左边的最大<=右边的最小，chunk数就加一\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        num = 1\r\n        # from the second index to the last index\r\n        for i in range(1,len(arr)):\r\n            # if max of left < min of right\r\n            if  max(arr[:i]) <= min(arr[i:]):\r\n                num += 1\r\n        return num\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n^2), n是`arr`长度，遍历一遍，遍历时取 max/min 要O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091903629","body":"### 思路\r\n- 从head遍历到最后的元素，记录list长度为`n`\r\n- 成环 ：（如果list长度`n`不是`k`的倍数）本来指向`None`的最后元素指向head\r\n- 断开：再遍历一次，找到第`n - k mod n`个元素，它后面的元素作为要输出的list的新head，它自己指向None\r\n\r\n### Code (python)\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head == None or head.next == None or k == 0:\r\n            return head\r\n\r\n        # count the length of list\r\n        n = 1\r\n        cnt = head\r\n        while cnt.next != None:\r\n            cnt = cnt.next\r\n            n += 1\r\n            \r\n        if k % n == 0:\r\n            return head\r\n            \r\n        # last element points to the first one\r\n        cnt.next = head\r\n\r\n        # find the second (k-th) to last one\r\n        for i in range(n - k % n):\r\n            cnt = cnt.next\r\n\r\n        # use its next as new head\r\n        output = cnt.next\r\n        # point to None\r\n        cnt.next = None\r\n\r\n        return output\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n), n为list长度\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092612321","body":"- ## 思路\r\n\t- 要`swapPairs`整个list，先swap前俩nodes：前2个nodes (`one`和`two`) 互换（`two`为head，指向`one`，再指向后面）；\r\n\t- 前俩nodes弄好后，list变短为从第3个node开始，把第3个node作为head输入`swapPairs`，依次递归\r\n\t- ### 代码\r\n\t\t-\r\n\t\t  ``` python\r\n\t\t  \t\t  class Solution:\r\n\t\t  \t\t      def swapPairs(self, head: ListNode) -> ListNode:\r\n\t\t  \t\t          if not head or not head.next:\r\n\t\t  \t\t              return head\r\n\t\t  \t\t  \r\n\t\t  \t\t          one = head\r\n\t\t  \t\t          two = one.next\r\n\t\t  \t\t          one.next = self.swapPairs(two.next)\r\n\t\t  \t\t          two.next = one\r\n\t\t  \t\t          \r\n\t\t  \t\t          return two\r\n\t\t  ```\r\n\t- ### 复杂度分析\r\n\t\t- 时间复杂度：O(n), n为list长度，每次递归n-2，也就是递归了n/2次，每次递归为O(1)\r\n\t\t- 空间复杂度：O(n)，递归深度为n/2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094069910","body":"### 思路\r\n先把链表转化为数组，找到中间位置作为root，再对左右递归\r\n\r\n### Code (python3)\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        arr = []\r\n        while head:\r\n            arr.append(head.val)\r\n            head = head.next\r\n        def buildBST(start, end):\r\n            if start > end: return None\r\n            mid = (start + end) // 2\r\n            root = TreeNode(arr[mid])\r\n            root.left = buildBST(start, mid - 1)\r\n            root.right = buildBST(mid + 1, end)\r\n            return root\r\n        return buildBST(0, len(arr)-1)\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，n为链表长度，遍历链表存为数组；递归的时间复杂度忽略（每次递归分一半，也就是递归了log n次，每次递归为O(1), 总共为O(log n)）\r\n- 空间复杂度：O(n), 多来了个长度为n的数组；递归的空间复杂度忽略，为O(log n), 因为递归深度为 log n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094293095","body":"### 思路\r\n两个指针分别遍历两个链表，并走一遍对方走过的路，如果有交点相遇点为交点，如无交点，相遇点为None\r\n\r\n### Code\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB: return None\r\n        p1 = headA\r\n        p2 = headB\r\n        while p1 != p2:\r\n            if p1: p1 = p1.next\r\n            else: p1 = headB\r\n            if p2: p2 = p2.next\r\n            else: p2 = headA\r\n        return p1\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(m+n), m+n为两个链表长度和\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095133996","body":"### 思路\r\n- 找环：快慢指针，慢指针走一步，快指针走两步，如果快指针遇到None则无环，如果快指针遇到慢指针则有环\r\n- 找成环节点：这个太巧妙了，看了别人的解法才明白。在相遇节点，一个指针继续一步步走，一个指针从头开始走，当再次相遇，相遇节点为成环节点。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        p1 = p2 = head\r\n        # 判断是否有环, 有环break，无环p2就会碰到None\r\n        while True:\r\n            # 如果 p2 or p2.next 是 None\r\n            if not p2 or not p2.next:\r\n                return None\r\n            p1 = p1.next\r\n            p2 = p2.next.next \r\n            if p1 == p2: break\r\n\t\t\r\n        p1 = head\r\n        while p1 != p2:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n\r\n        return p1\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n), n为链表长度\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096849646","body":"## 思路\r\n偷懒做法，用OrderedDict\r\n\r\n## 代码\r\n```python\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        self.dict = OrderedDict()\r\n        self.capacity = capacity\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.dict:\r\n            self.dict.move_to_end(key)\r\n            return self.dict[key]\r\n        else:\r\n            return -1\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        self.dict[key] = value\r\n        self.dict.move_to_end(key)\r\n        if len(self.dict) > self.capacity:\r\n            self.dict.popitem(last = False)\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098183852","body":"## 思路\r\n先写出递推公式：maxDepth(r) = max(maxDepth(r.left) + maxDepth(r.right)) + 1\r\n终止条件：r为None时，深度为0\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        return(max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1)\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n), 遍历二叉树时每个节点访问2次，共n个节点\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099251364","body":"### 思路\r\n- 如果p和q有且只有一个为空，则不相等\r\n- 如果p和q都为空，则相等\r\n- 否则，递归比较 root，root.left, root.right是否相等\r\n\r\n### Code\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        # if one of p and q is None\r\n        if (not p and q) or (not q and p): return False\r\n        # if p and q are None\r\n        if not p and not p: return True\r\n        return (p.val == q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100179683","body":"## 思路\r\n前序遍历\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        def dfs(root, sum):\r\n            if not root: return 0\r\n            elif not root.left and not root.right: return sum*10 + root.val\r\n            return dfs(root.left, sum*10 + root.val) + dfs(root.right, sum*10 + root.val)\r\n\r\n        return dfs(root, 0)\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100656465","body":"### 思路\r\n- 设置最大深度maxDepth为-1，left值为0；\r\n- 当当前深度depth大于maxDepth时，更新maxDepth和left值；\r\n- 往左右递归时深度+1\r\n\r\n### Code\r\n```python\r\nclass Solution:\r\n\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        \r\n        def dfs(root, depth):\r\n            if not root: return\r\n            if depth > maxDepth_left[0]:\r\n                maxDepth_left[0] = depth\r\n                maxDepth_left[1] = root.val\r\n            dfs(root.left, depth+1)\r\n            dfs(root.right, depth+1)\r\n\r\n        maxDepth_left = [-1, 0]\r\n        dfs(root, depth=0)\r\n        return maxDepth_left[1]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100902544","body":"## 思路\r\nBFS遍历，序列化时None以‘X’代替\r\n\r\n## Code\r\n```python\r\nfrom collections import deque\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root: return ''\r\n        queue = deque()\r\n        queue.append(root)\r\n        ser = ''\r\n        while queue:\r\n            node = queue.popleft()\r\n            if node != None:\r\n                ser += str(node.val) + ','\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                ser += 'X,'\r\n        return ser\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data: return None\r\n        data = data.split(',')\r\n        root = TreeNode(data.pop(0))\r\n        queue = [root]\r\n        while queue:\r\n            node = queue.pop(0)\r\n            if data:\r\n                val = data.pop(0)\r\n                if val != 'X':\r\n                    node.left = TreeNode(val)\r\n                    queue.append(node.left)\r\n            if data:\r\n                val = data.pop(0)\r\n                if val != 'X':\r\n                    node.right = TreeNode(val)\r\n                    queue.append(node.right)\r\n        return root\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101193444","body":"## 思路\r\ndfs遍历一遍，以col为key，将 (row, val) 存进hashmap；\r\n对col排序后，一列列append到res里（同col的对row排序）\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        hashmap = defaultdict(list)\r\n\r\n        def dfs(root, row, col):\r\n            if not root: return\r\n            hashmap[col].append((row, root.val))\r\n            dfs(root.left, row+1, col-1)\r\n            dfs(root.right, row+1, col+1)\r\n\r\n        dfs(root, 0, 0)\r\n        res = []\r\n        for col in sorted(hashmap.keys()):\r\n            res.append(list(zip(*sorted(hashmap[col])))[1])\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102179248","body":"## 思路\r\n最笨的两层循环\r\n\r\n## Code\r\n```python\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        for i in range(len(nums)):\r\n            for j in range(i+1, len(nums)):\r\n                if nums[i] + nums[j] == target: return [i, j]\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103966957","body":"### 思路\r\n- 遍历一遍`nums`，以num为key，出现次数为value，存入hash表\r\n- 按照value从小到大排序后，取最后k个key\r\n\r\n### Code\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        hashtable = defaultdict(int)\r\n        for i in range(len(nums)):\r\n            hashtable[nums[i]] += 1\r\n\r\n        return [key for key, value in sorted(hashtable.items(), key=lambda item: item[1])][-k:]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(nlogn)，快排\r\n- 空间复杂度：O(n)，hash表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104758130","body":"- ## 思路\r\n\t- 以一个`point`作为pi，算其它所有点到它的距离；\r\n\t- 以距离为key，频次为value存入hashtable\r\n\t- 如果频次为2，说明有两个点到pi距离一样，这时boomerang数量为2*1=2\r\n\t- 如果频次为3，boomerang数量为3*2=6\r\n\t- ### 代码\r\n\t\t-\r\n\t\t  ``` python\r\n\t\t  \t\t  class Solution:\r\n\t\t  \t\t      def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n\t\t  \t\t          num = 0\r\n\t\t  \t\t          for pi in points:\r\n\t\t  \t\t              hashtable= defaultdict(int)\r\n\t\t  \t\t              for pj in points:\r\n\t\t  \t\t                  dist = (pi[0]-pj[0])**2 + (pi[1]-pj[1])**2\r\n\t\t  \t\t                  hashtable[dist] += 1\r\n\t\t  \t\t              for n in hashtable.values():\r\n\t\t  \t\t                  num += n * (n-1)\r\n\t\t  \t\t          return num\r\n\t\t  ```\r\n\t- ### 复杂度分析\r\n\t\t- 时间复杂度：O(n^2)\r\n\t\t- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106643833","body":"## 思路\r\n- 左右指针窗口滑动，右指针一格格走增大窗口\r\n- 用一个hashmap作为计数器记录右指针指向字符出现的频次\r\n- 当计数器里记录的字符出现超过1次时，左指针一格格走直到计数器里所有字符出现次数少于一次（没有重复）\r\n- 返回左右指针差值\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        window = defaultdict(int)\r\n        left = right = 0\r\n        res = 0\r\n        while (right < len(s)):\r\n            c = s[right]\r\n            right += 1\r\n            window[c] += 1\r\n            while window[c] > 1:\r\n                d = s[left]\r\n                left += 1\r\n                window[d] -= 1\r\n            res = max(res, right - left)\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107523499","body":"## 思路\r\n- 以words中每个单词为key，出现次数为value，存入hashtable\r\n- 滑动窗口大小固定为`wordLen * wordNum`，每次滑动一格\r\n- 每次滑动，比较窗口中的单词的出现次数和需要的出现次数是否相同\r\n\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        strLen = len(s)\r\n        wordNum = len(words)\r\n        wordLen = len(words[0])\r\n        windowSize = wordNum * wordLen\r\n\r\n        init = {word:0 for word in words}\r\n        need = init.copy()\r\n        for word in words:\r\n            need[word] += 1\r\n\r\n        start = 0\r\n        ans = []\r\n\r\n        while start < strLen - windowSize + 1:\r\n            cnt = init.copy()\r\n            for i in range(start, start + windowSize, wordLen):\r\n                word = s[i: i + wordLen]\r\n                if word not in cnt:\r\n                    break\r\n                else:\r\n                    cnt[word] += 1\r\n                    if cnt[word] > need[word]:\r\n                        break\r\n            else: \r\n                ans.append(start)\r\n            \r\n            start += 1\r\n        \r\n        return(ans)\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O((strLen-windowSize)*windowSize)\r\n- 空间复杂度：O(windowSize)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108335678","body":"## 思路\r\n快慢指针，当快指针没到尾时，快指针走两步慢指针走一步\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        p1 = p2 = head\r\n        while p2.next and p2.next.next:\r\n            p1 = p1.next\r\n            p2 = p2.next.next\r\n        if not p2.next: return p1\r\n        if not p2.next.next: return p1.next\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109465776","body":"## 思路\r\n一个指针一直一格格走，另一个指针记录不重复list的尾部\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        p1 = 0\r\n        p2 = 1\r\n        numsLen = len(nums)\r\n        while p2 < numsLen:\r\n            if nums[p1] == nums[p2]:\r\n                p2 += 1\r\n            else:\r\n                p1 += 1\r\n                nums[p1] = nums[p2]\r\n                p2 += 1\r\n        return p1+1\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111167625","body":"## 思路\r\n二分查找的经典题\r\n\r\n## code\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left = 0\r\n        right = len(nums)\r\n        while left < right:\r\n            mid = (right-left)//2+left\r\n            if nums[mid] < target:\r\n                left = mid+1\r\n            else:\r\n                right = mid\r\n            print(left,right)\r\n        return left\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(logn)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112344949","body":"## 思路\r\n单调队列，将小于自己的元素都删除\r\n\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        window = []\r\n        res = []\r\n        for i, v in enumerate(nums):\r\n            if i >= k and window[0] <= i-k: window.pop(0)\r\n            while window and nums[window[-1]] <= v: window.pop()\r\n            window.append(i)\r\n            if i >= k-1: res.append(nums[window[0]])\r\n        return res\r\n```\r\n\r\n\r\n## 复杂度分析：\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113441917","body":"## 思路\r\n用nxn的matrix来存有向图\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        graph = [[0]*n for _ in range(n)]\r\n\r\n        for fr, to in trust:\r\n            graph[fr-1][to-1] = 1\r\n\r\n        # find the row with all zeros (i.e., trust nobody)\r\n        for i in range(n):\r\n            if sum(graph[i]) == 0:\r\n                res = i+1\r\n                # find the column with n-1 ones (i.e., trusted by all but himself)\r\n                if graph[res-1][res-1] == 0 and sum([row[res-1] for row in graph]) == n-1:\r\n                    return res\r\n        \r\n        return -1\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(m)\r\n- 空间复杂度：O(n^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinhaoti":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085717791","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        Idea:\n            case1: len(num) > len(str(k)):\n                add two digital -> get result & carry\n                left move 1 digital of k\n            case2: len(num) < len(str(k)):\n                k += carry\n                while: add k to new array / convert k to array\n        Topic: Array enumerate\n        TC: O(N + max(0, (K-N)^2)\n        SC: O(max(1,K-N))\n        \"\"\"\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            add_result = carry + num[i] + k % 10\n            num[i] = add_result % 10\n            carry = add_result // 10\n            k = k // 10\n        \n        re = []\n        k = k + carry\n        while k:\n            re.insert(0, k % 10)\n            k = k // 10\n        \n        return re + num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086549709","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Brute-force\n        TC: O(n^2)\n        SC: O(n)\n        \"\"\"\n        re = [-1] * len(s)\n\n                \n        for i in range(len(s)):\n            shortest = float('inf')\n            count = 0\n            for j in range(i, -1, -1):\n                if s[j] != c:\n                    count += 1\n                if s[j] == c:\n                    shortest = min(shortest, count)\n            \n            count = 0\n            for k in range(i, len(s)):\n                if s[k] != c:\n                    count += 1\n                if s[k] == c:\n                    shortest = min(shortest, count)\n            re[i] = shortest\n        \n        return re\n    \n    \n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Topic: Array enumerate\n        Idea: enumerate 3times\n            [-1] * n\n            1st: put 0\n            2nd: left->right, 0+1\n            3rd: right->left, 0+1\n        \n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        l = len(s)\n        re = [-1] * l\n        \n        for i in range(l):\n            if s[i] == c:\n                re[i] = 0\n        \n        cur_d = -1\n        for i in range(l):\n            print(re[i], cur_d)\n\n\n            if re[i] == 0:\n                cur_d = 0\n            re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n        # reversed enumerate\n        cur_d = float('inf')\n        for i in range(l-1, -1, -1):\n            if re[i] == 0:\n                cur_d = 0\n                \n            if cur_d < re[i] or re[i] == -1:\n                re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n\n        return re\n\n                \n                \n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868202","body":"```python\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Idea: \n        init: []-> stack, n->size\n        push: append\n        pop: pop()\n        increment: for -> increase\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(min(k, len(self.stack)))\n    SC: O(1)\n    \n    Improve: prefix-sum -> make increment O(1)\n    \"\"\"\n    \n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        \n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        return self.stack.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i == len(self.stack):\n                break\n            self.stack[i] += val\n\n            \nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Improve: prefix-sum -> make increment O(1)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(n)\n    Improve: SC -> O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = [0] * maxSize\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop()\n        re += self.incrementals[n - 1]\n        self.incrementals[n - 1] = 0\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    SC -> O(size of stack)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = []\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n        self.incrementals.append(0)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop() + self.incrementals.pop()\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n        \n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1090164816","body":"```python\nclass MyQueue:\n    \"\"\"\n    Ideas: \n        init: two stack\n        on push -> use help stack to push into on bottom of stack\n        pop -> just pop the reversed stack\n        empty -> just check stack\n        peek-> same\n    TC: O(n), n = size of stack\n    SC: O(n)\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n        self.help_stack = []\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n            \n        self.stack.append(x)\n        \n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n    \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        return self.stack.pop()\n        \n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.stack == []\n\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090425887","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        chunks -> count is same -> can sort to get same result\n        TC: O(n^2) ; compare two dict need O(n)\n        SC: O(n)\n        Improve: compare two dict\n        \"\"\"\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            # print(a,b)\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        TC: O(nlogn)\n        SC: O(n)\n        \"\"\"\n        count = collections.defaultdict(int)\n        non_zero_cnt = 0\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            if count[a] == -1: non_zero_cnt -= 1 # diff 从 -1 变成 0 ，non_zero_cnt 减一\n            if count[a] == 0: non_zero_cnt += 1 # diff 从 0 变成 1 ，non_zero_cnt 加一\n            count[a] += 1\n            if count[b] == 1: non_zero_cnt -= 1 # diff 从 1 变成 0 ，non_zero_cnt 减一\n            if count[b] == 0: non_zero_cnt += 1 # diff 从 0 变成 -1 ，non_zero_cnt 加一\n            count[b] -= 1\n            if non_zero_cnt == 0: ans += 1 # ，non_zero_cnt 等于 0 表示 diff 全部相等\n\n        return ans\n    \n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1094039783","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        \"\"\"\n        Ideas: iterative\n            swap_two -> cur = new_tail.next\n        \n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        if not head or not head.next: return head\n        dummy = ListNode(-1)\n        dummy.next = head\n        \n        prev = dummy\n        cur = dummy.next\n        while cur and cur.next:\n            nex = cur.next\n            cur.next = nex.next\n            nex.next = cur\n            prev.next = nex\n            # update cur, prev\n            prev = cur\n            cur = cur.next\n        return dummy.next\n    \n    \n    def swapPairs(self, head: ListNode) -> ListNode:\n        \"\"\"\n        Ideas: Recursive\n        TC: O(n * 1)\n        SC: O(1)\n        \"\"\"\n        if not head or not head.next: return head\n        nex = head.next\n        head.next = self.swapPairs(nex.next)\n        nex.next = head\n        return nex\n            \n            \n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094019547","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Keywords: LinkedList, BST, convert\n        Ideas: \n            recurssion\n            get mid value\n            fast & slow pointer -> build treeNode\n        TC: O(logn * n) = O(nlogn)\n        SC: O(logn * 1) = O(logn)\n        \"\"\"\n        def dfs(head, tail):\n            if head == tail: return None\n            slow, fast = head, head\n            while fast!= tail and fast.next != tail:\n                fast = fast.next.next\n                slow = slow.next\n            root = TreeNode(slow.val)\n            root.left = dfs(head, slow)\n            root.right = dfs(slow.next, tail)\n            return root\n        if not head: return head\n        return dfs(head, None)\n        \n        \n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Use list to improve, no need find mid value in linkedlist\n        Improve: O(n)\n        \n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        res = []\n        while head:\n            res.append(head.val)\n            head = head.next\n        \n        def dfs(res, l, r):\n            if l > r: return None\n            m = (l + r) // 2\n            root = ListNode(res[m])\n            root.left = dfs(res, l, m - 1)\n            root.right = dfs(res, m + 1, r)\n            return root\n            \n        return dfs(res, 0, len(res) - 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094198327","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \"\"\"\n        Ideas: map\n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        seen = set()\n        while headA:\n            seen.add(headA)\n            headA = headA.next\n            \n        while headB:\n            if headB in seen:\n                return headB\n            headB = headB.next\n        return None\n    \n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \"\"\"\n        Improve: two pointers fast, slow\n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n        \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1096854180","body":"```python\nclass Solution:            \n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Ideas: map\n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        if not head or not head.next: return None\n        seen = set()\n        while head:\n            if head in seen:\n                return head\n            else:\n                seen.add(head)\n            head = head.next\n        return None\n    \n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]: \n        \"\"\"\n        Improve: use fast, slow pointer\n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        if not head or not head.next: return None\n        \n        slow, fast = head, head\n        while True:\n            if fast == None or fast.next == None:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n            \n        fast = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return fast\n                \n  ```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096837959","body":"```python\n\"\"\"\nIdeas:\n    init: SC -> O(n)\n        cache map\n        head, tail\n    get: O(1) -> hash_map\n        if in cache:\n            return value\n        else:\n            update priority -> linked list -> DL list\n                get node\n                put node into head\n    put: O(1)\n        if in cache:\n            update value\n            update priority\n        else:\n            if size > capacity: \n                pop the loweset priority -> tail\n                del in map\n                create new Node -> put into head and into cache\n            else:\n                create node\n                put into head and into cache\n\"\"\"\nclass DLinkedNode:\n    def __init__(self, key = 0, val = 0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n    \n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = {}\n        self.capacity = capacity\n        self.size = 0\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    \n    def add2head(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        node.prev.next = node\n        node.next.prev = node\n        \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self.removeNode(node)\n            self.add2head(node)\n            return node.val\n        else:\n            return -1\n\n        \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.removeNode(node)\n            self.add2head(node)\n        else:\n            node = DLinkedNode(key, value)\n            if self.size >= self.capacity:\n                removed = self.tail.prev\n                self.removeNode(removed)\n                self.cache.pop(removed.key)\n                self.cache[key] = node\n                self.add2head(node)\n            else:\n                self.cache[key] = node\n                self.add2head(node)\n                self.size += 1\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098218275","body":"```python\n           \n    def maxDepth(self, root: TreeNode) -> int:\n        \"\"\"\n        topic: binary tree, max depth\n        ideas: Recurrsive\n            dfs: leaf node update\n        TC: O(n)\n        SC: O(h) = O(logn) -> worst O(n)\n        \"\"\"\n        def dfs(root):\n            if not root: return 0\n            left_height = dfs(root.left)\n            right_height = dfs(root.right)\n            return max(left_height, right_height) + 1\n        \n        return dfs(root)\n            \n        \n    def maxDepth(self, root: TreeNode) -> int:\n        \"\"\"\n        Iteration: Stack, 2 color method\n        TC: O(n)\n        SC: O(h) = O(logn), worst O(n)\n        \"\"\"\n        WHITE, GREY = 1, 0\n        stack = [(WHITE, root, 1)]\n        \n        depth = 0\n        while stack:\n            color, node, cur_depth = stack.pop()\n            if not node: continue\n            if color == WHITE:\n                stack.append((GREY, node, cur_depth))\n                stack.append((WHITE, node.right, cur_depth + 1))\n                stack.append((WHITE, node.left, cur_depth + 1))\n            else:\n                depth = max(cur_depth, depth)\n        return depth\n    \n    \n    def maxDepth(self, root: TreeNode) -> int:\n        \"\"\"\n        Ideas: BFS, queue\n        TC: O(n)\n        SC: O(m): max # of nodes at same level = n/2 -> O(n)\n        \"\"\"\n        if not root: return 0\n        queue = collections.deque([root])\n        depth = 0\n        while queue:\n            row = []\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                row.append(node.val)\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n            depth += 1\n        return depth\n        \n              \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098788915","body":"```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Topic: Tree, same tree\n        Ideas: recursion + dfs\n            if reach leaf and all None -> true\n            if one of node is None -> false\n            return q.val == p.val and left subtree and right subtree\n        TC: O(1 * n) = O(n)\n        SC: O(h)\n        \"\"\"\n        if not q and not p: \n            return True\n        if not q or not p:\n            return False\n        \n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n    \n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Ideas: bfs + level traversal\n            queue to get all p & q\n            get all trasveral and compare\n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        if not p and not q: return True\n        if not p or not q: return False\n            \n        q1 = collections.deque([p])\n        q2 = collections.deque([q])\n        \n        r1 = []\n        r2 = []\n        \n        while q1 and q2:\n            row1 = []\n            row2 = []\n            \n            size1 = len(q1)\n            size2 = len(q2)\n            \n            for _ in range(size1):\n                node = q1.pop()\n                if not node: \n                    row1.append(None)\n                    continue\n                else:\n                    row1.append(node.val)\n                if node.left: \n                    q1.append(node.left)\n                else:\n                    q1.append(None)\n                if node.right: \n                    q1.append(node.right)\n                else:\n                    q1.append(None)\n            \n            \n            for _ in range(size2):\n                node = q2.pop()\n                if not node: \n                    row2.append(None)\n                    continue\n                else:\n                    row2.append(node.val)\n                    \n                if node.left: \n                    q2.append(node.left)\n                else:\n                    q2.append(None)\n                    \n                if node.right: \n                    q2.append(node.right)\n                else:\n                    q2.append(None)\n                    \n                \n            r1.append(row1)\n            r2.append(row2)\n            \n        return r1 == r2\n    \n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Ideas: bfs + level traversal\n            queue to get all p & q\n            get all trasveral and compare\n        TC: O(n)\n        SC: O(q), size of q\n        \"\"\"\n        if not p and not q: return True\n        if not p or not q: return False\n            \n        q1 = collections.deque([p])\n        q2 = collections.deque([q])\n        \n        r1 = []\n        r2 = []\n        \n        while q1 and q2:\n            node1 = q1.pop()\n            node2 = q2.pop()\n            if not node1 and not node2: continue\n            if not node1 or not node2: return False\n            if node1.val != node2.val: return False\n            q1.append(node1.left)\n            q1.append(node1.right)\n            q2.append(node2.left)\n            q2.append(node2.right) \n        return True\n            \n        \n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Ideas:\n            use preorder and inorder traversal -> compare result\n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        \n        \n        p_inorder_ans = []\n        q_inorder_ans = []\n        p_preorder_ans = []\n        q_preorder_ans = []\n        \n        \n        def inorder(root, ans):\n            if not root: \n                ans.append(None)\n                return\n            inorder(root.left, ans)\n            ans.append(root.val)\n            inorder(root.right, ans)\n\n        def preorder(root, ans):\n            if not root: \n                ans.append(None)\n                return\n            ans.append(root.val)\n            preorder(root.left, ans)\n            preorder(root.right, ans)\n\n            \n        inorder(p, p_inorder_ans)\n        inorder(q, q_inorder_ans)\n        preorder(p, p_preorder_ans)\n        preorder(q, q_preorder_ans)\n        # print(p_inorder_ans)\n        # print(q_inorder_ans)\n        # print(p_preorder_ans)\n        # print(q_preorder_ans)    \n        return p_inorder_ans == q_inorder_ans and p_preorder_ans == q_preorder_ans\n    \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100841535","body":"```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Ideas: DFS\n            each time, carry cur_val into deeper recursive stack\n        TC: O(n)\n        SC: O(h)\n        \"\"\"\n        if not root: return 0\n        ans = 0\n        def dfs(root, cur_sum):\n            nonlocal ans\n            if not root: return\n            if not root.left and not root.right:\n                # print(cur_sum * 10 + root.val)\n                ans += cur_sum * 10 + root.val\n                return\n            dfs(root.left, cur_sum * 10 + root.val)\n            dfs(root.right, cur_sum * 10+ root.val)   \n        \n        dfs(root, 0)\n        return ans\n    \n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Ideas: BFS\n        TC： O(n)\n        SC: O(Q)  -> if full BT -> max width = (N+1) / 2 ->  O(N/2) = O(n)\n        \"\"\"\n        \n        queue = collections.deque([(root, 0)])\n        ans = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node, cur_sum = queue.popleft()\n                # print(node, cur_sum)\n                if not node.left and not node.right:\n                    ans += cur_sum * 10 + node.val\n                    # print(ans)\n                    \n                if node.left: queue.append((node.left, cur_sum * 10 + node.val))\n                if node.right: queue.append((node.right, cur_sum * 10 + node.val))\n        return ans\n                    \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100695398","body":"```python\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        Ideas: \n            BFS -> get last row first element\n        TC: O(n)\n        SC: O(n) -> no need to save ans -> improve to O(size of queue) -> worst O(N)\n        \"\"\"\n        queue = collections.deque([root])\n        res = None\n        while queue:\n            size = len(queue)\n            res = queue[0].val\n            for _ in range(size):\n                node = queue.popleft()\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100720916","body":"```python\nclass Codec:\n    \"\"\"\n    Ideas: DFS\n        serialize: use preorder + None when reach leaf\n        deserialize: use preorder to build TreeNode and connect left & right\n    TC: O(n)\n    SC: O(n)\n    \n    \"\"\"\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def preorder(root):\n            if not root: return \"None,\"\n            return str(root.val) + \",\" +  preorder(root.left) + preorder(root.right)\n            \n        return preorder(root)[:-1]\n        \n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        nodes = data.split(\",\")\n        q = collections.deque(nodes)\n        # print(nodes)\n        def preorder(q):\n            if q[0] == 'None':\n                q.popleft()\n                return None\n            \n            root = TreeNode(q[0])\n            q.popleft()\n            root.left = preorder(q)\n            root.right = preorder(q)\n            return root\n        \n        root = preorder(q)\n        return root\n            \n    \"\"\"\n    Ideas: BFS + queue\n        serialize: popleft -> if not node: append(\"None\") else: append(str(val))\n        deserialize: \n            queue -> i = 0 -> i += 2 -> node.left = left_node, node.right = right_node\n    TC: O(n)\n    SC: O(n)\n    \n    \"\"\"\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root: return \"\"\n        queue = collections.deque([root])\n        ans = []\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                if node: \n                    ans.append(str(node.val))\n                    queue.append(node.left)\n                    queue.append(node.right)\n                else:\n                    ans.append(\"None\")\n        return \"[\" +  \",\".join(ans) +\"]\"\n            \n            \n            \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"   \n        # print(data)\n        if not data: return []\n        data = data[1:-1]\n        \n        ls = data.split(',')\n        root = TreeNode(int(ls[0]))\n        queue = collections.deque([root])\n        \n        i = 1\n        while queue and i < len(ls):\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                \n                lv = ls[i]\n                rv = ls[i + 1]\n                i += 2\n                if lv != \"None\":\n                    left = TreeNode(int(lv))\n                    node.left = left\n                    queue.append(left)\n                \n                if rv != \"None\":\n                    right = TreeNode(int(rv))\n                    node.right = right\n                    queue.append(right)\n        return root\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101551777","body":"```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Ideas:\n            {\n                2: [4],\n                1: [2],\n                0: [5, 1, 6}\n            } \n            ->\n            {\n                2: {2: [4]},\n                1: {1: [2]},\n                0: {0:[1], 2:[5, 6]}\n            } \n            save in dict + dict + list\n            sort x, sort y, sort value\n        TC: O(n) + O(nlogn) = O(nlogn)\n        SC: O(n)\n        \"\"\"\n        \n        seen = collections.defaultdict(lambda: collections.defaultdict(list))\n        \n        def dfs(root, x, y):\n            if not root: return\n            dfs(root.left,x - 1, y + 1)\n            seen[x][y].append(root.val)\n            dfs(root.right, x + 1, y + 1)\n        dfs(root, 0, 0)\n\n        ans = []\n        for x in sorted(seen):\n            level = []\n            for y in sorted(seen[x]):\n                level += sorted(seen[x][y])\n            ans.append(level)\n        return ans\n        \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102751044","body":"```python3\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        bruteforce\n        TC: O(n^2)\n        SC: O(1)\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            num = nums[i]\n            remain = target - num\n            for j in range(n):\n                if j == i: continue\n                if nums[j] == remain:\n                    return [i, j]\n        return [-1, -1]\n                \n                \n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Improve: use hash\n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        \n        remainders = {}        \n        for i in range(len(nums)):\n            if nums[i] in remainders:\n                return [remainders[nums[i]], i]\n            remainders[target - nums[i]] = i\n        \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104017406","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Ideas: sort + hash\n\n        TC: O(nlogn)\n        SC: O(n)\n        \"\"\"\n        count_map = {}\n        for num in nums:\n            count_map[num] = count_map.get(num, 0) + 1\n        \n        count_array = []\n        for key, v in count_map.items():\n            count_array.append((v, key))\n        \n        count_array.sort(key=lambda x: x[0], reverse=True)\n        ans = []\n        for i in range(k):\n            ans.append(count_array[i][1])\n    \n        return ans\n    \n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Ideas:\n            hash count + bucket sort\n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        bucket = [[] for _ in range(len(nums) + 1)]\n        counter = {}\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n        \n        for num, count in counter.items():\n            bucket[count].append(num)\n        \n        ans = []\n    \n        for i in range(len(bucket) - 1, -1, -1):\n            if k == 0:\n                break\n            if bucket[i] != []:\n                ans += bucket[i]\n                k -= len(bucket[i])\n        return ans\n    \n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Ideas:heap sort\n            hash + min heap (keep size k)\n        Other ideas: quick select -> may do it later\n        TC: O(nlogn)\n        SC: O(n)\n        \"\"\"\n        import heapq\n        heap = []\n        counter = {}\n        for num in nums:\n            counter[num] = counter.get(num, 0) + 1\n        for num, count in counter.items():\n            # print(num, count)\n            heapq.heappush(heap, (count, num))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        ans = []\n        for _ in range(k):\n            ans.append(heapq.heappop(heap)[1])\n        return ans\n        \n\n\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107885409","body":"```python\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Second Middle Node: 1->2->3->4->5->6 get 4\n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111950880","body":"```python\nclass Solution:\n    \n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Ideas:\n            Sliding Windows + Brute-Force\n        TC: O(n * k)\n        SC: O(1)\n        Improve: heap\n        \"\"\"\n        ans = []\n        \n        for i in range(len(nums) - k + 1):\n            max_value = max(nums[i:i+k])\n            ans.append(max_value)\n        return ans\n    \n    \n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Ideas: heap -> max heap\n            insert into new num, pop out if cur_max out of windows\n        TC: O(nlogk)\n        SC: O(k)\n        Improve: monostack\n        \"\"\"\n        import heapq \n        heap = []\n        for i in range(k):\n            heapq.heappush(heap, (-1 * nums[i], i))\n        \n        ans = [-1 * heap[0][0]]\n        for i in range(k, len(nums)):\n            heapq.heappush(heap, (-1 * nums[i], i))\n            while heap[0][1] < i - k + 1:\n                heapq.heappop(heap)\n            ans.append(-1 * heap[0][0])\n        return ans\n            \n    \n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        \"\"\"\n        Ideas: Decreasing Mono-queue -> get cur_max within size-k:\n            with max-k size queue -> only save cur max to cur element -> decreasing mono-queue / increasing mono-stack\n        TC: O(n)\n        SC: O(n)\n        Ref: https://github.com/azl397985856/leetcode/blob/master/problems/239.sliding-window-maximum.md\n        \"\"\"\n        q = collections.deque()\n        ans = []\n        \n        for i in range(len(nums)):\n            if q and i - q[0][0] >= k: q.popleft()\n            while q and q[-1][1] < nums[i]: q.pop()\n            q.append((i, nums[i]))\n            # print(q)\n            if i >= k - 1: ans.append(q[0][1])\n        return ans\n        \n        \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085768414","body":"## 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086627537","body":"## 思路\n两遍循环，先从左到右遍历s, 找到值左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。取两个值中的最小值。\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let cIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) cIndex = i;\n    res[i] = i - cIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086786982","body":"## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087143843","body":"## 思路\n栈，遇到 ']' 开始出栈，直到遇到 '[' 时停止，此时获取到字符串c，再出栈获取重复数量n，c.repeat(parseInt(n))得到重复之后的数，入栈\n\n## 代码\n```javascript\nvar decodeString = function(s) {\n  let stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === ']') {\n      let c = '';\n      let pre = stack.pop();\n      while(pre !== '[') {\n        c = pre + c;\n        pre = stack.pop();\n      }\n      let n = '';\n      let preN = stack.pop();\n      while(!isNaN(preN)) {\n        n = preN + n;\n        preN = stack.pop();\n      }\n      stack.push(preN);\n      stack.push(c.repeat(parseInt(n)));\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088277164","body":"## 思路\n定义两个栈，pop的时候，将stack1的数据全部pop到stack2，返回stack2栈顶的值，再将stack2全部pop回stack1\n\n## 代码\n```javascript\n\nvar MyQueue = function() {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this.stack1.length > 0) {\n    this.stack2.push(this.stack1.pop());\n  }\n  let res = this.stack2.pop();\n  while (this.stack2.length > 0) {\n    this.stack1.push(this.stack2.pop());\n  }\n  return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack1[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack1.length === 0;\n};\n\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090089935","body":"## 思路\n* 单调栈\n* 栈中存储每个块的最大值\n* 前一块的最大值不大于后一块的任意值，如果不是，要合并成同一块\n* 当前值小于栈顶元素时，说明当前元素是属于栈顶元素那一块，此时pop出栈顶元素，记录下当前块的最大值\n* 一直pop直到值小于等于当前值，再将当前块的最大值入栈\n* 最后返回栈的长度\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n  let stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (stack.length > 0 && arr[i] < stack[stack.length - 1]) {\n      let peek = stack.pop();\n      while (stack.length !== 0 && stack[stack.length - 1] > arr[i]) stack.pop();\n      stack.push(peek);\n    } else {\n      stack.push(arr[i]);\n    }\n  }\n  return stack.length;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091709146","body":"## 思路\n先遍历链表，获取链表的长度length，和尾节点tail。将尾节点指向头，形成环。向右旋转K位，意味着头指针要向前走 length - K 步。\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n  if (head === null || head.next === null) return head;\n  let tail = head;\n  let length = 1;\n  while (tail.next) {\n    tail = tail.next;\n    length++;\n  }\n  tail.next = head;\n  let num = length - k % length;\n  while (num > 0) {\n    head = head.next;\n    tail = tail.next;\n    num--;\n  }\n  tail.next = null;\n  return head;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092724134","body":"## 思路\n定义一个pre节点和next节点，位置分别在要交换的两个节点的前后。遍历交换节点。\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n  if (head === null || head.next === null) return head;\n  let res = new ListNode(0);\n  let p1 = head;\n  let p2 = head.next;\n  let pre = res;\n  pre.next = head;\n  while (p1 && p2) {\n    let next = p2.next;\n    p1.next = next;\n    p2.next = p1;\n    pre.next = p2;\n    pre = p1;\n    p1 = next;\n    p2 = p1 === null ? null : p1.next;\n  }\n  return res.next;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094060612","body":"## 思路\n用快慢指针查找链表的中间节点，中间节点就是父节点。\n\n从中间节点分成左右两个链表，再分别查找左右两个链表的中间节点作为左右子节点，以此类推\n\n\n## 代码\n```javascript\nvar sortedListToBST = function(head) {\n  if (head === null) return head;\n  if (head.next === null) return new TreeNode(head.val);\n  return getRoot(head, null);\n};\n\nlet getRoot = function(start, end) {\n  if (start === end) return null;\n  let fast = start, slow = start;\n  while (fast !== end && fast.next !== end) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return new TreeNode(slow.val, getRoot(start, slow), getRoot(slow.next, end));\n}\n```\n\n## 复杂度分析\n\n* time: O(nlogn), 递归二分 logn, 每一层递归的基本操作为n。\n* space: O(logn), 递归，递归栈的开销是递归的深度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094179521","body":"## 思路\na,b两个指针分别指向两个链表的头，相同的速度移动。a到达尾部时重新定位到B链表的头，b到达尾部时重新定位到A链表的头。a,b相遇的点就是起始交点。\n\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n  let pA = headA, pB = headB;\n  while (pA !== pB) {\n    pA = pA.next;\n    pB = pB.next;\n    if (pA === null && pB !== null) pA = headB;\n    if (pB === null && pA !== null) pB = headA;\n  }\n  return pA;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095037648","body":"## 思路\n寻找环的入口，定义快慢指针，快指针每次走两步，慢指针每次走一步。\n\n两个指针第一次相遇时，将快指针指向头部，改成每次走一步。两个指针第二次相遇是就是环的入口。\n\n注意如果第一次相遇是在头部，说明头就是入口，直接返回\n\n## 代码\n```javascript\nvar detectCycle = function(head) {\n  if (head === null || head.next === null) return null;\n  let fast = head, slow = head;\n  let count = 0;\n  while (fast && fast.next) {\n    slow = slow.next;\n    if (count === 0) fast = fast.next.next;\n    else fast = fast.next;\n    if (slow === fast) {\n      if (head === fast) return head;\n      if (count === 0) {\n        fast = head;\n        count++;\n      } else {\n        return fast;\n      }\n    }\n  }\n  return null;\n};\n```\n\n## 复杂度分析\n\n* time:  O(n)\n* space:  O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096708772","body":"## 思路\n哈希表加双向链表\n\n哈希表存储 key, node; node 存储key, value\n\nput时更新或者新建node, 并且将node插入到链表头部。如果长度溢出了，则删除链表的尾部节点\n\nget时，通过哈希表获取到node，将node移到链表头部（移动node时可以先将node从该位置删除，在插入到头部）\n\n## 代码\n```javascript\nfunction ListNode(val, key) {\n  this.val = val;\n  this.key = key;\n  this.next = null;\n  this.pre = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n  this.head = new ListNode(0);\n  this.tail = new ListNode(0);\n  this.head.next = this.tail;\n  this.tail.pre = this.head;\n  this.map = new Map();\n  this.size = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n  if (this.map.has(key)) {\n    let node = this.map.get(key);\n    this.moveNodeInHead(node);\n    return node.val;\n  }\n  return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n  if (this.map.has(key)) {\n    let node = this.map.get(key);\n    node.val = value;\n    this.moveNodeInHead(node);\n  } else {\n    let node = new ListNode(value, key);\n    this.map.set(key, node);\n    let next = this.head.next;\n    this.head.next = node;\n    node.pre = this.head;\n    node.next = next;\n    next.pre = node;\n    if (this.map.size > this.size) this.deleteNodeInTail();\n  }\n};\n\nLRUCache.prototype.moveNodeInHead = function(node) {\n  let pre = node.pre;\n  let next = node.next;\n  pre.next = next;\n  next.pre = pre;\n  let hnext = this.head.next;\n  this.head.next = node;\n  node.pre = this.head;\n  node.next = hnext;\n  hnext.pre = node;\n}\n\nLRUCache.prototype.deleteNodeInTail = function() {\n  let node = this.tail.pre;\n  this.map.delete(node.key);\n  let p = node.pre;\n  p.next = this.tail;\n  this.tail.pre = p;\n  node.next = null;\n  node.pre = null;\n}\n```\n\n## 复杂度分析\n\n* time: O(1)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098101186","body":"## 思路\n先序遍历，记录每个节点所在的层数level。当遍历到叶子节点时，取当前叶子节点的层数，和已记录的最大层数num比较，存储较大值\n\n## 代码\n```javascript\nvar maxDepth = function(root) {\n  let num = 0;\n  let preOrder = function(root, level) {\n    if (!root) return;\n    if (!root.left && !root.right) num = Math.max(num, level);\n    preOrder(root.left, level + 1);\n    preOrder(root.right, level + 1);\n  };\n  preOrder(root, 1);\n  return num;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098736033","body":"## 思路\n同时前序遍历两个二叉树，比较两个treeNode的值。不相等返回false，如果两个node同时为空，说明完全相等，返回true\n\n## 代码\n```javascript\nvar isSameTree = function(p, q) {\n  return preorder(p, q);\n};\n\nlet preorder = function(p, q) {\n  if (p === null && q === null) return true;\n  if (p === null || q === null || p.val !== q.val) return false;\n  let left = preorder(p.left, q.left);\n  if (!left) return false;\n  return preorder(p.right, q.right);\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100015298","body":"## 思路\n先序遍历，拼接前一个结点的值和当前节点的值，直到叶子节点，这条路径的值即拼接完毕，将拼接的字符串转换成Number后添加到结果res中\n\n## 代码\n```javascript\nvar sumNumbers = function(root) {\n  let res = 0;\n  let preOrder = function(root, preVal) {\n    if(!root) return;\n    let num = preVal + root.val;\n    if (!root.left && !root.right) res += parseInt(num);\n    preOrder(root.left, num);\n    preOrder(root.right, num);\n  };\n  preOrder(root, '');\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100619789","body":"## 思路\nBFS, 层序遍历，用一个队列记录每一层的所有节点，队列的第一个数据就是该层最左边的节点\n\n## 代码\n```javascript\nvar findBottomLeftValue = function(root) {\n  let currentLevel = [root];\n  let res = root.val;\n  while(currentLevel.length > 0) {\n    let nextLevel = [];\n    for (let i = 0; i < currentLevel.length; i++) {\n      if (currentLevel[i].left) nextLevel.push(currentLevel[i].left);\n      if (currentLevel[i].right) nextLevel.push(currentLevel[i].right);\n    }\n    if (nextLevel.length > 0) res = nextLevel[0].val;\n    currentLevel = nextLevel;\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(q), q为队列长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100823686","body":"## 思路\nserialize，层序遍历，将值存储到数组中，假设二叉树为完全二叉树，缺失的节点用null补上，最后将得到的数组转换成字符串返回\n\ndeserialize，将字符串参数转换成数组，指针i从0开始移动，i+1为左节点，i+2为右节点，生成的左右节点push到队列queue中。i每次增加2，每次循环从队列中出队获取当前节点\n\n## 代码\n```javascript\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n  if (!root) return '';\n  let res = [], currentLevel = [root];\n  while (currentLevel.length > 0) {\n    let nextLevel = [];\n    for (let i = 0; i < currentLevel.length; i++) {\n      if (currentLevel[i]) {\n        nextLevel.push(currentLevel[i].left);\n        nextLevel.push(currentLevel[i].right);\n        res.push(currentLevel[i].val);\n      } else {\n        res.push('null');\n      }\n    }\n    currentLevel = nextLevel;\n  }\n  return res.toString();\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  if (data === '') return null;\n  let arr = data.split(',');\n  let root = new TreeNode(arr[0]);\n  let queue = [root];\n  let i = 0;\n  while (i + 2 < arr.length) {\n    let node = queue.shift();\n    if (arr[i + 1] === 'null') node.left = null;\n    else {\n      let left = new TreeNode(arr[i + 1]);\n      node.left = left;\n      queue.push(left);\n    }\n    if (arr[i + 2] === 'null') node.right = null;\n    else {\n      let right = new TreeNode(arr[i + 2]);\n      node.right = right;\n      queue.push(right);\n    }\n    i += 2;\n  }\n  return root;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101383337","body":"## 思路\nDFS, 先序遍历，记录每个节点的row和col，存储到map中，map中col为key值，value为对象数组[{row: row, val: root.val}]。\n\n对map的key排序，遍历key获取map的值，将取出来的数组根据row和val的值排序（先比较row的大小，row相同再比较val），再将排序好的数组push到结果数组res中。\n\nmap: { 0：[ {row: row, val: root.val} ] }\n\n## 代码\n```javascript\nvar verticalTraversal = function(root) {\n  let map = new Map();\n  let keys = [], res = [];\n  let preOrder = function(root, row, col) {\n    if (!root) return;\n    if (map.has(col)) map.get(col).push({row: row, val: root.val});\n    else {\n      map.set(col, [{row: row, val: root.val}]);\n      keys.push(col);\n    }\n    preOrder(root.left, row + 1, col - 1);\n    preOrder(root.right, row + 1, col + 1);\n  };\n  preOrder(root, 0, 0);\n  keys.sort((a,b) => { return a - b; });\n  for (let i = 0; i < keys.length; i++) {\n    let arr = map.get(keys[i]);\n    arr.sort((a,b) => {\n      if (a.row === b.row) return a.val - b.val;\n      else return a.row - b.row;\n    });\n    res.push(arr.map(val => {return val.val}));\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(nlogn)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102500282","body":"## 思路\n哈希表, map存储数据，数值为key，下标为value\n\n遍历nums数组，计算出target和当前值的差值val，如果map中包含val，则返回当前下标和val的下标\n\n若map中不包含val，则将当前值和下标存入map\n\n## 代码\n```javascript\nvar twoSum = function(nums, target) {\n  let map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    let val = target - nums[i];\n    if (map.has(val)) return [map.get(val), i];\n    else map.set(nums[i], i);\n  }\n  return [];\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103886219","body":"## 思路\n哈希表，累计nums中每个值的个数，存储到哈希表中。再用set将数组去重，之后sort排序，返回前k个即可\n\n## 代码\n```javascript\nvar topKFrequent = function(nums, k) {\n  let map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    if (map.has(nums[i])) map.set(nums[i], map.get(nums[i]) + 1)\n    else map.set(nums[i], 1);\n  }\n  let n = [...new Set(nums)];\n  n.sort((a,b) => { return map.get(b) - map.get(a); });\n  return n.slice(0, k);\n};\n```\n\n## 复杂度分析\n\n* time: O(nlogn)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105141170","body":"## 思路\n两点[x1, y1]和[x2, y2]之间的距离 d = (x1-x2)² + (y1-y2)², d开根就是两点的距离。\n\n排列：从n个数中取出m个数能组合的排列数 -> n(n-1)(n-2)...(n-m+1)\n\n两个循环遍历，计算出每个点到其它点之间的距离，存到map中，距离distance为key值，value为跟当前点距离相同的点的个数。固定当前点为第一个数，取出具有相同distance的点的个数 n, 从n中取两个数能组合的排列数就是当前的结果数量。\n\n## 代码\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n  let map = new Map(), count = 0;\n  let getDistance = function(p1, p2) {\n    let x = p1[0] - p2[0];\n    let y = p1[1] - p2[1];\n    return x * x + y * y;\n  }\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      let distance = getDistance(points[j], points[i]);\n      if (map.has(distance)) map.set(distance, map.get(distance) + 1);\n      else map.set(distance, 1);\n    }\n    map.forEach((val, key) => { if (val > 1) count += val * (val - 1); });\n    map.clear();\n  }\n  return count;\n};\n```\n\n## 复杂度分析\n\n* time: O(n²)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106540763","body":"### 思路\n滑动窗口，可变窗口大小,用set存储子串，set中包含当前字符时移动左指针\n\n### 代码\n```\nvar lengthOfLongestSubstring = function(s) {\n  let l = 0, set = new Set();\n  let res = 0;\n  for (let i = 0; i < s.length; i++) {\n    while (set.has(s[i])) {\n      res = Math.max(res, set.size);\n      set.delete(s[l]);\n      l++;\n    }\n    set.add(s[i]);\n  }\n  return Math.max(res, set.size);\n};\n```\n### 复杂度\ntime: O(n)\n\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107451243","body":"## 思路\n先用一个map存储words中的字符，字符为key，数量为value。计算words总长度 words[0].length*words.length。\n\n遍历字符串s，从当前位置left开始截取长度为words总长度的字符串y，将y按words[0]的长度分解出单词，将分解出的单词存储到map2中。\n\n比较map和map2中每个单词的数量。\n\n## 代码\n```\nvar findSubstring = function(s, words) {\n  let map = new Map(), map2 = new Map();\n  for (let i = 0; i < words.length; i++) {\n    if (map.has(words[i])) map.set(words[i], map.get(words[i]) + 1);\n    else map.set(words[i], 1);\n  }\n  let single = words[0].length;\n  let wordsLength = single * words.length;\n  let left = 0, res = [];\n  while (left < s.length - wordsLength + 1) {\n    let end = wordsLength + left, start = left;\n    map2.clear();\n    for (; start < end; start += single) {\n      let key = s.substr(start, single);\n      if (!map.has(key)) break;\n      if (map2.has(key)) map2.set(key, map2.get(key) + 1);\n      else map2.set(key, 1);\n      if (map2.get(key) > map.get(key)) break;\n    }\n    if (start === end) res.push(left);\n    left++;\n  }\n  return res;\n};\n```\n## 复杂度\ntime: O(n * m * k) n: s的长度，m: words的长度，k: 单个word的长度\n\nspace: O(m), m为words长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107840332","body":"头秃，看答案都看不懂==\n\n```\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = floorMod(currSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108427141","body":"## 思路\n快慢指针，快指针每次走两步，慢指针每次走一步。快指针走到终点时，慢指针刚好到中间。\n\n## 代码\n```\nvar middleNode = function(head) {\n  let fast = head, low = head;\n  while (fast && fast.next) {\n    fast = fast.next.next;\n    low = low.next;\n  }\n  return low;\n};\n```\n## 复杂度\ntime: O(n)\n\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109607634","body":"### 思路\n双指针。index指针表示结果数组的当前位置。遍历nums，当nums[i] 不等于 nums[i+1]时，说明nums[i+1]是第一个新的不重复的值，将这个值存储到index的位置。最后返回index值，index值就是结果数组的长度。\n\n### 代码\n```\nvar removeDuplicates = function(nums) {\n  let index = 1;\n  for (let i = 0; i < nums.length - 1; i++) {\n    if (nums[i] !== nums[i + 1]) {\n      nums[index] = nums[i + 1];\n      index++;\n    }\n  }\n  return index;\n};\n```\n\n### 复杂度\ntime: O(n)\n\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110857422","body":"### 思路\n二分查找，两个指针分别指向头和尾，取中间的节点center跟target比较大小。若 center > target,则尾部的指针移动到center。center < target,则头部指针移动到center。若相等则center就是所求位置。\n\n### 代码\n```javascript\nvar searchInsert = function(nums, target) {\n  if (nums[0] >= target) return 0;\n  if (nums[nums.length - 1] < target) return nums.length;\n  let left = 0, right = nums.length - 1;\n  while (left < right) {\n    let center = left + Math.floor((right - left + 1) / 2);\n    if (center === left || center === right) return center;\n    if (nums[center] > target) right = center;\n    else if (nums[center] < target) left = center;\n    else return center;\n  }\n  return left;\n};\n```\n### 复杂度\ntime: O(log(n))\n\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112192050","body":"### 思路\n建立一个递减的双端队列，存储窗口中的值。窗口移动时，入队的数小于等于队尾时直接入队，若大于队尾则一直出队直到数字不大于队尾。\n\n（要寻找最大值，所以队尾小于当前数字的值都无价值，需要出队抛弃掉）。\n\n左指针需要出队的失效元素，如果小于队头，根据入队规则说明之前已经被抛弃掉了，所以不做处理，等于队头的时候才要移除队头。\n\n### 代码\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n  let queue = [nums[0]];\n  for (let i = 1; i < k; i++) pushVal(nums[i], queue);\n  let res = [queue[0]];\n  let left = 0, right = k - 1;\n  while (right + 1 < nums.length) {\n    if (nums[left] >= queue[0]) queue.shift();\n    pushVal(nums[right + 1], queue);\n    res.push(queue[0]);\n    left++;\n    right++;\n  }\n  return res;\n};\n\n// 入队\nlet pushVal = function(val, queue) {\n  if (val <= queue[queue.length - 1]) queue.push(val);\n  else {\n    while (queue[queue.length - 1] < val) queue.pop();\n    queue.push(val);\n  }\n};\n```\n\n### 复杂度\ntime: O(n)\n\nspace: O(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113341177","body":"### 思路\n图的基本知识，定义两个数组，记录入度和出度。入度=n-1并且出度=0的点是要寻找的点\n\n### 代码\n```javascript\nvar findJudge = function(n, trust) {\n  let inArray = new Array(n).fill(0);\n  let outArray = new Array(n).fill(0);\n  for (let i = 0; i < trust.length; i++) {\n    outArray[trust[i][0] - 1] += 1;\n    inArray[trust[i][1] - 1] += 1;\n  }\n  for (let i = 0; i < n; i++) {\n    if (inArray[i] === n - 1 && outArray[i] === 0) return i+1;\n  }\n  return -1;\n};\n```\n\n### 复杂度\ntime: O(n)\n\nspace: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sallyrubyjade":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085802765","body":"### 思路\n从数组最后一位开始遍历，并取出k的个位数进行相加，再对k进行除10处理来保证每次取出的都是最末位，然后对判断相加数是否大于10，是的话要进一位（记得把这个进位带进下一次数组循环里），把相加数的个位数放在要返回数组的开头。最后判断k或者进位是否处理干净，因为可能k的位数比num数组长度大，进行循环，直到k为0。\n\n### 代码\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let ans = [];\n    let carry = 0;\n    for (let i = num.length - 1; i >= 0; i--) {\n        let temp = num[i] + (k % 10) + carry;\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    while (carry != 0 || k > 0){\n        let temp = carry + (k % 10);\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086623359","body":"### 思路\n遍历字符串，对每一个字符元素，使用左右指针思想，分别向左和向右寻找最近的字符c，使用Math.min()进行对比，找到最短距离，把值放进数组中，再对下一个字符元素进行相同操作，直到遍历结束。\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let ans = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            ans.push(0);\n            continue;\n        }\n\n        let left = i;\n        let right = i;\n        let shortest = Number.MAX_VALUE;\n\n        while(left >= 0) {\n            if(s[left] === c) {\n                shortest = Math.min(shortest, i - left);\n                break;\n            }\n            left--;\n        }\n\n        while(right <= s.length - 1) {\n            if (s[right] === c) {\n                shortest = Math.min(shortest, right - i);\n                break;\n            }\n            right++;\n        }\n        ans.push(shortest);\n    }\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792767","body":"### 思路\n用数组模拟栈，push和pop直接用数组的原生方法，但要对数组的长度进行判断，increment方法要比较数组长度大小与k值大小，选择偏小值对这个范围内的数组元素加上增量。\n\n### 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize) this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.list.length > 0) {\n        return this.list.pop();\n    }else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.list.length <= k) {\n        for(let i = 0; i < this.list.length; i++) {\n            this.list[i] += val;\n        }\n    }else {\n        for(let i = 0; i < k; i++) {\n            this.list[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n- 时间复杂度：初始化对象CustomStack O(1)，push操作 O(1)，pop操作 O(1)，increment操作 O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087584892","body":"### 思路\n遇到`]`字符之前所有元素都入栈，碰到`]`之后，一个个出栈判断，构建好内层顺序\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = [];\n    for(let char of s) {\n        if(char !== ']') {\n            stack.push(char);\n            continue;\n        }\n        // 当遇到‘]’后\n        let temp = stack.pop();\n        let str = '';\n        while(temp !== '[') {\n            str = temp + str;\n            temp = stack.pop();\n        }\n        let number = '';\n        temp = stack.pop();\n        while(!isNaN(temp)) {\n            number =  temp + number;\n            temp = stack.pop();\n        }\n        stack.push(temp);\n        stack.push(str.repeat(Number(number)));\n    }\n    return stack.join('');\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088635019","body":"### 思路\n利用两个栈实现队列，javascript中没有栈结构，用数组模拟栈。重点在于peek和pop操作时，两个栈怎么互动：将之前push到一个栈中的元素，依次弹出，放入另一个空的栈中，就可以保证最先加进的元素，在第一个栈的栈底变成另一个栈的栈顶，达到先出的效果。\n\n### 代码\n```javascript\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.peek();\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length) {\n        while (this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    let ans1 = true;\n    let ans2 = true;\n    if (this.stack1.length) {\n        ans1 = false;\n    }\n    if(this.stack2.length) {\n        ans2 = false;\n    }\n\n    return ans1 && ans2;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n### 复杂度分析\n- 时间复杂度：pop操作和peek操作为O(n)，push和empty为O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090183055","body":"### 思路\n将现有数组和排序后数组比较，因为如果满足分块条件，此时的数组和应该一致，比如[3, 7, 5] 与 [3, 5, 7]，可以分成两块[3]、[7, 5]，因为index为0时，数组和相等，index到2时，数组和又一次相等 。遍历数组，逐位检查数组和，相等多少次，就可以分成多少块。\n\n### 代码\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let sortedArr = arr.slice().sort((a, b) => a - b);\n\n    let num = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sortedArr[i];\n\n        if(sum1 === sum2) {\n            num++;\n        }\n    }\n\n    return num;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091692399","body":"### 思路\n第一遍遍历链表得到链表长度和最后一个节点，判断链表长度和k的数量关系，将最后一个节点连接头节点，闭合成环，只需再遍历一次链表，找到需要断开的位置即可。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next) {\n        return head;\n    }\n    let cur = head;\n    let len = 1;\n\n    while(cur.next) {\n        len++;\n        cur = cur.next;\n    }\n\n    let num = k % len;\n    if (num === 0) {\n        return head;\n    }\n    \n    cur.next = head;\n    cur = head;\n    for (let i = 0; i < len - num - 1; i++) {\n        cur = cur.next;\n    }\n    let newHead = cur.next;\n    cur.next = null;\n    return newHead;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093838514","body":"### 思路\n递归建立左右子树\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (head == null) return null;\n    let len = 0;\n    let h = head;  \n    while (head) { \n        len++;\n        head = head.next;\n    }\n\n    const buildBST = (start, end) => {\n        if (start > end) return null;     \n        const mid = (start + end) >>> 1;  \n        const left = buildBST(start, mid - 1); \n\n        const root = new TreeNode(h.val);      \n        h = h.next;                \n        root.left = left;  \n\n        root.right = buildBST(mid + 1, end);\n        return root;\n    };\n\n    return buildBST(0, len - 1);\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094261757","body":"### 思路\n双指针法，cursorA和cursorB同时从A，B出发，分别遍历俩链表，到达链表尾时，再分别从另个一链表头再开始从头遍历，如果两个链表有相交节点，那么两个指针一定会碰到一起，因为时间相同，走的路程长度相同。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) {\n        return null;\n    }\n    let cursorA = headA;\n    let cursorB = headB;\n    let count1 = 0;\n    let count2 = 0;\n\n    while (cursorA != cursorB) {\n        cursorA = cursorA.next;\n        cursorB = cursorB.next;\n        if (!cursorA) {\n            count1++;\n            cursorA = headB;\n            if (count1 > 1) {\n                break;\n            }\n        }\n        if (!cursorB) {\n            count2++;\n            cursorB = headA;\n            if (count2 > 1) {\n                break;\n            }\n        }\n    }\n    if (count1 > 1 || count2 >1) {\n        return null;\n    }else {\n        return cursorA;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094801347","body":"### 思路\n快慢指针，设定快指针一次走的长度是快指针的两倍，如果存在环的话，快指针一定会在环内超过慢指针，假设此时慢指针走的路程为k，那么快指针走的路程为2k，多走的k是环长度的n倍。假设入环点到相遇点的距离为m，那么链表头到入环点的距离为k - m，而根据之前的分析，从相遇点再走k - m步我们也可以确定来到入环点，那么让一个指针从头开始，一个链表从相遇点开始，从头开始的链表走到入环点时，两者一定会相遇。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            fast = head;\n\n            while (fast != slow) {\n                fast = fast.next;\n                slow = slow.next;\n            }\n            \n        return fast;\n        }\n    }\n\n    return null;   \n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096900702","body":"### 思路\n利用`Map`这个 ES6 新增数据结构是有序的，即不仅可以存储键值对(关键字-值)，还可以通过 delete 和 set 的 API 对数据进行更新，最后 set 的数据默认在 Map 的末尾。\n\n### 代码\n```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map.has(key)) {\n        let val = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key, val);\n        return val;\n    }else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    \n    // put 后判断是否超载\n    if(this.map.size > this.capacity){\n        this.map.delete(this.map.keys().next().value);\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097589601","body":"### 思路\nDFS, 找出终止条件：当前节点为空，找出返回值：节点为空时说明高度为 0，所以返回 0；节点不为空时则分别求左右子树的高度的最大值，同时加1表示当前节点的高度，返回该数值。\n\n### 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n\n    let depthL = maxDepth(root.left);\n    let depthR = maxDepth(root.right);\n\n    return Math.max(depthL, depthR) + 1;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)，即最好情况O(logn)，最坏情况O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099192122","body":"### 思路\n层序遍历\n\n### 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    let pQueue = [p];\n    let qQueue = [q];\n    let res = true;\n\n    while(pQueue.length && qQueue.length) {\n        let pNode = pQueue.shift();\n        let qNode = qQueue.shift();\n\n        if(pNode === null && qNode === null) {\n            res = true;\n        }else if(pNode === null || qNode === null) {\n            res = false;\n            break;\n        }else{\n            if(pNode.val != qNode.val) {\n                res = false;\n                break;\n            }else {\n                pQueue.push(pNode.left);\n                pQueue.push(pNode.right);\n                qQueue.push(qNode.left);\n                qQueue.push(qNode.right);\n            }\n\n        }\n    }\n\n    return res;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099802296","body":"### 思路\n层序遍历，根据父节点计算每个节点当前的代表数字，判断当前节点是否为叶子节点，如果是，就把此代表数字加入总和。\n\n### 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (!root) {\n        return 0;\n    }\n\n    let queue = [root];\n    let ans = 0;\n    while (queue.length) {\n        let node = queue.shift();\n        if (!node.left && !node.right) {\n            ans += node.val;\n        }\n\n        if (node.left) {\n            node.left.val += node.val * 10;\n            queue.push(node.left);\n        }\n        if (node.right) {\n            node.right.val += node.val * 10;\n            queue.push(node.right);\n        }\n    }\n    return ans;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100582085","body":"### 思路\nBFS，每一层取queue中第一个元素的值，遍历完，更新为最后一层第一个元素的值。\n\n### 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let queue = [root];\n    \n    let left;\n    while (queue.length) {\n        let curNum = queue.length;\n\n        left = queue[0].val;\n        while (curNum--) {\n            let node = queue.shift();\n            node.left && queue.push(node.left);\n            node.right && queue.push(node.right);\n        }\n    }\n    return left;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100881963","body":"### 代码\n```javascript\nvar serialize = function(root) {\n    if(!root) return '#';\n    const value = root.val;\n    const leftValue = serialize(root.left);\n    const rightValue = serialize(root.right);\n    const str =  `${value},${leftValue},${rightValue}`;\n    return str;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const dataArray = data.split(',').reverse();\n    const transform = (nodes) => {\n        if(nodes.length === 0) return null;\n        const value = nodes.pop();\n        if(value === '#') return null;\n        let root = new TreeNode(parseInt(value));\n        root.left = transform(nodes);\n        root.right = transform(nodes);\n        return root;\n    };\n    return transform(dataArray);\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101186768","body":"### 思路\nBFS遍历，遍历得到每个节点，并记录下每个节点的row值和column值。先对node数组按按col值排序，再对整个数组进行分组处理。\n\n### 代码\n```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    // sortNode逻辑\n    // 先按垂序排序，如果垂直相等，按node.val排序\n    let sortNode = (nodes) => {\n        nodes.sort((a, b) => {\n            if (a.row === b.row) {\n                return a.val - b.val;\n            }\n            return a.row - b.row;\n        });\n        let curArr = [];\n        nodes.forEach((cur) => {\n            curArr.push(cur.val);\n        })\n        return curArr;\n    }\n    // 先BFS\n    let queue = [root];\n    let nodes = [root];\n    root.row = 0;\n    root.col = 0;\n    while (queue.length) {\n        let node = queue.shift();\n\n        if (node.left) {\n            node.left.row = node.row + 1;\n            node.left.col = node.col - 1;\n            queue.push(node.left);\n            nodes.push(node.left);\n        }\n        if (node.right) {\n            node.right.row = node.row + 1;\n            node.right.col = node.col + 1;\n            queue.push(node.right);\n            nodes.push(node.right);\n        }\n    }\n    nodes.sort((a, b) => a.col - b.col);\n    let ans = [];\n    let temp = [];\n    for (let i = 0; i < nodes.length; i++) {\n        temp.push(nodes[i]);\n        if (i != nodes.length - 1) {\n            if (nodes[i].col != nodes[i+1].col) {\n                ans.push(sortNode(temp));\n                temp = [];\n            }\n        }\n    }\n    ans.push(sortNode(temp));\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102408637","body":"### 思路\n哈希表储存遍历过的元素和对应的索引\n\n### 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    let prevNums = {};\n\n    for (let i = 0; i < nums.length; i++) {\n        let targetNum = target - nums[i];\n        if (prevNums[targetNum] !== undefined) {\n            return [prevNums[targetNum], i];\n        }else {\n            prevNums[nums[i]] = i;\n        }\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103824422","body":"### 思路\n利用map储存每个数字出现的频率，然后将map转成数组进行排序，截取排序后的前k的元素即是结果。\n\n### 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (!map.has(nums[i])) {\n            map.set(nums[i], 1);\n        }else {\n             map.set(nums[i], map.get(nums[i]) + 1);\n        }\n    }\n    let sorted = Array.from(map).sort((a, b) => b[1] - a[1]);\n    \n    return sorted.slice(0, k).map(n => n[0]);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105257930","body":"### 思路\n查表\n\n### 代码\n```javascript\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n        let ans = 0;\n        for (const p of points) {\n            const m = new Map();\n            for (const q of points) {\n            //统计距离当前点相同距离的数量 加入map中\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            m.set(dis, (m.get(dis) || 0) + 1);\n        }\n\n        for (const [_, item] of m.entries()) {\n            ans += item * (item - 1);\n        }\n    }\n    return ans;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106485820","body":"### 思路\n滑动窗口\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let arr = [];\n    let max = 0;\n    for (let i = 0; i < s.length; i++) {\n        let index = arr.indexOf(s[i]);\n        if (index !== -1) {\n            arr.splice(0, index+1);\n        }\n        arr.push(s[i]);\n        max = Math.max(max, arr.length);\n    }\n    return max;\n};\n```\n\n### 复杂度分析：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107478060","body":"### 代码\n```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    if (!words || !words.length) return[];\n\n    let wordLen = words[0].length;\n    let allWordsLen = wordLen * words.length;\n    let ans = [], wordMap = {};\n    for (let w of words) {\n        wordMap[w] ? wordMap[w]++ :wordMap[w] = 1\n    }\n    for (let i = 0; i < s.length - allWordsLen + 1; i++) {\n        let wm = Object.assign({}, wordMap);\n\n        for (let j = i; j < i + allWordsLen - wordLen + 1; j += wordLen) {\n            let w = s.slice(j, j + wordLen);\n            if (wm[w]) {\n                wm[w]--\n            } else {\n                break;\n            }\n        }\n        if (Object.values(wm).every(n => n === 0)) ans.push(i);\n    }\n    return ans;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108524342","body":"### 思路\n快慢指针，快慢指针同时从链表头开始，快指针一次走两步，慢指针一次走一步，知道快指针到链表尾停止。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    return slow;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109938917","body":"### 思路\n双指针\n\n### 代码\n```javascript\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    if(!nums.length) return 0;\n    let i = 0;\n    for(let j = 1; j < nums.length; j++){\n        if(nums[j] !== nums[i]){\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110932076","body":"### 思路\n二分查找\n\n### 代码\n```javascript\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    const n = nums.length;\n    let left = 0, right = n - 1, ans = n;\n    while (left <= right) {\n        let mid = ((right - left) >> 1) + left;\n        if (target <= nums[mid]) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ans;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113427913","body":"### 代码\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @param {number[][]} trust\r\n * @return {number}\r\n */\r\nvar findJudge = function(n, trust) {\r\n    let cnts = new Array(n + 1), out = new Array(n + 1)\r\n    cnts.fill(0)\r\n    out.fill(0)\r\n    for(let t of trust){\r\n        cnts[t[1]]++\r\n        out[t[0]]++\r\n    }\r\n    for(let i = 1; i <= n; i++)\r\n        if(out[i] == 0 && cnts[i] == n - 1)\r\n            return i\r\n    return -1\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meemx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085804058","body":"### 思路\r\n从最低位（num数组最后一位开始），逐位相加\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        length = len(num)\r\n        result = []\r\n\r\n        for i in range(length - 1, -1, -1):\r\n            sum = num[i] + k % 10\r\n            k = k // 10\r\n            if sum >= 10:\r\n                k = k + sum // 10\r\n                sum = sum % 10\r\n            result.append(sum)\r\n\r\n        # 若A长度小于整数K\r\n        while k > 0:\r\n            sum = k % 10\r\n            k = k // 10\r\n            result.append(sum)\r\n\r\n        # 逆序输出\r\n        return result[::-1]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086569073","body":"### 思路\r\n\r\n- 第一遍：从左向右遍历\r\n- 第二遍：从右向左遍历，同时取最小值\r\n\r\n### 代码\r\n\r\n```pthon3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        # 第一遍 从左向右遍历\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n\r\n        # 第二遍 从右向左遍历 同时取最小值\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883737","body":"### 思路\r\n\r\n使用数组进行模拟，操作即较为简单与高效\r\n\r\n### 代码\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```\r\n\r\n### 时间复杂度\r\n\r\n- 时间复杂度：push是O(1)、pop是O(1)、increment是O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087195117","body":"### 思路\r\n\r\n使用栈\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                strs = ''\r\n                repeat = ''\r\n                while stack[-1] != '[':\r\n                    strs = stack.pop() + strs\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    repeat = stack.pop() + repeat\r\n                stack.append(int(repeat) * strs)\r\n                continue\r\n            stack.append(i)\r\n        return ''.join(stack)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088189776","body":"### 思路\r\n\r\n使用两个栈，如同两个杯子倒水一样进行操作\r\n\r\n### 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        res = self.stack_pop.pop()\r\n        return res\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(1) O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090375779","body":"### 思路\r\n将数组进行排序，随后计算加和，比较原数组和排序后数组的累积和\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        pre1,pre2=0,0\r\n        res=0\r\n        for a,b in zip(arr,sorted(arr)):\r\n            pre1+=a\r\n            pre2+=b\r\n            if pre1==pre2:\r\n                res+=1\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：取决于排序算法\r\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096665670","body":"### 思路\r\n利用双向链表进行记录\r\n\r\n### 代码\r\n\r\n```python3\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O（1）\r\n空间复杂度：O（N）","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101019030","body":"### 思路\r\n从根节点开始，对整棵树进行一次遍历，并在遍历过程中使用数组记录信息\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        \r\n        return ans\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间：O(nlogn)\r\n- 空间：O(n)\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107857491","body":"参考答案了\r\n\r\n```python3\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        s = sum(nums)\r\n        if s%k==0:\r\n            return 0\r\n        dic = {0:-1}\r\n        mod = s%k\r\n        total = 0\r\n        ans = len(nums)\r\n        for i in range(len(nums)):\r\n            total += nums[i]\r\n            cur = total % k\r\n            target = (cur -mod +k)%k\r\n            if target in dic:\r\n                ans = min(ans, i - dic[target])\r\n            dic[cur] = i\r\n        return -1 if ans == len(nums) else ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moonlee001":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085808810","body":"## 思路\n将k转化为数组，利用双指针倒序相加。\n## 代码\nvar addToArrayForm = function(num, k) {\n    const arrK = k.toString().split('');\n    const n = num.length;\n    const m = arrK.length;\n    let p1 = n - 1, p2 = m - 1;\n    let res = [];\n    let carry = 0;\n    while (p1 >= 0 || p2 >= 0) {\n        const num1 = p1 < 0 ? 0 : num[p1];\n        const num2 = p2 < 0 ? 0 : arrK[p2] - 0;\n        const sum = num1 + num2 + carry;\n        const mode = sum % 10;\n        carry = Math.floor(sum / 10);\n        res.unshift(mode);\n        p1--;\n        p2--;\n    }\n    if (carry) {\n        res.unshift(carry);\n    }\n    return res;\n};\n\n## 复杂度\n时间：O(n)\n空间： O(m) m为数字个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597227","body":"### 思路\n两次遍历字符串，取最小值。\n\n### 代码\n\n\n```js\nvar shortestToChar = function(S, C) {\n  let n = S.length;\n  let prev = -Infinity;\n  let ans = [];\n  for (let i = 0; i < n; i++) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = i - prev;\n  }\n  \n  prev = Infinity;\n  for(let i = n - 1; i >= 0; i--) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = Math.min(prev - i, ans[i]);\n  }\n  \n  return ans;\n\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797204","body":"### 思路\n使用数组模拟栈，inc使用空间换取时间，存储增量，如果需要pop的时候再将增量加到对应的值\n\n### 代码\n\n```javascript\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = stack;\n  this.map = new Map();\n}\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n}\n\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  } \n  const inc = this.map.get(this.stack.length) || 0;\n  this.map.set(this.stack.length - 1, (this.map.get(this.stack.length - 2) || 0) + inc);\n  this.map.set(this.stack.length, 0);\n  return this.stack.pop() + inc;\n}\n\nCustomStack.prototype.increment = function(k, val) {\n  const index = Math.min(k, this.stack.length) - 1;\n  if (index < 0) {\n    return;\n  }\n  this.map.set(index, (this.map.get(index) || 0) + val);\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087492216","body":"### 思路\r\n使用栈存储S，如果遇到右括号，则栈出，然后将处理好的字符在存入栈。\r\n\r\n### 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    const n = s.length;\r\n    let res = '';\r\n    for (let i = 0; i < n; i++) {\r\n        const cur = s.charAt(i);\r\n        if (cur == ']') {\r\n            let str = '';\r\n            while (stack.length && stack[stack.length - 1] !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            stack.pop();\r\n            let num = '';\r\n            while(stack.length && !isNaN(stack[stack.length - 1])) {\r\n                num = stack.pop() + num;\r\n            }\r\n            console.log(str, num);\r\n            stack.push(str.repeat(num));\r\n        } else {\r\n            stack.push(cur);\r\n        }\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂地：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088366994","body":"### 思路\n使用两个数组实现\n\n### 代码\n\n```javascript\nvar MyQueue = function() {\n  this.in = [];\n  this.out = [];\n}\nMyQueue.prototype.push = function (x) {\n  this.in.push(x);\n}\nMyQueue,prototypt.peek = function() {\n  if (this.out.length == 0) {\n    const n = this.in.length;\n    for (let i = 0; i < n; i++) {\n      this.out.push(this.in.pop());\n    }\n  }\n  return this.out[this.out.length - 1];\n}\nMyQueue,prototypt.pop = function() {\n  if (this.out.length == 0) {\n    const n = this.in.length;\n    for (let i = 0; i < n; i++) {\n      this.out.push(this.in.pop());\n    }\n  }\n  return this.out.pop();\n}\nMyQueue,prototypt.empty = function() {\n  return this.in.length === 0 && this.out.length === 0;\n}\n```\n\n### 复杂度分析\n- 时间复杂度： push: O(1) peek: O(n) pop: O(n) empty: O(1)\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089915588","body":"### 思路\n使用单调栈存储每个分块的最大值，遍历数组的每个值，如果遇到小于栈顶的值，依次栈出。\n### 代码\n```js\nvar maxChunksToSorted = function(arr) {\n    let stack = [arr[0]];\n    const n = arr.length;\n    for (let i = 1; i < n; i++) {\n        const cur = arr[i];\n        if (cur >= stack[stack.length - 1]) {\n            stack.push(cur);\n        } else {\n            const top = stack.pop();\n            while (cur < stack[stack.length - 1]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n        \n    }\n    return stack.length;\n};\n```\n### 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091016658","body":"### 思路\n\n1. k % n 计算出需要移动的步数\n2. 组成环形链表，在n - k的位置断开即可\n\n### 代码\n```js\nvar rotateRight = function (head, k) {\n  if (head == null) {\n    return head;\n  }\n  let n = 1, cur = head;\n  while (cur.next) {\n    cur = cur.next;\n    n++;\n  }\n  \n  let step = n - k % n;\n  if (step == n) {\n    return head;\n  }\n  \n  cur.next = head;\n  while (step > 0) {\n    cur = cur.next;\n    step--;\n  }\n  const next = cur.next;\n  cur.next = null;\n  return next;\n\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092370495","body":"### 思路\n有可能更改头结点，使用哑结点，使用p1、p2、next分别记录更改的两个指针，及后面未更改的串，进行穿针引线。\n### 代码\n```js\nvar swapPairs = function(head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    const dummy = new ListNode(-1);\n    dummy.next = head;\n    let cur = dummy;\n    \n    while (cur.next && cur.next.next) {\n        let p1 = cur.next;\n        let p2 = cur.next.next;\n        let next = cur.next.next.next;\n\n        cur.next = p2;\n        p2.next = p1;\n        p1.next = next;\n\n        cur = p1;     \n    }\n    \n    return dummy.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093581530","body":"### 思路\n1.利用双指针找到链表的中间节点作为root\n2.利用中间节点断开链表\n3.分别在左右两部分链表进行从步骤1开始递归操作\n\n### 代码\n```js\nvar sortedListToBST = function(head) {\n    if (head == null) {\n        return null;\n    }\n\n    let pre = null;\n    let slow = fast = head;\n\n    while (fast != null && fast.next != null) {\n        pre = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    if (pre != null) {\n        pre.next = null;\n    } else {\n        head = null;\n    }\n    const next = slow.next;\n    slow.next = null;\n    const root = new TreeNode(slow.val);\n    root.left = sortedListToBST(head);\n    root.right = sortedListToBST(next);\n    return root;\n};\n```\n\n### 复杂度分析\n- 时间复杂度： O(nlogn)\n- 空间复杂度： O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094148240","body":"### 思路\n使用双指针，遍历两个分支，当两个指针指向同一个节点时，即使交叉节点，如果没有交叉节点，两个指针则同时指向空\n\n### 代码\n```js\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) {\n        return null;\n    }\n\n    let p1 = headA, p2 = headB;\n\n    while(p1 != p2) {\n        p1 = p1 == null ? headB : p1.next;\n        p2 = p2 == null ? headA : p2.next;\n    }\n\n    return p1;\n\n};\n```\n### 复杂度分析\n- 时间复杂度 O(m + n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094420298","body":"### 思路\n遍历链表，遍历的过程中将每个节点存储在set里，每次遍历尝试查看set里是否有相同节点，有则返回，直到链表指向空\n\n### 代码\n```js\nvar detectCycle = function(head) {\n    const set = new Set();\n    let cur = head;\n    while (cur) {\n        if (set.has(cur)) {\n            return cur;\n        }\n        set.add(cur);\n        cur = cur.next;\n    }\n    return null;\n};\n```\n\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096332593","body":"### 思路\n使用双向链表加哈希表：哈希表记录key与node的对应关系，双向链表可以实现删除时间复杂度为O(1), LRU机制的增加，只需要在链表一端加入节点即可。从而实现增加的时间复杂度为O(1)\n\n### 代码\n```js\nfunction ListNode(val, prev, next) {\n    this.val = val ? val : -1;\n    this.prev = prev ? prev : null;\n    this.next = next ? next : null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n    this.head = new ListNode(-1);\n    this.tail = new ListNode(-1);\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n    this.size = 0;\n};\n\nLRUCache.prototype.addToHead = function (node) {\n    node.prev = this.head;\n    this.head.next.prev = node;\n    node.next = this.head.next;\n    this.head.next = node;\n}\n\nLRUCache.prototype.removeTail = function() {\n    const removeNode = this.tail.prev;\n    this.removeNode(removeNode);\n    return removeNode;\n}\n\nLRUCache.prototype.removeNode = function(node) {\n    const pre = node.prev;\n    const next = node.next;\n    pre.next = next;\n    next.prev = pre;\n}\n\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.map.has(key)) {\n        return -1;\n    }\n    const node = this.map.get(key);\n    this.removeNode(node);\n    this.addToHead(node);\n    return node.val[1];\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        const node = this.map.get(key);\n        this.map.delete(key);\n        node.val = [key, value];\n        this.map.set(key, node);\n        this.removeNode(node);\n        this.addToHead(node);\n    } else {\n        const node = new ListNode([key, value]);\n        this.map.set(key, node);\n        this.addToHead(node);\n        this.size++;\n        console.log(this.size);\n        if (this.size > this.capacity) {\n            const node = this.removeTail();\n            this.map.delete(node.val[0]);\n            this.size--;\n        }\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：put、get O(1)\n- 空间复杂度：O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097404421","body":"### 思路\n二叉树后序遍历\n\n### 代码\n```js\nvar maxDepth = function(root) { \n    const dfs = (root) => {\n        if (root == null) {\n            return 0;\n        }\n        const left = maxDepth(root.left);\n        const right = maxDepth(root.right);\n        \n        return Math.max(left, right) + 1;\n    }\n    \n    return dfs(root);\n}\n```\n\n### 复杂度分析\n- 时间复杂度  O(n)\n- 空间复杂度 O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098612343","body":"### 思路\n使用前序遍历递归实现，先判断两个节点是否值相等，再判断两个的左子树和柚子树\n\n### 代码\n```js\nvar isSameTree = function(p, q) {\n    if (p == null && q == null) {\n        return true;\n    } \n\n    if (p == null || q == null) {\n        return false;\n    }\n    \n    if (p.val !== q.val) {\n        return false;\n    }\n\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n}\n```\n\n### 复杂度分析\n- 时间复杂度：O(min(m, n))\n- 空间复杂度：O(min(m, n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099764737","body":"### 思路\n二叉树前序遍历，遇到叶子节点之后，收集数据\n\n### 代码\n```js\nvar sumNumbers = function(root) {\n    let ans = 0;\n    const dfs = (root, num) => {\n        if (root == null) {\n            return;\n        }\n        \n        num = num * 10 + root.val;\n\n        if (root.left == null && root.right == null) {\n            ans += num;\n            return;\n        }\n\n        dfs(root.left, num);\n        dfs(root.right, num);\n    }\n    dfs(root, 0);\n    return ans;\n};\n```\n\n### 复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100479943","body":"### 思路\ndfs求二叉树最大深度，根据深度值判断更新最左侧值\n\n### 代码\n```js\nvar findBottomLeftValue = function(root) {\n    let res;\n    let maxDepth = -1;\n    const dfs = (root, depth) => {\n        if (root == null) {\n            return;\n        }\n        if (depth > maxDepth) {\n            res = root.val;\n            maxDepth = depth;\n        }\n        \n        dfs(root.left, depth + 1);\n        dfs(root.right, depth + 1);\n        \n    }\n    dfs(root, 0);\n    return res;\n}\n```\n\n### 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100782187","body":"### 思路\nDFS\n\n### 代码\n```js\nfunction serialize (root) {\n  let res = [];\n  const dfs = (root) => {\n    if (root == null) {\n      res.push(null);\n      return;\n    }\n    res.push(root.val);\n    dfs(root.left);\n    dfs(root.right);\n  }\n  dfs(root);\n  return `[${res.join(',')}]`\n}\n\nfunction deserialize (data) {\n  const arr = data.substring(1, data.length - 1).split(',');\n  \n  const dfs = (arr) => {\n    if (arr[0] == null) {\n      arr.shift();\n      return null;\n    }\n    const root = new TreeNode(arr.shift());\n    root.left = dfs(arr);\n    root.right = dfs(arr);\n    return root;\n  }\n  return dfs(arr);\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101026560","body":"### 思路\n前序遍历二叉树，记录cloumn、row、val, 按照三个字段从左到右优先级进行排序，然后用map记录下同一cloumn的val,然后转化为数组输出即可.\n\n### 代码\n```js\nvar verticalTraversal = function(root) {\n    let tuples = [];\n    const dfs = (root, cloumn, row) => {\n        if (root == null) {\n            return;\n        }\n        tuples.push([cloumn, row, root.val]);\n        dfs(root.left, cloumn - 1, row + 1);\n        dfs(root.right, cloumn + 1, row + 1);\n    }\n    dfs(root, 0, 0);\n    tuples.sort((a, b) => {\n        if (a[0] !== b[0]) {\n            return a[0] - b[0];\n        } else if (a[1] !== b[1]) {\n            return a[1] - b[1];\n        } else if (a[2] !== b[2]) {\n            return a[2] - b[2];\n        }\n    });\n  \n    const map = new Map();\n    for (let i = 0; i < tuples.length; i++) {\n        const arr = tuples[i];\n        if (map.has(arr[0])) {\n            map.get(arr[0]).push(arr[2]);\n        } else {\n            map.set(arr[0], [arr[2]]);\n        }\n    }\n    return Array.from(map.values());\n};\n```\n### 复杂度分析\n- 时间复杂度 O(n + nlogn)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101896103","body":"### 思路\n1.将数组排序 2.使用双指针\n\n### 代码\n```js\nvar twoNumSum = function(nums, target) {\n  const map = new Map();\n  const n = nums.length;\n  for (let i = 0; i < n; i++) {\n    if (map.has(nums[i])) {\n      return [i, map.get(nums[i])];\n    } else {\n      map.set(target - nums[i], i);\n    }\n  }\n}\n```\n\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103497928","body":"### 思路\n由于时间复杂度限制，使用hashmap加堆排序的方式\n### 代码\n```js\nclass MinHeap{\n  constructor() {\n    this.data = [];\n  }\n  \n  peek() {\n    return this.data[0];\n  }\n  \n  poll() {\n    //   const first = this.data.shift();\n    //   this.bubbleDown(0);\n    //   return first;\n    const first = this.data[0];\n    const last =  this.data.pop();\n    this.data[0] = last;\n    this.bubbleDown(0);\n\n    return first;\n  }\n  \n  offer(val) {\n    this.data.push(val);\n    this.bubbleUp(this.data.length - 1);\n  }\n  \n  bubbleUp(i) {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.data[parent][1] > this.data[i][1]) {\n        this.swap(parent, i);\n        i = parent;\n      } else {\n          break;\n      }\n    }\n  }\n  \n  bubbleDown(i) {\n    while(true) {\n      let left = i * 2 + 1;\n      let right = i * 2 + 2;\n      let min = i;\n      if (left < this.size() && this.data[min][1] > this.data[left][1]) {\n        min = left;\n      }\n\n      if (right < this.size() && this.data[min][1] > this.data[right][1]) {\n        min = right;\n      }\n\n      if (min !== i) {\n        this.swap(i, min);\n        i = min;\n      } else {\n        break;\n      }\n    }\n  }\n  \n  size() {\n    return this.data.length;\n  }\n  \n  swap(i, j) {\n    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];\n  }\n}\nvar topKFrequent = function(nums, k) {\n  const n = nums.length;\n  const map = new Map();\n  for (let i = 0; i < n; i++) {\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1); \n  }\n  const heap = new MinHeap();\n  for (let [key, value] of map.entries()) {\n        heap.offer([key, value]);\n        if (heap.size() > k) {\n            heap.poll();\n        }\n  }\n  console.log(heap);\n  let res = [];\n  let i = 0;\n  while (i < k) {\n    res.push(heap.data[i][0]);\n    i++;\n  }\n  return res;\n}\n```\n### 复杂度分析\n- 时间复杂度：O(nlogk)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104769696","body":"### 思路\n（没看懂题目，看了答案写的），使用哈希表记录每组距离的个数，然后遍历哈希表，计算每选出2个数的组合数\n\n### 代码\n```js\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (let p of points) {\n        const map = new Map();\n        for (let q of points) {\n            const dis = Math.pow((p[0] - q[0]), 2) + Math.pow((p[1] - q[1]), 2); \n            map.set(dis, (map.get(dis) || 0) + 1);\n        }\n        for (let [key, value] of map.entries()) {\n            ans += (value - 1) * value;\n        }\n    }\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度： O(n^2)\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105991552","body":"### 思路\n滑动窗口\n\n### 代码\n```js\nvar longest = function (s) {\n  let window = {};\n  let left = 0, right = 0;\n  const n = s.length;\n  let ans = 0;\n  while(right < n) {\n    const cur = s[right];\n    window[cur] = window[cur] ? window[cur] + 1 : 1;\n    while (window[cur] >= 2) {\n       const cur = s[left];\n       window[cur]--;\n       left++;\n    }\n    ans = Math.max(ans, right - left + 1);\n    right++;\n  }\n  return ans;\n}\n```\n### 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度： O(m) 字符集大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107422231","body":"var findSubstring = function(s, words) {\n    const wordLen = words[0].length;\n    const wLen = words.length;\n    let res = [];\n    let map = new Map();\n    for (let i = 0; i < wLen; i++) {\n        map.set(words[i] , (map.get(words[i]) || 0) + 1);\n    }\n\n    let right = 0;\n    const n = s.length;\n    while (right < n) {\n        let left = right;\n        const subWord = new Map();\n        while (left < right + wLen * wordLen) {\n            const cur = s.substr(left, wordLen);\n            if (!map.has(cur) || subWord.get(cur) == map.get(cur)) {\n                break;\n            }\n            subWord.set(cur, (subWord.get(cur) || 0) + 1);\n            left += wordLen;\n        }\n        if (left == right + wLen * wordLen) {\n            res.push(right);\n        }\n        right++;\n    }\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107688600","body":"```js\nvar solution = function(nums, k) {\n    const floorMod = (a, b) => {\n        return (a % b + b) % b;\n    }\n  const map = new Map();\n  map.set(0, -1);\n  const n = nums.length;\n  let pre = 0;\n  let ans = n;\n  let target = 0;\n  for (let i = 0; i < n; i++) {\n      target += nums[i];\n  }\n  target %= k;\n  for (let i = 0; i < n; i++) {\n    pre += nums[i];\n    const remainder = pre % k;\n    map.set(remainder, i);\n    const prevSum = floorMod(pre - target, k)\n    if (map.has(prevSum)) {\n      ans = Math.min(ans, i - map.get(prevSum))\n    } \n  }\n  return ans == n ? -1 : ans;\n}\n```\n### 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度: O(min(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107950264","body":"### 思路\n快慢指针，慢指针每次走一步，快指针每次走两步，当快指针或者快指针next指向空的时候，slow就是中间节点\n\n### 代码\n```js\nvar findMiddleNode = function(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  \n  return slow;\n}\n```\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109176650","body":"### 思路\n使用双指针\n\n### 代码\n```js\nvar removeDuplicates = function(nums) {\n  const n = nums.length;\n  let slow = 0, fast = 0;\n  while (fast < n) {\n    if (nums[slow] !== nums[fast]) {\n      slow++;\n      nums[slow] = nums[fast];\n    }\n    fast++;\n  }\n  return slow + 1;\n}\n```\n### 复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110438204","body":"### 思路\n二分法\n\n### 代码\n```js\nvar serchPosition = function (nums, target) {\n  const n = nums.length;\n  let left = 0, right = n - 1;\n  while (left <= right) {\n    const mid = left + Math.floor((right - left) / 2);\n    if (nums[mid] >= target) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n}\n```\n### 复杂度分析\n- 时间复杂度： O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111380583","body":"### 思路\n滑动窗口\n### 代码\n```js\nvar maxSlidingWindow = function(nums, k) {\n    let res = [];\n    const n = nums.length;\n    let left = 0, right = k - 1;\n    while(right < n) {\n        let max = -Infinity;\n        let i = left;\n        while (i <= right) {\n            max = Math.max(max, nums[i]);\n            i++;\n        }\n        res.push(max);\n        left++;\n        right++;\n    }\n    return res;\n};\n```\n### 复杂度分析\n- 时间复杂度： O(n^2)\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113012589","body":"### 思路\n统计有向图的入度和出度\n### 代码\n```js\nvar findJudge = function(n, trust) {\n    const inDegrees = new Array(n + 1).fill(0);\n    const outDegrees = new Array(n + 1).fill(0);\n\n    for (let i = 0; i < trust.length; i++) {\n        const [x, y] = trust[i];\n        ++inDegrees[y];\n        ++outDegrees[x];\n    }\n\n    for (let i = 1; i <= n; i++) {\n        if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n```\n### 复杂地分析\n- 时间复杂度：O(n + t)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085811348","body":"# 思路\r\n先将数组转换成数字 再将结果转换为数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = 0\r\n        digit = 1\r\n        for i in num[::-1]:\r\n            sum += i * digit\r\n            digit *= 10\r\n        sum += k\r\n        res = []\r\n        while sum:\r\n            res.append(sum % 10)\r\n            sum = sum // 10\r\n        return res[::-1]\r\n        \r\n```\r\n# 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086538280","body":"# 思路\r\n先正序遍历 再倒着遍历一遍 \r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = -float(\"inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i \r\n            # i - 负无穷 = 正无穷\r\n            res.append(i - idx)\r\n        idx = float(\"inf\")\r\n        for i in range(len(s) - 1, -1 , -1):\r\n            if s[i] == c:\r\n                idx = i \r\n            res[i] = min(idx - i, res[i])\r\n        return res\r\n```\r\n# 时间复杂度\r\n时间：0(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1091318224","body":"# 思路\r\n创建两个array 一个是stack 一个是add记录相应位置的增量\r\n\r\n#代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n#复杂度\r\n时间：O（1）\r\n空间：O（n）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1091435449","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi = multi * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((multi, res))\r\n                res, multi = \"\", 0\r\n            elif c == \"]\":\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + res * cur_multi\r\n            else:\r\n                res += c \r\n        return res\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1091327913","body":"# 思路\r\n一个是stack in 一个是stack out\r\n# 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            while self.stack_in:\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n    def empty(self) -> bool:\r\n        if self.stack_out or self.stack_in:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091691548","body":"# 思路\r\n先得到链表的长度和尾部的指针，然后头尾拼接。然后找到需要翻转的节点的上一个节点，head指向他的next节点，然后将其指向None。\r\n# 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head: return None\r\n        count = 1\r\n        tail = head\r\n        while tail.next:\r\n            count += 1\r\n            tail = tail.next\r\n        k %= count\r\n        if k == 0: return head\r\n        tail.next = head\r\n        ptr = head\r\n        # just before the new head\r\n        for i in range(count - k - 1):\r\n            ptr = ptr.next\r\n\r\n        head = ptr.next\r\n        ptr.next = None\r\n        return head\r\n```\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095050236","body":"#思路\r\n快慢指针\r\n#代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if fast == slow:\r\n                break\r\n        if fast == None or fast.next == None :\r\n            return None\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096305746","body":"#思路\r\nhashmap里面存key val 为node node里面有key 和val\r\n\r\n#代码\r\n```python\r\nclass Node:\r\n    def __init__(self, key, val):\r\n        self.right = None\r\n        self.left = None\r\n        self.val = val\r\n        self.key = key\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.tail = Node(0, 0)\r\n        self.head = Node(0, 0)\r\n        self.tail.left = self.head\r\n        self.head.right = self.tail\r\n        # key为key, val为node, node里有key和val\r\n        self.cache = {}\r\n        self.cap = capacity\r\n\r\n    def insert(self, node):\r\n        # 全部插入在尾部\r\n        left_to_tail = self.tail.left\r\n        left_to_tail.right = node\r\n        node.left = left_to_tail\r\n        node.right = self.tail\r\n        self.tail.left = node\r\n\r\n    def delete(self, node):\r\n        prev, nxt = node.left, node.right\r\n        prev.right = nxt\r\n        nxt.left = prev\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            self.delete(self.cache[key])\r\n            self.insert(self.cache[key])\r\n            return self.cache[key].val\r\n        return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.delete(self.cache[key])\r\n        self.cache[key] = Node(key, value)\r\n        self.insert(self.cache[key])\r\n\r\n        if len(self.cache) > self.cap:\r\n            lru = self.head.right\r\n            self.delete(lru)\r\n            del self.cache[lru.key]\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098204303","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root: return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099180911","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p == None and q == None:\r\n            return True\r\n        elif p == None or q == None:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n        \r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100634288","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def __init__(self):\r\n        self.depth = 0\r\n        self.res = 0\r\n        self.max_depth = 0\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        # solution 1\r\n        # queue = collections.deque()\r\n        # queue.append(root)\r\n        # res_l = []\r\n        # while queue:\r\n        #     n = len(queue)\r\n        #     level = []\r\n        #     for i in range(n):\r\n        #         cur = queue.popleft()\r\n        #         level.append(cur)\r\n        #         if cur.left:\r\n        #             queue.append(cur.left)\r\n        #         if cur.right:\r\n        #             queue.append(cur.right)\r\n        #     res_l.append(level)\r\n        # return res_l[-1][0].val\r\n\r\n        # solution 2\r\n        self.traverse(root)\r\n        return self.res.val\r\n\r\n\r\n    def traverse(self, root):\r\n        if root == None:\r\n            return\r\n        self.depth += 1\r\n        if self.depth > self.max_depth:\r\n            self.max_depth = self.depth\r\n            self.res = root\r\n        self.traverse(root.left)\r\n        self.traverse(root.right)\r\n        self.depth -= 1\r\n\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106625522","body":"```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if s == \"\": return 0\r\n        left = right = 0\r\n        window = {}\r\n        res = 0\r\n        while right < len(s):\r\n            c = s[right]\r\n            if c not in window:\r\n                window[c] = 1\r\n            else:\r\n                window[c] += 1\r\n            while window[c] > 1:\r\n                left_s = s[left]\r\n                window[left_s] -= 1\r\n                left += 1\r\n            res = max(res, right - left + 1)\r\n            right += 1\r\n        return res            \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107440944","body":"```python\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        if not s or not words:\r\n            return []\r\n        n = len(s)\r\n        one_word_len = len(words[0])        #一个单词的长度\r\n        word_cnt = len(words)               #单词的个数\r\n        all_len = one_word_len * word_cnt\r\n\r\n        words_cnt = defaultdict(int)        #每个单词出现的次数\r\n        for w in words:\r\n            words_cnt[w] += 1\r\n\r\n        res = [] \r\n        for i in range(one_word_len):       #shell希尔排序的套路 start  delta = 一个单词的长度\r\n            cur_w_num = 0                     #单词个数\r\n            L, R = i, i\r\n            cur_w_dic = defaultdict(int)      #当前单词的次数统计\r\n            while R + one_word_len <= len(s):\r\n                w = s[R: R + one_word_len]\r\n                R += one_word_len           #R每次像右移一个单词的长度 类似于shell排序中的delta\r\n\r\n                if w not in words_cnt:          #结束前，出现个不知道哪里的单词，整个前面一片就废了\r\n                    L = R\r\n                    cur_w_dic.clear()\r\n                    cur_w_num = 0\r\n                else:\r\n                    cur_w_dic[w] += 1\r\n                    cur_w_num += 1\r\n                    while cur_w_dic[w] > words_cnt[w]:\r\n                        L_w = s[L : L + one_word_len]\r\n                        L += one_word_len       #L右移\r\n                        cur_w_dic[L_w] -= 1       #做好统计\r\n                        cur_w_num -= 1\r\n                    if cur_w_num == word_cnt:     #如果说ok了\r\n                        res.append(L)\r\n        \r\n        return res\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111176684","body":"```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left = 0\r\n        right = len(nums) - 1\r\n        #[left, right]\r\n        # terminal case: left = right + 1\r\n        while left <= right:\r\n            mid = left + (right - left) // 2\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] < target:\r\n                left = mid + 1\r\n            else:\r\n                right = mid - 1\r\n        return left\r\n        \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momomoi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085818993","body":"**思路** \r\n把num列表数据合并为数字和k相加然后再拆分还原\r\n\r\n**时间复杂度** \r\n单循环O(N)\r\n\r\n**代码实现**\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n       cmt_num = ''.join((str(i) for i in num))\r\n       add_sum = int(cmt_num) + k\r\n       split_sum = [int(l) for l in str(add_sum)]\r\n       return split_sum\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651671","body":"# 思路\r\n### 第一次遍历进行位置确认，第二次遍历进行选最小值\r\n\r\n# 复杂度\r\n### 时间复杂度O(N)\r\n### 空间复杂度O(N)\r\n# 代码\r\n```\r\nclass demo:\r\n    def test(self, S:str, C:str) -> List[int]:\r\n         sums = -1\r\n         zero_sums = [0]*len(S)\r\n         for i in range(len(S)):\r\n            if S[i] == C:\r\n                 sums = 0\r\n            else:\r\n                sums += 1\r\n            zero_sums[i] = sums\r\n         sums = -1\r\n         for j in range(len(S)-1, -1, -1):\r\n            if S[j] == C:\r\n                 sums = 0\r\n            else:\r\n                sums +=1\r\n            zero_sums[j] = min(sums, zero_sums[j])\r\n         return sums\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874668","body":"###看了题解和评论，因为在外面没法写就直接复用一下了\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087578922","body":"\n### 代码\n```\ndef decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                repeatStr = \"\"\n                repeatCount = \"\"\n                while stack and stack[-1] != \"[\":\n                    repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n### 复杂度\n#### 时间 O(N)\n#### 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088572928","body":"### 思路：\n刚开始觉得题目很简单，写了下代码，但是随后看了下题解的思路，发现push这块没考虑清楚，复用了下代码\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_1 = []\n        self.stack_2 = []\n\n    def push(self, sum):\n\n        while self.stack_1:\n            self.stack_2.append(self.stack_1.pop())\n        self.stack_2.append(sum)\n        while self.stack_2:\n            self.stack_1.append(self.stack_2.pop())\n\n    def pop(self):\n        return self.stack_1.pop()\n\n    def peek(self):\n        return self.stack_1[-1]\n\n    def empty(self):\n        return False if not bool(self.stack_1) else True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090256536","body":"### 解题思路\n#### 记录每个块中的最大值，最大值的个数就是分块数\n\n### 代码\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091689480","body":"### 思路\r\n#### 先遍历获得链表的长度以及链表尾部的指针，然后头尾拼接起来。 随后我们只要从头遍历k - k % length步就能够找到旋转后链表的头指针，断开尾指针和头指针，返回头指针。\r\n\r\n### 代码\r\n```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head is None:\r\n            return None\r\n        cur = head \r\n        length = 1\r\n        while cur.next:\r\n            cur = cur.next\r\n            length += 1\r\n        cur.next = head\r\n        k = length - k % length\r\n        while k:\r\n            k -= 1\r\n            cur = cur.next\r\n        head = cur.next\r\n        cur.next = None\r\n        return head\r\n```\r\n#### 时间复杂度O（N）\r\n#### 空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092965269","body":"### 递归\n\n### 代码\n```\nclass ListNode(object):\n    def swapPairs(self,head):\n        if not head or not head.next:\n            return head\n        first = head\n        second = head.next\n        third = head.next.next\n        second.next = first\n        first.next = self.swapPairs(third)\n        return second\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094039770","body":"### 解题思路\n #### 递归+快慢指针\n\n### 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def buildTree(left, right):\n            if left == right:\n                return\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        return buildTree(head, None)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085860307","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639221","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086876043","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087643862","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088800545","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090369863","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091686462","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092660972","body":"### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094042411","body":"### 解题思路\n    分治 \n### 代码实现\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094276559","body":"### 解题思路：\n1. 使用pA、pB两个指针分别指向A、B两个链表，两个指针以相同的速率向后移动\n2. 当pA指针移动到了A链接的末尾、令指针pA指向B链表的头部\n3. 当pB指针移动到了A链接的末尾、令指针pB指向A链表的头部\n4. 当pA、pB指针相遇时即为两个指针相遇的起点，否则两个指针不相交\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    let pA = headA;\n    let pB = headB;\n    while (pA != pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095095463","body":"### 解题思路\n\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // 定义快慢两个指针、只想链表头部\n    let fast = head;\n    let slow = head;\n    // 快指针走两步，满指针走一步\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // 相遇后将快指针指向链表头部\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095866734","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097910029","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\n- 空间复杂度 $(K)$, k为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099228520","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n  if(!p && !q) return true\n  if(!p || !q) return false;\n  if(p.val != q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100131944","body":"### 解题思路\n> DFS\n\n### 代码实现\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return dfs(root, 0)\n};\nvar dfs = function(root, sum) {\n    if (root === null) {\n        return 0;\n    }\n    const curSum = sum * 10 + root.val;\n    // 遍历到根节点\n    if (root.left === null && root.right === null) {\n        return curSum;\n    } else {\n        return dfs(root.left, curSum) + dfs(root.right, curSum);\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度 $O(n)$ n为二叉树的节点个数\n- 空间复杂度 $O(n)$ n为二叉树的节点个数\n\n\n### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (root === null) {\n        return 0;\n    }\n    const queue = [[root, root.val]];\n    let sum = 0;\n    while(queue.length > 0) {\n        const [node, curSum] = queue.shift();\n        if(node.left === null && node.right === null) {\n            sum += curSum;\n        } else {\n          node.left && queue.push([node.left, curSum * 10 + node.left.val]);  \n          node.right && queue.push([node.right, curSum * 10 + node.right.val]);  \n        }\n    }\n    return sum;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(n)$ n为二叉树的节点个数\n- 空间复杂度 $O(n)$ n为二叉树的节点个数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100691664","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  if(!root) return null;\n  const queue = [root]\n  let mostLeft = null;\n  while(queue.length > 0){\n    let curLevelSize = queue.length\n    mostLeft = queue[0]\n    for(let i = 0; i < curLevelSize; i++){\n      const curNode = queue.shift();\n      curNode.left && queue.push(curNode.left)\n      curNode.right&& queue.push(curNode.right)\n    }\n  }\n  return mostLeft.val\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树的节点\n- 空间复杂度 $O(N)$ N为二叉树的节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100895089","body":"### 解题思路\n> DFS（递归）\n\n### 代码实现\n> javaScript\n\n```\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  } \n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list);\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101472875","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n  if(!root) return root\n  const result = []\n  const obj = new Map();\n  // [node, rowVal, colVal]\n  const queue = [[root,0, 0]]\n\n  while(queue.length){\n    const [node, row, col] = queue.shift()\n    obj.set(col, (obj.get(col) || []).concat([[node.val, row]]))\n    node.left && queue.push([node.left, row + 1, col - 1 ])\n    node.right && queue.push([node.right, row + 1 , col + 1 ])\n  }\n\n  // sort\n  let sortedKeys = [...obj.keys()].sort((a,b) => a - b)\n\n  for(const key of sortedKeys){\n    let temp = obj.get(key)\n    temp = temp.sort((a,b) => {\n      if(a[1] != b[1]){\n        return a[1] - b[1]\n      }\n      return a[0] - b[0]\n    })\n    result.push(temp.map((item) => item[0]))\n  }\n  return result;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(NlogN)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102710873","body":"### 解题思路\n> 哈希表\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const hashMap = new Map();\n    for(let i = 0; i < nums.length; i++){\n      if (hashMap.has(target - nums[i])) {\n        return [hashMap.get(target - nums[i]), i]\n      } else {\n        hashMap.set(nums[i], i)\n      }\n    }\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ \n- 空间复杂度 $O(N)$ ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103950013","body":"### 解题思路\n> 桶排序\n\n### 代码实现\n> javaScript\n\n```\nlet topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    // 如果元素数量小于等于 k\n    if(map.size <= k) {\n        return [...map.keys()]\n    }\n    \n    return bucketSort(map, k)\n};\n\n// 桶排序\nlet bucketSort = (map, k) => {\n    let arr = [], res = []\n    map.forEach((value, key) => {\n        // 利用出现频率作为下标，将数据分配到各个桶中\n        if(!arr[value]) {\n            arr[value] = [key]\n        } else {\n            arr[value].push(key)\n        }\n    })\n    // 倒序遍历获取出现频率最大的前k个数\n    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){\n        if(arr[i]) {\n            res.push(...arr[i])\n        }\n\t}\n\treturn res\n}\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106370636","body":"### 解题思路\n>  哈希表+滑动窗口\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    const hashMap = new Set()\n    let longestSubstring = 0;\n    let slow = 0;\n    for(let fast = 0; fast < s.length; fast++){\n        let char = s[fast]  \n        while(hashMap.has(char) && slow < s.length){\n            hashMap.delete(s[slow])\n            slow++\n        }\n        longestSubstring = Math.max(longestSubstring, fast - slow + 1)\n        hashMap.add(char)\n    }\n    return longestSubstring\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107523985","body":"### 解题思路\n> 哈希表 + 滑动窗口\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    let hashMap = new Map;\n    const wordLength = words[0].length;\n    const result = [];\n    for (const word of words){\n        const val = (hashMap.get(word) || 0) +  1\n        hashMap.set(word, val);\n    }\n    for(let i = 0; i <= s.length - wordLength * words.length; i++){\n        const temp = new Map(hashMap);\n        let wordLeft = words.length;\n        for(let j = i; j < i + wordLength * words.length; j+= wordLength){\n            const curWord = s.slice(j, j+ wordLength);\n            if (!temp.has(curWord) || temp.get(curWord) <= 0) {\n                break;\n            }\n            wordLeft --;\n            temp.set(curWord, temp.get(curWord) - 1);\n        }\n        if (wordLeft === 0) {\n            result.push(i)\n        }\n    }\n\n    return result;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(NM)$ 其中 N是输入String的长度，M是words的长度\n- 空间复杂度 $O(M)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107809049","body":"#### 代码实现\n\n```\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    let map = new Map();\n    map.set(0, -1);\n    let res = nums.length;\n    let target = 0;\n    let curSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      curSum = (nums[i] + curSum) % k;\n      map.set(curSum, i);\n      let prevSum = floorMod(curSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$\n- 空间复杂度: $O(min(n, k))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108658864","body":"#### 解题思路\n> 双指针\n\n#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = (fast = head);\n  while (slow && fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n\n- 空间复杂度: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109913193","body":"### 解题思路\n- 使用读写指针,读指针遍历数组，写指针修改数组，删除重复元素\n\n### 代码实现\n\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    // 定义读、写指针，开始时均指向数组起点\n    let writePoint = 0;\n    let readPoint = 0;\n    // 数组未被遍历至末尾\n    while(readPoint < nums.length) {\n        // 当读写指针内容不相等时\n        if(nums[writePoint] !== nums[readPoint]) {\n            // 移动写指针\n            writePoint ++;\n            // 改写数组相应的值\n            nums[writePoint] = nums[readPoint]\n        }\n        readPoint ++;\n    }\n    return writePoint + 1\n};\n```\n### 复杂度分析\n- 时间复杂度：$O(N)$, N为数组长度\n- 空间复杂度：$O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085861308","body":"**思路**\r\n从num的个位开始与k逐个相加，与10相除，余数为当前位的数值，商为下次循环的k，求完后再倒序即可。\r\n\r\n**代码实现**\r\n```C++\r\nclass Solution {\r\n  public:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> out;\r\n        int sum = 0;\r\n        for(int i = num.size()-1; i >= 0 || k > 0; i--) {\r\n            if(i >= 0){\r\n                sum = k + num[i];\r\n                out.push_back(sum % 10);\r\n                k = sum /10;\r\n            }else{\r\n                out.push_back(k % 10);\r\n                k = k /10;\r\n            }\r\n        }\r\n        reverse(out.begin(),out.end());\r\n        return out;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(max(n,k))  n：num的数据长度；k：k的数据长度\r\n空间复杂度：同上","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1088783772","body":"**思路**\r\n先遍历一遍找到字符所在位置，在使用双坐标遍历字符串得到最小距离。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> idx;\r\n        vector<int> dst;\r\n        int position=0;\r\n        while((position=s.find(c,position))!=string::npos)\r\n        {\r\n            idx.push_back(position);\r\n            position++;\r\n        }\r\n        int current;\r\n        int next;\r\n        if(!idx.empty()){\r\n            current = idx[0];\r\n            if(idx.size()>1){\r\n               next = idx[1];\r\n            }else{\r\n              next = current;  \r\n            }\r\n        }\r\n        int num_idx = 2;\r\n        int min_dst = 0;\r\n        for(int i = 0;i< s.size();i++){\r\n            if(i>current){\r\n                min_dst = min(abs(i-current),abs(i-next));\r\n                dst.push_back(min_dst);\r\n                if(abs(i-current)>=abs(i-next)){\r\n                  current = next;\r\n                  if(num_idx < idx.size()){\r\n                    next = idx[num_idx]; \r\n                    num_idx++;                   \r\n                  }else{\r\n                      next =current;\r\n                  }\r\n                }   \r\n            }else if(i==current){\r\n                 dst.push_back(0);\r\n            }else{\r\n                dst.push_back(abs(i-current));\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(n*n)  两次循环字符串\r\n空间复杂度：O(n)","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090372653","body":"**思路**\r\n使用单调栈，分析可知当前值小于之前块的最大值时，则当前值为下一个分块的起点。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> max;\r\n        int top=0;\r\n        int top_tmp =0;\r\n        if(arr.empty()){\r\n            return 0;\r\n        }\r\n        for(int i=0; i<arr.size()-1;i++){\r\n          if(i==0){\r\n              max.push(arr[i]);\r\n          }\r\n\r\n          if(arr[i+1]>=max.top()){\r\n            max.push(arr[i+1]);\r\n          }else{\r\n            top = max.top();\r\n            top_tmp = max.top();\r\n            while(arr[i+1]< top_tmp && (!max.empty() )){\r\n                if(max.size()>1){\r\n                  max.pop();\r\n                  top_tmp = max.top();\r\n                }else{\r\n                    max.pop();\r\n                }\r\n            }\r\n            max.push(top);\r\n          } \r\n        }\r\n        if(max.empty()){\r\n            return 1;\r\n        }\r\n        return max.size();\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度**\r\n时间复杂度：O(n);\r\n空间复杂度：O(n);","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097559527","body":"**思路**\r\n递归操作，遍历左右子树，深度=左右子树深度的最大值+1（根节点）\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root){\r\n            return 0;\r\n        }\r\n        int L_depth = 0;\r\n        int R_depth = 0;\r\n        L_depth = maxDepth(root->left);\r\n        R_depth = maxDepth(root->right);\r\n        return max(L_depth,R_depth)+1;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(n), n 节点个数；\r\n空间复杂度：O(height), 递归开辟空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100080778","body":"**思路**\r\n从根节点开始往下遍历，和=当前节点+之前数据*10，当没有子节点的时候返回。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int DFS(TreeNode* root, int pre){\r\n        pre = pre*10 + root->val;\r\n        if(!root->left && !root->right){\r\n            return pre;\r\n        }\r\n        int sum_left = 0 ;\r\n        int sum_right = 0 ;\r\n        if(root->left){\r\n          sum_left =  DFS(root->left,pre);  \r\n        }\r\n        if(root->right){\r\n          sum_right =  DFS(root->right,pre);\r\n        }       \r\n        return sum_left+sum_right;\r\n\r\n    }\r\n\r\n    int sumNumbers(TreeNode* root) {\r\n        if(!root){\r\n            return 0;\r\n        }  \r\n        int pre = 0;\r\n        int sum = DFS(root,pre);\r\n        return sum;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(n)，节点个数\r\n空间复杂度：O(height)，树的深度","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106498433","body":"**思路**\r\n 使用滑动窗口及队列数据结构，遇到重复字符，则pop出队列中重复字符前的几个字符，否则字符进入队列。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        if(!s.size()){\r\n            return 0;\r\n        }\r\n       std::deque<string> dq;\r\n       dq.emplace_back()= s[0];\r\n       int length = 1;\r\n       int length_tmp;\r\n       for(int i = 1;i < s.size(); i++){\r\n               dq.emplace_back()= s[i]; \r\n               for(int j = 0; j<dq.size()-1;j++){\r\n                    if(dq.at(j) == dq.back()){\r\n                        int k =0 ;\r\n                        while(k<=j){\r\n                           dq.pop_front();\r\n                           k++;\r\n                        }\r\n                    }\r\n               }\r\n               length_tmp = dq.size();\r\n               length = max(length_tmp,length);\r\n        }\r\n        return length;        \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(n^2) ，每次都遍历窗口内是否有重复字符；\r\n空间复杂度：O(n)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108555547","body":"**思路**\r\n快慢指针，当链表长度为偶数，返回慢指针的下一个值，链表长度为奇数时，返回的慢指针为链表中间。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n        while((fast->next != NULL) && (fast->next->next != NULL)){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        if(fast->next != NULL){\r\n            return slow->next;\r\n        }else{\r\n            return slow;\r\n        }    \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(n) ，链表长度;\r\n空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109349965","body":"**思路**\r\n数组前面的部分保存不重复的数字，所以需要有个指针指向数组，当遇到不重复数字时，此指针后移并赋值，否则此指针不动。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        if(nums.size() <= 1){\r\n            return nums.size();\r\n        }\r\n        int length = 1;\r\n        for(int i=1; i <nums.size();i++){\r\n            if(nums[i]!=nums[i-1]){\r\n                nums[length]= nums[i];\r\n                length++;\r\n            }\r\n        }\r\n        return length;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(n);\r\n空间复杂度：O(1);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhulin1110":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873537","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n首先想到的是将数组转换成数，再和K相加，但会发生内存溢出的情况。\n- **改进** \n从个位数开始考虑，依次与 k 相加，（和 % 10） 存入输出数组 ，（和 / 10）取出进位位（更新后的k包含进位）。最后考虑 k 超出数组长度的部分，依次加到输出数组里即可。\n## 代码(JavaScript)\n```JavaScript\nvar addToArrayForm = function(num, k) {\n    var res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        res.push((num[i] + k) % 10);  //个位数存入数组\n        k = Math.floor((num[i] + k) / 10);  //更新k, 进位位包含在k中\n    }\n    // 对超出数组长度的 k 进行处理\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n## 复杂度\n- 时间复杂度\n> O(n) ，for循环遍历数组长度n，后面的可以忽略不计\n- 空间复杂度\n> O(n) ， 创建一个新的数组res存放结果，后面有循环但是没有分配新的内存空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646686","body":"## 题目\n\n字符的最短距离 https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 思路1（菜鸡的我自己写的，吐了）\n\n找到 s 中所有与 c 相同的字符，并将其索引存放到一个数组中。将数组中的元素索引依次与相同字符的索引做差，并比较得出最小值。值得注意的是，当 s 中与 c 相同的字符只有一个时，无需比较，直接做差即可。\n\n## 代码1（JavaScript）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    if (curr.length == 1) {\n        for (let i = 0; i < s.length; i++) {\n            res[i] = Math.abs(i - curr[0]);\n        }\n        return res;\n    }\n    for (let i = 0; i < s.length; i++) {\n        let j = 0;\n        let data = Math.abs(curr[j] - i);\n        while (curr && (j < curr.length - 1)) {\n            data = Math.min(data, (Math.abs(curr[j + 1] - i)));\n            j++;\n            res[i] = data;\n        }\n    }\n    return res;\n};\n```\n\n \t\t### 代码1改进（看了题解，稍稍改进）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            res[i] = 0;\n            continue;\n        }\n        for (const j of curr) {\n            const dist = Math.abs(j - i);\n            if (dist >= res[i]) break; // 小小剪枝，跟上次存的比较，j是不断增大的，目的就是为了找最小值，设置阈值\n            res[i] = dist;\n        }  \n    }\n    return res;\n};\n```\n\n\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n * n) 前面for循环是n，后面for循环嵌套while，while内最大是n，时间复杂度就是n*n，前面的n可以忽略不记\n\n- 空间复杂度\n\n  > O(n) res 和 curr \n\n## 思路2 （看了题解-贪心算法）\n\n两遍循环，先从左到右遍历s，找到左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。最后，取两个值中的最小值。\n\n## 代码2 （评论区大佬的）\n\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let lcIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) lcIndex = i;\n    res[i] = i - lcIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度2\n\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086837506","body":"## 题目\n\n设计一个支持增量操作的栈 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 思路1\n\n根据题目要求的直觉栈操作\n\n## 代码1（JavaScript）\n\n```javascript\nvar CustomStack = function(maxSize) {\n    this.max = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n   if (this.stack.length < this.max) {\n        this.stack.push(x); \n   }\n\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.stack.pop();\n    if (res == null) {\n        return -1;\n    } else {\n        return res;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length; i++) {\n        if (i < k) {\n            this.stack[i] += val;\n        }\n    }\n   \n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(1)  未定义新的数组存放结果\n\n## 思路2 （题解学习）\n\n前缀和（没看懂，待补充）。。。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087573823","body":"## 题目\n\n字符串解码 https://leetcode-cn.com/problems/decode-string/\n\n## 思路1\n\n定义两个栈，一个用来存放倍数，一个用来存放字符串。具体操作看程序注释\n\n## 代码1（JavaScript）\n\n```javascript\nvar decodeString = function(s) {\n   // 存倍数的栈\n    let numStack = [];\n    // 存待拼接的str的栈     \n    let strStack = [];\n    // 倍数   \n    let num = 0;\n    // 字符串\n    let result = '';\n    //  逐字符扫描\n    for (let char of s) {\n        // 遇到数字\n        if (!isNaN(char)) {\n            // 算出倍数\n            num = num * 10 + Number(char); \n        } \n        // 遇到 [\n        else if (char === '[') {\n            // 将result已经拼接完成的放到strStack当中\n            strStack.push(result);\n            // 入栈后清零 \n            result = '';\n            // 倍数num进入栈等待\n            numStack.push(num);\n            // 入栈后清零\n            num = 0;\n            \n        } \n        // 遇到 ]，两个栈的栈顶出栈\n        else if (char === ']') {\n            // 获取拷贝次数\n            let repeatTimes = numStack.pop();\n            // 构建子串\n            result = strStack.pop() + result.repeat(repeatTimes); \n        } \n        // 遇到字母，追加给result串\n        else {\n            result += char;\n        }\n    }\n    // 最终返回结果\n    return result;\n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088752873","body":"## 题目\r\n\r\n用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 思路1\r\n\r\n用两个栈实现队列：将一个栈当做输入栈，另一个栈当做输出栈。注意输出栈不为空的情况的处理。\r\n\r\n## 代码1（JavaScript）\r\n\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n    this.res = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length == 0) {\r\n        while (this.stack1.length !== 0) {\r\n            this.stack2.push(this.stack1.pop());\r\n        }\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack2.length == 0) {\r\n        while (this.stack1.length !== 0) {\r\n            this.stack2.push(this.stack1.pop());\r\n        }\r\n    }\r\n    return this.stack2[this.stack2.length - 1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if (this.stack1.length !== 0 || this.stack2.length !== 0) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度1\r\n\r\n- 时间复杂度\r\n\r\n  > O(n) \r\n\r\n- 空间复杂度\r\n\r\n  > O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090366513","body":"## 题目\n768. 最多能完成排序的块 II  https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n## 思路 （参照大佬答案，留下思路，与程序不符）\n- 利用单调递减栈来解题\n- 遍历数组，将元素存入栈中，再利用max记录当前栈顶的最大值\n- 如果遇到比当前栈元素大的值，那么可以直接入栈，因为可以单独分一块；但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素依次出栈，直到遇到小于等于该值的元素停止出栈，然后将max再push入栈（push的这个max就代表了这一个块）\n  - 例如：有该数组 {1, 1, 3, 4, 5, 2, 6, 7}，此时栈为{1, 1, 3, 4, 5}\n  - 接下来遍历到2了，2比max即5小，所以开始出栈，顺序是：5、4、3，由于1小于2，所以停止出栈，接下来将max(5)入栈，此时栈为：{1, 1, 5}\n- 不断遍历，直到数组遍历结束，此时栈中有多少个元素就代表有多少个块了\n- 分块规则：后一块元素的最小值大于等于前一块元素的最大值\n## 代码 (Javascript) 未用栈来做，待修改\n``` javascript\nvar maxChunksToSorted = function(arr) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let res = 0;\n    let arr2 = [...arr].sort((a, b) => a - b);\n    for (let i in arr) {\n        sum1 = sum1 + arr[i];\n        sum2 = sum2 + arr2[i];\n        if (sum1 == sum2) {\n            res += 1;\n            sum1 = 0;\n            sum2 = 0;\n        }\n    }\n    return res;\n};\n```\n没有用栈来做，待修改","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091431781","body":"## 题目 \n     旋转链表 https://leetcode-cn.com/problems/rotate-list/submissions/\n## 思路 1 (自己写的)\n     首先获取链表的长度 length，同时将单向链表转化成循环链表，遍历 length - k % length 找到倒数第k个节点并将其作为head，同时将 length - k % length 的下一个指向 null，断开链表\n## 代码1 (Javascript)\n```Javascript\nvar rotateRight = function(head, k) {\n    let length = 0;\n    let curr1 = head;\n    let curr2 = head;\n    if (head == null) {\n        return head;\n    }\n    while (curr1.next !== null) {\n        curr1 = curr1.next;\n        length++;\n    }\n    length++;\n    curr1.next = head;\n    let temp = length - k % length;\n    while (temp) {\n        curr2 = curr2.next;\n        temp--;\n        curr1 = curr1.next;\n    }\n    curr1.next = null;\n    return curr2;\n};\n```\n## 复杂度分析1\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n## 思路2 (快慢指针)\n     快指针比慢指针多走k步，当快指针到达原链表终点时，慢指针到达旋转后链表的尾节点。将快指针接到头节点形成循环链表，慢指针指向头节点，不要忘记断开循环链表。\n## 代码2 (Javascript)\n```Javascript\nvar rotateRight = function(head, k) {\n   let slow = head;\n   let fast = head;\n   let curr = head;\n   let length = 0;\n   if (!head || !head.next) {\n       return head;\n   }\n   while (curr) {\n       curr = curr.next;\n       length++;\n   }\n   k = k % length;\n   while (fast.next) {\n       if (k-- <= 0) {\n           slow = slow.next;\n       }\n       fast = fast.next; \n   }\n   fast.next = head;\n   let res = slow.next;\n   slow.next = null;\n   return res;\n};\n```\n## 复杂度分析2\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092590450","body":"## 题目\r\n\r\n两两交换链表中的节点 https://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 思路1（迭代法）\r\n\r\n![](https://img-blog.csdnimg.cn/fd8ea430a8c94651a489f0ba29ae8ab9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Lmf5rKh5Zyw5pa55Y67,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\r\n\r\n## 代码1（JavaScript）\r\n\r\n```javascript\r\nvar swapPairs = function(head) {\r\n     if (!head || !head.next) {\r\n        return head;\r\n    }\r\n    let prehead = new ListNode();\r\n    prehead.next = head;\r\n    let temp = prehead;\r\n    while (temp.next !== null && temp.next.next !== null) {\r\n        const node1 = temp.next;\r\n        const node2 = temp.next.next;\r\n        temp.next = node2;\r\n        node1.next = node2.next;\r\n        node2.next = node1;\r\n        temp = node1;\r\n    }\r\n    return prehead.next;\r\n};\r\n```\r\n\r\n## 复杂度1\r\n\r\n- 时间复杂度\r\n\r\n  > O(n) 所有的节点都需要遍历一遍\r\n\r\n- 空间复杂度\r\n\r\n  > O(1) \r\n\r\n## 思路2 （迭代法）\r\n\r\n在分析迭代的过程中就能体会到递归的思路\r\n\r\n## 代码2（JavaScript）\r\n\r\n```Javascript\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head;\r\n    }\r\n    let res = new ListNode();\r\n    res = head.next;\r\n    head.next = swapPairs(res.next);\r\n    res.next = head;\r\n    return res;\r\n};\r\n```\r\n\r\n## 复杂度分析2\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093912602","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n \n\n示例 1:\n\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n\n示例 2:\n\n输入: head = []\n输出: []\n\n\n \n\n提示:\n\nhead 中的节点数在[0, 2 * 104] 范围内\n-105 <= Node.val <= 105\n```\n\n## 前置知识\n\n- 二叉搜索树\n- 递归\n\n## 思路1\n- 观察题目发现，升序排列的链表相当于二叉树的中序遍历，其中根节点正好处于中间节点处，由此想到快慢指针可以用于找中间节点，快指针一次前进两节点，慢指针一次前进一个节点，当快指针到达尾节点处时，慢指针恰好处于中间节点。**以上思路确定根节点**\n- 由于二叉搜索树的左子树节点都小于根节点，右子树节点都大于根节点。链表恰好是升序排列，中间节点的左侧均小于中间节点，中间节点的右侧均大于中间节点，创建左右子树即可。\n\n## 代码1\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null;\n    return dfs(head,null);\n};\nfunction dfs(head, tail) {\n    if (head == tail) {\n        return null;\n    }\n    let fast = head;\n    let slow = head;\n    while (fast != tail && fast.next != tail) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    let root = new TreeNode(slow.val);\n    root.left = dfs(head, slow);\n    root.right = dfs(slow.next, tail);\n    return root;\n}\n\n```\n\n\n**复杂度分析1**(不太会。。。)\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(nlog(n))$ 递归树的深度为 lognlogn，每一层的基本操作数为 nn，因此总的时间复杂度为O(nlogn)\n- 空间复杂度：$O(log(n))$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094218461","body":"## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 哈希表\n- 双指针\n\n## 思路1 哈希表\n将链表A中的节点存到set中，判断链表B中有没有相同节点即可。\n\n## 代码1\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let data = new Set();\n    while (headA !== null) {\n        data.add(headA);\n        headA = headA.next;\n    }\n    while (headB !== null) {\n        if (data.has(headB)) {\n            return headB;\n        }\n        headB = headB.next;\n    }\n    return null;\n};\n\n```\n\n\n**复杂度分析1**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n## 思路2 双指针\nA链表的长度为a，B链表的长度为b，重合部分长度为c。根据 a - c + b == b - c + a。指向A、B链表头的指针每次前移一位，遇到相同的节点则结束循环。其中，如果A链表的指针走到null，则使其为headB，如果B链表的指针走到null，则使其为headA。\n\n## 代码2\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) { \n    let a = headA;\n    let b = headB;\n    while (a !== b) {\n        if (a !== null) {\n            a = a.next;\n        } else {\n            a = headB;\n        }\n        if (b !== null) {\n            b = b.next;\n        } else {\n            b = headA;\n        }\n    }\n    // while (a != b) {\n    //     a = a === null ? headB : a.next;\n    //     b = b === null ? headA : b.next;\n    // }\n    return a;\n};\n\n```\n\n\n**复杂度分析2**\n\n- 时间复杂度：$O(n)$   A、B链表各遍历一次\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094502484","body":"## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n## 前置知识\n\n- 快慢指针\n\n## 思路\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e5dd0404b3844c0b89943e085978415e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Lmf5rKh5Zyw5pa55Y67,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (head == null ||head.next == null) {\n        return null;\n    }\n    let slow = head;\n    let fast = head;\n    do {\n        if (fast != null && fast.next != null) {\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        slow = slow.next;  \n    } while (slow != fast);\n    if (fast == null) {\n        return null;\n    }\n    fast = head;\n    while (slow != fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    return fast;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096409978","body":"\n## 题目地址(146. LRU 缓存)\n\nhttps://leetcode-cn.com/problems/lru-cache/\n\n## 题目描述\n\n```\n请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\n实现 LRUCache 类：\nLRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n \n\n示例：\n\n输入\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n\n\n \n\n提示：\n\n1 <= capacity <= 3000\n0 <= key <= 10000\n0 <= value <= 105\n最多调用 2 * 105 次 get 和 put\n```\n\n## 思路\n哈希表 + 双向链表\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)){\n        let value = this.map.get(key);\n        this.map.delete(key); // 删除后，再 set ，相当于更新到 map 最后一位\n        this.map.set(key, value);\n        return value;\n    } else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 如果已有，那就要更新，即要先删了再进行后面的 set\n    if(this.map.has(key)){\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    // put 后判断是否超载\n    if(this.map.size > this.capacity){\n        this.map.delete(this.map.keys().next().value);\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\n```\n\n\n**复杂度分析**\n\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098099905","body":"\n## 题目地址(104. 二叉树的最大深度)\n\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n## 题目描述\n\n```\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n```\n\n## 前置知识\n\n- 二叉树\n- 递归\n\n## 思路\n找二叉树的最大深度，换句话说就是找二叉树的最大高度。\n\n找子树最大高度的过程遍历节点的顺序是 做左节点、右节点、根节点，遍历顺序可以看做和后序遍历相同。\n- 递归两步走\n**1. 找出重复的子问题**\n找子树的最大高度\n**2. 确定终止条件**\n二叉树遍历的终止条件是没有东西遍历了，即当前节点是空的。\n- 节点为空，高度为0\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (root == null) return 0;\n    let leftTree = maxDepth(root.left);\n    let rightTree = maxDepth(root.right);\n    return Math.max(leftTree, rightTree) + 1;\n};\n\n```\n\n\n**复杂度分析**\n\nn 是二叉树的节点数，height是二叉树高度\n\n- 时间复杂度：$O(n)$ 每个节点都要被遍历一遍\n- 空间复杂度：$O(height)$ \n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098903966","body":"\n## 题目地址(100. 相同的树)\n\nhttps://leetcode-cn.com/problems/same-tree/\n\n## 题目描述\n\n```\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n \n\n示例 1：\n\n输入：p = [1,2,3], q = [1,2,3]\n输出：true\n\n\n示例 2：\n\n输入：p = [1,2], q = [1,null,2]\n输出：false\n\n\n示例 3：\n\n输入：p = [1,2,1], q = [1,1,2]\n输出：false\n\n\n \n\n提示：\n\n两棵树上的节点数目都在范围 [0, 100] 内\n-104 <= Node.val <= 104\n```\n\n## 前置知识\n\n- 深度优先遍历\n- 二叉树\n\n## 思路\n先判断特殊情况：二者均为空，或其中一个为空\n\n深度优先遍历，递归判断左子树和右子树是否相等\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if (p == null && q == null) {\n        return true;\n    } else if ((p !== null && q == null) || (p == null && q !== null)) {\n        return false;\n    }\n    if (p.val !== q.val) {\n        return false;\n    } else {\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100115454","body":"\n## 题目地址(129. 求根节点到叶节点数字之和)\n\nhttps://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n## 题目描述\n\n```\n给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n\n每条从根节点到叶节点的路径都代表一个数字：\n\n例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。\n\n计算从根节点到叶节点生成的 所有数字之和 。\n\n叶节点 是指没有子节点的节点。\n\n \n\n示例 1：\n\n输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n\n示例 2：\n\n输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n\n\n \n\n提示：\n\n树中节点的数目在范围 [1, 1000] 内\n0 <= Node.val <= 9\n树的深度不超过 10\n```\n\n\n## 思路\n深度优先遍历 DFS\n\n当前节点和 = 前置节点 * 10 + 当前节点值， 把当前节点当做子树的前置节点进行递归。没有值了就结束啦\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return tree(root, 0);\n};\n\nfunction tree(root, presum) {\n    if (!root) return null;\n    let sum = presum * 10 + root.val;\n    if (root.left == null && root.right == null) {\n        return sum;\n    } else {\n        return tree(root.left, sum) + tree(root.right, sum);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\nn为二叉树的节点个数\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100671796","body":"\n## 题目地址(513. 找树左下角的值)\n\nhttps://leetcode-cn.com/problems/find-bottom-left-tree-value/\n\n## 题目描述\n\n```\n给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n\n假设二叉树中至少有一个节点。\n\n \n\n示例 1:\n\n输入: root = [2,1,3]\n输出: 1\n\n\n示例 2:\n\n输入: [1,2,3,4,null,5,6,null,null,7]\n输出: 7\n\n\n \n\n提示:\n\n二叉树的节点个数的范围是 [1,104]\n-231 <= Node.val <= 231 - 1 \n```\n\n## 前置知识\n\n- DFS\n\n## 思路\n前序遍历 DFS\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let maxDepth = 0;\n    let res = root.val;\n\n    dfs(root.left, 0);\n    dfs(root.right, 0);\n\n    return res;\n\n    function dfs(cur, depth) {\n        if (!cur) {\n            return;\n        }\n        const curDepth = depth + 1;\n        if (curDepth > maxDepth) {\n            maxDepth = curDepth;\n            res = cur.val;\n        }\n        dfs(cur.left, curDepth);\n        dfs(cur.right, curDepth);\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点数，h为树的高度\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(h)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100884701","body":"\n## 题目地址(297. 二叉树的序列化与反序列化)\n\nhttps://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\n\n## 题目描述\n\n```\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n \n\n示例 1：\n\n输入：root = [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]\n\n\n示例 2：\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n输入：root = [1,2]\n输出：[1,2]\n\n\n \n\n提示：\n\n树中结点数在范围 [0, 104] 内\n-1000 <= Node.val <= 1000\n```\n\n## 思路\n先序遍历这颗二叉树，遇到空子树的时候序列化成 None，否则继续递归序列化。\n\n根据 , 把原先的序列分割开来得到先序遍历的元素列表，然后从左向右遍历这个序列：\n\n- 如果当前的元素为 None，则当前为空树\n- 否则先解析这棵树的左子树，再解析它的右子树\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点数。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101428790","body":"\n## 题目地址(987. 二叉树的垂序遍历)\n\nhttps://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/\n\n## 题目描述\n\n```\n给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\n\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\n\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n\n返回二叉树的 垂序遍历 序列。\n\n \n\n示例 1：\n\n输入：root = [3,9,20,null,null,15,7]\n输出：[[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列  1 ：只有结点 20 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n示例 2：\n\n输入：root = [1,2,3,4,5,6,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列  0 ：结点 1 、5 和 6 都在此列中。\n          1 在上面，所以它出现在前面。\n          5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列  1 ：只有结点 3 在此列中。\n列  2 ：只有结点 7 在此列中。\n\n\n示例 3：\n\n输入：root = [1,2,3,4,6,5,7]\n输出：[[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。\n\n \n\n提示：\n\n树中结点数目总数在范围 [1, 1000] 内\n0 <= Node.val <= 1000\n```\n\n## 思路\nDFS + 三元组\n\n- DFS 遍历树的节点，对于每个节点，求得坐标，并获得节点的三元组 (row, col, val)，分别为行，列，节点值\n- 对三元组按照 列从小到大，行从小打到，值从小到大进行排序\n- 排序后的数组元素顺序和题目要求结果的元素顺序相同，只需要对同一列的元素合并成同一个数组即可\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    const nodeArr = [];\n\n    const getNodeArr = function dfs(root, i, j) {\n        if (!root) return;\n\n        nodeArr.push([i, j, root.val]);\n        dfs(root.left, i + 1, j - 1);\n        dfs(root.right, i + 1, j + 1);\n    };\n\n    getNodeArr(root, 0, 0);\n\n    nodeArr.sort((a, b) => {\n        if (a[1] !== b[1]) return a[1] - b[1];\n        if (a[0] !== b[0]) return a[0] - b[0];\n        return a[2] - b[2];\n    });\n\n    const resArr = [];\n    let lastCol = -1010; // -1000 <= col <= 1000\n    for (let i = 0; i < nodeArr.length; ++i) {\n        let curCol = nodeArr[i][1];\n        if (curCol !== lastCol) {\n            lastCol = curCol;\n            resArr.push([]);\n        }\n        resArr[resArr.length - 1].push(nodeArr[i][2]);\n    }\n\n    return resArr;\n};\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：O(n²)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101928112","body":"\n## 题目地址(1. 两数之和)\n\nhttps://leetcode-cn.com/problems/two-sum/\n\n## 题目描述\n\n```\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n \n\n示例 1：\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n \n\n提示：\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n只会存在一个有效答案\n\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n```\n\n## 思路\n哈希表存 key 和 value，key对应数值，value对应下标。\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    var map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (map.has(target - nums[i])) {\n            return [map.get(target - nums[i]), i];\n        } else {\n            map.set(nums[i], i);\n        }\n    }\n    return [-1, -1];\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103676567","body":"\n## 题目地址(347. 前 K 个高频元素)\n\nhttps://leetcode-cn.com/problems/top-k-frequent-elements/\n\n## 题目描述\n\n```\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n \n\n示例 1:\n\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n\n示例 2:\n\n输入: nums = [1], k = 1\n输出: [1]\n\n \n\n提示：\n\n1 <= nums.length <= 105\nk 的取值范围是 [1, 数组中不相同的元素的个数]\n题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n \n\n进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。\n```\n\n## 思路\n哈希表存储元素和元素出现的次数\n\n数组排序返回出现频率前 k 高的元素\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    return arr.sort((a, b) => map.get(b) - map.get(a)).slice(0, k);\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105183162","body":"## 题目地址(447. 回旋镖的数量)\n\nhttps://leetcode-cn.com/problems/number-of-boomerangs/\n\n## 题目描述\n\n```\n给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。\n\n返回平面上所有回旋镖的数量。\n\n \n\n示例 1：\n\n输入：points = [[0,0],[1,0],[2,0]]\n输出：2\n解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n\n\n示例 2：\n\n输入：points = [[1,1],[2,2],[3,3]]\n输出：2\n\n\n示例 3：\n\n输入：points = [[1,1]]\n输出：0\n\n\n \n\n提示：\n\nn == points.length\n1 <= n <= 500\npoints[i].length == 2\n-104 <= xi, yi <= 104\n所有点都 互不相同\n```\n\n\n## 思路1\n三层循环，暴力解法\n\n## 代码1\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    if (points == null || points.length <= 2)\n        return 0;\n\n    let res = 0;\n\n    for (let i = 0; i < points.length; i++) {\n\n        for (let j = 0; j < points.length; j++) {\n\n            if (i == j)\n                continue;\n\n            for (let k = 0; k < points.length; k++) {\n\n                if (k == i || k == j)\n                    continue;\n\n                if (getDistance(points[i], points[j]) == getDistance(points[i], points[k]))\n                    res++;\n            }\n        }\n    }\n\n    return res;\n}\nlet x = [];\nlet y = [];\nfunction getDistance(x, y) {\n\n    let x1 = y[0] - x[0];\n    let y1 = y[1] - x[1];\n\n    return x1 * x1 + y1 * y1;\n\n}\n\n```\n\n\n**复杂度分析1**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n³)\n- 空间复杂度：O(n)\n## 思路2 看题解的。。\n哈希表+ 枚举\n\n## 代码2\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;\n    for (let p of points) {\n        const map = new Map();\n        for (let q of points) {\n            const dis = Math.pow((p[0] - q[0]), 2) + Math.pow((p[1] - q[1]), 2); \n            map.set(dis, (map.get(dis) || 0) + 1);\n        }\n        for (let [_, value] of map.entries()) {\n            ans += (value - 1) * value;\n        }\n    }\n    return ans;\n};\n\n```\n\n\n**复杂度分析2**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n²)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106247476","body":"## 题目地址(3. 无重复字符的最长子串)\n\nhttps://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n## 题目描述\n\n```\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n \n\n示例 1:\n\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n\n\n示例 2:\n\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n\n\n示例 3:\n\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n\n\n提示：\n\n0 <= s.length <= 5 * 104\ns 由英文字母、数字、符号和空格组成\n```\n## 前置知识\n滑动窗口、哈希表\n## 思路\n 滑动窗口：定义一个右指针，遍历数组，依次固定一个左节点，使用过的左节点删除，如果没有重复节点，右指针不断右移，直到右指针大于字符串长度或者已存在遍历到的节点。判断是否已经存在使用 Javascript 中的set。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1eaa8c05a3d94402a84b63d8ffcf55df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Lmf5rKh5Zyw5pa55Y67,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    var curr = new Set();\n    let r = 0;\n    let n = s.length;\n    let res = 0;\n    for (let i = 0; i < n; i++) {\n        if (i != 0) {\n            curr.delete(s.charAt(i - 1));\n        } \n        while (r < n && !curr.has(s.charAt(r))) {\n            curr.add(s.charAt(r));\n            r++;\n        }\n        res = Math.max(res, r - i);\n    }\n    return res;\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(|∑|)  ∑为可能出现字符串的个数，128\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107472418","body":"\n## 题目地址(30. 串联所有单词的子串)\n\nhttps://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/\n\n## 题目描述\n\n```\n给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。\n\n \n\n示例 1：\n\n输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 \"barfoo\" 和 \"foobar\" 。\n输出的顺序不重要, [9,0] 也是有效答案。\n\n\n示例 2：\n\n输入：s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n输出：[]\n\n\n示例 3：\n\n输入：s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n输出：[6,9,12]\n\n\n \n\n提示：\n\n1 <= s.length <= 104\ns 由小写英文字母组成\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\nwords[i] 由小写英文字母组成\n```\n\n## 前置知识\n- 哈希表\n- 滑动窗口\n\n## 思路\n使用滑动窗口，当窗口的大小和words的长度一致时，使用map存储该窗口根据单词长度划分的单词，\n\n将map和words构成的map进行对比，满足要求则输出left。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    let left = 0, right = 0;\n    let slen = s.length;\n    let wordLen = words[0].length;\n    let wordNum = words.length;\n    let wlen = wordNum * wordLen;\n    let wordMap = new Map();\n    for (let word of words) {\n        let count = wordMap.has(word) ? wordMap.get(word) : 0;\n        wordMap.set(word, count + 1);\n    }\n    let res = [];\n    while (right < slen) {\n        right++;\n        if (right - left === wlen) {\n            if (match(s.substring(left, right), wordMap, wordNum, wordLen)) {\n                res.push(left);\n            }\n            left++;\n        }\n    }\n    return res;\n};\n\nfunction match(str, wordMap, wordNum, wordLen) {\n    let map = new Map();\n    for (let i = 0; i < wordNum; i++) {\n        let word = str.substring(i * wordLen, (i + 1) * wordLen);\n        let count = map.has(word) ? map.get(word) : 0;\n        map.set(word, count + 1);\n    }\n    let matchflag = true;\n    for (let [key, value] of wordMap) {\n        if (!map.has(key) || map.get(key) !== value) {\n            matchflag = false;\n        }\n    }\n    return matchflag;\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107804570","body":"\n## 题目地址(1590. 使数组和能被 P 整除)\n\nhttps://leetcode-cn.com/problems/make-sum-divisible-by-p/\n\n## 题目描述\n\n```\n给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。\n\n请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。\n\n子数组 定义为原数组中连续的一组元素。\n\n \n\n示例 1：\n\n输入：nums = [3,1,4,2], p = 6\n输出：1\n解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。\n\n\n示例 2：\n\n输入：nums = [6,3,5,2], p = 9\n输出：2\n解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。\n\n\n示例 3：\n\n输入：nums = [1,2,3], p = 3\n输出：0\n解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。\n\n\n示例  4：\n\n输入：nums = [1,2,3], p = 7\n输出：-1\n解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。\n\n\n示例 5：\n\n输入：nums = [1000000000,1000000000,1000000000], p = 3\n输出：0\n\n\n提示：\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= p <= 109\n```\n\n## 前置知识\n\n- 哈希表\n- 前缀和\n- 同余定理：两个模 k 的余数相减，得到的数一定会被 k 整除\n\n## 思路\n以a1、a2、a3、a4为例，\n\n- 若mod等于0 ，则可以整除，表示当前整个数列都可以被p整除 无需移除子数列\n\n- 若mod不等于0,则需要移除子序列\n\n- 若s3 = a1 + a2 + a3 , S4 = a1 + a2 + a3 + a4, s4 % p == S3 % p , 则有 (S4-S3) % p == 0, 也代表在S4中移除S3之后 剩下的数之和可以被p整除\n\n- 若 Sm % p == (Sn - mod) % p 意味着(m,n]区间内有 ,(Sn - mod - Sm ) % p == 0; 那么(Sn-Sm)%p == mod , 这个可以简单的这么推一下 设 a = Sn - mod - Sm , 则 a + mod == Sn-Sm , (a + mod)%p == (a%p + mod%p)%p == mod % p == mod ;\n\n根据上一步可知使得整个数列mod不为0的子数列应该在(m,n]中间，然后我们只要遍历整个数组找到这个最小的区间便可。\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} p\n * @return {number}\n */\nvar minSubarray = function(nums, p) {\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n    }\n    let target = sum % p;\n    if(target == 0) return 0;\n\n    const map = new Map;\n    let curCount = 0;\n    let res = Infinity;\n    map.set(0,-1);\n    for( let i = 0 ; i < nums.length ; i++ ){\n        curCount += nums[i];\n        const curPos = (curCount - target + p) % p;\n        if( map.has(curPos) ){\n            res = Math.min(res, i - map.get(curPos));\n            if( res == 1 && nums.length > 1 ){\n                return res;\n            }\n        }\n        map.set(curCount % p,i)\n    }\n    res >= nums.length && (res = Infinity);\n    return res === Infinity ? -1 : res;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108548381","body":"\r\n## 题目地址(876. 链表的中间结点)\r\n\r\nhttps://leetcode-cn.com/problems/middle-of-the-linked-list/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个头结点为 head 的非空单链表，返回链表的中间结点。\r\n\r\n如果有两个中间结点，则返回第二个中间结点。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：[1,2,3,4,5]\r\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\r\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\r\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\r\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\r\n\r\n\r\n示例 2：\r\n\r\n输入：[1,2,3,4,5,6]\r\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\r\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n给定链表的结点数介于 1 和 100 之间。\r\n```\r\n\r\n## 前置知识\r\n\r\n- 快慢指针\r\n\r\n## 思路\r\n快指针每次前进两步，慢指针每次前进一步。\r\n\r\n当快指针为null 或快指针的下一个节点为null（为了处理偶数链表）时，慢指针恰好指向中间节点。\r\n## 关键点\r\n注意结果的输出\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar middleNode = function(head) {\r\n  let fast = head;\r\n  let slow = head;\r\n  while (fast && fast.next) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n  return slow;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109525314","body":"\n## 题目地址(26. 删除有序数组中的重复项)\n\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n## 题目描述\n\n```\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n判题标准:\n\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n如果所有断言都通过，那么您的题解将被 通过。\n\n \n\n示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n0 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums 已按 升序 排列\n```\n\n## 前置知识\n\n- 双指针\n\n## 思路\n双指针：左指针指示nums数组的连续索引值，right指示当前搜索到的元素位置。\n\n如果左右指针的值相等，右指针右移一位；如果不相等，左指针右移一位，同时左指针索引对应的值更新为当前右指针索引对应的值。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n  let left = 0;\n  let right = 1;\n  while (right <= nums.length) {\n    if (nums[right] == nums[left]) {\n      right++;\n    } else {\n      left++;\n      nums[left] = nums[right];\n    }\n  }\n  return left;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110488762","body":"\n## 题目地址(35. 搜索插入位置)\n\nhttps://leetcode-cn.com/problems/search-insert-position/\n\n## 题目描述\n\n```\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 O(log n) 的算法。\n\n \n\n示例 1:\n\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n\n\n示例 2:\n\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n\n\n示例 3:\n\n输入: nums = [1,3,5,6], target = 7\n输出: 4\n\n\n \n\n提示:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums 为 无重复元素 的 升序 排列数组\n-104 <= target <= 104\n```\n\n## 前置知识\n\n- 二分法\n\n## 思路\n经典二分\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (nums[mid] > target) {\n      right = mid - 1;\n    } else if(nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return left;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(log(n))\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111668025","body":"\n## 题目地址(239. 滑动窗口最大值)\n\nhttps://leetcode-cn.com/problems/sliding-window-maximum/\n\n## 题目描述\n\n```\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回 滑动窗口中的最大值 。\n\n \n\n示例 1：\n\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\n\n示例 2：\n\n输入：nums = [1], k = 1\n输出：[1]\n\n\n \n\n提示：\n\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n1 <= k <= nums.length\n```\n\n## 前置知识\n\n- 滑动窗口\n\n## 思路\n见注释\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n  // 队列数组（存放的是元素下标，为了取值方便）\n  const q = [];\n  // 结果数组\n  const ans = [];\n  for (let i = 0; i < nums.length; i++) {\n    // 若队列不为空，且当前元素大于等于队尾所存下标的元素，则弹出队尾\n    while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n      q.pop();\n    }\n    // 入队当前元素下标\n    q.push(i);\n    // 判断当前最大值（即队首元素）是否在窗口中，若不在便将其出队\n    while (q[0] <= i - k) {\n      q.shift();\n    }\n    // 当达到窗口大小时便开始向结果中添加数据\n    if (i >= k - 1) ans.push(nums[q[0]]);\n  }\n  return ans;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112827715","body":"\n## 题目地址(997. 找到小镇的法官)\n\nhttps://leetcode-cn.com/problems/find-the-town-judge/\n\n## 题目描述\n\n```\n小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。\n\n如果小镇法官真的存在，那么：\n\n小镇法官不会信任任何人。\n每个人（除了小镇法官）都信任这位小镇法官。\n只有一个人同时满足属性 1 和属性 2 。\n\n给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。\n\n如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。\n\n \n\n示例 1：\n\n输入：n = 2, trust = [[1,2]]\n输出：2\n\n\n示例 2：\n\n输入：n = 3, trust = [[1,3],[2,3]]\n输出：3\n\n\n示例 3：\n\n输入：n = 3, trust = [[1,3],[2,3],[3,1]]\n输出：-1\n\n \n\n提示：\n\n1 <= n <= 1000\n0 <= trust.length <= 104\ntrust[i].length == 2\ntrust 中的所有trust[i] = [ai, bi] 互不相同\nai != bi\n1 <= ai, bi <= n\n```\n\n## 前置知识\n\n- 有向图\n\n## 思路\n每个人是图的节点，trust 的元素 trust[i] 是图的有向边，从 trust[i][0] 指向 trust[i][1]。我们可以遍历 trust，统计每个节点的入度和出度，存储在inDegrees 和 outDegrees 中。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n  const inDegrees = new Array(n + 1).fill(0);\n  const outDegrees = new Array(n + 1).fill(0);\n  for (const edge of trust) {\n      const x = edge[0], y = edge[1];\n      ++inDegrees[y];\n      ++outDegrees[x];\n  }\n  for (let i = 1; i <= n; ++i) {\n      if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n        return i;\n      }\n  }\n  return -1;\n};\n\n```\n\n\n**复杂度分析**\n\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizimu0709":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873737","body":"- 思路\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\nAB两数都加完后判断进位 , 进位不为 0 加在前面。\r\n\r\n- 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] res, int K) {\r\n        List<Integer> Arr = new ArrayList<>();\r\n        int n = res.length;\r\n        int i = n-1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while(i >= 0 || K != 0){\r\n            int x = i >= 0 ? res[i] : 0;\r\n            int y = K >= 0 ? K%10 : 0;\r\n            sum = x + y +carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n             --i;\r\n             Arr.add(0,sum%10);\r\n        }\r\n        if(carry != 0)\r\n            Arr.add(0,carry);\r\n        return Arr;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091746423","body":"- 分析\r\n与链表长度成整数倍的旋转前后链表不变\r\n使用快慢指针找到倒数第 k 个节点，然后完成基本的链接与断开与断开操作\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || k == 0) return head;\r\n        // 计算有效的 k 值：对于与链表长度成整数倍的「旋转」都是没有意义的（旋转前后链表不变）\r\n        int tot = 0;\r\n        ListNode tmp = head;\r\n        while (tmp != null && ++tot > 0) tmp = tmp.next;\r\n        k %= tot;\r\n        if (k == 0) return head;\r\n\r\n        // 使用「快慢指针」找到倒数第 k 个节点（新头结点）：slow 会停在「新头结点」的「前一位」，也就是「新尾结点」\r\n        ListNode slow = head, fast = head;\r\n        while (k-- > 0) fast = fast.next;\r\n        while (fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        // 保存新头结点，并将新尾结点的 next 指针置空\r\n        ListNode nHead = slow.next;\r\n        slow.next = null;\r\n        // 将新链表的前半部分（原链表的后半部分）与原链表的头结点链接上\r\n        fast.next = head;\r\n        return nHead;\r\n    }\r\n}\r\n```\r\n复杂度\r\n\r\n- 时间复杂度：O(n)\r\n\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098192245","body":"思路：\r\n深度优先\r\n\r\n- dfs深度优先分别遍历左右两边子树的长度\r\n\r\n- 比较出最大值最后结果加1（父节点）即可\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root==null) return 0;\r\n        else{\r\n            int lLevel=maxDepth(root.left);\r\n            int rLevel=maxDepth(root.right);\r\n            return 1+Math.max(lLevel,rLevel);\r\n        }\r\n    }\r\n}\r\n```\r\n时间空间复杂度O(n)\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103314876","body":"思路\r\n\r\n- 把记录的数字和对应的出现次数放到堆中\r\n- 如果堆已满且当前数的次数比堆顶大，用当前元素替换堆顶元素\r\n- 返回\r\n```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> count = new HashMap<>();\r\n        for(int num : nums){\r\n            count.put(num, count.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>(){\r\n            public int compare(int[] m, int[] n){\r\n                return m[1] - n[1];\r\n            }\r\n        });\r\n        \r\n        for(Map.Entry<Integer, Integer> entry : count.entrySet()){\r\n            int num = entry.getKey(), cnt = entry.getValue();\r\n            if(queue.size() == k){\r\n                if(cnt > queue.peek()[1]){\r\n                    queue.poll();\r\n                    queue.offer(new int[]{num, cnt});\r\n                }\r\n            }else{\r\n                queue.offer(new int[]{num, cnt});\r\n            }\r\n        }\r\n\r\n        int[] res = new int[k];\r\n        for(int i = 0; i < k; i++){\r\n            res[i] = queue.poll()[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n- 时间复杂度：O(nlogk)\r\n\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085898822","body":"## Idea\r\nIterate through the number array backwards. Add each element to k, remove the last digit from k and add it to the list.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086368202","body":"## Idea\r\nIterate through the string for 3 times. Locate all occurrences of c in the first iteration. Update distance based on distance on the left side in the second iteration and update distance based on distance on the right side in the third iteration.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int[] ans = new int[str.length];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        for (int i = 0; i < str.length; i++) {\r\n            if (str[i] == c) {\r\n                ans[i] = 0;\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < str.length - 1; i++) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i+1] = Math.min(ans[i] + 1, ans[i+1]);\r\n            }\r\n        }\r\n        \r\n        for (int i = str.length-1; i > 0; i--) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i-1] = Math.min(ans[i] + 1, ans[i-1]);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866023","body":"## Idea\r\nStore the element in an array and use an int variable to represent the actual size.\r\n\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int cur = 0;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur < arr.length) {\r\n            arr[cur++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) {\r\n            return -1;\r\n        }\r\n        return arr[--cur];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, cur); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: push: O(1); pop: O(1); increment: O(min(k, cur))\r\nSpace: O(maxSize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087575778","body":"## Idea\r\nUse a queue and delegate the nested encoded string to recursion\r\nUse a int variable to store k and delegate decoding to recursion when there is a '[', and a ']' indicates that the job is done and should continue.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] str = s.toCharArray();\r\n        Queue<Character> q = new LinkedList<>();\r\n        for (char c : str) {\r\n            q.add(c);\r\n        }\r\n        return process(q);\r\n    }\r\n    \r\n    public String process(Queue<Character> q) {\r\n        int num = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!q.isEmpty()) {\r\n            char c = q.poll();\r\n            if (Character.isDigit(c)) {\r\n                num *= 10;\r\n                num += c - '0';\r\n            }\r\n            else if (c == '[') {\r\n                String s = process(q);\r\n                for (int i = 0; i < num; i++) {\r\n                    sb.append(s);\r\n                }\r\n                num = 0;\r\n            }\r\n            else if (c == ']') {\r\n                break;\r\n            }\r\n            else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088690453","body":"## Idea\r\nuse stack s1 for push and stack s2 for pop and peek\r\nWhenever pop or peek is invoked, we pop all elements from s1 into s2 if s2 is empty.\r\n\r\n## Code\r\n```\r\nclass MyQueue {\r\n    public Stack<Integer> s1;\r\n    public Stack<Integer> s2;\r\n    \r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    private void update() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        update();\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        update();\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Complexity\r\nTime: \r\npush O(1)\r\npop O(n)\r\npeek O(n)\r\nempty O(1)\r\n\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090409687","body":"## Idea\r\nUse increasing monotonic stack. If the next element to push is smaller than the element at the top, find the largest elements that is smaller than the current element. Every elements between this largest element(exclusive) and the current element(inclusive) will be considered in a chunk and we push the largest one among these elements back to the stack.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        int num = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (!s.isEmpty()) {\r\n                if (arr[i] >= s.peek()) {\r\n                    s.push(arr[i]);\r\n                }\r\n                else {\r\n                    int max = -1;\r\n                    while (!s.isEmpty() && s.peek() > arr[i]) {\r\n                        max = Math.max(max, s.pop());\r\n                    }\r\n                    s.push(max);\r\n                }\r\n            }\r\n            else {\r\n                s.push(arr[i]);\r\n            }\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094043729","body":"## Idea\nuse the middle point of the linkedlist as the root, the left part to the middle point is the left subtree and the right part to the middle point is the right subtree. Use two pointers to find out the middle point.\n\n## Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        if (slow != head) {\n            prev.next = null;\n            root.left = sortedListToBST(head);\n        }\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }   \n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094310014","body":"## Idea\r\nFind the difference between the length of two linkedlist. Traverse the longer list until two lists have same number of remaining nodes. Traverse two list at the same time and find the intersection. If null is reached before finding the intersection, there is no intersection.\r\n\r\n## Code\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        int sizeA = size(headA);\r\n        int sizeB = size(headB);\r\n        int diff = Math.abs(sizeA-sizeB);\r\n        ListNode tmp = sizeA > sizeB ? headA : headB;\r\n        ListNode tmp2 = tmp == headA ? headB : headA;\r\n        for (int i = 0; i < diff; i++) {\r\n            tmp = tmp.next;\r\n        }\r\n        while (tmp.next != null && tmp2.next != null && tmp != tmp2) {\r\n            tmp = tmp.next;\r\n            tmp2 = tmp2.next;\r\n        }\r\n        if (tmp.val == tmp2.val) {\r\n            return tmp;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    public int size(ListNode head) {\r\n        int size = 0;\r\n        ListNode tmp = head;\r\n        while (tmp.next != null) {\r\n            tmp = tmp.next;\r\n            size++;\r\n        }\r\n        return size;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(m+n)\r\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094313047","body":"## Idea\r\nUse two pointers to find the cycle, if any.\r\n\r\n## Code\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return null;\r\n        ListNode fast = head, slow = head;\r\n        while (true) {\r\n            // if any pointer reaches null, there is no cycle\r\n            slow = slow.next;\r\n            if (slow == null) return null;\r\n            fast = fast.next;\r\n            if (fast == null) return null;\r\n            fast = fast.next;\r\n            if (fast == null) return null;\r\n            \r\n            // if two pointers meet, there is a cycle\r\n            if (slow == fast) {\r\n                break;\r\n            }\r\n        }\r\n        // slow pointer restarts at head and fast remains its own position, find the cycle\r\n        slow = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1101861418","body":"## Idea\r\nUse a map and a doubly linked list to store the keys and values.\r\n\r\n## Code\r\n```\r\nclass LRUCache {\r\n    public Map<Integer, Node> cache;\r\n    public int capacity;\r\n    public Node head, tail;\r\n    \r\n    class Node {\r\n        public int key;\r\n        public int val;\r\n        public Node prev;\r\n        public Node next;\r\n        \r\n        public Node(){};\r\n        public Node(int k, int v, Node p, Node n) {\r\n            this.key = k;\r\n            this.val = v;\r\n            this.prev = p;\r\n            this.next = n;\r\n        }\r\n    }\r\n        \r\n    public LRUCache(int capacity) {\r\n        this.cache = new HashMap<>();\r\n        this.capacity = capacity;\r\n        this.head = new Node();\r\n        this.tail = new Node();\r\n        head.prev = null;\r\n        head.next = tail;\r\n        tail.prev = head;\r\n        tail.next = null;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (cache.containsKey(key)) {\r\n            Node node = cache.get(key); \r\n            moveToTail(node);\r\n            return node.val;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            Node node = cache.get(key);\r\n            node.val = value;\r\n            moveToTail(node);\r\n            return;\r\n        }\r\n        Node node = new Node();\r\n        node.key = key;\r\n        node.val = value;\r\n        cache.put(key, node);\r\n        addNode(node);\r\n        int size = cache.size();\r\n        \r\n        if (size > capacity) {\r\n            Node toRemove = head.next;\r\n            removeNode(toRemove);\r\n            cache.remove(toRemove.key, toRemove);\r\n        }\r\n    }\r\n\r\n    private void addNode(Node node) {\r\n        Node tmp = tail.prev;\r\n        tmp.next = node;\r\n        node.prev = tmp;\r\n        node.next = tail;\r\n        tail.prev = node;\r\n    }\r\n\r\n    private void removeNode(Node node) {\r\n        Node p = node.prev;\r\n        Node n = node.next;\r\n        p.next = n;\r\n        n.prev = p;\r\n    }\r\n\r\n    public void moveToTail(Node node) {\r\n        removeNode(node);\r\n        addNode(node);\r\n    }\r\n}\r\n```\r\n## Time Complexity\r\nTime: O(1) for get() and put()\r\nSpace: O(n)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100572629","body":"## Idea\r\npreorder DFS\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return preorder(root, 0);\r\n    }\r\n    \r\n    public int preorder(TreeNode root, int sum) {\r\n        if (root == null) return 0;\r\n        sum = sum * 10 + root.val;\r\n        if (root.left == null && root.right == null) return sum;\r\n        return preorder(root.left, sum) + preorder(root.right, sum);\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100566595","body":"## Idea\r\nBFS and record the left most value on each level\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int left = 0;\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        q.add(root);\r\n        while (!q.isEmpty()) {\r\n            int size = q.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = q.poll();\r\n                if (i == 0) {\r\n                    left = cur.val;\r\n                }\r\n                if (cur.left != null) q.add(cur.left);\r\n                if (cur.right != null) q.add(cur.right);\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n## Complexity\r\ntime: O(n)\r\nspace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101601310","body":"## Idea\r\nUse a map to store the element and its index\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target)\r\n    {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            map.put(nums[i], i);\r\n        }\r\n        int[] res = new int[2];\r\n        for (int i = 0; i < nums.length; i ++) {\r\n            if (map.containsKey(target-nums[i]) && map.get(target-nums[i]) != i) {\r\n                res[0] = i;\r\n                res[1] = map.get(target-nums[i]);\r\n                break;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Time Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103026115","body":"## Idea\r\nUse a map to store all elements as key and their number of occurrence as value, and then use a PriorityQueue to sort them by frequency.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    static class Num {\r\n        int number;\r\n        int frequent;\r\n        \r\n        public Num(int n, int f) {\r\n            this.number = n;\r\n            this.frequent = f;\r\n        }\r\n    }\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(nums[i])) {\r\n                int freq = map.get(nums[i]);\r\n                map.put(nums[i], freq+1);\r\n            }\r\n            else {\r\n                map.put(nums[i], 1);\r\n            }\r\n        }\r\n        PriorityQueue<Num> q = new PriorityQueue<>((n1, n2) -> n2.frequent - n1.frequent);\r\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            q.add(new Num(entry.getKey(), entry.getValue()));\r\n        }\r\n        int[] res = new int[k];\r\n        for (int i = 0; i < k; i++) {\r\n            res[i] = q.poll().number;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(nlogn)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105405583","body":"## Idea\r\nTreat each element as the middle point and iterate through the array and store the distance from this middle point to all other elements in a hashmap with other points as values\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int res = 0;\r\n        for (int i = 0; i < points.length; i++) {\r\n            Map<Integer, Set<int[]>> map = new HashMap<>();\r\n            int[] p1 = points[i];\r\n            for (int j = 0; j < points.length; j++) {\r\n                int[] p2 = points[j];\r\n                if (i == j) continue;\r\n                int dis = distance(p1[0], p1[1], p2[0], p2[1]);\r\n                if (!map.containsKey(dis)) {\r\n                    Set<int[]> set = new HashSet<>();\r\n                    set.add(p2);\r\n                    map.put(dis, set);\r\n                }\r\n                else {\r\n                    Set<int[]> set = map.get(dis);\r\n                    set.add(p2);\r\n                }\r\n            }\r\n            for (Integer dis : map.keySet()) {\r\n                int n = map.get(dis).size();\r\n                if (n >= 2) {\r\n                    res += n*(n-1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public int distance(int x1, int y1, int x2, int y2) {\r\n        return (y2-y1)*(y2-y1) + (x2-x1)*(x2-x1);\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n^2)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106629183","body":"## Idea\r\nUse an array instead of a hashmap to store the index of the characters and update pointer when the current character is already in the array.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        if (s.length() == 0) return 0;\r\n        char[] c = s.toCharArray();\r\n        int[] map = new int[256];\r\n        Arrays.fill(map, -1);\r\n        int max = 0;\r\n        int pre = -1;\r\n        int cur = 0;\r\n        for (int i = 0; i < c.length; i++) {\r\n            pre = Math.max(pre, map[c[i]]);\r\n            cur = i - pre;\r\n            max = Math.max(cur, max);\r\n            map[c[i]] = i;\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107881645","body":"## Idea\r\nUse fast and slow pointers. When the fast pointer reaches the end, the slow one is in the middle.\r\n## Code\r\n```\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast.next != null && fast.next.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        if (fast.next == null) {\r\n            return slow;\r\n        }\r\n        return slow.next;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiayuhui231":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085901627","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n   - 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\n   - 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\n## C++代码\n``` class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int t = k, idx=0;\n        vector<int> ans;\n        while(t)\n        {\n            if(idx<num.size()) t+=num[idx++];\n            ans.push_back(t%10);\n            t /= 10;\n        }\n        while(idx<num.size()) ans.push_back(num[idx++]);\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```\n## 复杂度\n     时间：O(n）\n     空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558705","body":"## 题目\n字符的最短距离\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n## 思路\n- 前后各遍历一次，找最短距离\n## 代码\n``` class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n            vector<int> pos(s.size(),-1);\n        int pre = -1;\n        for(int i = s.size() -1;i >= 0;i--)\n            if(s[i] == c){\n                pre = i;\n                pos[i] = 0;\n            }else if(pre != -1) pos[i] = pre - i;\n        pre = -1;\n        for(int i = 0;i < s.size();i++){\n            if(s[i] == c){\n                pre = i;\n        }else if(pos[i] == -1 && pre != -1){\n            pos[i] = i - pre;\n        }else if(pos[i] != -1 && pre != -1){\n            pos[i] = min( i - pre, pos[i]);\n        }\n        }\n        return pos;\n    }\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086872513","body":"# 代码\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top;\n\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if (top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for (int i = 0; i < lim; ++i) {\n            stk[i] += val;\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087671554","body":"## 题目\n字符串解码\nhttps://leetcode-cn.com/problems/decode-string/\n## 思路\n     可以结合分配律，先将括号里的字母结合起来\n\n## 代码\n``` \nclass Solution {\npublic:\n    string decodeString(string s) {\n         int len = s.size();\n        int num = 0;\n        stack<int> numstack;\n        stack<string> strstack;\n        string cur = \"\";\n        string result = \"\";\n        for(int i=0; i<len; ++i)\n        {\n            if(s[i]>='0' && s[i]<='9')\n            {\n                num = 10*num + s[i] - '0';\n            }\n            else if(s[i] == '[')\n            {\n                numstack.push(num);\n                strstack.push(cur);\n                num = 0;\n                cur.clear();\n            }\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\n                cur += s[i];\n            else if(s[i] == ']')\n            {\n                int k = numstack.top();\n                numstack.pop();\n                for(int j=0; j<k; ++j)\n                    strstack.top() += cur;\n                cur = strstack.top();\n                strstack.pop();\n            }\n        }\n        result = result + cur;\n        return result;     \n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088804924","body":"## 代码\n```\nclass MyQueue {\npublic:\n    stack<int> stIn;\n    stack<int> stOut;\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）\n        if (stOut.empty()) {\n            // 从stIn导入数据直到stIn为空\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n    }\n\n    /** Get the front element. */\n    int peek() {\n        int res = this->pop(); // 直接使用已有的pop函数\n        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n        return res;\n    }\n\n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090438471","body":"## 代码\n```\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> premax(n), sumin(n);\n        // 前缀最大\n        for (int i = 0; i < n; i++) {\n            if (i == 0) premax[i] = arr[i];\n            else premax[i] = max(premax[i - 1], arr[i]);\n        }\n        // 后缀最小\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1) sumin[i] = arr[i];\n            else sumin[i] = min(sumin[i + 1], arr[i]);\n        }\n        int ans = 1;\n        // 如果当前位置的前缀最大值小于等于下一个位置的后缀最小，说明当前位置小于等于后面所有位置，可分一块，ans++\n        for (int i = 0; i < n - 1; i++) {\n            if (premax[i] <= sumin[i + 1]) ans++;\n        }\n        return ans;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091892765","body":"## 题目\n旋转链表 \nhttps://leetcode-cn.com/problems/rotate-list/comments/\n## 思路\n     先遍历求得总长度，再找到原表倒数第k+1个节点，该节点next个节点就是新的头结点\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || head->next == nullptr || k==0) return head;\n        int count = 1;\n        ListNode* tail = head;\n        //ListNode* tmp = head;\n        while(tail->next != nullptr){\n            count++;\n            tail = tail->next;\n        }\n        k %= count;\n\n        if(k == 0) return head;\n        // 不满足上述条件，必将进行旋转，所以先将首尾相连\n        tail->next = head;\n        // 现在只需要找到倒数第k+1个节点\n        for(int i = 0; i< count-k; i++){\n            tail = tail->next;\n        }\n        ListNode* newHead = tail->next;\n        tail->next = nullptr;\n        return newHead;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092651388","body":"## 题目\n两两交换链表中的节点\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/\n\n## 思路\n    利用递归，先将每一级的链表交换，返回交换后的链表，上一级就接着整理好的链表继续递归，每一层只改动两个节点，head、next\n\n## 代码\n```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr) return head;\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        return next;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094076416","body":" 代码\r\n\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        TreeNode* root;       \r\n        if(!head)\r\n            return nullptr;\r\n        \r\n        if(!head->next){\r\n            root = new TreeNode(head->val);\r\n            return root;\r\n        }        \r\n        \r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n        ListNode *prev = head;\r\n        \r\n        while(fast != NULL && fast->next != NULL){\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        \r\n        while(prev->next != slow)\r\n            prev = prev->next;      \r\n        root = new TreeNode(slow->val);\r\n        ListNode* headRight = slow->next;\r\n        prev->next = nullptr;\r\n        root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(headRight);\r\n        \r\n        return root;\r\n        \r\n    } \r\n\r\n};\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094167873","body":"## 题目\n相交链表\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 思路\n两链表总会走相同的路程，故只需A走完，走B，B走完走A，他们总会相遇的。\n\n##代码\n``` \nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) {\n            return NULL;\n        }\n        ListNode* node1 = headA, * node2 = headB;\n        while(node1 != node2){\n            node1 = node1 ? node1->next : headB;\n            node2 = node2 ? node2->next : headA;\n        }\n        return node1;\n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(m+n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095028658","body":"## 题目\n环形链表\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n## 思路\n   快慢指针，总会相遇则交点为起始点，反之则无\n## 代码\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head, * fast = head;\n        while(fast && fast->next){\n            slow = slow -> next;\n            fast = fast->next->next;\n            if(slow == fast){\n                ListNode* cur = head;\n                while(cur != slow){\n                    cur = cur->next;\n                    slow = slow->next;\n                }\n                return cur;\n            }\n        }\n        return NULL;\n        \n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096928840","body":" 代码\r\nstruct DoubleLinkList {\r\n\tDoubleLinkList* pre;\r\n\tDoubleLinkList* next;\r\n\tint key;\r\n\tint value;\r\n\tDoubleLinkList(int key, int value) : key(key), value(value), pre(NULL), next(NULL) {};\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n\t// 表头\r\n\tDoubleLinkList* head;\r\n\t// 表尾\r\n\tDoubleLinkList* tail;\r\n\t// 缓存，记录key所对应的链表节点\r\n\tmap<int, DoubleLinkList*> memory;\r\n\t// 容量\r\n\tint cacheCapacity = 0;\r\n\tLRUCache(int capacity) {\r\n\t\t// 初始化\r\n\t\tcacheCapacity = capacity;\r\n\t\thead = new DoubleLinkList(-1, -1);\r\n\t\ttail = new DoubleLinkList(-1, -1);\r\n\t\thead->next = tail;\r\n\t\ttail->pre = head;\r\n\t}\r\n\r\n\tint get(int key) {\r\n\t\t// 如果缓存中查找到该key, 则需更新该key为最近使用（即放到表尾）\r\n\t\tif (memory.find(key) != memory.end()) {\r\n\t\t\tDoubleLinkList* node = memory[key];\r\n\t\t\t// 从链表中移除该节点\r\n\t\t\tremoveNode(node);\r\n\t\t\t// 将该节点放至表尾\r\n\t\t\tpushNode(node);\r\n\t\t\treturn node->value;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tvoid put(int key, int value) {\r\n\t\t// 如果缓存中有当前key\r\n\t\tif (memory.find(key) != memory.end()) {\r\n\t\t\tDoubleLinkList* node = memory[key];\r\n\t\t\t// 从链表中移除该节点\r\n\t\t\tremoveNode(node);\r\n\t\t\t// 将该节点放至表尾\r\n\t\t\tpushNode(node);\r\n\t\t\t// 修改节点对应的值\r\n\t\t\tnode->value = value;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// 如果内存已经放满\r\n\t\tif (memory.size() == cacheCapacity) {\r\n\t\t\t// 获取链表头结点的key\r\n\t\t\tint topKey = head->next->key;\r\n\t\t\t// 移除链表中的首个节点，并从memory中移除该key\r\n\t\t\tremoveNode(head->next);\r\n\t\t\tmemory.erase(topKey);\r\n\t\t}\r\n\t\t// 表尾放置新key\r\n\t\tDoubleLinkList* node = new DoubleLinkList(key, value);\r\n\t\tpushNode(node);\r\n\t\t// 存入缓存\r\n\t\tmemory[key] = node;\r\n\t}\r\n\t// 从链表中移除节点\r\n\tvoid removeNode(DoubleLinkList* node) {\r\n\t\t// 将该节点从链表中移除\r\n\t\tnode->pre->next = node->next;\r\n\t\tnode->next->pre = node->pre;\r\n\t}\r\n\t// 表尾插入结点\r\n\tvoid pushNode(DoubleLinkList* node) {\r\n\t\tnode->pre = tail->pre;\r\n\t\ttail->pre->next = node;\r\n\t\tnode->next = tail;\r\n\t\ttail->pre = node;\r\n\t}\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098111765","body":"## 题目\n二叉树的最大深度 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/\n## 思路\n    递归\n## 代码\n``` \nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return max(left,right)+1;\n\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1100113552","body":"class Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n          if(p&&q)\r\n            {\r\n            if((p->val==q->val)&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right))\r\n            return true;\r\n            else\r\n            return false;\r\n            }\r\n           else if(p==nullptr&&q==nullptr)\r\n           return true;\r\n            else\r\n            return false;\r\n    }\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100079471","body":"## 题目\n求根节点到叶节点数字之和  \nhttps://leetcode-cn.com/problems/sum-root-to-leaf-numbers/submissions/\n\n## 思路\n    利用递归，往上依次将前一个数乘10相加，最后左右相加。\n\n## 代码\n```\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root,0);\n    }\n\n    long long dfs(TreeNode*root, long long sum){\n        if(!root) return 0;\n        if(!root->left  && !root->right) return sum+root->val;\n        sum += root->val;\n        return dfs(root->left, 10*sum)+ dfs(root->right, 10*sum);\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100665027","body":"## 题目\n找树左下角的值 \nhttps://leetcode-cn.com/problems/find-bottom-left-tree-value/comments/\n\n## 思路\n    先遍历左边的节点，当左右树深度最大且相同时，就直接返回左值，抛弃右值。\n\n## 代码\n```\nclass Solution {\npublic:\n    TreeNode* targtNode;\n    int maxHigh = 0;\n    int findBottomLeftValue(TreeNode* root) {\n       dfs(root, 1);\n       return targtNode->val;\n    }\n    \n    void dfs (TreeNode* node, int higt){\n        if(!node->left && !node->right){\n            if(higt > maxHigh){\n                targtNode = node;\n                maxHigh = higt;\n            }\n            return;\n        }\n        if(node->left) dfs(node->left, higt+1);\n        if(node->right) dfs(node->right, higt+1);\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100871403","body":"## 题目\n二叉树的序列化与反序列化\nhttps://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/\n\n## 思路\n    层序遍历\n## 代码\n```\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if(root == NULL) return \"#_\";\n        string res = to_string(root->val) + \"_\";\n        res += serialize(root->left);\n        res += serialize(root->right);\n        return res;\n        \n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        std::stringstream ss(data);\n        std::string item;\n        queue<string> q;\n       while (std::getline(ss, item, '_')) \n        q.push(item);\n        return helper(q);\n    }\n\n    TreeNode* helper(queue<string>& q){\n        string val = q.front();\n        q.pop();\n        if(val == \"#\")\n            return NULL;\n        TreeNode* head = new TreeNode(stoi(val));\n        head->left = helper(q);\n        head->right = helper(q);\n        return head;\n    }\n};\n```\n复杂度：\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101397779","body":"## 题目\n二叉树的垂序遍历 \nhttps://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/\n## 思路\n    可以先将所有值及列值放入map中，再依次取出\n\n## 代码\n```\nclass Solution {\npublic:\n    map<int, multiset<int>> res;\n    void helpr(TreeNode* node,int m, int n){\n        if(!node) return ;\n        res[m].insert(n*10000+node->val);\n        helpr(node->left,m-1,n+1);\n        helpr(node->right,m+1,n+1);\n        return;\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        helpr(root,0,0);\n        vector<vector<int>>num;\n        for(auto x:res){\n            vector<int>cur;\n            for(auto v:x.second){\n                cur.push_back(v%10000);\n            }\n                num.push_back(cur);\n        }\n        return num;\n\n    }\n};\n```\n\n## 复杂度：\n时间复杂度:O(nlogn)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102801782","body":"## 题目\n两数之和\nhttps://leetcode-cn.com/problems/two-sum/\n\n## 代码\n```\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n std::unordered_map <int,int> map;\n        for(int i = 0; i < nums.size(); i++) {\n            auto iter = map.find(target - nums[i]);\n            if(iter != map.end()) {\n                return {iter->second, i};\n            }\n            map.insert(pair<int, int>(nums[i], i));\n        }\n        return {};\n    }\n};\n```\n\n## 复杂度：\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103852007","body":"## 题目\n前K个高频元素\nhttps://leetcode-cn.com/problems/top-k-frequent-elements/submissions/\n\n## 思路\n将数组插入到map中，并统计次数。利用小顶堆排序，将前k个值存入数组中输出\n\n## 代码\n```\nclass Solution {\npublic:\n    // 小顶堆\n    class mycomparison {\n    public:\n        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n            return lhs.second > rhs.second;\n        }\n    };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int> map;\n        for(auto x:nums) map[x]++;\n        \n        priority_queue<pair<int,int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        for(unordered_map<int,int>::iterator it = map.begin(); it != map.end(); it++){\n            pri_que.push(*it);\n            if(pri_que.size() > k){\n                pri_que.pop();\n            }\n        }\n        vector<int>res(k);\n        for(int i = k-1;i>=0;i--){\n            res[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n        return res;\n    }\n};\n```\n\n##复杂度：\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105438492","body":"代码\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n const int n = points.size();\r\n        int ans = 0;\r\n        unordered_map<int,int> dicts;\r\n        for(int i = 0; i < n; ++i){\r\n            dicts.clear();\r\n            for(int j = 0; j < n; ++j){\r\n                if(i == j) continue;\r\n                int x1 = points[i][0], y1 = points[i][1];\r\n                int x2 = points[j][0], y2 = points[j][1];\r\n                long long d = (x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1);\r\n                dicts[d]++;\r\n            }\r\n            for(auto & [k,v] : dicts){ // 遍历哈希表的方式 \r\n                ans += (v)*(v-1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106583735","body":"## 题目\n无重复字符的最长子串\nhttps://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n## 思路\n    滑动窗口，当有重复字母，窗口左移一位\n\n## 代码\n```\nclass Solution {\npublic:\nint hashmap[130];\n    int lengthOfLongestSubstring(string s) {\n        int max = 0;\n        int n = s.size();\n        for(int i = 0,j=0;j<n;j++){\n            hashmap[s[j]]++;\n            while(hashmap[s[j]]>1){\n                hashmap[s[i++]]--;\n            }\n            if(j-i+1 > max){\n                max = j-i+1;\n            }\n        }\n        return max;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107455627","body":"## 题目\n串联所有单词的子串\nhttps://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/comments/\n\n## 代码\n```\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        if(s.empty() || words.empty()) return {};\n        int n = words.size(), m = words[0].size(),j=0;\n        if(s.size() < m*n) return {};\n        vector<int> res;\n        unordered_map<string,int>mp,tmp;\n        for(auto str: words){\n            mp[str]++;\n        }\n        string str = \"\";\n        for(int i = 0; i+m*n<= s.size();i++){\n            for( j = i;j<i+m*n;j+=m){\n                str =  s.substr(j,m);\n                if(mp.find(str) == mp.end()) break;\n                tmp[str]++;\n            }\n            if(j == i+m*n && tmp == mp) res.push_back(i);\n            tmp.clear();\n        }\n        return res;\n\n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(n^m)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107838205","body":"## 代码\n```\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> s(n + 1);\n        for(int i = 1; i <= nums.size(); i ++)\n            s[i] = s[i - 1] + nums[i - 1];\n        \n        unordered_map<int, int> cnt;//表示每一个前缀和除以k余数的数量\n        cnt[0] ++;\n        int res = 0;\n        for(int i = 1; i <= n; i ++) {\n            int r = (s[i] % k + k) % k;\n            res += cnt[r];\n            cnt[r] ++;\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108738343","body":"## 题目\n链表的中间节点\nhttps://leetcode-cn.com/problems/middle-of-the-linked-list/submissions/\n\n## 代码\n```\n ListNode* cur=head;\n        vector<ListNode*> res;\n        int len=0;\n        while(cur!=nullptr){\n            len++;\n            res.push_back(cur);\n            cur=cur->next;\n        }\n        return res[len/2];\n```\n## 复杂度\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109743019","body":"## 题目\n删除有序数组中的重复项\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/\n## 代码\n```\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int j = 0;\n        for(int i = 1;i<nums.size();i++){\n            if(nums[j] != nums[i]){\n                nums[++j] = nums[i];\n            }\n        }\n        return ++j;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111063341","body":"## 题目\n搜索插入位置\nhttps://leetcode-cn.com/problems/search-insert-position/submissions/\n## 代码\n```\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0;\n        int right = n;\n        while(left<right){\n            int middle = left + ((right-left) >> 1);\n                if(nums[middle] > target){\n                    right = middle;\n                }else if(nums[middle]<target){\n                    left = middle + 1;\n                }else{\n                    return middle;\n                }\n        }\n        return  right;\n}\n```\n\n## 复杂度：\n时间复杂度：O(logn)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112181882","body":"## 题目\n滑动窗口最大值\nhttps://leetcode-cn.com/problems/sliding-window-maximum/comments/\n## 思路\n遇到一个新元素就把队列尾部不大于它的元素都弹出去，并且在尾部压入新元素\n如果队列头部元素超出窗口范围，就弹出头部\n每次头部元素是最大值，输出到结果中即可 \n\n## 代码\n```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n  vector<int> res;\n        deque<int> a;\n        for(int i=0;i<nums.size();i++){\n            while(!a.empty()&&nums[a.back()]<=nums[i])\n                a.pop_back();\n            if(!a.empty()&&a.front()==i-k)\n                a.pop_front();\n            a.push_back(i);\n            if(i>=k-1)\n                res.push_back(nums[a.front()]);\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113150483","body":"## 题目\n找到小镇的法官\n\n## 代码\n```\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegree(n + 1 , 0);\n        vector<int> outDegree(n + 1 , 0);\n\n        for(const auto pairs : trust){\n            inDegree[pairs[1]] += 1;\n            outDegree[pairs[0]] += 1;\n        }\n        \n        for(int i = 1; i < inDegree.size() ; ++i){\n            if(inDegree[i] == n - 1 and outDegree[i] == 0)      return i;\n        }\n        return -1;\n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085906678","body":"# Plan:\r\n```\r\niterate from end of num, last digit of k, insert to the head of the linkedlist, update carry, curSum\r\n\r\nedge cases: k is longer, num is longer, carry == 1 in the end\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int numIndex = num.length - 1;\r\n        int curSum = 0, carry = 0;\r\n        \r\n        while (numIndex >= 0) {\r\n            curSum = num[numIndex] + k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n            numIndex--;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            curSum = k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) sum.addFirst(carry);\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity:\r\n```\r\nTime: O(max(num.length, log_10_k))\r\nSpace: O(max(num.length, log_10_k)) for the linkedlist\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537211","body":"# Plan & Complexity: \n\n```\nIt is guaranteed that c occurs at least once in s.\n1 <= s.length <= 10^4\n\ns = \"loveleetcode\", c = \"e\"\n\nl o v e l e e t c o d e\nm m m 0 1 0 0 1 2 3 4 0\n3 2 1 0 1 0 0 1 2 2 1 0\n\nidea: two traversals, left-> right, right -> left\n\nTime: O(s.length())\nSpace: O(s.length()) for the distances array\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()];\n        int toCompare = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.abs(toCompare - i);\n            }\n        }\n        \n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.min(distances[i], Math.abs(toCompare - i));\n            }\n        }\n        \n        return distances;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897041","body":"```java\n/*\nBruteforce:\nsimulate with an array\n\n\nOptimization:\nprefix sum\n\nwhen pop, adjust the inc for the previous cell\n\ninc list and stack list\n\nTime: O(1) \nSpace: O(1) per element\n\n*/\n\nclass CustomStack {\n\tint capacity;\n\tint size;\n\tList<Integer> stack = new ArrayList<>();\n\tList<Integer> inc = new ArrayList<>();\n\n\tpublic CustomStack(int maxSize) {\n\t\tcapacity = maxSize;\n\t\tsize = 0;\n\t}\n\n\tpublic void push(int x) {\n\t\tif (size < capacity) {\n\t\t\tstack.add(x);\n\t\t\tinc.add(0);\n\t\t\tsize++;\n\t\t}\n\t}\n\n\tpublic int pop() {\n\t\tif (size == 0) return -1; // empty check\n\t\tint ans = stack.get(size - 1) + inc.get(size - 1);\n\t\tif (size >= 2) {\n\t\t\tinc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n\t\t}\n\t\tinc.remove(size - 1);\n\t\tstack.remove(size - 1);\n\t\tsize--;\n\t\treturn ans;\n\t}\n\n    // index - > inc at that index\n\tpublic void increment(int k, int val) {\n\t\tif (size > 0) { \n\t\t\tinc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n\t\t}\n\t}\n\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087730751","body":"# Logic:\ntwo stacks, one for freq, one for str\n[: push cur freq, str to each stack, reset\n]: pop freq, str from each stack, pass curStr to temp and append\n\n# Complexity:\nTime: O(n), n = decoded len\nSpace: O(n), for two stacks and output\n\n# Code:\n```java\nclass Solution {\n    public String decodeString(String s) {\n        if (s.length() == 1) return s;\n        \n        StringBuilder decoded = new StringBuilder();\n        Stack<Integer> numStack = new Stack<>();\n        \n        Stack<StringBuilder> stack = new Stack<>();\n        int index = 0;\n        int curNum = 0;\n        StringBuilder curS = new StringBuilder();\n        \n        while (index < s.length()) {\n            if (Character.isDigit(s.charAt(index))) {             \n                curNum = curNum * 10 + s.charAt(index) - '0';\n                index++;\n            }\n            else if(s.charAt(index) == '[') {\n                numStack.push(curNum);\n                curNum = 0;\n                \n                stack.push(curS);\n                curS = new StringBuilder();\n                \n                index++;\n            }\n            else if (Character.isLetter(s.charAt(index))) {\n                curS.append(s.charAt(index));\n                index++;\n            }\n            else if (s.charAt(index) == ']') {\n                \n                StringBuilder temp = curS;\n                int freq = numStack.pop();\n                curS = stack.pop();\n                \n                for (int i = 0; i < freq; i++) {\n                    curS.append(temp);\n                }\n                index++;\n            }\n            \n        }\n        return curS.toString();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088905443","body":"# Plan:\r\ntwo stacks, one for pop only, one for push only, transfer elements before each operation\r\n\r\n# Complexity:\r\n```\r\nTime: O(N), N = total number of elements\r\nSpace: O(N) for N elements\r\n```\r\n# Code:\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack = new Stack<>();\r\n    Stack<Integer> popStack = new Stack<>();\r\n    \r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return popStack.isEmpty() && pushStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090434006","body":"# Plan:\n```\n5 5 5 -> 3\n1 5 5 -> 3\n5 1 5 -> 2\n6 1 5 -> 1\n[5,4,3,2,1] -> 1\n\n\n[1,1,0,0,1]-> 2\n\nIdea:\nmerge if the current num <= stack top \nstack stores the representatives (largest for that chunk)\nfrom stack bottom to top: increasing or equal\n\n-> 2 cases within the for loop\n```\n\n# Complexity:\n```\nTime: O(n), n = array.length, at most two operations on each element\nSpace: O(n)\n```\n# Code:\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> monoStack = new Stack<>();\n        for (int num : arr) {\n            if (monoStack.isEmpty() || monoStack.peek() <= num) {\n                monoStack.push(num);\n            }\n            else {\n                int curMax = monoStack.peek();\n                while (!monoStack.isEmpty() && monoStack.peek() > num) {\n                    monoStack.pop();\n                }\n                monoStack.push(curMax);\n            }\n        }\n        return monoStack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091905475","body":"# Idea:\n```\n\ncorner case: head == null, k == 0\nget len first, k = k % len, k==0 corner case\n\nfast and slow pointer\n```\n# Complexity:\n```\nTime: O(len of linkedlist)\n\nspace: O(1)\n```\n\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) return head;\n        int len = getLen(head);\n        k = k % len;\n        \n        if (k == 0) return head;\n        \n        ListNode fast = head, slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        \n        slow.next = null;\n        fast.next = head;\n        \n        return newHead;\n    }\n    \n    private int getLen(ListNode head) {\n        ListNode cur = head;\n        int len = 0;\n        while (cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        return len;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093021196","body":"# Idea:\n```\nfirst, second pointer, pre, dummy head\n```\n# Complexity:\n```\nTime: O(n), n = len of list\nSpace: O(1)\n```\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, first = head, second = first.next;\n        \n        while (second != null) {\n            ListNode newFirst = second.next;\n            pre.next = second;\n            second.next = first;\n            first.next = newFirst;\n            \n            if (newFirst == null) { // edge case\n                break;\n            }\n            \n            // update three pointers\n            pre = first;\n            first = newFirst;\n            second = first.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094073161","body":"# Idea: \n```\nuse dummy head, find mid, break into halves, disconnect, recursively build the tree\n```\n# Complexity:\n```\nTime:\n\nT(1) = T(0) = 1\nT(n) = 2 * T(n/2) + O(n/2)  -> extra linear traversal\n     = 2 * [2 * T(n/4) + O(n/4)] + O(n/2)\n     = 4 * T(n/4) + O(n)\n     = 4 * [2 * T(n/8) + O(n/8)] + O(n)\n     = 8 * T(n/8) + 3 * O(n/2)\n     = x * T(n/x) + log x * O(n/2)\n\nn/x = 1, n = x\nT(n) = n * T(1) + logn * O(n) = n + nlogn = nlogn\n\nSpace: \ntree: O(n), n = len of linkedlist\nstack: O(height) = O(logn)\n```\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        // must deal with the one node case as the base case\n        if (head.next == null) return new TreeNode(head.val, null, null);\n        ListNode dummy = new ListNode(0, head);\n        ListNode fast = head, slow = dummy;\n        while (fast != null && fast.next != null) { // 1-2-3-4\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        ListNode rootList = slow.next;\n        ListNode nextHead = rootList.next;\n        slow.next = null;\n        rootList.next = null;\n        \n        TreeNode root = new TreeNode(rootList.val);\n        \n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(nextHead);\n        \n        return root;\n    }\n    \n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094301369","body":"# Idea: \n```\ntwo pointers, restart from the other head if reaches null\n```\n\n# Complexity:\n```\na.   \n     b\nc\nTime: O(a + b + c), a, b, c represents len, a + b = lenA, b + c = lenB in case of intersection\n\nif node in segment b == null, no intersection, len of b = 1\n\nSpace: O(1)\n```\n\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode curA = headA, curB = headB;\n        while (curA != curB) {\n            curA = curA == null ? headB : curA.next;\n            curB = curB == null ? headA : curB.next;\n        }\n        return curA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095142802","body":"# Idea:\n```\n     *____c\n d   |     |\n----------|-------\n  a.    b\n\nmeet at *\n\nfast covers: a + b + c + d + b + c\nslow covers: a + b + c\n\n2 * (a + b + c) = a + b + c + d + b + c\n\na = d\nrestart fast from the origin, slow from *, one step for each this time\n\nthe cycle starts at where they meet\n```\n\n# Complexity:\n```\nTime: O(a + b + c + d) if circle exists, otherwise, O(len of list)\n\nSpace: O(1)\n```\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        if (fast == null || fast.next == null) return null;\n        \n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096901103","body":"# Idea: \n```\nhashmap + doubly linked list (head, tail)\n```\n# Complexity:\n```\nTime:\n\neach operation O(1)\n\nSpace:\nO(n), n = total number of nodes\n```\n# Code:\n```java\nclass LRUCache {\n    \n    class Node {\n        int key;\n        int val;\n        Node pre;\n        Node next;\n        \n        Node(int key, int val, Node pre, Node next) {\n            this.key = key;\n            this.val = val;\n            this.pre = pre;\n            this.next = next;\n        }\n    }\n    \n    int capacity;\n    Map<Integer, Node> keyNodeMap;\n    Node head;\n    Node tail;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        keyNodeMap = new HashMap<>();\n        head = new Node(-1, -1, null, null);\n        tail = new Node(-1, -1, null, null);\n        connect(head, tail);\n    }\n    \n    private void connect(Node n1, Node n2) {\n        n1.next = n2;\n        n2.pre = n1;\n    }\n    \n    public int get(int key) {\n        if (keyNodeMap.containsKey(key)) {\n            Node target = keyNodeMap.get(key);\n            Node preTarget = target.pre;\n            Node nextTarget = target.next;\n            connect(preTarget, nextTarget);\n            \n            Node headNext = head.next;\n            connect(head, target);\n            connect(target, headNext);\n            return target.val;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (keyNodeMap.containsKey(key)) {\n            Node target = keyNodeMap.get(key);\n            target.val = value;\n            \n            Node preTarget = target.pre;\n            Node nextTarget = target.next;\n            connect(preTarget, nextTarget);\n            \n            Node headNext = head.next;\n            connect(head, target);\n            connect(target, headNext);\n            return;\n        }\n        if (capacity == 0) { // remove 1 from tail\n            Node toRm = tail.pre;\n            Node newTailPre = toRm.pre;\n            connect(newTailPre, tail);\n            keyNodeMap.remove(toRm.key);\n            capacity++;\n        }\n        // add new node to head and map\n        Node newNode = new Node(key, value, null, null);\n        Node headNext = head.next;\n        connect(head, newNode);\n        connect(newNode, headNext);\n        keyNodeMap.put(key, newNode);\n        capacity--;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098211545","body":"# Idea:\n```\npostorder traversal\n```\n# Complexity:\n```\nTime: O(n), n = total number of nodes\nSpace: O(height)\n```\n\n# Code:\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        return postOrder(root);\n    }\n    \n    private int postOrder(TreeNode root) {\n        if (root == null) return 0;\n        int leftMaxD = postOrder(root.left);\n        int rightMaxD = postOrder(root.right);\n        \n        return 1 + Math.max(leftMaxD, rightMaxD);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099316120","body":"```\nIdea: pre-order\n\nTime: O(n), n = number of nodes in one tree\nSpace: O(height)\n```\n# Code:\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100134979","body":"# Idea: \n```\npre-order traversal, update total when it is the leaf\n```\n# Complexity:\n```\nTime: O(n), n = number of nodes\nSpace: O(height), worst O(n) in case of degenerate tree\n```\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if (root == null) return 0;\n        int[] total = new int[1];\n        preorder(root, 0, total);\n        return total[0];\n    }\n    \n    private void preorder(TreeNode curNode, int curSum, int[] total) {\n        if (curNode == null) return;\n\n        curSum = curSum * 10 + curNode.val;\n        if (curNode.left == null && curNode.right == null) {\n            total[0] += curSum;\n            return;  \n        }\n        \n        preorder(curNode.left, curSum, total);\n        preorder(curNode.right, curSum, total);    \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100688455","body":"# idea: \r\n```\r\nlevel-order traversal\r\n```\r\n# Complexity:\r\n```\r\nTime: O(n), n = number of nodes\r\nSpace: O(n)\r\n```\r\n# Code:\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n\r\n\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int candidate = -1;\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode curNode = queue.poll();\r\n                if (i == 0) {\r\n                    candidate = curNode.val;\r\n                }\r\n                \r\n                if (curNode.left != null) {\r\n                    queue.offer(curNode.left);\r\n                }\r\n                if (curNode.right != null) {\r\n                    queue.offer(curNode.right);\r\n                }\r\n            }\r\n        }\r\n        return candidate;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100906024","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\n/*\n# Note:\nlevel-order traversal\nin serialization: do not insert null into queue while keeping null in output string\nin deserialization: #XXX, then the first token is empty, do not forget to inc index at the end of finishing right\n\n# Complexity:\nTime:O(n), number of nodes\nSpace: O((n+1)/2), widest level, O(n)\n\n\n\n\n*/\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) return \"null\";\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        StringBuilder serialized = new StringBuilder();\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = queue.poll();\n                if (cur == null) {\n                    serialized.append(\"#null\");\n                } else {\n                    serialized.append(\"#\" + cur.val);\n                    queue.offer(cur.left);\n                    queue.offer(cur.right);\n                }\n            }\n        }\n        //System.out.println(serialized.toString()); // #1#2#3#null#null#4#5#null#null#null#null. root = [1,2,3,null,null,4,5]\n        return serialized.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data.equals(\"null\")) return null;\n        \n        String[] tokens = data.split(\"#\");// tokens[1]=1, tokens[0] = \"\"\n\n        TreeNode root = new TreeNode(Integer.parseInt(tokens[1]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int index = 2;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = queue.poll();\n                \n                if (tokens[index].equals(\"null\")) {\n                    cur.left = null;\n                } else {\n                    cur.left = new TreeNode(Integer.parseInt(tokens[index]));\n                    queue.offer(cur.left);\n                }\n                \n                index++;\n                \n                if (tokens[index].equals(\"null\")) {\n                    cur.right = null;\n                } else {\n                    cur.right = new TreeNode(Integer.parseInt(tokens[index]));\n                    queue.offer(cur.right);\n                }\n                \n                index++; // do not forget this line\n            }\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101515473","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n/*\n# Plan1:\npreorder\n- track depth\n- vertical distance (go left: - 1, right + 1)\n\nnested map:\n- key sorted by vertical distances (its values sorted by treenode val)\n \nTreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>\n\nno need to specifically track minVertical, maxVertical if we use treemap\n\nTime:\ntouch each node once during dfs, O(n)\noffer each node to pq and poll each node from pq\nO(nlogn)\n\nSpace: \nmap: O(n), n = number of nodes\ndfs: O(height)\n\n# Plan2: BFS + hashmap x->pairs\nTime:\n- bfs, touch on each node once\n- Collections.sort on each list of same x, \nassume: i number of possible x's, on average j nodes for each\n\ni * jlog(j) = n log j, n = number of nodes\n- add to list O(n)\n\n\nSpace: queue O(widest) = O[(n+1)/2] = O(n)\nhashmap: store number of pairs = number of nodes, O(n)\n->assume: i number of possible x's, on average j nodes for each, either way i * j = n\n\n\n*/\n\nclass Solution {\n    public List<List<Integer>> verticalTraversal1(TreeNode root) {\n        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> VThenDepthMap = new TreeMap<>();\n        dfs(root, 0, 0, VThenDepthMap);\n        \n        List<List<Integer>> traversal = new ArrayList<>();\n        // when we traverse, vertical is sorted (vertically, go from left to right)\n        for (TreeMap<Integer, PriorityQueue<Integer>> sortedDtosortedVals : VThenDepthMap.values()) {\n            traversal.add(new ArrayList<>()); \n            // start from min vertical distance, go from top to bottom, if same depth (also same vertical), smaller comes first\n            \n            for (PriorityQueue<Integer> sortedValsOfSameD : sortedDtosortedVals.values()) {\n                while (!sortedValsOfSameD.isEmpty()) {\n                    traversal.get(traversal.size() - 1).add(sortedValsOfSameD.poll()); // poll() once for each node, O(nlogn)\n                }\n            }\n        }\n        return traversal;\n    }\n    \n    // x: vertical, y : level\n    // time: for each node val, need to be inserted to the right priorityqueue O(nlogn) \n    // touch each node once O(n)\n    // intotal O(nlogn)\n    private void dfs(TreeNode cur, int x, int y, TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> VThenDepthMap) {\n        if (cur == null) {\n            return;\n        }\n        \n        if (!VThenDepthMap.containsKey(x)) {\n            VThenDepthMap.put(x, new TreeMap<> ());\n        }\n        \n        if (!VThenDepthMap.get(x).containsKey(y)) {\n            VThenDepthMap.get(x).put(y, new PriorityQueue<>());\n               \n        }\n        VThenDepthMap.get(x).get(y).offer(cur.val);\n        \n        dfs(cur.left, x - 1, y + 1, VThenDepthMap);\n        dfs(cur.right, x + 1, y + 1, VThenDepthMap);\n    }\n    \n    // Method 2: level-order + hashmap\n    class Pair {\n        TreeNode node;\n        int x;\n        int y;\n        \n        Pair(TreeNode node, int x, int y) {\n            this.node = node;\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> traversal = new ArrayList<>();\n        // vertical distance -> list of pairs\n        Map<Integer, List<Pair>> xToPairsMap = new HashMap<>();\n        // BFS\n        Queue<Pair> queue = new LinkedList<>();\n        queue.offer(new Pair(root, 0, 0));\n        int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE;\n        // BFS: O(n) time\n        while (!queue.isEmpty()) {\n            \n            Pair cur = queue.poll();\n            \n            if (cur.node == null) System.out.println(queue.size());\n            \n            minX = Math.min(minX, cur.x);\n            maxX = Math.max(maxX, cur.x);\n                \n            if (!xToPairsMap.containsKey(cur.x)) {\n                xToPairsMap.put(cur.x, new ArrayList<>());\n            }\n            xToPairsMap.get(cur.x).add(cur);\n            \n            if (cur.node.left != null) {\n                queue.offer(new Pair(cur.node.left, cur.x - 1, cur.y + 1));\n            }\n            if (cur.node.right != null) {\n                queue.offer(new Pair(cur.node.right, cur.x + 1, cur.y + 1));\n            }\n\n        }\n        \n        // sort\n        for (int v = minX; v <= maxX; v++) {\n            List<Pair> sameXPairs = xToPairsMap.get(v);\n            // sort by y (depth) first and then value\n            // if depth/y is the same, smaller value comes first\n            Collections.sort(sameXPairs, new Comparator<Pair>() {\n                public int compare(Pair a, Pair b) {\n                    if (a.y == b.y) {\n                        return a.node.val - b.node.val;\n                    }\n                    return 0; // bfs puts pairs of smaller depth first\n                }\n            });\n            \n            List<Integer> sameX = new ArrayList<>();\n            for (Pair sameXPair : sameXPairs) {\n                sameX.add(sameXPair.node.val);\n            }\n            traversal.add(sameX);\n        }\n        \n        return traversal;\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102808286","body":"# Idea:\nmap: val - index\n\n```java\n/*\nTime: O(nums.length)\nSpace: O(nums.length)\n\n*/\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> valIndexMap = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (valIndexMap.containsKey(target - nums[i])) {\n                return new int[]{valIndexMap.get(target - nums[i]), i};\n            }\n            else {\n                valIndexMap.put(nums[i], i);\n            }\n        }\n        return new int[0];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104090227","body":"```java\n/*\n\nIdea: \nmap: val-freq, minheap of size k\n\nTime: O(nums.length) + O(number of unique num) * O(logk) + O(k)\nSpace: O(number of unique num) + O(k)\n\n*/\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> valFreqMap = new HashMap<>();\n        // O(nums.length) time\n        for (int num : nums) {\n            valFreqMap.put(num, valFreqMap.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>((a, b) -> (a.getValue() - b.getValue()));\n        // O(number of unique num) * O(logk)\n        for (Map.Entry<Integer, Integer> entry : valFreqMap.entrySet()) {\n            minHeap.offer(entry);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n        \n        // O(k)\n        int[] res = new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i] = minHeap.poll().getKey();\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105410276","body":"```java\n/*\nPlan: get all pair-wise distances?  --> no idea later\n\nmap: distance - count\n[i, j], [i, k]\n\nfor the current i, same distance, count - x, -> i can form x pairs of this distance with the remaining points. we can draw j and k from this set.\n\nTime: O(n^2), n = points.length\nSpace: O(number of unique distances)\n*/\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if (points.length <= 2) return 0;\n        \n        int count = 0, dist = 0;\n        // for each possible i\n        for (int i = 0; i < points.length; i++) {\n            Map<Integer, Integer> distFreqMap = new HashMap<>();\n            for (int j = 0; j < points.length; j++) {\n                // same point\n                if (i == j) {\n                    continue;\n                }\n                dist = getDis(points[i], points[j]);\n                distFreqMap.put(dist, distFreqMap.getOrDefault(dist, 0) + 1);\n            }\n            for (int value : distFreqMap.values()) {\n                count += value * (value - 1);\n            }\n            \n        }\n            \n        return count;    \n    }\n    \n    private int getDis(int[] point1, int[] point2) {\n        return (point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106651087","body":"# Idea:\n```\nsliding window\n```\n\n# Complexity:\n```\nTime: O(s.length())\nSpace: O(s.length())\n```\n\n```java\n\n//  s = \"abcabcbb\"\n\nclass Solution {\n    public int lengthOfLongestSubstring1(String s) {\n        int l = 0, r = 0, maxLen = 0;\n        Map<Character, Integer> charFreqMap = new HashMap<>();\n        while (r < s.length()) {\n            char rightChar = s.charAt(r);\n            charFreqMap.put(rightChar, charFreqMap.getOrDefault(rightChar, 0) + 1);\n            r++;\n            while (charFreqMap.get(rightChar) >= 2) {\n                char leftChar = s.charAt(l);\n                charFreqMap.put(leftChar, charFreqMap.get(leftChar) - 1);\n                \n                if (charFreqMap.get(leftChar) == 0) {\n                    charFreqMap.remove(leftChar);\n                }\n                l++;\n            }\n            maxLen = Math.max(maxLen, r - l);\n        }\n        return maxLen;\n    }\n    \n    // optimized using a set\n    public int lengthOfLongestSubstring(String s) {\n        int l = 0, r = 0;\n        int maxLen = 0;\n        Set<Character> visited = new HashSet<>();\n        \n        while (r < s.length()) {\n            char rightChar = s.charAt(r);\n            while (visited.contains(rightChar)) {\n                visited.remove(s.charAt(l));\n                l++;\n            }\n            \n            visited.add(rightChar);\n            maxLen = Math.max(maxLen, visited.size());\n\n            r++;\n        }\n        return maxLen;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107523808","body":"```java\n/*\nTime:\nO(words.length()) + O(s.length() - unitLen*wordNum) * [O(unitLen*wordNum) + O(wordNum) * O(unitLen)]\n-> O(s.length() - unitLen*wordNum) * O(wordNum) * O(unitLen)\n\n\nSpace:two maps\nO(number of unique words)\n\n*/\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> indices = new ArrayList<>();\n        // get freq \n        Map<String, Integer> wordFreq = new HashMap<>();\n        for (String word : words) {\n            wordFreq.put(word, wordFreq.getOrDefault(word, 0) + 1);\n        }\n        \n        int unitLen = words[0].length(), wordNum = words.length;\n        // sliding window\n        // len to check = word.length * num of words\n        // index to check: [0, end], s.length()-1 - end + 1=word.length * num of words\n        // end = s.length() - unitLen*wordNum\n        \n        for (int start = 0; start <= s.length() - unitLen*wordNum; start++) {\n            String curSub = s.substring(start, start + unitLen*wordNum);\n            // use a curFreqMap to see the difference\n            Map<String, Integer> curWordFreq = new HashMap<>();\n            int wordIndex = 0;\n            // within curSub\n            for (wordIndex = 0; wordIndex + unitLen <= curSub.length(); wordIndex += unitLen) { // note the incremental\n                String curUnit = curSub.substring(wordIndex, wordIndex + unitLen);\n                // not in given dictionary\n                if (!wordFreq.containsKey(curUnit)) {\n                    break;\n                }\n                curWordFreq.put(curUnit, curWordFreq.getOrDefault(curUnit, 0) + 1);\n                // > required freq\n                if (curWordFreq.get(curUnit) > wordFreq.get(curUnit)) {\n                    break;\n                }\n            }\n            \n            // if finish the check, bingo\n            if (wordIndex == curSub.length()) {\n                indices.add(start);\n            }\n            \n        }\n        \n        return indices;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108748507","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n\r\n/*\r\n1 -> 1\r\n\r\n1-2 -> 2\r\n\r\n1-2-3 -> 2\r\n\r\nIdea: two pointers, no need for dummy head\r\n\r\nTime: O(list.length)\r\nSpace: O(1)\r\n*/\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head, slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109959628","body":"```java\n/*\n\n1 <= nums.length <= 3 * 10^4\n\n1 1 2 2 3 3 4\n\n\n1 2 3 4 3 3 4\n            n\n        r\n        \n1 2 3 3 4\n\nTwo pointers, one for overwrite, one for traversal\n\nTime: O(nums.length)\nSpace: O(1)\n*/\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int resIndex = 1, numsIndex = 1;\n        for (numsIndex = 1; numsIndex < nums.length; numsIndex++) {\n            if (nums[numsIndex] == nums[resIndex - 1]) {\n                continue;\n            }\n            nums[resIndex] = nums[numsIndex];\n            resIndex++;\n        }\n        return resIndex;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111154471","body":"```java\n/*\n注意，原输入无重复值\n套最左插入位置二分法模版，修改一行即可\ntime: O(nlogn), n = nums.length\nspace: O(1)\n*/\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            else if (nums[mid] > target) {\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112377783","body":"```java\n\n/*\narraydeque\n---> decreasing\n\nhead.  tail (add to tail)\n\n\nTime: O(nums.length)\nSpace: O(k)\n\n\n*/\n\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (k == 1) return nums;\n        int[] maxes = new int[nums.length - k + 1];\n        int windowIndex = 0;\n        ArrayDeque<Integer> indicesQueue = new ArrayDeque<>();\n        for (int i = 0; i < nums.length; i++) {\n            // window size within\n            while (!indicesQueue.isEmpty() && i - indicesQueue.peekFirst() + 1 > k) {\n                indicesQueue.pollFirst();\n            }\n            // monotonically decreasing property check-up\n            while (!indicesQueue.isEmpty() && nums[indicesQueue.peekLast()] < nums[i]) {\n                indicesQueue.pollLast();\n            }\n            \n            // after the previous while, guarantee to have if not empty, nums[indexStack.peekLast()] >= nums[i]\n            indicesQueue.addLast(i);\n            // add to windows\n            if (i >= k - 1) {\n                maxes[windowIndex++] = nums[indicesQueue.peekFirst()]; // use val here!\n            }\n        }\n        return maxes;\n        \n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113472946","body":"```java\n/*\n\nUse arrays to record indegree and outdegree\n\nTime: O(n)\nSpace: O(n)\n\n*/\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] indegree = new int[n];\n        int[] outdegree = new int[n];\n        for (int[] pair : trust) {\n            // pair[0] trusts pair[1]\n            indegree[pair[1] - 1]++;\n            outdegree[pair[0] - 1]++;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == n - 1 && outdegree[i] == 0) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bin214":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085914856","body":"####思路\n\n按位取出数字k，依次加到数组A内，需注意产生的进位，如果数组首位仍有进位，则数组首部加一位\n\n\n\n#### 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> ans = new ArrayList<>();\n    int n = num.length;\n    int sum = 0, flag = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        sum = (k % 10) + num[i] + flag;\n        k = k / 10;\n        if (sum >= 10) {\n            sum = sum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        ans.add(sum);\n    }\n    while (k != 0){\n        ans.add(k % 10 + flag);\n        k = k / 10;\n        if(flag != 0) flag = 0;\n    }\n    if(flag != 0)\n        ans.add(1);\n    Collections.reverse(ans);\n    return ans;\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(m + n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1087057313","body":"## 思路\n左右遍历一遍，第一遍遍历时先给数组赋初始值，再赋距离值，第二遍遍历赋更小值\n\n## 代码\n```\npublic int[] shortestToChar(String s, char c) {\n    int n = s.length();\n    int[] ans = new int[n];\n    int flag = 0, index_c = 0;\n    for(int i = 0; i < n; i++){\n        ans[i] = n;//赋初始最大值\n        if(s.charAt(i) == c){\n            flag = 1;\n            index_c = i;\n        }\n        if(flag == 1){\n            ans[i] = i - index_c;//赋距离值\n        }\n    }\n    flag = 0;\n    for(int i = n - 1; i >= 0; i--){\n        if(s.charAt(i) == c){\n            flag = 1;\n            index_c = i;\n        }\n        if(flag == 1){\n            if(index_c - i < ans[i])\n                ans[i] = index_c - i;//更新距离值\n        }\n    }\n    return ans;\n}\n```\n\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1087067405","body":"## 代码\n```java\npublic int[] stack;\n    public int size = 0;\n    public int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if(size == maxSize)\n            return;\n        stack[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0)\n            return -1;\n        return stack[size--];\n    }\n\n    public void increment(int k, int val) {\n        int i = 0;\n        while(i < size && i < k){\n            stack[i] = stack[i] + val;\n            i += 1;\n        }\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1089702476","body":"## 思路\n用栈处理[]的嵌套，每次处理完]后将结果入栈，最终结果将栈清空\n\n## 代码\n```java\npublic String decodeString(String s) {\n        int i = 0, n = s.length();\n        Stack<String> stack = new Stack<>();\n        while (i < n){\n            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') {\n                int left = i;\n                while (s.charAt(i) >= '0' && s.charAt(i) <= '9') {\n                    i++;\n                }\n                stack.push(s.substring(left, i));\n            }\n            if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z'){\n                int left = i;\n                while (i < n && s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {\n                    i++;\n                }\n                stack.push(s.substring(left, i));\n                if(i == n) break;\n            }\n            if (s.charAt(i)=='['){\n                stack.push(\"[\");\n                i++;\n                if(i == n) break;\n            }\n            if (s.charAt(i)==']'){\n                StringBuffer tmp1 = new StringBuffer();\n                while(!stack.peek().equals(\"[\")){\n                    tmp1 = tmp1.insert(0, stack.pop());\n                }\n                stack.pop();//\"[\"\n                int times = Integer.parseInt(stack.pop());\n                StringBuffer tmp2 = new StringBuffer();\n                for(int ic = 0; ic < times; ic++)\n                    tmp2 = tmp2.insert(0, tmp1);//字符串插入自身会导致指数级增大,因此使用两个变量\n                stack.push(tmp2.toString());\n                i++;\n            }\n        }\n        StringBuffer ans = new StringBuffer();\n        while (!stack.empty())\n            ans.insert(0, stack.pop());\n        return ans.toString();\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1089737563","body":"## 思路\n用一个逆序和一个正序的栈，具体将数据存在正序还是逆序栈决定了push和pop方法的性能，由于有peek方法，选择将数据存储在逆序栈中\n\n## 代码\n```java\nclass MyQueue {\n    Deque<Integer> stackReverse = new LinkedList<>();\n    Deque<Integer> stackTmp = new LinkedList<>();\n\n    public MyQueue() {\n\n    }\n\n    public void push(int x) {\n        while (!stackReverse.isEmpty())\n            stackTmp.push(stackReverse.pop());\n        stackTmp.push(x);\n        while (!stackTmp.isEmpty())\n            stackReverse.push(stackTmp.pop());\n    }\n\n    public int pop() {\n        if(!stackReverse.isEmpty())\n            return stackReverse.poll();\n        else return -1;\n    }\n\n    public int peek() {\n        if(!stackReverse.isEmpty())\n            return stackReverse.peek();\n        else return -1;\n    }\n\n    public boolean empty() {\n        return stackReverse.isEmpty();\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090236394","body":"## 思路\n最开始想到的是窗口法，左部分序列的最大值小于右部分序列的最小值就能划分，另最左边的值为最小值，最右边的值为最大值时都可以被划分，但是没能想出比较简洁的写法，题解的计数排序的思路比较清晰，感觉会比较适合面试\n\n## 代码\n```java\npublic int maxChunksToSorted(int[] arr) {\n        int chunkNumber = 0, n = arr.length;\n        int[] arrSort = (int[])arr.clone();\n        Arrays.sort(arrSort);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int nonzero = 0;\n        for(int i = 0; i < n; i++){\n            int x = arr[i];\n            int y = arrSort[i];\n            map.put(x, map.getOrDefault(x, 0) + 1);\n            if(map.get(x) == 0) nonzero--;\n            if(map.get(x) == 1) nonzero++;\n\n            map.put(y, map.getOrDefault(y, 0) - 1);\n            if(map.get(y) == 0) nonzero--;\n            if(map.get(y) == -1) nonzero++;\n\n            if(nonzero == 0) chunkNumber++;\n        }\n        return chunkNumber;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091635028","body":"## 思路\n使用快慢指针，快指针先走k步，快慢指针一起走到快指针到头，快指针指向原链表头，慢指针指向变成新链表头（被虐了几天终于能AC一道题了）\n\n## 代码\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        ListNode fast = head, slow = head, headCopy = head;\n        for(int i = 0; i < k; i++){//防止k大于链表长度，可以改成先求链表长度再求余的形式\n            if(fast.next != null)\n                fast = fast.next;\n            else\n                fast = head;\n        }\n        while (fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        fast.next = headCopy;\n        ListNode newHead = slow.next;\n        slow.next = null;\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092609446","body":"## 思路\n同样是快慢指针法，但需要额外的指针指向慢指针的前驱方便交换，另外链表的长度为奇数或偶数时都需要做判别\n\n## 代码\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return head;\n        ListNode preHead = new ListNode();\n        preHead.next = head;\n        ListNode pre = preHead, slow = head, fast = head.next;\n        while(true){\n            pre.next = fast;\n            slow.next = fast.next;\n            fast.next = slow;\n\n            if(slow.next != null)\n                slow = slow.next;\n            else return preHead.next;\n            if(slow.next != null)\n                fast = slow.next;\n            else return preHead.next;\n            pre = pre.next.next;\n        }\n    }\n```\n\n## 复杂度\n时间复杂度：O(n)，遍历一遍链表\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094958526","body":"## 思路\n没想出空间o(1)的方法，使用哈希表存储全部结点，出现重复时则有环\n\n## 代码\n```java\npublic ListNode detectCycle(ListNode head) {\n    HashMap<ListNode, Integer> hash = new HashMap<>();\n    while (head != null){\n        if(!hash.containsKey(head)){\n            hash.put(head, 1);\n        }else {\n            return head;\n        }\n        head = head.next;\n    }\n    return null;\n}\n```\n\n## 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095059114","body":"# 代码\n```java\npublic ListNode detectCycle(ListNode head) {\n        HashMap<ListNode, Integer> hash = new HashMap<>();\n        while (head != null){\n            if(!hash.containsKey(head)){\n                hash.put(head, 1);\n            }else {\n                return head;\n            }\n            head = head.next;\n        }\n        return null;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096804064","body":"## 思路\n使用哈希表存储数据，使用链表存储顺序，开始尝试用单向链表，但是遇到问题\n* 无法从哈希表中删除对应数据->链表中应同时存储key和value\n* 对于更新结点，采用的是交换待更新结点与链表头的方法，但是并不准确，交换后原链表头的优先级下降过多了->采用双链表，使用删除+头部添加的方式\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097483581","body":"## 思路\n二叉树深度为左右子树深度+1\n\n## 代码\n```java\npublic int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        TreeNode left = root.left;\n        TreeNode right = root.right; \n        return Math.max(maxDepth(root.right), maxDepth(root.left)) + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098634500","body":"## 思路\n递归处理\n\n## 代码\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p!= null && q!= null)\n            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        else return p == null && q == null;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099804905","body":"## 思路\n主要还是二叉树的回溯思想\n\n## 代码\n```java\n    public int sumNumbers(TreeNode root) {\n        int allSum = 0, oneSum = 0;\n        List<Integer> list = new ArrayList<>();\n        sumNumbers(root, list, oneSum);\n        for (Integer integer : list) allSum += integer;\n        return allSum;\n    }\n\n    public void sumNumbers(TreeNode root, List<Integer> list, int oneSum){\n\n        oneSum = oneSum * 10 + root.val;\n        if(root.left == null && root.right == null) {\n            list.add(oneSum);\n            return;\n        }\n        if(root.left != null)\n            sumNumbers(root.left, list, oneSum);\n        if(root.right != null)\n            sumNumbers(root.right, list, oneSum);\n    }\n```\n\n## 复杂度\n时间：O(nlogn)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100633023","body":"## 思路\n层次遍历\n\n## 代码\n```java\n Deque<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            int last = 0;\n            for(int i = 0; i < size; i++){\n                TreeNode p = queue.poll();\n                if(p.right != null) queue.offer(p.right);\n                if(p.left != null) queue.offer(p.left);\n                last = p.val;\n            }\n            if(queue.isEmpty()) return last;\n        }\n        return root.val;\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101145894","body":"## 代码\n```java\nclass Solution(object):\n    def verticalTraversal(self, root):\n        seen = collections.defaultdict(\n            lambda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n\n        dfs(root)\n        ans = []\n        # x 排序、\n        for x in sorted(seen):\n            level = []\n            # y 排序\n            for y in sorted(seen[x]):\n                # 值排序\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n\n        return ans\n```java","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107408472","body":"```python\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113925216","body":"```python\nclass Solution:\n    def dfs(self, graph, colors, i, color, N):\n        colors[i] = color\n        for j in range(N):\n            # dislike eachother\n            if graph[i][j] == 1:\n                if colors[j] == color:\n                    return False\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\n                    return False\n        return True\n\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\n        graph = [[0] * N for i in range(N)]\n        colors = [0] * N\n        for a, b in dislikes:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n        for i in range(N):\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\n                return False\n        return True\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oision-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085926377","body":"### 思路\n逐位相加，若大于10则进位。\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int len = num.size();\n        for (int i = len - 1; i >= 0; i--) {\n            int temp = num[i] + k % 10;\n            k = k / 10;\n            if (temp >= 10) {\n                k += 1;\n                temp = temp % 10;\n            }\n            result.push_back(temp);\n        }\n        while (k != 0) {\n            result.push_back(k % 10);\n            k = k / 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650727","body":"### 思路\n将两边遍历的结果存入数组，留下较小的值\n### 解答\n``` c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) {\n            if (s[i] == c) {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) {\n            if (s[i] == c) {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```\n###  复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085927113","body":"func addToArrayForm(num []int, k int) []int {\n    for i := len(num) - 1; i >= 0; i-- {\n        num[i] += k % 10\n        k /= 10\n\n        // if overflow\n        if num[i] > 9 {\n            k++\n            num[i] -= 10\n        }\n    }\n\n    // if k length more than num length\n    for k > 0 {\n        num = append([]int{k % 10}, num...)\n        k /= 10\n    }\n\n    return num\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666125","body":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestShortestDistanceToACharacter(t *testing.T) {\n\ts := \"loveleetcode\"\n\tvar c byte = 'e'\n\n\tchars := shortestDistanceToACharacter(s, c)\n\n\tfor _, v := range chars {\n\t\tfmt.Print(v, \"\\t\")\n\t}\n\tfmt.Println()\n\n}\n\nfunc shortestDistanceToACharacter(s string, c byte) []int {\n\tres := make([]int, len(s))\n\n\t// prevent overflow\n\tleft, right := math.MinInt32/2, math.MaxInt32/2\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\tleft = i\n\t\t}\n\t\tres[i] = i - left\n\t}\n\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tright = i\n\t\t}\n\t\tres[i] = min(res[i], right-i)\n\t}\n\n\treturn res\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868863","body":"```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack {\r\n        make ([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n   if len(this.stack) > 0  {\r\n       res := this.stack[len(this.stack) - 1]\r\n       this.stack = this.stack[:len(this.stack) - 1]\r\n       return  res\r\n   } else {\r\n      return -1 \r\n   }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    } \r\n\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088720831","body":"```go\ntype MyQueue struct {\n    inStack, outStack []int\n}\n\n\nfunc Constructor() MyQueue {\n    return MyQueue{\n        inStack : make([]int, 0),\n        outStack : make([]int, 0),\n    }\n}\n\n\nfunc (q *MyQueue) Push(x int)  {\n    q.inStack = append(q.inStack, x)\n}\n\n\nfunc (q *MyQueue) Pop() int {\n    if len(q.outStack) == 0 {\n        for len(q.inStack) > 0 {\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\n            q.inStack = q.inStack[:len(q.inStack) - 1]\n        }\n    }\n    x := q.outStack[len(q.outStack) - 1]\n    q.outStack = q.outStack[:len(q.outStack) - 1]\n\n    return x\n}\n\n\nfunc (q *MyQueue) Peek() int {\n    if len(q.outStack) == 0 {\n        for len(q.inStack) > 0 {\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\n            q.inStack = q.inStack[:len(q.inStack) - 1]\n        }\n    }\n    x := q.outStack[len(q.outStack) - 1]\n    return x\n}\n\n\nfunc (q *MyQueue) Empty() bool {\n    return len(q.outStack) == 0 && len(q.inStack) == 0\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092336991","body":"```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\n // 迭代实现\nfunc swapPairs(head *ListNode) *ListNode {\n    dummyHead := &ListNode{0, head}\n    temp := dummyHead\n\n    // 后一个结点和后两个结点不为nil\n    for temp.Next != nil && temp.Next.Next != nil {\n       nodeBefore := temp.Next\n       nodeAfter := temp.Next.Next\n\n       temp.Next = nodeAfter\n       nodeBefore.Next = nodeAfter.Next\n       nodeAfter.Next = nodeBefore\n       temp = nodeBefore\n    }\n\n    return dummyHead.Next\n\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095084862","body":"```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    // 创建头结点和尾结点\n    slow, fast := head, head\n\n    // 快慢指针\n    for fast != nil {\n        slow = slow.Next\n        if fast.Next == nil {\n            return nil\n        }\n        fast = fast.Next.Next\n        //\n        if fast == slow {\n            p := head\n            for p != slow {\n                p = p.Next\n                slow = slow.Next\n            }\n            return p\n        }\n    }\n    return nil\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098113058","body":"/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n        return 0\n    }\n\n    queue := []*TreeNode{}\n    queue = append(queue, root)\n    ans := 0\n\n    // 广度优先遍历\n    for len(queue) > 0 {\n        sz := len(queue) \n        for sz > 0 {\n                node := queue[0]\n                queue = queue[1:]\n                if node.Left != nil {\n                    queue = append(queue, node.Left)\n                }\n                if node.Right != nil {\n                    queue = append(queue, node.Right)\n                }\n                sz--\n        }\n        ans++\n    }\n    return ans\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100875460","body":"type Codec struct{}\n\nfunc Constructor() (_ Codec) {\n    return\n}\n\nfunc (Codec) serialize(root *TreeNode) string {\n    sb := &strings.Builder{}\n    var dfs func(*TreeNode)\n    dfs = func(node *TreeNode) {\n        if node == nil {\n            sb.WriteString(\"null,\")\n            return\n        }\n        sb.WriteString(strconv.Itoa(node.Val))\n        sb.WriteByte(',')\n        dfs(node.Left)\n        dfs(node.Right)\n    }\n    dfs(root)\n    return sb.String()\n}\n\nfunc (Codec) deserialize(data string) *TreeNode {\n    sp := strings.Split(data, \",\")\n    var build func() *TreeNode\n    build = func() *TreeNode {\n        if sp[0] == \"null\" {\n            sp = sp[1:]\n            return nil\n        }\n        val, _ := strconv.Atoi(sp[0])\n        sp = sp[1:]\n        return &TreeNode{val, build(), build()}\n    }\n    return build()\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102597795","body":"```go\nfunc twoSum(nums []int, target int) []int {\n    hashTable := map[int]int{}\n    for i, x := range nums {\n        if p, ok := hashTable[target-x]; ok {\n            return []int{p, i}\n        }\n        hashTable[x] = i\n    }\n    return nil\n\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107525799","body":"func findSubstring(s string, words []string) []int {\n    wL := len(words)            // words 中单词个数\n    oneWordL := len(words[0])   // 每个单词长度\n    hm := make(map[string]int)  // 存words中单词的map\n    Allcount := 0              // 记录不同单词的个数，用于在窗口滑动过程中判断是否满足答案条件\n    for i := 0; i < wL; i++ {\n        if _, ok := hm[words[i]]; !ok {\n           Allcount++ \n        }\n        hm[words[i]]++\n    }\n\n    ans := []int{}\n    for i := 0; i < oneWordL; i++ {\n        Count := 0\n        tmpHm := map[string]int{} // 滑动窗口中的单词记录map\n        left, right := i, i + oneWordL\n        for ; right <= len(s); right += oneWordL {\n            str := s[right - oneWordL : right]\n            if _ , ok := hm[str]; ok {\n                tmpHm[str]++\n                if tmpHm[str] == hm[str] {\n                    Count++\n                }\n            }\n\n            for right - left > oneWordL * wL {\n                str := s[left : left + oneWordL]\n                if _, ok := tmpHm[str]; ok {\n                    tmpHm[str]--\n                }\n\n                if tmpHm[str] + 1 == hm[str] {\n                    Count--\n                }\n                left += oneWordL\n            }\n\n            if Count == Allcount && right - left == oneWordL * wL { // 两个条件判断是否\n                ans = append(ans, left)\n            }\n        }\n    }\n    return ans\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhishinaigai":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085936068","body":"### 思路\r\n浅抄一手答案\r\n\r\n### 代码\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector <int> ans;\r\n        int len=num.size();\r\n        \r\n        for(int i=len-1;i>=0;i--){\r\n            int s=num[i]+k%10;\r\n            k/=10;\r\n            if(s>=10){\r\n                k++;\r\n                s-=10;\r\n            }\r\n            ans.push_back(s);\r\n        }\r\n        while(k>0){\r\n            ans.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n        return ans;\r\n    }\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652806","body":"### 思路\r\n今天也是抄答案的一天呢\r\n### 代码\r\n```\r\nvector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(),-1);\r\n        int len=s.size();\r\n        int p=-1;\r\n        for(int i=0;i<len;i++){\r\n            if(s[i]==c){\r\n                p=i;\r\n                ans[i]=0;\r\n            } \r\n            else if(p!=-1) ans[i]=i-p;\r\n        }\r\n        p=-1;\r\n        for(int i=len-1;i>=0;--i){\r\n            if(s[i]==c) p=i;\r\n            if(p!=-1) ans[i]=min(ans[i],p-i);\r\n            if(ans[i]==-1) ans[i]=p-i;\r\n             \r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086847912","body":"### 思路\r\n使用vector实现\r\n### 代码\r\n```c\r\nclass CustomStack {\r\npublic:\r\n    vector <int> stk;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=stk.size()-1){\r\n            ++top;\r\n            stk[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1) return -1;\r\n        --top;\r\n        return stk[top+1];\r\n\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim=min(k,top+1);\r\n        for(int i=0;i<lim;++i){\r\n            stk[i]+=val;\r\n        }\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087532217","body":"思路\r\n---\r\n\r\n抄答案都没看懂哇，字符串一生之敌\r\n\r\n代码\r\n---\r\n```c\r\nstring getDigits(string &s,size_t &ptr){\r\n        string ret=\"\";\r\n        while(isdigit(s[ptr])){\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n    string getString(vector<string> &v){\r\n        string ret;\r\n        for(const auto &s:v){\r\n            ret+=s;\r\n        }\r\n        return ret;\r\n    }\r\n    string decodeString(string s) {\r\n        int len=s.size();\r\n        vector <string> stk;\r\n        size_t i=0;\r\n\r\n        while(i<len){\r\n            char cur=s[i];\r\n            if(isdigit(cur)){\r\n                string digits=getDigits(s,i);\r\n                stk.push_back(digits);\r\n            }\r\n            else if(isalpha(cur)||cur=='['){\r\n                stk.push_back(string(1,s[i++]));\r\n            }\r\n            else{\r\n                ++i;\r\n                vector<string> sub;\r\n                while(stk.back()!=\"[\"){\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(),sub.end());\r\n                stk.pop_back();\r\n                int reptime=stoi(stk.back());\r\n                stk.pop_back();\r\n                string t,o=getString(sub);\r\n                while(reptime--) t+=o;\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n        return getString(stk);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088858579","body":"思路\r\n---\r\n\r\n两个栈一个in一个out\r\n\r\n代码\r\n---\r\n\r\n```c\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> ins,outs;\r\n    void in2out(){\r\n        while(!ins.empty()){\r\n            outs.push(ins.top());\r\n            ins.pop();\r\n        }\r\n    }\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        ins.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outs.empty()){\r\n            in2out();\r\n        }\r\n        int x=outs.top();\r\n        outs.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outs.empty()){\r\n            in2out();\r\n        }\r\n        return outs.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return ins.empty() && outs.empty();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090237216","body":"思路\r\n---\r\n\r\n- 使用栈存储每个块最大的元素\r\n- 若arr[i]大于栈顶元素则直接入栈\r\n- 若arr[i]小于栈顶元素则将大于arr[i]的元素从栈中弹出\r\n\r\n代码\r\n---\r\n\r\n```c\r\nint maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> maxstk;\r\n        maxstk.push(arr[0]);\r\n        for(int i=1;i<arr.size();i++){\r\n            if(arr[i]<maxstk.top()){\r\n                int maxnum=maxstk.top();\r\n                while(!maxstk.empty()&&maxstk.top()>arr[i]) maxstk.pop();\r\n                maxstk.push(maxnum);\r\n            }\r\n            else{\r\n                maxstk.push(arr[i]);\r\n            }\r\n        }\r\n        return maxstk.size();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091887734","body":"思路\r\n---\r\n将链表变成环再在相应位置切断\r\n\r\n代码\r\n---\r\n```c\r\nListNode* rotateRight(ListNode* head, int k) {\r\n        if(k==0||head==nullptr||head->next==nullptr) return head;\r\n        int n=1;\r\n        ListNode *iter=head;\r\n        while(iter->next!=nullptr){\r\n            iter=iter->next;\r\n            n++;\r\n        }\r\n        int add=n-k%n;\r\n        if(add==n) return head;\r\n        iter->next=head;\r\n        while(add--){\r\n            iter=iter->next;\r\n        }\r\n        ListNode *ret=iter->next;\r\n        iter->next=nullptr;\r\n        return ret;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092790544","body":"思路\r\n---\r\n迭代实现\r\n\r\n代码\r\n---\r\n```c\r\nListNode* swapPairs(ListNode* head) {\r\n        ListNode * dhead=new ListNode(0);\r\n        dhead->next=head;\r\n        ListNode* temp=dhead;\r\n        while(temp->next!=nullptr&&temp->next->next!=nullptr){\r\n            ListNode* n1=temp->next;\r\n            ListNode* n2=temp->next->next;\r\n            temp->next=n2;\r\n            n1->next=n2->next;\r\n            n2->next=n1;\r\n            temp=n1;\r\n        }\r\n        return dhead->next;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094157359","body":"思路\r\n---\r\n递归\r\n\r\n代码\r\n---\r\n```c\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n        TreeNode *root;\r\n        if(!head) return nullptr;\r\n        if(!head->next){\r\n            root = new TreeNode(head->val);\r\n            return root;\r\n        }\r\n        ListNode* fast=head;\r\n        ListNode* slow=head;\r\n        ListNode* pre=head;\r\n        while(fast!=nullptr&&fast->next!=nullptr){\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }\r\n        while(pre->next!=slow) pre=pre->next;\r\n        root=new TreeNode(slow->val);\r\n        ListNode* headright=slow->next;\r\n        pre->next=nullptr;\r\n        root->left=sortedListToBST(head);\r\n        root->right=sortedListToBST(headright);\r\n\r\n        return root;\r\n    }\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094157906","body":"思路\r\n---\r\n双指针\r\n\r\n代码\r\n---\r\n```c\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA==nullptr||headB==nullptr){\r\n            return nullptr;\r\n        }\r\n        ListNode *a=headA;\r\n        ListNode *b=headB;\r\n        while(a!=b){\r\n            a= a==nullptr ? headB : a->next;\r\n            b= b==nullptr ? headA : b->next;\r\n        }\r\n        return a;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094939531","body":"思路\r\n---\r\n快慢指针\r\n\r\n代码\r\n---\r\n```c\r\nListNode *detectCycle(ListNode *head) {\r\n        ListNode *fast=head,*slow=head;\r\n        do{\r\n            if(!fast||!fast->next) return nullptr;\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }while(fast!=slow);\r\n        fast=head;\r\n        while(fast!=slow){\r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        return fast;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096698768","body":"思路\r\n---\r\n这答案抄的我人麻了\r\n\r\n代码\r\n---\r\n```c\r\nstruct DLinkedNode{\r\n    int key,value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode():key(0),value(0),prev(nullptr),next(nullptr) {}\r\n    DLinkedNode(int _key,int _value):key(_key),value(_value),prev(nullptr),next(nullptr) {}\r\n};\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int,DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\npublic:\r\n    LRUCache(int _capacity) :capacity(_capacity),size(0) {\r\n        head=new DLinkedNode();\r\n        tail=new DLinkedNode();\r\n        head->next=tail;\r\n        tail->prev=head;\r\n\r\n    }\r\n    \r\n    int get(int key) {\r\n        if(!cache.count(key)){\r\n            return -1;\r\n        }\r\n        DLinkedNode* node=cache[key];\r\n        movetohead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(!cache.count(key)){\r\n            DLinkedNode* node=new DLinkedNode(key,value);\r\n            cache[key]=node;\r\n            addtohead(node);\r\n            ++size;\r\n            if(size>capacity){\r\n                DLinkedNode* r=removetail();\r\n                cache.erase(r->key);\r\n                delete r;\r\n                --size;\r\n            }\r\n        }\r\n        else{\r\n            DLinkedNode* node=cache[key];\r\n            node->value=value;\r\n            movetohead(node);\r\n        }\r\n    }\r\n    void addtohead(DLinkedNode* node){\r\n        node->prev=head;\r\n        node->next=head->next;\r\n        head->next->prev=node;\r\n        head->next=node;\r\n    }\r\n    void removenode(DLinkedNode* node){\r\n        node->prev->next=node->next;\r\n        node->next->prev=node->prev;\r\n    }\r\n    void movetohead(DLinkedNode* node){\r\n        removenode(node);\r\n        addtohead(node);\r\n    }\r\n    DLinkedNode* removetail(){\r\n        DLinkedNode* node=tail->prev;\r\n        removenode(node);\r\n        return node;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098029113","body":"思路\r\n---\r\n深度优先遍历\r\n\r\n代码\r\n---\r\n```c\r\nint maxDepth(TreeNode* root) {\r\n        if(root==nullptr) return 0;\r\n        else return max(maxDepth(root->left),maxDepth(root->right))+1;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099098752","body":"思路\r\n---\r\ndfs\r\n\r\n代码\r\n---\r\n```c\r\nbool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p==nullptr&&q==nullptr) return true;\r\n        else if(p==nullptr||q==nullptr) return false;\r\n        else if(p->val!=q->val) return false;\r\n        else return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100060364","body":"思路\r\n---\r\ndfs\r\n\r\n代码\r\n---\r\n```c\r\nclass Solution {\r\npublic:\r\n    int res;\r\n    int sumNumbers(TreeNode* root) {\r\n        dfs(root,0);\r\n        return res;\r\n    }\r\n    void dfs(TreeNode* root,int number){\r\n        number=number*10+root->val;\r\n        if(!root->left&&!root->right) res+=number;\r\n        if(root->left) dfs(root->left,number);\r\n        if(root->right) dfs(root->right,number);\r\n    }\r\n};\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100657417","body":"### 思路\r\ndfs\r\n\r\n### 代码\r\n```c\r\nclass Solution {\r\npublic:\r\n    int left,maxd=-1;\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        dfs(root,0);\r\n        return left;\r\n    }\r\n    void dfs(TreeNode *root,int dep){\r\n        if(!root) return;\r\n        if(dep>maxd){\r\n            left=root->val;\r\n            ++maxd;\r\n        }\r\n        dfs(root->left,dep+1);\r\n        dfs(root->right,dep+1);\r\n    }\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100873849","body":"摆了\r\n\r\n### 代码\r\n```c\r\n\r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101348487","body":"思路\r\n---\r\n哈希+dfs\r\n\r\n代码\r\n---\r\n```c++\r\ntypedef pair<int,int> PII;\r\nclass Solution {\r\npublic:\r\n    map<int,vector<PII>> S;\r\n    void dfs(TreeNode* root,int u,int v){\r\n        if(!root) return;\r\n        S[v].push_back({u,root->val});\r\n        dfs(root->left,u+1,v-1);\r\n        dfs(root->right,u+1,v+1);\r\n    }\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root,0,0);\r\n        vector<vector<int>> res;\r\n        for(auto [x,y]:S){\r\n            sort(y.begin(),y.end());\r\n            vector<int> v;\r\n            for(auto a:y) v.push_back(a.second);\r\n            res.push_back(v);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102627555","body":"思路\r\n---\r\n哈希\r\n\r\n代码\r\n---\r\n```c++\r\nvector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int,int> hashtable;\r\n        for(int i=0;i<nums.size();++i){\r\n            auto it=hashtable.find(target-nums[i]);\r\n            if(it!=hashtable.end()){\r\n                return {it->second,i};\r\n            }\r\n            hashtable[nums[i]]=i;\r\n        }\r\n        return {};\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103908377","body":"思路\r\n---\r\n**小顶堆**\r\n先用哈希表记录每个数据出现次数。遍历哈希表，将哈希表的key和value作为pair加入小顶堆。每次向堆中加入一个元素，如果堆的大小超过k，就pop一次。最后将堆中元素依次pop，即为前k高频元素。\r\n\r\n代码\r\n---\r\n```c++\r\nclass Solution {\r\npublic:\r\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\r\n        return m.second > n.second;\r\n    }\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int,int> occ;\r\n        for(auto& v:nums){\r\n            occ[v]++;\r\n        }\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(&cmp)>q(cmp);\r\n        for(auto & [num,count]:occ){\r\n            if(q.size()==k){\r\n                if(q.top().second<count){\r\n                    q.pop();\r\n                    q.emplace(num,count);\r\n                }\r\n            }\r\n            else{\r\n                q.emplace(num,count);\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while(!q.empty()){\r\n            ret.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105952736","body":"思路\r\n---\r\n双指针+哈希\r\n\r\n代码\r\n---\r\n```c++\r\nint lengthOfLongestSubstring(string s) {\r\n        unordered_set<char> occ;\r\n        int len=s.size();\r\n        int rk=-1,ans=0;\r\n        for(int i=0;i<len;++i){\r\n            if(i!=0) occ.erase(s[i-1]);\r\n            while(rk+1<len&&!occ.count(s[rk+1])){\r\n                occ.insert(s[rk+1]);\r\n                rk++;\r\n            }\r\n            ans=max(ans,rk-i+1);\r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107523075","body":"### 代码\r\n\r\n```c\r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        vector<int> res; // 结果\r\n        unordered_map<string, int> search;\r\n        for (auto &word : words) ++search[word]; // 参照物初始化\r\n        int n = s.size(), m = words.size(), len = words[0].size(); // 获取隐藏变量\r\n        for (int i = 0, j = 0; i < n - m * len + 1; ++i) { // 主逻辑\r\n            unordered_map<string, int> sub; // 子字符 查找的中间结果\r\n            for (j = 0; j < m; ++j) { // 子字符串查找逻辑\r\n                auto word = s.substr(i + j * len, len); // 获取子串\r\n                if (!search.count(word)) break; // 子串 不在 words 里面\r\n                if (++sub[word] > search[word]) break; // 子串个数 比 words 多\r\n            }\r\n            if (j == m) res.push_back(i); // 完全匹配\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108461101","body":"思路\r\n---\r\n快慢指针\r\n\r\n代码\r\n---\r\n```c++\r\nListNode* middleNode(ListNode* head) {\r\n        ListNode* fast=head;\r\n        ListNode* slow=head;\r\n        while(fast&&fast->next){\r\n            slow=slow->next;\r\n            fast=fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109435776","body":"思路\r\n---\r\n双指针\r\n\r\n代码\r\n---\r\n```c++\r\nint removeDuplicates(vector<int>& nums) {\r\n        int len=nums.size();\r\n        if(len==0) return 0;\r\n        int l=1,r=1;\r\n        while(r<len){\r\n            if(nums[r]!=nums[r-1]){\r\n                nums[l]=nums[r];\r\n                l++;\r\n            }\r\n            r++;\r\n        }\r\n        return l;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度O(n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110442076","body":"思路\r\n---\r\n二分法\r\n\r\n代码\r\n---\r\n```c++\r\nint searchInsert(vector<int>& nums, int target) {\r\n        int len=nums.size();\r\n        int l=0,r=len-1;\r\n        while(l<=r){\r\n            int mid=(l+r)/2;\r\n            if(target==nums[mid]) return mid;\r\n            else if(target<nums[mid]) r=mid-1;\r\n            else l=mid+1;\r\n        }\r\n        return r+1;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112184765","body":"思路\r\n---\r\n单调队列\r\n\r\n代码\r\n---\r\n```c++\r\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        int len=nums.size();\r\n        deque<int> q;\r\n        for(int i=0;i<k;i++){\r\n            while(!q.empty()&&nums[i]>=nums[q.back()]){\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n        }\r\n        vector<int> ans {nums[q.front()]};\r\n        for(int i=k;i<len;i++){\r\n            while(!q.empty()&&nums[i]>=nums[q.back()]){\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n            while(q.front()<=i-k){\r\n                q.pop_front();\r\n            }\r\n            ans.push_back(nums[q.front()]);\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间：O(n)\r\n空间：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113208078","body":"思路\r\n---\r\n计算入度和出度\r\n\r\n代码\r\n---\r\n```c++\r\nint findJudge(int n, vector<vector<int>>& trust) {\r\n        vector <int> in(n+1);\r\n        vector <int> out(n+1);\r\n        for(auto& edge:trust){\r\n            int x=edge[0];\r\n            int y=edge[1];\r\n            ++in[y];\r\n            ++out[x];\r\n        }\r\n        for(int i=1;i<=n;i++){\r\n            if(in[i]==n-1&&out[i]==0) return i;\r\n        }\r\n        return -1;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonhe-wq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938194","body":"思路：将列表中的数转化为整数，与k相加，再转化为可迭代对象，加入数组输出\n代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s=''.join(str(i) for i in num)\n        n = str(eval(s)+k)\n        l = []\n        for i in n:\n            l.append(eval(i))\n        return l\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086649828","body":"思路：\n对于每一个等于c的字符，在其两侧分别计算距离，而对于每个字符，距离取最小值\n优化方向：\n将等于c的字符分为首个，中间，末尾，分别控制不同的区域\n代码：\n'''\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        ans = [l for i in range(l)]\n        for i in range(l):\n            if s[i] == c:\n                for j in range(l):\n                    ans[j]=min(ans[j],abs(i-j))\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877618","body":"思路：\n构建数组作为栈，再用一个额外的变量存储maxsize，对于每个要相加的值，先判断长度是否小于k，再遍历\n```\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.num = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.num:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087712391","body":"思路：\n每次遇到[记录下来位置，遇到]则将片段重复mul次，并将指针重新移动到最左端，重复操作\n对于数字，每次遇到时判断，如果与[相邻，则记为mul，否则舍去\n最后通过列表将序列中的数字全部去除\n代码：\n```class Solution:\n    def decodeString(self, s: str) -> str:\n        left = []\n        num = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        n = \"\"\n        s0 = \"\"\n        mul = 0\n        i = 0\n        ans =\"\"\n        nu = \"\"\n        while i <len(s):\n            if s[i] == \"[\":\n                left.append(i)\n                n = s[:i]\n                for j in n:\n                    if j in num:\n                        nu += j\n                    else:\n                        nu =\"\"\n                mul = eval(nu)\n                nu = \"\"\n                i += 1\n            elif s[i] == \"]\":\n                s0 = s[:left[-1]]+s[left[-1]+1:i] * mul+s[i+1:]\n                s = s0\n                i = 0\n            else:\n                i +=1\n        l = list(s)\n        for i in range(len(l)):\n            if l[i] in num:\n                pass\n            else:\n                ans += l[i]\n        return ans\n复杂度：O(n)还是O(n^2)我也不知道","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088377130","body":"思路：\n创建入栈和出栈列表，向入栈队列添加元素，当都为空时返回空，当出栈为空时，依次将入栈元素压入，再返回\n代码：\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.inStack = []\n        self.outStack = []\n\n\n    def push(self, x: int) -> None:\n        self.inStack.append(x)\n\n    def pop(self) -> int:\n        if not self.empty():\n            if self.outStack:\n                return self.outStack.pop()\n            else:\n                while self.inStack:\n                    self.outStack.append(self.inStack.pop())\n                return self.outStack.pop()\n        else:\n            return 0\n\n    def peek(self) -> int:\n        if self.empty():\n            return 0\n        if not self.outStack:            \n            while self.inStack:\n                self.outStack.append(self.inStack.pop())\n        val = self.pop()\n        self.outStack.append(val)\n        return val\n\n\n\n    def empty(self) -> bool:\n        if not (self.inStack or self.outStack):\n            return True\n        return False","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091732167","body":"思路：\n先判断是否满足旋转条件，再求出链表长度，对k取余数，为真正需要移位次数k0\n再将指针转移到倒数第二个，将其定义为最后一个，最后一个移到第一个，重复k0次\n复杂度：\nO(n)\n代码：\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        index = 0 \n        node = head\n        head = head\n        test = head\n        l = 0\n        if k == 0 or not head or not head.next:\n            return head\n        while test:\n            test = test.next\n            l += 1\n        k = k%l\n        while index <k:\n            flag  = node.next.next\n            if flag:\n                node = node.next\n                continue\n            else:\n                i = node.next\n                node.next = None\n                i.next = head\n                head = i\n                node  = head\n            index += 1\n        return head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092541812","body":"思路：\n用多个变量分别记录各个位置的链表，再重新排序\n私以为关键点在于最后如何跳出循环，如果为偶数个节点，直接跳出，如果为奇数个节点，需要额外的判断，可以使用not的特性，直接跳出\n代码\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        node = ListNode(0,head)\n        h0 = node\n        while node.next.next:\n            next2 = node.next.next.next\n            next0 = node.next\n            next1 = node.next.next\n            node.next = next1\n            node.next.next = next0\n            node.next.next.next = next2\n            node = node.next.next\n            re = h0.next\n            if not node.next or not node.next.next:\n                return re\n        return h0.next\n            \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094008518","body":"思路：\n说实话，我一开始根本没有思路，这类递归都不太会\n我看了l神的答案，觉得题目难点就在于要想到递归\n代码：\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        l = 0\n        stack = []\n        cut, slow, fast = None, head, head\n        if not head:\n            return head\n        while fast and fast.next:\n            cut = slow\n            slow = slow.next           \n            fast = fast.next.next\n        if cut:\n            cut.next = None   \n        midTree = TreeNode(slow.val)\n        if slow==fast:\n            return midTree\n        midTree.left = self.sortedListToBST(head)\n        midTree.right = self.sortedListToBST(slow.next)\n        return midTree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094173688","body":"思路：\r\n交叉遍历，当第一次取到末尾时，相互交换，heada到headb链上，headb到heada链上，如果再次走到末尾且两者没有相同的节点，返回空，否则返回相等的节点\r\n代码：\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        vala = []\r\n        valb = []\r\n        ha = headA\r\n        hb = headB\r\n        flaga = False\r\n        flagb = False\r\n        while True:\r\n            if headA == headB:\r\n                return headB           \r\n            if not headA.next and not flaga:\r\n                pre = headA\r\n                headA.next = hb\r\n                headA = headA.next\r\n                pre.next = None\r\n                flaga = True\r\n            elif not headA.next and flaga:\r\n                return None\r\n            else:\r\n                headA = headA.next\r\n            if not headB.next and not flagb:\r\n                pre = headB\r\n                headB.next = ha\r\n                headB = headB.next\r\n                pre.next = None\r\n                flagb = True\r\n            elif not headB.next and flagb:\r\n                return None\r\n            else:\r\n                headB = headB.next\r\n复杂度：\r\nO(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094463378","body":"思路：\n创建列表，如果里面没有对应结点，则加入，如果有，则返回\n代码：\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        l = []\n        if not head or not head.next:\n            return None\n        while head:\n            if head not in l:\n                l.append(head)\n                head = head.next\n            else:\n                return head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096252908","body":"思路：\n构造字典和列表，分别记录键值对和顺序，在查询和修改时都要考虑顺序变化\n```python\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.dict = {}\n        self.ord = []\n        self.cap = capacity\n\n    def get(self, key: int) -> int:\n        if key in self.dict:           \n            self.ord.remove(key)\n            self.ord.append(key)\n            return self.dict[key]\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        self.dict[key] = value\n        if key in self.ord:\n            self.ord.remove(key)\n            self.ord.append(key)\n        else:\n            if len(self.ord)==self.cap:\n                k = self.ord.pop(0)\n                del self.dict[k]\n                self.ord.append(key)\n            else:\n                self.ord.append(key)\n\n\n\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097515755","body":"思路：\n层序遍历，用列表记录每棵子树，然后如果列表不为空，level += 1\n代码：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        q = [root]\n        level = 1\n        while q:\n            child = []\n            for i in q:\n                if i.left:\n                    child.append(i.left)\n                if i.right:\n                    child.append(i.right)\n            if child:\n                level += 1\n            q = child\n        return level\n```\n复杂度：\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098700188","body":"思路：\n层序遍历\n代码：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        q1 = [p]\n        q2 = [q]\n        if p.val != q.val:\n            return False\n        while q1 and q2:\n            child1 = []\n            child2 = []\n            num1 = []\n            num2 = []\n            l1 = len(q1)\n            l2 = len(q2)\n            if l1 !=l2:\n                return False\n            for i in range(l1):\n                if q1[i].left:\n                    child1.append(q1[i].left)\n                    if q2[i].left:\n                        child2.append(q2[i].left)\n                    else:\n                        return False\n                else:\n                    if q2[i].left:\n                        return False\n                if q1[i].right:\n                    child1.append(q1[i].right)\n                    if q2[i].right:\n                        child2.append(q2[i].right)\n                    else:\n                        return False\n                else:\n                    if q2[i].right:\n                        return False\n                num1.append(q1[i].val)\n                num2.append(q2[i].val)\n            q1 = child1\n            q2 = child2\n            if num1==num2:\n                continue\n            else:\n                return False\n        return True\n            \n```\n复杂度：\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099820041","body":"思路：\n层序遍历，当没有子节点时，以字符串的形式保存值，输出时去掉前面的0\n代码：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        q = [root]\n        re = [str(root.val)]\n        tar = []\n        while q:\n            child = []\n            num = []\n            for i in range(len(q)):\n                if q[i].left:\n                    num.append(re[i]+str(q[i].left.val))\n                    child.append(q[i].left)\n                if q[i].right:\n                    num.append(re[i]+str(q[i].right.val))\n                    child.append(q[i].right)\n                if not q[i].left and not q[i].right:\n                    tar.append(re[i])\n            q = child\n            re = num\n\n\n        for i in range(len(tar)):\n            for j in range(len(tar[i])):\n                if tar[i][j]==\"0\":\n                    pass\n                else:\n                    tar[i] = tar[i][j:]\n                    break\n            if tar[i]:\n                tar[i] = eval(tar[i])\n        return sum(tar)\n```\n复杂度：\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100662780","body":"思路：\n层序遍历，找到最左边的节点的值即可\n代码：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = [root]\n        re = 0\n        while q:\n            re = q[0].val\n            child = []\n            for i in q:\n                if i.left:\n                    child.append(i.left)\n                if i.right:\n                    child.append(i.right)\n            q = child\n        return re\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100891624","body":"思路：\n构建先序遍历和中序遍历，然后用\"+\"分割，输入再用.lstrip(\"[\")和.split(\",\")清洗数据，再重新构建\n构建时，先序遍历第一个是根节点，再在中序遍历中找到根节点，分割中序遍历，根据长度，分割先序遍历，再递归\n代码：\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        pre = []\n        mid = []\n        def preOrder(root):\n            if not root:\n                return []\n            nonlocal pre\n            pre.append(root.val)\n            preOrder(root.left)\n            preOrder(root.right)\n        def midOrder(root):\n            if not root:\n                return []\n            nonlocal mid\n            midOrder(root.left)\n            mid.append(root.val)\n            midOrder(root.right)\n        preOrder(root)\n        midOrder(root)\n        re = str(pre)+\"+\"+str(mid)\n        print(re)\n        return re\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        pre,mid = data.split(\"+\")\n        if len(pre)==2 or len(mid)==2:\n            return None\n        pre = pre.lstrip(\"[\")\n        mid = mid.lstrip(\"[\")\n        pre = pre.rstrip(\"]\")\n        mid = mid.rstrip(\"]\")\n        pre = pre.split(\",\")\n        mid = mid.split(\",\")\n        for i in range(len(pre)):\n            pre[i] = eval(pre[i])\n        for i in range(len(mid)):\n            mid[i] = eval(mid[i])\n        root = self.plant(pre,mid)\n        return root\n    def plant(self,pre,mid):\n        if not pre or not mid:\n            return None\n        root = TreeNode(pre[0])\n        sp = mid.index(pre[0])\n        leftTreeMid = mid[:sp]\n        rightTreeMid = mid[sp+1:]\n        leftLength = len(leftTreeMid)\n        rightLength = len(rightTreeMid)\n        leftTreePre = pre[1:leftLength+1]\n        rightTreePre = pre[leftLength+1:]\n        root.left = self.plant(leftTreePre,leftTreeMid)\n        root.right = self.plant(rightTreePre,rightTreeMid)\n        return root\n        \n\n            \n\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101273451","body":"思路：\n层序遍历，每层单独设置一个列表，这一层每个元素记录下一层和它的位置。\n然后再判断行，用字典记录重复列的次数，循环取出，排序，再重新加入\n代码：\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        q = [root]\n        min = 0\n        max = 0\n        if not root:\n            return None\n        lo = [[[root.val, 0, 0]]]\n        level = 0       \n        while q:\n            child=[]\n            lo.append([])  \n            for i in range(len(q)):\n                if q[i].left:\n                    child.append(q[i].left)\n                    lo[-1].append([q[i].left.val, lo[level][i][1] + 1, lo[level][i][2] - 1])\n                if q[i].right:\n                    child.append(q[i].right)\n                    lo[-1].append([q[i].right.val, lo[level][i][1] + 1, lo[level][i][2] + 1])\n            q = child\n            level += 1\n            if not child:\n                lo.pop()\n        new = []\n        for i in lo:\n            for j in i:\n                new.append(j)\n        new = sorted(new,key = lambda x: x[2])\n        col = []\n        tar = []\n        row = {}\n        temp = []\n        for i in new:\n            if i[2] not in col:\n                tar.append([])\n                col.append(i[2])\n                row.clear()\n            if i[1]not in row:\n                tar[-1].append(i[0])\n                row[i[1]] = 1\n            else:\n                while row[i[1]]>0:\n                    temp.append(tar[-1].pop())\n                    row[i[1]] -= 1\n                temp.append(i[0])\n                temp.sort()\n                row[i[1]] = len(temp)\n                tar[-1].extend(temp)\n                temp = []\n\n        return tar         \n```\n复杂度：\nO(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101893172","body":"代码：\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        l = len(nums)\r\n        for i in range(l):\r\n            add1 = nums[i]\r\n            add2 = target - add1\r\n            if add2 in nums[i+1:]:\r\n                return [i,nums[i+1:].index(add2)+1+i]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103901981","body":"思路：\n使用Collections库的counter函数，再调用.most_common()记录下最常见的前k个元素，遍历其中元素，取出对应位置的值，输出\n代码：\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = collections.Counter(nums)\n        mostCommon = dic.most_common(k)\n        tar = []\n        for i in mostCommon:\n            tar.append(i[0])\n        return tar\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105369328","body":"思路：\n记录每个节点距离其他节点的距离，并由此构造出字典，然后对每一个值A(m,2)，求和\n说实话，我一开始还没有想到这种方法\n代码：\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points)<=2:\n            return 0\n        l = len(points)\n        ans = 0\n        dic = {}\n        for i in range(l):\n            dic.clear()\n            p1 = points[i]\n            for j in range(l):\n                p2 = points[j]\n                r = (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2\n                dic[r] = dic.get(r, 0) + 1\n            for j in dic:\n                ans += dic[j]*(dic[j] - 1)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106002046","body":"思路：\n滑动窗口，当右侧字符串不在原来字符串里面时，右侧指针右移，重新记录长度，否则左侧指针移\n代码：\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l = len(s)\n        slow = 0\n        fast = slow + 1\n        if not s:\n            return 0\n        ans = 1\n        while fast<l:\n            if s[fast] not in s[slow:fast]:\n                ans = max(fast - slow + 1, ans)\n                fast += 1\n            else:\n                slow += 1\n        return ans\n```\n复杂度：\nO(n)                ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107952195","body":"思路：\n快慢指针\n代码：\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = head\n        while head and head.next:\n            head = head.next.next\n            slow = slow.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109205778","body":"思路：双指针，一个负责读取不同的值，一个负责写入不同的值\n代码：\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        fast, slow = 0, 0\n        while fast < len(nums):\n            if nums[slow]!=nums[fast]:\n                slow += 1\n                nums [slow] = nums[fast]\n            fast += 1\n        return slow + 1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111975785","body":"思路：\n完全不会，看了答案\n答案的意思是：构建一个递减的序列，每当一个数要进入时，不断判断是不是比当前最小值小，如果不，从后往前pop，为了移动窗口，每当一个数进来后，判断左侧第一个是不是应该pop，然后答案队列append当前最大值\n代码：\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = collections.deque()\n        for i in range(k):\n            while q and nums[i]>=nums[q[-1]]:\n                q.pop()\n            q.append(i)\n        ans = [nums[q[0]]]\n        for i in range(k,n):\n            while q and nums[i]>=nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            while q[0]<=i-k:\n                q.popleft()\n            ans.append(nums[q[0]])\n        return ans\n```\n复杂度：\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113140950","body":"代码：\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        inDegrees = collections.Counter(y for _, y in trust)\n        outDegrees = collections.Counter(x for x, _ in trust)\n        print(inDegrees)\n        print(outDegrees)\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938263","body":"## 989. Add to Array-Form of Integer\n### 1. 思路\n- 基础思考点：transform a number to an int array\n```C\n// 代码实现\nvar array = [];\nvar k = 123;\nwhile (k >= 1) {\n  array.push(Math.floor(k % 10));\n  k /= 10;\n}\n// array: [1, 2, 3]\n```\n拓展上述代码，思路变为：\n> k 或 num 还有剩余位数时，resultArray 不断添加剩余数位\n### 2. 细节处理\n- 相加的结果会进位（这里我用了 num 来存储进位数据）\n  - 如果 num 数组还有数字，给数组的最后一位+1\n  - 如果 num 数组没有数字了，将数组的最后一位赋为 1\n- num 代表的数字，其位数和 k 的位数不一致\n  - 判断一下，确保 getK 和 getN 不会越位\n\n### 3. 复杂度\n- 时间：O(n)  \n  - while 的长度为 max(k的位数，num的位数);  \n  - while 内部涉及的数组操作:     \narray.pop(), array.push(), array[i] =，三者的时间复杂度为 O(1)\n- 空间：O(n)\n  - 新开了一个数组，O(n)\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nconst addToArrayForm = (num, k) => {\n  let temp = 0;\n  const resultArray = [];\n  while (k >= 1 || num.length) {\n    temp = getK(Math.floor(k % 10)) + getN(num);\n    resultArray.push(handleTemp(temp, num));\n\n    temp = 0;\n    k /= 10;\n  }\n  return resultArray.reverse();\n};\n\nconst getK = (kNum) => kNum >= 1 ? kNum : 0;\nconst getN = (num) => num.length ? num.pop() : 0;\nconst handleTemp = (temp, num) => {\n  if (temp >= 10) {\n    temp -= 10;\n    if (num.length) {\n      num[num.length - 1] += 1;\n    } else {\n      num[0] = 1;\n    }\n  }\n  return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086504869","body":"821. Shortest Distance to a Character\n### 1. 思路\n- 基础思路\n  - 求数组中两个元素 i, j 的距离: i - j\n- 拓展\n  - 求 i 到左右两边 j、h 的最短距离  \n### 2. 细节\n  - j 的位置未知：\n    - 开一个线性数据结构，记录 j 的位置\n  - 离 i 最近的元素不一定是 j，i 可能还有左相邻、且距离更近的元素 h：\n    - 求最短距离时，比较 Math.min(Math.abs(i - j), Math.abs(i - h))\n  - i - j、i - h，索引不应越界  \n### 3. 复杂度\n- 时间：O(n)\n  - 遍历 s，且遍历内部无 O(n) 及以上层级的操作\n- 空间：O(n)\n  - 新开了 resultArr 数组\n\n```javascript\nvar shortestToChar = function(s, c) {\n  const cHash = new Array(s.length).fill(0);\n  let cHashStart = 0;\n  const resultArr = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      cHash[cHashStart] = i;\n      cHashStart++;\n      resultArr[i] = 0;\n    }\n  }\n  cHashStart = 0;\n  cHashPrev = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (i !== cHash[cHashStart]) {\n      cHashPrev = cHashStart > 0 ? cHashStart - 1 : 0;\n      const shortestGap = Math.min(\n        Math.abs(cHash[cHashPrev] - i),\n        Math.abs(cHash[cHashStart] - i)\n      );\n      resultArr[i] = shortestGap;\n    } else {\n      cHashStart++;\n    }\n  }\n  return resultArr;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086889454","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.pop() || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (this.stack[i]) { this.stack[i] += val; }\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n### Complexity\n- time\n  - inc: O(n), pop/push: O(1)\n- space\n  - O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1088540976","body":"## 394. 字符串解码\r\n## 思路\r\n- 用栈来处理嵌套字符串：以 3[a2[c]] 为例\r\n  - 遇到 [ ，入栈括号外层字符串、及外层字符串的重复次数\r\n  - 遇到 ] ，出栈顶层字符串、重复次数；生成新的当前层字符串\r\n    > 当前字符串 = 栈顶字符串 + 重复后的括号内层字符串\r\n  - 遇到数字，并入当前层重复次数\r\n  - 遇到字母，并入当前层字符串\r\n\r\n## 复杂度\r\n- 时间 O(N)\r\n- 空间 O(N)  \r\n## 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n  let times = 0;\r\n  let timesStack = [];\r\n  let nestedStrStack = [];\r\n  let temp = '';\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i];\r\n    const charIsNum = char * 1;\r\n    if (charIsNum >= 0) {\r\n      times = times * 10 + charIsNum;\r\n      continue;\r\n    }\r\n    if (char === '[') {\r\n      nestedStrStack.push(temp);\r\n      temp = '';\r\n      timesStack.push(times);\r\n      times = '';\r\n      continue;\r\n    }\r\n    if (char === ']') {\r\n      temp = nestedStrStack.pop() + temp.repeat(timesStack.pop());\r\n      continue;\r\n    }\r\n    temp += char;\r\n  }\r\n  return temp;\r\n};\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088214516","body":"## 232. 用栈实现队列\n\n## 思路\n- 基本思路\n  - 问题：删除数组开头元素，时间复杂度相对较高\n  - 解决办法：用两个栈实现队列\n- 两个栈实现队列细节\n  - 栈 2、栈 1 的作用\n    - 栈 1 用于入栈，栈 2 用于出栈\n  - 栈 2 、栈 1 的关系\n    - 栈 2 即倒过来的栈 1：栈 1 最前面的元素，会被推到栈 2 末尾\n  - 栈 2 和栈 1 联合，对消减时间复杂度的贡献\n    - 删除栈 1 的开头元素，即变为删除栈 2 的末尾元素，O(N) => O(1)\n\n## 复杂度\n- 空间复杂度 O(N)\n- 时间复杂度\n  - 摊还时间复杂度 O(1)\n    - 最坏情况 O(N)：栈 2 为空，需要 for loop 挤压栈 1 时 \n    - 最好情况 O(1)\n\n## 摊还分析\n- 摊还分析的核心\n  - 高频次操作的时间复杂度小 + 低频次操作的时间复杂度高，二者均摊了每次操作的代价\n  - 即，每 n 次入队才能产生一次代价为 n 的出队操作\n- 所有操作的总时间复杂度\n  >  O(2N) = n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）\n- 综上所述，每次操作的平均时间复杂度为 O(2N/2N)=O(1)\n\n## 代码\n```\nvar MyQueue = function() {\n  this.queue1 = [];\n  this.queue2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.queue1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  this.cleanQ1();\n  return this.queue2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  this.cleanQ1();\n  return this.queue2[this.queue2.length - 1];\n};\n\nMyQueue.prototype.cleanQ1 = function() {\n  if (this.queue2.length === 0) {\n    const q1Len = this.queue1.length;\n    for (let i = 0; i < q1Len; i++) {\n      this.queue2.push(this.queue1.pop());\n    }\n  }\n}\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.queue1.length === 0 && this.queue2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090014593","body":"## 769. Max Chunks To Make Sorted\r\n\r\n## 思路\r\n- 基本思路\r\n  - 何时满足分区条件\r\n    - 下一个分区中的所有数字 >= 上一个分区的最大值    \r\n      > 数组遍历中的当前元素 >= 上一个分区的最大值\r\n  - 如何存储上一个分区的最大值\r\n    - 维护一个单调递增栈，栈顶即为上一个分区的最大值  \r\n- 实现：遍历数组 + 单调栈 \r\n  - 满足分区条件时 (当前元素 >= 栈顶元素）\r\n    - 将当前元素压入单调栈中\r\n  - 不满足分区条件时（当前元素 < 栈顶元素）\r\n    - 需将之前的分区和当前元素合为一个新的分区：\r\n      - 保存栈顶元素 stackTop（上一个分区中的最大值）\r\n      - 将单调栈中大于当前元素的元素出栈，直到当前元素 >= 栈顶元素\r\n      - 将已保存的栈顶元素 stackTop 压入单调栈中\r\n- 数组能分成的最多块数量\r\n  - 单调栈中的元素个数，即每一分区的最大值\r\n\r\n## 复杂度\r\n- 空间： O(N)\r\n- 时间： O(N)\r\n  - 为数不多的最坏情况下，while 内部的运行次数也无法达到 O(N)  \r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  const stack = [arr[0]];\r\n  for (let i = 1; i < arr.length; i++) {\r\n    const stackTop = getStacktop(stack);\r\n    if (arr[i] >= stackTop) { // 满足条件，找到新的分区\r\n      stack.push(arr[i]);\r\n      continue;\r\n    }\r\n    while (stack.length && arr[i] < getStacktop(stack)) {\r\n      stack.pop(); // 将大于当前元素的所有元素出栈\r\n    }\r\n    stack.push(stackTop); // \r\n  }\r\n  return stack.length;\r\n};\r\n\r\nvar getStacktop = function(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091769680","body":"## 61. 旋转链表\r\n\r\n## 思路\r\n- 向右旋转链表  \r\n=> 1. 使旧链表首尾相连  \r\n=> 2. 遍历到旋转后的链表尾节点 t （第 n - k % n 个节点）     \r\n=> 3. 存储新链表首节点 res = t.next    \r\n=> 4. 切开环型链表 delete t.next  \r\n\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(1)\r\n\r\n## 代码\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!k || !head?.next) {\r\n        return head;\r\n    }\r\n    // 存储链表尾部，链表长度\r\n    let n = 1;\r\n    let tail = head;\r\n    while (tail.next) {\r\n      n++;\r\n      tail = tail.next;\r\n    }\r\n    \r\n    // 计算旋转后链表尾节点的位置\r\n    let rotatedEndDistance = n - k % n;\r\n    if (rotatedEndDistance === n) {\r\n        return head;\r\n    }\r\n\r\n    // 连接链表首尾\r\n    tail.next = head;\r\n\r\n    // 找到旋转后链表尾节点的位置\r\n    while (rotatedEndDistance) {\r\n      tail = tail.next;\r\n      rotatedEndDistance--;\r\n    }\r\n\r\n    // 存储旋转后链表头节点的位置\r\n    const res = tail.next;\r\n    // 切断前述尾节点和新头节点的连接\r\n    tail.next = null;\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092869447","body":"## 24. 两两交换链表中的节点\r\n## 思路\r\n- 两两交换，实际有三个节点在动态变化：\r\n- 实现\r\n   - 设置头中、尾、节点\r\n   - 修改头、中、尾三个节点的 next \r\n   - 更新头、尾节点的位置\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(1)\r\n\r\n## 代码\r\n```javascript\r\nconst swapPairs = (curr) => {\r\n  const res = new ListNode(0);\r\n  res.next = curr;\r\n  let head = res;\r\n  while (curr?.next) {\r\n    const tail = curr.next;\r\n    curr.next = tail.next;\r\n    tail.next = curr;\r\n    head.next = tail;\r\n\r\n    head = curr;\r\n    curr = curr.next;\r\n  }\r\n  return res.next;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094033202","body":"## 109. 有序链表转换二叉搜索树\r\n## 思路\r\n- 将链表转化成数组后，不断寻找数组的中间元素，再依此反复分配左右子树\r\n\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n  const linkedListArr = [];\r\n  while (head) {\r\n    linkedListArr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  \r\n  return formBST(0 , linkedListArr.length - 1, linkedListArr);\r\n};\r\n\r\nconst formBST = (start, end, arr) => {\r\n  if (start > end) {\r\n    return null;\r\n  }\r\n  const mid = (start + end) >>> 1;\r\n  const root = new TreeNode(arr[mid]);\r\n  root.left = formBST(start, mid - 1, arr);\r\n  root.right = formBST(mid + 1, end, arr);\r\n  return root;\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095207543","body":"## 142. 环形链表 II\n## 思路\n- 链表是否有环\n  - slow、fast 指针可相遇，说明链表有环\n- 如何寻找环的入口\n  - 从头节点发出一个指针，再从 slow、fast 相遇节点发出一个指针\n  - 两个指针不断往前走（每次走一个节点）\n  - 两个指针在环的入口相遇\n<img width=\"389\" alt=\"image\" src=\"https://user-images.githubusercontent.com/51183663/162776567-24f7b0e2-5cac-46df-a711-e0069299d62f.png\">\n\nslow pointer moved steps * 2 = fast pointer moved steps\n```\n(x + y) * 2 = x + y + n(y + z)\nx = n(y + z) - y\nx = (n - 1)(y + z) + z\n```\n> 从相遇点到入环点的距离 z，加上 n-1 圈的环长(y + z)，等于从链表头部到入环点的距离 x\n\n\n## 复杂度\n- 时间：O(N)\n- 空间：O(1)\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    var slow = head;\n    var fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (fast == slow) {\n            var cycleFinder = head;\n            while (slow != cycleFinder) {\n                slow = slow.next;\n                cycleFinder = cycleFinder.next;\n            }\n            return cycleFinder;\n        }\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096791125","body":"## LRU\r\n## 基本思路\r\n- 查询/修改过的节点，要提前到头部\r\n  - 哈希查询 O(1)\r\n  - 链表查询 O(N), 头部增删 O(1)\r\n  - 综上，哈希表用于存放节点地址，链表用于修改节点\r\n\r\n## 复杂度\r\n- 时间：O(1)\r\n- 空间：O(capacity) \r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.cacheMap = {};\r\n    this.linkedList = new DLinkedList(capacity);\r\n};\r\n\r\nvar Node = function(key, value) {\r\n    this.prev = null;\r\n    this.next = null;\r\n    this.key = key;\r\n    this.value = value;\r\n}\r\n\r\nvar DLinkedList = function(capacity) {\r\n    this.front = new Node();\r\n    this.rear = new Node(); \r\n    this.front.next = this.rear;\r\n    this.rear.prev = this.front;\r\n    this.capacity = capacity;\r\n    this.size = 0;\r\n};\r\n\r\nDLinkedList.prototype.addFront = function(node) {\r\n    node.prev = this.front;\r\n    node.next = this.front.next;\r\n    this.front.next.prev = node;\r\n    this.front.next = node;\r\n};\r\n\r\nDLinkedList.prototype.moveToFront = function(node) {\r\n    this.deleteNode(node);\r\n    this.addFront(node);\r\n};\r\n\r\nDLinkedList.prototype.deleteNode = function(node) {\r\n    node.next.prev = node.prev;\r\n    node.prev.next = node.next;\r\n};\r\n\r\nDLinkedList.prototype.deleteRear = function() {\r\n    var rear = this.rear.prev;\r\n    this.deleteNode(rear);\r\n    return rear;\r\n};\r\n\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    var node = this.cacheMap[key];\r\n    if (node) {\r\n        this.linkedList.moveToFront(node);\r\n        return node.value;\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    var node = this.cacheMap[key];\r\n    if (node) {\r\n        node.value = value;\r\n        this.linkedList.moveToFront(node);\r\n    } else {\r\n        var newNode = new Node(key, value);\r\n        this.linkedList.addFront(newNode);\r\n        this.cacheMap[key] = newNode;\r\n        if (this.linkedList.size == this.linkedList.capacity) {\r\n            var rear = this.linkedList.deleteRear();\r\n            delete this.cacheMap[rear.key];     \r\n        } else {\r\n            this.linkedList.size++;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097494633","body":"## 104. 二叉树的最大深度\r\n## 复杂度\r\n- 时间：O(N) \r\n  - n 二叉树节点个数\r\n  - 每个节点在递归中只被遍历一次\r\n- 空间：O(height)\r\n  - height 二叉树高度\r\n  - 递归函数需要栈空间，而栈空间取决于递归的深度\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if (root === null) return 0;\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099295309","body":"## 100. 相同的树\r\n## 复杂度\r\n- 时间：O(min(m, n))\r\n- 空间：O(min(m, n))\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (!p && !q) return true;\r\n    if (!p || !q) return false;\r\n    if (p.val !== q.val) return false;\r\n    \r\n    return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100191937","body":"## 129. 求根到叶子节点数字之和\r\n## 思路\r\n- DFS\r\n  - 递归停止：root 左、右节点皆空\r\n\r\n## 复杂度\r\n- 压栈 curr 数组、计算 curr 数组导致不必要的空间和时间开销，需要优化\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar sumNumbers = function(root) {\r\n  return new SumNumbers(root).sumNumbers();\r\n};\r\n\r\nclass SumNumbers {\r\n  constructor(root) {\r\n    this.root = root;\r\n    this.result = 0;\r\n  }\r\n\r\n  sumNumbers() {\r\n    this.sumRecurr(this.root, []);\r\n    return this.result;\r\n  }\r\n\r\n  sumRecurr(root, curr) {\r\n    curr.push(root?.val);\r\n    if (!root.left && !root.right) {\r\n      this.result += this.calcSum(curr);\r\n      return;\r\n    }\r\n    if (root.left) this.sumRecurr(root.left, [...curr]);\r\n    if (root.right) this.sumRecurr(root.right, [...curr]);\r\n  }\r\n\r\n  calcSum(arr) {\r\n    let res = 0;\r\n    let len = arr.length;\r\n    while (arr.length) {\r\n      res += arr.pop() * (10 ** (len - arr.length - 1));\r\n    }\r\n    return res;\r\n  }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100681166","body":"## 513. 找树左下角的值\r\n## 思路\r\n- DFS + 前序遍历\r\n  - 因此最底层、最左边节点，即第一个遇到的最底层节点\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar findBottomLeftValue = function(root) {\r\n  if (!root.left && !root.right) {\r\n    return root.val;\r\n  }\r\n  return new FindBottomLeftValue(root).findBottomLeftValue();\r\n};\r\n\r\nclass FindBottomLeftValue {\r\n  constructor(root) {\r\n    this.root = root;\r\n    this.depth = 0;\r\n    this.leftValue = Infinity;\r\n  }\r\n\r\n  findBottomLeftValue() {\r\n    this.findBottomLeftValueRecurr(this.root, 0);\r\n    return this.leftValue;\r\n  }\r\n\r\n  findBottomLeftValueRecurr(root, depth) {\r\n    if (!root.left && !root.right) {\r\n      if (depth > this.depth) {\r\n          this.depth = depth;\r\n          this.leftValue = root.val;\r\n      }\r\n      return;\r\n    }\r\n    if (root.left) {\r\n      this.findBottomLeftValueRecurr(root.left, depth+1);\r\n    }\r\n    if (root.right) {\r\n      this.findBottomLeftValueRecurr(root.right, depth+1);\r\n    }\r\n  }\r\n}\r\n```  \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100816124","body":"## 297. 二叉树的序列化与反序列化\r\n\r\n## 题意\r\n题目话有点多，简述一下题意\r\n  - serialize(binary tree A) => string A\r\n  - deserialize(string A) => binary tree A\r\n\r\n## 思路\r\n- 序列化：DFS + 先序遍历，构建当前树的字符串\r\n  - 细节：null 节点，也要在字符串中占位\r\n- 反序列化：字符串拆成数组后，按照先序遍历的顺序，构建二叉树\r\n  - 每次从数组中剔除首节点：\r\n  - 遇 null 字符串，返回 null\r\n  - 遇数字字符串，构建树\r\n\r\n## 改进\r\n- 时间复杂度高\r\n  - 上述思路，每次从字符串数组中剔除首节点，时间复杂度高 O(N)\r\n- 如何改进\r\n  - 序列化时反着来，原本二叉树字符串的构建顺序为「中、左、右」，改为「右、左、中」\r\n  - 反序列化时，不剔除首节点，反过来剔除尾节点（时间复杂度为 O(1)\r\n\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)\r\n  \r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nconst serialize = (root) => {\r\n  if (root == null) {\r\n    return 'n';\r\n  }\r\n  return serialize(root.right) + ',' + serialize(root.left) + ',' + root.val; \r\n};\r\n\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\n\r\nvar deserialize = (data) => {\r\n  let list = data.split(',');\r\n\r\n  const buildTree = () => {   \r\n    const val = list.pop();\r\n    if (val === 'n') {\r\n      return null;\r\n    }\r\n    const root = new TreeNode(+val); \r\n    root.left = buildTree();       \r\n    root.right = buildTree();       \r\n    return root;                       \r\n  };\r\n\r\n  return buildTree(); \r\n};\r\n\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102529635","body":"## 1. Two Sum\r\n\r\n## Solution 1: hash map\r\n### Iteration\r\n- Use a hash map to store the index of each element and their substrahend. \r\n- If the substrahend of each element is alreay stored in our hash map, we get the answer\r\n### Complexity\r\n- time: O(n)\r\n- space: O(n)\r\n### Code\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function(nums, target) {\r\n  const sumCache = {};\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const currNum = nums[i];\r\n    const targetMinus = target - currNum;\r\n    if (sumCache[targetMinus] !== undefined) {\r\n      return [sumCache[targetMinus], i];\r\n    }\r\n    sumCache[currNum] = i;\r\n  }\r\n  return [];\r\n};\r\n```\r\n\r\n## Solution 2: Two Pointer\r\n### Set up\r\n- make sure the given array is sorted\r\n- set up two pointers that are at the two ends of the sorted array (right end, left end)\r\n### Iteration\r\n- iterate the sorted array, sum the values at the two pointers\r\n  - sum == target\r\n    - return [left, right]\r\n  - sum > target\r\n    - move the right pointer one step to the left side \r\n    - REASON: this will reduce the next sum, coz the array is sorted from left to right, aka smallest to largest\r\n  - sum < target\r\n    - move the left pointer one step to the right side\r\n\r\n### Complexity\r\n- time: O(n)\r\n- space: O(n)\r\n### Code\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function(nums, target) {\r\n  const iterNums = nums.slice();\r\n  iterNums.sort((a, b) => a - b);\r\n\r\n  let l = 0, r = nums.length - 1;\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const left = iterNums[l];\r\n    const right = iterNums[r];\r\n    const currSum = left + right;\r\n    if (currSum === target) { // at most happened once\r\n      const ans = [];\r\n      for (let j = 0; j < nums.length; j++) {\r\n        if (nums[j] === left || nums[j] === right) ans.push(j);\r\n      }\r\n      return ans;\r\n    }\r\n    currSum < target ? l++ : r--;\r\n  }\r\n  return [];\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103493802","body":"## 347. top-k-frequent-elements\r\n## Solution\r\nHash + Sort\r\n## Complexity\r\n- Time: O(nlogn) for sort()\r\n- Space: O(N)\r\n## Code\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar topKFrequent = function(nums, k) {\r\n  const hash = {};\r\n  for (n of nums) {\r\n    if (!hash[n]) hash[n] = 0;\r\n    hash[n] += 1;\r\n  }\r\n  const hashArr = Object.keys(hash);\r\n  if (hashArr.length === k) return hashArr; // for nums like [1,1,1,1,1,2,2,2,2] 2, no need to sort for inputs like this\r\n  return hashArr.sort((a, b) => hash[b] - hash[a]).filter((n, i) => i + 1 < k);\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105356254","body":"```javascript\r\nvar numberOfBoomerangs = function(points) {\r\n    let count = 0;\r\n    \r\n    for (const p1 of points) {\r\n      const hash = new Map();\r\n      for (const p2 of points) {\r\n        if (p1 === p2) continue;\r\n        const distance = Math.pow(p1[0] - p2[0], 2) +  Math.pow(p1[1] - p2[1], 2);\r\n        const distcache = hash.get(distance);\r\n        hash.set(distance, distcache ? distcache + 1 : 1);\r\n      }\r\n      for (const [dist, amount] of hash) {\r\n        count += amount * (amount - 1); // permutation, A(n, 2) = n!/(n-2)! = n * (n - 1);\r\n      } \r\n    }\r\n    \r\n    return count;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106650721","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLongestSubstring = function (s) {\r\n\tlet l = 0; \r\n\tlet res = 0; \r\n\tlet hash = {};\r\n\tfor (let r = 0; r < s.length; r++) {\r\n           const str = s[r];\r\n           if (hash[str] >= l) l = hash[str] + 1;\r\n\t   res = Math.max(res, r - l + 1);\r\n\t   hash[str] = r; \r\n\t}\r\n\treturn res;\r\n};\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107472504","body":"## 30. substring-with-concatenation-of-all-words\r\n## Solution: hash\r\n> To make this question a bit easier, we can first transform the input string into something more friendly for data handling —— hash map   \r\nAs the output order is not important, I will use hash maps here.\r\n- Transform「words」into a hash map A\r\n- Split the input string into substrings and store each word of the substrings in hash map B\r\n- Match hash map A and B\r\n  - if matched, store the index of each substring's first letter\r\n\r\n## Complexity\r\n- time: O(n^2)\r\n- space: O(n)\r\n```typescript\r\nfunction findSubstring(s: string, words: string[]): number[] {\r\n  return findMatchedIndexes(s, words);  \r\n};\r\n\r\nconst findMatchedIndexes = (s: string, words: string[]) => {\r\n  const wordLen = words[0].length;\r\n  const tot = words.length * wordLen;\r\n  const wordCounts = countWords(words);\r\n  const matchedIndexes = [];\r\n  for (let i = 0; i + tot <= s.length; i++) {\r\n    const substringHash = splitSubstringToHash(s.substr(i, tot), wordLen);\r\n    if (isHashMatch(substringHash, wordCounts)) {\r\n      matchedIndexes.push(i);\r\n    }\r\n  }\r\n  return matchedIndexes;\r\n};\r\n\r\nconst splitSubstringToHash = (substring: string, wordLen: number) => {\r\n  const sHash = {};\r\n  for (let j = 0; j < substring.length; j=j+wordLen) {\r\n    let substrWord = substring.substr(j, wordLen);\r\n    if (sHash[substrWord]) {\r\n      sHash[substrWord]++;\r\n    } else {\r\n      sHash[substrWord] = 1;\r\n    }\r\n  }\r\n  return sHash;\r\n}\r\n\r\nconst isHashMatch = (hashA: object, hashB: object): boolean => {\r\n  const Akeys = Object.keys(hashA);\r\n  const Bkeys = Object.keys(hashB);\r\n  if (Akeys.length !== Bkeys.length) return false\r\n  let isMatching = true;\r\n  Akeys.find((aKey: string) => {\r\n    if (!hashB[aKey] || hashB[aKey] !== hashA[aKey]) {\r\n      isMatching = false;\r\n      return true;\r\n    }\r\n  })\r\n  Bkeys.find((bKey: string) => {\r\n    if (!hashA[bKey] || hashB[bKey] !== hashA[bKey]) {\r\n      isMatching = false;\r\n      return true;\r\n    }\r\n  })\r\n  return isMatching;\r\n};\r\n\r\nconst countWords = (words: string[]) => {\r\n  const wordsHash = {};\r\n  words.forEach((word: string) => {\r\n    if (wordsHash[word]) {\r\n      wordsHash[word]++;\r\n    } else {\r\n      wordsHash[word] = 1;\r\n    }\r\n  })\r\n  return wordsHash;\r\n};\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108505793","body":"```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar middleNode = function(head) {\r\n  let iter = head;\r\n  let len = 0;\r\n  while (iter) {\r\n    len += 1;\r\n    iter = iter.next;\r\n  }\r\n  let index = 0;\r\n  let terminor = len >>> 1;\r\n  while (index < terminor) {\r\n    index++;\r\n    head = head.next;\r\n  }\r\n  return head;\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109450418","body":"```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar removeDuplicates = function(nums) {\r\n    var nonDuplicateIndex = 0;\r\n    for (let i = 0; i < nums.length; i++) {\r\n      if (i === 0 || nums[i] !== nums[i - 1]) {\r\n        nums[nonDuplicateIndex] = nums[i];\r\n        nonDuplicateIndex++;\r\n      }\r\n    }\r\n    return nonDuplicateIndex;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110953780","body":"```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\n\r\nvar searchInsert = function(nums, target) {\r\n    const len = nums.length;\r\n    let l = 0, r = len - 1, ans = len;\r\n    while (l <= r) {\r\n        let mid = ((r - l) >> 1) + l;\r\n        if (target <= nums[mid]) {\r\n            ans = mid;\r\n            r = mid - 1;\r\n        } else {\r\n            l = mid + 1;\r\n        }\r\n    }\r\n    return ans;\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111971136","body":"## Code\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar maxSlidingWindow = function(nums, k) {\r\n  const q = [];\r\n  const res = [];\r\n  for (let i = 0; i < nums.length; i++) { // move the sliding window to the right hand side\r\n    // kick out the last element of our current queue: when the last one is smaller than the iterating element, that means the last element is impossible to be the biggest number\r\n    while (q.length && nums[i] >= nums[q[q.length - 1]]) {\r\n      q.pop();\r\n    }\r\n\r\n    // push the index of the iterating element into our queue \r\n    q.push(i);\r\n\r\n    // adjust our sliding window——kick out the top element from our queue: index of the top element in our queue <= index of the leftmost element of our sliding window\r\n    while (q[0] <= i - k) {\r\n      q.shift();\r\n    }\r\n\r\n    // i >= k - 1 ，we reached the target sliding window size，push the largest number of the current sliding window to our answer array\r\n      if (i >= k - 1) res.push(nums[q[0]]);\r\n  }\r\n  return res;\r\n};\r\n```\r\n## Complexity\r\n- Time：O(N)\r\n- Space：O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113241529","body":"## 997. Find the Town Judge\r\n## Solution\r\n- The key to solve this problem is to focus on the two conditions: \r\n  - The town judge trusts nobody.\r\n  - Everybody (except for the town judge) trusts the town judge.\r\n- We will build two arrays to record how people trust others and how they are trusted by others. If someone is the judge:\r\n  - that person will have n - 1 people that trust him/her.\r\n  - that person will trust 0 others. \r\n\r\n## Complexity\r\n- Time：O(N)\r\n- Space: O(N)\r\n## Code\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @param {number[][]} trust\r\n * @return {number}\r\n */\r\nvar findJudge = function(n, trust) {\r\n    const trustedByOthersCount = new Array(n + 1).fill(0);\r\n    const trustOthersCount = new Array(n + 1).fill(0);\r\n    for (const trustInfo of trust) {\r\n      ++trustOthersCount[trustInfo[0]];\r\n      ++trustedByOthersCount[trustInfo[1]];\r\n    }\r\n\r\n    for (let i = 1; i <= n; i++) {\r\n      if (trustedByOthersCount[i] === n - 1 && trustOthersCount[i] === 0) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"divingcub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938282","body":"## Idea\r\nBackward iteration, 考虑位进.\r\n\r\n## Code \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> sum = new ArrayList<Integer>();\r\n        int length = num.length;\r\n        num[length - 1] += k;\r\n        for (int i = length - 1; i > 0; i--) {\r\n            int curNum = num[i];\r\n            if (curNum > 9) {\r\n                num[i - 1] += curNum / 10;\r\n                num[i] %= 10;\r\n            }\r\n            sum.add(num[i]);\r\n        }\r\n        do {\r\n            sum.add(num[0] % 10);\r\n            num[0] /= 10;\r\n        } while (num[0] > 0);\r\n        Collections.reverse(sum);\r\n        return sum;\r\n    }\r\n}\r\n\r\n## Complexity\r\nTime:O(n)\r\nSpace: O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087690980","body":"## 思路\n\n遇见非 ']' 都直接进行进栈操作，见 ']' 则进行扫描栈内，和上面一个匹配 ']' 的 '['，然后统计出匹配括号内的所有字符，接着将 匹配到 '[' 最近的数字出栈，然后再按照数字倍数 重新将统计到的字符进行进栈操作，最后只要依次出战所有元素。\n\n##代码\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c == ']'){\n          \n                StringBuilder temp = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    temp.insert(0,stack.pop());\n                }\n            \n                String tempString = temp.toString();\n                stack.pop();\n            \n                temp = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    temp.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(temp.toString());\n              \n                while(count > 0){\n                    for(char ch : tempString.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }else{\n            \n                stack.push(c);\n            }\n        }\n    \n        StringBuilder ans = new StringBuilder();\n        while(!stack.isEmpty()){\n            ans.insert(0,stack.pop());\n        }\n        return ans.toString();\n    }\n}\n\n\n##复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088900557","body":"## 思路部分\n\n双栈实现的思想\n\n## 代码实现部分\n\n```\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        stack1.push(x);\n        while (!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n\n    public int pop() {\n        return stack1.pop();\n    }\n\n    public int peek() {\n        return stack1.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n## 复杂度\n\n1. O(N)  -- 时间复杂度\n2. O(N) --  空间复杂度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090437546","body":"## idea\n\n要计算分割点位置用于唯一确定分块, 其中分割点右端点是从左到右遍历需要确定的.\n\n分割点很显然 分割点左边都比分割点右边的值小, 这样排序完成才会有序, 所以需要设计一个前缀数组记录左侧最大值信息,记录范围为[0,index]. 使用后缀数组记录右侧最小值信息, 范围为(index,arr.length).\n如果满足左侧最大值小于右侧最小值, 显然是一个分割点, 记录即可.\n\n## Code\n\n```java\nclass Solution {\n\n \n    public int maxChunksToSorted(int[] arr) {\n        if(arr.length==1)\n            return 1;\n        int[] prefix=new int[arr.length];\n        int[] suffix=new int[arr.length];\n\n        prefix[0]=arr[0];\n        suffix[arr.length-1]=Integer.MAX_VALUE;\n        for(int i=1;i<arr.length;i++){\n            prefix[i]=Math.max(prefix[i-1],arr[i]);\n            suffix[arr.length-i-1]=Math.min(suffix[arr.length-i],arr[arr.length-i]);\n        }\n        int ans=0;\n        for(int i=0;i<arr.length;i++){\n            if(prefix[i]<=suffix[i]){\n                ans++;\n            }\n        }\n        return ans;\n\n    }\n}\n\n\n```\n\n## Complexity\n\n时间复杂度:O(N)\n 空间复杂度:O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091902653","body":"## idea\r\n首尾相连，循环 length - (k % length）的次数，利用新尾部打断点。\r\n\r\n## code\r\n```\r\npublic ListNode rotateTRight(ListNode head, int k){\r\n  \r\n  if(head == null || head.next == null || k ==0) return head;\r\n  \r\n  ListNode tem = head;\r\n  int count = 1;\r\n \twhile(tem.next != null){\r\n  \ttem = tem.next;\r\n    count ++ ;\r\n  }\r\n  \t\r\n  \tk = k% count;\r\n  \r\n  if(k == 0) return head;\r\n  \r\n   tem.next =head;\r\n  \r\n  for(i=0; i<count-k; i++){\r\n    \r\n    tem = tem.next;\r\n    \r\n  }\r\n  \r\n  ListNode latestHead = tem.next;\r\n  tem.next = null;\r\n  return latestHead;\r\n  \r\n}\r\n\r\n```\r\n\r\n## Complexity\r\n时间复杂度 O(n)\r\n空间复杂度O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094162872","body":"## idea \n跑两次，相交会出交点的\n\n##Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n     \n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n      \n        while(pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n## Complexity\nTime (Max(m,n))\nSpace O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098294063","body":"``` \r\nclass Solution{\r\n\r\n        public boolean isSameTree(TreeNode p, Tree q){\r\n\r\n\tif( p == null && q == null) return true;\t\r\n\r\n\tif(q ==null || p ==null) return false;\r\n\r\n\tif(p.val != q.val) return false;\r\n\r\n\t  return isSameTree(p.right, q.right) && isSameTree(p.left, q.left);\t\r\n\t\r\n}\r\n}\r\n```\r\n\r\nComplexity:\r\n\r\n\r\n\r\nTime complexity : O(N)\\mathcal{O}(N)O(N), where N is a number of nodes in the tree, since one visits each node exactly once.\r\n\r\nSpace complexity : O(log⁡(N))\\mathcal{O}(\\log(N))O(log(N)) in the best case of completely balanced tree and O(N)\\mathcal{O}(N)O(N) in the worst case of completely unbalanced tree, to keep a recursion stack. \r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101170840","body":"```\nclass Solution {\n    Map<TreeNode, Integer> node2col = new HashMap<>(), node2row = new HashMap<>();\n    Map<Integer, Map<Integer, List<Integer>>> col2row2nodes = new HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> ans = new ArrayList<>();\n        node2col.put(root, 0);\n        node2row.put(root, 0);\n        dfs1(root);\n        dfs2(root);\n        List<Integer> cols = new ArrayList<>(col2row2nodes.keySet());\n        Collections.sort(cols);\n        for (int col : cols) {\n            Map<Integer, List<Integer>> row2nodes = col2row2nodes.get(col);\n            List<Integer> rows = new ArrayList<>(row2nodes.keySet());\n            Collections.sort(rows);\n            List<Integer> cur = new ArrayList<>();\n            for (int row : rows) {\n                List<Integer> nodes = row2nodes.get(row);\n                Collections.sort(nodes);\n                cur.addAll(nodes);\n            }\n            ans.add(cur);\n        }\n        return ans;\n    }\n    // 树的遍历，根据「节点到列」&「节点到行」的映射关系，构造出「从列到行，从行到节点集」的映射关系\n    void dfs2(TreeNode root) {\n        if (root == null) return ;\n        int col = node2col.get(root), row = node2row.get(root);\n        Map<Integer, List<Integer>> row2nodes = col2row2nodes.getOrDefault(col, new HashMap<>());\n        List<Integer> nodes = row2nodes.getOrDefault(row, new ArrayList<>());\n        nodes.add(root.val);\n        row2nodes.put(row, nodes);\n        col2row2nodes.put(col, row2nodes);\n        dfs2(root.left);\n        dfs2(root.right);\n    }\n    // 树的遍历，记录下「节点到列」&「节点到行」的映射关系\n    void dfs1(TreeNode root) {\n        if (root == null) return ;\n        if (root.left != null) {\n            int col = node2col.get(root);\n            node2col.put(root.left, col - 1);\n            int row = node2row.get(root);\n            node2row.put(root.left, row + 1);\n            dfs1(root.left);\n        }\n        if (root.right != null) {\n            int col = node2col.get(root);\n            node2col.put(root.right, col + 1);\n            int row = node2row.get(root);\n            node2row.put(root.right, row + 1);\n            dfs1(root.right);\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105926479","body":"```\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // 哈希集合，记录每个字符是否出现过\n        Set<Character> occ = new HashSet<Character>();\n        int n = s.length();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.remove(s.charAt(i - 1));\n            }\n            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {\n                // 不断地移动右指针\n                occ.add(s.charAt(rk + 1));\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = Math.max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n}\n\n```\n\n复杂度：\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107891667","body":"```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n         ListNode fast = head; \n    ListNode slow = head;\n    \n    while(fast != null && fast.next != null){\n      \tslow = slow.next;\n\t\t\t\tfast = fast.next.next;       \n    }\n    return slow; \n\n    }\n}\n```\n## 复杂度：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111144884","body":"```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int l = 0, r = nums.length;\r\n        while (l < r) {\r\n            int mid = l + r >> 1;\r\n            if (nums[mid] < target) l = mid + 1;\r\n            else r = mid;\r\n        }\r\n        return l;\r\n    }\r\n}\r\n```\r\n时间复杂度; O(logn);\r\n空间复杂度： O(1);\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaru-zhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085944030","body":"# 思路\r\n- 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\r\n- 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        n = len(A)\r\n        ans = []\r\n\r\n        for i in range(n-1, -1, -1):\r\n            total = A[i] + K % 10\r\n\r\n            K //= 10\r\n            \r\n            if total >= 10:\r\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\r\n                K += 1\r\n\r\n            ans.append(total % 10)\r\n            \r\n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\r\n        while K > 0:\r\n            ans.append(K % 10)\r\n            K //= 10\r\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\r\n        return ans[::-1]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086878419","body":"# 思路\r\n前序遍历数组找出与左侧的字母的最短距离，后序遍历数组找出与右侧字母的最短距离，两者取其最小为最终结果。\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = -float(\"inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i \r\n            # i - 负无穷 = 正无穷\r\n            res.append(i - idx)\r\n        idx = float(\"inf\")\r\n        for i in range(len(s) - 1, -1 , -1):\r\n            if s[i] == c:\r\n                idx = i \r\n            res[i] = min(idx - i, res[i])\r\n        return res\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086878823","body":"# 思路\r\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n# 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087655547","body":"# 思路\r\n将数字、字母、[一个一个加入到栈中；\r\n如果遇到],就从栈中取出字母，直到遇到[\r\n将[去掉，然后从栈中取出数字（判断是否为数字，因为可能有多个）\r\n重复这些字母\r\n重复以上\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n# 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088709573","body":"# 思路\r\n采用辅助栈\r\n# 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n```\r\n# 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cshowww":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085951022","body":"## 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for(int i=n-1;i>=0;i--){\n            int sum = k%10 + num[i];\n            k = k/10;\n            if(sum >= 10){\n                sum = sum-10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n\n        while(k > 0){\n            res.add(0,k%10);\n            k = k/10;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661223","body":"## 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int prev = Integer.MIN_VALUE/2;\n        int n = s.length();\n        int ans[] = new int[n];\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n        prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(n)\n\n## 思路\n双指针，两次遍历，一次从头到尾，一次从尾到头。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896699","body":"## 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n\n## 复杂度\n时间： O(1)  \n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086899934","body":"## 思路\n使用栈，遇到‘]’弹出元素，对字母和数字分别转成string和int，然后再运算结果压栈。\n\n## 代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }\n            else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();\n\n                stack.pop();\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(sb.toString());\n\n                while(count > 0){\n                    for(char ch : sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n\n## 复杂度\n空间：O(n)  \n时间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1091866537","body":"## 补卡\n## 代码：\n```\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n```\n\n复杂度：\n时间：O(n)  \n空间：O(n)\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090433524","body":"## 代码\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n```\n\n## 复杂度\n时间、空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091862825","body":"## 思路\n快慢指针\n\n## 代码\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return head;\n        }\n        if(k == 0){\n            return head;\n        }\n        ListNode dummy = head;\n        int len = 0;\n        while(head != null){\n            head = head.next;\n            len++;\n        }\n        int index = k%len;\n\n        ListNode slow = dummy;\n        ListNode fast = dummy;\n        for(int i=0;i<index;i++){\n            fast = fast.next;\n        }\n        ListNode newHead = fast;\n        \n        while(fast.next != null){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        fast.next = dummy;\n        dummy = slow.next;\n        slow.next = null;\n        return dummy;\n       \n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093008712","body":"## 代码：\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094297346","body":"## 代码（以前做过）\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n        while(head1 != head2){\n            head1 = head1==null?headB:head1.next;\n            head2 = head2==null?headA:head2.next;\n        }\n        return head1;\n    }\n}\n```\n\n## 复杂度\n时间：O(A+B)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095210198","body":"## 代码\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode node = findNode(head);\n        if(node == null){\n            return null;\n        }\n\n        int num = 1;\n        \n        for(ListNode cur=node;cur.next!=node;cur=cur.next){\n            num++;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        for(int i=0;i<num;i++){\n            fast = fast.next;\n        }\n\n        \n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n        \n    }\n\n    public ListNode findNode(ListNode head){\n        if(head==null || head.next==null){\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head.next;\n        \n        while(fast!=null && fast.next!=null){\n            if(fast == slow){\n                return slow;\n            }\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return null;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096765015","body":"## 思路\n以前做过\n\n## 代码\n```\nclass ListNode{\n    ListNode prev;\n    ListNode next;\n    int key;\n    int value;\n    public ListNode(int key,int value){\n        this.key = key;\n        this.value = value;\n    }\n}\nclass LRUCache {\n    \n    private int capacity;\n    private ListNode head;\n    private ListNode tail;\n    private Map<Integer,ListNode> map;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.head = new ListNode(-1,-1);\n        this.tail = new ListNode(-1,-1);\n        this.map = new HashMap<>();\n\n        this.tail.prev = head;\n        this.head.next = tail;\n    }\n    \n    public int get(int key) {\n        if(map.get(key) == null){\n            return -1;\n        }\n        else{\n            ListNode node = map.get(key);\n            int value = node.value;\n            moveToTail(node,value);\n            return node.value;\n        }\n    }\n    \n    public void moveToTail(ListNode node,int newValue){\n        deleteNode(node);\n        node.value = newValue;\n        insertToTail(node);\n    }\n\n    public void deleteNode(ListNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    public void insertToTail(ListNode node){\n        tail.prev.next = node;\n        node.prev = tail.prev;\n\n        node.next = tail;\n        tail.prev = node;\n    }\n\n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            moveToTail(map.get(key),value);\n        }\n        else{\n            if(map.size() == capacity){\n                ListNode node = head.next;\n                deleteNode(node);\n                map.remove(node.key);\n            }\n            \n            ListNode node = new ListNode(key,value);\n            insertToTail(node);\n            map.put(key,node);\n            \n        }\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098204036","body":"## 思路\n层序遍历\n\n## 代码\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int res = 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i=0;i<size;i++){\n                TreeNode node = queue.poll();\n                if(node.left!=null){\n                    queue.add(node.left);\n                }\n                if(node.right!=null){\n                    queue.add(node.right);\n                }\n            }\n            res++;\n        }\n        return res;\n    }\n\n}\n\n```\n## 复杂度\n时间and空间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100169988","body":"## 思路\n前序遍历\n\n## 代码\n```\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return preorderSearch(root,0);\n    }\n\n    public int preorderSearch(TreeNode root,int path){\n        if(root == null){\n            return 0;\n        }\n\n        path = path*10 + root.val;\n        if(root.left==null && root.right==null){\n            return path;\n        }\n        return preorderSearch(root.left,path) + preorderSearch(root.right,path);\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100688307","body":"## 思路\nBFS\n\n## 代码\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = [root]\n        ans = root.val\n        while queue:\n            ans = queue[0].val\n            n = len(queue)\n            for i in range(n):\n                node = queue[0]\n                del queue[0]\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans\n\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106531522","body":"## 思路\n去重想到HashSet，字符串问题一般双指针（滑动窗口）\n\n## 代码\n```\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s.length() == 0){\n            return 0;\n        }\n        int left = 0;\n        int right = 0;\n        int n = s.length();\n        int maxLen = 0;\n        HashSet<Character> set = new HashSet<>();\n        for(;right<n;right++){\n            while(set.contains(s.charAt(right))){\n                set.remove(s.charAt(left));\n                left++;\n            }\n            set.add(s.charAt(right));\n            maxLen = Math.max(right-left+1,maxLen);\n        }\n        return maxLen;\n    }\n}\n```\n\n## 复杂度\n时间:O(n)  \n空间:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kesucaso":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085955510","body":"#思路\n\nnum数组中的每个数字与k中的对应位置的数字相加，然后如果对应位置相加大于10，则进位到高位的位置上去。\n\n#代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        for i in range(len(num)-1,-1,-1):\n            n = num[i]+k%10\n            k=k//10\n            if n>=10:\n                ans.append(n%10)\n                k+=1\n            else:\n                ans.append(n)\n        while k>=1:\n            ans.append(k%10)\n            k=k//10\n        return ans[::-1]\n```\n\n#复杂度分析\n\n时间复杂度：O(n) （遍历数组）\n\n空间复杂度：O(n) （返回的数组大小）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661051","body":"# 思路\n\n从后往前遍历，遇到等于C的字符就把pre指针置为当前的索引，然后对答案数组进行修改。再从前往后遍历，也是遇到等于C的字符就把pre指针置为当前的索引，对答案数组修改的时候需要对比刚刚已经修改的值和当前赋的值的中选最小值。\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [0]*len(s)\n        pre = float(\"inf\")\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                pre = i\n            ans[i]=pre-i\n        pre = float(\"-inf\")\n        for i in range(len(s)):\n            if s[i]==c:\n                pre = i\n            ans[i]=min(abs(pre-i),ans[i])\n        return ans\n```\n\n# 复杂度分析\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886054","body":"# 思路\n\n因为栈的大小固定，所以可以根据索引方便定位每个元素。简单模拟就行。\n\n# 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            x = self.stack.pop()\n            return x\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i>=len(self.stack):\n                break\n            else:\n                self.stack[i]+=val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087716035","body":"# 思路\n\n使用栈。如果遇到”[“，那就把之前的字符和数字压入栈中，然后将字符置零，任何遇到”]“就把刚刚存在栈里面的字符加上括号里的字符。依次这样做。\n\n# 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        num = 0\n        ans = \"\"\n        for i in s:\n            if i.isdigit():\n                num = num*10+int(i)\n            elif i==\"[\":\n                stack.append([ans,num])\n                # print(stack)\n                ans = \"\" #保存了之后就清零，开始存储括号里面的字符\n                num = 0\n            elif i==\"]\":\n                content = stack.pop()\n                ans = content[0]+content[1]*ans\n            else:\n                ans+=i\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088876125","body":"# 思路\n\n用两个栈来实现队列。一个栈用来push，一个栈用来pop。\n\n# 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.pushstack = []\n        self.popstack = []\n\n    def push(self, x: int) -> None:\n        self.pushstack.append(x)\n\n    def pop(self) -> int:\n        if self.popstack:\n            ans = self.popstack.pop()\n            return ans\n        while self.pushstack:\n            temp = self.pushstack.pop()\n            self.popstack.append(temp)\n\n        return self.popstack.pop()\n\n    def peek(self) -> int:\n        if self.popstack:\n            ans = self.popstack[-1]\n            return ans\n        while self.pushstack:\n            temp = self.pushstack.pop()\n            self.popstack.append(temp)\n\n        return self.popstack[-1]\n\n    def empty(self) -> bool:\n        return self.pushstack==[] and self.popstack==[]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090384711","body":"# 思路\n\n我们需要的是找出每个排序块中的最大值，如果后序元素不存在比当前最大的元素更小的元素，那么当前的元素就可以分块。利用单调栈来存储最大的元素，并且依次弹出更小的元素。\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] #单调栈\n\n        for i in range(len(arr)):\n            if stack and stack[-1]>arr[i]:\n                max_value = stack.pop() #存排序块中最大的数字\n                #如果出现了比当前更小的数字，插入到栈中合适的位置\n                while stack and stack[-1]>arr[i]:\n                    stack.pop()\n                stack.append(max_value)\n            else:\n                stack.append(arr[i])\n        # print(stack)\n        return len(stack)\n```\n\n# 复杂度\n\n时间：O(n)；空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091892018","body":"- 思路\r\n\r\n先统计链表长度，然后对旋转次数取余数。快指针先走K步，然后慢指针一起走，直到快指针走到链表尾部。慢指针的下一个节点就是新的链表头，然后截断连接上去。\r\n\r\n- 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head==None or k==0 or head.next==None:\r\n            return head\r\n        cur = head\r\n        length = 0\r\n        while cur:\r\n            length+=1\r\n            cur = cur.next\r\n        k = k%length\r\n        if k==0: return head\r\n        fast = head\r\n        for i in range(k):\r\n            fast = fast.next\r\n        slow = head\r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        newhead = slow.next\r\n        slow.next=None\r\n        fast.next=head\r\n        return newhead\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092989882","body":"- 思路\n\n非递归地去交换两个节点。新建一个虚拟头结点，然后依次交换虚拟头结点之后的两个节点，\n\n- 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\n        dummy = ListNode(-1)\n        dummy.next = head\n        temp = dummy\n        while temp.next!=None and temp.next.next!=None:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072465","body":"- 思路\n\n一个函数找中点，一个函数递归构造左右子树。\n\n- 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def findMid(left,right):\n            fast,slow = left,left\n            while fast!=right and fast.next!=right:\n                fast=fast.next.next\n                slow=slow.next\n            return slow\n\n        def bulidTree(left,right):\n            if left==right:\n                return None\n          \n            mid = findMid(left,right)\n            root = TreeNode(mid.val)\n            root.left=bulidTree(left,mid)\n            root.right=bulidTree(mid.next,right)\n            return root\n\n        # root = bulidTree(head,None)\n        return bulidTree(head,None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094228554","body":"<aside>\n💡 双指针。如果链表相交，一个长a一个长b，如果两个指针走到链表结尾就又从另一个链表的头开始移动，那么一定会在a+b相遇。\n\n</aside>\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        curA = headA\n        curB = headB\n        while curA!=curB:\n            curA = curA.next if curA!=None else headB\n            curB = curB.next if curB!=None else headA\n        #如果是没有环的话 curA==curB==None 也会退出循环\n        return curA\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095232748","body":"<aside>\n💡 双指针。如果有环，假设环外长度为a，第一次相遇慢指针在环内走了b，快指针走了b+n*(b+c)，所以(a+b)*2=a+b+(b+c)*n，a=n*(b+c)-b=c+(n-1)*(b+c)；所以在第一次相遇之后，将快指针重新指向链表头部，然后和慢指针同步走，相遇的时候则为环开始的节点。\n\n</aside>\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = head\n        fast = head\n        while True:\n            if fast==None or fast.next == None:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n            if slow==fast:\n                break\n\n        fast = head\n        while fast!=slow:\n            fast = fast.next\n            slow = slow.next\n\n        return fast\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096898866","body":"<aside>\n💡 创建链表节点进行模拟。\n\n</aside>\n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098198851","body":"<aside>\n💡 递归。如果节点为空则返回0，否则就+1。时间：O(n)。空间：O(height)。\nBFS。每层的节点存起来，然后进入下一层，就+1的高度。时间：O(n)。空间：O(n)[最坏情况]\n\n</aside>\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root==None:\n            return 0\n        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        int ans = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size > 0) {\n                TreeNode node = queue.poll();\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n                size--;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100677739","body":"<aside>\n💡 BFS。可以每一层一层地遍历，输出最后一层的第一个元素。或者每一层反转着遍历，这样最后的元素就是最后一层最左边的元素了。\n\n</aside>\n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        #bfs\n \n        queue = deque()\n        queue.append(root)\n        while queue:\n            node = queue.popleft()\n            if node.right:\n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n        return node.val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085957096","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int tmp = 0;\n        for(int i = num.size() - 1; i >= 0; i--){\n            tmp = num[i] + k % 10;\n            k /= 10;\n            if(tmp >= 10){\n                tmp = tmp % 10;\n                k++;\n            }\n            res.push_back(tmp);\n        }\n\n        for( ; k > 0; k/=10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088755614","body":"\n```c++\nclass MyQueue {\nprivate:\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        int top_v = s2.top();\n        s2.pop();\n        return top_v;\n    }\n    \n    int peek() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095857165","body":"```c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100148546","body":"```c++\nclass Solution {\nprivate:\n    int res;\n    string path;\n    void traverse(TreeNode* node){\n        if(node == nullptr){\n            return;\n        }\n        path += to_string(node->val);\n        if(node->left == nullptr && node->right == nullptr){\n            res += stoi(path);\n        }\n        traverse(node->left);\n        traverse(node->right);\n\n        path.pop_back();\n    }\npublic:\n    int sumNumbers(TreeNode* root) {\n        traverse(root);\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100690193","body":"```c++\nclass Solution {\npublic:\n    int left, maxDepth = -1;\n    int findBottomLeftValue(TreeNode* root) {\n        dfs(root, 0);\n        return left;\n    }\n\n    void dfs(TreeNode* root, int depth){\n        if(root == nullptr)\n            return;\n        if(depth > maxDepth){\n            left = root->val;\n            maxDepth = depth;\n        }\n        dfs(root->left, depth + 1);\n        dfs(root->right, depth + 1);\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102675710","body":"```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n        for(int i = 0; i < nums.size(); i++){\n            if(map.count(nums[i])){\n                return {map[nums[i]], i};\n            }\n            map[target - nums[i]] = i;\n        }\n        return {};\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103870299","body":"```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        vector<int> res(k, 0);\n        unordered_map<int, int> m;\n        for(auto &num : nums){\n            m[num]++;\n        }\n        priority_queue<pair<int, int>, vector<pair<int, int>>, less<>> q;\n        for(auto node : m){\n            pair<int, int> tmp;\n            tmp = make_pair(node.second, node.first);\n            q.push(tmp);\n        }\n        for(int i = 0;i<k;i++){\n            auto p = q.top();\n            q.pop();\n            res[i] = p.second;\n        }\n        return res;\n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108633000","body":"```c++\n    ListNode* middleNode(ListNode* head) \n    {\n        if(head == NULL)\n            return head;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast != NULL && fast -> next != NULL)\n        {\n            slow = slow -> next;\n            fast = fast -> next -> next;\n        }\n        return slow;\n\t}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109774504","body":"```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for(int i = 1; i < nums.size(); i++){\n            if(nums[k] != nums[i]){\n                nums[++k] = nums[i];\n            }\n        }\n        return k+1;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085962315","body":"##思路\r\nnum从后向前进行运行，每次都用k和对应位置上数字进行相加，若相加结果大于10，则携带进位前往下一位。\r\n如果num结束后，k中仍然剩余部分数字，直接进行求余即可。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans= new ArrayList<>();\r\n        for(int i=num.length-1;i>=0;i--)\r\n        {\r\n            ans.add(0,(num[i]+k)%10);\r\n            k=(k+num[i])/10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            ans.add(0,k%10);\r\n            k=k/10;\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n##复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092934604","body":"**代码**\r\n```\r\npublic ListNode swapPairs(ListNode head) {\r\n         ListNode dummy = new ListNode();  // 哨兵节点\r\n        dummy.next = head;\r\n        ListNode cur = dummy;\r\n        while (cur.next != null && cur.next.next != null) {\r\n            ListNode node1 = cur.next;\r\n            ListNode node2 = cur.next.next;\r\n            cur.next = node2;\r\n            node1.next = node2.next;\r\n            node2.next = node1;\r\n            cur = node1;\r\n        }\r\n        return dummy.next;\r\n    }\r\n```\r\n**复杂度**\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094265311","body":"**思路**\r\n利用set集合中的数据都是唯一的特性，将其中一个链表加入到set中，另一个链表进行遍历，如果set中存在相同的地址则说明存在交点\r\n**代码**\r\n```Java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A=headA;\r\n        ListNode B=headB;\r\n        HashSet<ListNode> set=new HashSet<>();\r\n        while (A!=null)\r\n        {\r\n            set.add(A);\r\n            A=A.next;\r\n        }\r\n        while (B!=null)\r\n        {\r\n            if(set.contains(B))\r\n            {\r\n                return B;\r\n            }\r\n            B=B.next;\r\n        }\r\n        return null;\r\n    }\r\n```\r\n**复杂度**\r\n+ 时间复杂度 \b\bO(n)\r\n+ 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095006917","body":"**思路**\n将Listnode加入到list中，当Listnode为空后，在list中进行查找如果可以查找相同的结点则说明有环。\n**代码**\n```java\npublic ListNode detectCycle(ListNode head) {\n        if(head==null)\n        {\n            return null;\n        }\n        List<ListNode> node=new ArrayList<>();\n        ListNode temp=head;\n        while(temp!=null && node.contains(temp)!=true)\n        {\n            node.add(temp);\n            temp=temp.next;\n        }\n        for(int i=0;i<node.size();i++)\n        {\n            if(node.get(i)==temp)\n            {\n                return temp;\n            }\n        }\n        return null;\n    }\n```\n**复杂度**\n+ 时间复杂度O(n)\n+ 空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085969554","body":"**Thoughts**\nAdding up by digits.\nIn the array, we start from the last element.\nFor the integer k, each time we use the last digit (k % 10),\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\n\n**Code**\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n               k += 1;\n               sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Time Complexity**\nTime: O(N), one for loop\nSpace: O(1), use one arraylist as result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086529915","body":"**Thoughts**\n1. Get all indices of c, go through s to compare i with indices of c\n2. Traverse s from left side and right side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\n\n**Code**\n```jave\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        ArrayList<Integer> list = new ArrayList<>();\n        int[] res = new int[n];\n        int p = 0; \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\n                p++;\n            }\n            res[i] = Math.abs(list.get(p) - i);\n        }\n        return res;\n    }\n```\n**Time Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767250","body":"**Thoughts**\n\nUse an array to simulate the stack, top var to record the index of the top value\nAlso, use another array to record the value needed to be added. Addition only happens with Popping, if PoP() is called, we start from the top value, add stack\\[top] with add\\[top], then we add the val in add\\[top] to the previous one add\\[top - 1], make sure the index in two array are  consistent\n\n**Code**\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0; \n        top--;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0) {\n            add[limit] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**Complexity**\nTime: O(1) for all operations\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086926037","body":"**Thoughts**\n1. Using two stacks to record the number and characters\n2. Traversing s, when it's number(digit), push(c);\n\t\t\twhen it's `[`, save current sb to stack;\n\t\t\twhen it's `]`, do the multiplication;\n\t\t\twhen it's char, append to sb\n\t\t\t\n**Code**\n```java\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        Deque<Integer> stack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        for (Character c: s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                stack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = sbStack.pop();\n                int count = stack.pop();\n                for (int i = 0; i < count; i++) {\n                    tmp.append(sb.toString());\n                }\n                sb = tmp;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087854700","body":"**Thoughts**\nUsing two stacks to stimulate the FIFO sequence, one var to record the front element of the queue\n\n**Code**\n```java\nclass MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n**Complexity**\n* Time: O(1), Push and Pop are constant time\n* Space: O(1) no extra space used","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090286989","body":"**Thoughts**\n\nIf the element in the array is greater then it's following elements, then it's the start of the chunk. So the problem turns into finding such \"start\" of chunks. Use a stack, each time we compare one number with the top of the stack, if !stack.isEmpty() && num < top, we remove the number in the stack which is < num\n\n**Code**\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        for (int num: arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**Complexity**\nTime: O(n)\nSpace: O(n) number of chunks","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091884729","body":"**Thoughts**\n\n1. traverse the list to locate tail of the list\n2. find the node to be the new head\n3. connect the tail and head to make the list a ring\n4. depart the ring at the new head\n\n**Code**\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) {\n            return head;\n        }\n        int n = 0;\n        ListNode tail = null, tmp = head;\n        // to get the length of list, and locate tail node\n        while (tmp = null) {\n            tail = tmp;\n            n++;\n            tmp = tmp.next;\n        }\n        k %= n; // in case k > n\n        ListNode p = head;\n        // locate (n - k)th node \n        for (int i = 0; i < n - k - 1; i++) {\n            p = p.next;\n        }\n        // create a ring, then depart it at p.next, which is the new head\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092862412","body":"**Thoughts**\nUsing dummy head, and keep swapping every two nodes\n\n**Code**\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        while (pre.next != null && pre.next.next != null) {\n            ListNode start = pre.next;\n            ListNode end = pre.next.next;\n            pre.next = end;\n            start.next = end.next;\n            end.next = start;\n            pre = start;\n        }\n        return dummy.next;\n    }\n```\n\n**Complexity**\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093664992","body":"**Thoughts**\n\nSplit the linkedlist intor three parts:\n* the mid node, which will be the root of tree\n* the left part, will be left subtree\n* the right part, will be right subtree\nUse fast and slow pointers to locate the mid point(root), use recursion to genarate left and right subtrees\n\n**Code**\n\n```java\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        } else if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode pre = slow;\n        while (fast != null && fast.next != null) {\n            pre = slow; // pre is the previous node of slow\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.right = sortedListToBST(slow.next);\n        slow.next = null;\n        pre.next = null;\n        root.left = sortedListToBST(head);\n        return root;\n    }\n```\n\n**Complexity**\n\n* Time: O(nlogn), each level traverse n/2, logn is the height of tree\n* Space: O(logN), height of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094284355","body":"**Code**\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return headA == null ? headB : headA;\n        }\n        ListNode pa = headA, pb = headB;\n        while (pa != pb) {\n            pa = pa == null ? headB : pa.next;\n            pb = pb == null ? headA : pb.next;\n        }\n        return pa;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095050636","body":"**Thoughts**\n\nThis is a problem based on judging if a list has cycle, so the first half part would be the same by using fast and slow pointer. If cycle exists, fast pointer will meet slow finally.\n\nSo when fast meet slow, the position is the start of cycle. Use another pointer points to head, and start a loop, when pointer catch slow, return.\n\n**Code**\n```java\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n```\n\n**Complexity**\n* Time:O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095400235","body":"**Thoughts**\nThere would be two data structures, one for saving data, another for tracking the recently used.\n\nFor data store, a hashmap can realize O(1) read and write\nFor tracking, linkedlist is better in add and remove compared with array. \nA doublylinkedlist is better than a single one, we can manage the \"latest\" at head, and least recently used at tail.\n\n**Code**\n```java\nclass LRUCache {\n    class DoublyLinkedNode {\n        int key;\n        int value;\n        DoublyLinkedNode prev;\n        DoublyLinkedNode next;\n        public DoublyLinkedNode() {};\n        public DoublyLinkedNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    Map<Integer, DoublyLinkedNode> cache;\n    DoublyLinkedNode head, tail;\n    private int size, capacity;\n    public LRUCache(int capacity) {\n        cache = new HashMap<Integer, DoublyLinkedNode>();\n        head = new DoublyLinkedNode();\n        tail = new DoublyLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n        size = 0;\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        //1. get value from cache\n        //2. find node in the list\n        //3. remove node and put it to head\n        DoublyLinkedNode tmp = cache.get(key);\n        if (tmp != null) {\n            remove(tmp);\n            addToHead(tmp);\n            return tmp.value;\n        } else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        //1. check cache: if exist, update value\n        //      remove -> addToHead\n        //2. not exist, cache put\n        // size++, check capacity\n        //  if exceed, remove tail\n        DoublyLinkedNode node = cache.get(key);\n        if (node == null) {\n            DoublyLinkedNode cur = new DoublyLinkedNode(key, value);\n            cache.put(key, cur);\n            addToHead(cur);\n            size++;\n            if (size > capacity) {\n                DoublyLinkedNode tail = removeTail();\n                size--;\n                cache.remove(tail.key);\n            }\n        } else {\n            node.value = value;\n            cache.put(node.key, node);\n            remove(node);\n            addToHead(node);\n        }\n    }\n\n    private void remove(DoublyLinkedNode node) {\n        node.next.prev = node.prev;\n        node.prev.next = node.next;\n    }\n\n    private void addToHead(DoublyLinkedNode node) {\n        node.next = head.next;\n        node.prev = head;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private DoublyLinkedNode removeTail() {\n        DoublyLinkedNode node = tail.prev;\n        remove(node);\n        return node;\n    }\n}\n```\n\n**Complexity**\n* Time: O(1) write and read\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098115002","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        int leftMax = maxDepth(root.left);\n        int rightMax = maxDepth(root.right);\n        return Math.max(leftMax, rightMax) + 1;\n\n    }\n}\n```\n\n**Complexity**\nTime: O(n) visit every node once\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098259143","body":"**Thought**\n\nBasic recursion\n\n**Code**\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(min(m, n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099443253","body":"**Thoughts**\nDFS to explore the tree from root to each leaf. If current node is leaf, return the value from root to leaf.\n\n**Code**\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int sum) {\n        if (root == null ) return 0;\n\n        int tmp = sum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return tmp;\n        }\n        return dfs(root.left, tmp) + dfs(root.right, tmp);\n    }\n}\n```\n\n**Complexity**\nTime: O(n) visit every node once\nSpace: O(logn) stack size","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100209970","body":"**Code**\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (i == 0) {\n                    res = node.val;\n                }\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100892202","body":"**Code**\n```java\n\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        return reserialize(root, \"\");\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return redeserialize(dataList);\n    }\n\n    private String reserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = reserialize(root.left, str);\n            str = reserialize(root.right, str);\n        }\n        return str;\n    }\n\n    private TreeNode redeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        } \n\n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = redeserialize(dataList);\n        root.right = redeserialize(dataList);\n\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100933853","body":"```java\n\nclass Solution {\n    Map<TreeNode, int[]> map = new HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int n = list.size();\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < n;) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) {\n                tmp.add(list.get(j++)[2]);\n            }\n            res.add(tmp);\n            i = j;\n        }\n        return res;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) return;\n\n        int[] info = map.get(root);\n        int col = info[0], row = info[1], val = info[2];\n        if (root.left != null) {\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if (root.right != null) {\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101617628","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i])) {\n                return new int[]{i, map.get(target - nums[i])};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1102961936","body":"**Thoughts**\nUse HashMap to count the. frequency each number shows\nUse heap to record the top k\n\n**Code**\n```java\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int[] res = new int[k];\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));\n        for (Integer key: map.keySet()) {\n            if (heap.size() < k) {\n                heap.add(key);\n            } else if (map.get(key) > map.get(heap.peek())){\n                heap.remove();\n                heap.offer(key);\n            }\n        }\n        int idx = k - 1;\n        while (!heap.isEmpty()) {\n            res[idx--] = heap.remove();\n        }\n        return res;\n    }\n}\n```\n\n**Complexity**\nTime: O(nlogn)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104239622","body":"**Thoughts**\nTreat each point as the mid point, and calculate the distance between current point with all other points. Mapping the distance and the counts. Then traverse the keySet of map to get the total count of different pairs(EACH TIME WE SELECT TWO, so it's A(N, 2) = n * (n - 1))\n\n**Code**\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for (int dis: map.keySet()) {\n                int count = map.get(dis);\n                ans += count * (count - 1);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n**Complexity**\nTime: O(n ^ 2)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105872208","body":"**Thoughts**\n1. Use HashMap or array to count the last shown index of character\n2. Two pointers as slide window to traverse the string, each time if we meet a character already in the map, the left pointer moves to the next index of the exist character\n\n**Code**\n```java\n    public int lengthOfLongestSubstring(String s) {\n        if (s.length() == 0 || s == null) {\n            return 0;\n        }\n        int left = 0, max = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (int right = 0; right < s.length(); right++) {\n            if (map.containsKey(s.charAt(right))) {\n                left = Math.max(left, map.get(s.charAt(right)) + 1);\n            }\n            map.put(s.charAt(right), right);\n            max = Math.max(max, right - left + 1);\n        }\n        return max;\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107882349","body":"**Thoughts**\nFast and slow pointers\n\n**Code**\n```java\npublic ListNode middleNode(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1108890607","body":"**Thoughts**\nThe problem requires in-place operation, so we can only change the value in the array.\nUsing two pointer, left points to the index of the end of non-duplicated values, right traverse the array, if it's the same value as left, right moves to the next, if left and right points to different value, left's next value changes to which right points\n\n**Code**\n```java\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int left = 0, right = 0;\n        while (right < nums.length) {\n            if (nums[left] == nums[right]) {\n                right++;\n            } else {\n                // nums[left] != nums[right]\n                left++;\n                nums[left] = nums[right];\n            }\n        }\n        return left + 1;\n    }\n\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111109291","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111453321","body":"**Thoughts**\r\n\r\nUse PriorityQueue to keep track of the maximum in each window, also if the index of the peek value is less then i - k, then we should remove it from the heap\r\n\r\n**Code**\r\n```java\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int n = nums.length;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] != b[0] ? b[0] - a[0] : b[1] - a[1]);\r\n        int[] res = new int[n - k + 1];\r\n        for (int i = 0; i < k; i++) {\r\n            pq.offer(new int[]{nums[i], i});\r\n        }\r\n        res[0] = pq.peek()[0];\r\n        for (int i = k; i < n; i++) {\r\n            pq.offer(new int[]{nums[i], i});\r\n            while (pq.peek()[1] <= i - k) {\r\n                pq.poll();\r\n            }\r\n            res[i - k + 1] = pq.peek()[0];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**Complexity**\r\nTime: O(nlogn), n for the loop, logn for the offer() operation of heap\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112435760","body":"```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegree = new int[n + 1];\n        int[] outDegree = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0];\n            int y = edge[1];\n            ++inDegree[y];\n            ++outDegree[x];\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (inDegree[i] == n - 1 && outDegree[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"antmup":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085970492","body":"### 思路\n1、首先将数组转换为对应的数字；\n2、将两个数字相加；\n3、将最终的数字拆解为数组；\n\n### 代码\n\n``` js\nfunction intSumOfArray(initNumArray, Addend) {\n  // 第一步\n  const initNum = +initNumArray.join('');\n\n  // 第二步\n  const tempSum = String(initNum + Addend);\n  console.log(tempSum, 'tempSum');\n  // 第三步\n  return  tempSum.split('').map(Number);\n}\n\nconsole.log(intSumOfArray([1, 2, 0, 0], 34));\nconsole.log(intSumOfArray([2, 7, 4], 181));\nconsole.log(intSumOfArray([2, 1, 5], 806));\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651757","body":"### 思路\n1、首先找到字符在数组中的下标数组；\n2、先处理第一个字符之前的，以及最后一个字符之后；\n3、如果当前元素等于目标字符，在数组中 push 0；\n4、处理两个字符中间的距离问题；\n\n### 代码\n\n``` js\nfunction beelineOfCharacter(targetString, targetCharacter) {\n  // 判断目标字符是否处在数组字符串的末尾\n  const isEnd = targetString[targetString.length - 1] === targetCharacter;\n  console.log(isEnd);\n\n  // 寻找目标字符在数组当中的位置\n  let targetCharIndex = [];\n  for (let i = 0; i < targetString.length; i++) {\n    if (targetString[i] === targetCharacter) {\n      targetCharIndex.push(i);\n    }\n  }\n  console.log(targetCharIndex, 'targetCharIndex');\n\n  let finalArray = [];\n  for (let j = 0; j < targetString.length; j ++) {\n    const item = targetString[j];\n    console.log(targetString[j], '1111');\n    // 等于目标元素就push0\n    if (item === targetCharacter) {\n      finalArray.push(0);\n    }\n\n    // 处理第一个目标字符之前的元素\n    const firstCharIndex = targetCharIndex[0];\n    if (j < firstCharIndex) {\n      const tempArray = numberToIndex(firstCharIndex);\n      finalArray.concat(tempArray);\n    }\n    \n  }\n  \n}\n\nfunction numberToIndex(number) {\n  let indexArray = [];\n  for (let i = 0; i < number; i++) {\n    indexArray.unshift(i);\n  }\n  indexArray.pop()\n\n  return indexArray;\n}\n\n\nbeelineOfCharacter('acd', 'c')\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090945410","body":"### 思路\n1、首先判断当前的链表长度是否为1，如果是1，直接返回表头就好；\n  2、获取链表的长度；\n  3、制造快慢指针\n\n### 代码\n\n``` js\nfunction fastSlowPointer(head, k) {\n  /*\n    1、判断链表的长度和 k 值是否合法\n  */\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  // 获取链表的长度\n  let linkedListLength = 0;\n  let now = head;\n  while (now) {\n    now = now.next;\n    linkedListLength ++;\n  }\n\n  // 当前的 k 值获取的是链表的第几位\n  k = k % linkedListLength;\n\n  // 制造快慢指针\n  let slow = (fast = head);\n  while(fast.next) {\n    if (k-- <= 0) {\n      // 慢指针\n      slow = slow.next;\n    }\n    // 快指针\n    fast = fast.next;\n  }\n\n  // 开始查数\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  \n  return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092314887","body":"### 思路\n1、保证两个节点的交换；\n  2、其余节点的交换两两进行；\n\n### 代码\n``` js\nfunction swapPairs(head) {\n  // 当链表为空或者链表只有一个元素的时候，直接返回该链表\n  if (!head || !head.next) {\n    return head;\n  }\n\n  // 准备循环的素材\n  let res = head.next;\n  let now = head;\n  let preNode = new ListNode();\n  preNode.next = head;\n\n  while(now && now.next) {\n    // 创建第二个节点和尾节点\n    let secondNode = now.next;\n    let tailNode = secondNode.next;\n\n    // 两个节点两两交换\n    now.next = tailNode;\n    secondNode.next = now;\n    preNode.next = secondNode;\n\n    // 创建下一次循环的条件 ～ 前置节点\n    preNode = now;\n    now = tailNode;\n  }\n  \n  return res;\n}\n\n```\n** 复杂度 **\n- 时间复杂度：只遍历了一遍链表，O(N);\n- 空间复杂度：借用了一个pre节点，常量级的O(1);","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095724620","body":"### 代码\nconsole.log('**** 第 12 天 ****');\n\n/*\n  题目地址：https://leetcode-cn.com/problems/lru-cache/\n*/\n\n// 创建双链表\nclass DoubleLinkedListNode {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n// 实现最近最少使用的类\nclass LRUCache {\n  // 声明基础的常量\n  constructor(capacity) {\n    // 声明容量相关的字段\n    this.capacity = capacity;\n    this.count = 0;\n\n    //声明初始的链表\n    this.hashmap = {}; // 用来记录每个值的索引，使得链表的查找时间复杂度为O(1);\n    this.dummyHead = new DoubleLinkedListNode(null, null);\n    this.dummyTail = new DoubleLinkedListNode(null, null);\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n    \n  }\n\n  // 判断容器是否已经装满\n  _isFull() {\n    return this.count === this.capacity;\n  }\n\n  // 移除节点的方法\n  _removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n\n    node.prev = null;\n    node.next = null;\n\n    return node;\n  }\n\n  // 添加节点到头部的方法\n  _addNodeToHead(node) {\n    const head = this.dummyHead.next;\n\n    node.next = head;\n    head.prev = node;\n    node.prev = this.dummyHead;\n    this.dummyHead.next = node;\n  } \n\n  // 获取节点值的方法\n  get(key) {\n    // 如果key在hashmap中，则返回它的值\n    if (key in this.hashmap) {\n      const node = this.hashmap[key];\n\n      this._addNodeToHead(this._removeNode(node));\n\n      return node.value;\n    }\n\n    // 否则返回-1\n    else {\n      return -1;\n    }\n  }\n\n  // 添加节点\n  put(key, value) {\n    // 如果key已经存在，更新key的值，将key移到最前面\n    if (key in this.hashmap) {\n      const node = this.hashmap[key];\n      node.value = value; // 更新值\n\n      // 删除之前的节点，将节点放在链表的最前面\n      this._addNodeToHead(this._removeNode(node));\n    }\n    \n    // 如果key不存在，检查容量是否已经满了\n    /*\n      如果满了，删除最后一个节点的值；\n      如果没有满，新增节点\n    */\n\n    else {\n      if (this._isFull()) {\n        const node = this.dummyTail.prev;\n\n        delete this.hashmap[node.key];\n        this._removeNode(node);\n\n        this.count  = this.count - 1;\n      }\n\n      const node = new DoubleLinkedListNode(key, value);\n      this.hashmap[key] = node;\n      \n      this._addNodeToHead(node);\n      this.count  = this.count + 1;\n    }\n  }\n}\n\n** 复杂度分析 **\n-- 时间复杂度：O(1) \n-- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097993663","body":"### 代码\n\n``` js\n\nfunction maxDepth(root) {\n  if (root === null) {\n    return 0;\n  }\n\n  return Math.max(\n    maxDepth(root.left), maxDepth(root.right),\n  ) + 1;\n}\n\n```\n\n*** 复杂度分析 ***\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098590581","body":"### 代码\n``` js\nfunction isSameTree(p, q) {\n  if(!p || !q) {\n    // 当某个节点的左子树或者右子树孩子节点都为空时，说明当前节点一致\n    return !p && !q;\n  }\n\n  return (\n    p.val === q.val &&\n    isSameTree(p.left, q.left) &&\n    isSameTree(p.right, q.right)\n  )\n\n\n/*\n  层次遍历的写法\n*/\nfunction isSameTree1(p, q) {\n  let curLevelA = [p];\n  let curLevelB = [q];\n\n\n  while(curLevelA.length && curLevelB.length) {\n    let nextLevelA = [];\n    let nextLevelB = [];\n\n    // 判断当前层是否一致\n    let isOk = isSameCurLevel(curLevelA, curLevelB, nextLevelA, nextLevelB);\n\n    // 当前层如果一样，就继续比较下一层，否则结束比较\n    if (isOk) {\n      curLevelA = nextLevelA;\n      curLevelB = nextLevelB;\n    } else {\n      return false;\n    }\n  }\n\n  // 所有的节点比较完，发现都相同，则返回true\n  return true;\n}\n\n// 判断当前层的节点是否一样\nfunction isSameCurLevel(curLevelA, curLevelB, nextLevelA, nextLevelB) {\n  // 首先判断节点数量是否一致\n  if (curLevelA.length !== curLevelB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < curLevelA.length; i++) {\n    const isSame = isSameNode(curLevelA[i], curLevelB[i]);\n\n    if (!isSame) {\n      return false;\n    }\n\n    curLevelA[i] && nextLevelA.push(curLevelA[i].left, curLevelA[i].right);\n    curLevelB[i] && nextLevelB.push(curLevelB[i].left, curLevelB[i].right);\n  }\n\n  return true;\n}\n\n// 判断当前的节点是否相同\nfunction isSameNode(nodeA, nodeB) {\n  // 如果存在空节点，只有当它们都为空时才相同\n  if (!nodeA || !nodeB) {\n    return nodeA === nodeB;\n  }\n\n  return nodeA.val === nodeB.val;\n}\n\n```\n** 复杂度分析 **\n- 时间复杂度：O(N);，n为节点的数量\n- 空间复杂度：O(h)，h为树的深度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099730143","body":"### 代码\n``` js\nfunction sumNumbers(root) {\n  let sum = 0;\n\n  dfs(root, 0);\n  function dfs(root, data) {\n    // 如果当前节点为空，直接结束\n    if (!root) {\n      return;\n    }\n    \n    const curSum = data * 10 + root.val;\n\n    // 当前阶段为叶子节点时将计算好的值做相加\n    if (!root.left && !root.right) {\n      sum += curSum;\n  \n      return;\n    }\n  \n    dfs(root.left, curSum);\n    dfs(root.right, curSum);\n  }\n\n  return sum;\n}\n\nfunction sumNumbers1(root) {\n  let sum = 0;\n  let curLevel = [];\n\n  if (root) {\n    curLevel.push(root);\n  }\n\n  while (curLevel.length) {\n    let nextLevel = [];\n\n    for(let i = 0; i < curLevel.length; i++) {\n      if (curLevel[i].left) {\n        curLevel[i].left.val = curLevel[i].val * 10 + curLevel[i].left.val;\n        nextLevel.push(\n          curLevel[i].left\n        );\n      }\n\n      if (curLevel[i].right) {\n        curLevel[i].right.val = curLevel[i].val * 10 + curLevel[i].right.val;\n        nextLevel.push(\n          curLevel[i].right\n        );\n      }\n\n      if (!curLevel[i].left && !curLevel[i].right) {\n        sum += curLevel[i].val;\n      }\n\n      curLevel = nextLevel;\n    }\n  }\n\n  return sum;\n}\n```\n** 复杂度分析 **\n- 时间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100796071","body":"### 代码\n``` js\n// 题目地址：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\n\n// 序列化和反序列化\nfunction serialize(root) {\n  const queue = [root];\n  let res = [];\n\n  while (queue.length) {\n    // 删除数组的第一项并返回删除的内容\n    const root = queue.shift();\n\n    if (root) {\n      res.push(root.val);\n\n      queue.push(root.left);\n      queue.push(root.right);\n    } else {\n      res.push('#');\n    }\n  }\n\n  return res.join(',');\n}\n\nfunction deserialize(data) {\n  if (data === '#') {\n    return null;\n  }\n\n  const res = data.split(',');\n  const root = new TreeNode(res[0]);\n  const queue = [root];\n  let cursor = 1;\n\n  // 当光标的值不小于序列化数组的程度时，说明完成遍历\n  while (cursor < res.length) {\n    const node = queue.shift();\n    const leftValue = res[cursor];\n    const rightValue = res[cursor + 1];\n\n    if (leftValue !== '#') {\n      const leftNode = new TreeNode(leftValue);\n      node.left = leftNode;\n      queue.push(leftNode);\n    }\n\n    if (rightValue !== '#') {\n      const rightNode = new TreeNode(rightValue);\n      node.right = rightNode;\n      queue.push(rightNode);\n    }\n\n    cursor += 2;\n  }\n\n  return root;\n}\n```\n\n** 复杂度分析 **\n- 时间复杂度：o(n);\n-","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101877902","body":"### 思路\n参考官方暴力遍历以及hash的方式\n\n### 代码\n\n``` js\n// 遍历的方式\nfunction twoSum(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n\n  return null;\n}\n\n// hash的方法\nfunction twoSum1(nums, terget) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    if (map.has(target - nums[i])) {\n      return [map.get(target - nums[i]), i];\n    } else {\n      map.set(target -nums[i], i)\n    }\n  }\n\n  return null\n}\n```\n\n** 复杂度分析 **\n\n循环遍历的方方式\n- 时间复杂度：O(n^2),\n- 空间复杂度：O(1)\n\nhash的方式\n- 时间复杂度：O(N);\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103303983","body":"### 思路\n1、先生成一个hash表；\n2、通过遍历的方式将出现的次数维护到hash表中；\n3、最后将符合条件的key塞到新数组中返回\n### 代码\n\n``` js\n\n// hash表的方式\nfunction topKFrequent(nums, k) {\n  // 生成一个hash结构\n  let hash = new Map();\n\n  // 遍历维护一组hash数据\n  for (let i = 0; i < nums.length; i++) {\n    if (hash.has(nums[i])) {\n      let value = hash.get(nums[i]);\n      \n      hash.set(nums[i], value+1);\n    } else {\n      hash.set(nums[i], 1);\n    }\n  }\n\n  // 将符合条件的值维护到数组中返回\n  let res = [];\n  for (let [ key, values ] of hash) {\n      console.log(key, values);\n    if (values >= k) {\n      res.push(key);\n    }\n  }\n\n  return res;\n}\n```\n** 复杂度分析 **\n- 时间复杂度：O(N);\n- 空间复杂度：O(N) ,N为数组的长度","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107670639","body":"### 思路\n有点没理解前后关系，晚点再看下\n\n```\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = floorMod(currSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085972190","body":"## idea\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(max(len(num), digit(k))\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646210","body":"## idea\n左右遍历数组\n## code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874987","body":"## idea\n数组实现栈\n## code\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n## complexity\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087174643","body":"## 辅助栈\n解码顺序是由内向外，先解码里面的括号再解码外面的括号，而遍历字符串是先遇到外面的括号再遇到里面的括号，符合栈先进后出原则，需要用到两个辅助栈multiStack、resStack，一个由存字符串，一个存数字，两个变量mutil、res存储将要存进栈的元素，则遍历思路为：\n1. 遇到 \\[ 将multi、res存进栈待用，变量重置\n2. 遇到 \\] 从multiStack获取解码倍数，从resStack获取解码字符串的前缀，得到的解码字符串 tmp = resStack.pop() + res * multiStack.pop()，再将解码字符串存储在res中\n3. 遇到数字，作为multi的最低位 \n4. 遇到其他，添加到res的尾部\n5. 遍历结束后res，即最终解码字符串就是答案\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> resStack = new LinkedList<>();\n        Deque<Integer> multiStack = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '[') {\n                multiStack.push(multi);\n                multi = 0;\n                resStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (ch == ']') {\n                StringBuilder tmp = new StringBuilder();\n                tmp.append(resStack.pop());\n                int curMulti = multiStack.pop();\n                for (int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = tmp;\n            } else if (Character.isDigit(ch)) {\n                multi = multi * 10 + ch - '0';\n            } else {\n                res.append(ch);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n## 复杂度\n- 时间：O(len(s))\n- 空间：栈空间，O(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088293928","body":"## idea\n双辅助栈实现队列\n## code\n```java\nclass MyQueue {\n    Deque<Integer> pushStack = new LinkedList<>();\n    Deque<Integer> popStack = new LinkedList<>();\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n## complexity\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090428939","body":"## 计数\n遍历数组，若和有序数组expect计数相同，则说明此时可分块，res++\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int res = 0;\n        int nonzero = 0;\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i], y = expect[i];\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (nonzero == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n## 复杂度\n- O(nlogn)，排序\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091728051","body":"## 链表操作\n先遍历链表，得到链表尾tail和链表长度len，若k % len == 0说明移动的长度为链表长度的倍数，即不移动直接返回head，否则尾节点连接头节点，新尾节点离旧头节点len - k % len - 1，找到新尾节点newTail，则新头节点newHead = newTail.next，并断开尾节点后的连接newTail.next = null，返回新头节点\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        int len = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) {\n            return head;\n        }\n        tail.next = head;\n        ListNode newTail = head;\n        for (int i = 0; i < k; i++) {\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        return newHead;\n    }\n}\n```\n## 复杂度\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092410760","body":"## 链表操作\n创建哑节点dummy指向head，令pre = dummy，每次交换pre后两个节点one和two，然后令pre = one，即将交换后的第二个节点作为下一轮循环的pre\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        while (pre.next != null && pre.next.next != null) {\n            ListNode one = pre.next;\n            ListNode two = pre.next.next;\n            pre.next = two;\n            one.next = two.next;\n            two.next = one;\n            pre = one;\n        }\n        return dummy.next;\n    }\n}\n```\n## 复杂度\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093664914","body":"## 二分 or 快慢指针\n递归找中点作为根节点创建二叉树，有两种方式：\n1. 数组二分，空间换时间\n2. 每次递归都使用快慢指针找中点\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        while (head != null) {\n            list.add(head.val);\n            head = head.next;\n        }\n        return buildTree(0, list.size() - 1, list);\n    }   \n\n    TreeNode buildTree(int left, int right, List<Integer> list) {\n        if (left > right) {\n            return null;\n        }\n        int mid = left + (right - left + 1) / 2;\n        TreeNode root = new TreeNode(list.get(mid));\n        root.left = buildTree(left, mid - 1, list);\n        root.right = buildTree(mid + 1, right, list);\n        return root;\n    }\n}\n```\n- 时间：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094086866","body":"## 双指针\n令pA = headA，pB = headB，遍历直至为null时pA = headB，pB = headA，若相交两个指针将会在交点会合：\n令headA到交点距离为a，headB到交点距离为b，交点到链表尾距离为c，pA或pB遍历各自链表后从另一链表到交点所走过的距离都为a + b + c，所以同时开始遍历的情况下会在交点会合。\n否则遍历至链表尾返回null\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094592985","body":"## 快慢指针\n- slow走一步，fast走两步\n- fast指针走过的长度为 a + b + n(b + c) = a + (n + 1) b + nc\n- slow指针走过的长度为 a + b\n- fast指针走过的长度是slow的两倍\n- a + (n + 1)b + nc  = 2(a + b)\n- a = c  + (n - 1)(b + c)\n- 所以若p指向head，slow指向b和c的交点，同时移动指针则当p走了a距离即走到环入口点时，slow也走过c  + (n - 1)(b + c)即饶了(n - 1)圈后走了c距离也到达换入口点\n\n![](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next == null) {\n                return null;\n            }\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode p = head;\n                while (p != slow) {\n                    p = p.next;\n                    slow = slow.next;\n                }\n                return p;\n            }\n        }\n        return null;\n    }\n}\n```\n- 时间：O(n)，slow走过的长度不超过链表总长度\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096764786","body":"## 双向链表 + 哈希表\n- get和put的平均复杂度为O(1)不难联想到哈希表，而实现LRU还需要维护一个双向链表，我们秩序每次添加或修改链表时将元素放在表头，当大于元素数量大于容量时将表尾元素移除\n- Java API就有此实现LinkedHashMap，我们也可以继承该类然后覆盖removeEldestEntry方法完成题目\n\n1\n```java\nclass LRUCache {\n    class DListNode {\n        int key, value;\n        DListNode pre;\n        DListNode next;\n\n        DListNode() {}\n\n        DListNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    int size, capacity;\n    Map<Integer, DListNode> cache = new HashMap<>();\n    DListNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        size = 0;\n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        DListNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DListNode node = cache.get(key);\n        if (node == null) {\n            node = new DListNode(key, value);\n            cache.put(key, node);\n            addToHead(node);\n            size++;\n            if (size > capacity) {\n                DListNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                removeNode(removedTail);\n                size--;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DListNode node) {\n       node.pre = head;\n       node.next = head.next;\n       head.next.pre = node;\n       head.next = node;\n    }\n\n    DListNode removeTail() {\n        DListNode removedTail = tail.pre;\n        removeNode(removedTail);\n        return removedTail;\n    }\n\n    void moveToHead(DListNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    void removeNode(DListNode node) {\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n}\n```\n2\n```java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097862671","body":"## 二叉树DFS\n树的最大深度 = max（左子树最大深度，右子树最大深度）+ 1\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n- time: O(n)\n- space: O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099256390","body":"## DFS\r\n两树相同 = 根节点相同 + 左右子树相同\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        }\r\n        if (p == null || q == null) {\r\n            return false;\r\n        }\r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n- time: O(n)\r\n- space: O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099942121","body":"## DFS\nDFS遍历每条路径，递归参数存储路径值，当判断为叶子节点时将路径值加到结果变量上\n```java\nclass Solution {\n    int res = 0;\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return res;\n    }\n\n    void dfs(TreeNode root, int pre) {\n        if (root == null) {\n            return;\n        }\n        int cur = pre * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            res += cur;\n            return;\n        }\n        dfs(root.left, cur);\n        dfs(root.right, cur);\n    }\n}\n```\n- time: O(n)\n- space: O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100675880","body":"## 二叉树\n先判断是不是最底层，取最底层的第一个节点值即使答案，即判断用 depth > maxDepth而不是 >=\n```java\nclass Solution {\n    int maxDepth = -1;\n    int res = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        dfs(root, 0);\n        return res;\n    }\n\n    void dfs(TreeNode root, int depth) {\n        if (root == null) {\n            return;\n        }\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            res = root.val;\n        }\n        dfs(root.left, depth + 1);\n        dfs(root.right, depth + 1);\n    }\n}\n```\n- O(n)\n- O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100888446","body":"## DFS\n序列化：后序遍历，前构造左右子树字符串，再和当前节点字符串合并\n反序列化：前序遍历，先创建当前节点，再创建左右子树，用队列保存构造值\n```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"null,\";\n        }\n        String left = serialize(root.left);\n        String right = serialize(root.right);\n        return root.val + \",\" + left + right;\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] split = data.split(\",\");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(split));\n        return buildTree(queue);\n    }\n\n    TreeNode buildTree(Queue<String> queue) {\n        String s = queue.poll();\n        if (\"null\".equals(s)) {\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(s));\n        root.left = buildTree(queue);\n        root.right = buildTree(queue);\n        return root;\n    }\n}\n```\n- time: O(n)\n- space: O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101473837","body":"## DFS + 优先队列\n- 借助三元组{列值，行值，节点值}排序节点\n- DFS遍历所有节点将三元组放入以按列值 > 行值 > 节点值为比较器的优先队列\n- 将列值相同的放入同一个List中\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        Queue<int[]> queue = new PriorityQueue<>((a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            }\n            if (a[1] != b[1]) {\n                return a[1] - b[1];\n            }\n            return a[2] - b[2];\n        });\n        dfs(0, 0, root, queue);\n        List<List<Integer>> res = new LinkedList<>();\n        while (!queue.isEmpty()) {\n            \n        }\n    }\n\n    void dfs(int row, int col, TreeNode root, Queue<int[]> queue) {\n        if (root == null) {\n            return;\n        }\n        queue.offer(new int[]{row, col, root.val});\n        dfs(row + 1, col - 1, root.left, queue);\n        dfs(row + 1, col + 1, root.right, queue);\n    }\n}\n```\n- time: O(nlog(n)), due to heap sort\n- space: O(n), store n triples","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101960421","body":"## 哈希表\n- 循环遍历数组，每次循环以值和下标作为键值放入哈希表\n- 每次循环判断哈希表是否包含target - nums[i]，若有则返回当前下标和target - nums[i]在哈希表中对应的下标\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (map.containsKey(target - nums[i])) {\n                return new int[]{map.get(target - nums[i]), i};\n            }\n            map.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n```\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103900858","body":"## 哈希表 + 优先队列\n哈希表存不同的数及其出现次数，优先队列使用二元组对哈希表键值对以值排序\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        Queue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        map.forEach((num, count) -> {\n            if (queue.size() < k) {\n                queue.offer(new int[]{num, count});   \n            } else if (count > queue.peek()[1]) {\n                queue.poll();\n                queue.offer(new int[]{num, count});\n            }\n        });\n        int[] res = new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i] = queue.poll()[0];\n        }\n        return res;\n    }\n}\n```\n- time: O(nlog(k))，对k个元素进行堆排序\n- space: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105244490","body":"## 哈希表 + 枚举\n每个点枚举通过该点的边距离并存入哈希表对距离计数，相同距离则形成“回旋镖”，每个点枚举完后，遍历哈希表，每个值的全排列相加则是通过该点的元组数，最后清空表再对下个点进行距离枚举\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if (points == null || points.length <= 2) {\n            return 0;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points.length; j++) {\n                int dis = getDis(points[i], points[j]);\n                map.put(dis, map.getOrDefault(dis, 0) + 1);\n            }\n            for (Integer value : map.values()) {\n                res += value * (value - 1);\n            }\n            map.clear();\n        }\n        return res;\n    }\n\n    int getDis(int[] p, int[] q) {\n        return (p[0] - q[0]) * (p[0] - q[0]) +\n            (p[1] - q[1]) * (p[1] - q[1]);\n    }\n}\n```\n- time: O(n^2)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106032032","body":"## 集合 + 滑动窗口\n遍历字符串，每一轮都循环判断集合是否包含带加入集合的右指针指向元素，是则移除左指针指向元素，再将右指针指向元素加入集合，最后再判断左右指针形成的字串是不是最长\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int res = 0, l = 0, r = 0;\n        int len = s.length();\n        while (r < len) {\n            while (set.contains(s.charAt(r))) {\n                set.remove(s.charAt(l));\n                l++;\n            }\n            set.add(s.charAt(r));\n            res = Math.max(res, r - l + 1);\n            r++;\n        }\n        return res;\n    }\n}\n```\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107432100","body":"## 哈希表 + 滑动窗口\n- 用哈希表map存储字符串并统计及其格数以便查找\n- 两重循环，外循环遍历寻找子串的起点，每次内循环前使用哈希表tmp存储此次内循环单词情况，内循环遍历单词判断单词是否存在map中或tmp中该单词个数是否不超过map中个数，若否- - 内循环完成后，判断map表和tmp表是否相同（或者用count存储符合条件的word个数判断是否和words的单词个数相同），若是则将外循环起点下标添加到答案res中\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int len = s.length();\n        int wordsNum = words.length;\n        int wordLen = words[0].length();\n        Map<String, Integer> map = new HashMap<>();\n        List<Integer> res = new LinkedList<>();\n        for (int i = 0; i < wordsNum; i++) {\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\n        }\n        for (int i = 0; i < len - wordLen * wordsNum + 1; i++) {\n            int left = i;\n            Map<String, Integer> tmp = new HashMap<>();\n            int count = 0;\n            while (left + wordLen <= len) {\n                String word = s.substring(left, left + wordLen);\n                if (!map.containsKey(word)) {\n                    break;\n                }\n                tmp.put(word, tmp.getOrDefault(word, 0) + 1);\n                if (tmp.get(word) > map.get(word)) {\n                    break;\n                }\n                count++;\n                left += wordLen;\n            }\n            if (count == wordsNum) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n```\n- O(n * wordNum * wordLen)\n- O(wordNum)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107778120","body":"## 前缀和 + 同余定理\n- 所求子串pre[i, j] = pre[j] - pre[i - 1]\n- (total - pre[i, j]) % k = 0 => total % k  = pre[i, j] % k => (pre[j] - total) % k = pre[i - 1] %k，同余定理得  (pre[j]  - total % k) % k = pre[i - 1] % k\n- 设total % k = target，则遍历数组，将pre[i] % k放入map并记录下标，判断map是否存在(pre[i] - target) % k，有，则满足上式即为符合条件的字串\n- 子串距离为 i - map.get(pre - target) % k，即 j - (i - 1)  = j - i + 1，判断是否为最短符合条件子串，若是则保存\n- 用floorMod代替%同一正负数的余数答案（floodMod(a, b) { (a + b) % b}，pre - target可能为负数\n- 遍历数组前map.put(0, -1)，防止子串从下标0开始\n```java\nimport java.util.*;\n\nclass Solution {\n    public int solve(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int total = 0;\n        for (int num : nums) {\n            total += num;\n        }\n        int target = Math.floorMod(total, k);\n        map.put(0, -1);\n        int pre = 0, res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            pre += nums[i];\n            int mod = Math.floorMod(pre, k);\n            map.put(mod, i);\n            if (map.containsKey(Math.floorMod(pre - target, k))) {\n                res = Math.min(res, i - map.get(Math.floorMod(pre - target, k)));\n            }\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```\n- time: O(n)\n- space: O(n)\n \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108674408","body":"## 思路\n1. 动态数组：遍历节点将存入动态数组，然后通过size/2索引取第二个中间节点\n2. 几何关系：起点到中点长度等于总长度一半，先遍历得到总长度，再重新遍历n/2长度得到中点\n3. 快慢指针：都从头节点开始，慢指针走一步，快指针走两部，遍历结束慢指针指向中点，以下代码以此为例\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109246800","body":"## 快慢指针\n遍历数组，快指针一直前进，慢指针作为新数组索引，当快指针指向数不等于其上一个数（即不重复）时前进\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return 0;\n        }\n        int slow = 1, fast = 1;\n        while (fast < len) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n}\n```\n- time: O(n)\n- space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111050809","body":"## 二分查找\n- 若找到返回mid，若找不到返回left\n- left = right时如{1}，target = 0 or 2\n- left = right - 1时如{1，2}，target = 0 or 3\n- 以上情况是二分查找所有可能发生情况，返回left皆符合需求\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n}\n```\n- time: O(log(n))\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112377157","body":"## 双端队列\n双端队列保存索引值，首先将比nums[i]小的出队列，再将索引值i放入队列尾，\n如果i >= k - 1，即队列先前累计进队列的索引数达到滑动窗口大小，即可将队头作为当前滑动窗口的最大值\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> deque = new LinkedList<>();\n        int[] res = new int[nums.length - k + 1];\n        for (int i = 0; i < nums.length; i++) {\n            while (!deque.isEmpty() && nums[i] >=  nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offer(i);\n            if (i >= k - 1) {\n                res[i - k + 1] = nums[deque.peek()];\n            }\n            if (deque.peek() == i - k + 1) {\n                deque.poll();\n            }\n        }\n        return res;\n    }\n}\n```\n- time: O(n)\n- space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113008443","body":"## 有向图\n转换为有向图，找出度为0，入度为n - 1的点\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] outDegrees = new int[n + 1];\n        int[] inDegrees = new int[n + 1];\n        for (int[] edge : trust) {\n            int start = edge[0], end = edge[1];\n            outDegrees[start]++;\n            inDegrees[end]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n- time: O(m + n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113915515","body":"## 二分图\n以邻接矩阵创建无向图，遍历顶点着色同时深度遍历其相邻顶点着反色，若发现相邻将要着色的顶点已经着色并且和期望色不同则返回false，成功着色返回true\n```java\nclass Solution {\n    List<Integer>[] graph;\n    int[] color;\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        graph = new ArrayList[n + 1];\n        color = new int[n + 1];\n        for (int node = 1; node <= n; node++) {\n            graph[node] = new ArrayList<>();\n        }\n        for (int[] edge : dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        for (int node = 1; node <= n; node++) {\n            if (color[node] == 0 && !dfs(node, 1)) {\n                return false;\n            } \n        }\n        return true;\n    }\n\n    boolean dfs(int node, int c) {\n        if (color[node] != 0) {\n            return color[node] == c;\n        }\n        color[node] = c;\n        for (int nei : graph[node]) {\n            if (!dfs(nei, -c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n- time: O(v + e)，v是顶点数，e是边数\n- space: O(v + e)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"webcoder-hk":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085977131","body":"```python\r\n# 都转成整数相加，再转成数组\r\nfrom typing import *\r\nfrom functools import reduce\r\n\r\ndef solution(a:List[int], b:int)->List[int]:\r\n    x = reduce(lambda x,y:x*10+y, a)\r\n    x += b\r\n    result = []\r\n    r = x%10\r\n    x //= 10\r\n    while x or r:\r\n        result.append(r)\r\n        r = x%10\r\n        x //= 10\r\n    result.reverse()\r\n    return result\r\n```\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565255","body":"```python\r\n# 先正向遍历数组标出不等于C得字符，再反向遍历数组利用正向遍历留下得信息算出所需结果。\r\nclass Solution:\r\n    def shortestDistance(self, S:str, C:str)-> List[int]:\r\n        n = len(S)\r\n        result = [0 for _ in range(n)]\r\n        j = 0\r\n        for i in range(n):\r\n            if S[i]!=C:\r\n                j += 1\r\n                result[i] = j\r\n            else:\r\n                j = 0\r\n        j = 0\r\n        for i in range(n-1, -1, -1):\r\n            if S[i] != C:\r\n                j += 1\r\n                if i-result[i]>=0 and result[i-result[i]]==0:\r\n                    result[i] = min(result[i], j)\r\n                else:\r\n                    result[i] = j\r\n            else:\r\n                j = 0\r\n        return result\r\n```\r\ntime: O(2n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866910","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.maxSize = maxSize\n        self.data = []\n        \n    def push(self, x):\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n            \n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        else:\n            return -1\n\n    def increment(self, k, v):\n        n = min(len(self.data), k)\n        for i in range(n):\n            self.data[i] += v\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087459907","body":"```python\nclass Solution(object):\n    def decodeString(self, s):\n        stack, res, n = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append((n, res))\n                res, n = \"\", 0\n            elif c == ']':\n                cur_n, last_res = stack.pop()\n                res = last_res + cur_n * res\n            elif '0' <= c <= '9':\n                n = n * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088518859","body":"```python\nclass MyQueue(object):\n    def __init__(self):\n        self.stack = MyStack()\n        self.tmp = MyStack()\n\n    def push(self, x):\n        while self.stack.size()>0:\n            self.tmp.push(self.stack.pop())\n        self.stack.push(x)\n        while self.tmp.size()>0:\n            self.stack.push(self.tmp.pop())\n\n    def pop(self):\n        if self.stack.size()>0:\n            return self.stack.pop()\n\n    def peek(self):\n        if self.stack.size()>0:\n            return self.stack.peek()\n\n    def empty(self):\n        return self.stack.empty()\n    \nclass MyStack(object):\n    def __init__(self):\n        self.data = []\n\n    def push(self, x):\n        self.data.append(x)\n\n    def pop(self):\n        if len(self.data)>0:\n            return self.data.pop()\n            \n    def peek(self):\n        if len(self.data)>0:\n            return self.data[-1]\n\n    def empty(self):\n        return len(self.data)==0\n    \n    def size(self):\n        return len(self.data)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090440309","body":"```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count = collections.Counter()\r\n        counted = []\r\n        for x in arr:\r\n            count[x] += 1\r\n            counted.append((x, count[x]))\r\n\r\n        ans, cur = 0, counted[0]\r\n        for X, Y in zip(counted, sorted(counted)):\r\n            cur = max(cur, X)\r\n            if cur == Y:\r\n                ans += 1\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091411816","body":"```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head is None:\r\n            return None\r\n        p = q = head\r\n        n = 0\r\n        while q.next is not None:\r\n            q = q.next\r\n            n += 1\r\n        for _ in range(n-k%(n+1)):\r\n            p = p.next\r\n        q.next = head\r\n        head = p.next\r\n        p.next = None\r\n        return head\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092471397","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        h = head\n        p, q = h, h.next\n        p.next = q.next\n        q.next = p\n        head = q\n        while h.next is not None:\n            p, q = h.next, h.next.next\n            if q is not None:\n                p.next = q.next\n                q.next = p\n                h.next = q\n            h = p\n        return head\n```\ntime: O(n)\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093958519","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None:\n            return head\n        d = []\n        node = head\n        while node is not None:\n            d.append(node.val)\n            node = node.next\n        return self.buildTree(d)\n        \n    def buildTree(self, d):\n        if len(d) == 0:\n            return None\n        mid = len(d)//2\n        r = TreeNode(d[mid])\n        r.left = self.buildTree(d[:mid])\n        r.right = self.buildTree(d[mid+1:])\n        return r\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094183925","body":"```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        d = {}\r\n        pa,pb = headA, headB\r\n        while pa is not None:\r\n            d[id(pa)] = pa.val\r\n            pa = pa.next\r\n        while pb is not None:\r\n            if d.get(id(pb)):\r\n                return pb\r\n            pb = pb.next\r\n```\r\ntime: O(n)\r\nspace: O(n)\r\n\r\n```python\r\n# optimized\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p, q = headA, headB\r\n        while p != q:\r\n            if p is None: p = headB\r\n            else: p = p.next\r\n            if q is None: q = headA\r\n            else: q = q.next\r\n        return p\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094611157","body":"```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if head is None or head.next is None: return None\r\n        p,q = head,head.next\r\n        while p != q:\r\n            for _ in range(2):\r\n                if q is None:\r\n                    return None\r\n                q = q.next\r\n            p = p.next\r\n        head2 = p.next\r\n        p.next = None\r\n        p,q = head,head2\r\n        while p != q:\r\n            p = p.next\r\n            q = q.next\r\n            if p is None: p = head2\r\n            if q is None: q = head            \r\n        return p\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096842250","body":"```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = DLinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098141449","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        return max(self.maxDepth(root.left)+1, self.maxDepth(root.right)+1)\n```\ntime: O(n)\nspace: O(depth)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098700950","body":"```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if p is None and q is None:\n            return True\n        elif p is not None and q is not None:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) and p.val == q.val\n        else:\n            return False\n```\ntime: O(min(m,n))\nspace: O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100607954","body":"```python3\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        def dfs(r, cnt):\r\n            if r is None:\r\n                return 0\r\n            cnt = cnt*10 + r.val\r\n            if r.left is None and r.right is None:\r\n                return cnt\r\n            return dfs(r.left, cnt) + dfs(r.right, cnt)\r\n        return dfs(root, 0)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100686198","body":"```python3\n        self.left, self.maxdep = 0, -1\n        def dfs(root, dep):\n            if root is None:\n                return\n            if dep > self.maxdep:\n                self.left = root.val\n                self.maxdep += 1\n            dfs(root.left, dep+1)\n            dfs(root.right, dep+1)\n        dfs(root, 0)\n        return self.left\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100903520","body":"```python3\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        queue = [root]\r\n        res = [root.val]\r\n        while len(queue)>0:\r\n            root = queue.pop(0)\r\n            if root.left is not None:\r\n                queue.append(root.left)\r\n                res.append(root.left.val)\r\n            else:\r\n                res.append(None)\r\n            if root.right is not None:\r\n                queue.append(root.right)\r\n                res.append(root.right.val)\r\n            else:\r\n                res.append(None)\r\n        for i in range(len(res)-1, -1, -1):\r\n            if res[i] is None:\r\n                res.pop()\r\n            else:\r\n                return res\r\n        \r\n    def deserialize(self, data):\r\n        n = len(data)\r\n        if n == 0:\r\n            return None\r\n        root = TreeNode(data[0])\r\n        queue = [root]\r\n        i = 1\r\n        while i<n and len(queue)>0:\r\n            r = queue.pop(0)\r\n            if r is not None:\r\n                if data[i] is not None:\r\n                    r.left = TreeNode(data[i])\r\n                    queue.append(r.left)\r\n                i += 1\r\n                if i<n:\r\n                    if data[i] is not None:\r\n                        r.right = TreeNode(data[i])\r\n                        queue.append(r.right)\r\n                i += 1\r\n        return root\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101410731","body":"```python3\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.dict = defaultdict(list)\n        def helper(root, row, col):\n            if root is None:\n                return\n            self.dict[col].append((row,root.val))\n            helper(root.left, row+1, col-1)\n            helper(root.right, row+1, col+1)\n        helper(root, 0, 0)\n        res = []\n        for k in sorted(self.dict.keys()):\n            d = sorted(self.dict[k])\n            res.append([t[1] for t in d])\n        return res\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101967979","body":"```python3\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        d = {}\n        for i in range(len(nums)):\n            j = d.get(target-nums[i])\n            if j is not None:\n                return (j, i)\n            else:\n               d[nums[i]] = i\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103539934","body":"```python3\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        cnts,heap = {},[]\n        for n in nums:\n            cnts[n] = cnts.get(n, 0)+1\n        for n in cnts.keys():\n            heappush(heap, (cnts[n], n))\n            if len(heap)>k:\n                heappop(heap)\n        return [t[1] for t in heap]\n```\ntime: O(n*logn)\nspace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085981416","body":"# Problem [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)\n## Algorithm\n1. Add *k* to each digit of num from the lowest digit.\n2. Then *k%10* is saved to result as the new digit, and *k/10* is used as the new *k* for next digit.\n3. The drawback of this method is if *k* is very close to MAX_VALUE (within 10), then there could be overflow.\n\n## Complexity\n* Time complexity: O(max(num.length, logK))\n* Space complexity: O(max(num.length, logK))\n\n## Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665460","body":"# Problem [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\r\n\r\n## Algorithm\r\n1. Walk through the array from the left to find the closest char c to the right of each char in s.\r\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\r\n3. Find the min distance of step 1 and 2.\r\n4. Step 2 and 3 can be combined.\r\n\r\n## Complexity\r\n* Time Complexity: We are going over the array exactly twice. O(N)\r\n* Space Complexity: We can use the same output array, so no extra space. O(1)\r\n\r\n## Code\r\nLanguage: Java\r\n```Java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] result = new int[n];\r\n        Arrays.fill(result, n);\r\n        // Find closest c on the right of each char\r\n        int cur = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur <= i) {\r\n                result[cur] = i - cur;\r\n                cur++;\r\n            }\r\n        }\r\n\r\n        // Update to get the closest c from both sides by comparing left side\r\n        cur = n - 1;\r\n        for (int i = n - 1; i >=0; i--) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur >= i) {\r\n                result[cur] = Math.min(result[cur], cur - i);\r\n                cur--;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891831","body":"# Problem: [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n## Algorithm\n* Use an array to implement ths stack\n* Use *index* to track the current number of elements in the array and the top of the stack.\n\n## Complexity\n* *push* operation time complexity is O(1) since we simply assign one value to the current index of the array.\n* *pop* operation time complexity is O(1).\n* *inc* operation time complexity is O(k) where k is the number of elements to increment.\n* Total space complexity of the stack is O(n) where n is the maxSize.\n\n## Code\nLanguage: Java\n```java\nclass CustomStack {\n    private int[] stack;\n    private int index = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (index == stack.length) {\n            return;\n        }\n        stack[index++] = x;\n    }\n    \n    public int pop() {\n        if (index == 0) {\n            return -1;\n        }    \n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k; i++) {\n            if (i + 1 > index) {\n                return;\n            }\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087060502","body":"# Problem [394. Decode String](https://leetcode.com/problems/decode-string/)\n\n## Algorithm\n* Iterate over each character in the string and use a stack to keep track of visited character.\n  1. Keep pushing to the stack until we hit a ']' in string.\n  2. When we hit a ']' in string.\n     1. Keep popping from stack and form a substring until we get a '[' from stack.\n     2. Keep popping digits from stack until it is no longer a digit.\n     3. Convert popped out digits to a multiplier of the substring.\n     4. Decode the substring and push the decoded substring to the stack.\n\n## Complexity\nTime Complexity: O(N) where N is the length of the decoded string.\nSpace Complexity: O(N) where N is the length of the decoded string.\n\n## Code\nLanguage: Java\n\n``` Java\npublic String decodeString(String s) {\n   Deque<Character> stack = new ArrayDeque<>();\n   for (char c : s.toCharArray()) {\n       if (c != ']') {\n           stack.addFirst(c);\n           continue;\n       }\n       List<Character> decodedStr = new ArrayList<>();\n       while (stack.peekFirst() != '[') {\n           decodedStr.add(stack.removeFirst());\n       }\n       // Remove '['\n       stack.removeFirst();\n       \n       // Get multiplier\n       int num = 0;\n       int base = 1;\n       // Important to check if stack is empty first\n       while (!stack.isEmpty() && Character.isDigit(stack.peekFirst())) {\n           // It is very important to keep track of base, as the lower digits may be 0s like \"100\"\n           // Simply using num = num * 10 + stack.removeFirst() - '0' won't work.\n           num = num + (stack.removeFirst() - '0') * base;\n           base *= 10;\n       }\n       \n       // Put decoded string back to stack\n       for (int i = 0; i < num; i++) {\n           for (int j = decodedStr.size() - 1; j >= 0; j--) {\n               stack.addFirst(decodedStr.get(j));\n           }\n       } \n   }\n   char[] result = new char[stack.size()];\n   for (int i = stack.size() - 1; i >= 0; i--) {\n       result[i] = stack.removeFirst();\n   }\n   return new String(result);        \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088222950","body":"# Problem [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\r\n\r\n## Algorithm\r\n* Use two stacks to implement the queue: inStack and outStack.\r\n* Each element will be first pushed into inStack.\r\n* If outStack is not empty, we will pop from outStack. If outStack is empty, when pop/peek is called on the queue, we pop all elements in inStack and push them to outStack. After this, the head of the queue is at the top of outStack.\r\n\r\n## Complexity\r\n* *push()*: time complexity O(1).\r\n* *pop()*: amortized time complexity O(1). Each element will only be moved from inStack to outStack once with a total time of O(n). If we pop *n* times, the amortized time for each *pop()* is O(1).\r\n* *peek()*: same as *pop()*.\r\n\r\n## Code\r\nLanguage: Java\r\n\r\n``` Java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<>();\r\n        outStack = new ArrayDeque<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.addFirst(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            top();\r\n        }\r\n        return outStack.removeFirst();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            top();\r\n        }\r\n        return outStack.peekFirst();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void top() {\r\n        // move all elements from inStack to outStack\r\n        while (!inStack.isEmpty()) {\r\n            outStack.addFirst(inStack.removeFirst());\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090402046","body":"# Problem [768. Max Chunks To Make Sorted II](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n\n## Algorithm\n* In a valid solution, the max value in the *i* th partition must be less than the min value of the *i+1* th partition.\n* Use a stack to keep track of the max value of each partition.\n* Iterate over the array, if current value is less than the top of the stack, it must be in the same partition as the value at the top of the stack.\n\n## Complexity\n* Time Complexity: We iterate over the array only once. *O(N)*.\n* Space Complexity: A stack is introduced whose max length is *N*. *O(N)*.\n\n## Code\nLanguage: Java\n```Java\npublic int maxChunksToSorted(int[] arr) {\n    Deque<Integer> stack = new LinkedList<>();\n    // Use stack to keep track of the max value of each partition\n    for (int val : arr) {\n        if (stack.isEmpty() || stack.peekFirst() <= val) {\n            stack.addFirst(val);\n        } else {\n            int curMax = stack.peekFirst();\n            while (!stack.isEmpty() && stack.peekFirst() > val) {\n                stack.removeFirst();\n            }\n            stack.addFirst(curMax);\n        }\n    }\n    return stack.size();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091026426","body":"# Problem [61. Rotate List](https://leetcode.com/problems/rotate-list/)\n\n## Algorithm\n* First we find the length and tail of the list. Modulo length by *k* to find the min number of rotation needed.\n* Then traverse the list from head *length-k* nodes, to find the new tail and new head.\n\n## Complexity\n* Time Complexity: We go over the list twice. *O(N)*.\n* Space Complexity: *O(1)*\n\n## Code\nLanguage: Java\n\n``` Java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        \n        // first find length and tail\n        ListNode cur = head;\n        int len = 1;\n        while (cur.next != null) {\n            cur = cur.next;\n            len++;\n        }\n        if (k % len == 0) return head;\n        \n        ListNode tail = cur;\n        k = k % len;\n        cur = head;\n        // Find the new tail and head\n        for (int i = 1; i < len - k ; i++) {\n            cur = cur.next;\n        }\n        tail.next = head;\n        head = cur.next;\n        cur.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092832329","body":"# Problem [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/)\n\n## Algorithm\n* We simply need to go over the list and swap each pair of nodes.\n* The key is to also keep track of the previous and next nodes of the pair of nodes.\n\n## Complexity\n* Time Complexity: *O(N)*\n* Space Complexity: *O(1)*\n\n## Code\nLanguage: Java\n``` Java\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode next = cur.next;\n            ListNode temp = next.next;\n            pre.next = next;\n            next.next = cur;\n            cur.next = temp;\n            pre = cur;\n            cur = temp;\n        }\n        return dummy.next;        \n    }\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097452461","body":"# Problem [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)\n\n## Algorithm\n* Recursively get the maxDepth of left and right sub tree. Final result is *max(leftDepty, rightDepth) + 1*.\n\n## Complexity\n* Time Complexity: *O(N)* where *N* is the total number of nodes.\n* Space Complexity: *O(h)* where *h* is the height of the tree.\n\n\n## Code\nLanguage: Java\n``` Java\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099328028","body":"# Problem [Same Tree](https://leetcode.com/problems/same-tree/description/)\n\n## Algorithm\n* Check if the two roots are the same, if so recursively check if their left children and right children are equal.\n\n## Complexity\n* Time Complexity: *O(N)* where *N* is the total number of nodes\n* Space Complexity: Depth of the callstack - *O(h)* where *h* is the height of the tree.\n\n## Code\nLanguage: Java\n``` Java\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) {\n        return true;\n    }\n    if (p == null || q == null || p.val != q.val) {\n        return false;\n    }\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103409730","body":"# Problem [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)\n\n## Algorithm\n* Iterate over the array and use a map to keep track of counts of each value.\n* Use a priority queue to maintain *k* map entries with the highest frequency.\n\n## Complexity\n* Time Complexity: Creating map takes *O(N)* time. Iterating entries to create priority queue takes *O(Nlogk)* time. Total is *O(Nlogk)*.\n* Space Complexity: *O(N)*.\n\n## Code\nLanguage: Java\n``` Java\npublic int[] topKFrequent(int[] nums, int k) {\n    Map<Integer, Integer> counter = new HashMap<>();\n    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\n            Map.Entry.<Integer, Integer>comparingByValue());\n\n    for (int num : nums) {\n        counter.putIfAbsent(num, 0);\n        counter.put(num, counter.get(num) + 1);\n    }\n    for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n        pq.offer(entry);\n        if (pq.size() > k) {\n            pq.poll();\n        }\n    }\n    int[] result = new int[k];\n    for (int i = 0; i < k; i++) {\n        result[i] = pq.poll().getKey();\n    }\n    return result;\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110478429","body":"# Problem [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/description/)\n\n## Algorithm\n* Use standard binary search to solve the problem.\n* The tricky part is we can use *left <= right* as the while loop condition and do *left = mid + 1* or *right = mid - 1* when target is not found. When the target is not found, we can always move left or right by 1 from mid because *left* will always move to a value larger than target which would be the \"to be inserted\" position of the target.\n\n## Complexity\n* Time Complexity: *O(logN)*.\n* Space Complexity: *O(1)*.\n\n## Code\nLanguage: Java\n``` Java\npublic int searchInsert(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrorz0914":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000216","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans= new ArrayList<>();\n        for(int i=num.length-1;i>=0;i--)\n        {\n            ans.add(0,(num[i]+k)%10);\n            k=(k+num[i])/10;\n        }\n        while(k!=0)\n        {\n            ans.add(0,k%10);\n            k=k/10;\n        }\n        return ans;\n    }\n##复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091815050","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duantao74520":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000316","body":"### 思路：\n\n小学加法，大于10进一，从个位开始加，将结果塞到数组，最终返回数组时，翻转一下数组。\n\n例如【2,1,5】 与 806\n\n1. 遍历数组，初始化进位为0\n\n   5 + 8 + 0 = 11 ，塞1， 进位1。\n\n   1 + 0 + 1 = 2    ，塞2， 进位0\n\n   2 + 8 + 0 = 10  ，塞0， 进位1\n\n   关键在遍历完数组后，k 有可能为0 ，但是进位可能为1.\n\n2. 特殊处理以上情况\n\n   k += 进位\n\n   这样的话，k为0 ，构造成1， k非0，刚好可以进位\n\n3. 遍历剩余的k，每次除10\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret_vec;\n        int up = 0;\n        // 遍历num\n        for (int pos = num.size() - 1 ; pos >= 0; pos--) {\n            int a = num[pos];\n            int b = k % 10;\n            k = k / 10;\n            ret_vec.emplace_back((a + b + up) % 10);\n            up = (a + b + up) /10;\n        }\n        k = k + up; // 防止有进位 k 还等于0的情况\n        while (k > 0) {\n            ret_vec.emplace_back(k % 10 );\n            k = k /10;\n        }\n         std::reverse(ret_vec.begin(), ret_vec.end());\n         return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n1. 空间复杂度 O(1)\n\n2. 时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086631015","body":"### 思路：\n\n维护两个指针，一个代表着离左边的c的位置，一个代表着离右边的c的位置\n\n遍历数组：\n\n1. 从左往右遍历s1，直到找到c，然后赋值左右c。\n2. 再次从左往右遍历s2，开始记录离左右两边最近的c。\n3. 直到s2遍历到c的位置，继续遍历上一个遍历队列s1,直到数组尽头\n4. 继续遍历s2，输出位置\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n       int c_l = -1, c_r = -1;\n        int i = 0, j = 0;\n        vector<int> ret_vec;\n        while (j < s.size()) {\n            for (i ; i < s.size(); i++) {\n                if (s[i] == c) {\n                    c_l = c_r;\n                    c_r = i;\n                    if (c_l == -1) { // 第一个c\n                        c_l = c_r;\n                    }\n\t\t\t\t\ti++;\n                    break;\n                }\n                if (i == s.size()-1) { // 最后一个c\n                    c_l = c_r;\n                }\n            }\n            for (j ; j < i; j++) {\n                ret_vec.emplace_back(min(abs(j - c_l) , abs(j-c_r)));\n            }\n\t\t\tcout << c_l << c_r << i << j <<endl;\n        }\n        return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n时间： o(n)\n\n空间： o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086849106","body":"### 思路：\n\n正常模拟栈的操作，用top代表栈顶，maxSize代表着最大的数组长度\n\n### 代码：\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack =  new vector<int>(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            (*my_stack)[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            top --;\n            return (*my_stack)[top+1];\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++) {\n            (*my_stack)[i] += val;\n        }\n    }\nprivate:\n    vector<int>* my_stack;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n时间： add/top: O(1)  inc:O(N)\n\n空间复杂度： O(N);\n\n### 改进一：\n\n由于只有pop的时候才会取数，那么我们可以存一个add的数组，代表着所有增加的值。\n\n比如：\n\n- 调用了 increment(3, 2)，就把 increment[3] 增加 2。\n- 继续调用 increment(2, 5)，就把 increment[2] 增加 5。\n\n![img](https://tva1.sinaimg.cn/large/0081Kckwly1glwx1ryzxpj31jq0hijte.jpg)\n\n而当我们 pop 的时候：\n\n- 只需要将栈顶元素**加上 increment[cnt - 1]** 即可， 其中 cnt 为栈当前的大小。\n- 另外，我们需要将 increment[cnt - 1] 更新到 increment[cnt - 2]，并将 increment[cnt - 1] 重置为 0。\n\n### 代码：\n\n```\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack.resize(maxSize);\n        add_vec.resize(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            my_stack[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            // s[top] + add[top]\n            int val = my_stack[top] + add_vec[top];\n            // add[top-1] += add[top]\n            if (top >= 1) {\n                add_vec[top -1] += add_vec[top];\n            }\n            add_vec[top] = 0;\n            top --;\n            return val;\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k -1, top);\n        if (limit >= 0) {\n            add_vec[limit] += val;  // 只需要记录需要加的数\n        }\n    }\nprivate:\n    vector<int> my_stack;\n    vector<int> add_vec;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n空间 O(N)\n\n时间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087464857","body":"### 思路：\n\n双指针，用一个指针指向【的后一个， 前面的数字代表的循环的次数，每次从'【'遍历到'】'。\n\n用递归解决多重括号。\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    bool IsWord(const char& c) {\n        return c >= 'a' && c <= 'z';\n    }\n    bool IsNum(const char& c) {\n        return c >= '0' && c <= '9';\n    }\n    string decodeString(string s) {\n        string ret_str;\n        for(size_t i =0 ; i < s.size(); i++) {\n            // 如果是字母直接塞, 循环终止条件\n            if (IsWord(s[i])) {\n                ret_str += s[i];\n                continue;\n            }\n            // 如果是数字，则循环填写\n            int j = i;\n            if (IsNum(s[i])) {\n                int loop_times = s[i] - '0';\n                // 计算遍历次数\n                while(IsNum(s[++j])) {\n                    loop_times = loop_times*10 + (s[j] -'0');\n                }\n                cout << \"loop_times = \" << loop_times << endl;\n                // 找出 【】里面的字母\n                int first_p = j;\n                int num_left_brackets = 1;\n                while(num_left_brackets) {\n                    ++j;\n                    if (s[j] == '[') {\n                        num_left_brackets++;\n                    }\n                    if (s[j] == ']') {\n                        num_left_brackets--;\n                    }\n                }// 退出循环时，j = ]所在的位置\n                cout << \"j = \" << j << endl;\n                // 开始递归遍历\n                for (int k = 0; k < loop_times; k++) {\n                    cout << \"sub_str = \" << s.substr(first_p+1, j-first_p-1) << endl;\n                    ret_str += decodeString(s.substr(first_p+1, j-first_p-1));\n                    cout << \"k = \" << k << endl;\n                    cout << \"ret_str = \" << ret_str << endl;\n                }\n            }\n            i = j; // 防止多塞\n        }\n        return ret_str;\n    }   \n};\n```\n\n### 复杂度：\n\n时间： O(n)\n\n空间： O(1）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088618574","body":"### 思路：\n\n两个栈，push的时候push到s1， pop的时候从s2出，s2没有的时候，将所有的s1push到s2。\n\n### 代码：\n\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if (s2.empty()) {\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int ret_val = s2.top();\n        s2.pop();\n        return ret_val;\n    }\n    \n    int peek() {\n        if (s2.empty()) {\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n    stack<int> s1 , s2;\n};\n```\n\n复杂度：\n\n空间：O(N)\n\n时间:  O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090345080","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n\n作者：zhouzihong\n链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/c-tu-shi-by-zhouzihong-367n/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091822672","body":"### 思路：\n\n最主要的是要找到倒数第k个节点，涉及到链表的，多想想双指针，快慢指针等。\n\n1. 快慢指针找到第k个节点\n\n2. ​        // a b c d e null\n\n   ​        // d e a b c null\n\n   ​        p_quick->next = head; // e->a\n\n   ​        p_head = p_slow->next; // head->d\n\n   ​        p_slow->next = nullptr; // d->nul\n\n### 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0) {\n            return head;\n        }\n        // 获取队列长度\n        int len = 1;\n        ListNode* p_head = head;\n        while(p_head->next != nullptr) {\n            len++;\n            p_head = p_head->next;\n        }\n        k = k %len;\n        \n        // 快慢指针\n        ListNode *p_slow = head, *p_quick = head;\n        while (p_quick->next != nullptr) {\n            if (k <= 0) {\n                p_slow = p_slow->next;\n            }\n            k--;\n            p_quick = p_quick->next;\n        }\n        \n        // a b c d e null\n        // d e a b c null\n        p_quick->next = head; // e->a\n        p_head = p_slow->next; // head->d\n        p_slow->next = nullptr; // d->nul\n        return p_head;\n    }\n};\n```\n\n### 复杂度：\n\n时间： O(N)\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092878240","body":"### 思路：\n\n一定要画图解决。\n\n1. 用哨兵来表示头结点\n2. 结束条件： 当前节点的下一个 和 下下一个都不为空\n\n### 解答：\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 新建一个哨兵节点\n        ListNode org_head;\n        org_head.next = head;\n        ListNode* p_head =  &org_head;\n        // 每次遍历当前节点的后两个节点，直到后面只有一个，或者一个都没有\n        while(p_head->next != nullptr && p_head->next->next != nullptr) {\n            ListNode* node1 = p_head->next , *node2 = p_head->next->next;\n            ListNode* tmp = node2->next;\n            node2->next = node1;\n            node1->next = tmp;\n            p_head->next = node2;\n            p_head = p_head->next->next;\n        }\n        return org_head.next;\n    }\n};\n```\n\n### 复杂度：\n\n时间：O(n)\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094070087","body":"### 思路：\n\n利用递归的方法。\n\n1. 快慢指针找到中点，\n\n   1 2 3 4 5  中点 3\n\n   1 2 3 4 5 6 中点 3\n\n2. 中点的左指针指向 他的左边。  右指针指向右边。\n3. 递归返回值： 返回中间节点。\n4. 递归参数： 头结点，尾结点。\n5. 结束条件： 当前链表全为nullptr的时候\n\n### 代码：\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return getTree(head, nullptr);\n    }\n    TreeNode* getTree(ListNode* head, ListNode* tail) {\n        // 结束条件  \n        if (head == tail) {\n            return nullptr;\n        }\n        // 快慢指针找到中间节点。中间节点= p_slow\n        ListNode *p_slow = head, *p_quick = head;\n        while(p_quick != tail && p_quick->next != tail) {\n            p_slow = p_slow->next;\n            p_quick = p_quick->next->next;\n        }\n        // 创建中间节点\n        TreeNode *t_mid = new TreeNode(p_slow->val);\n        t_mid->left = getTree(head, p_slow);\n        t_mid->right = getTree(p_slow->next, tail);\n        return t_mid;\n    }\n};\n```\n\n### 复杂度：\n\n时间：NLog(N) 每个节点都要遍历，并且都还会有一个二分遍历\n\n空间：LogN 每个二分遍历需要建一个快慢指针","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094199735","body":"### 思路：\n\n两个链表相不相交  一个指针可以从A遍历到尾部，然后又从B遍历到尾部。另一个指针从B遍历到尾部，接着又从A开始。\n\n![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)\n\n即： p_a : 4 1 8 4 5 5 6 1 8(i) 4 5\n\n​\t\tp_b：5 6 1 8 4 5 4 1 8(i) 4 5\n\n相等的点就是相交的点。\n\n遍历结束条件： p_a = null && p_b =null 并且 p_a已经在B分支了\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p_a = headA, *p_b = headB;\n        bool change_a = false, change_b = false;\n        while (!(p_a == nullptr && p_b == nullptr && change_a && change_b)){\n            // 切换条件\n            if (p_a == nullptr && change_a == false) {\n                change_a = true;\n                p_a = headB;\n            }\n            if (p_b == nullptr && change_b == false) {\n                change_b = true;\n                p_b = headA;\n            }\n            if (p_a == p_b) {\n                return p_b;\n            } else {\n                p_a = p_a->next;\n                p_b = p_b->next;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n\n### 复杂度：\n\n时间： O(N)\n\n空间： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095112003","body":"### 思路：\n\n快慢指针，我们可以在两者第一次相遇（p比s多整数环) 后将快指针放回开头，这样二者再次相遇的点一点是环的入口点，\n\n结束条件： 快指针=null  或者 快慢指针相交。\n\n证明：\n\n![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\nSlow:  3  2  0 -4 2\n\nQuick: 3 0 -4 0  2\n\n设 环的长度为B,前序节点的长度为A;\n\nQ=2S\n\n相遇时 Q= S + nb  n为未知数\n\n相减则 Q = 2nb    S =nb\n\n### 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr){\n            return nullptr;\n        }\n        ListNode *s = head, *p = head;\n        while (p != nullptr && p->next != nullptr) {\n            s = s->next;\n            p = p->next->next;\n            if (p == s) {\n                p = head;\n                while (s != p) {\n                    s = s->next;\n                    p = p->next;\n                }\n                return s;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n\n### 复杂度：\n\n时间 O(N) \n\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096846670","body":"// 用hash + 双向链表来做\n//对于 get 操作，首先判断 key 是否存在：\n//如果 key 不存在，则返回 -1−1；\n\n//如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n\n//对于 put 操作，首先判断 key 是否存在：\n\n//如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n//如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\n\nstruct DListNode {\n    int key, val;\n    DListNode* next;\n    DListNode* pre;\n    DListNode():val(0), next(nullptr), pre(nullptr){};\n    DListNode(int key, int val):key(key), val(val), next(nullptr), pre(nullptr){};\n};\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        capacity_ = capacity;\n        // 伪头尾结点\n        head = new DListNode();\n        tail = new DListNode();\n        head->next = tail;\n        tail->pre = head;\n    }\n    \n    int get(int key) {\n        if (list_map_.count(key)) {\n            return list_map_[key]->val;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        // 存在\n        if (list_map_.count(key)) {\n            list_map_[key]->val = value;\n            // 移动当前结点到head 后\n            moveToHead(list_map_[key]);\n        }\n        // 不存在\n        if (size < capacity_) { // 还有容量，头部插\n            DListNode* node = new DListNode(key, value);\n            addToHead(node);\n            list_map_[key] = head->next;\n            size++;\n        } else {\n            DListNode* node =  removeTail();\n            list_map_.erase(node->key);\n            node = new DListNode(key, value);\n            addToHead(node);\n            list_map_[key] = head->next;\n            size++;\n        }\n    }\n    void addToHead(DListNode* node) {\n        node->pre = head;\n        node->next = head->next;\n        head->next->pre = node;\n        head->next = node;\n    }\n    \n    void removeNode(DListNode* node) {\n        node->pre->next = node->next;\n        node->next->pre = node->pre;\n    }\n\n    void moveToHead(DListNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DListNode* removeTail() {\n        DListNode* node = tail->pre;\n        removeNode(node);\n        return node;\n    }\n\nprivate:\n    DListNode *head, *tail;\n    int size = 0;\n    map<int , DListNode*> list_map_;\n    int capacity_;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098157620","body":"### 思路：\r\n\r\n递归：\r\n\r\n maxDepth = max(maxDepth(left), maxDepth(right)) + 1;\r\n\r\n结束条件， root = nullptr;、\r\n\r\n### 代码：\r\n\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        // 递归： maxDepth = max(maxDepth(left), maxDepth(right)) + 1;\r\n        // 结束条件， root = nullptr;\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n### 复杂度：\r\n\r\n时间O(N)\r\n\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099252978","body":"class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        }\n        if (p == nullptr || q == nullptr) {\n            return false;\n        }\n        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100808471","body":"### 思路：\n\n利用DFS递归\n\n递归式： int sum_num =  father_num*10 + root->val;\n\n​\t\t返回 左节点+右节点的和\n\n结束条件： \n\n1. cur = nullptr 即没有该节点，则该节点的为0\n2. 如果左右节点都没有数，则返回当前的总和\n\n### 代码：\n\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root, int father_num) {\n        //结束条件\n        if (root == nullptr) {\n            return 0;\n        }\n        // 递归条件\n        int sum_num =  father_num*10 + root->val;\n        if (root->left == nullptr && root->right == nullptr) {\n            return sum_num;\n        }\n        return sumNumbers(root->left, sum_num) + sumNumbers(root->right, sum_num);\n\n    }\n\n    int sumNumbers(TreeNode* root) {\n        return sumNumbers(root, 0);\n    }\n};\n```\n\n### 复杂度：\n\n时间：O(N)\n\n空间： O(N) 取决于高度，最坏O(N) 链表","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100678150","body":"class Solution {\npublic:\n    int findBottomLeftValue_bfs(TreeNode* root) {\n        queue<TreeNode*> q;\n        TreeNode* ans = NULL;\n        q.push(root);\n        while (!q.empty()) {\n            ans = q.front();\n            int size = q.size();\n            while (size--) {\n                TreeNode* cur = q.front();\n                q.pop();\n                if (cur->left )\n                    q.push(cur->left);\n                if (cur->right)\n                    q.push(cur->right);\n            }\n        }\n        return ans->val;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100811288","body":"### 思路：\n\n利用BFS\n\n常见BFS的套路：层序遍历\n\n```c++\nqueue<TreeNode*> que;\nque.push(tree); // 把第一个节点放进去\nif(que)\nwhile(que.empty()) { // 遍历当前层的所有节点，并把下一层的放入新的队列中\n  TreeNode* node = que.front(); // 第一个出队\n  que.pop();\n\tque(node->left); // 如果有左子树 入队\n  que.push(node->right); // 如果有右子树 入队\n}\n```\n\n本题的思路：只有遍历完上一层节点，才会遍历下一层节点\n\n### 代码：\n\n```\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        // BFS 一层一层的遍历，最下面一层第一个\n        queue<TreeNode*> que;\n        que.push(root);\n        int first_val = 0;\n        while (!que.empty()) {\n            // 弹出第一个\n            queue<TreeNode*> que_new;\n            first_val = que.front()->val;\n            while(!que.empty()) {  // 遍历上一层\n                TreeNode* node = que.front();\n                if (node->left) {\n                    que_new.push(node->left);\n                } \n                if (node->right) {\n                    que_new.push(node->right);\n                }\n                que.pop();\n            }\n            que = que_new;  // 将下一层赋值给上一层\n        }\n        return first_val;\n    }\n};\n```\n\n### 复杂度：\n\n时间O(N)\n\n空间 max O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101474518","body":"### 思路：\n\n1. 用一个vector保存坐标与值。\n\n2. ```\n       struct ValNode {\n           int x;\n           int y;\n           int val;\n       };\n   ```\n\n3. DFS遍历，并将坐标与值写入\n\n4. 按 y x val排序\n\n5. 打印\n\n\n\n### 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    // DFS 遍历所有节点，并且把节点坐标放到暂存区中\n    void DFS(TreeNode* root, int x, int y) {\n        if (root == nullptr) {\n            return;\n        }\n        ValNode val_node{.x = x, .y=y, .val=root->val};\n        dp.emplace_back(val_node);\n        DFS(root->left, x+1, y-1);\n        DFS(root->right, x+1, y+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        DFS(root, 0, 0);\n        // 排序dp 按照  y x val 排序\n        std::sort(dp.begin(), dp.end(), [](const ValNode& a, const ValNode&b){\n            if (a.y < b.y) {\n                return true;\n            } else if (a.y > b.y) {\n                return false;\n            } else {\n                if (a.x < b.x) {\n                    return true;\n                } else if (a.x > b.x) {\n                    return false;\n                } else {\n                    return a.val <= b.val;\n                }\n            }\n        });\n        // 打印\n        vector<vector<int>> ret_vec;\n        int last_y =  -10001;\n        vector<int> tmp_dp;\n        for (const auto& node_val : dp) {\n            if (node_val.y != last_y && !tmp_dp.empty()) {\n                ret_vec.emplace_back(tmp_dp);\n                tmp_dp.clear();\n            }\n            tmp_dp.emplace_back(node_val.val);\n            last_y = node_val.y;\n        }\n        if (!tmp_dp.empty()) {\n            ret_vec.emplace_back(tmp_dp);\n        }\n        return ret_vec;\n    }\nprivate:\n    struct ValNode {\n        int x;\n        int y;\n        int val;\n    };\n    vector<ValNode> dp;\n};\n```\n\n### 复杂度：\n\n时间： O(nLOG(n));\n\n空间： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102731788","body":"思路： \n边遍历边加入。\n代码：\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        map<int, int> hash;\n        for (int i = 0; i < nums.size(); i++) {\n            if (hash.count(target-nums[i])==0) {\n                hash[nums[i]] = i;\n            } else {\n                return vector{hash[target-nums[i]], i};\n            }\n        }\n        return {};\n    }\n};\n复杂度：\n时间：O(N)\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103941352","body":"### 思路：\n\n方案一： hash表 + partial_sort\n\n方案二： hash表 + 小顶堆（只用保存最大的）\n\n方案三： hash表 + 快排\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n// hash + 堆排序\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        map<int, int> hash;\n        // hash 表\n        for (const int& num: nums) {\n            hash[num]++;\n        }\n        // 小顶堆\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> small_queue;\n        for ( auto& [num, size] : hash) {\n            if (small_queue.size() < k) {\n                small_queue.push(make_pair(size, num));\n            } else if (size > small_queue.top().first) {\n                small_queue.pop();\n                small_queue.push(make_pair(size, num));\n            }\n        }\n        // 输出\n        vector<int> ret_vec;\n        while(small_queue.size()) {\n            ret_vec.emplace_back(small_queue.top().second);\n            small_queue.pop();\n        }\n        return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n时间： O(n)\n\n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105312759","body":"### 思路：\n\n1.  统计每个节点与其他节点的距离\n\n2. ​        // 计算以当前节点为中心，有多少个回旋镖。\n\n   ​        // 例如当前节点与其他节点的距离为 0 1 2 2 3 3 3\n\n   ​        // 则 当前节点的回旋镖有 A22 + A23 = 2+6 = 8个。  A23是距离为3的，选任意两个，并且有序的\n\n### 代码：\n\n```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        // 统计每个节点与其他节点的距离\n        vector<vector<int>> len_vec;\n        for (const auto& point1 : points) {\n            std::vector<int> len;\n            for(const auto& point2: points) {\n                len.emplace_back(pow((point1[0]- point2[0]), 2) + pow((point1[1]- point2[1]), 2));\n            }\n            len_vec.push_back(len);\n        }\n        // 计算以当前节点为中心，有多少个回旋镖。\n        // 例如当前节点与其他节点的距离为 0 1 2 2 3 3 3\n        // 则 当前节点的回旋镖有 A22 + A23 = 2+6 = 8个。  A23是距离为3的，选任意两个，并且有序的\n        int total_len = 0;\n        for (const auto& vec : len_vec) {\n            map<int, int> len_2_size;\n            for (int num : vec) {\n                len_2_size[num] ++;\n            }\n            for (const auto [len ,size] : len_2_size) {\n                if (size >=2) {\n                    total_len += size*(size-1);\n                }\n            }\n        }\n        return total_len;\n    }\n};\n\n```\n\n### 复杂度：\n\n时间 O(N2)\n\n空间 O(N2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1107457098","body":"思路:滑动窗口\n代码：\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if (s.empty()) {\n            return 0;\n        }\n        std::vector<int> str_index(256, -1); // 存放滑动窗口的字符与下标的映射。\n        int first = 0, end = 0;\n        int max_len = 1;\n        while (end < s.size()) {\n            // 如果序列中已有\n            if (str_index[s[end]] >= 0) {\n                while(first <= str_index[s[end]]) {\n                    cout << \"del \" << s[first] << endl;\n                    str_index[s[first]] = -1;\n                    first++;\n                }\n            }\n            str_index[s[end]] = end;\n            cout << \"add \"<< s[end] << endl;\n            max_len = max(max_len, end-first+1);\n            end++;\n        }\n        return max_len;\n    }\n};\n复杂度：\n时间： O(n)\n空间：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107471171","body":"### 思路：\n\n1. 如果子串的字符数能够满足要求，判断里面的单词是否符合要求\n\n   1. 将words保存到hash1表中，key为word，value为出现的次数\n\n      ![image.png](https://pic.leetcode-cn.com/b8cb6bc68dc678d742b758afd94ffb63bb84818464d5c8df9b03b7a1067c4537-image.png)\n\n   2. 遍历子串s，遍历每个单词，保存至hash2表中。\n\n      1. 如果单词不在hash表1中，则返回false\n      2. 如果单词的数量超过了hash表1的数量\n\n### 代码：\n\n```\nclass Solution {\npublic:\n    bool IsVectorEque(const string& s) {\n        //cout << \"s = \" << s << endl;\n         std::map<string, int> hash2;\n        for (int i =0 ;i <= s.size() - word_len; i+=word_len) {\n            string sub_str = s.substr(i, word_len);\n           // cout << \"sub_str = \" << sub_str << endl;\n            if (hash1.find(sub_str) != hash1.end()) { // 单词次数大于当前已有次数\n                hash2[sub_str] ++;\n                if (hash2[sub_str] > hash1[sub_str] ) {\n                   // cout << \"s = \" << s << \" key > \" << sub_str << endl;\n                    return false;\n                }\n            } else { // 单词不存在\n              //  cout << \"s = \" << s << \" key not in \" << sub_str << endl;\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> findSubstring(string s, vector<string>& words) {\n        // 字符串的hash表\n        int word_num = 0;\n        if (words.size() > 0) {\n            word_len = words[0].size();\n        }\n        for (const auto& word : words) {\n            hash1[word]++;\n            word_num += word_len;\n        }\n        std::vector<int> ret_vec;\n        if (s.size() < word_num) {\n            return ret_vec;\n        }\n        for (int i =0 ; i<= s.size() - word_num; i++) {\n            if (IsVectorEque(s.substr(i, word_num))) {\n                ret_vec.emplace_back(i);\n            }\n        }\n        return ret_vec;\n    }\nprivate:\n    std::map<string, int> hash1; // 单词与频次的hash表 \n    int word_len;        \n};\n```\n\n### 复杂度：\n\n时间：O(N2)\n\n空间： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107858697","body":"### 思路：\n\n1. 看到整除考虑同余定理。\n   1. 几个整数除以同一个除数，若余数相同，则这几个整数同余。\n   2. 余数的和决定和的余数。\n   3. 余数的差决定差的余数。\n\n2. 看到连续子数组就可以考虑用前缀和进行优化\n   1. https://www.jianshu.com/p/d0dabea38302\n   2. 比如求连续数组加起来等于k，那么就可以构造一个前缀和的数组，用双指针相减便可以得到。\n\n3. 再回来看题目，1+8+6+4+5 = 24 ，24除以7余3，\n   1. 那么该题可以改成，找到最小连续数组，使得他的和除以7余3。\n   2. 同理和数的余，等于余数的合，那么我找(pre[j]-pre[i])%7 = 3\n   3. 那我我们只需要找到pre[j]%7 - pre[i] = 3;\n   4. 利用hash,将除以7的余数保存下来\n\n```\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        // 前缀和\n        std::vector<long int> presum;\n        long int last_sum = 0;\n        for (auto & num : nums) {\n            last_sum += num;\n            presum.emplace_back(last_sum);\n        }\n        int diff_yushu = last_sum % p;\n        if (diff_yushu % p == 0) return 0;\n        // 利用两数之和的原理，求前缀和的余数差等于3\n        int len = INT_MAX;\n        map<int, int> hash;\n        hash.emplace(0,-1);\n        for (int i = 0; i < presum.size(); i++) {\n            int cur_yushu = presum[i] % p;\n            int target_yushu = cur_yushu - diff_yushu >= 0 ? cur_yushu - diff_yushu : cur_yushu - diff_yushu + p;\n            if ( hash.find(target_yushu) != hash.end()) {\n                len = min(len, i - hash[target_yushu]);\n            } \n            hash[cur_yushu] = i;\n        }\n        if (len == INT_MAX || len == nums.size()) {\n            len = -1;\n        }\n        return len;\n\n    }\n};\n```\n\n### 复杂度：\n\n时间：O(N)\n\n空间： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108678101","body":"class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        // 快慢指针，如果是奇数，返回慢指针，如果是偶数，返回慢指针与慢指针后一个\n        if (head->next == nullptr || head ==nullptr) {\n            return head;\n        }\n        ListNode *p_slow = head, *p_quick = head;\n        while (p_quick->next != nullptr) {\n            p_slow = p_slow->next;\n            if (p_quick->next->next == nullptr) {\n                return p_slow;\n            }\n            p_quick = p_quick->next->next;\n\n        }\n        return p_slow;\n\n    }\n};\n\n复杂度：\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109873985","body":"思路：\n双指针\n1. 如果p2 != p1 那么将p2的值赋给p1下一格\n2. 如果p2 = p1 那么 p2后移 p1不动\n\n代码：\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.size() <= 1) {\n            return nums.size();\n        }\n        int p1 = 0, p2 = 1;\n        int len = 1;\n        for (;p2 < nums.size();) {\n            if (nums[p1] != nums[p2]) {\n                nums[p1 + 1] = nums[p2];\n                p1 ++;\n                p2 ++;\n                len ++;\n            } else {\n                p2++;\n            }\n        }\n        return len;\n    }\n};\n\n复杂度：\n时间 O(N)\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"omegalzx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086006617","body":"~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] num2 = convertNumToArray(k);\n        List<Integer> result = new ArrayList<>();\n        int i = num.length - 1;\n        int j = num2.length - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (j >= 0) {\n                sum += num2[j];\n            }\n            result.add(sum % 10);\n            carry = sum / 10;\n            i--;\n            j--;\n        }\n        if (carry > 0) {\n            result.add(carry);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n\n    private int[] convertNumToArray(int num) {\n        List<Integer> result = new LinkedList<>();\n        while (num > 0) {\n            result.add(num % 10);\n            num /= 10;\n        }\n        Collections.reverse(result);\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n~~~\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086682692","body":"~~~java\r\nclass CustomStack {\r\n\r\n    private final int maxSize;\r\n    private final int[] stack;\r\n    private final int[] inc;\r\n    private int top = -1;\r\n    private final int bottom = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n        inc = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top == maxSize - 1) {\r\n            return;\r\n        }\r\n        stack[++top] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (top < bottom) {\r\n            return -1;\r\n        }\r\n        int res = stack[top] + inc[top];\r\n        if (top > bottom) {\r\n            inc[top - 1] += inc[top];\r\n        }\r\n        inc[top] = 0;\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k - 1, top);\r\n        if (i >= bottom) {\r\n            inc[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087645644","body":"~~~java\nint ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++)));\n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuilder t = new StringBuilder();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuilder ret = new StringBuilder();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(List<String> v) {\n        StringBuilder ret = new StringBuilder();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088766445","body":"~~~java\r\nclass MyQueue {\r\n\r\n    private final Stack<Integer> stack1 = new Stack<>();\r\n    private final Stack<Integer> stack2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int size = stack2.size();\r\n        if (size == 0) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        int size = stack2.size();\r\n        if (size == 0) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n~~~\r\n- pop O(n)\r\n- peek O(n)\r\n- push O(1)\r\n- empty O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090427467","body":"# 思路\r\n\r\n- 贪心算法\r\n- 对于数组[a0,an]，易得\r\n  - 对于任意的[ai, aj]，当 max(aj+1,an) <= max(ai,aj)，且j>i，则[ai,aj]为排序块\r\n  - 对于任意的[ai, aj]，当max(ai,aj) <= ak，且k>j>i，则[ai,ak]为排序块的子块\r\n\r\n\r\n# 代码\r\n\r\n~~~java\r\npublic int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.peek()) {\r\n                int topValue = stack.pop();\r\n                while (!stack.isEmpty() && num < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(topValue);\r\n            } else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n~~~\r\n\r\n- 时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091757991","body":"~~~java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        // 计算链表长度\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        // 计算目标链表最后一个节点索引\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add-- > 0) {\r\n            iter = iter.next;\r\n        }\r\n        ListNode ret = iter.next;\r\n        // 断开环链表\r\n        iter.next = null;\r\n        return ret;\r\n    }\r\n}\r\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072448","body":"~~~java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        List<Integer> list = new ArrayList<>();\r\n        while (head != null) {\r\n            list.add(head.val);\r\n            head = head.next;\r\n        }\r\n        return helper(list, 0, list.size() - 1);\r\n    }\r\n\r\n    private TreeNode helper(List<Integer> list, int start, int end) {\r\n        if (start > end) {\r\n            return null;\r\n        }\r\n        int mid = (start + end) / 2;\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        root.left = helper(list, start, mid - 1);\r\n        root.right = helper(list, mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094276234","body":"~~~java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode p = headA;\r\n        ListNode q = headB;\r\n\r\n        while (p != q) {\r\n            p = p == null ? headB : p.next;\r\n            q = q == null ? headA : q.next;\r\n        }\r\n        return p;\r\n    }\r\n}\r\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1097029072","body":"~~~java\r\nclass LRUCache {\r\n    private final int capacity;\r\n    private final Map<Integer, Node> map;\r\n    private final LinkedList<Node> linkedList;\r\n\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<>();\r\n        linkedList = new LinkedList<>();\r\n    }\r\n\r\n    public int get(int key) {\r\n        Node node = map.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        linkedList.remove(node);\r\n        linkedList.addFirst(node);\r\n        return node.getValue();\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        // 当前key已经存在，删除当前元素\r\n        Node node = map.get(key);\r\n        if (node != null) {\r\n            linkedList.remove(node);\r\n        }\r\n        // 将该值放在第一个位置\r\n        Node newNode = new Node(key, value);\r\n        linkedList.addFirst(newNode);\r\n        // 如果当前容量已满，删除最后一个元素\r\n        if (linkedList.size() > capacity) {\r\n            Node elder = linkedList.removeLast();\r\n            map.remove(elder.getKey());\r\n        }\r\n        // map中新建从key到Node的映射\r\n        map.put(key, newNode);\r\n    }\r\n}\r\n\r\nclass Node {\r\n    private final int key;\r\n    private final int value;\r\n    private Node next;\r\n    private Node pre;\r\n\r\n    public Node(int key, int value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    public void setNext(Node next) {\r\n        this.next = next;\r\n    }\r\n\r\n    public int getKey() {\r\n        return key;\r\n    }\r\n\r\n    public int getValue() {\r\n        return value;\r\n    }\r\n\r\n    public Node getNext() {\r\n        return next;\r\n    }\r\n\r\n    public Node getPre() {\r\n        return pre;\r\n    }\r\n\r\n    public void setPre(Node pre) {\r\n        this.pre = pre;\r\n    }\r\n\r\n~~~","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098167515","body":"- dfs 递归\r\n~~~java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099230088","body":"- 递归判断左右子树是否相等\r\n~~~java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n~~~","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1105239258","body":"~~~java\r\npublic int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> occurrences = new HashMap<>();\r\n        for (int num : nums) {\r\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\r\n        }\r\n\r\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\r\n        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(m -> m[1]));\r\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\r\n            int num = entry.getKey();\r\n            int count = entry.getValue();\r\n            if (queue.size() == k) {\r\n                if (queue.peek()[1] < count) {\r\n                    queue.poll();\r\n                    queue.offer(new int[]{num, count});\r\n                }\r\n            } else {\r\n                queue.offer(new int[]{num, count});\r\n            }\r\n        }\r\n        int[] ret = new int[k];\r\n        for (int i = 0; i < k; ++i) {\r\n            ret[i] = queue.poll()[0];\r\n        }\r\n        return ret;\r\n    }\r\n~~~","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105331810","body":"~~~java\r\npublic int numberOfBoomerangs(int[][] points) {\r\n        int count = 0;\r\n        for (int[] p : points) {\r\n            Map<Integer, Integer> map = new HashMap<>();\r\n            for (int[] q : points) {\r\n                int computer = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                map.put(computer, map.getOrDefault(computer, 0) + 1);\r\n            }\r\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n                int m = entry.getValue();\r\n                count += m * (m - 1);\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n~~~\r\n- 时间复杂度 O(N^2)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108625074","body":"> 双指针\r\n~~~java\r\npublic ListNode middleNode(ListNode head) {\r\n        ListNode node1 = head;\r\n        ListNode node2 = head;\r\n\r\n        while (node2 != null && node2.next != null) {\r\n            node1 = node1.next;\r\n            node2 = node2.next.next;\r\n        }\r\n        return node1;\r\n    }\r\n~~~\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109252373","body":"~~~java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int p = 0;\r\n        int length = 0;\r\n\r\n        for (int i = 0; i < nums.length - 1; i++) {\r\n            if (nums[i] != nums[i + 1]) {\r\n                nums[++p] = nums[i + 1];\r\n                length++;\r\n            }\r\n        }\r\n        return ++length;\r\n    }\r\n}\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1109993035","body":"~~~java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int len = nums.length;\r\n        if(len == 0){\r\n            return -1;\r\n        }\r\n        if(nums[len - 1] < target){\r\n            return len;\r\n        }\r\n        int left, right, mid;\r\n        left = 0;\r\n        right = len - 1;\r\n        while(left < right){\r\n            mid = (left + right) >>> 1;\r\n            if(nums[mid] == target){\r\n                return mid;\r\n            }else if(nums[mid] < target){\r\n                left = mid + 1;\r\n            }else{\r\n                right = mid;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vivixu-qiqi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007071","body":"```\r\nvar addToArrayForm = function(num, k) {\r\n    let sum = k;\r\n    let index = num.length - 1;\r\n    let result = '';\r\n    let resultArr = [];\r\n    while(index >= 0 || sum > 0) {\r\n        if(index >= 0) {\r\n            sum += num[index];\r\n        }\r\n        result += sum % 10;\r\n        sum = Math.floor(sum / 10);\r\n        index--;\r\n    }\r\n    for(let i = result.length - 1; i >= 0; i--) {\r\n        resultArr.push(+result[i]);\r\n    }\r\n    return resultArr;\r\n};\r\n```\r\nTime Complexity：O(max(n,logk))\r\nSpace Complexity：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646668","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [];\r\n        for i in range(len(s)):\r\n            if (s[i] == c):\r\n                result.append(0)\r\n                continue\r\n            for left in range(i, -1, -1):\r\n                dist1 = 0\r\n                if (s[left] == c):\r\n                    dist1 = i - left\r\n                    break\r\n            for right in range(i, len(s)):\r\n                dist2 = 0\r\n                if (s[right] == c):\r\n                    dist2 = right - i\r\n                    break\r\n            if (dist1 == 0):\r\n                result.append(dist2)\r\n            if (dist2 == 0):\r\n                result.append(dist1)   \r\n            if (dist1 <= dist2 and dist1 != 0):\r\n                result.append(dist1)\r\n            if (dist1 > dist2 and dist2 != 0):\r\n                result.append(dist2)    \r\n\r\n        return result;\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874419","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize\r\n  this.size = 0\r\n  this.stack = []\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.size < this.maxSize) {\r\n    this.stack.push(x)\r\n    this.size++\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.size === 0) {\r\n    return -1\r\n  } else {\r\n    this.size--\r\n    return this.stack.pop()\r\n  }\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.size); i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n```\r\nO(1) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087690400","body":"```\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let res = '';\r\n    let i = 0;\r\n\r\n    while (i < s.length) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i++]);\r\n            continue;\r\n        }\r\n\r\n        let str = '', n = '', segment = '';\r\n        while (stack[stack.length-1] !== '[') {\r\n            str = stack.pop() + str;\r\n        }\r\n\r\n        stack.pop();\r\n        while (!isNaN(stack[stack.length-1])) {\r\n            n = stack.pop() + n;\r\n        }\r\n        for (let j = 0; j < Number(n); j++) {\r\n            segment = str + segment;\r\n        }\r\n        stack.push(segment);\r\n        i++;\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088839886","body":"```\r\nvar MyQueue = function() {\r\n    s1 = []\r\n    s2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    s1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(s2.length === 0) while(s1.length != 0) s2.push(s1.pop())\r\n    return s2.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return s2.length === 0 ? s1[0] : s2[s2.length - 1] \r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return s1.length === 0 && s2.length === 0\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090401575","body":"```\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    a = arr[i];\r\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack && stack[stack.length - 1] > a) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(a);\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091773890","body":"```\r\nvar rotateRight = function(head, k) {\r\n    \r\n    let list=head;\r\n    let len=0; \r\n    while(list){list=list.next; len++;}\r\n    \r\n    k=k%len;\r\n    if(k==0 || head===null){return head;}\r\n    \r\n    let index=len-k-1;\r\n    list=head;\r\n    \r\n    while(index){list=list.next; index--;}\r\n    let newNode=list.next;\r\n    list.next=null;\r\n    \r\n    list=newNode;\r\n    while(list.next){list=list.next;}\r\n    list.next=head;\r\n    \r\n    return newNode;\r\n};\r\n```\r\nTime : O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092634980","body":"```\r\nconst swapPairs = function (head) {\r\n\tconst pre = new ListNode(0, head);\r\n\tif (!head || !head.next) {\r\n\t\treturn head;\r\n\t}\r\n\tlet cur = pre;\r\n\tlet nextTwo = null,\r\n\t\tnextOne = null;\r\n\r\n\twhile (cur.next && cur.next.next) {\r\n\t\tnextTwo = cur.next.next;\r\n\t\tnextOne = cur.next;\r\n\t\tcur.next = nextTwo;\r\n\t\tnextOne.next = nextTwo.next;\r\n\t\tnextTwo.next = nextOne;\r\n\r\n\t\tcur = nextOne;\r\n\t}\r\n\treturn pre.next;\r\n};\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094063622","body":"```\r\nvar sortedListToBST = function(head) {\r\n    return toBST(toArray(head))\r\n};\r\n\r\nconst toArray = head => {\r\n    const arr = []\r\n    while (head) {\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n    return arr\r\n}\r\n\r\nconst toBST = (arr, l = 0, r = arr.length) => {\r\n    if (l === r) return null\r\n    const m = Math.floor((l + r) / 2)\r\n    const root = new TreeNode(arr[m])\r\n    root.left = toBST(arr, l, m)\r\n    root.right = toBST(arr, m + 1, r)\r\n    return root\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094301377","body":"```\r\nconst getIntersectionNode = function (headA, headB) {\r\n\tif (!headA || !headB) {\r\n\t\treturn null;\r\n\t}\r\n\tlet curA = headA;\r\n\tlet curB = headB;\r\n\tlet diff = 0;\r\n\tlet lenA = 1;\r\n\tlet lenB = 1;\r\n\tlet result = null;\r\n\twhile (curA.next) {\r\n\t\tcurA = curA.next;\r\n\t\tlenA++;\r\n\t}\r\n\twhile (curB.next) {\r\n\t\tcurB = curB.next;\r\n\t\tlenB++;\r\n\t}\r\n\tcurA = headA;\r\n\tcurB = headB;\r\n\tif (lenA < lenB) {\r\n\t\t[curA, curB] = [curB, curA];\r\n\t\t[lenA, lenB] = [lenB, lenA];\r\n\t}\r\n\tdiff = lenA - lenB;\r\n\twhile (diff-- > 0) {\r\n\t\tcurA = curA.next;\r\n\t}\r\n\twhile (curB) {\r\n\t\tresult = curA === curB ? curA : null; //x先比较当下元素\r\n\t\tif (result === curA) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcurA = curA.next;\r\n\t\tcurB = curB.next;\r\n\t}\r\n\treturn result;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094935010","body":"```\r\nvar detectCycle = function(head) {\r\n   if (!head || !head.next) return null;\r\n\tlet slow = head;\r\n\tlet fast = head;\r\n\tlet meetNode, startIndex;\r\n\twhile (fast && fast.next) {\r\n\t\tslow = slow.next; //慢指针走一步\r\n\t\tfast = fast.next.next; //快指针走两步\r\n\t\tif (slow === fast) { //相遇\r\n\t\t\tmeetNode = slow;\r\n\t\t\tstartIndex = head;\r\n\t\t\twhile (meetNode !== startIndex) { //一个指针在head，另一个指针在相遇点，它们相遇即为起始点\r\n\t\t\t\tmeetNode = meetNode.next;\r\n\t\t\t\tstartIndex = startIndex.next;\r\n\t\t\t}\r\n\t\t\treturn startIndex;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096597129","body":"```\r\nclass Node {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.next = null;\r\n        this.prev = null;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity;\r\n        this.cache = {};\r\n        this.count = 0;\r\n        this.head = new Node(0,0);\r\n        this.tail = new Node(0,0);\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n    }\r\n    \r\n    get(key) {\r\n        if (!(key in this.cache)) return -1;\r\n        const node = this.cache[key];\r\n        this.remove(node);\r\n        this.add(node);\r\n        return node.value;\r\n    }\r\n    \r\n    put(key, value){\r\n        const node = new Node(key, value);\r\n        if (!(key in this.cache)) {\r\n            this.add(node);\r\n        } else {\r\n            this.remove(this.cache[key]);\r\n            this.add(node);\r\n        }\r\n        if (this.count > this.capacity) {\r\n            this.remove(this.head.next);\r\n        }\r\n    }\r\n    \r\n    add(node){\r\n        this.cache[node.key] = node;\r\n        this.count++;\r\n        node.prev = this.tail.prev;\r\n        this.tail.prev.next = node;\r\n        node.next = this.tail;\r\n        this.tail.prev = node;\r\n    }\r\n    \r\n    remove(node){\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        node.prev = null;\r\n        node.next = null;\r\n        delete this.cache[node.key];\r\n        this.count--;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1099083563","body":"```\r\nvar maxDepth = function(root) {\r\n    if(root == null)\r\n        return 0\r\n    return Math.max(maxDepth(root.left)+1, maxDepth(root.right)+1)\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099084923","body":"```\r\nvar isSameTree = function(p, q) {\r\n    const pValues = helper(p);\r\n    const qValues = helper(q);\r\n    \r\n    if (pValues.length !== qValues.length) return false;\r\n    \r\n    // check each value is same\r\n    for (let i = 0; i < qValues.length; i++) {\r\n        if (qValues[i] !== pValues[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\n// return value list of node\r\nconst helper = (node) => {;\r\n    if (node === null) return [null];\r\n    const leftValues = helper(node.left);\r\n    const rightValues = helper(node.right);                      \r\n    \r\n    return [node.val, ...leftValues, ...rightValues];\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100179978","body":"```\r\nvar sumNumbers = function(root, path = '') {\r\n    if(root.left === null && root.right === null) return Number(`${path}${root.val}`);\r\n    if(root.left === null) return sumNumbers(root.right, `${path}${root.val}`);\r\n    if(root.right === null) return sumNumbers(root.left, `${path}${root.val}`);  \r\n    return sumNumbers(root.left, `${path}${root.val}`) + sumNumbers(root.right, `${path}${root.val}`)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100684112","body":"```\r\nvar findBottomLeftValue = function(root) {\r\n    const store = {val: -1, size: 0};\r\n    helper(root, 0, store);\r\n    return store.val;\r\n};\r\n\r\nfunction helper(root, level, store){\r\n    if(!root) return null;\r\n    \r\n    if(store.size === level){\r\n        store.val = root.val;\r\n        store.size++;\r\n    }\r\n    \r\n    helper(root.left, level + 1, store);\r\n    helper(root.right, level + 1, store);\r\n    \r\n    return null;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100885098","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar serialize = function(root) {\r\n  let sb = [];\r\n  const dfs= (node) => {\r\n    if (node === null) {\r\n      sb.push(\"null\");\r\n      return;\r\n    }\r\n    sb.push(node.val);\r\n    dfs(node.left);\r\n    dfs(node.right);\r\n  };\r\n  dfs(root);\r\n  return sb.join(',');\r\n};\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n  let nodes = data.split(',');\r\n  let index = 0\r\n  const dfsBuild = () => {\r\n    if (nodes[index] === \"null\") {\r\n      index += 1\r\n      return null;\r\n    }\r\n    \r\n    let currentNode = new TreeNode(Number(nodes[index++]));\r\n    currentNode.left = dfsBuild();\r\n    currentNode.right = dfsBuild();\r\n    return currentNode;\r\n  };\r\n  return dfsBuild();\r\n};\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\nTime: O(n)\r\nSpace: O(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101430125","body":"```\r\nvar verticalTraversal = function(root) {\r\n    if(!root) return [];\r\n    let queue = [[root, 0, 0]];\r\n    let objMap = new Map();\r\n    let min = Infinity;\r\n    let max = -Infinity;\r\n    let finalArr = [];\r\n    while(queue.length > 0) {\r\n        let first = queue.pop();\r\n        let nodeObj = first[0];\r\n        let scaleLevel = first[1];\r\n        let depth = first[2];\r\n        min = Math.min(scaleLevel, min);\r\n        max = Math.max(scaleLevel, max);\r\n        if(objMap.has(scaleLevel)) {\r\n            let arr = objMap.get(scaleLevel);\r\n            arr.push([nodeObj, depth]);\r\n            objMap.set(scaleLevel, arr);\r\n        } else {\r\n            objMap.set(scaleLevel, [[nodeObj, depth]]);\r\n        }\r\n        if(nodeObj.left) {\r\n            queue.unshift([nodeObj.left, scaleLevel-1, depth+1]);\r\n        }\r\n        if(nodeObj.right) {\r\n            queue.unshift([nodeObj.right, scaleLevel+1, depth+1]);\r\n        }\r\n    };    \r\n    for(let i=min; i<=max; i++) {\r\n        let arr = objMap.get(i);\r\n        arr.sort((a, b) => {\r\n            if(a[1] === b[1]) {\r\n                return a[0].val - b[0].val;\r\n            }\r\n            return a[1] - b[1];\r\n        })\r\n        arr = arr.map((elem) => elem[0].val);\r\n        finalArr.push(arr);\r\n    }\r\n    return finalArr;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102793421","body":"```\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = function(nums, target) {\r\n    const myMap = new Map();\r\n    \r\n    // Map each number in nums to its index\r\n    for(let i = 0; i < nums.length; ++i){\r\n        myMap.set(nums[i], i);\r\n    }\r\n    \r\n    // Let's find the answer ....\r\n    for(let i = 0; i < nums.length; ++i){\r\n        const complement = target - nums[i];\r\n        \r\n        if(myMap.has(complement)){\r\n            const j = myMap.get(complement);\r\n            if(i !== j){\r\n                return [i, j];    \r\n            }\r\n        }\r\n    }\r\n    \r\n    return [-1, -1];\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106595455","body":"```\r\nfunction lengthOfLongestSubstring() {\r\n  if (s.length === 0) return 0;\r\n  const map = new Map();\r\n  let i = 0;\r\n  let j = 0;\r\n  let totalLen = 0;\r\n  \r\n  while (j < s.length) {\r\n    const curr = map.get(s[j]);\r\n    if (curr !== undefined && curr >= i) { \r\n      i = curr + 1;\r\n    }\r\n    \r\n    totalLen = Math.max(totalLen, j - i);\r\n    \r\n    map.set(s[j], j);\r\n    j++;\r\n  }\r\n  \r\n  return totalLen + 1;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107522772","body":"```\r\nvar findSubstring = function(s, words) {\r\n    let totalCharCount = 0\r\n    let map = new Map()\r\n    \r\n    let wordLength = words[0].length\r\n    let wordCount = words.length\r\n    \r\n    let slideWindow = wordLength * wordCount\r\n    \r\n    for (let word of words) {\r\n        map.has(word) ? map.set(word, map.get(word) + 1) : map.set(word, 1)\r\n    }\r\n    \r\n    let leftIndex = 0\r\n    let rightIndex = slideWindow - 1\r\n    let result = []\r\n    \r\n    const helper = (tempStr) => {\r\n        let visited = new Map()\r\n        \r\n        for (let i = 0; i < tempStr.length; i+= wordLength) {\r\n            let word = tempStr.substr(i, wordLength)\r\n            \r\n            visited.has(word) ? visited.set(word, visited.get(word) + 1) : visited.set(word, 1)\r\n        }\r\n        \r\n        for (let [key, val] of visited) {\r\n            if (map.get(key) != val) return false\r\n        }\r\n        \r\n        return true\r\n    }\r\n    \r\n    while (rightIndex < s.length) {\r\n        \r\n        if (rightIndex - leftIndex + 1 == slideWindow) {\r\n            let tempStr = s.substring(leftIndex, rightIndex + 1)\r\n            \r\n            if (helper(tempStr)) result.push(leftIndex)\r\n            \r\n            leftIndex++\r\n        }\r\n        \r\n        rightIndex++\r\n    }\r\n    \r\n    return result\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109933996","body":"```\r\nconst removeDuplicates = function (nums) {\r\n\tlet slowIndex = 0;\r\n\tfor (let fastIndex = 1; fastIndex < nums.length; fastIndex++) {\r\n\t\tif (nums[fastIndex] !== nums[slowIndex]) {\r\n\t\t\tslowIndex++;\r\n\t\t\tnums[slowIndex] = nums[fastIndex];\r\n\t\t}\r\n\t}\r\n\treturn slowIndex + 1;\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112299151","body":"```\r\nvar maxSlidingWindow = function(nums, k) {\r\n    const q = [];\r\n    const res = [];\r\n    \r\n    let l = 0;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        while (q && nums[q[q.length - 1]] <= nums[i]) {\r\n            q.pop();\r\n        }\r\n        q.push(i); // we will push indices which will make it easier to compare q values with window pointers\r\n\r\n        // if first element out of bounce\r\n        if (l > q[0]) {\r\n            q.shift();\r\n        }\r\n        // will get the window size\r\n        if (l === i - k + 1) {\r\n            // push first element from our q\r\n            res.push(nums[q[0]]);\r\n            // shrink window\r\n            l++;\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113465665","body":"```\r\nvar findJudge = function(n, trust) {\r\n    let trustee = {};\r\n    let trusted = {};\r\n    if(n === 1){\r\n        return 1;\r\n    }\r\n    for (let i = 0; i<= trust.length-1; i++){\r\n        if(trusted[trust[i][1]] !== undefined){\r\n            trusted[trust[i][1]] += 1 ;\r\n        }\r\n        else{\r\n            trusted[trust[i][1]] = 1;\r\n        }\r\n        if(trustee[trust[i][0]] !== undefined){\r\n            trustee[trust[i][0]] += 1 ;\r\n        }\r\n        else{\r\n            trustee[trust[i][0]] = 1;\r\n        }\r\n          \r\n    }\r\n    for(keys in trusted){\r\n        if(trusted[keys] === n-1 && !trustee[keys]){\r\n            return keys;\r\n        }\r\n    }\r\nreturn -1;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kwdfw":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007092","body":"Day1\n\n[989、数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n#javascript\n## 思路\n1、类似现实中的加法题，取数组和数字的对应位相加并加上进位\n\n2、若相加和大于9，则用carry记录下进位为1\n\n3、算完一直就输入到数组中一位\n\n4、不断循环，从最后一位一直到第一位\n\n5、反转数组\n\n#### 处理特殊示例\n1、相加的结果比原来的位数多一位，如990+100=1090，需要在循环结束后单独判断再加一位\n\n2、数组的位数比数字的位数少，如0+23，按照循环会造成数组越界，需要加判断条件，越界就将值置为0\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let carry=0//记录进位\n    let ru=[]//最终返回的数组\n    let i=num.length-1//循环计数器\n    let result//每一位的结果\n    while(i>-1||k!=0){//||条件保证任意位数的情况下都可以进入循环\n        const x= i>=0? num[i]:0//解决数组和数字位数不同的问题\n        const y=k!=0 ? k%10:0\n        result=x+y+carry//得到某位的值\n        if(result>9){//若大于9，则保留进位，并输入到数组中\n            carry=1\n            ru.push(result%10)\n        }\n        else{//若小于等于9，则不保留进位，并输入到数组中\n            carry=0\n            ru.push(result)\n        }\n        k=Math.floor(k/10)//下取整，有时会自动进位\n        i--//推进循环\n    }\n    if(carry==1) ru.push(1)//解决相加结果比原来多一位\n    return ru.reverse()//反转数组\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653607","body":"Day2\n\n[821、数组形式的整数加法](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n#javascript\n## 思路\n1、遍历数组\n\n2、对于每个字符都分别向左和右查找c\n\n3、对比左和右的长度，取最小值填入数组中\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n    var answer=Array(s.length).fill(0);//将数组中填满0\n    for(let i=0;i<s.length;i++){\n      if (s[i] === c) continue;//若该位置与字符相同，则不用管\n      let short=Infinity\n      for(let j=i;j<s.length;j++){\n          if(s[j]===c){\n              short=Math.min(short,j-i)\n              break\n          }\n      }  \n      for(let k=i;k>-1;k--){\n          if(s[k]===c){\n               short=Math.min(short,i-k)\n               break\n          }\n      }\n      answer[i]=short\n    }\n    return answer\n};\n```\n## 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894389","body":"Day3\n\n[1381、设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/submissions/)\n\n#javascript\n## 思路\n1、设置一个辅助数组inc\n\n2、调用增量函数的时候，用inc记录增加的数和值\n\n3、执行pop操作的时候，通过inc实现增加的值(利用栈的操作特性，减少了时间复杂度)\n\n## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nlet increments=[]//记录inc函数的传入值\n\n\nvar CustomStack = function(maxSize) {\n    this.max=maxSize\n    this.stack=[]\n    increments=Array(this.max).fill(0)//把数组的所有元素填满为0\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.max>this.stack.length)\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length==0) return -1\n    else{\n        increments[this.stack.length-2]+=increments[this.stack.length-1]\n        //inc数组的栈顶加到栈顶的下一个\n        const res=increments[this.stack.length-1]+this.stack.pop()\n        //将inc数组的栈顶加到原栈的栈顶\n        increments[this.stack.length]=0\n        //inc数组的栈顶置0\n        return res\n        //注意：stack.length的值一直在变\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k>this.stack.length) increments[this.stack.length-1]+=val\n    //如果栈中元素总数小于k，赋值到inc数组的栈顶\n    else increments[k-1]+=val\n    //对应inc数组的栈加上增加的值\n};\n```\n## 复杂度分析\n时间复杂度：O(1)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087644890","body":"Day4\n\n[394、字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n#javascript #栈\n## 思路\n1、从头到尾遍历字符串\n\n2、数字存入数字的栈中，字符存入字符的栈中\n\n3、出栈时，按照规定对数字和字符进行运算\n\n## 代码\n```javascript\nvar decodeString = function(s) {\n    let arrNum=[],arrStr=[]//定义两个存放的栈\n    let num=0,str=''//定义两个暂存的点\n    for(let n of s){//遍历字符串\n        if(!isNaN(n)){//如果是数字，就存到数字中\n            num=num*10+Number(n)\n        }\n        else if(n=='['){//如果是[，则将数字和字符都压入栈中，并将暂存点清空\n            arrNum.push(num)\n            num=0\n            arrStr.push(str)\n            str=''\n        }\n        else if(n==']'){//如果是]，则将数字和字符都出栈，并做对应的运算\n            str=arrStr.pop()+str.repeat(arrNum.pop())\n        }\n        else{//如果是字符，就存到字符中\n            str+=n\n        }\n    }\n    return str\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088661569","body":"Day5\n\n[232、用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n#javascript #队列\n## 思路\n1、设置两个栈，一个负责入队，一个负责出队，倒换之后刚好符合队列的性质\n\n## 代码\n```javascript\nvar MyQueue = function() {\n    this.arr1=[]//入队的栈\n    this.arr2=[]//出队的栈\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr1.push(x)//入队\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.arr2.length==0){\n        while(this.arr1.length!=0){\n            this.arr2.push(this.arr1.pop())\n        }\n        return this.arr2.pop()\n    }//如果出队的队列没有元素，就把入队的队列都拿过来\n    else return this.arr2.pop()//出队\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.arr2.length==0){\n        while(this.arr1.length!=0){\n            this.arr2.push(this.arr1.pop())\n        }\n        return this.arr2[this.arr2.length-1]\n    }//如果出队的队列没有元素，就把入队的队列都拿过来\n    else return this.arr2[this.arr2.length-1]//返回队头元素，即数组的最后一个元素\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    while(this.arr1.length!=0){\n        this.arr2.push(this.arr1.pop())\n    }//把入队队列全拿过来\n    if(this.arr2.length==0) return true\n    else return false\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089866383","body":"Day6\n\n[768、最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n#javascript #队列\n## 思路\n1、构造一个单调栈\n\n2、使栈始终保持单调递增，碰到递减的情况就清除之前的数，只取最大的数\n\n3、栈中元素的个数就是能划分的排序的最多块数\n\n[题解](https://leetcode-solution.cn/solutionDetail?type=3&id=6&max_id=2)\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        a = arr[i];\n        if (stack.length > 0 && stack[stack.length - 1] > a) {//如果小于栈顶元素，则需要融合\n            const cur = stack[stack.length - 1];//记录栈顶元素的值\n            while (stack && stack[stack.length - 1] > a) stack.pop();\n            //一直清除栈中元素，直到给的值大于栈顶元素\n            stack.push(cur);\n            //将栈中最大元素放回栈中\n        }\n        else {//如果大于栈顶元素，则入栈\n            stack.push(a);\n        }\n    }\n    return stack.length;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091012211","body":"Day7\n\n[61、旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n#javascript #链表\n## 思路\n1、观察示例可以发现，需要从链表的后边截取一部分放到链表头部\n\n2、需要获取这一部分的头节点和尾节点\n\n3、使用快慢指针来分别获取头节点和尾节点\n\n 4、连接好新链表，并返回头节点\n### 特殊示例处理\n\n1、null链表和链表中只有一个元素，直接返回原头指针\n\n2、k或者rLength=0，则代表不用动链表，直接返回原头指针\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n    if(head==null) return null//头结点为空\n    if(head.next==null) return head//链表中只有一个节点\n    let p=head//保留头结点位置\n    let rLength=0//记录链表长度\n    while(p!=null){\n        p=p.next\n        rLength++\n    }\n    rLength=k%rLength//移动的位置大于长度时，会发生重复移动没有意义\n    if(rLength==0) return head//算完后发现不需要移动\n    let slow=head,fast=head//定义快慢指针，快指针指原链表尾，慢指针指新链表尾\n    while(fast.next!=null){\n        if(rLength--<=0) slow=slow.next\n        fast=fast.next\n    }\n    let q=slow.next\n    slow.next=null\n    fast.next=head\n    head=q\n    return head\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092367317","body":"Day8\n\n[24、两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n#javascript #链表\n## 思路1 迭代\n1、遍历链表，每次走两步\n\n2、需要获取四个节点才可以完成两两交换，获取对应的四个节点的位置\n\n3、 把四个节点按要求指向对应的节点\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if(head==null||head.next==null) return head//处理特殊示例\n    let p1=new ListNode(),p2=head,p3=p2.next,p4=p3.next\n    //给p1赋一个虚拟节点来处理头结点，这样可以将第一次交换放到循环里执行\n    p1.next=p2\n    head=p2.next//记录最后要返回的头结点\n    while(true){\n      p1.next=p3\n      p3.next=p2\n      p2.next=p4\n      //完成两两交换\n      if(p2.next==null||p4.next==null) break\n      //分成奇数个和偶数个节点两种情况，分别对应一个退出循环的方法\n      p1=p1.next\n      p1=p1.next\n      p2=p1.next\n      p3=p2.next\n      p4=p3.next\n      //所有节点向后走两步\n    }\n    return head\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n## 思路2 递归\n1、需要四个节点,p1,p2,p3,p4，做三次指向步骤，才能完成两两交换\n\n2、递归的返回值是下一次的p1也是这一次的p4\n\n3、递归到链表尾会返回空值，结束递归\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if(head==null||head.next==null) return head//处理特殊示例\n    let nextNode=head.next//nextNode为3号节点，head为2号节点\n    head.next=swapPairs(nextNode.next)//2号节点指向4号节点，同时完成了下一次操作的1号节点指向3号节点\n    nextNode.next=head//3号节点指向2号节点\n    return nextNode\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094067880","body":"Day9\n\n[109、有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n#javascript #树 #链表\n1、二叉搜索树要求左子树必须小于父节点，右子树必须大于父节点\n\n2、获取中间节点的位置，并且分别向左右两侧找左子树和右子树\n\n3、 递归调用\n\n## 代码\n```javascript\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }//快慢指针分别获取链表的中间位置和末尾位置\n  let root = new TreeNode(slow.val);//中间位置设为根节点\n  root.left = dfs(head, slow);//选择中间位置左边的节点的中间位置作为左子节点\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```\n## 复杂度分析\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094155674","body":"Day10\n\n[160、相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n#javascript #链表\n## 思路\n1、使用两个指针分别遍历链表，但是两个链表长度不同，无法相交\n\n2、遍历到链表尾后，交换两个链表的位置，刚好能够补上之前差的位置，节点相交的位置就是链表相交的位置\n\n3、返回节点的位置\n\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let a=headA,b=headB\n    while(a!=b){//两个节点相等时，退出循环\n        a= a==null? headB:a.next//a到链表尾时，换到B链表上\n        b= b==null? headA:b.next//b到链表尾时，换到A链表上\n    }//如果两个链表无相交节点，则一轮之后，a==b==null，返回null\n    return a\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095040446","body":"Day11\n\n[142、环形链表](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n#javascript #链表\n## 思路1：哈希表\n1、遍历链表，并记录链表中的所有值\n\n2、遇到相同的值就返回当前节点\n\n3、遍历完成后，仍没有相同的值，就返回null\n\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    let mySet=new Set()//建立一个哈希表\n    while(head){//不是环，就遍历一遍\n        if(mySet.has(head)) return head//如果在表中查到相同的元素，则返回该元素\n        mySet.add(head)//如果表中没有相同的元素，则添加该元素至表中\n        head=head.next//遍历\n    }\n    return null//无环，则返回null\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n## 思路2：快慢指针\n1、设置快慢指针，快指针一次走两步，慢指针一次走一步\n\n2、两指针相遇时，慢指针不变，快指针回到头结点，改为一次走一步\n\n3、当第二次相遇时，节点位置为入环节点\n\n[题解](https://leetcode-solution.cn/solutionDetail?type=3&id=11&max_id=2)\n\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    if(!head||!head.next) return null\n    let slow=head,fast=head\n    do {\n        if (fast != null && fast.next != null) {//处理特殊示例\n            fast = fast.next.next;\n        }\n        else {\n            return null\n        }\n        slow = slow.next;\n    } while (fast != slow);\n    //两个指针第一次相遇时，退出循环\n    fast=head\n    while(slow!=fast){\n        slow=slow.next\n        fast=fast.next\n    }\n    //两个指针第二次相遇时，得到入环节点\n    return slow\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096663087","body":"Day12\n\n[146、 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\n[题解](https://leetcode-solution.cn/solutionDetail?type=3&id=12&max_id=2)\n\n#javascript #链表\n\n1、利用map对象的性质，可以保存键值对，并记录先后顺序\n\n2、每次get或put操作时，都把原来的key重新插入一遍，使关键字更新\n\n## 代码\n```javascript\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)){//如果调用了就重新插入一个键值对，保持关键字的更新\n        const temp=this.map.get(key)\n        this.map.delete(key)\n        this.map.set(key,temp)\n        return temp\n    }\n    else return -1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if(this.map.has(key)){//如果存在则重新插入键值对，保持关键字的更新\n        this.map.delete(key)\n    }\n    this.map.set(key,value)\n    if(this.map.size>this.capacity){\n        this.map.delete(this.map.keys().next().value)//超过容量，就删除该关键字\n    }\n};\n```\n## 复杂度分析\n时间复杂度：O(1)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097487555","body":"Day13\n\n[104、二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n#javascript #树\n\n1、遍历树\n\n2、每层都加一，选左右两个子树中最大的返回\n\n3、 递归调用\n\n## 代码\n```javascript\nvar maxDepth = function(root) {\n    if(!root) return 0\n    const l=maxDepth(root.left)\n    const r=maxDepth(root.right)\n    if(l>r) return l+1\n    else return r+1\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098611187","body":"Day14\n\n[100、相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n#javascript #树\n\n## 思路一：递归\n\n1、递归遍历树\n\n2、判断值和左右子树是否相同\n\n## 代码\n```javascript\nvar isSameTree = function(p, q) {\n    if (!p || !q) return !p && !q//如果p和q都为空，就返回true，一个为空，就返回false\n    if(p.val!=q.val) return false\n    if(!isSameTree(p.left,q.left)) return false\n    if(!isSameTree(p.right,q.right)) return false\n    return true\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n## 思路二：前中序遍历\n\n1、通过前中序遍历可以唯一确定一棵树\n\n2、定义四个数组，分别代表p前序，q前序，p中序，q中序的遍历结果\n\n3、比较四个数组，可以得到树是否相同\n\n## 代码\n```javascript\nvar isSameTree = function(p, q) {\n  const preorderP = preOrder(p, [])\n  const preorderQ = preOrder(q, [])\n  const inorderP = inOrder(p, [])\n  const inorderQ = inOrder(q, [])\n  return (\n    preorderP.join(\"\") === preorderQ.join(\"\") &&\n    inorderP.join(\"\") === inorderQ.join(\"\")//数组的join方法将数组连成字符串\n  )\n};\n\nfunction preOrder(root,arr){\n    if(!root) {//数组中没有元素就插入一个空格字符\n        arr.push(\" \")\n        return arr\n    }\n    arr.push(root.val)\n    preOrder(root.left,arr)\n    preOrder(root.right,arr)\n    return arr\n}\n\nfunction inOrder(root,arr){\n    if(!root) {\n        arr.push(\"\")\n        return arr\n    }\n    preOrder(root.left,arr)\n    arr.push(root.val)\n    preOrder(root.right,arr)\n    return arr\n}\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100187107","body":"Day15\n\n[129、求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\n\n#javascript #树\n## 思路\n\n1、设置sum和curSum来分别记录总和和每个分支的和\n\n2、上一节点的和*10+本节点=本节点的和\n\n3、碰到叶子节点，就代表分支结束，加到sum里面\n\n4、递归调用\n\n## 代码\n```javascript\nvar sumNumbers = function(root) {\n    let sum = 0//记录总和\n    function dfs(root, cur) {//传入上一节点和之前节点的求和值\n    if (!root) return //递归结束条件\n    let curSum = cur * 10 + root.val//求和\n    if (!root.left && !root.right) {//如果到了叶子节点，就加到sum里面\n        sum += curSum\n        return\n    }\n    dfs(root.left, curSum)\n    dfs(root.right, curSum)\n    }\n    dfs(root, 0)//开始调用递归\n    return sum;   \n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100624016","body":"Day16\n\n[513、找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n#javascript #树\n## 思路\n\n1、采用树的层序遍历，遍历结束后，取最后一行的左节点返回\n\n2、把每一层存在一个数组里\n\n3、每次循环都通过遍历上一层的数组，把下一层再存入数组\n\n4、当数组中存的都是空节点时，循环结束\n\n## 代码\n```javascript\nvar findBottomLeftValue = function(root) {\n    let curLevel=[]//存储树的上一层的数组\n    curLevel.push(root)\n    let res=root.val//最后的结果\n    while(curLevel.length){//当数组中存放的都是空节点时，树的层序遍历结束\n        let nextLevel=[]//存储树的下一层的数组\n        for(let i=0;i<curLevel.length;i++){//遍历上一层，把下一层放进去\n            if(curLevel[i].left) nextLevel.push(curLevel[i].left) \n            if(curLevel[i].right) nextLevel.push(curLevel[i].right) \n        }\n        res=curLevel[0].val//取当前遍历层的左下节点的值\n        curLevel=nextLevel//遍历结束后，换到下一层\n    }\n    return res\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100894318","body":"Day17\n\n[297、二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n#javascript #树\n## 思路\n\n1、设计一个队列，采用树的层序遍历，将空节点作为“#”加入数组\n\n2、将数组转换成字符串并输出\n\n3、将字符串转为数组，list作为存放节点值的位置\n\n4、定义一个队列，用来确定树的结构\n\n## 代码\n```javascript\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    let cur=[root]\n    let res=[]\n    while(cur.length){\n        const node=cur.shift()//获取数组首元素并删除\n        if(node){\n            res.push(node.val)\n            cur.push(node.left)\n            cur.push(node.right)\n        }\n        else res.push('#')\n    }\n    return res.join(',')//数组转为字符串，并用,号分割\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if(data=='#') return null\n    const list=data.split(\",\")//记录二叉树的值\n    const root = new TreeNode(list[0])\n    let queue=[root]//表明二叉树的结构\n    let cur=1//list的下标值\n    while(cur<list.length){//list被遍历结束后退出循环\n        const node=queue.shift()//取队列的首元素\n        if(list[cur]!='#'){\n            const leftNode=new TreeNode(list[cur])//拿到左节点的值\n            node.left=leftNode\n            queue.push(leftNode)\n        }\n        if(list[cur+1]!='#'){\n            const rightNode=new TreeNode(list[cur+1])\n            node.right=rightNode\n            queue.push(rightNode)\n        }\n        cur+=2//每次循环会用掉两个list中的元素\n    }\n    return root\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101029967","body":"Day18\n\n[987、二叉树的垂序遍历](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)\n\n#javascript #树\n## 思路\n\n1、遍历二叉树，并记录每个节点的坐标和值在nodes\n\n2、将nodes中的节点按照列，行，值的顺序升序排序\n\n3、遍历nodes，记录上一次的列号，如果列号不同，则开一个新数组。并向数组中插入值\n\n## 代码\n```javascript\nvar verticalTraversal = function(root) {\n    let nodes=[]//用来记录所有节点的数组\n    function dfs(node,row,col,nodes){//遍历所有节点并记录到nodes中\n        if(!node) return null\n        nodes.push([col, row, node.val])\n        dfs(node.left,row+1,col-1,nodes)\n        dfs(node.right,row+1,col+1,nodes)\n    }\n    dfs(root,0,0,nodes)\n    nodes.sort((a,b)=>{//将所有节点按照列，行，值进行升序排序\n        if(a[0]!=b[0]){\n            return a[0]-b[0]\n        }else if(a[1]!=b[1]){\n            return a[1]-b[1]\n        }else{\n            return a[2]-b[2]\n        }\n    })\n    let res=[]//返回的最终数组\n    let lastCol=-Number.MAX_VALUE//记录上一次的列号\n    for(let n of nodes){//遍历nodes\n        if(n[0]!=lastCol){\n            lastCol=n[0]\n            res.push([])//如果列号不同，就新创建一个数组\n        }\n        res[res.length - 1].push(n[2])//往res中的最后一个数组中添加值\n    }\n    return res\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102720430","body":"Day19\n\n[1、两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n#javascript #哈希表\n\n## 思路\n\n可以双重循环暴力解，时间复杂度O（n2）\n\n或者哈希表解，时间复杂度O（n）\n\n1、建立哈希表，如果不满足题意，就把数值和下标存入哈希表中\n\n2、如果target-nums[i]可以在哈希表中查到时，则表明满足题意，返回相应的下标值\n\n## 代码\n```javascript\nvar twoSum = function(nums, target) {\n    let map = new Map();//建哈希表\n    for(let i=0;i<nums.length;i++){//遍历数组\n        if(map.has(target-nums[i])) return [map.get(target-nums[i]),i]\n        //如果哈希表中有满足的元素，就返回下标\n        else map.set(nums[i],i)\n        //如果哈希表中元素不满足，就设置值和下标传入哈希表中\n    }\n    return []//处理特殊示例\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104015619","body":"Day20\n\n[347、前k个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n#javascript #哈希表\n\n## 思路\n1、建立哈希表，遍历数组\n\n2、哈希表中记录数组中的值和出现的次数\n\n3、将哈希表按照出现的频率排序\n\n4、取前k频率的数作为数组返回\n\n## 代码\n```javascript\nvar topKFrequent = function(nums, k) {\n    const map = new Map()//初始化哈希表\n    for(let item of nums){//遍历数组\n        if(map.has(item)) map.set(item,map.get(item)+1)\n        //如果表中存在相同元素，就把出现频率+1\n        else map.set(item,1)\n        //如果表中无元素，就设置出现频率为1\n    }\n    const arr = [...map].sort((a,b) => b[1] - a[1])\n    //将map拆成数组，并且按照出现频率进行排序\n    const result = []\n    for(let i = 0; i < k; i++){//取出现频率前k高的元素\n        result.push(arr[i][0])\n    }\n    return result;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105286884","body":"Day21\n\n[447、回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)\n\n#javascript #哈希表\n\n## 思路\n1、设有m个点到points[i]的距离相同\n\n2、从m点中选出两个点作为一个回旋镖\n\n3、个数为组合数：m*（m-1）\n\n4、遍历points，将每个距离的出现次数记录到哈希表中\n\n5、遍历哈希表，求和\n\n[题解](https://leetcode-cn.com/problems/number-of-boomerangs/solution/hui-xuan-biao-de-shu-liang-by-leetcode-s-lft5/)\n\n## 代码\n```javascript\nvar numberOfBoomerangs = function(points) {\n    let ans = 0;//记录回旋镖数量\n    for (const p of points) {//外层循环\n        const cnt = new Map();//建立哈希表\n        for (const q of points) {\n            const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n            cnt.set(dis, (cnt.get(dis) || 0) + 1);\n            //将每个距离的出现次数记录到哈希表中\n        }\n        for (const [_, m] of cnt.entries()) {\n            ans += m * (m - 1);\n            //遍历哈希表，求出回旋镖个数\n        }\n    }\n    return ans;\n};\n```\n## 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106519047","body":"Day22\n\n[3、无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n#javascript #哈希表 #双指针\n\n## 思路\n1、建立一个滑动窗口，尾节点遍历s\n\n2、把滑动窗口中的元素的值和位置存入哈希表中\n\n3、遇到相同字符时，头节点移至之前字符的下一个位置\n\n4、求出滑动窗口的最大长度并返回\n\n## 代码\n```javascript\nvar lengthOfLongestSubstring = function(s) {\n    let map={}//建立哈希表\n    let max=0//最终结果\n    let l=0,r=0//窗口的首尾指针\n    for(;r<s.length;r++){//窗口的尾指针遍历s\n        let pos=map[s[r]]//记录与当前字符相同的字符的位置\n        if(pos<=r&&pos>=l){//如果窗口中出现了相同字符\n            l=pos+1//窗口的首指针移动到上次相同字符位置的后一位\n        }\n        map[s[r]]=r//窗口右移\n        max=Math.max(max,r-l+1)//记录窗口的最大长度\n    }\n    return max\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107522309","body":"Day23\n\n[30、串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)\n\n#javascript #哈希表 #双指针\n\n## 思路\n1、建立一个滑动窗口，遍历s\n\n2、建立两个哈希表分别记录滑动窗口和words中的数据\n\n3、窗口和words中数据满足题意时，记录位置\n\n4、返回记录位置的数组\n\n[题解](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/88ms-9901-hua-dong-chuang-kou-by-youngli-ep75/)\n\n## 代码\n```javascript\nvar findSubstring = function(s, words) {\n    const wordsLength=words.length,wordLength=words[0].length\n    let mapWords={}//建立记录words数据的哈希表\n    for(let n of words){\n        mapWords[n]=(mapWords[n]||0)+1\n    }//将words数据记录到哈希表中\n    let i=0,l=0,r=0,res=[],win={},count=0\n    while(i<wordLength){\n        //当s开头字符不是words中单词的首字符时，可以多次遍历得出结果\n        l=i,r=i,win={},count=0//每次遍历将变量置空\n        while(r<s.length){//按每个单词来遍历s\n            const ss=s.substring(r,r+wordLength)\n            //获取下一个单词\n            r+=wordLength\n            //窗口向右滑动一格\n            if(!mapWords[ss]){\n                //如果获取到不在words中的单词，就清空原窗口，重新建立窗口\n                l=r\n                win={}\n                count=0\n            }else{\n                win[ss]=(win[ss]||0)+1//将新单词加入到窗口中\n                count++//出现在words中的单词的个数\n                while(win[ss]>mapWords[ss]){\n                    //出现多余单词，就把窗口从左侧收缩\n                    const sl = s.substring(l,l+wordLength)\n                    win[sl] = (win[sl]||0)-1\n                    count--\n                    l+=wordLength\n                }\n                if(count===wordsLength) res.push(l)\n            }\n        }\n        i++\n    }\n    return res\n};\n```\n## 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107838615","body":"Day24\n\n[974、和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)\n\n#javascript #哈希表\n\n## 思路\n1、数学方法转化为：preSum[j] mod k==preSum[i-1] mod k(见题解证明)\n\n2、建立一个哈希表记录相同前缀和 mod k出现的次数\n\n3、遍历数组，并更新哈希表\n\n4、如果有前缀和 mod k 在哈希表中，就把该位置的值记录到count中\n\n5、返回count\n\n[题解](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/solution/you-jian-qian-zhui-he-na-jiu-zai-ci-dai-ni-da-tong/)\n\n## 代码\n```javascript\nvar subarraysDivByK = function(nums, k) {\n    let map={0:1},preSumModK=0,count=0\n    for(let i=0;i<nums.length;i++){//遍历数组\n        preSumModK=(preSumModK+nums[i])%k//计算前缀和modk\n        if(preSumModK<0){//如果前缀和是负数，按照负数的mod方法处理\n            preSumModK+=k\n        }\n        if(map[preSumModK]){\n            count+=map[preSumModK]//如果哈希表中存过相同的前缀和，就把次数取出来\n            map[preSumModK]++//出现的次数加1\n        }\n        else{\n            map[preSumModK]=1//哈希表中没有，则存入出现的次数为1\n        }\n    }\n    return count\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108538001","body":"Day25\n\n[876、链表的中间节点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\n\n#javascript  #双指针\n\n## 思路\n1、分别建立快慢指针，遍历链表\n\n2、慢指针的速度是快指针的一半\n\n3、返回慢指针\n\n## 代码\n```javascript\nvar middleNode = function(head) {\n    let slow=head,fast=head//定义快慢指针\n    while(slow&&fast&&fast.next){//遇到空就退出循环\n        fast=fast.next.next\n        slow=slow.next\n    }//快指针走两步，慢指针走一步\n    return slow\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109964719","body":"Day26\n\n[26、删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n#javascript  #双指针\n\n## 思路\n1、分别建立快慢指针，遍历链表\n\n2、慢指针不动，当两指针不相等时，慢指针+1，快指针赋给慢指针值\n\n3、返回慢指针的数字+1\n\n## 代码\n```javascript\nvar removeDuplicates = function(nums) {\n    let p1 = 0,//慢指针\n        p2 = 0;//快指针\n\n    while (p2 < nums.length) {//快指针遍历数组\n        if (nums[p1] != nums[p2]) {\n            p1++;\n            nums[p1] = nums[p2];\n        }//当指针不相等时，把p2指的赋给p1\n        p2++;\n    }\n    return p1 + 1;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111164113","body":"Day27\n\n[35、搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n#javascript  #双指针\n\n## 思路\n1、要求时间复杂度logn，故采用二分查找\n\n2、定义左右指针，每次比较目标值和中间指针的值，不相等就改变左右指针\n\n3、返回左指针，即为按顺序插入的位置\n\n## 代码\n```javascript\nvar searchInsert = function(nums, target) {\n  let left = 0,\n    right = nums.length-1;\n  while (left <= right) {\n    const middle = Math.floor((left+right)/2);\n    const middleValue = nums[middle];\n    if (middleValue === target) {\n      return middle;\n    } else if (middleValue < target) {\n      left = middle + 1;\n    } else {\n      right = middle - 1;\n    }\n  }\n  return left;\n};\n```\n## 复杂度分析\n时间复杂度：O(logn)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112288367","body":"Day28\n\n[239、滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n#javascript #队列\n## 思路\n1、创建一个单调递减的双端队列来保存接下来的滑动窗口中可能出现最大值的数\n\n2、每次入队时，把比入队值小的数都移除，从队尾移除\n\n3、每次右移一个，就把索引大于i-k+1的数移除，因为超出窗口的范围了\n\n4、每次最大值取队列的队首即可\n\n5、返回最大值数组\n\n## 代码\n```javascript\nvar maxSlidingWindow = function(nums, k) {\n    const res=[]//最终结果\n    const dequeue=new Dequeue([])//初始化双端队列\n    for(let i=0;i<k-1;i++){\n        dequeue.push(nums[i])\n    }//把前k-1个数入队\n    for(i=k-1;i<nums.length;i++){\n        dequeue.push(nums[i])//入队\n        res.push(dequeue.max())//求最大值\n        dequeue.shift(nums[i-k+1])//出队\n    }//求最大值\n    return res\n};\n\nclass Dequeue{\n    constructor(nums){\n        this.list=nums\n    }\n\n    push(val){\n        const nums=this.list\n        while(nums[nums.length-1]<val){\n            nums.pop()\n        }//比输入值小的都退出队列,保持队列单调递减,队头元素是最大值\n        nums.push(val)\n    }\n\n    shift(val){\n        let nums=this.list\n        if(nums[0]===val){\n            //有可能上一个滑动窗口中左侧的数已经在push操作中被删除了,不能无脑删首元素\n            nums.shift()\n        }\n    }\n    //清除上一个滑动窗口中左侧的数\n\n    max(){\n        return this.list[0]\n    }//返回队列的最大值\n}\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113388893","body":"Day29\n\n[997、找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)\n\n#javascript #图\n## 思路\n1、将题目转化为，找到入度为n-1（除自己），出度为0的编号\n\n2、建立两个数组分别记录每个编号的入度和出度的值\n\n3、遍历trust，记录出度和入度\n\n4、遍历trust，找到符合条件的编号\n\n## 代码\n```javascript\nvar findJudge = function(n, trust) {\n    let inDegrees=new Array(n+1).fill(0)\n    let outDegrees=new Array(n+1).fill(0)\n    //初始化存储入度和出度的数组，长度为n+1的原因是编号从1开始，索引0被废弃\n    for(let people of trust){\n      const x=people[0],y=people[1]\n      //x为当前出度的编号，y为当前入度的编号\n      inDegrees[y]++\n      outDegrees[x]++\n      //记录每个编号出度和入度的值\n    }\n    for(let i=1;i<n+1;i++){\n      if(inDegrees[i]===n-1&&outDegrees[i]===0) return i\n      //选出出度为0，入度为n-1的编号\n    }\n    return -1\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086012990","body":"### lc989 数组形式的整数加法\n\n#### 解法一\n\n##### 思路\n\n+ 先将数组翻转\n+ 在将 k 全部加在数组最后一位上\n+ 计算数组最后一位的进位，并作为下一次运算的 k\n+ 直到 k 为 0 且 数组遍历完成\n+ 最后将数组重新翻转\n\n##### 代码实现\n\n~~~ c++\nclass Solution1 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        reverse(num.begin(), num.end());\n\n        for (int i = 0; i < len; i++) {\n            num[i] += k;\n            k = num[i] / 10;\n            num[i] %= 10;\n        }\n\n        while (k > 0) {\n            num.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)\n\n\n\n#### 解法二\n\n##### 思路\n\n+ 将数组和 k 逐位相加\n+ 计算进位，并加在 k 的下一位上\n+ 直到 k 为 0 且数组遍历完成\n\n##### 代码实现\n\n~~~ c++\nclass Solution2 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        vector<int> result;\n\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n        while (k > 0) {\n            result.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086018719","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res= new ArrayList<Integer>();\n       Integer n = num.length;\n       for(int i = n-1 ;i>=0||k>0;--i,k/=10)\n       {\n           if(i>=0)\n           {\n               k+=num[i];\n           }\n           res.add(k%10);\n       }\n       Collections.reverse(res);\n        return res;\n    }\n}\n\n思路：将整个加数 k 加入数组表示的数的最低位。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664444","body":"### 【Day 2】821. 字符的最短距离\n#### 思路：分别比较左边和右边距离最近的值，取最小。\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pre = -10000; //最大数据范围是10000\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) { //计算左段与c最近的距离\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = i - pre;\n        }\n        pre = 10000;\n        for (int i = s.length() - 1; i >= 0; i--) { //计算右段与c最近的距离,同时与之前记录的左段进行比较\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n###\n时间复杂度：O(N)O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。\n空间复杂度：O(N)O(N)，ans 数组的大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897344","body":"### 【Day 3】1381. 设计一个支持增量操作的栈\n方法1：模拟\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087116500","body":"### 【Day 4】394. 字符串解码\n####  思路：构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n当 c 为字母时，在 res 尾部添加 c；\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n进入到新 [ 后，res 和 multi 重新记录。\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n返回字符串 res。\n\n```\npublic String decodeString(String s) {\n        // 思路: 乘法和 递推公式 前一个和作为下一个加法的加数\n        // 3[a]2[bc] = 3a+2bc = (3a + \"\") + 2bc\n        // 3[a2[c]] = 3(2c + a) = 3(2c + a) + \"\"\n        \n        // 1. 初始化倍数和res 及其对应栈\n        int multi = 0;\n        StringBuilder res = new StringBuilder();\n        Deque<Integer> multi_stack = new LinkedList<>();\n        Deque<String> res_stack = new LinkedList<>();\n\n        // 2. 遍历字符\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            // 3. 统计倍数\n           //只有在碰到'['时才会入栈。比如'12[a]',初始状态muti=0；c='1'，muti=0*10+1=1;c='2',muti=1*10+2=12;c='[',muti=12入栈，然后muti=0.\n            if (ch >= '0' && ch <= '9')\n                multi = multi * 10 + (ch - '0');\n            // 4. 统计res\n            else if (ch >= 'a' && ch <= 'z') \n                res.append(ch);\n            // 5. 入栈并重置临时变量\n            else if (ch == '[') {\n                multi_stack.push(multi);\n                res_stack.push(res.toString());\n                // 重置开始下一轮重新统计\n                multi = 0;\n                res = new StringBuilder();\n            // 6. 出栈做字符串乘法和加法\n            } else {\n                int cur_multi = multi_stack.pop();\n                StringBuilder temp = new StringBuilder();\n                // 乘以当前统计字符串res\n                for (int i = 0; i < cur_multi; i++)\n                    temp.append(res);\n                // 加上前一个统计字符串作为当前res\n                res = new StringBuilder(res_stack.pop() + temp);\n            }\n        }\n        return res.toString();\n    }\n```\n####\n时间复杂度 O(N)O(N)，一次遍历 s；\n空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088812452","body":"## 【Day 5】232. 用栈实现队列\n```\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n```\n## 复杂度分析\n\n时间复杂度：O(1)。\n\n空间复杂度：O(n)。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091664885","body":"### 【Day 7】61. 旋转链表\n思路：记给定链表的长度为 nn，注意到当向右移动的次数 k \\geq nk≥n 时，我们仅需要向右移动 k \\bmod nkmodn 次即可。因为每 nn 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k \\bmod n)(n−1)−(kmodn) 个节点（从 00 开始计数）。\n这样，我们可以先将给定的链表连接成环，然后将指定位置断开。\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        //算出链表的长度\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n       //找到断开的位置\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n       //移动链表\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n复杂度分析\n\n时间复杂度：O(n)O(n)，最坏情况下，我们需要遍历该链表两次。\n空间复杂度：O(1)O(1)，我们只需要常数的空间存储若干变量。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086021602","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sums = 0\n        for i,j in enumerate(num):\n            sums += j*10**(len(num)-i-1)\n        sums += k\n        ans = []\n        while sums:\n            temp = sums %10\n            sums = sums//10\n            ans.insert(0,temp)\n        return ans\n            \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086548738","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        dic = []\n        for i,j in enumerate(s):\n            if j == c:\n                dic.append(i)\n        ans = []\n        \n        for i in range(len(s)):\n            temp = []\n            for j in dic:\n                temp.append(abs(j-i))\n            ans.append(min(temp))\n        return ans\n```\n                \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086898887","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            #self.stack.insert(0,x)\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<=k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            for i in range(k):\n                self.stack[i] += val\n        \n```      ","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092304824","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            return head\n        prehead = ListNode(0)\n        ans = prehead\n        while head and head.next:\n            temp = head.next.next\n            nexts = head.next\n            nexts.next = head\n            prehead.next = nexts\n            head.next = temp\n            ##important\n            prehead = head\n            head= temp\n        return ans.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093321806","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre ,slow , quick = None,head,head\n\n        while quick and quick.next:\n            pre = slow\n            slow = slow.next\n            quick = quick.next.next\n        #print(pre==head)\n        if pre:\n            pre.next = None\n        a = TreeNode(slow.val)\n        if quick == slow:\n            return a\n        \n        a.left = self.sortedListToBST(head)\n        a.right = self.sortedListToBST(slow.next)\n        return a\n        \n```      ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094185505","body":"\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a = headA\n        b = headB\n        lena = 0\n        lenb = 0\n        while a:\n            a = a.next\n            lena +=1\n        while b:\n            b = b.next\n            lenb +=1\n        \n        a = headB\n        b= headA\n        if lena >=lenb:\n            step = lena-lenb\n            for i in range(step):\n                b = b.next\n        else:\n            step = lenb-lena\n            for i in range(step):\n                a = a.next\n        while a:\n            if a == b:\n                return a\n            a= a.next\n            b = b.next\n        return None\n        \n```  ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095687050","body":"```\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dic = collections.OrderedDict()\n        \n\n    def get(self, key: int) -> int:\n        if key in self.dic:\n            v = self.dic[key]\n            \n            self.dic.pop(key)\n            self.dic[key] = v\n            \n            return v\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dic:\n            self.dic.pop(key)\n            self.dic[key] = value\n        else:\n            if len(self.dic)>= self.capacity:\n                self.dic.popitem(last=False) \n                self.dic[key] = value\n            else:\n                self.dic[key] = value\n```        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1096981934","body":"```        \n#dfs\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        level = 1\n        ans = 1\n        stack = [(root,level)]\n        while stack:\n            node,level = stack.pop()\n            ans = max(level,ans)\n            if node.left:\n                stack.append((node.left,level+1))\n            if node.right:\n                stack.append((node.right,level+1))\n        return ans\n```       ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100186395","body":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n#bfs\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        que = collections.deque()\n        que.append((root,0))\n        ans = 0\n        while que:\n            n,temp = que.popleft()\n            if n.left:\n                que.append((n.left,n.val+temp*10))\n            if n.right:\n                que.append((n.right,n.val+temp*10))\n            if not n.left and not n.right:\n                ans += temp*10+n.val\n        return ans\n            \n        ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101878156","body":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dic = {}\n        for i,j in enumerate(nums):\n            if j in dic:\n                return [i]+[dic[j]]\n            else:\n                dic[target -j] = i\n\n        return None","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1102950513","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        if k == 0:\n            return []\n        if k > len(nums):\n            return nums\n        dic = {}\n        for i in nums:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n        \n        dic = sorted(dic.items(), key=lambda x: x[1], reverse=True)\n        ans = []\n        for i in range(k):\n            ans.append(dic[i][0])\n\n        return ans ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104660908","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def dis(a,b):\n            return (a[0]-b[0])**2 +(a[1]-b[1])**2 \n        #collections.defaultdict(int)\n        dic = [{} for _ in range(len(points))]\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i!= j:\n                    dist = dis(points[i],points[j])\n                    if dist not in dic[i]:\n                        dic[i][dist] = 1\n                    else:\n                        dic[i][dist] +=1\n        ans = 0   \n        #print(dic)\n        for d in dic:\n            for k,v in d.items():\n                if v >1:\n                    #print(2*math.comb(v,2))\n                    ans += 2*math.comb(v,2)\n                \n        return ans\n                    ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108730030","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        l,r = head,head\n        while r and r.next:\n            l = l.next\n            r = r.next.next\n        return l\n        ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110436935","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l,r = 0,len(nums)-1\n        while l<r:\n            \n            mid = (l+r)//2\n            #print(l,r,mid)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid+1\n            elif nums[mid] > target:\n                r = mid-1\n        if target> nums[l]:\n            return l+1\n        else:\n            return l\n        ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112435058","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        indegree,outdegree = [0]*(n+1),[0]*(n+1)\n        for i,j in trust:\n            indegree[j] +=1\n            outdegree[i] +=1\n        for i in range(1,n+1):\n            if indegree[i] == n-1:\n                if outdegree[i] == 0:\n                    return i\n        return -1\n        \n        ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lskong":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022222","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n\n        vector<int> res;\n        res.reserve(A.size() + 5);\n\n        int i = A.size() - 1;\n        int carry = 0;\n\n        while (i >= 0 || K > 0)\n        {\n            int n1 = i >= 0 ? A.at(i) : 0;\n            int n2 = K > 0 ? K % 10 : 0;\n            int sum = n1 + n2 + carry;\n            carry = sum / 10;\n            res.push_back(sum % 10);\n            --i;\n            K /= 10;\n        }\n\n        if (carry)\n        {\n            res.push_back(1);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086585016","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> pos;\n        vector<int> res;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                pos.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.size(); i++) {\n            int tmp = 100000000000000;\n            for(int j = 0; j < pos.size(); j++) {\n                tmp =min(tmp, abs(i -pos[j]));\n            }\n            res.push_back(tmp);\n        } \n    return res;\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1091146337","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> st;\n        st.push(arr[0]);\n        for(int i = 1; i < arr.size(); i++) {\n            if(arr[i] < st.top()) {\n                int maxNum = st.top();\n                while(!st.empty() && st.top() > arr[i])  st.pop();\n                st.push(maxNum);\n            }\n            else st.push(arr[i]);    \n        }\n    return st.size();\n\n    }\n};","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092431857","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      if(head == nullptr || head->next== nullptr) {\n          return head;\n      }\n      ListNode* first = head;\n      ListNode* second = head->next;\n      head = second;\n      first->next = swapPairs(second->next);\n      second->next =first;\n      return head;\n\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mapo0102":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022435","body":"思路：\n创建一个链表，获取数组长度\n逆序从最低位开始，进行链表的加和。\n完成加和后，判断k值是否完成，如果未完成，继续向链表头部加k值，然后k/10，消耗尽k的所有位数。\n\n代码：\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int n = num.length;\n\n        for (int i = n - 1; i >= 0 ; i--) {\n            int sum = k%10 + num[i];\n            k = k / 10;\n            if(sum >= 10){\n                sum -= 10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n        while(k>0){\n            res.add(0,k%10);\n            k=k/10;\n        }\n        return res;\n    }\n\n    }\n\n\n复杂度：\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646897","body":"思路：\n首先先从左向右遍历一遍，将ans数组中的所有元素标志成对应位。\n再从右往左遍历一遍，再比较大小，将ans对应位置中更小的数放入对应ans。\n\n代码：\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086900343","body":"思路：\r\npush方法：当栈顶top不等于 栈长-1，top指针+1，栈顶元素等于新加入元素。\r\npop方法：当top为-1时，返回-1；否则，指针先-1，然后返回（top+1）位置的元素。\r\nincrement方法：取当前k和当前所有元素的较小值，从底部开始遍历这个较小值数量的栈元素，给每个元素+val\r\n代码：\r\nint[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n\r\n\r\n时间复杂度：O（1）\r\n空间复杂度：O（n）\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086913613","body":"思路：将数字和char先压入栈中，把字符一个个压入栈中，遇到]符号就执行循环赋值操作。\n代码：class Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n\n                while(!stack.isEmpty() && stack.peek() != '['){\n                    sb.insert(0,stack.pop());\n                }\n\n                String sub = sb.toString();//获得一个[]的字段\n\n                stack.pop();//去掉[\n\n                sb = new StringBuilder();//清理掉sb当前的内容\n\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());//获得[]前的系数\n                }\n\n                int count = Integer.parseInt(sb.toString());\n            \n                while(count > 0){\n                    for(char ch:sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;//将一整个重复的字符串压入栈中\n            }\n        }\n    }\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n\n复杂度：\n空间复杂度：O(n)\n时间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086024431","body":"### 思路\n\n数组num转换为字符串与k相加后再转换为List\n\n### 代码\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tostr = ''.join([str(i) for i in num])\n        res = str(int(tostr)+ k)\n        reslist = [int(i) for i in res]\n        return reslist\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，其中 n 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897297","body":"\n### 代码\n\n\n```\nclass CustomStack {\n    int[] stack;\n    int size;\n    int[] increment;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize + 1];\n        size = 0;\n    }\n    \n    public void push(int x) {\n        if(size == stack.length){\n            return;\n        }\n        stack[size++] = x;\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        int res = stack[size - 1];\n        if(increment[size] != 0){\n            res += increment[size];\n            increment[size - 1] += increment[size];\n            increment[size] = 0;\n        }\n        size--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        increment[Math.min(k, size)] += val;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxSize)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088736837","body":"### 思路\n【Day 5】232. 用栈实现队列\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n使用双栈\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1=new Stack<>();\n        stack2=new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty())\n                stack2.push(stack1.pop());\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if(stack2.isEmpty()){\n            while(!stack1.isEmpty()){\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090427059","body":"### 思路\n768-https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n官方题解\n排序后第k个，一定大于等于前k个数，找到这个最小k，然后重复\n\n### 代码\n```java（\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.Counter()\n        counted = []\n        for x in arr:\n            count[x] += 1\n            counted.append((x, count[x]))\n\n        ans, cur = 0, None\n        for X, Y in zip(counted, sorted(counted)):\n            cur = max(cur, X)\n            if cur == Y:\n                ans += 1\n        return ans\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094069086","body":"### 思路\n\nleetcode 109 \nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/109-you-xu-lian-biao-zhuan-huan-er-cha-s-lzlb/\n链表转成数组\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (null==head) {\n            return null;\n        }\n        List<Integer> nums = new ArrayList<>();\n        while (null!=head) {\n            nums.add( head.val );\n            head = head.next;\n        }\n        return toBst(nums,0, nums.size()-1);\n    }\n\n    private TreeNode toBst( List<Integer> nums, int left, int right ) {\n        if (left>right) {\n            return null;\n        }\n        int middle = left + (right - left)/2;\n        TreeNode root = new TreeNode(nums.get( middle ));\n        root.left = toBst( nums,left,middle-1 );\n        root.right = toBst( nums,middle+1,right );\n        return root;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096878594","body":"### 思路\n\nleetcode 146 \nhttps://leetcode-cn.com/problems/lru-cache/\n哈希表&双向链表\n\n### 代码\n\n\n```java\nclass LRUCache {\n\n    private int size;\n    private int capacity;\n    private HashMap<Integer, Node> nodeMap;\n    private Node headNode;\n    private Node tailNode;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        this.nodeMap = new HashMap<>();\n        this.headNode = new Node();\n        this.tailNode = new Node();\n        \n        // 双向链表，头尾指针互相指向\n        this.headNode.preNode = tailNode;\n        this.headNode.nextNode = tailNode;\n        this.tailNode.preNode = headNode;\n        this.tailNode.nextNode = headNode;\n    }\n\n    public int get(int key) {\n        Node node = nodeMap.get(key);\n        if (node != null) {\n            // 节点被访问，移动到队尾\n            move2Tail(node);\n            return node.val;\n        } else {\n            return -1;\n        }\n    }\n\n    public void put(int key, int value) {\n        Node node = nodeMap.get(key);\n        if (node != null) {\n            // key已存在，更新节点的值\n            node.val = value;\n            // 节点被访问，移动到队尾\n            move2Tail(node);\n        } else {\n            // 创建新节点\n            node = new Node();\n            node.key = key;\n            node.val = value;\n            if (size < capacity) {\n                // 容量未满，新节点添加到队尾\n                add2Tail(node);\n                // 容量+1\n                size++;\n            } else {\n                // 容量已满，删除队头节点，该节点为最久未使用\n                int oldKey = removeHead();\n                // 同时删除哈希表\n                nodeMap.remove(oldKey);\n                // 新节点添加到队尾\n                add2Tail(node);\n            }\n            // 新key添加到哈希表\n            nodeMap.put(key, node);\n        }\n    }\n\n    // 队尾添加节点\n    private void add2Tail(Node node) {\n        node.preNode = tailNode.preNode;\n        node.nextNode = tailNode;\n        tailNode.preNode.nextNode = node;\n        tailNode.preNode = node;\n    }\n\n    // 移动节点到队尾\n    private void move2Tail(Node node) {\n        node.preNode.nextNode = node.nextNode;\n        node.nextNode.preNode = node.preNode;\n        node.preNode = tailNode.preNode;\n        node.nextNode = tailNode;\n        tailNode.preNode.nextNode = node;\n        tailNode.preNode = node;\n    }\n\n    // 删除节点，并返回节点key\n    private int remove(Node node) {\n        int key = node.key;\n        node.preNode.nextNode = node.nextNode;\n        node.nextNode.preNode = node.preNode;\n        node = null;\n        return key;\n    }\n\n    // 删除队首节点，并返回节点key\n    private int removeHead() {\n        Node node = headNode.nextNode;\n        int key = node.key;\n        node.nextNode.preNode = headNode;\n        headNode.nextNode = node.nextNode;\n        node = null;\n        return key;\n    }\n\n    // 自定义双向链表节点\n    private class Node {\n        private int key;\n        private int val;\n        private Node preNode;\n        private Node nextNode;\n    }\n}\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(capacity)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098223883","body":"\n### 思路\n\n104. 二叉树的最大深度\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n### 代码\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // 获取左子树、右子树的最大深度，比较，取得最大值\n        if(root == null)return 0;\n        int maxLeftDepth = maxDepth(root.left);\n        int maxRightDepth = maxDepth(root.right);\n        int depth = Math.max(maxLeftDepth,maxRightDepth)+1;\n        return depth;\n    }\n}\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102777022","body":"### 思路\n\n【Day 19】两数之和\nhttps://leetcode-cn.com/problems/two-sum/comments/\n\n### 代码\n\n\n```java\npublic int[] twoSum(int[] nums, int target) {\n    int[] res = new int[2];\n    if(nums == null || nums.length == 0){\n        return res;\n    }\n    Map<Integer, Integer> map = new HashMap<>();\n    for(int i = 0; i < nums.length; i++){\n        int temp = target - nums[i];\n        if(map.containsKey(temp)){\n            res[1] = i;\n            res[0] = map.get(temp);\n        }\n        map.put(nums[i], i);\n    }\n    return res;\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108738336","body":"### 思路\n\n876. 链表的中间结点\nhttps://leetcode-cn.com/problems/middle-of-the-linked-list/\n\n### 代码\n\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode p = head, q = head;\n        while (q != null && q.next != null) {\n            q = q.next.next;\n            p = p.next;\n        }\n        return p;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oneline-wsq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086026979","body":"### 思路\n\n将num数组计算为一个数，然后再与k相加，最后再返回数组。\n\n### 代码\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        sum1=0\n        n=len(num)\n        for i in range(n):\n            sum1=sum1+pow(10,n-i-1)*num[i]\n\n        sum2=sum1+k\n\n        return [int(x) for x in str(sum2)]\n```\n\n### 复杂度分析\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597093","body":"### 思路\n\n首先在s中找到所有等于c的索引；再从0开始循环，计算与索引集合相减绝对值最小的值。\n\n### 代码\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n\n        ans=[]\n        # 首先找出所有的c的索引\n        tmp=[]\n        k=0\n        for i in s:\n            if i==c:\n                tmp.append(k)\n            k+=1\n        \n        for i in range(len(s)):\n            tmp2=[abs(j-i)for j in tmp]\n            ans.append(min(tmp2))\n\n        return ans\n```\n\n### 复杂度分析\n\n时间复杂度：O(n*m)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086844229","body":"### 思路\n\n用python的list实现。\n\n### 代码\n\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize=maxSize\n        self.stack=[]\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack)<self.maxsize:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack)==0:\n            return -1\n        else:\n            ans=self.stack[-1]\n            self.stack=self.stack[0:-1]\n            return ans\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        n=len(self.stack)\n        addn=min(k,n)\n        for i in range(addn):\n            self.stack[i]=self.stack[i]+val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087073420","body":"### 思路\n利用栈来实现\n### 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # 本题的核心思路是在栈里面每次存储两个信息：（左括号前的字符串，左括号前的数字）\n        stack=[] # (str,int)记录左括号之前的字符串和左括号外的上一个数字\n        num=0\n        res=\"\" # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num=num*10+int(c)\n            elif c==\"[\":\n                stack.append((res,num))\n                res,num=\"\",0\n            elif c==\"]\":\n                top=stack.pop()\n                res=top[0]+res*top[1]\n            else:\n                res+=c\n        return res\n```\n### 复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088586552","body":"# ****[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)****\n\n### 思路\n\n### 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.data=list()\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n\n        return self.data.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        pdata=self.data[0]\n        self.data=self.data[1:]\n        return pdata\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n        return self.data[0]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.data)==0:\n            return True\n        else:\n            return False\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度分析\n\n时间复杂度： O(1)\n\n空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089757686","body":"### 思路\n\n遍历arr，压入tmp栈中，如果tmp中的所有值小于后面未遍历到的所有值的最小值，则证明可以在此划分为1个块，tmp清空，否则，继续。\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \n        k=0\n        tmp=[]\n        for i,element in enumerate(arr[:-1]):\n            max_bh=max(arr[i+1:])\n            min_bh=min(arr[i+1:])\n            tmp.append(element)\n            if max(tmp)<=min_bh:\n                k=k+1\n                tmp=[]\n\n        k=k+1\n        return k\n```\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1092605344","body":"### 思路\n\n1. 对于空链表与只有一个数的链表，直接返回\n2. 旋转链表k次，求k%num(链表总长)，避免k太长\n3. 用两个while循环，第一个循环是循环k%num次，第二个循环是每次都找最到链表的末尾，然后把末尾作为新的head\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n\n        if head==None or head.next==None:\n            return head\n        \n        i=0\n        p1=head\n        \n        # 计算链表的总长度\n        tmp_p=head\n        num=1\n        while tmp_p.next !=None:\n            tmp_p=tmp_p.next\n            num=num+1\n        \n        k=k%num\n\n        while  i<k:\n            while p1.next !=None:\n                p2=p1\n                p1=p1.next\n            \n            p1.next=head\n            head=p1\n            p2.next=None\n            \n            i=i+1\n        \n        return head\n```\n\n### 复杂度分析\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092641023","body":"### 思路\n\n利用递归，两两交换元素，返回交换后的头节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef e2(head): # 交换两个元素，并返回head值\n    p1=head\n    if p1:\n        p2=head.next\n    else:\n        p2=None\n\n    if p1!=None and p2!=None:\n        p1.next=e2(p2.next)\n        p2.next=p1\n    elif p1!=None and p2==None:\n        return p1\n    return p2\n\nclass Solution:\n\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head==None or head.next==None:\n            return head\n\n        p1=head\n        p2=head.next\n        p3=p2 # 最终返回\n\n        e2(p1)\n\n        return p3\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093808703","body":"### 思路\n\n先将链表转为list，再进行迭代。\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \n        if not head:\n            return None\n        # 先计算出链表的长度\n        p1=head\n        n=0.0\n        data=[]\n        while p1:\n            data.append(p1.val) # 将数据存到list中\n            p1=p1.next \n            n+=1\n        \n\n        def buildT(arr):\n            nn=float(len(arr))\n            mm=int(nn/2+0.5)\n\n            if nn<=0:\n                return None\n\n            mnode=TreeNode(val=arr[mm-1])\n            mnode.left=buildT(arr[0:mm-1])\n            mnode.right=buildT(arr[mm:int(nn)])\n\n            return mnode    \n\n        return buildT(data)\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094163583","body":"### 思路1：循环遍历两个链表\n\n先固定指向链表1的指针，遍历链表2，遍历结束没有，则指向下一个节点。\n\npython，最后计算超时\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        p1=headA\n        p2=headB\n        while p1:\n            while p2:\n                if p1!=p2:\n                    p2=p2.next\n                else:\n                    return p2\n            if not p2:\n                p2=headB\n            p1=p1.next\n\n        return None\n```\n\n### 复杂度分析\n\n时间复杂度：O(m*n)\n\n空间复杂度：O(1)\n\n### 思路2-双指针\n\n一个指针先遍历A，再遍历B；\n\n另一个指针先遍历B，再遍历A，到达交点的时候，走过的路径相同。\n\n### 代码：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        \"\"\"参考：双指针\"\"\"\n        A,B =headA,headB\n        while A!=B:\n            A=A.next if A else headB\n            # 这一行的逻辑是：\n            # if A非空，则A=A.next 否则A=headB\n            B=B.next if B else headA\n        return A\n```\n\n### 复杂度分析：\n\n时间复杂度：O(m+n)\n\n空间复杂度：O(1)\n\n\n### 思路3-哈希表\n\n先将其中一个链表存到哈希表中，此时再遍历另外一个链表查找重复节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        \"\"\"参考：哈希表\"\"\"\n        s=set()\n        p,q=headA,headB\n        while p:\n            s.add(p)\n            p=p.next\n        while q:\n            if q in s:\n                return q\n            q=q.next\n\n        return None\n```\n\n### 复杂度分析：\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094499151","body":"### 思路\n\n哈希表\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        \n        # 将遍历到的所有放入set中\n        tmp=set()\n        p1=head\n        pos=-1\n\n        while p1:\n            pos+=1\n            if p1 in tmp:\n                return p1\n            tmp.add(p1)\n            p1=p1.next\n        return None\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095960901","body":"### 思路\n\n哈希表+双向链表。\n\n\n### 代码\n\n```python\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n\n```\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(capacity）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097507982","body":"### 思路\n\n递归，深度优先搜索\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n\n        if root is None:\n            return 0\n        else:\n            left_height=self.maxDepth(root.left)\n            right_height=self.maxDepth(root.right)\n            return max(left_height,right_height)+1\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099123460","body":"### 思路\n\n深度优先搜索\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        \n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val !=q.val:\n            return False\n        else:\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```\n\n### 复杂度分析\n\n时间复杂度：O(min(m,n))\n空间复杂度：O(min(m,n))\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100652823","body":"### 思路\n\n广度优先搜索\n\n### 代码\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        \"\"\"广度优先\"\"\"\n        queue=[root]\n        ans=root.val\n        while queue:\n            ans=queue[0].val\n            n=len(queue)\n            for i in range(n):\n                node=queue[0]\n                del queue[0]\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans\n```\n\n### 复杂度分析\n\n时间复杂度：O(N）\n\n空间复杂度：O(Q)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101914127","body":"### 思路\n\nfor循环，判断与target相减的数是否在数组中。\n\n### 代码\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        l=[]\n        for index,num in enumerate(nums):\n            s=target-num\n            if s in nums[index+1:]:\n                l.append(index)\n                i2=nums[index+1:].index(s)+index+1\n                l.append(i2)\n            \n        return l\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103388181","body":"### 思路\n\n首先记录每个数字的出现次数，再排序，得到前k个元素\n\n### 代码\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # 首先对数组排序\n        nums.sort()\n        pre=nums[0]\n        n=0\n        cn=dict()\n        for i in nums:\n            if i==pre:\n                n+=1\n            else:\n                cn[pre]=n\n                n=1\n            cn[i]=n\n            pre=i\n        # 对字典按照value排序\n        \n        cn2=dict(sorted(cn.items(),key=lambda kv:(kv[1],kv[0]),reverse=True))\n\n        i=0\n        r=[]\n        for key in cn2.keys():\n            i+=1\n            if i<=k:\n                r.append(key)\n            else:\n                break\n        return r\n```\n\n### 复杂度分析\n\n时间复杂度：O(nlogn)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104641841","body":"### 思路\n\n哈希表\n\n\n### 代码\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans=0\n        for p in points:\n            cnt=defaultdict(int)\n            # defaultdict的作用是在于，当字典里的key不存在但被查找时，返回的不是keyError而是一个默认值. int时，默认是0\n            for q in points:\n                dis=(p[0]-q[0])**2+(p[1]-q[1])**2\n                cnt[dis]+=1 # 这里将距离数存在字典里\n            for m in cnt.values():\n                ans+=m*(m-1)\n        return ans\n```\n\n### 复杂度分析\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107376611","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:\n            return []\n        one_word=len(words[0]) # 一个字符的长度\n        word_num=len(words)  # words中一共有多少个字符\n        n=len(s) \n        words=Counter(words)\n        res=[]\n        for i in range(0,one_word): # 这里的range范围为什么是(0,one_word)?\n            cur_cnt=0\n            left=i\n            right=i\n            cur_Counter=Counter()\n            while right+one_word<=n:\n                w=s[right:right+one_word]\n                right+=one_word # right加上一个one_word的长度\n                if w not in words:\n                    left=right\n                    cur_Counter.clear()\n                    cur_cnt=0\n                else:\n                    cur_Counter[w]+=1 # 用Counter来计数\n                    cur_cnt+=1 # 组成cur_Counter中的所有单词个数\n                    while cur_Counter[w]>words[w]:\n                        left_w=s[left:left+one_word]\n                        left+=one_word\n                        cur_Counter[left_w]-=1 \n                        cur_cnt-=1\n                    if cur_cnt==word_num:\n                        res.append(left)\n        return res\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107690724","body":"### 思路\n\n参考：同余定理+前缀和\n\n### 代码\n\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k # 加k是为了正负求余统一\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(min(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108110016","body":"### 思路\n\n快慢指针，快指针一次走两步，慢指针一次走一步\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        pslow=head\n        pfast=head\n        nn=0\n        # 快慢指针\n        while pfast:\n            pfast=pfast.next\n            nn+=1\n            if not nn%2: # nn为偶数\n                pslow=pslow.next\n            \n        return pslow\n```\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109594487","body":"### 思路\n\n双指针法\n\n### 代码\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # 双指针\n        p1=0\n        p2=1\n\n        while p2<len(nums):\n            if nums[p2]!=nums[p1]:\n                nums[p1+1]=nums[p2]\n                p1+=1\n            p2+=1\n        return p1+1\n```\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110527355","body":"# 思路\n二分查找\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        b=0\n        e=len(nums)-1\n        while b<=e:\n            mid=floor((b+e)/2)\n            if nums[mid]==target:\n                return mid\n            elif target<nums[mid]:\n                e=mid-1\n            else:\n                b=mid+1\n        return b\n```\n\n时间复杂度：*O*(log*n*)，其中 n 为数组的长度。二分查找所需的时间复杂度为*O*(log*n*)。\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111740651","body":"# 思路\n\n利用堆\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        h=[]\n        ans=[]\n        for i in range(k):\n            heapq.heappush(h,(-nums[i],i))\n        ans.append(-h[0][0])\n        for i in range(k,len(nums)):\n            heapq.heappush(h,(-nums[i],i))\n            while h[0][1]<i-k+1:\n                heapq.heappop(h)\n            ans.append((-h[0][0]))\n        return ans\n```\n\n时间复杂度：O(log k)\n\n空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113177739","body":"### 代码\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        who_t=[0 for i in range(n)]\n        trusted = [0 for i in range(n)]\n        for i in trust:\n            who_t[i[0]-1]+=1\n            trusted[i[1]-1] += 1\n        \n        for i in range(len(who_t)):\n            if who_t[i]==0 and trusted[i]==n-1:\n                return i+1\n        return -1\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuguang520-lab":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037440","body":"##思路\n模拟加法运算，注意将数组反转\n\n##code\n```cpp\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {//判断是否有进位\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);//判断k是否比数组的长度要长\n        }\n        reverse(res.begin(), res.end());\n        return res;\n```\n##复杂度分析\n- 实践复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646031","body":"#思路\n使用的是暴力解法没有使用官方的前后遍历所以时间复杂度和空间复杂度比较高\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result;\n        vector<int > index;\n        int len = s.length();\n        for(int i = 0; i< len; i++)\n        {\n            if(s.at(i) == c)//将字符串转换成字符在进行比较\n            {\n                index.push_back(i);\n            }\n        }\n        int len_index = index.size();\n        for(int i = 0; i < len; i++)\n        {\n            int dis_min = len;//初始化为len\n            for(int j =0; j<len_index; j++)\n            {\n                dis_min = min(abs(i-index[j]),dis_min);\n            }\n            result.push_back(dis_min);\n        }\n    return result;\n    }\n};\n```\n#复杂度分析\n- 时间复杂度O(cN) c表示c字符出现的数量，n为字符串的长度\n-空间复杂度O(2N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086816450","body":"# 思路\n使用数组模拟栈的用法，定义一个容量，栈顶和栈底就很容易实现\n# code\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        element = new int[maxSize];\n        top_stack = -1;\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if(top_stack == maxsize - 1)\n        {\n            return;//超过容量，不进行操作\n        }\n        element[++top_stack] = x;\n    }\n    \n    int pop() {\n        if(top_stack < 0)\n        {\n            return -1;\n        }\n        return element[top_stack--];\n    }\n    \n    void increment(int k, int val) {\n        if(top_stack < k - 1) //按照最短长度进行累加\n        {\n            for(int i = 0; i <= top_stack; i++)\n            {\n                element[i] += val;\n            }\n        }\n        else\n        {\n            for(int i = 0; i < k; i++)\n            {\n                element[i] +=val;\n            }\n        }\n    }\nprivate:\n    int* element;//数组\n    int top_stack;//栈顶\n    int maxsize;//最大容量\n};\n```\n# 时间复杂度分析\n- 空间复杂度O(N)\n\n- 时间复杂度O(N) 利用了一个数组进行模拟","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088440527","body":"# 思路\n利用两个栈来实现队列的功能，一个栈用来接受输入，一个栈接受是输出，如果输出栈没有数字了就从输入栈中添加\n# code\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1_input.push(x);\n    }\n    \n    int pop() {\n        if(s1_input.size() == 0 &&s2_output.size() == 0)\n        {//判断队列中是否有元素\n            exit(0);\n        }\n        if(!s2_output.empty())//输出栈有元素就直接从输出栈输出\n        {\n            int i = s2_output.top();\n            s2_output.pop();\n            return i;\n        }\n        else\n        {\n            while(!s1_input.empty())\n            {\n                s2_output.push(s1_input.top());\n                s1_input.pop();\n            }\n            int i = s2_output.top();\n            s2_output.pop();\n            return i;\n        }\n    }\n    \n    int peek() {//和pop函数一样，少了删除\n        if(s1_input.size() == 0 &&s2_output.size() == 0)\n        {\n            exit(0);\n        }\n        if(!s2_output.empty())\n        {\n            int i = s2_output.top();\n            return i;\n        }\n        else\n        {\n            while(!s1_input.empty())\n            {\n                s2_output.push(s1_input.top());\n                s1_input.pop();\n            }\n            int i = s2_output.top();\n            return i;\n        }\n    }\n    \n    bool empty() {\n        return (s1_input.empty() && s2_output.empty());\n    }\nprivate:\n    stack<int> s1_input;\n    stack<int> s2_output;\n};\n```\n# 复杂度分析\n- 时间复杂度 O（1）\n- 空间复杂度O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090393004","body":"# 思路\n使用滑动窗口来解决\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n# 复杂度分析\n- 时间复杂度O(nlogn)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091880599","body":"# 思路\n使用闭合环\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(n)\n- 空间复杂度O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092445362","body":"# 思路\n增加一个空节点使对于头节点的操作和其余节点的操做一样\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr||head->next == nullptr )\n        {\n            return head;\n        }\n        ListNode* pre_head = new ListNode;//创建空节点使头节点的操作和另外节点的操作统一\n        pre_head->next = head;\n        ListNode* tem = pre_head;\n        while(tem->next !=nullptr&&tem->next->next !=nullptr)\n        {\n            ListNode* first = tem->next;\n            ListNode* last = tem->next->next;\n\n            first->next = last->next;\n            last->next = first;\n            tem->next = last;\n            tem = first;\n        }\n        return pre_head->next;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093967886","body":"# 思路\n使用快慢指针找出中点所在的位置，将其作为节点建树\n```cpp\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(nlogn)\n- 时间复杂度O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094829390","body":"# 思路\n利用双指针遍历两个链表，在指针变为空时指向另一条链表，最后会相遇\n# code\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      //双指针\n      ListNode* p_a = headA;\n      ListNode* p_b = headB;\n      if(p_a==nullptr||p_b==nullptr)\n      {\n          return nullptr;\n      }\n      while(p_a!=p_b)\n      {\n          p_a = p_a==nullptr?headB:p_a->next;\n          p_b = p_b == nullptr?headA:p_b->next;\n      }\n    return p_a;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(m+n)\n- 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094743683","body":"# 思路\n采用快慢指针法，先找出相遇的点在哪里，然后将slow指针重新开始，fast指针从相遇的点开始但是速度要和slow一致，在下次他们相遇的点处就是循环入口出\n# code\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        if(head == nullptr||head->next==nullptr||head->next->next==nullptr)\n            return NULL;\n        //找出相遇点slow\n        while(fast->next!=nullptr && fast->next->next!= nullptr)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow == fast)\n            {\n                slow = head;\n                while(slow != fast)//以相同的速度前进，相遇的点就是循环开始点\n                {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                return slow;\n            }\n        }\n        return slow == fast?slow:NULL;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097856512","body":"# 思路\n遍历左子树得出左子树的深度，遍历右子树得到右子树的深度，最后取最大值在加1就是最大深度\n# code\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr)\n        {\n            return 0;\n        }\n        \n        int left_max = maxDepth(root->left);\n        int right_max = maxDepth(root->right);\n        return max(left_max,right_max) + 1; \n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098842682","body":"# 思路\n利用前序遍历对树结构进行比较，首先比较树的结构，在对值进行比较\n# code \n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) { \n    bool root_is_equal;\n    //对根节点是否为空来判断结构是否相等\n    if(p==nullptr && q == nullptr)\n    {\n        return true;\n    }\n    if(p!=nullptr && q==nullptr)\n    {\n       return false;\n    }\n    if(p==nullptr && q!=nullptr)\n    {\n       return false;\n    }\n    //节点不为空，比较值\n    if(p->val == q->val)\n    {\n        root_is_equal = true;\n    }\n    else\n    {\n        root_is_equal = false;\n    }\n\n    bool left_is_equal = isSameTree(p->left,q->left);\n    bool right_is_equal = isSameTree(p->right,q->right);\n    return (root_is_equal&&left_is_equal && right_is_equal);\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度o(logn)\n-空间复杂度o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099839162","body":"# 思路\n使用bfs，用两个队列来分别存储节点和值，节点的值等于前一个节点的值乘以10再加上自身的值\n# code\n```cpp\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        queue<TreeNode*> nodequeue;\n        queue<int> valqueue;\n        nodequeue.push(root);\n        valqueue.push(root->val);\n        int sum = 0;\n        while(!nodequeue.empty())\n        {\n            TreeNode* node = nodequeue.front();\n            nodequeue.pop();\n            int num = valqueue.front();\n            valqueue.pop();\n            TreeNode* left = node->left;\n            TreeNode* right = node->right;\n            if(left==nullptr&&right==nullptr)\n            {\n                sum += num;\n            }\n            else\n            {\n                if(left!= nullptr)\n                {\n                    nodequeue.push(left);\n                    valqueue.push(left->val+num*10);\n                }\n                if(right != nullptr)\n                {\n                    nodequeue.push(right);\n                    valqueue.push(right->val + num*10);\n                }\n            }\n        }\n        return sum;\n    }\n\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100584913","body":"# 思路\n使用bfs，对每一层进行一次循环，并且输出循环开始的数据就是每一层最左边的位置。\n# code\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int left;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty())\n        {\n            int size = q.size();\n            for(int i = 0; i<size; i++)//每一层的进行循环\n            {\n                TreeNode* cur = q.front();\n                q.pop();\n                if(cur->left != nullptr)\n                {\n                    q.push(cur->left);\n                }\n                if(cur->right != nullptr)\n                {\n                    q.push(cur->right);\n                }\n                if(i == 0)//最左边的值\n                {\n                    left = cur->val;\n                }\n            }\n        }\n        return left;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度 O(N), 每一个节点都会遍历\n- 空间复杂度O(N), 保存每一层的数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100876464","body":"# 思路\n首先使用前序遍历整个二叉树，将一个节点记录到string对象中，同时需要带有间隔符，遇到空指针也需要有标记，最后在恢复阶段，需要先将data拆分成一个链表，每一个链表节点代表二叉树的节点，在前序递归过程中，链表不断缩短，最终恢复二叉树\n# code\n```cpp\nclass Codec {\npublic:\n    void rserialize(TreeNode* root, string& str) {\n        if (root == nullptr) {\n            str += \"None,\";\n        } else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }\n    }\n\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if (dataArray.front() == \"None\") {\n            dataArray.erase(dataArray.begin());\n            return nullptr;\n        }\n\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        for (auto& ch : data) {\n            if (ch == ',') {\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(ch);\n            }\n        }\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度o(n)\n- 空间复杂度o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101446829","body":"# 思路\n选一种遍历方式将树的节点值进行保存，同时还有行和列，然后对列进行排行\n# code\n```cpp\nclass Solution {\npublic:\n    vector<tuple<int,int,int>> node; \n    void dfs(TreeNode* root, int row, int col)\n    {\n        if(root==nullptr)\n        {\n            return;\n        }\n        node.emplace_back(col,row,root->val);\n        dfs(root->left,row+1,col-1);\n        dfs(root->right,row+1,col+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root,0,0);\n        sort(node.begin(),node.end());//进行排序，按照列行值。\n        int last_col = INT_MIN;\n        vector<vector<int>> result;\n        for(const auto& [col,row,val] : node)\n        {\n            if(col != last_col)\n            {\n                last_col = col;\n                result.emplace_back();//只是创建下一个数组\n            }\n            result.back().emplace_back(val);\n        }\n        return result;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(nlogn)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102768725","body":"# 思路\n使用哈希表储存数组中的值，并且哈希表需要在检查完是否存在有结果之后才添加数组元素，不然会被取代。\n# code\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int>  m;\n        for(int i = 0; i< nums.size();i++)\n        {\n            auto it = m.find(target - nums[i]);\n            if(it!=m.end())\n            {\n                return {i, it->second};\n            }\n            m[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103991261","body":"# 思路\r\n遍历数组，使用哈希表存储数字出现的次数，将哈希表放入优先队列（从大到小进行了排序）中进行处理，当优先队列的长度等于K时，比较top元素的值和当前循环值的大小，将大的数字插入进去\r\n# code\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\r\n    static bool compare(pair<int,int> m, pair<int, int> n)//需要采用静态函数，不然下面的比较函数需要采用成员函数指针\r\n    {\r\n        return m.second > n.second;\r\n    }\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int,int> m;\r\n        for(int i = 0;i < nums.size(); i++)\r\n        {\r\n            m[nums[i]]++;\r\n        }\r\n\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&compare)> q(compare);\r\n        for(pair<int,int> i : m)\r\n        {\r\n            if(q.size() == k)\r\n            {\r\n                if(q.top().second < i.second)\r\n                {\r\n                    q.pop();\r\n                    q.emplace(i);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                q.emplace(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while(!q.empty())\r\n        {\r\n            res.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n- 时间复杂度O(Nlok)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105288898","body":"# 思路\r\n哈希表以距离作为key，出现一样的距离就对value值加1\r\n# code\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>> &points) {\r\n        int ans = 0;\r\n        for (auto &p : points) {\r\n            unordered_map<int, int> cnt;\r\n            for (auto &q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                ++cnt[dis];\r\n            }\r\n            for (auto &[_, m] : cnt) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n- 时间复杂度O(n2)\r\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105967862","body":"# 思路\r\n滑动窗口，收缩条件时右指针的值在哈希表中已经出现\r\n# code\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_map<char,int> window;\r\n        int left = 0, right = 0;\r\n        int len = 0;\r\n        while(right < s.length())\r\n        {\r\n            char c = s[right];\r\n            window[c]++;\r\n            right++;\r\n            //收缩左侧\r\n            while(window[c] > 1)\r\n            {\r\n                char d = s[left];\r\n                left++;\r\n                window[d]--;\r\n            }\r\n            len = max(len,right - left);\r\n        }\r\n        return len;\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n- 时间复杂度O（n）\r\n- 空剑复杂度O（k）k为出现的字符个数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107858762","body":"# 思路\n使用前缀和 和哈希表\n# code\n···cpp\nlong long allSum = 0;\n        for (auto& num : nums)\n            allSum += num;        \n        if (allSum < p) return -1;\n\n        int mod = 0;        \n        mod = allSum % p;\n        if (mod == 0) return 0;\n        unordered_map<int, int> dict; // dict: 某个前缀和%k得到的余数->pos\n        dict[0] = -1;\n        const int len = nums.size();\n        int minLen = len;\n        long long preSum = 0;\n        for (int i = 0; i < len; i++)\n        {\n            preSum += nums[i];\n            int curMod = preSum % p;\n            int target = (curMod - mod + p) % p; /* 这里curMod - mod 需要 + p使其成为一个>p的数, 方便后面求mod p */\n            if (dict.count(target))\n                minLen = min(minLen, i - dict[target]);\n            dict[curMod] = i; /* 记录curMod的最后一次出现时的index: 不论此时哈希表里面有没有curMod, 都需要更新其index */\n        }\n        return minLen == len ? -1 : minLen;\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108078289","body":"# 思路\n快慢指针\n# code\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode * slow, * fast;\n        slow = fast = head;\n        while(fast !=nullptr && fast->next!= nullptr)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109298908","body":"# 思路\n直接暴力遍历，但是当发现相同值时下标不增加。\n# code\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.size() == 0||nums.size() == 1)\n        {\n            return nums.size();\n        }\n        for(int i = 1; i< nums.size();)\n        {\n            if(nums[i] == nums[i-1])\n            {\n                nums.erase(nums.begin() + i);//删除了节点之后i不能增加\n            }\n            else\n            {\n                i++;\n            }\n        }\n        return nums.size();\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(n2),vector的成员函数erase函数需要线性时间\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110514456","body":"# 思路\n二分查找\n# code\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size();\n        while(left < right)\n        {\n            int mid = left + (right - left) / 2;\n            if(nums[mid] < target)\n            {\n                left = mid + 1;\n            }\n            else if(nums[mid] > target)\n            {\n                right = mid;//right表示不可达的区域\n            }\n            else\n            {\n                return mid;\n            }\n        }\n        return left;//表示应该插入的位置\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(logn)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111983027","body":"# 思路\n采用分块进行处理，利用前缀和后缀\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        //使用分块处理，利用前缀和后缀来表达一个区间的最大值。\n        //初始化前缀\n        vector<int> prefixmax(nums.size());\n        for(int i = 0; i< nums.size(); i++)\n        {\n            if(i % k == 0)\n            {\n                prefixmax[i] = nums[i];//处于区间的开始\n            }\n            else\n            {\n                prefixmax[i] = max(prefixmax[i-1], nums[i]);\n            }\n        }\n        vector<int> suffixmax(nums.size());\n        for(int i = nums.size() - 1; i>= 0; i--)\n        {\n            if( i == nums.size() - 1 || (i+1) % k == 0)\n            {\n                suffixmax[i] = nums[i]; //处于区间末尾\n            }\n            else\n            {\n                suffixmax[i] = max(suffixmax[i+1], nums[i]);\n            }\n        }\n\n        vector<int> ans;\n        for(int i =0; i<= nums.size() - k ; i++)\n        {\n            ans.push_back(max(suffixmax[i], prefixmax[i + k - 1]));//交叉域就是所要求的\n        }\n        return ans;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度o(n)\n- 空间复杂度o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037807","body":"# 思路：两次遍历，两次转换\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        array_num = 0\n        for i in range(n):\n            array_num += num[i] * (10 ** (n-i-1))\n        total = array_num + k\n        ans = []\n        for s in str(total):\n            ans.append(int(s))\n        return ans \n```\n时间复杂度:O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086594925","body":"#思路:笨蛋解法，第一次遍历找位置，第二次遍历求距离最小值\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        position = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n\n        for i in range(len(s)):\n            dis = []\n            for p in position:\n                dis.append(abs(i-p))\n            ans.append(min(dis))\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087688854","body":"# 思路：遍历字符串，遇到]之前一直入栈，遇到[之后出栈，找到重复的字符和次数后再入栈。最后栈内就是最终结果\n```python \nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for item in s :\n            if  item == ']':\n                repeatstr = ''\n                repeatcount = ''\n                while stack and stack[-1] != '[':\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatcount = stack.pop() + repeatcount\n                stack.append(repeatstr * int(repeatcount))\n            else:\n                stack.append(item)\n        ans = ''.join(stack)\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088657357","body":"# 思路：\n在push 的时候将先入队的元素放到后面\n```pyhon\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack =[]\n        self.aux_stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        while self.stack:\n            self.aux_stack.append(self.stack.pop())\n        self.aux_stack.append(x)\n        while self.aux_stack:\n            self.stack.append(self.aux_stack.pop())\n    \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack.pop()\n        \n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack[-1] \n        \n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stack) == 0:\n            return True\n        else:\n            return False\n\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090389244","body":"# 思路：计数，如果两个数组计数信息一致，那么排序信息一致\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n时间复杂度：O(n**2）\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091854719","body":"# 思路\n快慢指针找到倒数第k个结点，然后改变指针的指向\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 找到倒数第k个结点\n        if head:\n            p1,p2 = head,head\n            count = 1\n            i = 0\n            while i<k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n    \n        while p2.next:\n            p1 = p1.next\n            p2 = p2.next\n        if p1.next:\n            tmp =p1.next\n        else:\n            return head\n        p1.next =None # 倒数第k+1个\n        p2.next = head # 倒数第k个\n        return tmp\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094258014","body":"# 思路：\n双指针法，走到头就从另外一条链表的头开始，相遇位置就是相交位置\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a,b = headA,headB\n        while a!=b:\n            if a:\n                a = a.next\n            else:\n                 a = headB\n            if b:\n                b = b.next\n            else:\n                b = headA\n        return a\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095933072","body":"# 思路\n快慢指针，快指针每次走两步，慢指针每次走一步，相遇后快指针从头开始。下次相遇的地方就是环的起点。\n```python \n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        x = None\n        slow = fast =head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while x!=slow:\n            x = x.next\n            slow =slow.next\n        return x\n            \n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098882825","body":"# 思路：\n递归，高度为左右子树高度的最大值加一\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n时间复杂度：O(N)\n空间复杂度：O(H)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098873603","body":"# 思路\n递归，判断左右子树是不是分别相同\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        else:\n            return (p.val==q.val) and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) \n```\n时间复杂度：O(N) N为总节点数\n空间复杂度：O(H) H为树的高度","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101432305","body":"# 思路：\n三层的哈希表，分别按照x,y,val排序\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        seen = collections.defaultdict(lambda: collections.defaultdict(list))\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n        dfs(root)\n        ans = []\n        for x in sorted(seen):\n            level = []\n            for y in sorted(seen[x]):\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n        return ans \n```\n时间复杂度:O(nlogn)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102627232","body":"# 思路：\n哈希表存想要目标数字，遇到了就返回下标\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        wanted = {}\n        for i,num in enumerate(nums):\n            if num in wanted:\n                return [wanted[num],i]\n            wanted[target-num] = i\n\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106466959","body":"# 思路\n滑动窗口+哈希表\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        k, res, c_dict = -1, 0, {}\n        for i, c in enumerate(s):\n            if c in c_dict and c_dict[c] > k:  # 字符c在字典中 且 上次出现的下标大于当前长度的起始下标\n                k = c_dict[c]\n                c_dict[c] = i\n            else:\n                c_dict[c] = i\n                res = max(res, i-k)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107520252","body":"# 思路\n滑动窗口\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        allWords = collections.Counter(words)\n        wordNum = len(words)\n        wordLen = len(words[0])\n        res = []\n        for i in range(len(s) - wordNum * wordLen + 1):\n            subWords = collections.defaultdict(int)\n            index = i\n            while index < i + wordNum * wordLen:\n                curWord = s[index: index + wordLen]\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\n                    break\n                subWords[curWord] += 1\n                index += wordLen\n            if index == i + wordNum * wordLen:\n                res.append(i)\n        return res\n```\n时间复杂度：O(s)\n空间复杂度：O(m*n*k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107858299","body":"# 思路\n哈希表+同余定理\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n        if mod == 0:\n            return 0\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```\n时间复杂度：O（N）\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108313591","body":"# 思路\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow,fast = head,head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n时间复杂度：O（N）\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109760265","body":"# 思路：\n双指针，读指针遇到不同的就在写指针的位置写入。\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        read,write = 0,0\n        while read < len(nums):\n            if nums[read] != nums[write]:\n                write += 1\n                nums[write] = nums[read]\n            read += 1\n        return write+1\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110696198","body":"# 思路：\n二分查找\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l,r  = 0,len(nums)\n        while l < r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid\n            else:\n                l = mid + 1\n        return l \n```\n时间复杂度：O(logn)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111692737","body":"# 思路：\n单调队列\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        ans = []\n        q = collections.deque() # 保存下标\n        for i in range(len(nums)):\n            while  q and nums[q[-1]] <= nums[i]:\n                q.pop()\n            while q and i-q[0] >= k:\n                q.popleft()\n            q.append(i)\n            if i >= k-1:\n                ans.append(nums[q[0]])\n        return ans  \n```\n时间复杂度：O(n)\n空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113130197","body":"# 思路\n寻找入度为n-1同时出度为0的节点\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree,out_degree = [0] * (n+1), [0]*(n+1)\n        for a,b in trust:\n            in_degree[b] += 1\n            out_degree[a] += 1\n        for i in range(1,n+1):\n            if in_degree[i] == n-1 and out_degree[i] == 0:\n                return i\n        return -1\n\n            \n```\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruceleeqaq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086039762","body":"思路:  模拟加法，先将数组转换成数字 再将结果转换为数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661332","body":"\n\n```class Solution:\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n        class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans    if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n```\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895082","body":"\n\n```python\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```\n\n复杂度\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088767021","body":"\nclass MyQueue:\n\n    def __init__(self):\n        self.L = []\n\n    def push(self, x: int) -> None:\n        self.L.append(x)\n\n    def pop(self) -> int:\n        print(self.L)\n        return self.L.pop(0)\n\n    def peek(self) -> int:\n        return self.L[0]\n\n\n    def empty(self) -> bool:\n        if(len(self.L) == 0):\n            return True\n        else:\n            return False\n\n### 复杂度\n\n时间：O(1)\n\n空间：O(N)\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093009328","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 创建头结点\n        cur = ListNode(0)\n        cur.next = head\n        \n        first = cur\n        while cur.next and cur.next.next:\n            n1 = cur.next\n            n2 = n1.next\n            n3 = n2.next\n            \n            cur.next = n2\n            n2.next = n1\n            n1.next = n3\n            \n            cur = n1\n        return first.next\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094068320","body":"class Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (nullptr == head) return nullptr;\n        return getTree(head, nullptr);\n    }\n    TreeNode* getTree(ListNode* startPtr, ListNode* endPtr){\n        if (startPtr == endPtr) return nullptr;\n        ListNode* lowPtr = startPtr;\n        ListNode* fastPtr = startPtr;\n        while(endPtr != fastPtr && endPtr != fastPtr->next){\n            lowPtr = lowPtr->next;\n            fastPtr = fastPtr->next->next;\n        }\n        TreeNode* root = new TreeNode(lowPtr->val);\n        root->left = getTree(startPtr,lowPtr);\n        root->right = getTree(lowPtr->next,endPtr);\n        return root;\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098211347","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int leftHeight = maxDepth(root.left);\n        int rightHeight = maxDepth(root.right);\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n}\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086041856","body":"## 思路\n从最低位想相加开始计算起\n\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n## 复杂度\ntime O(N)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086660724","body":"## 思路\n左右遍历 问题在于初始的c位置怎么算,算到数组中间好了\n对于prev\n因为如果不除以2的话，INT_MIN= -2^31，而刚开始的时候i-INT_MIN=i+2^31就会发生溢出，但是INT_MAX-i就不会发生溢出了，所以INT_MAX就没必要除以2了，为了看起来舒服点都除以2了\n```\nclass Solution {\npublic:\n   vector<int> shortestToChar(string S, char C) {\n       vector<int> distance(S.size(), 0);\n       int prev = INT_MIN/2;\n       for(int i = 0; i < S.size(); i ++){\n           if(S[i] == C) prev = i;\n           distance[i] = i - prev;\n       }\n       prev = INT_MAX/2;\n       for(int i = S.size() - 1; i >= 0; i --){\n           if(S[i] == C) prev = i;\n           distance[i] = min(distance[i], prev - i);\n       }\n       return distance;\n   }\n};\n```\n## 复杂度\n时空O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087668469","body":"# idea\n multiStack for num\n'['  将当前结果串resultStr 与 multi 的值进行入栈操作；\n']'，进行出栈操作 同时复制相应的倍数加入尾部\n```cpp\nclass Solution {\n    public:\n    string decodeString(string s) {\n        std::stack<int> multiStack;\n        std::stack<string> stringStack;\n        string resultStr;\n        int curMulti = 0;\n\n        for (int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if(c == '[') {\n                multiStack.push(curMulti);\n                stringStack.push(resultStr);\n                curMulti = 0;\n                resultStr.clear();\n            }\n            else if(c == ']') {\n                int tmp = multiStack.top();\n                multiStack.pop();\n                string tmpStr;\n                for( int i = 0; i < tmp; i++ ) {\n                    tmpStr.append(resultStr);\n                }\n                resultStr = (stringStack.top() +tmpStr);\n                stringStack.pop();\n\n            }\n            else if (c >='0' && c <= '9') {\n                curMulti = curMulti* 10 + (c-'0');\n            }\n            else {\n                resultStr.append({c});\n            }\n        }\n        return resultStr;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091868256","body":"## idea\nfast slow pointer be careful with that head->next == NULL\nand the k id bigger than the length of the LinkList\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* fast;\n        ListNode* slow;\n        \n        if (k == 0||head==NULL||head->next == NULL) return head;\n         slow = head;\n         fast = head;\n         int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n\n\n         k = k % n;// ring \n        while (k > 0) {\n            fast = fast->next;\n            k--;\n       }\n       \n       while (fast->next != NULL) {\n           fast = fast->next;\n           slow = slow->next;\n       }\n       fast->next = head;\n       ListNode* cur = slow->next;\n       slow->next = NULL;\n       return cur;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093015599","body":"# idea\nsave the prev pointer as well as the prehead\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (nullptr == head || nullptr == head->next) return head;\n        ListNode* preHead = new ListNode(-1,head);\n        ListNode* tmpPtr = preHead;\n        ListNode *cur = preHead->next;\n        while (nullptr != cur && nullptr != cur->next){\n            ListNode *second = cur->next;\n            cur->next = second->next;\n            second->next = cur;\n            tmpPtr->next = second;\n            tmpPtr = cur;\n            cur = cur->next;\n        }\n        return preHead->next;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094280660","body":"## idea\nAB链表相接,继续走总能走到\n```cpp\nif (headA == nullptr || headB == nullptr) return nullptr;\n\nListNode *pA = headA;\nListNode *pB = headB;\nwhile (pA != pB) {\n    pA = pA ==nullptr ? headB : pA->next;\n    pB = pB == nullptr ? headA : pB->next;\n}\nreturn pB;","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100663336","body":"## idea\nusing bfs \nreturn the ans->val\n``` cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        TreeNode* ans = NULL;\n        q.push(root);\n        while (!q.empty()) {\n            ans = q.front();\n            int size = q.size();\n            while (size--) {\n                TreeNode* cur = q.front();\n                q.pop();\n                if (cur->left )\n                    q.push(cur->left);\n                if (cur->right)\n                    q.push(cur->right);\n            }\n        }\n        return ans->val;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100891288","body":"## idea\n序列化：后序遍历，前构造左右子树字符串，再和当前节点字符串合并\n反序列化：前序遍历，先创建当前节点，再创建左右子树，用队列保存构造值\n```cpp\nclass Codec {\npublic:\n    void rserialize(TreeNode* root, string& str) {\n        if (root == nullptr) {\n            str += \"None,\";\n        } else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }\n    }\n\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if (dataArray.front() == \"None\") {\n            dataArray.erase(dataArray.begin());\n            return nullptr;\n        }\n\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        for (auto& ch : data) {\n            if (ch == ',') {\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(ch);\n            }\n        }\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101329887","body":"## idea\r\n1.dfs and store the node \r\n\r\n2.hashmap key is the x-val ,val is the pair(y-val, val) sorting the 2Dvector, adding the every col with the col order\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    map<int, vector<vector<int>>> S;\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        vector<vector<int>> res;\r\n        for(auto& [k, v] : S) {\r\n            sort(v.begin(), v.end());\r\n            vector<int> col;\r\n            for(auto& p : v) col.push_back(p[1]);\r\n            res.push_back(col);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    void dfs(TreeNode* root, int x, int y) {\r\n        if(!root) return;\r\n        S[y].push_back({x, root->val});\r\n        dfs(root->left, x + 1, y - 1);\r\n        dfs(root->right, x + 1, y + 1);\r\n    }\r\n};\r\n\r\n### timespace analysis\r\n总的来说，我们需要进行三次排序，分别是对 x 坐标，y 坐标 和 值。\r\n\r\n那么时间复杂度是多少呢？我们来分析一下：\r\n\r\n哈希表最外层的 key 总个数是最大是树的宽度。\r\n\r\n哈希表第二层的 key 总个数是树的高度。\r\n\r\n哈希表值的总长度是树的节点数。\r\n\r\n也就是说哈希表的总容量和树的总的节点数是同阶的。因此空间复杂度为 O(N)O(N)， 排序的复杂度大致为 NlogNNlogN，其中 N 为树的节点总数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102661632","body":"## idea\nhashmap record the index and find the num\ntwo pointer is not useable cause it could not record the initial index of vector nums\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashtable;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto it = hashtable.find(target - nums[i]);\n            if (it != hashtable.end()) {\n                return {it->second, i};// be careful the finded index must be the former\n            }\n            hashtable[nums[i]] = i;\n        }\n        return {};\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104021903","body":"```cpp\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        map<int,int> mp;//<值，次数>\n        priority_queue<pair<int,int>> pq;\n        for(int t:nums){\n            ++mp[t];\n        }\n        for(pair<int,int> t:mp){\n            pq.emplace(t.second,t.first);//<次数，值>\n        }\n        vector<int> resu;\n        while(k--){\n            resu.emplace_back(pq.top().second);\n            pq.pop();\n        }\n        return resu;\n    }\n};\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107857516","body":"# idea \n同余定理\n前缀和\n哈希\n```cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> s(n + 1);\n        for(int i = 1; i <= nums.size(); i ++)\n            s[i] = s[i - 1] + nums[i - 1];\n        \n        unordered_map<int, int> cnt;//表示每一个前缀和除以k余数的数量\n        cnt[0] ++;\n        int res = 0;\n        for(int i = 1; i <= n; i ++) {\n            int r = (s[i] % k + k) % k;\n            res += cnt[r];\n            cnt[r] ++;\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108575317","body":"# idea\ntwo pointer\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while (fast->next != nullptr && fast->next->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        if (fast->next == nullptr) return slow;\n        else return slow->next;\n\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109193350","body":"# idea\ntwo pointers\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int slow = 0, fast = 1;\n        int len = nums.size();\n        while (fast < len ) {\n            if (nums[slow] != nums[fast]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n            fast++;\n        }\n        return slow + 1;\n\n    }\n};\n\n# complexity\nTC O(N)\nSC O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110901693","body":"# idea\nbinary search\nbe careful with details\n```cpp\nclass Solution {\npublic:\n    \n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size();\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n        \n            if (nums[mid] > target) right = mid;\n            else if (nums[mid] < target) left = mid + 1;\n            else return mid;\n        }\n        return left;\n\n\n    }\n};\n\n# TC O(logN)  SC: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086054479","body":"思路在注释里\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        // 初始化参数\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n\n        // 1. 从后往前逐位相加\n        for(int i = n - 1;i >= 0;i--){\n            // 1.1 逐位相加\n            int sum = A[i] + K % 10;         // 每次重置sum\n            K /= 10;    \n            // 1.2 处理两位相加 进位的情况\n            if(sum >= 10){\n                K++;                        // 进位到K的末尾\n                sum -= 10;                  // 进位清掉\n            }\n            // 1.2 当前相加的结果 添加到结果集\n            res.add(sum);\n        }\n\n        // 2. K的数字长度大于数组的数字长度\n        for(;K > 0;K /= 10){                // 每次K左移一位\n            res.add(K % 10);                // 添加到结果集\n        }\n\n        // 3. 将结果集翻转即是所求答案\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n复杂度\n空间：O(N)\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663042","body":"思路：\r\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n```\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n```\r\n复杂度\r\n时间复杂度：O(N)，其中 N 是 S 的长度，我们需要遍历字符串两次。\r\n空间复杂度：O(N)，ans 数组的大小。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092885103","body":" 思路:\n设置工作坐标temp，令node1=temp.next;node2=temp.next.next;当node1和node2，不为null时，交换node1和node2 的链接顺序，并让temp跳到node1，重复执行\n\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n      ListNode dummpyHead=new ListNode(0);\n      dummpyHead.next=head;\n      ListNode temp=dummpyHead;\n      while(temp.next!=null&&temp.next.next!=null){\n        ListNode node1=temp.next;\n        ListNode node2=temp.next.next;\n          node1.next=node2.next;\n          node2.next=node1;\n          temp.next=node2;\n          temp=node1;\n      }\n      return dummpyHead.next;\n     \n    }\n}\n```\n\n复杂度\n空间 O(N)\n时间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houyanlu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086055675","body":"### 思路\n\n从最低位开始跟k的个位相加，大于10则进一位，\n\n\n### 代码\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int n = num.size();\n\n        // 从个位开始跟k的个位相加，大于10则进一位\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n\n        // 最后剩下的k， 说明k是比原数组很大很大，应该是放在加和后的高位\n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n\n        std::reverse(result.begin(), result.end());\n\n        return result;\n    }\n};\n\n**复杂度分析**\n- 时间复杂度：O(N)，一次遍历\n- 空间复杂度：O(N) 同等大小的一个vector","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646499","body":"### 思路\n\n先从后往前遍历一遍，\n再从前往后遍历一遍，查漏补缺以及比较出最近的值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int length = s.length();\n        vector<int> resultVector(length, -1);\n\n        int preIndex = -1;\n\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.at(i) == c) {\n                preIndex = i;\n                resultVector[i] = 0;\n            }\n\n            if (preIndex != -1) {\n                resultVector[i] = preIndex - i;        \n            }\n\n        }\n\n        preIndex = -1;\n        for (int i = 0; i < length; i++) {\n            if (s.at(i) == c) {\n                preIndex = i;\n            } else if (resultVector.at(i) == -1 && preIndex != -1) {\n                 resultVector[i] = i - preIndex;        \n            } else if (resultVector.at(i) != -1 && preIndex != -1) {\n                resultVector[i] = std::min(i - preIndex, resultVector[i]);\n            }\n        }\n\n        return resultVector;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895800","body":"### 思路\n\n使用数组模拟栈，用一个变量 m_topIndex 来记录当前栈顶的位置.\n\npush 操作，先判断是否到达栈顶，没有就 m_topIndex 自增1，数组的相应位置 赋值。\n\npop 操作，先判断是否为空，空返回−1， 否则m_topIndex 自减后返回自减前位置的值。\n\ninc 操作，直接对栈底的最多 k 个元素加上 val。\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        m_vector.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (m_topIndex != m_vector.size() - 1) {\n            m_topIndex++;\n            m_vector[m_topIndex] = x; \n        }\n\n        \n        \n    }\n    \n    int pop() {\n        if (m_topIndex == -1) {\n            return -1;\n        }\n\n        m_topIndex--;\n        return m_vector[m_topIndex + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = std::min(k, m_topIndex + 1);\n\n        for (int i = 0; i < limit; i++) {\n            m_vector[i] += val;\n        }\n    }\n\nprivate:\n    vector<int> m_vector;\n    int m_topIndex {-1};\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n- 时间复杂度：因为数组支持随机访问，push和pop都是O(1), inc是O(k)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087624824","body":"### 思路\n\n因为需要从里到外的展开[]对，需要增加一个辅助栈 **multiStack** 用于存储紧挨着[ 的倍数\n每当遇到左方括号时，将当前结果串**resultStr** 与 **multi** 的值进行入栈操作；\n当遇到右方括号时，进行出栈操作\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        std::stack<int>  multiStack;   // \n        std::stack<string> strignStack;\n        string resultStr;\n        int curMulti = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s[i];\n            if (c == '[') { \n                // 如果是“[”, 先存放当前记录的次数和字符串入辅助栈, 再清空两者的值\n                multiStack.push(curMulti);\n                strignStack.push(resultStr);\n                curMulti = 0;\n                resultStr.clear();\n            } else if (c == ']') {\n                // 取出次数，说明需要重复栈顶记录次数的resultStr,也就是这个数字后跟着的[]之间的字符\n                int tmp = multiStack.top();\n                multiStack.pop();\n                string tmpStr;\n                for (int i = 0; i < tmp; i++) {\n                    tmpStr.append(resultStr);\n                }\n                resultStr = (strignStack.top() + tmpStr);\n                strignStack.pop();\n            } else if (c >= '0' && c <= '9') {\n                // 数字可能几十 几百\n                curMulti = curMulti * 10 + (c - '0');\n            } else {\n                resultStr.append({c});\n            }\n        }\n\n        return resultStr;\n    }\n};\n```\n\n#### 复杂度分析\n\n+ 时间复杂度 *O*(*N*)，一次遍历字符串`s`；\n+ 空间复杂度 *O(N)*，辅助栈在极端情况下需要线性空间，例如 `2[3[aaaaaa]]`。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1090171597","body":"### 思路\n\n两个栈： \n1、push时：一个栈负责一直push存数据\n2、在pop的时候就要注意需要从上面的push栈中pop所有数据到另一个栈中，逐个出去，直至为空。 \n重复12\n\n\n### 代码\n\n\n\n```cpp\n\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        m_pushStack.push(x);\n    }\n    \n    int pop() {\n        if (m_popStack.empty()) {\n            while (!m_pushStack.empty()) {\n           m_popStack.push(m_pushStack.top());\n           m_pushStack.pop();\n        }\n        }\n\n        int temp = m_popStack.top();\n        m_popStack.pop();\n        return temp;\n        \n    }\n    \n    int peek() {\n        if (!m_popStack.empty()) {\n            return m_popStack.top();\n        }\n\n        while (!m_pushStack.empty()) {\n           m_popStack.push(m_pushStack.top());\n           m_pushStack.pop();\n        }\n\n        return m_popStack.top();\n    }\n    \n    bool empty() {\n        return m_pushStack.empty() && m_popStack.empty();\n    }\n\nprivate:\n    stack<int> m_pushStack;\n    stack<int> m_popStack;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n**复杂度分析**\n- 时间复杂度：push：O(1), pop和peek时pop栈有数据时就需要O(1),为空时最坏就需要O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1091413316","body":"### 思路\n\n当前元素，后续的元素都比他小，那就是一个块\n需要一个栈来存储每个块的最大元素\n如果比栈顶元素还要大了就直接入栈不影响前面的排列块\n如果比栈顶元素小,就需要：1、把栈顶取出来暂存 \n                       2、比较栈中的元素跟当前num的大小，如果比num小，不影响前面的块，\n                                                      如果比num大，说明需要影响到了前面的某一块，需要合并起来\n\n\n### 代码\n\n\n\n```cpp\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        std::stack<int> stack;\n\n        int head = -1;\n\n        for (const auto item : arr) {\n            if (stack.empty() || item >= stack.top()) {\n                stack.push(item);\n            } else {\n                head = stack.top();\n                stack.pop();\n\n                while (!stack.empty() && stack.top() > item) {\n                    stack.pop();\n                } \n\n                stack.push(head);        \n            }\n        }\n        \n        return stack.size();\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N), 需要遍历一边数组\n- 空间复杂度：O(N), 极端情况就是需要整个数组分块","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1093127156","body":"### 思路\r\n\r\n假设链表的长度为n，为了将链表每个节点向右移动 k 个位置，我们只需要将链表的后 k % n个节点移动到链表的最前面，然后将链表的后k % n个节点和前 n - k个节点连接到一块即可\r\n\r\n\r\n### 代码\r\n\r\n\r\n```cpp\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr || k == 0 || head->next == nullptr) {\r\n            return head;\r\n        }\r\n\r\n        int n = 0;        //链表的长度\r\n        ListNode* tail;   //尾节点\r\n        for(ListNode* p = head; p ; p = p->next){\r\n            tail = p;\r\n            n++;\r\n        }\r\n        k %= n;  \r\n        ListNode* p = head;\r\n        for(int i = 0; i < n - k - 1; i++) {\r\n            p = p->next;  //找到链表的第n-k个节点\r\n        } \r\n         \r\n        tail->next = head;\r\n        head = p->next;\r\n        p->next = nullptr;\r\n        return head;     //返回新的头节点\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093109308","body":"### 思路\n\n// 递归\n// 每一层递归: 设需要交换的两个点为 head 和 next，head连接\"后面交换完成的子链表\"，next连接head，完成交换。\n// 终止条件：  head为空指针 或 next为空指针 (当前无节点或者只有一个节点，无法进行交换)\n\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n\n        return next;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094043216","body":"### 思路\n\n1、使用快慢双指针找到中间元素\n2、中间的就是二叉树的根，左右部分的就是左右子树，再按1去递归构造左右子树\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n     TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;        \n        }\n        return sortedListToBST(head, nullptr);\n    }\n\n\n   TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if (head == tail) {\n            return nullptr;        \n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != tail && fast->next != tail) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode* root = new TreeNode(slow->val);\n        root->left     = sortedListToBST(head, slow);\n        root->right    = sortedListToBST(slow->next, tail);\n\n        return root;\n    }\n};\n\n```\n\n**复杂度分析**\n递归树的深度为 logn 所以时间复杂度和空间复杂度都是logn * 递归函数内部所需要的时间和空间\n\n- 时间复杂度：O(logn)\n- 空间复杂度：O(logn)   \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094293661","body":"### 思路\n\n使用双指针法，分别指向两个链表的起点，以相同的速度向后移动，若A = B则为相交的点\n若没有交点，则遍历完两个链表后共同指向nullptr, 不影响返回\n\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n\n        if (headA == headB) {\n            return headA;\n        }\n        \n        ListNode* tmpA = headA;\n        ListNode* tmpB = headB;\n\n        while (tmpA != tmpB) {\n            if (tmpA == nullptr) {\n                tmpA = headB;\n            } else {\n                tmpA = tmpA->next;\n            }\n\n             if (tmpB == nullptr) {\n                tmpB = headA;\n            } else {\n                tmpB = tmpB->next;\n            }\n        }\n\n        return tmpA;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)   \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094902319","body":"### 思路\n\n快慢指针法：fast每次走两步，slow每次走一步\n第一次相遇时：fast回到head，和slow一样每次走一步，再次相遇的时候就是环的入口\n![图片](https://tva1.sinaimg.cn/large/008i3skNly1gqoqk2rhuij30gp08u3z0.jpg)\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr) {\n            return nullptr;\n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n\n                return fast;\n            } \n        }\n\n        return nullptr;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096922498","body":"### 思路\n用标准库的unordered_map和list实现，最关键的是要知道list的splice方法，否则在找寻节点上会时间不满足\n具体思路见代码注释\n\n\n### 代码\n\n\n```cpp\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        m_capacity = capacity;       \n    }\n    \n    int get(int key) {\n        // 不存在返回-1\n        if (m_map.count(key) == 0) {\n            return -1;\n        }\n\n        m_list.splice(m_list.begin(), m_list, m_map[key]);\n        return m_map[key]->second;\n    }\n    \n    void put(int key, int value) {\n        // 先判断有就返回, 没有就需要先判断是否需要逐出，需要就先逐出再插入，逐出链表的末尾元素，再插入\n        // 不需要就直接插入,再将key更新到链表的头\n        if (get(key) != -1) {  //key存在,调用get时已将缓存移到头部，再更新map\n            m_map[key]->second = value;\n        } else {   //key不存在\n            if(m_list.size() == m_capacity) {\n                int delKey = m_list.back().first;\n                m_list.pop_back();\n                m_map.erase(delKey);\n            }\n\n            m_list.emplace_front(key, value); //如果key不存在，在头部加入新的缓存   \n            m_map[key] = m_list.begin();\n        }\n    }\n\n    private:\n        int m_capacity { 0 };\n        std::list<pair<int, int>> m_list;  //数据用双向链接存储\n        std::unordered_map<int, list<pair<int, int>>::iterator> m_map;  //value是list的迭代器\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)   \n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098021082","body":"### 思路\n\n知道了左子树和右子树的最大深度 ll 和 rr，那么该二叉树的最大深度即为max(l,r) + 1\n在递归用同样的方式算出左子树和右子树的高度\n\n### 代码\n\n\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n         \n        int left  = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        \n        return max(left, right) + 1;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1100683850","body":"### 思路\n用递归去解决\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        }\n\n        if (p == nullptr || q == nullptr) {\n            return false;\n        }\n\n        if (p->val != q->val) {\n            return false;\n        }\n\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N为节点数\n- 空间复杂度：O(h)，其中 h 为树的高度。  \n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100242159","body":"### 思路\ndfs遍历整棵树，当遍历到叶节点时，将路径表示的数累加到答案中\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int res = 0;\n    int sumNumbers(TreeNode* root) {\n        dfs(root, 0);\n        return res;\n    }\n\n    void dfs(TreeNode* root, int number) {\n        number = number * 10 + root->val;\n\n        if (!root->left && !root->right) { //遍历到叶节点，将number加入res中\n            res += number;  \n        }  \n        if (root->left) {\n            dfs(root->left, number); //递归左子树\n        }  \n        if (root->right) {\n            dfs(root->right, number); //递归右子树\n        } \t\t\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N为节点数，对每个节点访问一次。\n- 空间复杂度：O(N)  最坏情况下，二叉树退化为链表，递归调用的栈空间为N个节点所占用的栈空间  \n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100682136","body":"### 思路\nBFS遍历整棵树，不同的是在遍历每一层的时候，==要把最左边的节点记录下来==，遍历完即是左边的节点\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        std::queue<TreeNode *> q;\n        TreeNode* result = nullptr;\n        q.push(root);\n\n        while (!q.empty()) {\n            int size = q.size(); //获取当前这一层的结点个数\n            for (int i = 0; i < size; i++) {//出队\n                TreeNode* tmp = q.front();\n                q.pop();\n\n                if (i == 0) { //每一层最左边的结点值\n                    result = tmp;        \n                }  \n                if (tmp->left) {\n                    q.push(tmp->left);\n                } \n                if (tmp->right) {\n                    q.push(tmp->right);\n                }\n            }\n        }\n\n        return result->val;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N为节点数，对每个节点访问一次。\n- 空间复杂度：O(width) 最坏情况下，二叉树为满二叉树，最后一层的时候队列需要存储所有叶子节点  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100865463","body":"### 思路\nDFS，序列化思路：前序遍历整棵树，遇到左右孩子为空标记为NULL, 每个节点以\",\"分隔，追加到字符串中，\n     反序列化思路：将字符串拆分为链表，递归构建左右子树即可\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string ret;\n        dfs(root, ret);\n\n        return ret;\n    }\n\n    void dfs(TreeNode* root, string &str) {\n        if (root == nullptr) {\n            str.append(\"NULL,\");\n        } else {\n            str.append(to_string(root->val));\n            str.append(\",\");\n            dfs(root->left, str);\n            dfs(root->right, str);\n        }\n    }\n\n\n    TreeNode* decode(list<string> &nodeList) {\n        if (nodeList.front() == \"NULL\") {\n            nodeList.erase(nodeList.begin());\n            return nullptr;\n        }\n\n        TreeNode *node = new TreeNode(stoi(nodeList.front()));\n        nodeList.erase(nodeList.begin());\n        node->left  = decode(nodeList);\n        node->right = decode(nodeList);\n\n        return node;  \n    }\n\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        for (auto& ch : data) {\n            if (ch == ',') {\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(ch);\n            }\n        }\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n\n        return decode(dataArray);\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N为节点数，对每个节点访问一次。\n- 空间复杂度：O(N)  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101484728","body":"### 思路\nBFS\n需要使用一个map来存储不同y值的节点\n我们每次遍历的节点的y值是相同的，那么我们可以将此次遍历的节点都存储到一个临时的map中，当遍历结束后，我们可以遍历这个临时的map，根据不同的y值去从到大排序。\n最后将排好序的节点再加入到我们的第一个map即可。\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    struct Node {\n        int x { 0 };\n        int y { 0 };\n        TreeNode *root { nullptr };\n        Node() {}\n        Node(int a, int b, TreeNode *c) : x(a), y(b), root(c) {}\n    };\n\n    vector <vector <int>> ans;\n    map <int, vector<int>> ss;\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        if (root == nullptr) {\n            return ans;         \n        }\n        queue <Node> q;\n        q.push({0, 0, root});\n        while (!q.empty()) {\n            int n = q.size();\n            map <int, vector<int>> tmp; // 临时的 map\n            for(int i = 0; i < n; i++) {\n                auto k = q.front();\n                q.pop();\n                tmp[k.y].push_back(k.root->val);\n                if(k.root->left) q.push({k.x + 1, k.y - 1, k.root->left});\n                if(k.root->right) q.push({k.x + 1, k.y + 1, k.root->right});\n            }\n\n            for (auto &[x, y] : tmp) { // 遍历\n                sort(y.begin(), y.end());  // 排序\n                for (auto &c : y) {\n                    ss[x].push_back(c);  // 将节点加入第一个 map(ss) 中\n                }\n            }\n            tmp.clear();\n        }\n        for(auto &[x, y] : ss) {\n            ans.push_back(y);\n        } \n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn) N为节点数\n- 空间复杂度：O(N)  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102610362","body":"### 思路\n\n使用哈希表存储，key是值，value是数组下标，遍历每一个元素的时候从哈希表中找有没有value和遍历的当前元素加和为target， 有就是这两个下标， 没有就是存入map当前遍历元素的值和下标\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (map.find(target - nums[i]) != map.end()) {\n                return {map[target - nums[i]], i};\n            }\n\n            map[nums[i]] = i;\n        }\n\n        return {};       \n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)， 寻找每一个元素hash表的操作都是O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103884605","body":"### 思路\n先用哈希法统计出频率\n再构造一个k个节点的小顶堆\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> map;\n\n        for (auto item : nums) {\n            map[item]++;  \n        }\n\n        // 小顶堆, pair的比较，先比较第一个元素，第一个相等比较第二个\n        priority_queue <pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > q;\n\n        // 堆中元素为 [频次，数值] 元组，并根据频次维护小顶堆特性\n        for (const auto &item : map) {\n             if (q.size() != k) {\n                q.push(make_pair(item.second, item.first));\n            } else {\n                if (item.second > q.top().first) {\n                    q.pop();\n                    q.push(make_pair(item.second, item.first));\n                }\n            }\n        }\n        \n        vector<int> ans;\n        while(q.size()) {\n            ans.push_back(q.top().second);\n            q.pop();\n        }\n\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N∗logK)  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105267617","body":"### 思路\n三遍for循环枚举所有的值超过了时间限制\n问题就需要精简时间的计算, 问题可以转化为：距离A点所有的距离为x的点都可以两两组合为三元组\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        if (points.empty()) {\n            return 0;\n        }\n\n        unordered_map<int, int> map;\n        int ans = 0;\n\n        for (int i = 0; i < points.size(); i++) {\n            map.clear();   //这一行很重要，每次循环算一个点的\n            for (int j = 0; j < points.size(); j++) {\n                int distance = getInstance(points[i], points[j]);\n                map[distance]++;\n            }\n\n            for (const auto&[key, val] : map) {\n                ans += val * (val - 1);\n            }\n        }\n        return ans;\n}\n\nint getInstance(const vector<int>& point1, const vector<int>& point2) {   \n        int x1 = point1[0];\n        int y1 = point1[1];\n\n        int x2 = point2[0];\n        int y2 = point2[1];\n\n        return (x2 - x1) * (x2 - x1) + (y1 - y2) * (y1 - y2);\n}\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N^2)  \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106694254","body":"### 思路\n这道题在讲滑动窗口的时候就有提到，所以一开始就是想到滑动窗口来做，\n一直向右扩大窗口，遇到有重复的元素意味着需要改变窗口的大小，将窗口的最左边移动到重复元素位置的下一个即可。   \n滑动窗口中元素的位置可以用hash表来记录\n最重要的是：每次改变窗口大小的时候一定要比较保留最大的窗口大小，以为可能移动完最后并不是最长的\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char,int> map;\n        int maxLen = 0, l = 0, r = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char curChar = s[i];\n            if (map.count(curChar) > 0) { //说明字符存在\n                int lastPos = map[curChar];  //上次出现的位置\n                if (lastPos >= l && lastPos <= r) {\n                    l = lastPos + 1;\n                }\n            }\n\n            maxLen = std::max(maxLen, r - l + 1);\n            map[curChar] = r;\n            r++;\n        }\n\n        return maxLen;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N为字符串的长度\n- 空间复杂度：O(maxLength)  map中存储最长串的空间\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107524717","body":"### 思路\n其实还是暴力法去判断每一个连续子串是否符合要求，\n在比较的过程中使用了两个hash表来比较是否子串中word的个数是相等的\n\n\n### 代码\n\n\n```cpp\n\n\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        int length   = s.length();\n        int wordSize = words[0].length();\n        vector<int> ansVec;\n\n        unordered_map<string, int> targetMap;\n        for (const auto& word : words) {\n            ++targetMap[word];\n        }\n\n        for (int i = 0; i < length - wordSize * words.size() + 1; i++) {\n            string subString = s.substr(i, wordSize * words.size());\n            unordered_map<string, int> tmpMap;\n            int j = 0;\n            for ( ; j < subString.length(); j = j + wordSize) {\n                string tmpStr = subString.substr(j, wordSize);\n                if (targetMap.count(tmpStr) < 0) {\n                    break;\n                }\n\n                ++tmpMap[tmpStr];\n\n                if (tmpMap[tmpStr] > targetMap[tmpStr]) {\n                    break;\n                }\n            } \n\n            if (j == subString.length()) {\n                ansVec.push_back(i);\n            }\n        }\n\n        return ansVec;\n    }\n};\n\n```\n\n**复杂度分析**\n令 length 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度\n- 时间复杂度：O(length * m * k), 就是两重for循环的时间复杂度\n- 空间复杂度：O(m)   哈希表的大小就是words数组元素的个数，多少个key也就是\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108544418","body":"### 思路\n快慢指针，每次快指针走两步，慢指针走2步， 慢指针走1步， 快指针走到头慢指针就是链表的中间\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if (head->next == nullptr) {\n            return head;\n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        return slow;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109713015","body":"### 思路\n\n用双指针遍历数组，左指针的位置是下一个要写入元素的位置， 右指针则在探测寻找下一个要写入的元素， 遍历一遍即可\n\n\n### 代码\n\n\n\n```cpp\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) {\n            return 0;\n        }\n\n        int left = 1, rihgt = 1;\n        while (rihgt < nums.size()) {\n            if (nums[rihgt] != nums[rihgt - 1]) {\n                nums[left] = nums[rihgt];\n                ++left;\n            }\n\n            ++rihgt;\n        }\n\n        return left;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110979397","body":"### 思路\n\n二分发，需要注意mid取值，以及取平均时的溢出处理\n\n\n### 代码\n\n\n\n```cpp\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        if (nums.empty()) {\n            return 0;    \n        }\n\n        int left = 0, right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = ((right - left) / 2) + left;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (target > nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112360396","body":"### 思路\n利用一个 **双端队列**，在队列中存储元素在数组中的位置， 并且维持队列的严格递减,，也就说维持队首元素是 **最大的 **，\n当遍历到一个新元素时, 如果队列里有比当前元素小的，就将其移除队列，以保证队列的递减。当队列元素位置之差大于 k，就将队首元素移除。\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        if (nums.empty() || nums.size() < k || k == 0) {\n            return {};\n        }\n\n        vector<int> ans;\n        deque<int> q;\n        for (int i = 0; i < nums.size(); i++) {\n            // 在尾部添加元素，并且使头部元素最大\n            while (!q.empty() && nums[q.back()] < nums[i]) {\n                q.pop_back();\n            }\n\n            q.push_back(i);\n            // 如果超出了窗口范围\n            if (q.front() == i - k) {\n                q.pop_front();\n            }\n\n            if (i >= k - 1) {\n                ans.push_back(nums[q.front()]);\n            }\n        }\n\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113396246","body":"### 思路\n问题就转化为求图中入度为 n - 1 并且出度为 0的点。\n遍历trust数组，构造出度数组和入度数组，最后遍历寻找两个数组中，符合要求的那个下标\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1); //从1编号所以大小要加1\n        vector<int> outDegrees(n + 1);\n\n        for (const auto&item : trust) {\n            ++inDegrees[item[1]];\n            ++outDegrees[item[0]];\n        }\n\n        for (int i = 1; i <= n; i++) {\n            if (inDegrees[i] == (n-1) && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n+m), 需要遍历trust数组和第二遍寻找法官的遍历为n\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086056841","body":"### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663153","body":"### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\t\tint N = s.length();\n\t\tint[] ans = new int[N];\n\t\tint pre = -N;\n\t\tfor(int i = 0; i<N;i++) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = i-pre;\n\t\t}\n\t\tpre = 2*N;\n\t\tfor(int i = N-1; i>=0;i--) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = Math.min(ans[i],pre-i);\n\t\t}\n\t\treturn ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891512","body":"```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094066181","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> valRecord = new ArrayList<>();\n        ListNode currentNode = head;\n        while (currentNode!=null) {\n            valRecord.add(currentNode.val);\n            currentNode = currentNode.next;\n        }\n        int[] nums = new int[valRecord.size()];\n        for(int i = 0; i < valRecord.size(); i++) {\n            nums[i] = valRecord.get(i);\n        }\n        return sortedListToBSTHelper(nums, 0, nums.length-1);\n    }\n\n    public TreeNode sortedListToBSTHelper(int[] nums, int left, int right) {\n        if(left == right)\n            return new TreeNode(nums[left]);\n        if(left > right)\n            return null;\n        int mid = left + (right-left)/2;\n        int val = nums[mid];\n        TreeNode leftNode = sortedListToBSTHelper(nums,left, mid-1);\n        TreeNode rightNode = sortedListToBSTHelper(nums, mid+1, right);\n        return new TreeNode(val, leftNode, rightNode);\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095228053","body":"```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public static ListNode inCycleNode(ListNode head) {\n        ListNode fast = head.next;\n        ListNode slow = head;\n        while(slow!=null && fast!=null) {\n            slow = slow.next;\n            fast = fast.next;\n            if(slow == fast) return slow;\n            if(fast!=null) fast = fast.next;\n        }\n        return null;\n    }\n\n    public static ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) return null;\n        if(head.next == head) return head;\n        ListNode inLoopNode = inCycleNode(head);\n        if(inLoopNode == null) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        int count = 1;\n        for(ListNode point=inLoopNode; point.next!= inLoopNode; point = point.next) {\n            count++;\n        }\n        for(int i = 0; i < count;i++) {\n            fast = fast.next;\n        }\n        while(slow!=fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098189050","body":"```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111007480","body":"```java\n        public int searchInsert(int[] nums, int target) {\n            if(target > nums[nums.length-1]) return nums.length;\n            if(target < nums[0]) return 0;\n            int l = 0, r = nums.length - 1;\n            int mid = (l + r) / 2;\n            while (nums[mid]!= target) {\n                if(r==l+1) {\n                    mid = mid+1;\n                    break;\n                };\n                if (nums[mid] > target) {\n                    r = mid;\n                } else {\n                    l = mid;\n                }\n                mid = (l + r) / 2;\n            }\n\n            return mid;\n        }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-will":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086057669","body":"## Idea:\nGo through the num array, accumulate the sum of each digits. Then sum with k and convert into a list.\n\n## Code:\n'''\n\n\tclass Solution:\n\t\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\t\tsumArr = 0\n\t\t\tfor i, e in enumerate(num[::-1]):\n\t\t\t\tsumArr += e if i == 0 else e * (10 ** i)\n\n\t\treturn map(int, list(str(sumArr + k)))\n'''\n\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1088882603","body":"## Idea\r\n方法1. 找到所有c的位置，再遍历一次找当前位置和c的最小值\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_idx = []\r\n        shortestDistanceToC = []\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                c_idx.append(i)\r\n        \r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                shortestDistanceToC.append(0)\r\n            else:\r\n                # taking shortest dist(so abs()) from i to all c's idxs\r\n                min_dist = min([abs(a-b) for a, b in zip(c_idx, [i] * len(c_idx))])\r\n                shortestDistanceToC.append(min_dist)\r\n        \r\n        return shortestDistanceToC\r\n```\r\n\r\n## Complexity\r\nTime: O(n) <br>\r\nSpace: O(m), m = # of c in s","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086931775","body":"## Code\nPython:\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = 0\n        self.maxSize = maxSize\n        self.incr = []\n        \n\n    def push(self, x: int) -> None:\n        if self.size >= self.maxSize: return\n        self.stack.append(x)\n        self.incr.append(0)\n        self.size += 1\n        \n    def pop(self) -> int:\n        if self.size == 0: return -1\n        if self.size > 1:\n            self.incr[-2] += self.incr[-1]\n        self.size -= 1\n        return self.stack.pop() + self.incr.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0: self.incr[min(k, self.size) - 1] += val\n\nTime: O(1) for all operation\nSpace: O(size)\n\nC++:\nclass CustomStack {\nprivate:\n    int size;\n    vector<int> stack;\n    vector<int> incr;\n\n    // 思路二 另一种写法：incr加一个dummy位，解决溢出\npublic:\n    CustomStack(int maxSize) {\n        this->size = 0;\n        this->stack.resize(maxSize);\n        this->incr.resize(maxSize + 1);\n    }\n    \n    void push(int x) {\n        if (size == stack.size()) return;\n        stack[size++] = x;\n    }\n    \n    int pop() {\n        if (size == 0) return -1;\n        int ret = stack[size - 1];\n        if (incr[size] != 0) {\n            ret += incr[size];\n            // 因为size == 0 开始handle\n            // size == 1, idx = 0, preidx=-1 溢出被dummy(第0位)handle了\n            incr[size - 1] += incr[size]; \n            incr[size] = 0;\n        }\n        size--;\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        incr[min(k, size)] += val;\n    }\n};\n\nTime: O(1) for all operations\nSpace: O(maxSize)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086936836","body":"## Idea\r\nUsing stack LIFO and nitrate through the string and process the char \r\n\r\n\r\n## Code\r\n\r\n```py\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, ret, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append((multi, ret))\r\n                ret, multi = \"\", 0\r\n            elif '0' <= c <= '9':\r\n                # 处理多位数字：一个空只会有一个数字，利用数字特性 n * 10 + c\r\n                multi = multi * 10 + int(c)\r\n            elif c == ']':\r\n                cur_multi, last_ret = stack.pop()\r\n                ret = last_ret + cur_multi * ret\r\n            else:\r\n                ret += c\r\n        return ret\r\n\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088049019","body":"## Code\n```java\nclass MyQueue {\n    private Stack<Integer> s1 = new Stack<>();\n    private Stack<Integer> s2 = new Stack<>();\n    private int front;\n        \n    public MyQueue() {\n        \n    }\n    \n    // 每次S1空都更新front\n    public void push(int x) {\n        if (s1.empty())\n            front = x;\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if (s2.empty()) {\n            // s1搬空 下次push更新front\n            while(!s1.empty())\n                s2.push(s1.pop());\n        }\n        return s2.pop();\n    }\n    \n    // peek是两部分逻辑 S2相当于队列如不为空直接返回peek 否则S1最底就是peek值\n    public int peek() {\n        if (!s2.empty()) \n            return s2.peek();\n        return front;\n    }\n    \n    public boolean empty() {\n        return s1.empty() && s2.empty();\n    }\n}\n```\n\n## Complexity\nTime: amortized O(1) pop <br>\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089415383","body":"## Idea\n贪心法，代码不难，难在想到这个思路。重点是sorted arr和arr中元素个数相等即一个区块，因为依次查找所以一定是最小区块，即贪心法，所以一定是最多的个数\n\n## Code\n```py\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = num_nonzero = 0\n        \n        for x, y in zip(arr, sorted(arr)):\n            count[x] += 1\n            if count[x] == 0: num_nonzero -= 1\n            if count[x] == 1: num_nonzero += 1\n                \n            count[y] -= 1\n            if count[y] == -1: num_nonzero += 1\n            if count[y] == 0: num_nonzero -= 1\n            \n            if num_nonzero == 0: ans += 1\n            \n        return ans\n```\n\n## Complexity\nO(nlongn) <br>\nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090839748","body":"## Idea\n找到新链表的首和尾，尾比首少一步，steps = list_len - k % list_len - 1。特殊情况，如果k是0或list_len的整数倍，则无需反转，返回head即可\n\n## Code\n凭感觉写的比较乱，应该有更好的写法\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        \n        new_head = head\n        list_len = 0\n        tail = None\n        while new_head:\n            list_len += 1\n            if new_head and not new_head.next:\n                tail = new_head\n            new_head = new_head.next\n        \n        new_tail = head\n        steps = list_len - k % list_len - 1\n        for _ in range(steps):\n            new_tail = new_tail.next\n        \n        if new_tail.next:\n            new_head = new_tail.next\n            new_tail.next = None\n            tail.next = head\n        else:\n            new_head = head\n        \n        return new_head\n```\n## Complexity\nO(n) <br>\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092190427","body":"## Idea\n滑窗有三位，每次三个operations，之后向右滑动，重复操作即可\n\n## Code\n之前的写法不够简洁，借鉴了别人的码\n```py\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # dummy让code简介\n        dummy = ListNode()\n        dummy.next = head\n        cur = head\n        prev = dummy\n        # 至少两个node才swap\n        while cur and cur.next:\n            next = cur.next\n            # 滑窗内三次opeartions\n            cur.next = next.next\n            next.next = cur\n            prev.next = next\n            # 设置新滑窗\n            prev = cur\n            cur = cur.next\n        \n        return dummy.next\n```\n\n# Complexity\nO(n) <br>\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093593697","body":"## code\n```java\npublic class Solution {\npublic TreeNode sortedListToBST(ListNode head) {\n    if(head==null) return null;\n    return toBST(head,null);\n}\npublic TreeNode toBST(ListNode head, ListNode tail){\n    ListNode slow = head;\n    ListNode fast = head;\n    if(head==tail) return null;\n    \n    while(fast!=tail&&fast.next!=tail){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    TreeNode thead = new TreeNode(slow.val);\n    thead.left = toBST(head,slow);\n    thead.right = toBST(slow.next,tail);\n    return thead;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094109607","body":"## Idea\nset or two pointer\n\n## Code\n```py\n# Hashset\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        nodesA = set()\n        while headA:\n            nodesA.add(headA)\n            headA = headA.next\n        \n        while headB:\n            if headB in nodesA:\n                return headB\n            headB = headB.next\n            \n        return None\n\n# two pointer\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB: return None\n        \n        pA, pB = headA, headB\n        while pA != pB:\n            pA = pA.next if pA else headB\n            pB = pB.next if pB else headA\n        \n        return pA\n```\n\n## Complexity\nO(m + n) O(m) <br>\nO(m + n) O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094464285","body":"## Code\n```py\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n        is_circle = False\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                is_circle = True\n                break\n        \n        if not is_circle: return False\n        \n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n            \n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095533738","body":"## Code\n```java\nclass LRUCache {\n    int cap;\n     LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    \n    private void makeRecently(int key) {\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) {\n            return -1;\n        }\n        makeRecently(key);\n        return cache.get(key);\n        \n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            // modify the old val\n            cache.put(key, value);\n            // promote to the recently (delete and add)\n            makeRecently(key);\n            return;\n        } else {\n            if (cache.size() >= cap) {\n                // delete the least used\n                int leastKey = cache.keySet().iterator().next();\n                cache.remove(leastKey);\n            }\n            cache.put(key, value);\n        }\n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097429669","body":"## Code\n```py\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098355563","body":"## Code\r\n```py\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        # 两个node都不存在\r\n        if not p and not q: return True\r\n        \r\n        # 只存在一个，或值不一样\r\n        if (not p) ^ (not q) or p.val != q.val:\r\n            return False\r\n        \r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099506127","body":"## Idea\nRecursion\n\n## Code\n```py\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def sumTreeNode(root, accum):\n            accum += str(root.val)\n            if not root.left and not root.right:\n                return int(accum) \n            \n            total = 0\n            if root.left:\n                total += sumTreeNode(root.left, accum)\n                \n            if root.right:\n                total += sumTreeNode(root.right, accum)\n                \n            return total\n             \n        \n        return sumTreeNode(root, \"\")\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100446067","body":"## Code\r\n```py\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        maxDepth = 0\r\n        val = None\r\n        def findBLV(root, depth):\r\n            nonlocal maxDepth, val\r\n            if not root: return\r\n            if root and maxDepth < depth:\r\n                val = root.val\r\n                maxDepth = depth\r\n            \r\n            depth += 1\r\n            findBLV(root.left, depth)\r\n            findBLV(root.right, depth)\r\n            \r\n        findBLV(root, 1)\r\n        return val\r\n```\r\n\r\n## Complexity\r\nO(n) <br>\r\nO(log n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103063111","body":"## Code\n看到更好的解法了，但还是把我本来的做法贴出来吧\n```py\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        numFreqMap = collections.defaultdict(int)\n        for num in nums:\n            numFreqMap[num] += 1\n        \n        numFreqMap = sorted(numFreqMap.items(), key=lambda x: -x[1])\n        return [pair[0] for pair in numFreqMap][:k]\n```\n## Complexity\nO(n log n) not optimal <br> O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104721790","body":"## Idea\n关键想到permutation: nP2 = n * n - 1 和 需要边的长度可以用哈希表储存\n\n## Code\n```py\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        booms = 0\n        map_ = dict()\n        \n        def get_dist(a, b):\n            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n        \n        for i in points:\n            for j in points:\n                d = get_dist(i, j)\n                # nP2 = n!/(n-2)! = n * (n - 1) found n = 1, nP2 = 0\n                map_[d] = map_.get(d, 0) + 1     \n            \n            for val in map_.values():\n                booms += val * (val - 1)\n                \n            map_.clear()\n            \n        return booms\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106518510","body":"## Code\n```py\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s: return 0\n        charFreq = defaultdict(int)\n        longestStrLen, left, right = 0, 0, 0\n        \n        while right < len(s):\n            ch = s[right]\n            charFreq[ch] += 1\n            \n            while charFreq[ch] > 1:\n                chRemoved = s[left]\n                charFreq[chRemoved] -= 1\n                left += 1\n                \n            longestStrLen = max(longestStrLen, right - left + 1)\n            right += 1\n        \n        return longestStrLen\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1106774753","body":"## Code\n```py\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wds_count = len(words)\n        wd_len = len(words[0])\n        lenght = wds_count * wd_len\n        wordCnt = defaultdict(int)\n        \n        for word in words:\n            wordCnt[word] += 1\n        \n        def is_concatenation(i):\n            # corner case: 可以重复的 \n            count = wds_count\n            wordFreq = dict(wordCnt)\n            for x in range(wds_count):\n                start = i + x * wd_len \n                wd = s[start: start + wd_len]\n                if wd in wordFreq:\n                    wordFreq[wd] -= 1\n                    if wordFreq[wd] >= 0:\n                        count -= 1\n            return count == 0\n        \n        ptr = 0\n        res = []\n        while ptr <= len(s) - lenght:\n            if is_concatenation(ptr):\n                res.append(ptr)\n            ptr += 1\n            \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109168885","body":"## Code\n\n```py\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n, ptr = len(nums), 0\n        for i in range(n):\n            if nums[ptr] != nums[i]:\n                ptr += 1\n                nums[ptr] = nums[i]\n        return ptr + 1\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112850830","body":"## Code\n```py\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if not trust and n == 1: return 1\n        truster = []\n        trusted_count = defaultdict(int)\n        for p1, p2 in trust:\n            truster.append(p1)\n            trusted_count[p2] += 1\n        for trustee, count in trusted_count.items():\n            if count == n-1 and trustee not in truster:\n                return trustee\n        else:\n            return -1\n```\ntimeO(n) <br> spaceO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hohojii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086058735","body":"##思路\n逐位相加\n##代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665804","body":"##左右遍历\n##code\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n, 1e6);\n        int last = -1e6;\n        for(int i = 0; i < n; i++) {\n            if(s[i] == c) {\n                ans[i] = 0;\n                last = i;\n            }\n            else ans[i] = min(ans[i], i - last);\n        }\n        last = 1e6;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s[i] == c) last = i;\n            else ans[i] = min(ans[i], last - i);\n        }\n        return ans;\n    }\n};\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088860479","body":"‘’‘’class MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090409162","body":"##code''''\npublic class Solution {\n\n     public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091886164","body":"##code‘’‘’\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)O(n)，最坏情况下，我们需要遍历该链表两次。\n空间复杂度：O(1)O(1)，我们只需要常数的空间存储若干变量。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxjo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086060234","body":"## 思路\nnum与k从右向左逐位相加，遇到进位则加到下一位上\n\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    for(let i = num.length - 1; i >= 0; i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum >= 10){\n            sum -= 10;\n            k += 1;\n        }\n        res.push(sum);\n    }\n    //解决k位数大于数组长度\n    while(k > 0){\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度： O(max(num.length, lgk))  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652531","body":"## 思路\n\n使用不定长滑动窗口，边界字符为c，left和right维护窗口`\n\n## 代码\n```\nvar shortestToChar = function(s, c) {\n    let res = [];\n    let left = -Infinity;\n    let right = s.indexOf(c);\n    for(let i = 0; i < s.length; i++){\n        res.push(Math.min(Math.abs(i - left), Math.abs(i -right)));\n        if(i === right){\n            left = right;\n            right = s.indexOf(c, right + 1);\n        }\n    }\n    return res;\n};\n```\n\n## 复杂度分析\n\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886549","body":"## 思路\n使用数组，并用原生的push、pop方式实现\n\n## 代码\n\n```\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize){\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length > 0 ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < this.stack.length; i++){\n        if(i < k){\n            this.stack[i] += val;\n        }\n    }\n};\n```\n## 复杂度分析\n时间复杂度： push(): O(1); pop():O(1); increment:O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087716526","body":"## 思路\n使用非\"]\"的字符入栈，遇到\"]\"时，字符出栈，在遇到\"[\"之前出栈的字符拼接得repeatString，随后数字字符出栈拼接转化成对应数字就是repeatNum，根据上述两个变量，得到重复的完整字符串，随后压入栈重复上述操作。\n\n## 代码\n```\n var decodeString = function(s) {\n    let stack = [];\n    for(let c of s){\n        if(c !== ']'){\n            stack.push(c);\n            continue;\n        }\n        let repeatString = '';\n        while(stack.length > 0 && stack[stack.length - 1] != '['){\n            repeatString = stack.pop() + repeatString;\n        }\n    \n        /* 弹出[ */\n        stack.pop();\n    \n        let repeatNum = '';\n        while(stack.length > 0 && !isNaN(stack[stack.length - 1])){\n            repeatNum = stack.pop() + repeatNum;\n        }\n        stack.push(repeatString.repeat(Number(repeatNum)));\n    }\n    return stack.join('');\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088852525","body":"## 思路\nstack1作为输入栈，stack2作为输出栈，只有当stack2为空时，才将stack1中的数据移到stack2中\n\n## 代码\n```\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length > 0){\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length > 0){\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack2.length == 0 && this.stack1.length == 0 ? true : false;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090406510","body":"## 思路\n栈里表示的每一个块的局部最大值，且保持后入栈的局部最大值要大于先入栈的局部最大值（即该栈出栈的元素是单调减的，所以是递减栈）\n\n## 代码\n```\nvar maxChunksToSorted = function(arr) {\n    let res = [];\n    for(let ele of arr){\n        if(res.length > 0 && res[res.length - 1] > ele){\n            //解决2 2 1这种情况，当后面出现比栈中最大值要小的数时，只能分成1块\n            let cur = res[res.length - 1];\n            while(res.length > 0 && res[res.length - 1] > ele){\n                res.pop();\n            }\n            res.push(cur);\n        }\n        else{\n            res.push(ele);\n        }\n    }\n    return res.length;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091890623","body":"## 思路\n总的思路是将倒数step个节点移至链表头部  \n使用快慢指针：  \n1、获取链表长度length  \n2、取余数step，利用余数自减，快指针移至第step + 1个节点（因为初始fast = head）  \n3、快慢指针同时走，快指针走到尾时，慢指针走到倒数第step+1个节点（因为初始slow = head）\n\n## 代码\n```\n var rotateRight = function(head, k) {\n    if(head === null || head.next === null){\n        return head;\n    }\n    //获取链表长度\n    let length = 0;\n    let temp = head;\n    while(temp !== null){\n        length += 1;\n        temp = temp.next;\n    }\n\n    let step = k % length;\n    let fast = head;\n    let slow = head;\n    while(step > 0){\n        fast = fast.next;\n        step -= 1;\n    }\n\n    while(fast.next !== null){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    fast.next = head;\n    head = slow.next;\n    slow.next = null;\n    return head;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092926330","body":"## 思路\n1、使用两个指针pre和cur交换节点，pre指向交换节点的前一个节点，cur指向交换节点的第一个节点  \n2、注意使用虚拟节点virtual，此时head是否为空，均返回virtual.next,可以减少边界判断\n## 代码\n```\n var swapPairs1 = function(head) {\n    let virtual = new ListNode(null, head);\n    let pre = virtual;\n    let cur = head;\n    while(cur !== null && cur.next !== null){\n        let curNext = cur.next;\n        pre.next = curNext;\n        cur.next = curNext.next;\n        curNext.next = cur;\n        \n        pre = cur;\n        cur = cur.next;\n    }\n    return virtual.next;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072395","body":"## 思路\n1、二分查找使用快慢指针找到中间节点  \n2、使用递归\n## 代码\n```\n var sortedListToBST1 = function(head) {\n    if(head === null) return null;\n    if(head.next === null) return new TreeNode(head.val);\n    let fast = head.next.next;\n    let slow = head;\n    while(fast !== null && fast.next !== null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let root = new TreeNode(slow.next.val);\n    let rightHead = slow.next.next;\n    slow.next = null;\n    root.left = sortedListToBST1(head);\n    root.right = sortedListToBST1(rightHead);\n    return root;\n};\n```\n## 复杂度分析\n时间复杂度：O(nlogn)  \n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094255320","body":"## 思路\n使用双指针\n## 代码\n```\nvar getIntersectionNode = function(headA, headB) {\n    if(headA === null) return null;\n    if(headB === null)  return null;\n    let node1 = headA;\n    let node2 = headB;\n    while(node1 !== node2){\n        node1 = node1 !== null ? node1.next : headB;\n        node2 = node2 !== null ? node2.next : headA;\n    }\n    return node1;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095139932","body":"## 思路\n参考官方题解，使用了快慢指针。  \n1、fast=head, slow=head  \n2、fast一次走两步，slow一次走一步，当相遇时，说明有环  \n3、若有环，p=head，p和slow均一次走一步，p和slow相遇处就是入环点  \n## 代码\n```\nvar detectCycle = function(head) {\n    if(head === null) return null;\n    let fast = head;\n    let slow = head;\n    while(fast !== null && fast.next !== null){\n        fast = fast.next.next;\n        slow = slow.next;\n        if(fast === slow){\n            //进入这个循环，说明有环\n            let p = head;\n            while(p != slow){\n                p = p.next;\n                slow = slow.next;\n            }\n            return p;\n        }\n    }\n    return null;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096909080","body":"## 思路\r\n使用哈希+双向链表   \r\n哈希存储键，保证get的时间复杂度为O(1)  \r\n双向链表存储值，保证put的时间复杂度为O(1) \r\n## 代码\r\n```\r\nvar Node = function(key, val){\r\n    this.key = key;\r\n    this.value = val;\r\n    this.next = null;\r\n    this.pre = null;\r\n}\r\n/**\r\n * @param {number} capacity\r\n */\r\n var LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.cache = new Map();\r\n    //虚拟头节点和尾节点，方便移动节点\r\n    this.head = new Node(null, null);\r\n    this.tail = new Node(null, null);\r\n    this.head.next = this.tail;\r\n    this.tail.pre = this.head;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    if(!this.cache.has(key)){\r\n        return -1;\r\n    }\r\n    let node = this.cache.get(key);\r\n    this.moveToHead(node);\r\n    return node.value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if(this.cache.has(key)){\r\n        let node = this.cache.get(key);\r\n        node.value = value;\r\n        this.moveToHead(node);\r\n    }\r\n    else{\r\n        let node = new Node(key,value);\r\n        this.cache.set(key, node);\r\n        this.addToHead(node);\r\n        //超过capacity时，删除尾节点\r\n        if(this.cache.size > this.capacity){\r\n            let tailPre = this.tail.pre;\r\n            tailPre.pre.next = this.tail;\r\n            this.tail.pre = tailPre.pre;\r\n            this.cache.delete(tailPre.key);\r\n        }\r\n    }\r\n};\r\n\r\nLRUCache.prototype.moveToHead = function(node){\r\n    node.pre.next = node.next;\r\n    node.next.pre = node.pre;\r\n    this.addToHead(node);\r\n}\r\n\r\nLRUCache.prototype.addToHead = function(node){\r\n    node.next = this.head.next;\r\n    this.head.next.pre = node;\r\n    this.head.next = node;\r\n    node.pre = this.head;\r\n}\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度：get() put()时间复杂度均为O(1)  \r\n空间复杂度：O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098204578","body":"## 思路\ndfs+递归  \n二叉树最大深度= Max(左子树最大深度，右子树最大深度) + 1\n## 代码\n```\nvar maxDepth = function(root) {\n    if(root == null) {\n        return 0;\n    }\n    else{\n        return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\n    }\n};\n```\n## 复杂度分析\n时间复杂度：O(n) 二叉树中所有节点只遍历1次  \n空间复杂度：O(height) height表示二叉树的深度，递归栈所需要的空间就是二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099038148","body":"## 思路\r\n递归  \r\n## 代码\r\n```\r\nvar isSameTree = function(p, q) {\r\n    if(p === null && q === null) return true;\r\n    if(p === null || q === null) return false;\r\n    return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(n) 二叉树中所有节点只遍历1次  \r\n空间复杂度：O(height) height表示二叉树的深度，递归栈所需要的空间就是二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100184432","body":"## 思路\n递归实现dfs\n## 代码\n```\nvar sumNumbers = function(root) {\n    return dfs(root, 0);\n};\n\nvar dfs = function(curNode, preSum){\n    if(curNode === null) return 0;\n\n    let sum = preSum * 10 + curNode.val;\n    if(curNode.left === null && curNode.right === null) return sum;\n    return dfs(curNode.left, sum) + dfs(curNode.right, sum);\n}\n```\n## 复杂度分析\n时间复杂度：O(n) 二叉树中所有节点只遍历1次  \n空间复杂度：O(h) h表示二叉树的深度，递归栈所需要的空间就是二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100692403","body":"## 思路\nBFS，最左边的节点就是该层第一个节点\n## 代码\n```\nvar findBottomLeftValue = function(root) {\n    let queue = [];\n    let cur;\n    let res;\n    queue.push(root);\n    while(queue.length > 0){\n        let curLength = queue.length;\n        for(let i = 0; i < curLength; i++){\n            cur = queue.shift();\n            if(i === 0){\n                res = cur.val;\n            }\n            if(cur.left !== null){\n                queue.push(cur.left);\n            }\n            if(cur.right !== null){\n                queue.push(cur.right);\n            }\n        }\n    }\n    return res;\n};\n```\n## 复杂度分析\n 时间复杂度:(n)  \n 空间复杂度:(q) q表示队列长度。最坏情况是满二叉树，此时q = (n - 1)/ 2,与n同阶","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100853018","body":"## 思路\nBFS，序列化时，叶子节点的两个null子节点，以\"null\"值序列化，这样可以在反序列化时保证在values[i]和values[i+1]分别为同一个节点的左右孩子，values[i + 2]为另一个节点的左孩子\n## 代码\n```\nvar serialize = function(root) {\n    let queue = [];\n    let res = [];\n    queue.push(root);\n    while(queue.length > 0){\n        let cur = queue.shift();\n        if(cur === null){\n            res.push(\"null\");\n        }\n        else{\n            res.push(cur.val);\n            queue.push(cur.left);\n            queue.push(cur.right);\n        }\n    }\n    return res.join(',');\n};\n\nvar deserialize = function(data) {\n    let values = data.split(\",\");\n    if(values[0] === \"null\") {\n        return null;\n    }\n    let root = new TreeNode(values[0]);\n    //保存每一层非空父节点\n    let parentsQueque = [root];\n\n    for(let i = 1; i < values.length; i+=2){\n        let parent = parentsQueque.shift();\n        if(parent != null){\n            let leftNode = values[i] === \"null\" ? null : new TreeNode(values[i]);\n            let rightNode = values[i + 1] === \"null\" ? null : new TreeNode(values[i + 1]);\n            parent.left = leftNode;\n            parent.right = rightNode;\n            if(leftNode !== null) parentsQueque.push(leftNode);\n            if(rightNode !== null) parentsQueque.push(rightNode);\n        }\n        else{\n            continue;\n        }\n    }\n    return root;\n};\n```\n## 复杂度分析\n 时间复杂度:(n)  \n 空间复杂度:(q) q表示队列长度。最坏情况是满二叉树，此时q = (n - 1)/ 2,与n同阶","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1102804164","body":"## 思路\ndfs遍历树，使其形成{col: {row :[val1, val2...]}}的结构，然后分别对col、row以及[val1,val2...]进行排序即可\n## 代码\n```\nvar verticalTraversal = function(root) {\n    let nodes = {};\n    dfs(root, 0, 0, nodes);\n    let res = [];\n    for(let col of Object.keys(nodes).sort((a, b) => a - b)){\n        let temp = [];\n        for(let row of Object.keys(nodes[col]).sort((a, b) => a - b)){\n            if(nodes[col][row].length == 1){\n                temp = temp.concat(nodes[col][row]);\n            }\n            else{\n                temp = temp.concat(nodes[col][row].sort((a, b) => a - b));  \n            }\n        }\n        res.push(temp);\n    }\n    return res;\n};\n\n\nvar dfs = function(node, row, col, nodes){\n    if(node === null) return;\n    if(col in nodes){\n        if(row in nodes[col]){\n            nodes[col][row].push(node.val);\n        }\n        else{\n            let temp = nodes[col];\n            temp[row] = [node.val];\n            nodes[col] = temp;\n        }\n    }\n    else{\n       let temp = {};\n       temp[row] = [node.val];\n       nodes[col] = temp;\n    }\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102765716","body":"## 思路\n使用哈希{value:index}用以保存已经遍历的数据，若target-value存在于哈希表中，则只需要O(1)的时间就可以找到\n## 代码\n```\nvar twoSum = function(nums, target) {\n    let map = new Map();\n    for(let i = 0; i < nums.length; i++){\n        if(map.has(target - nums[i])){\n            return [i, map.get(target - nums[i])]\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n};\n```\n## 复杂度分析\n 时间复杂度:O(n)   \n 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104094031","body":"## 思路\n1、建立Node类，用以保存元素值和频率，方便后续输出  \n2、使用Map保存各个元素的频次，形式为key：Node  \n3、对Map的前k个数进行自底向上的建立小顶堆heap，堆顶是频率最小的元素  \n4、对map的其余元素，比较其频率与堆顶元素的频率，如果频率大于堆顶元素的频率，则替换堆顶元素，然后自顶向下的堆化过程  \n5、输出heap的值\n\n## 代码\n```\nvar Node = function(key, val){\n    this.key = key;\n    this.val = val;\n}\n\nvar Swap = function(arr, i, j){\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n/**\n * @description: 根据heap索引，交换其中一部分元素\n * @param {Node[]} heap\n * @param {number} n：表示堆的大小\n * @param {*} i：对堆中第i个元素进行操作\n * @return {*}\n * @author: XuXiaoling\n */\nvar Heapify = function(heap, n, i){\n    if(i >= n) return;\n    let childIndex1 = 2 * i + 1;\n    let childIndex2 = 2 * i + 2;\n    let minIndex = i;\n    if((childIndex1 < n) && (heap[childIndex1].val < heap[minIndex].val)){\n        minIndex = childIndex1;\n    }\n    if((childIndex2 < n) && (heap[childIndex2].val < heap[minIndex].val)){\n        minIndex = childIndex2;\n    }\n    if(minIndex != i){\n        Swap(heap, minIndex, i);\n        Heapify(heap, n, minIndex);\n    }\n}\n\n\n/**\n * @description: 构建小顶堆\n * @param {*} heap\n * @param {*} n\n * @return {*}\n * @author: XuXiaoling\n */\nvar BuildHeap = function(heap, n){\n    let lastIndex = n - 1;\n    let lastParentIndex = Math.floor((lastIndex - 1) / 2);\n    for(let i = lastParentIndex; i >=0; i--){\n        Heapify(heap, n, i);\n    }\n}\n\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    //使用map求得各个元素的频率\n    let map = new Map();\n    let res = [];\n    nums.forEach(num => {\n        let count = map.has(num) ? map.get(num).val : 0;\n        map.set(num, new Node(num, count + 1));\n    })\n    let heap = []\n    map.forEach((value, key) =>{\n        if(heap.length < k){\n            heap.push(value);\n            BuildHeap(heap, heap.length);\n        }\n        else{\n            if(value.val > heap[0].val){\n                heap[0] = value;\n                BuildHeap(heap, heap.length);\n            }\n        }\n    })\n\n    heap.forEach(node =>{\n        res.push(node.key);\n    })\n    return res;\n};\n```\n## 复杂度分析\n 时间复杂度:O(nlogk) n表示nums的长度，k表示最高频率的前k个元素   \n 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105380480","body":"## 思路\n1、计算points中剩余点与p1之间的距离，并以距离为key，相同距离点的数量为value  \n2、根据排列组合，能与p1组成回旋镖的数目 = value * （value - 1）\n\n## 代码\n```\nvar numberOfBoomerangs = function(points) {\n    let res = 0;\n    let map = new Map();\n    for(let p1 of points){\n        for(let p2 of points){\n            let dist = Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n            let count = map.has(dist) ? map.get(dist) : 0;\n            map.set(dist, count + 1);\n        }\n        for(let val of map.values()){\n            res += val * (val - 1);\n        }\n        map.clear();\n    }\n    return res;\n};\n```\n## 复杂度分析\n 时间复杂度:O(n^2)  \n 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106645646","body":"## 思路\r\n1、滑动窗口+哈希，其中哈希key为字符，value为该字符的索引  \r\n2、遍历字符串的过程中，当出现重复字符时，将left更新为map中重复字符的索引+1，并同时更新map中重复字符索引为right\r\n\r\n## 代码\r\n```\r\nvar lengthOfLongestSubstring = function(s) {\r\n    let left = 0;\r\n    let res = 0;\r\n    let map = new Map();\r\n    for(let right = 0; right < s.length; right++){\r\n        //map.get(s[right]) >= left，避免abba这种情况，保证重复的元素索引是在当前left、right内\r\n        if(map.has(s[right]) && map.get(s[right]) >= left){\r\n            left = map.get(s[right]) + 1;\r\n        }\r\n        map.set(s[right], right);\r\n        res = Math.max(res, right - left + 1);\r\n    }\r\n    return res;\r\n};\r\n```\r\n## 复杂度分析\r\n 时间复杂度:O(n)  \r\n 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107517930","body":"## 思路\r\n 1、使用wordMap保存单词以及对应的数目，key为单词，value为单词对应的数目   \r\n 2、使用left和right构成定长的滑动窗口，在滑动窗口中截取字串subStr。如果subStr不存在于wordMap中，left左移；若subStr存在于wordMap中，则存入tempMap。如果tempMap[subStr] > wordMap[subStr]，left左移  \r\n 3、最后判断tempMap和wordMap是否相同\r\n\r\n## 代码\r\n```\r\nvar findSubstring = function(s, words) {\r\n    let res = [];\r\n    if(words.length === 0) return res;\r\n    let wordLength = words[0].length;\r\n\r\n    //wordMap：统计words中的单词数目\r\n    let wordMap = new Map();\r\n    for(let word of words){\r\n        let count = wordMap.has(word) ? wordMap.get(word) : 0;\r\n        wordMap.set(word, count + 1);\r\n    }\r\n\r\n    let tempMap = new Map();\r\n    for(let left = 0; left < s.length - wordLength * words.length + 1; left++){\r\n        let right = left + wordLength * words.length - 1;\r\n        let i = left;\r\n        while( i <= right){\r\n            let subStr = s.slice(i, i + wordLength);\r\n            if(wordMap.has(subStr)){\r\n                let tempCount = tempMap.has(subStr) ? tempMap.get(subStr) : 0;\r\n                tempMap.set(subStr, tempCount + 1);\r\n                if(tempMap.get(subStr) > wordMap.get(subStr)) break;\r\n                i += wordLength;\r\n            }\r\n            else break;\r\n        }\r\n        if(i - right === 1) {\r\n            res.push(left);\r\n        }\r\n        tempMap.clear();\r\n    }\r\n    return res;\r\n};\r\n```\r\n## 复杂度分析\r\n 时间复杂度:O(n * m) n表示s长度，m表示单词个数  \r\n 空间复杂度:O(m) m表示单词个数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108003460","body":"## 思路\n快慢指针\n## 代码\n```\nvar middleNode = function(head) {\n    if(head === null)  return null;\n    let fast = head;\n    let slow = head;\n    while(fast !== null && fast.next !== null){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow;\n};\n```\n## 复杂度分析\n 时间复杂度:O(n)  \n 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109599299","body":"## 思路\n双指针，将不重复的k个元素全部移到数组的前k个位置上\n## 代码\n```\nvar removeDuplicates = function(nums) {\n    if(nums.length === 0 || nums.length === 1) return nums.length;\n    let fast = 0;\n    let slow = 0;\n    while(fast < nums.length - 1){\n        if(nums[fast] === nums[fast + 1]){\n            fast++;\n        }\n        else{\n            slow++;\n            fast++;\n            nums[slow] = nums[fast];\n        }\n    }\n    return slow + 1;\n};\n\n```\n## 复杂度分析\n 时间复杂度:O(n)  \n 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111147718","body":"## 思路\n双指针，二分法\n## 代码\n```\nvar searchInsert = function(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while(left <= right){\n        let mid = Math.floor((right + left) / 2);\n        if(nums[mid] == target) return mid;\n        else if(nums[mid] < target) left = mid + 1;\n        else if(nums[mid] > target) right = mid -1;\n    }\n    return left;\n};\n\n```\n## 复杂度分析\n 时间复杂度:O(log n)  \n 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112334486","body":"## 思路\n双指针，单调递减队列  \n队列里存的是从大到小排序的值的索引，因此队首就是最大值的索引\n\n## 代码\n```\nvar maxSlidingWindow = function(nums, k) {\n    let res = [];\n    let queue = [];\n    //找到第一个滑动窗口的最大值，当nums.length < i < k时，nums[i] = undefined, undefined使用<、>和任何值比较大小均为false\n    for(let i = 0; i < k; i++){\n        while(queue.length > 0 && nums[queue[queue.length - 1]] < nums[i]){\n            queue.pop();\n        }\n        queue.push(i);\n    }\n\n    res.push(nums[queue[0]]);\n    for(let right = k; right < nums.length; right++){\n        let left = right - k + 1;\n        while(queue[0] < left){\n            queue.shift();\n        }\n        while(queue.length > 0 && nums[queue[queue.length - 1]] < nums[right]){\n            queue.pop();\n        }\n        queue.push(right);\n        res.push(nums[queue[0]]);\n    }\n    return res;\n    \n};\n\n```\n## 复杂度分析\n 时间复杂度：O(n) 每个元素最多入队出队一次  \n 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113448720","body":"## 思路\n根据图节点的入度和出度判断。法官的入度为n - 1，出度为0\n\n## 代码\n```\nvar findJudge = function(n, trust) {\n    let inDegree = new Array(n + 1).fill(0);\n    let outDegree = new Array(n + 1).fill(0);\n    for(let ele of trust){\n        inDegree[ele[1]] += 1;\n        outDegree[ele[0]] += 1;\n    }\n    for(let i = 1; i < n + 1; i++){\n        if(inDegree[i] == n - 1 && outDegree[i] == 0){\n            return i;\n        }\n    }\n    return -1;\n};\n\n```\n## 复杂度分析\n 时间复杂度：O(n)  \n 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ha0cheng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086068703","body":"思路：\r\n实现数组形式的加法，逐位相加，保存进位\r\n\r\n代码：\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        Next= 0\r\n        p = len(num)- 1\r\n        while p>=0:\r\n            x = num[p]+k%10+Next\r\n            num[p] = x%10\r\n            Next = x//10\r\n\r\n            k//=10\r\n            p-=1\r\n            if k==0 and Next ==0:\r\n                break\r\n\r\n        while k>0 or Next>0:\r\n            x = k%10+Next\r\n            num.insert(0,x%10)\r\n            Next = x//10\r\n            k//=10\r\n        return num\r\n```\r\n\r\n\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086159354","body":"思路：\r\n遍历两遍，第一遍确定字符的位置，第二遍确定距离每个字符位置最近的字符区间，输出结果\r\n\r\n代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        P = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n              P.append(i)\r\n        r = []\r\n        left = 0\r\n        for i in range(len(P)):\r\n            if i==len(P)-1:\r\n                right = len(s)-1\r\n            else:\r\n                right = (P[i]+P[i+1]-1)//2\r\n            j = P[i] - left \r\n            while j>0:\r\n                r.append(j)\r\n                j-=1\r\n            while j<=right-P[i]:\r\n                r.append(j)\r\n                j+=1\r\n        \r\n            left = right+1\r\n        \r\n        return r\r\n```\r\n时间复杂度：需要遍历两遍，每次均是原字符数组的长度，所以复杂度为O(N)\r\n空间复杂度：需要一个空间来存储字符位置，最坏情况下是N，复杂度为O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886712","body":"思路：\r\n\r\n入栈和出栈都是基础操作，主要要实现的是第三个功能，栈底前k个元素增加值，要访问栈底，想到使用数组，最开始的思路是循环增加前k个值，复杂度是O(k)，看了参考答案，如果用数组add来保存每个位置的增加量，并且在pop的过程中传递倒数第二个值，便可实现增加量的传递，实现复杂度为O(1)的方法\r\n\r\n代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.Stack = [] \r\n        self.add = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.Stack.append(x)\r\n            self.add.append(0)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            if self.length>1:\r\n                self.add[self.length-2] += self.add[self.length-1]\r\n            self.length-=1\r\n            return self.Stack.pop()+self.add.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        idx = min(k-1,self.length-1)\r\n        if idx>=0:\r\n            self.add[idx] += val\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：入栈，出栈和增加值的复杂度都是O(1)\r\n空间复杂度：设当前栈长度是cnt，那么需要额外存储的add数据需要空间是O(cnt)，复杂度是O(cnt)，最坏情况下复杂度是O(maxSiz)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1090462710","body":"思路1：使用递归，主要解决括号的嵌套，从左到右遍历，遍历一个字符分四种情况：\r\n1.如果是数字，则需要形成一个有效的数字，参考字符串转数字，保存\r\n2.如果是字母，则直接加在解码字符串后面\r\n3.如果是'['，则调用该递归函数，把这个'['对应的']'之间的字符解码，乘以保存的数字，加入到解码字符串后面\r\n4.如果是']'，则返回该字符串，同时需要一个指针指示现在的位置，继续遍历后面的\r\n\r\n代码如下：\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def decode_substr(idx):\r\n            decoded_str=''\r\n            num = 0\r\n            while idx<len(s):\r\n                if s[idx].isdigit():\r\n                    num= num*10+int(s[idx])\r\n                elif s[idx].isalpha():\r\n                    decoded_str += s[idx]\r\n                elif s[idx]=='[':\r\n                    substr,idx = decode_substr(idx+1)\r\n                    decoded_str += num*substr\r\n                    num=0\r\n                elif s[idx]==']':\r\n                    return decoded_str,idx\r\n                idx+=1\r\n            return decoded_str\r\n\r\n        return decode_substr(0)\r\n```\r\n\r\n复杂度分析:\r\n时间复杂度：遍历一遍字符串，复杂度为O(N)\r\n空间复杂度：保存一个解码后的字符串，复杂度为O(N)\r\n\r\n\r\n\r\n思路2：使用栈\r\n具体来说，一个数字栈，储存重复的次数，一个字符串栈，储存当前中括号前的字符串信息，以及一个result字符，代表当前中括号内的字符结果。\r\n1.如果是数字，保存\r\n2.如果是字母，则直接加在result\r\n3.如果是'['，则num进栈，result进栈，num设为0,result设为空字符，\r\n4.如果是']'，此时的result代表这个']'对应的一段字符，重复数字栈的栈顶数字后，在前面加上字符串的栈顶就是前一个'['的字符串前列。\r\n\r\n代码：\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        numstack = []\r\n        strstack = []\r\n        num = ''\r\n        result = ''\r\n        for i in range(len(s)):\r\n            if s[i].isdigit():\r\n                num+=s[i]\r\n            elif s[i].isalpha():\r\n                result +=s[i]\r\n            elif s[i] == '[':\r\n                numstack.append(int(num))\r\n                strstack.append(result)\r\n                result = ''\r\n                num=''\r\n            elif s[i] == ']':\r\n                result = strstack.pop() + result * numstack.pop()\r\n            \r\n\r\n        return result\r\n```\r\n复杂度分析：\r\n\r\n时间复杂度：遍历一遍字符串，每一种操作都是O(1)，复杂度为O(N)\r\n空间复杂度：两个栈的空间，不会超过O(N)，一个result字符串，一个num字符串，也不会超过O(N),复杂度为O(2N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1091925625","body":"思路：两个栈，一个栈作为进栈instack，一个作为出栈Outstack，当有元素加入队列时，直接压入instack中，出队列时如果outstack非空就弹出outstack栈顶元素，如果是空，则将instack的元素按顺序弹出并压入outstack中，弹出栈顶元素。这是利用了栈的进出过程是一次逆序过程，而队列是顺序，两次逆序就等同于顺序。\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.Instack = []\r\n        self.Outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.Instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.Outstack:\r\n            return self.Outstack.pop()\r\n        while self.Instack:\r\n            temp = self.Instack.pop()\r\n            self.Outstack.append(temp)\r\n        if self.Outstack:\r\n            return self.Outstack.pop()\r\n        else:\r\n            return None    \r\n\r\n    def peek(self) -> int:\r\n        if self.Instack:\r\n            return self.Instack[0]\r\n        elif self.Outstack:\r\n            return self.Outstack[-1]\r\n        else:\r\n            return None\r\n\r\n    def empty(self) -> bool:\r\n        if not self.Instack and not self.Outstack:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n```\r\n\r\n复杂度分析：\r\n\r\n时间复杂度：入队O(1)，出队复杂度为O(N)，但是摊还复杂度分析，如果所有元素均出栈，则最多只需要O(N)的操作,平均复杂度为O(1)，相反的如果只出栈一个元素，同时这个出栈操作是最后一个操作，那么复杂度是O(N)，最坏情况下。\r\n空间复杂度：O(1),两个栈的总空间不会超过队列所占的空间。","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091189327","body":"思路：首先遍历一遍，确定链表长度n，然后找到新的头节点和尾节点，原来的尾节点要连在源头节点上，形成一个环形列表，然后找到第n-k个节点，是新的尾节点；第n-k+1个节点，是新的头节点，返回。\r\n\r\n代码：\r\n\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        tail = head\r\n        n=1\r\n        while tail.next:\r\n            tail=tail.next\r\n            n+=1\r\n        k=k%n\r\n        i=0\r\n        tail.next=head\r\n        for i in range(n-k-1):\r\n            head = head.next   \r\n        new_head = head.next\r\n        head.next = None\r\n    \r\n        return new_head\r\n```\r\n  \r\n复杂度分析：\r\n时间复杂度：遍历两遍，第一次n，第二次n-k，是O(n)\r\n空间复杂度：只需要一些空间来存储尾节点和新头节点，复杂度是O(1)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092446399","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # if not head or not head.next:\n        #     return head\n        \n        pre_node = ListNode(next=head)   \n        last_node = pre_node\n        while head and head.next:\n            next_head = head.next.next\n\n            last_node.next = head.next\n            head.next.next = head\n            head.next = next_head\n\n            last_node = head\n            head = next_head\n  \n        return pre_node.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072329","body":"思路：参考官方思路，递归的形成平衡二叉树，对于一段链表来说，递归的过程就是找到中间节点，作为根节点，同时调用函数，把左右两个链表分别转化成左子树和右子树，返回左子树和右子树的根节点，作为该根节点的左右子节点即可。\r\n注意是要把中间节点左右链表变成两个子链表需要让中间节点前一个节点断开，指向None.\r\n\r\n代码如下：\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        fast = head\r\n        slow = head\r\n        pre = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n\r\n        root = TreeNode(val=slow.val)\r\n    \r\n        if not pre:\r\n            return root    \r\n        pre.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n复杂度分析：\r\n时间复杂度：递归深度为O(log N)，每次递归需要遍历整个递归链表，即O(Nlog N)\r\n空间复杂度：递归深度为O(log N)，因为每次递归，问题规模变为原来的一半，规模指数下降，所以空间复杂度为O(log N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294747","body":"思路1：保存一条链表的所有节点在一个哈希表中，然后遍历另外一个节点找到第一个在这个哈希表中的节点。\r\n思路2：遍历两个链表，保存长度m,n，可以得到相交链表起始点的差距|m-n|，然后用快慢指针找到第一个相等的节点即可。\r\n思路3：用两个指针从A和B的头结点开始遍历，如果A遍历到尾就再从B的头结点开始遍历，如果B到头就从A的头结点继续开始遍历，最终能到达同样的结点，即是相同的起始结点；如果同时到达None，则是无共同结点。\r\n\r\n思路2代码如下：\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        lengthA = 1\r\n        lengthB = 1\r\n        A = headA\r\n        B = headB\r\n        while A.next:\r\n            lengthA +=1\r\n            A = A.next\r\n        while B.next:\r\n            lengthB +=1\r\n            B = B.next\r\n\r\n        A = headA\r\n        B = headB\r\n        if lengthA>=lengthB:\r\n            for i in range(0,lengthA-lengthB):\r\n                A=A.next\r\n        else:\r\n            for i in range(0,lengthB-lengthA):\r\n                B=B.next\r\n        \r\n        while A!=B:\r\n            A=A.next\r\n            B=B.next\r\n        return A\r\n```\r\n\r\n思路3代码如下：\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        A = headA\r\n        B = headB\r\n        while A or B:\r\n            A = A if A else headB\r\n            B = B if B else headA\r\n            if A == B:\r\n                return A \r\n            A = A.next \r\n            B = B.next \r\n        \r\n        return None\r\n\r\n```\r\n\r\n分析：\r\n思路1 遍历一遍，需要一个哈希表来存储，时间复杂度为O(m+n)，空间复杂度为O(n)\r\n思路2 需要遍历两遍，时间复杂度为O(m+n)，空间复杂度为O(1)\r\n思路3 需要遍历两遍，时间复杂度最坏是O(m+n)，空间复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095190019","body":"思路：快慢指针。从预先的节点pre开始走，slow每次走一步，fast每次走两步。直到遇到None(无环)或者slow和fast重合。如果重合，假设pre到环的入口长度是A，入口到重合点的长度是B，重合点到入口的长度是C，则此时slow走的步长是A+B，fast走的步长是2(A+B) = A+n(B+C)+B，可得C = (n-1)(B+C)+A，所以A%(B+C) = C%(B+C). 则我们设置一个点从重合点出发，一个点从pre出发，最终会达到环的入口，结束。\r\n\r\n代码如下：\r\n\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        pre = ListNode(0)\r\n        pre.next = head\r\n        right = pre\r\n        left = pre\r\n        while right.next and right.next.next:\r\n            right=right.next.next\r\n            left=left.next\r\n            if left==right:\r\n                break\r\n        if not right.next or not right.next.next:\r\n            return None\r\n        \r\n        left = pre\r\n        while left!=right:\r\n            left=left.next\r\n            right=right.next\r\n\r\n        return left\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度，最多遍历两次，复杂度为O(N)\r\n空间复杂度，只需要常数项的时间，复杂度为O(1)\r\n\r\n另外可以用哈希表保存遍历过的点，每次进入一个新的点，判断是否在表中O(1)，此时复杂度为O(N),需要存储哈希表复杂度为O(N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096900863","body":"思路：双向链表+哈希表，实现O(1)的访问和插入\r\n\r\n代码如下：\r\n\r\n```\r\nclass DoublelinkedListNode:\r\n    def __init__(self,key=0,value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.pre = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = {}\r\n        self.head = DoublelinkedListNode(-1,-1)\r\n        self.tail = DoublelinkedListNode(-1,-1)\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            self.movetohead(self.cache[key])\r\n            return self.cache[key].value        \r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.cache[key].value = value\r\n            self.movetohead(self.cache[key])\r\n        else:\r\n            new_head = DoublelinkedListNode(key,value)\r\n            self.cache[key] = new_head\r\n            if self.size<self.capacity:\r\n                self.addtohead(new_head)\r\n                self.size+=1\r\n            else:\r\n                self.cache.pop(self.tail.pre.key)\r\n                self.deletenode(self.tail.pre)\r\n                self.addtohead(new_head)\r\n\r\n\r\n                \r\n    def addtohead(self,node):\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n\r\n\r\n    def deletenode(self,node):\r\n        node.next.pre = node.pre\r\n        node.pre.next = node.next\r\n\r\n    def movetohead(self,node):\r\n        self.deletenode(node)\r\n        self.addtohead(node)\r\n```\r\n\r\n时间复杂度： get和put操作均为O(1)\r\n空间复杂度：需要储存一个哈希表，复杂度是O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097515521","body":"思路： 递归遍历，假定F(node)可以计算以node为根节点的最大深度，那么有递推式F(node) = 1 + max(F(node.left),F(node.right)). 最后补充递归终止条件，if node==None:F(node) =0.\r\n\r\n代码如下：\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\r\n```\r\n时间复杂度：O(N)，本质上相当于深度优先遍历，DFS\r\n空间复杂度：O(maxDepth)，回归栈的深度最深为树的最大深度。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100174416","body":"思路：DFS，需要找到所有叶子节点，需要存储每个节点当前对应的cur值，当遍历到叶子节点时，该路径的值即为cur*10 + val\r\n\r\n代码如下\r\n```\r\nclass Solution:\r\n    def sumNumbers(self, root: TreeNode) -> int:\r\n        def dfs(root, cur):\r\n            if not root:                          \r\n            #空节点返回 0 \r\n                return 0\r\n            if not root.left and not root.right: \r\n            # 找到叶子节点，返回值 \r\n                return cur*10 + root.val\r\n            else:                              \r\n            # 如果非空节点，继续找叶子节点，更新当前父节点的cur值\r\n                return dfs(root.left, cur*10 + root.val) + dfs(root.right, cur*10 + root.val)\r\n    \r\n        return dfs(root, 0)\r\n```\r\n时间复杂度：遍历所有节点一遍，O(N)\r\n空间复杂度：回归栈的大小为树的深度,O(depth)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100595462","body":"思路：找到最后一层中最左边的节点，DFS递归或者层次遍历。\r\n\r\n1. 递归\r\n写一个函数，找到以这个节点为根节点的最后一层最左边的节点的值，同时返回深度。则递归过程为：\r\n返回左子树的最左节点和右子树的最左节点中深度最深的那个，如果同样深则返回左子树的最左节点。\r\n\r\n时间复杂度: O(N), 需要遍历一遍所有节点\r\n空间复杂度: O(depth)，是递归所占用的空间，为树的深度\r\n\r\n2.层次遍历\r\n逐层的遍历一棵树，从左到右访问，访问完一个节点将他的左右子节点加入到队列中，进行下次遍历，每一层最左的节点即是刚开始遍历这一层时的最左边节点。\r\n\r\n时间度复杂度：O(N), 需要遍历一遍所有节点\r\n空间复杂度:  O(Q)，是队列最多需要保存的一层的节点个数，满二叉树下与N同阶\r\n\r\n\r\n递归代码如下：\r\n```\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        def DFS_findvalue(root,cur_depth):\r\n            if not root.left and not root.right:\r\n                return root.val, cur_depth\r\n\r\n            left_depth = cur_depth\r\n            right_depth = cur_depth\r\n\r\n            if root.left:\r\n                left_val, left_depth = DFS_findvalue(root.left, cur_depth+1)\r\n            if root.right:\r\n                right_val, right_depth  = DFS_findvalue(root.right, cur_depth+1)\r\n            if left_depth >= right_depth:\r\n                return left_val, left_depth\r\n            else:\r\n                return right_val, right_depth\r\n\r\n        val, depth = DFS_findvalue(root,0)\r\n        return val\r\n```\r\n\r\n层次遍历代码如下：\r\n```\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        queue = collections.deque()\r\n        queue.append(root)\r\n        while queue:\r\n            length = len(queue)\r\n            res = queue[0].val\r\n            for _ in range(length):\r\n                node = queue.popleft()\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n        \r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100903934","body":"思路：层次遍历, BFS\r\n序列化：层次遍历，保存每一层的节点\r\n反序列化：按层次遍历输出节点。\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)，都是层次遍历一遍，复杂度都是O(N)\r\n空间复杂度：O(Q)，即需要保存的队列的最长的长度。\r\n代码如下：\r\n```\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root: return '#' \r\n        ans = ''\r\n        queue = [root]\r\n\r\n        while queue:\r\n            node = queue.pop(0)\r\n            if node:\r\n                ans += str(node.val) + ','\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                ans += '#,'\r\n        # print(ans)   \r\n        return ans\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data == '#': return None\r\n\r\n        nodes = data.split(',')\r\n        root = TreeNode(val = int(nodes[0]))\r\n        queue = [root]\r\n        left = 1\r\n        while  left< len(nodes)-1:\r\n            pre = queue.pop(0)\r\n            if nodes[left] == '#':\r\n                pre.left = None\r\n            else:\r\n                node = TreeNode(val = int(nodes[left]))\r\n                pre.left = node\r\n                queue.append(node)\r\n\r\n            right = left +1 \r\n            if nodes[right] == '#':\r\n                pre.right = None\r\n            else:\r\n                node = TreeNode(val = int(nodes[right]))\r\n                pre.right = node\r\n                queue.append(node)\r\n            \r\n            left += 2\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101501061","body":"思路：层次遍历，先处理一层的节点，然后将这一层的节点排序后，加入总的结果中，用字典来存储结果，字典的key是列的值。\r\n\r\n复杂度分析：\r\n时间复杂度:  O(N+Mlog M+QlogQ) , 主要是层次遍历的复杂度O(N), 以及排序的复杂度O(MlogM)，其中M是最后的column的个数，Q是最坏情况下同一层的节点都在同一列，大致为O(NlogN).\r\n空间复杂度：O(N), 哈希表的大小与节点个数同阶\r\n\r\n\r\n代码如下：\r\n```\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        re = {}\r\n        node_queue = [root]\r\n        col_queue = [0]\r\n        while node_queue:\r\n            length = len(node_queue)\r\n            layer_re = {}\r\n            for _ in range(length):\r\n                \r\n                node = node_queue.pop(0)\r\n                col = col_queue.pop(0)\r\n                if col not in layer_re.keys():\r\n                    layer_re[col] = [node.val]\r\n                else:\r\n                    layer_re[col].append(node.val)\r\n            \r\n                if node.left:\r\n                    node_queue.append(node.left)\r\n                    col_queue.append(col-1)\r\n                if node.right:\r\n                    node_queue.append(node.right)\r\n                    col_queue.append(col+1)\r\n                \r\n            for i in layer_re.keys():\r\n                layer_re[i].sort()\r\n                if i not in re.keys():\r\n                    re[i] = layer_re[i]\r\n                else:\r\n                    re[i].extend(layer_re[i])\r\n            \r\n        Col = list(re.keys())\r\n        Col.sort()\r\n        result = []\r\n        for col in Col:\r\n            result.append(re[col])\r\n        return result \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102344736","body":"思路：\r\n1.穷举\r\n穷举每两个元素的和，判断是否等于target\r\n2.哈希表\r\n用哈希表来存储访问过的元素的下标，每当访问一个新的元素nums[i]时，判断target-nums[i]是否在哈希表中\r\n\r\n穷举复杂度：\r\n时间复杂度：O(N^2)\r\n空间复杂度：O(1)\r\n\r\n哈希表复杂度:\r\n时间复杂度：O(N)，因为判断target-nums[i]是否在哈希表的操作复杂度为O(1)\r\n空间复杂度：O(N)，需要建立一个哈希表来存储访问过的元素\r\n\r\n\r\n\r\n哈希表代码如下：\r\n```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        hashmap = {}\r\n        for i in range(len(nums)):\r\n            if target - nums[i] in hashmap:\r\n                return [hashmap[target - nums[i]],i]\r\n            hashmap[nums[i]] = i\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103546303","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        for num in nums:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n\n        Bucket = [[] for _ in range(len(nums))]\n\n        for i in count.keys():\n            Bucket[count[i]-1].append(i)\n        Result = []\n        i = len(nums)-1\n        while len(Result)<k:\n            Result.extend(Bucket[i])\n            i -= 1\n        return Result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105321805","body":"思路：遍历存储邻接矩阵+哈希表\r\n题目的本质是找到dist(i,j) = dist(i,k)，如果把i当成中点，则需要找到离i距离相同的两个点，有顺序要求，假设离i距离为D的点有n个，那么则存在n(n-1)个不同的组合，因为算的是两两距离，我先用一个邻接矩阵存储距离，然后遍历每一行。\r\n\r\n复杂度分析：\r\n时间复杂度：O(n^2），两层循环\r\n空间复杂度：O(n^2)，邻接矩阵的空间为n^2\r\n\r\n```\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        num = len(points)\r\n\r\n        A = [[0 for _ in range(num)] for i in range(num)]\r\n        for i in range(num):\r\n            for j in range(i+1,num):\r\n                A[i][j] = (points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2\r\n                A[j][i] = A[i][j]\r\n\r\n        Result = 0\r\n        for i in range(num):\r\n            Count = collections.Counter(A[i])\r\n            for n in Count.values():\r\n                if n>1:\r\n                    Result += n*(n-1)\r\n        \r\n        return int(Result)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105482358","body":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s: return 0\n        position = {}\n        left = 0\n        right = 0 \n        maxstr = 0\n        for right in range(len(s)):\n            if s[right] in position:\n                if position[s[right]]>=left:\n                    if maxstr < right - left:\n                        maxstr = right - left\n                    left = position[s[right]]+1\n            position[s[right]] = right\n\n        if maxstr < right - left+1:\n            maxstr = right - left+1 \n        return maxstr","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107521572","body":"思路：双指针+哈希表\r\n先用哈希表存储需要匹配的字符列表的统计个数。\r\n用双指针中间的窗口来代表目前访问的字符串，用哈希表来代表目前这段窗口的统计个数，如果一致则记录，不一致则分情况移动左右指针，具体的是：\r\n1.如果右指针之前指的字符在字符列表中，统计个数超过了原有，那么就找到可以减去这个字符串个数的位置，移动左节点\r\n2.如果不在列表中，则移动右指针+1，左指针指向离右指针距离为一个匹配字符串的长度，重新记录哈希表。\r\n\r\n复杂度分析：\r\n时间复杂度：O(n+m), n是字符串长度，m是字符列表长度，因为遍历一遍字符串，每次需要操作O(1)\r\n空间复杂度：O(m)， 哈希表的大小与m成正比\r\n\r\n代码如下\r\n```\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        length = len(words[0])\r\n        Count = Counter()\r\n        curr = {}\r\n        for i in range(len(words)):\r\n            Count[words[i]] +=1\r\n        n = i+1\r\n        r = []\r\n        left = 0\r\n        right = length\r\n        C = Counter()\r\n        while right < len(s)+1:\r\n            if Count[s[right-length:right]]:\r\n\r\n                C[s[right-length:right]] +=1\r\n                print(left,right)\r\n                if C[s[right-length:right]]>Count[s[right-length:right]]:\r\n                    C[s[left:left+length]] -=1\r\n                    left +=length\r\n                    while C[s[right-length:right]]>Count[s[right-length:right]]:\r\n                        C[s[left:left+length]] -=1\r\n                        left +=length\r\n                    right+=length\r\n\r\n                else:\r\n                    # print(left,right)  \r\n                    if (right - left)/length == n:\r\n                        r.append(left)\r\n                        C[s[left:left+length]] -=1\r\n                        left+=length\r\n                    right+=length \r\n\r\n            else:\r\n                right+=1\r\n                left = right - length\r\n                C = Counter()\r\n\r\n        return r\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108457408","body":"思路：快慢指针\r\n快慢指针从头结点出发，慢指针每次走一步，快指针每次走两步，如果快指针到了None或者快指针.next到了None就停止，此时慢指针恰好指向中点偏右的方向。\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)，需要遍历一遍链表\r\n空间复杂度：O(1)\r\n\r\n\r\n代码如下：\r\n```\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        return slow\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111151737","body":"思路：二分法+双指针\r\n按照二分法来找target\r\n备注: 我这里[left,right]指代的是target有可能出现的位置，当left>right停止，此时left指针就是指向target应该在的位置\r\n\r\n复杂度：\r\n时间复杂度：O(logn)，每次搜索空间减少一半，所以按logn的复杂度递减\r\n空间复杂度：O(1)\r\n\r\n代码如下\r\n```\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left = 0\r\n        right = len(nums)-1\r\n        while left<=right:\r\n            if nums[(left+right)//2]<target:\r\n                left =  (left+right)//2+1\r\n            elif nums[(left+right)//2]>target:\r\n                right = (left+right)//2-1\r\n            else:\r\n                return (left+right)//2\r\n\r\n        return left\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joewx21":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086071168","body":"### 思路\n\n将k加到num的低位，大于10就取余留下个位，整除取出个位得到进位，每位循环直到最高位并且 k 为0或者i<0。如果 i 小于0，数字长度加一，再循环上过程。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        while(k > 0){\n            num[i] += k;\n            k = num[i] / 10;\n            num[i--] %= 10;\n            if(i < 0 && k > 0){\n                num.insert(num.begin(), 0);\n                i = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(n)\n\\- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663863","body":"### 思路\n\n先把s中所有等于c的元素的下标值存入到数组sc中，然后利用双重循环遍历s，比较s中各个下标值与sc中元素值的大小，将当前下标值与sc[j]的差的绝对值最小值存入scret中\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> sc; // 与c相同的值得索引\n        vector<int> scret; // 距离结果\n        for(int i =0; i<s.size(); i++){\n            if(s[i] == c){\n                sc.push_back(i);\n            }\n        }\n        if(sc.size() == 1){\n            for(int i = 0; i < s.size(); i++){\n                scret.push_back(abs(i-sc[0]));\n            }\n        }\n        for (int i = 0; i<s.size(); i++){\n            for(int j = 0; j<sc.size()-1; j++){\n                if(i<=sc[j]){\n                    scret.push_back(abs(sc[j]-i));\n                    break;\n                }\n                if(i>sc[j]&&i<=sc[j+1]){\n                    scret.push_back(min(abs(i-sc[j]), abs(i-sc[j+1])));\n                    break;\n                }\n                if(i>sc[sc.size()-1]){\n                    scret.push_back(abs(i-sc[sc.size()-1]));\n                    break;\n                }\n            }\n        }\n        return scret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858315","body":"### 思路\n\n这里使用数组来进行栈的模拟，方便执行inc(int k, int val)操作\n\n### 代码\n\n```cpp\nclass CustomStack {\npublic:\n    int maxSize;\n    vector<int> stack;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if(stack.empty()||stack.size()<maxSize){\n            stack.push_back(x);\n            return ;\n        }\n    }\n    \n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        int val = stack.back();\n        stack.pop_back();\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k&&i<stack.size(); i++){\n            stack[i] += val;\n        }\n        return ;\n    }\n};\n```\n\n**时间复杂度**：O(min(k, stak.size()))\n\n**空间复杂度**：O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087568418","body":"### 思路\n\n用两个栈，一个存字符串一个存数字，遇到数字就把之前的字符串压入字符串栈，再把数字压入数字栈，因为数字后必是`[`，使用`str`记录的字符串是`[`之前的，将其压入栈，重新记录`str`，遇到`]`时，弹出数字栈顶元素k，并重复`str`k次。之后将字符串栈栈顶元素弹出来并与当前字符串拼接，作为新的当前正在累积的字符串。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> str_stk;//字符串栈\n        stack<int> num_stk;//数字栈\n        string str;\n        for(int i=0;i<s.size();i++){\n            if(isdigit(s[i])){\n                int n=s[i]-'0';\n                while(isdigit(s[++i])){\n                    n=10*n+s[i]-'0';\n                }\n                num_stk.push(n);\n                i--;\n            }\n            else if(s[i]=='['){\n                str_stk.push(str);\n                str=\"\";\n            }\n            else if(s[i]==']'){\n                string tmp;\n                for(int i=0;i<num_stk.top();i++){\n                    tmp+=str;\n                }\n                str=tmp;\n                num_stk.pop();\n                str=str_stk.top()+str;\n                str_stk.pop();\n            }\n            else{\n                str+=s[i];\n            }\n        }\n        return str;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088900438","body":"### 思路\n\n用两个栈来模拟队列，当需要出队时，直接取出tmp栈里面的元素，若tmp为空将stk栈的元素依次放入即可。\n\n### Code\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> stk, tmp;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    void get() {\n        if(tmp.empty()) {\n            while(!stk.empty()){\n                tmp.push(stk.top());\n            stk.pop();\n            }\n        }\n    }\n\n    int pop() {\n        int t;\n        get();\n        t = tmp.top();\n        tmp.pop();\n        return t;\n    }\n    \n    int peek() {\n        get();\n        return tmp.top();\n    }\n    \n    bool empty() {\n        return tmp.empty() && stk.empty();\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090160350","body":"### 思路\n\n思路：将数组先进行拷贝然后排序，用一个键值对记录下当前数字在数组中的正确位置，遍历数组的过程中，找到目前元素的最远正确位置为一组，如果当前元素在正确的位置上，则单独为一组。\n\n### code\n\n```cpp\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) \n    {\n        int n=arr.size();\n        vector<int> temp=arr;\n        sort(temp.begin(),temp.end());\n        unordered_map<int,queue<int>> hashmap;\n        //排序并记录当前元素的正确位置，由于数组中可能有重复元素，因此用一个队列记录元素的位置\n        for(int i=0;i<n;i++)\n        {\n            hashmap[temp[i]].push(i);\n        }\n        int ans=0;\n        int index=0;\n        //遍历原有数组进行分组\n        while(index<n)\n        {\n            int next=hashmap[arr[index]].front();\n            hashmap[arr[index]].pop();\n            if(hashmap[arr[index]].size()==0)\n            {\n                hashmap.erase(arr[index]);\n            }\n            //next表示当前组内的最大下标\n            for(int i=index+1;i<=next;i++)\n            {\n                int curr=hashmap[arr[i]].front();\n                hashmap[arr[i]].pop();\n                if(hashmap[arr[i]].size()==0)\n                {\n                    hashmap.erase(arr[i]);\n                }\n                next=max(next,curr);\n            }\n            ans++;\n            index=next+1;\n        }\n        return ans;\n    }\n};\n\n```\n\n**时间复杂度：** O(N^2)\n\n**空间复杂度：** O(2N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086072595","body":"## 思路\n\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i;\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(0, k % 10);\n        }\n        return list;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(max(num.length(),logK))$\n\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\n\n- 额外空间复杂度: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667405","body":"## 思路(法一)\n\n利用库函数**indexOf(c)**来找到**后一个出现字母的位置**,比较前一个出现和后一个出现的距离,取最小值\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n   public int[] shortestToChar_1(String s, char c) {\n        int[] ans = new int[s.length()];\n        int fir = -1, sec = Integer.MAX_VALUE / 2, cur = 0;\n        fir = s.indexOf(c);\n        for (int i = 0; i < ans.length; i++) {\n            if (fir > i) {\n                ans[i] = fir - i;\n            } else if (fir == i) {\n                ans[i] = 0;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            } else if (i < sec) {\n                ans[i] = Math.min(Math.abs(fir - i), Math.abs(sec - i));\n            } else {\n                ans[i] = 0;\n                fir = sec;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N^2)$\n\n​\t\t\t\t\t\t\t因为String类中indexOf()方法是暴力匹配方法时间复杂度为$O(N*M)$,而我们这里M=1,所以综上总的时间复杂度为$O(N^2)$\n\n- 额外空间复杂度: $O(N)$\n\n## 思路(法二)\n\n对于每个字符 S[i]，通过**顺序遍历和逆序遍历两次**,试图找出距离向左和向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public int[] shortestToChar_2(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        //假设上一个出现的位置为Integer.MIN_VALUE / 2\n        int prev = Integer.MIN_VALUE / 2;\n\n        //记录s[i]与前一个字符c的距离\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        //假设最后一个出现的位置为Integer.MAX_VALUE / 2\n        prev = Integer.MAX_VALUE / 2;\n\n        //计算s[i]与后一个字符c的距离,与原来的距离比较取最小值\n        for (int i = N - 1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N)$\n\n- 额外空间复杂度: $O(N)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885823","body":"## 思路\n\n同样用数组来模拟实现栈,但是对increment()方法进行优化\n\n再用一个辅助数组add来记录increase的值, 利用==差分思想==, 在每次pop()时把add数组和原数组arr==相加输出==\n\n## 语言\n\njava\n\n## 代码\n\n```java\nclass CustomStack_PrefixSum {\n    private int[] arr;\n    private int[] add;\n    private int top;\n\n    public CustomStack_PrefixSum(int maxSize) {\n        arr=new int[maxSize];\n        add=new int[maxSize];\n        top=-1;\n    }\n\n    public void push(int x) {\n        if (top < arr.length-1 ) {\n            arr[++top]=x;\n        }\n    }\n\n    public int pop() {\n        if (top >= 0) {\n            int res=arr[top]+add[top];\n            if (top>=1){\n                add[top-1]+=add[top];\n            }\n            add[top--]=0;\n            return res;\n        }return -1;\n    }\n\n    public void increment(int k, int val) {\n        int end= Math.min(k-1, top);\n        if (end>=0){\n            add[end]+=val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:CustomStack(),push(),pop(), increment()时间复杂度为都为$O(1)$\n- 空间复杂度:$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087732150","body":"## 思路\n\n栈操作\n\n- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n- 如果当前的字符为字母或者左括号，直接进栈\n- 如果当前的字符为右括号，开始出栈,一直到左括号出栈\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic String decodeString(String s) {\n        Stack<Integer> add=new Stack<>();\n        Stack<String> str=new Stack<>();\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i)>=48&&s.charAt(i)<=57){\n                int j=i;\n                while(s.charAt(j+1)>=48&&s.charAt(j+1)<=57){\n                    j++;\n                }\n                int num=Integer.parseInt(s.substring(i,j+1));\n                add.push(num);\n                i=j;\n            }else if(s.charAt(i)==91){\n                int j=i+1;\n                String temp = new String(\"\");\n                while (s.charAt(j)>=97&&s.charAt(j)<=122){\n                    temp+=(s.charAt(j));\n                    j++;\n                }\n                i=j-1;\n                str.push(temp);\n            }else if(s.charAt(i)==93){\n                int time=add.pop();\n                String base=str.pop();\n                StringBuilder builder1 = new StringBuilder();\n                while (time>0){\n                    builder1.append(base);\n                    time--;\n                }\n                if (!str.isEmpty()){\n                    base=str.pop();\n                }\n                else base=\"\";\n                base+=builder1.toString();\n                str.push(base);\n            }else {\n                String t=new String(\"\");\n                if (!str.isEmpty()){\n                    t = str.pop();\n                }\n                t+=s.charAt(i);\n                str.push(t);\n            }\n        }\n        return str.peek();\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度: $O(S)$,S表示解码后字符串长度\n- 空间复杂度:$O(S)$,S表示解码后字符串长度,维护栈,栈的总大小最终与S相同\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088897408","body":"## 思路\n\n使用两个栈,一个栈负责存储新Push()进来的数据,当需要==访问\\弹出队列头==时,把原栈的数据放到另一个栈中,实现==逆序==\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class MyQueue {\n    LinkedList<Integer> stack  ;\n    LinkedList<Integer> queue ;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack = new LinkedList<>();\n        queue = new LinkedList<>();\n    }\n\n    /**\n     * Push element x to the back of queue.\n     * @复杂度分析\n     *      时间复杂度:O(1)\n     *      空间复杂度:O(n)\n     * */\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    /**\n     * Removes the element from in front of queue and returns that element.\n     * @复杂度分析\n     *      时间复杂度:摊还时间复杂度为O(1)\n     *      空间复杂度:O(1)\n     * */\n    public int pop() {\n        if (queue.isEmpty()){\n            while (!stack.isEmpty()){\n                queue.push(stack.poll());\n            }\n        }\n        return queue.pop();\n    }\n\n    /**\n     * Get the front element.\n     * 时间复杂度:\n     *      摊还时间复杂度:O(1)\n     *      空间复杂度:O(1)\n     * */\n    public int peek() {\n        if (queue.isEmpty()){\n            while (!stack.isEmpty()){\n                queue.push(stack.poll());\n            }\n        }\n        return queue.peek();\n    }\n\n    /**\n     * Returns whether the queue is empty.\n     *时间复杂度:\n     *      时间复杂度:O(1)\n     *      空间复杂度:O(1)\n     * */\n    public boolean empty() {\n        if (stack.isEmpty()&&queue.isEmpty()){\n            return true;\n        }return false;\n    }\n}\n\n```\n\n## 复杂度分析\n\n- push()\n    - 时间复杂度:O(1)\n    - 空间复杂度:O(n)\n- pop()\n    - 摊还时间复杂度:O(1)\n    - 空间复杂度:O(1)\n- empty()\n    - 时间复杂度:O(1)\n    - 空间复杂度:O(1)\n- peek()\n    - 摊还时间复杂度:O(1)\n    - 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090432796","body":"## 思路\n\n先对原数组排序,排好序后找到原数组中每个对应位置(p)元素应该在的位置(q),从左往右遍历数组根据(p,q)的区间的包含关系可以不断扩大stk的大小.\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n        Stack<Pair<Integer, Integer>> stk = new Stack<>();\n        int[] sorted ;\n       sorted =arr.clone();\n       BoboNote.DataStructure.Arrays.sort(sorted);\n        int[] indexs = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            int index =Search(sorted, arr[i]);\n            indexs[i]=index;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            int left=Math.min(i,indexs[i]),right=Math.max(i,indexs[i]);\n            if (stk.isEmpty()){\n                stk.push(new Pair<>(left,right));\n            }else{\n                Pair<Integer, Integer> idx = stk.pop();\n                int preL=idx.getKey();\n                int preR=idx.getValue();\n                if (preL <= left && preR >= left && right > preR) {\n                    stk.push(new Pair<>(preL,right));\n                }\n                else if (left>preR){\n                    stk.push(new Pair<>(preL,preR));\n                    stk.push(new Pair<>(left,right));\n                }else {\n                    stk.push(new Pair<>(preL,preR));\n                }\n            }\n        }\n\n        return stk.size();\n    }\n     private int Search(int[] sorted, int a) {\n        int i=0;\n        while (sorted[i++]!=a);\n        sorted[--i]=-1;\n        return i;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(n*logn+n^2)$\n- 空间复杂度:$O(2n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091911830","body":"## 思路\n\n通过遍历找到链表的最后一个元素,并统计出链表的长度大小==size==。利用==（k%size）==的值来判断移动后链表的头节点位置，若（k%size）== 0 直接返回head，否则遍历到应该返回的头结点的前一个结点处，把它的next设置为==null==。\n\n## 语言\n\njava\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n     public ListNode rotateRight(ListNode head, int k) {\n\n        if (k==0||head==null)return head;\n        int size=1;\n        ListNode pre=null,cur=head;\n        while (cur.next!=null){\n            cur=cur.next;\n            size++;\n        }\n        if (k%size==0)return head;\n        cur.next=head;\n        cur=cur.next;\n        \n        int time=size-(k%size);\n        while (time-->0){\n            pre=cur;\n            cur=cur.next;\n        }\n        if (pre!=null){\n            pre.next=null;\n        }\n        return cur;\n    }\n\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(n)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092962166","body":"## 思路\n\n链表操作(穿针引线法)\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        ListNode virHead = new ListNode(0, head);\n        ListNode cur=virHead;\n        while (cur.next!=null&&cur.next.next!=null){\n            ListNode t=cur.next;\n\n            cur.next=cur.next.next;\n            cur=cur.next;\n            t.next=cur.next;\n            cur.next=t;\n            cur=t;\n        }\n        return virHead.next;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(n)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072755","body":"class Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n            return convert(head,null);\r\n    }\r\n    //转换方法\r\n    public TreeNode convert(ListNode left,ListNode right){\r\n            if(left == right){\r\n                return null;\r\n            }\r\n            //得到中间值,然后递归处理两边\r\n            ListNode mid = getMedian(left,right);\r\n            TreeNode root = new TreeNode(mid.val);\r\n            //right为null和mid,left为left和mid.next\r\n            root.left = convert(left,mid);\r\n            root.right = convert(mid.next,right);\r\n            return root;\r\n    }\r\n    //中间值\r\n    public ListNode getMedian(ListNode left,ListNode right){\r\n            ListNode slow = left;\r\n            ListNode fast = left;\r\n            while(fast != right && fast.next != right){\r\n                slow = slow.next;\r\n                fast = fast.next.next;\r\n            }\r\n            return slow;\r\n    }   \r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094298305","body":"## 思路\n\n双指针法\n\n**走到尽头见不到你,于是去走你来时的路,等到相遇时才发现,你也走过我来时的路!**\n\n可以理解成两个人速度一致， 走过的路程一致。==那么肯定会同一个时间点到达终点==。如果到达终点的最后一段路两人都走的话，那么这段路上俩人肯定是肩并肩手牵手的。\n\n该题的关键是让两个不同链表的指针都同步到 ==离链表尾部相同距离的位置==!\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) {\n        return null;\n    }\n    ListNode curA = headA , curB = headB;\n    while (curA != curB) {\n        curA = curA == null ? headB : curA.next;\n        curB = curB == null ? headA : curB.next;\n    }\n    return curA;\n}\n```\n\n## 复杂度分析\n\n- 最差时间复杂度:$O(n+m)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095238936","body":"## 思路\n\n快慢指针法\n\n若链表中存在环那么快慢指针最后一定会在环中的某个位置==重合==\n\n 此时slow指针已经走了==a+b==(a表示环外的步数,b表示入环开始到重合位置的步数);\n\n而对于fast指针此时已经走了==a+n(b+c)+b==(c表示从此时重合位置开始继续向前走到入环点的步数)\n\n这时候因为重合我们可以得到这样的等式:\n$$\na+n(b+c)+b=2(a+b)\n\\rightarrow \na=c+(n-1)(b+c)\n$$\n这时我们发现从相遇点到入环点的距离C加上 ==n-1== 圈的环长，恰好等于从链表头部到入环点的距离。即若此时再额外使用一个指针 $\\textit{ptr}$从链表头出发,随后，它和 $\\textit{slow}$ 每次向后移动一个位置。最终，它们会在入环点相遇。\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head==null)return null;\n       ListNode slow=head,fast=head,reRun=head;\n        do{\n            if (fast.next==null||fast.next.next==null)return null;\n            fast=fast.next.next;\n            slow=slow.next;\n        }while (slow!=fast);\n        while (slow!=reRun){\n            slow=slow.next;\n            reRun= reRun.next;\n        }\n        return reRun;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(N)$ \n    - 在最开始的快慢指针遍历的过程中,slow指针走的次数不会大于链表长度N\n    - 而在后面寻找入环点的过程中,reRun指针走的次数也不会大于链表长度N\n    - 综上$O(N)+O(N)=O(N)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096905627","body":"## 思路\n\n哈希表 + 只定义双向链表\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class LRUCache_custom {\n\n    class DoubleLinkedNode{\n        int val;\n        int key;\n        DoubleLinkedNode prev;\n        DoubleLinkedNode next;\n\n        public DoubleLinkedNode() {\n        }\n\n        public DoubleLinkedNode(int key,int val) {\n            this.key = key;\n            this.val = val;\n            \n        }\n    }\n\n    private int capacity;\n    private int size;\n    private DoubleLinkedNode dummyHead,dummyTail;\n    private HashMap<Integer,DoubleLinkedNode> map;\n\n\n    public LRUCache_custom(int capacity) {\n        this.capacity=capacity;\n        size=1;\n        map=new HashMap<>();\n        dummyHead=new DoubleLinkedNode();\n        dummyTail=new DoubleLinkedNode();\n        dummyHead.next=dummyTail;\n        dummyTail.prev=dummyHead;\n    }\n\n    public int get(int key) {\n        DoubleLinkedNode node = map.get(key);\n        if (node ==null)return -1;\n        moveToHead(node);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        DoubleLinkedNode node = map.get(key);\n        if (node!=null){\n            node.val=value;\n            moveToHead(node);\n        }\n        else {\n            if (size<capacity){\n                size++;\n            }else {\n               DoubleLinkedNode tail=removeTail();\n               map.remove(tail.key);\n               \n            }\n        }\n        DoubleLinkedNode node1 = new DoubleLinkedNode(key, value);\n        map.put(key,node1);\n        addToHead(node1);\n    }\n\n    private DoubleLinkedNode removeTail() {\n        DoubleLinkedNode res = dummyTail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private void moveToHead(DoubleLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    private void removeNode(DoubleLinkedNode node) {\n        node.prev.next=node.next;\n        node.next.prev=node.prev;\n    }\n    private void addToHead(DoubleLinkedNode node) {\n        node.prev=dummyHead;\n        node.next=dummyHead.next;\n        dummyHead.next.prev=node;\n        dummyHead.next=node;\n    }\n}\n\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(1)$ \n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098214522","body":"## 思路\n\n深度优先搜索\n\n*      假设我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为  ==max(l,r)+1==\n\n\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root==null)return 0;\n        int leftH=maxDepth(root.left);\n        int rightH=maxDepth(root.right);\n        return Math.max(leftH,rightH)+1;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(N)$每个节点在递归中只被遍历一次。\n- 空间复杂度:$O(depth)$ 要开与深度一致大小的栈(递归)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099330442","body":"## 思路\n\n两棵树一起同步的深度优先搜索\n\n*      如果当两个结点都为null时返回true\n*      如果有一节点为null,而另一个结点非null时,即两个树出现不同返回false\n*      如果上面条件都不满足,那就比较两个结点的值是否一致,不一致直接返回false\n*      两个结点值相同,则继续深度优先遍历他们的左孩子和右孩子\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p==null&&q==null)return true;\n        if ((p==null&&q!=null)||(p!=null&&q==null))return false;\n        if (p.val!=q.val)return false;\n        if (!isSameTree(p.left,q.left))return false;\n        if (!isSameTree(p.right,q.right))return false;\n        return true;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(min(m,n))$,其中m和n表示两棵树的结点数\n- 空间复杂度:$O(min(m,n))$,其中m和n表示两棵树的结点数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100193134","body":"## 思路\n\n深度优先递归\n\n*      叶结点就是没有子节点。判断的依据就是**root.left == null && root.right == null**，只有到达这个位置，才会结束。\n*      否则继续向下递归, 并且将base变为base*10+root.val;\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic int sumNumbers(TreeNode root) {\n        if (root==null)return 0;\n        return sumNumbers(root,0);\n    }\n    public int sumNumbers(TreeNode root,int base) {\n        if (root.left==null&&root.right==null)return base*10+root.val;\n        int sum=0;\n        if (root.left!=null){\n            sum+=sumNumbers(root.left,base*10+root.val);\n        }\n        if (root.right!=null){\n            sum+=sumNumbers(root.right,base*10+root.val);\n        }\n        return sum;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(N)$,其中N表示结点数\n- 空间复杂度:$O(high)$,high表示树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100695860","body":"## 思路\n\n广度优先递归(层序遍历)\n\n- 利用队列来模拟层序遍历,并记录每一次的第一个结点,该结点即为题目所求.\n\n\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic int findBottomLeftValue(TreeNode root) {\n        if(root==null)return 0;\n        LinkedList<TreeNode> nodeList = new LinkedList<>();\n        nodeList.offer(root);\n        TreeNode ans=null;\n        while (!nodeList.isEmpty()){\n            int size=nodeList.size();\n            ans=nodeList.peekFirst();\n            for (int i = 0; i < size; i++) {\n                TreeNode t=nodeList.poll();\n                if (t.left!=null)nodeList.offer(t.left);\n                if (t.right!=null)nodeList.offer(t.right);\n            }\n        }\n        return ans.val;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(N)$,其中N表示结点数\n- 空间复杂度:$O(2^{high-1})$,high表示树的高度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101516645","body":"## 思路\n\n自定义排序\n\n*      我们可以从根节点开始，对整棵树进行一次遍历，在遍历的过程中使用数组 nodes 记录下每个节点的行号 row，列号 col 以及值 value。在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。\n*      在排序完成后，我们还需要按照题目要求，将同一列的所有节点放入同一个数组中。因此，我们可以对nodes 进行一次遍历，并在遍历的过程中记录上一个节点的列号 lastcol。如果当前遍历到的节点的列号 col 与 lastcol 相等，则将该节点放入与上一个节点相同的数组中，否则放入不同的数组中。\n\n## 语言\n\njava\n\n## 代码\n\n```java\n public List<List<Integer>> verticalTraversal(TreeNode root) {\n        ArrayList<int[]> list = new ArrayList<>();\n        DFS(root,0,0,list);\n        Collections.sort(list, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if (o1[0]!=o2[0]){\n                    return o1[0]-o2[0];\n                }else {\n                    if (o1[1]!=o2[1]){\n                        return o1[1]-o2[1];\n                    }else {\n                        return o1[2]-o2[2];\n                    }\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<>();\n        int size=0;\n        int left=Integer.MIN_VALUE;\n        for (int[] t:list){\n            if (t[0]!=left){\n                left=t[0];\n                ans.add(new ArrayList<>());\n                size++;\n            }\n            ans.get(size-1).add(t[2]);\n        }\n        return ans;\n    }\n\n    private void DFS(TreeNode root, int row, int col, ArrayList<int[]> list) {\n        if (root==null)return;\n        list.add(new int[]{col,row,root.val});\n        DFS(root.left,row+1,col-1,list);\n        DFS(root.right,row+1,col+1,list);\n    }\n```\n\n## 复杂度分析N\n\n- 时间复杂度:$O(NlogN)$,N为节点数\n- 空间复杂度:$O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104102043","body":"## 思路\n\n哈希表+小根堆\n\n*      先记录数组中每个元素出现的次数,存放在一个hashMap中\n*      维护一个小根堆,存放前K个出现多的数\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> hashMap = new HashMap<>();\n        for (int t:nums){\n            hashMap.put(t,hashMap.getOrDefault(t,0)+1);\n        }\n\n        //小根堆\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[1]-o2[1];\n            }\n        });\n\n        Set<Map.Entry<Integer, Integer>> set = hashMap.entrySet();\n        for (Map.Entry<Integer, Integer> t: set){\n            int num=t.getKey(),count=t.getValue();\n            if (queue.size()==k){\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num,count});\n                }\n            }else{\n                queue.offer(new int[]{num,count});\n            }\n        }\n        int[] ans=new int[k];\n        for (int i = 0; i < k; i++) {\n            ans[i]=queue.poll()[0];\n        }\n        return ans;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(N*logK)$,N为数组长度,遍历数组需要$O(N)$的时间复杂度.而且在遍历的过程中还要维护一个小根堆,堆的大小至多为K,所以每次的堆操作需要$O(logK)$的时间,综上共需要$O(NlogK)$\n- 空间复杂度:$O(N)$ ,维护一个至多N个结点的哈希表\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105412007","body":"class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0], y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for (int dist : map.keySet()) {\n                int cnt = map.get(dist);\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106647157","body":"public int lengthOfLongestSubstring(String s) {\n        if (s.isEmpty())return 0;\n        int a=0,b=-1,max=-1,count=0;\n        HashMap<Character,Integer> map = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (map.containsKey(c)){\n                if (b-a+1>max)max=b-a+1;\n                int end = map.get(c);\n                while (a<= end){\n                    map.remove(s.charAt(a++));\n                }\n                map.put(c,i);\n                b=i;\n            }else {\n                map.put(c,i);\n                b++;\n            }\n        }\n        if (b-a+1>max)max=b-a+1;\n        return max;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1108764346","body":"public List<Integer> findSubstring(String s, String[] words) {\n        ArrayList<Integer> ans = new ArrayList<>();\n        HashMap<String, Integer> wordsMap = new HashMap<>();\n        for (String word:words){\n            wordsMap.put(word,wordsMap.getOrDefault(word,0)+1);\n        }\n\n        int len = s.length();\n        int step = words[0].length();\n        int nums = words.length;\n        for (int i = 0; i <= len - step * nums; i++) {\n            HashMap<String,Integer> count = new HashMap<>();\n            boolean flag=true;\n            for (int j = 0; j < nums; j++) {\n                int start = i + j * step;\n                String sub = s.substring(start, start + step);\n                if (!wordsMap.containsKey(sub)){\n                    flag=false;\n                    break;\n                }\n                count.put(sub, count.getOrDefault(sub, 0) + 1);\n                if (count.get(sub)>wordsMap.get(sub)){\n                    flag=false;\n                    break;\n                }\n            }\n            if (flag)ans.add(i);\n        }\n        return ans;\n    }","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108695892","body":" public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109914525","body":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums==null)return 0;\n        int left=-1,last=Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i]!=last){\n                left++;\n                last=nums[i];\n                if (left!=i){\n                    nums[left]=nums[i];\n                }\n            }\n        }\n        return left+1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111174419","body":"public int searchInsert(int[] nums, int target) {\n        int right= nums.length-1,left=0;\n        // if (target>nums[right])return right+1;\n        // else if (target<nums[0])return 0;\n        int mid=0;\n        while (right-1>left){\n            mid=left+((right-left)>>1);\n            if (nums[mid]==target)return mid;\n            else if (nums[mid]<target)left=mid;\n            else right=mid;\n        }\n        return nums[left]==target?left:left+1;\n    }\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113476887","body":" public int findJudge(int n, int[][] trust) {\n        //作为所有村民的集合\n        HashSet<Integer> people = new HashSet<>();\n        //作为可能是法官的人选\n        HashMap<Integer, Integer> judge = new HashMap<>();\n        for (int i = 1; i < n + 1; i++) {\n            people.add(i);\n        }\n        for(int[] arr:trust){\n            people.remove(arr[0]);\n            judge.put(arr[1],judge.getOrDefault(arr[1],0)+1);\n        }\n        if (people.size()!=1)return -1;\n        Integer person = people.iterator().next();\n        return judge.getOrDefault(person,0)==n-1? person :-1;\n    }\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086074254","body":"### Idea\r\nLet carry = k; Add k with each digit of num form right to left, \r\nput units digit into res, update carry \r\nreverse res\r\n\r\n### Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = k;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || carry > 0) {\r\n            if (i >= 0) {\r\n                carry += num[i];\r\n            }\r\n            res.add(carry % 10);\r\n            carry /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### Complexity\r\nTime: O(N)  N refers to the length of num. (reach each element once) \r\nSpace: O(1)  (no extra space except result)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086670553","body":"## Idea\r\nTwo-pass: \r\n1st left to right, find shortest distant to character on left.\r\n2nd right to left, find shortest distant to character on right, and pick shorter one.\r\n\r\n## Code\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int position = -n;\r\n        int[] res = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = i - position;\r\n            System.out.print(res[i]);\r\n        }\r\n        System.out.print(\" \");\r\n        for (int i = position - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = Math.min(res[i], position - i);\r\n            System.out.print(res[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(N)  N refers to the length of string. Traverse string twice\r\nSpace: O(N) extra space for output","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086902125","body":"## Idea\nUse an array to store increment value\nprefix sum: arr[i] means from arr[0] to arr[i], plus arr[i] (val) when poll stack\ne.g. if poll arr[i], res = stack.pollFirst() + arr[i]\nupdate array: arr[i-1] = arr[i-1] + arr[i]\n\n## Code\n```\nclass CustomStack {\n    int n;\n    int[] arr; // arr[i] means from arr[0] to arr[i], plus arr[i] (val) when poll stack\n    Deque<Integer> stack = new ArrayDeque<>();\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n        arr = new int[n];\n    }\n    \n    public void push(int x) {\n        // if the stack hasn't reached the maxSize\n        if (stack.size() < n) { \n            stack.offerFirst(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1; // index of peek item\n        if (i < 0) {\n            return -1;\n        }\n        if (i > 0) { // more than 1 item in stack\n            arr[i-1] += arr[i];\n        }\n        int res = stack.pollFirst() + arr[i]; // add val to poll item\n        arr[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0) { \n            arr[i] += val;\n        }\n    }\n}\n```\n\n## Complexity\nTime: O(N) N = maxSize (initialize array in Java)\nSpace: O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087754257","body":"## Idea\nUse two stack: \nOne intStack to store temp number k until reach to a '['\nOne strStack to store temp string until reach to a ']'\nThe peek item of strStack will record the current temp string, \nand the after-process string is after that\n\n# Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        Deque<StringBuilder> strStack = new ArrayDeque<>();\n        Deque<Integer> intStack = new ArrayDeque<>();\n        \n        int k = 0;\n        strStack.offerFirst(new StringBuilder());\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + c - '0';\n            }\n            else if (c == '[') {\n                strStack.offerFirst(new StringBuilder());\n                intStack.offerFirst(k);\n                k = 0;\n            }\n            else if (c == ']') {\n                String preStr = strStack.pollFirst().toString();\n                int preK = intStack.pollFirst();\n                for (int i = 0; i < preK; i++) {\n                    strStack.peekFirst().append(preStr);\n                }\n            }\n            else {\n                strStack.peekFirst().append(c);\n            }\n        }\n        return strStack.pollFirst().toString();\n    }\n}\n```\n## Complexity\nTime: O(N)  N refers to length of input String\nSpace: O(N) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1090482383","body":"## Idea\nMaintain two stacks (in&out), one handle push operation, another handle pop and peek operation.\nMove all elements form in to out before the pop and peek operation\n\n## Code\n```\nclass MyQueue {\n    Deque<Integer> in;\n    Deque<Integer> out;\n    \n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        in.addFirst(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pollFirst();\n    }\n    \n    public int peek() {\n        if (!out.isEmpty()) {\n            return out.peekFirst();\n        }\n        else {\n            while(!in.isEmpty()) {\n                out.offerFirst(in.pollFirst());\n            }\n            return out.peekFirst();\n        }\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n\n## Complexity\nTime: O(1) amortized O(1) because we do not neet to move items every time\nSpace: O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1093050726","body":"## Idea\nUse two array (pre & after)\npre stores the max element before each arr[i]\nafter stores the min element before each arr[i]\nCompare pre and after, if the pre[i] <= after[i+1] meaning all elements in arr[0, i] are <= all elements in arr[i+1, n-1], which could be split. res++\n\n## Code\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int[] pre = new int[n];\n        int[] after = new int[n];\n        \n        pre[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            pre[i] = Math.max(arr[i], pre[i-1]);\n        }\n        after[n-1] = arr[n-1];\n        for (int i = n - 2; i >= 0; i--) {\n            after[i] = Math.min(arr[i], after[i+1]);\n        }\n        \n        int res = 1;\n        for (int i = 0; i < n-1; i++) {\n            if (pre[i] <= after[i+1]) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)  n refers to the length of arr\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1093277761","body":"## Idea\nCount the number of nodes of list first. Link the head and tail to make a loop.\nCalculate the offset between the head and newHead, cut the loop\n\n## Code\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        \n        int len = 0;\n        ListNode curr = head;\n        while (curr.next != null) {\n            curr = curr.next;\n            len++;\n        }\n        len++; // add last node\n        curr.next = head;\n\n        int offset = len - k % len;\n        curr = head;\n        while (offset > 1) { // stop at new tail\n            curr = curr.next;\n            offset--;\n        }\n        \n        ListNode newHead = curr.next;\n        curr.next = null;\n        return newHead;\n    }\n}\n```\n## Complexity\nTime: O(n)  n refers to length of linklist\nSpace: O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1095734141","body":"## Idea\nRecursion: return the new head of the sub list\nEnd when reach the null node (or edge case)\nNew head should be the node after the original head\nOriginal head.next should be the result of sub question\nLink the newHead and original head\n\n## Code\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode newHead = head.next;\n        head.next = swapPairs(head.next.next);\n        newHead.next = head;\n        \n        return newHead;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094200236","body":"## Idea\nTwo pointer (fast & slow) to find middle node -> root\nUse recursion to build tree;\n\n## Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return helper(head, null);\n    }\n    \n    public TreeNode helper(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        }\n        \n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != tail && fast.next != tail) { // !!\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = helper(head, slow);\n        root.right = helper(slow.next, tail);\n        return root;\n    } \n}\n```\n## Complexity\nTime: O(nlogn)  n for traverse, logn for binary search\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094194811","body":"## Idea\nTwo pointer: a and b pointing to headA and headB\nMove a and b forword with same pace until they are pointing to a same node\nIf one pointer reach to the end of the list, point it to the another head and go ahead.\nThey will reach to the intersection or to the null since they will both move the length of two lists\n\n## Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB== null) {\n            return null;\n        }\n        \n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n## Complexity\nTime: O(m+n)  m and n refers to the length of two lists\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094427757","body":"## Idea\nTwo pointer (slow & fast): traverse the list with different pace to find the meeting point\n(no cycle if fast pointer reach to the tail)\nLet head to first point into cycle be A; first point into cycle to meeting point B; meeting point to first point into cycle be C; Then 2(A+B) = A+B+C+B meaning A=C\nPut slow pointer to the head and traverse the list with same pace. \nWhen two pointer meet again, we got the first point into cycle. \n    \n## Code\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next; // diff pace\n            if (slow == fast) {\n                break; // meeting point\n            }\n        }\n        \n        if (fast == null || fast.next == null) { // if no cycle\n            return null;\n        }\n        \n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next; // same pace\n        }\n        return slow; // since A=C\n    }\n}\n```\n## Complexity\nTime: O(n)  n refers to the length of list\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095438019","body":"## Idea\nUse a double linklist to store nodes in the cache\nUse a map to store key-node pair to support quick access in list\nHelper function: insert and remove to opreate map and list\nUpdate (remove&insert) the position of opreated (get&put) node in list\n\n## Code\n```\nclass LRUCache {\n    Map<Integer, Node> map = new HashMap<>();\n    Node head = new Node(0, 0);\n    Node tail = new Node(0, 0);\n    int cap;\n    \n    public LRUCache(int capacity) {\n        cap = capacity;\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node curr = map.get(key);\n            remove(curr);\n            insert(curr);\n            return curr.val;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            remove(map.get(key));\n            insert(new Node(key, value));\n        }\n        else {\n            if (map.size() == cap) {\n                remove(tail.pre);\n            }\n            insert(new Node(key, value));\n        }\n\n    }\n    \n    public void insert(Node node) {\n        map.put(node.key, node);\n        Node temp = head.next;\n        head.next = node;\n        node.pre = head;\n        node.next = temp;\n        temp.pre = node;\n    }\n    \n    public void remove(Node node) {\n        map.remove(node.key);\n        node.pre.next = node.next;\n        node.next.pre = node.pre;\n    }\n    \n    class Node{\n        int key;\n        int val;\n        Node pre;\n        Node next;\n        public Node(int k, int value) {\n            key = k;\n            val = value;\n        }\n    }\n}\n```\n## Complexity\nTime: O(1)\nSpace: O(n)  n refers to the capacity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097520419","body":"## Idea\nRecursion: The max depth of binary tree is the deeper subtree of it plus 1\n\n## Code \n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        \n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        \n        return Math.max(left, right) + 1;\n    }\n}\n\n## Complexity\nTime: O(n)  n refers to the totla number of nodes of the tree\nSpace: O(height)  height of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098465425","body":"## Idea\nRecursion: compare every nodes of two tree\n\n## Code\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        else if (p == null || q == null) {\n            return false;\n        }\n        else if (p.val != q.val) {\n            return false;\n        }\n        else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    } \n}\n```\n## Complexity\nTime: O(n)  n refers to the total nodes of tree\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099826807","body":"## Idea\ndfs traverse the tree. the sum value to a leaf is the value of the path * 10 + node value\nadd node value when reach to the node\nreturn total when reach to the leaf\ngo to left and right child\n\n## Code\n```\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs (0, root);\n    }\n    \n    public int dfs(int currTotal, TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        \n        currTotal = currTotal * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return currTotal;\n        }\n\n        return dfs(currTotal, root.left) + dfs(currTotal, root.right);\n    }\n}\n```\n## Complexity\nTime: O(n)  reach to every nodes of the tree\nSpace: O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100564977","body":"## Idea\nBFS: record the left most node value before we expend each level\ni.e. peek element of queue\n\n## Code\n```\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if (root == null) {\n            return -1;\n        }\n        \n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int left = 0;\n        while(!q.isEmpty()) {\n            int levelSize = q.size();\n            left = q.peek().val;\n            for(int i = 0; i < levelSize; i++) {\n                TreeNode curr = q.poll();\n                if (curr.left != null) {\n                    q.offer(curr.left);\n                }\n                if (curr.right != null) {\n                    q.offer(curr.right);\n                }\n            }\n        }\n        return left;\n    }\n}\n```\n## Complexity\nTime: O(n)  reach to every node of the tree\nSpace: O(q)  largest size of queue","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100961984","body":"## Idea\nRecursion: Inorder traverse the tree, trate null as #\n\n## Code\n```\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"#\";\n        }\n        return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Queue<String> q = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return helper(q);\n    }\n    \n    public TreeNode helper(Queue<String> q) {\n        String s = q.poll();\n        if (s.equals(\"#\")) {\n            return null;\n        }\n        TreeNode r = new TreeNode(Integer.valueOf(s));\n        r.left = helper(q);\n        r.right = helper(q);\n        return r;\n    }\n}\n```\n## Complexity\nTime: O(n)  reach to each node of tree\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1104203540","body":"## Idea\nBFS: use a priorityQueue instead of queue to make each level sorted by row than by node.val\nPut verticalNode into TreeMap to sort col during BFS\nData structure: Use TreeMap sort col; Use PriorityQueue sort row then sort node.val\nmap holds the result\n\n## Code\n```\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        // sort by row then node.val\n        PriorityQueue<VerticalNode> q  = new PriorityQueue<>((a, b) -> {\n            if (a.row == b.row) {\n                return a.node.val - b.node.val;\n            }\n            else {\n                return a.row - b.row;\n            }\n            }); \n        Map<Integer, List<Integer>>map = new TreeMap<>(); // key is col, sort by col\n        \n        q.offer(new VerticalNode(root, 0, 0));\n        while (!q.isEmpty()) {\n            VerticalNode curr = q.poll();\n            List<Integer> list = map.getOrDefault(curr.col, new ArrayList<>());\n            list.add(curr.node.val);\n            map.put(curr.col, list);\n            \n            if (curr.node.left != null) {\n                q.offer(new VerticalNode(curr.node.left, curr.col-1, curr.row+1));\n            }\n            if (curr.node.right != null) {\n                q.offer(new VerticalNode(curr.node.right, curr.col+1, curr.row+1));\n            }\n        }\n        \n        List<List<Integer>> res = new ArrayList<>();\n        for (List<Integer> values : map.values()) {\n            res.add(values);\n        }\n        return res;\n    }\n    \n    class VerticalNode {\n        TreeNode node;\n        int col;\n        int row;\n        \n        public VerticalNode(TreeNode n, int c, int r) {\n            node = n;\n            col = c;\n            row = r;\n        }\n    }\n}\n```\n## Complexity\nTime: O(nlogn) n times heapify\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102042410","body":"## Idea\nUse map to store the number and its index we reached;\nTraverse the nums, if the map contains (target - current num) meaning there is a number we reached could be the answer with the current number, break the loop\n\n## Code\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        int[] res = new int[2];\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i])) {\n                res[0] = map.get(target - nums[i]);\n                res[1] = i;\n                break;\n            }\n            else {\n                map.put(nums[i], i);\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)  reach to each elements of nums once\nSpace: O(n)  size of map","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103441656","body":"## Idea\nUse Map record the freq of each element\nUse PriorityQueue (min heap) to keep top k frequent elements\n\n## Code\n```\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int n : nums) {\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n        \n        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));\n        for (int n : map.keySet()) {\n            if (minHeap.size() < k) {\n                minHeap.offer(n);\n            }\n            else {\n                if (map.get(n) > map.get(minHeap.peek())){\n                    minHeap.poll();\n                    minHeap.offer(n);\n                }\n            }\n        }\n        \n        int[] res = new int[k];\n        int i = 0;\n        while (!minHeap.isEmpty()) {\n            res[i] = minHeap.poll();\n            i++;\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(nlogk)  size of priorityQueqe is k, n times heapify\nSpace: O(n)  size of map","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105869688","body":"## Idea\nNest for loop to calculate the distance for each pair of points\nUse Map to store the number of same distance in each inner loop\nAggreagate the res from map if multiple same distance occur in each inner loop, then clear the map\n\n## Code\n```\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        \n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) {\n                    continue;\n                }\n                int dist = getDist(points[i], points[j]);\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            \n            for (int v : map.values()) {\n                    res += v * (v - 1);\n            }\n            map.clear();\n        }\n        return res;\n    }\n    public int getDist(int[] a, int[] b) {\n        int x = a[0] - b[0];\n        int y = a[1] - b[1];\n        return x * x + y * y;\n    } \n}\n```\n## Complexity\nTime: O(n^2)\nSpace: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106691882","body":"## Idea\nUse sliding window to record the bound of start and end \nUse set to make sure characters are unique in the window\nIf we find a char already in the set, remove the char at start pointer until that chr is not in set\nbecause we need a substring which is consistent\n\n## Code \n```\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int start = 0;\n        int end = 0;\n        \n        int max = 0;\n        while (end < s.length()) {\n            while (set.contains(s.charAt(end))) {\n                set.remove(s.charAt(start++));\n            }\n            \n            set.add(s.charAt(end++));\n            max = Math.max(max, end - start);\n        }\n        return max;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107735535","body":"## Idea\r\n同余定理+prefix sum\r\n\r\n```\r\nclass Solution {\r\n    public int minSubarray(int[] a, int p)\r\n    {\r\n        int need = 0;\r\n        int n = a.length;\r\n        \r\n        for(var i : a)\r\n            need = (need+i) % p;\r\n        \r\n        if(need == 0)\r\n            return 0;\r\n        \r\n        Map<Integer, Integer> m = new HashMap<>();\r\n        m.put(0, -1);\r\n        \r\n        int prefix = 0, ans = n;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            prefix = (prefix + a[i])%p;\r\n            \r\n            int search = (prefix - need)%p;\r\n            if(search < 0)\r\n                search += p;\r\n            \r\n            if(m.containsKey(search))\r\n            {\r\n                ans = Math.min(ans, i-m.get(search));\r\n            }\r\n            \r\n            m.put(prefix, i);\r\n        }\r\n        \r\n        return ans==n ? -1 : ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108046644","body":"## Idea\nTwo pointer slow & fast\nSlow takes one step and fast takes two step until fast get the end\nIf even number nodes, slow takes extra one step\nSlow pointing to the middle node at the end\n\n## Code\n```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        if (fast.next != null) {\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110471198","body":"## Idea\nBinary search\n## Code\n```\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[mid] > target) {\n                right = mid - 1;\n            }\n            else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n## Complexity\nTime: O(nlogn)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111731667","body":"## Idea\nUse stack is a sliding window\nhead has the largest element, if the incoming element is larger, remove the head\n## Code\n```\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        int[] res = new int[nums.length - k + 1];\n        int ri = 0;\n        \n        for (int i = 0; i < nums.length; i++) {\n            while (!stack.isEmpty() && nums[stack.peekFirst()] < nums[i]) {\n                stack.pollFirst();\n            }\n            stack.offerFirst(i);\n            \n            if (i >= k - 1) {\n                res[ri++] = nums[stack.peekLast()];\n            }\n            \n            if (stack.peekLast() == i - k + 1) {\n                stack.pollLast();\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime:O(n)\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113480405","body":"## Idea\nDirected graph: for [x,y], outdegree of node x -1, indegree of node y +1\nJudge: indegree - outdegree = n - 1 \n## Code\n```\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] countD = new int[n+1];\n        for (int[] t : trust) {\n            countD[t[0]]--;\n            countD[t[1]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (countD[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n## Complity\nTime:O(n)\nSpace:O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113926534","body":"## Idea\nBuild graph, color node, dfs\nUse an array of list to build graph of dislike\nUse map to store color of each node\nSet a node with color 0, then the enemy of it should set to color 1\nDFS set color and check if node has right color\n\n## Code\n```\nclass Solution {\n    List<Integer>[] graph;\n    Map<Integer, Integer> colorMap;\n    \n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        colorMap = new HashMap<>();\n        graph = new ArrayList[n+1];\n        for (int i = 0; i <= n; i++) { // initialize graph\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int[] dk : dislikes) { // build graph\n            graph[dk[0]].add(dk[1]);\n            graph[dk[1]].add(dk[0]);\n        }\n        \n        for (int node = 1; node <= n; node++) {\n            if (!colorMap.containsKey(node)) { // no color\n                boolean possible = dfs(node, 0); // check p\n                if (possible == false) { // check bipartition possible\n                    return false;\n                }\n            }\n            else {\n                continue;\n            }\n        }\n        return true;\n    }\n    \n    public boolean dfs(int node, int c) {\n        if (colorMap.containsKey(node)) { // has color\n            return colorMap.get(node) == c; // check color\n        }\n        \n        colorMap.put(node, c); // color it\n        for (int notFriend : graph[node]) { // traverse its enemy\n            boolean check = dfs(notFriend, c^1); // check enemy\n            if (check == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n## Complexity\nTime:O(V+E)\nSpace:O(V+E)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raingolee":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086081768","body":"### 思路\n从低位开始（从右到左），两个位置的数相加，如果超过10，则增加一个标记位，下一个位置的数字相加之后加一，因为是不等长的，所以存在相同位置的数字为空时候则设置为0，切不需要设置标记位。\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091783926","body":"### 解题思路：\n计算链表的长度，并将尾指针指向头节点形成循环链表，将头指针右移链表长度-k后，再在头指针前一个节点形成断链\n\n### 复杂度\n时间复杂度O(N)\n\n### 实现\n```\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    if(head==NULL||head->next==NULL)\n        return head;\n    //判断链表是否为空或者为一个节点\n    int length=0;\n    //计算链表的长度\n    struct ListNode* rear=head;\n    while(rear->next!=NULL){\n        rear=rear->next;\n        length++;\n    }\n    //使尾指针指向最后一个节点，少算入最后一个节点的长度，因此循环结束后还需要长度加一\n    length++;\n    rear->next=head;\n    //使尾指针指向头节点，形成循环链表\n    k%=length;\n    //%运算，防止k值大于链表长度\n    for(int i=0;i<length-k;i++)\n        head=head->next;\n    //将头指针向右移动链表长度减去右移长度\n    while(rear->next!=head)\n        rear=rear->next;\n        rear->next=NULL;\n    //将尾指针指向头指针前一个节点，并进行断链\n    return head;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"all-sunday":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082274","body":"### 思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n\n### 代码\n\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n- 空间复杂度：O(max(n,k))，开辟了新数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086641183","body":"### 思路\r\n先遍历一次字符串s，获得字符串s种所有c的小标，并存在cIndexs数组；\r\n\r\n双层循环，外层遍历字符串s，内层遍历cIndexs数组，即将字符串s种每一个字字符的小标与所有的字符c小标分别求绝对值，所得值中最小的即为所求目标，存入结果answer数组。\r\n\r\n暂没有其他思路，就暴力求解了。😥\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] answer = new int[n];\r\n        int[] cIndexs = new int[n];\r\n        int cNum = 0;\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                cIndexs[cNum++] = i;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            int minDistance = n;\r\n            for(int j = 0; j < cNum; j++){\r\n                int distance = Math.abs(i - cIndexs[j]);\r\n                if(distance < minDistance){\r\n                    minDistance = distance;\r\n                }\r\n            }\r\n            answer[i] = minDistance;\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，双重循环，其中N为字符串s的长度。\r\n- 空间复杂度：O(N)，使用了额外的大小为字符串长度N的数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086893650","body":"### 思路\n用数组模拟栈的操作，top记录栈顶的位置。\n### 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < stack.length - 1){\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top > -1){\n            int res = stack[top];\n            stack[top--] = 0;\n            return res;\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if(top < k - 1){\n            k = top + 1;\n        }\n        for(int i = 0; i < k; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：初始化、push、pop操作均为O(1)，inc操作为O(k)。\n- 空间复杂度：O(maxSize)，使用了额外长度为maxSize的数组stack。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087733546","body":"### 思路\r\n每个左括号对应一个子问题，通过递归调用函数解决；\r\n\r\n遇到'['，则递归调用，返回得到的字符串和当前处理到的下标，根据数字mutil得到新的res，并根据返回的下标i继续解析剩余字符串。\r\n### 代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n\r\n    private String[] dfs(String s, int i){\r\n        StringBuilder res = new StringBuilder();\r\n        int mutil = 0;\r\n        while(i < s.length()){\r\n            char c = s.charAt(i);\r\n            if(c >= '0' && c <= '9'){\r\n                mutil = mutil * 10 + Integer.parseInt(String.valueOf(c));\r\n            }else if(c == '['){\r\n                String[] temp = dfs(s, i + 1);\r\n                i = Integer.parseInt(temp[0]);\r\n                while(mutil > 0){\r\n                    res.append(temp[1]);\r\n                    mutil--;\r\n                }\r\n            }else if(c == ']'){\r\n                return new String[] {String.valueOf(i), res.toString()};\r\n            }else{\r\n                res.append(String.valueOf(c));\r\n            }\r\n            i++;\r\n        }\r\n        return new String[] {res.toString()};\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，实际上还是遍历。\r\n- 空间复杂度：O(N)，极端情况下，递归深度达到N。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088939342","body":"### 思路\n双栈，输入栈专门用于输入；\n\n输出栈用于pop和peek操作，如果输出栈为空，则将输入栈的元素全部压入输出栈，此时输出栈的输出顺序即为队列顺序；\n\n输入、输出栈均为空，则队列为空。\n### 代码\n```\nclass MyQueue {\n    private Stack<Integer> in;//输入栈\n    private Stack<Integer> out;//输出栈\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n       if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }\n       return out.pop(); \n    }\n    \n    public int peek() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)。\n- 空间复杂度：O(N)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090435914","body":"### 思路\n没得思路，我没看懂😥，下面是官方题解。\n### 代码\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中N为arr的长度。\n- 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091915351","body":"### 思路\n计算出链表的长度n，并找到链表的尾节点，将其与头节点相连，得到闭合为环的链表；\n\n然后我们找到新链表的最后一个节点，将当前闭合为环的链表断开，即得结果。\n### 代码\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，遍历链表。\n- 空间复杂度：O(1)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093035590","body":"### 思路\n遍历链表，每次借助temp节点交换两个节点，没有节点或只有一个节点。\n### 代码\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode res = new ListNode();\n        res.next = head;\n        ListNode temp = res;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return res.next;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，遍历一次链表。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072173","body":"### 思路\n没得思路，看的官方题解😢。\n### 代码\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)。\n- 空间复杂度：O(logn)，平衡二叉树的高度为O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095231957","body":"### 思路\n遍历链表，通过哈希表记录遍历过的节点，如果节点再哈希表中已存在，则有环且该节点即为答案，否则无环。\n### 代码\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode node = head;\n        Set<ListNode> set = new HashSet<>();\n\n        while(node != null){\n            if(set.contains(node)){\n                return node;\n            }else{\n                set.add(node);\n            }\n            node = node.next;\n        }\n        return null;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，遍历链表。\n- 空间复杂度：O(n)，创建了哈希表。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098196888","body":"### 思路\ndfs，节点为空说明当前节点高度为0，否则分别求左右子树的高度的最大值，再加1即为当前节点高度。\n### 代码\n```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        int leftHeight = maxDepth(root.left);\n        int rightHeight = maxDepth(root.right);\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，遍历每一个节点。\n- 空间复杂度：O(n)，递归深度为树的高度，最大为n。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099330967","body":"### 思路\n如果两个二叉树相同，那么根节点的值相同，且左右子树也相同，可以通过dfs，递归地判断。\n### 代码\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }else if(p == null || q == null){\n            return false;\n        }else if(p.val != q.val){\n            return false;\n        }else{\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(min(m,n))，m和n分别是两个二叉树的节点数。\n- 空间复杂度：O(min(m,n))。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100140338","body":"### 思路\n每个节点对应的数字等于其父节点对应数字乘以10再加上当前节点的数字，dfs遍历每一个节点，直至节点为null则返回。\n### 代码\n```\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int num){\n        if(root == null) return 0;\n        int temp = num * 10 + root.val;\n        if(root.left == null && root.right == null){\n            return temp;\n        }else{\n            return dfs(root.left, temp) + dfs(root.right, temp);\n        }\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，遍历每一个节点。\n- 空间复杂度：O(n)，递归深度为树的高度，最大为n。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100905443","body":"### 思路\n属实不会，搬运官方题解😥。\n### 代码\n```\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)。\n- 空间复杂度：O(n)。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102742532","body":"### 思路\n遍历数组元素nums[i]，如果哈希表中不存在target - nums[i]，则将当前元素插入哈希表，直到匹配到才返回。\n### 代码\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if (hashtable.containsKey(target - nums[i])){\n                return new int[]{i, hashtable.get(target - nums[i])};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int [0];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，遍历一次数组。\n- 空间复杂度：O(n)，哈希表的开销。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104100146","body":"### 思路\n先遍历数组，用哈希表记录每个数字出现的次数；\n\n建立小根堆，遍历哈希表，如果堆的元素个数小于k，则直接插入堆中；\n\n如果堆的元素个数等于k，则比较堆顶与当前出现次数的大小，如果当前的更大，则弹出堆顶，将其插入堆中，否则继续遍历；\n\n遍历结束，堆中元素即为所求目标。\n### 代码\n```\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        \n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogk)，遍历数组建立哈希表是O(n)，遍历哈希表进行小根堆的维护是O(nlogk)。\n- 空间复杂度：O(n)，哈希表大小O(n)，小根堆O(k)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105289129","body":"### 思路\n先遍历数组，统计所有点到points[i]的距离；\n\n将每个距离出现的次数记录在哈希表中；\n\n遍历哈希表，累加排列组合数。\n### 代码\n```\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int[] p : points){\n            for(int [] q : points){\n                int distance = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n\n            for(int value : map.values()){\n                res += value * (value - 1);\n            }\n            \n            map.clear();\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n^2)，双重循环。\n- 空间复杂度：O(n)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106652181","body":"### 思路\n滑动窗口：遍历字符串，根据是否出现重复，不停移动窗口，并更新最大长度maxLen。\n### 代码\n```\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s.length() == 0) return 0;\n        HashMap<Character, Integer> map = new HashMap<>();\n        int maxLen = 0;\n        int left = 0;\n        for(int i = 0; i < s.length(); i++){\n            if(map.containsKey(s.charAt(i))){\n                left = Math.max(left, map.get(s.charAt(i)) + 1);\n            }\n            map.put(s.charAt(i), i);\n            maxLen = Math.max(maxLen, i - left + 1);\n        }\n        return maxLen;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)。\n- 空间复杂度：O(n)。\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108731198","body":"### 思路\n快慢指针：slow指针一次走一个节点，fast指针一次走两个节点，当fast指针到达链表末尾时，slow指针正好位于中间。\n### 代码\n```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109961219","body":"### 思路\n双指针：数组是有序的，那么重复的元素一定会相邻，删除重复元素，实际上就是将不重复的元素移到数组的左侧；\n\nfast指针遍历数组，如果nums[fast] != nums[fast - 1]，则nums[fast]和之前的元素都不同，则将nums[fast]的值复制到nums[slow]，slow值加1，重复操作直至fast遍历完数组。\n### 代码\n```\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        if (n == 0) {\n            return 0;\n        }\n        int fast = 1, slow = 1;\n        while (fast < n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111140053","body":"### 思路\n二分查找：数组是有序的，通过left和right下标计算中间下标mid；\n\n根据nums[mid]和target比较大小，相等则直接返回mid，nums[mid]<target，则left右移，nums[mid]>target则right左移；\n\n查找结束如果没有相等值，则返回 left，该值为插入位置。\n### 代码\n```\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while(left <= right){\n            int mid = (left + right) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(nums[mid] < target){\n                left = mid + 1;\n            }else{\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(logn)。\n- 空间复杂度：O(1)。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113408869","body":"### 思路\n运用图，定义两个数组，记录入度和出度，入度为n-1且出度为0的点就是要寻找的点。\n### 代码\n```\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegress = new int[n + 1];\n        int[] outDegress = new int[n + 1];\n        for(int[] edge : trust){\n            int x = edge[0], y = edge[1];\n            inDegress[y]++;\n            outDegress[x]++;\n        }\n        for(int i = 1; i <= n; i++){\n            if(inDegress[i] == n - 1 && outDegress[i] == 0){\n                return i;\n            } \n        }\n        return -1;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n+m)，m是trust的长度，要先遍历一次trust，再遍历一次inDegrees和outDegress。\n- 空间复杂度：O(n)。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082862","body":"public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663613","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092993516","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n      ListNode dummpyHead=new ListNode(0);\n      dummpyHead.next=head;\n      ListNode temp=dummpyHead;\n      while(temp.next!=null&&temp.next.next!=null){\n        ListNode node1=temp.next;\n        ListNode node2=temp.next.next;\n          node1.next=node2.next;\n          node2.next=node1;\n          temp.next=node2;\n          temp=node1;\n      }\n      return dummpyHead.next;\n     \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107356751","body":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        HashMap<String,Integer> map = new HashMap<>();\n        int n = s.length();\n        int sl = words[0].length();\n        List<Integer> res = new ArrayList<>();\n\n        if (n < sl){\n            return new ArrayList<>();\n        }\n\n        for (String str : words) {\n            map.put(str,map.getOrDefault(str,0)+1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            int x = i;\n            if (i + sl * words.length > n)\n                break;\n            String str = s.substring(x,x+sl);\n            HashMap<String,Integer> tmp = new HashMap<>(map);\n            \n            while (!tmp.isEmpty() && tmp.containsKey(str)) {\n                x = x + sl;\n                tmp.put(str,tmp.get(str) - 1);\n                if (tmp.get(str) == 0){\n                    tmp.remove(str);\n                }\n                if (x + sl > n) {\n                    break;\n                }\n                str = s.substring(x,x+sl);\n            }\n            \n            if (tmp.isEmpty()){\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086083587","body":"## 思路\n\n- 直接把k加到A中\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int i = A.size()-1;\n        while(K > 0){\n            A[i] += K;\n            K = A[i] / 10;\n            A[i--] %= 10;\n            \n            if(i < 0 && K > 0){\n                A.insert(A.begin(),0);\n                i = 0;\n            }\n        }\n        \n        return A;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hulichao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086084672","body":"思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n复杂度分析\n\n时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n空间复杂度：O(max(n,k))，开辟了新数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667513","body":"### 思路\n关键点在于加一个变量，用来指出距离当前遍历到的字符的最左的目标字符的下标，和距离当前遍历到的字符的最右的目标字符的下标。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int[] ans = new int[S.length()];\n        int pre = -100001;\n        //从左到右\n        for (int i = 0; i < S.length(); i++) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = i - pre;\n        }\n\n        pre = 100001;\n        for (int i = S.length() - 1; i >=0 ; i--) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = Math.min(ans[i], pre -i);\n        }\n\n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896250","body":"### 思路\n用个数组模拟栈就好了。\n\n### 代码\n\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087681468","body":"### 思路\n使用两个栈 分别用来记录 数字 和 其他所有字符\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        // 使用两个栈 分别用来记录 数字 和 其他所有字符\n        Stack<Integer> stack_num = new Stack<>();\n        Stack<String> stack_string = new Stack<>();\n\n        char[] chars = s.toCharArray();\n        for(char ch: chars){\n            // 如遇到数字 进入数字栈\n            if (Character.isDigit(ch))\n                stack_num.push(ch - '0');\n\n            // 如遇到字母 进入其他栈\n            else if (Character.isAlphabetic(ch))\n                stack_string.push(String.valueOf(ch));\n\n            // 如遇到 [ 进入其他栈 并在数字栈做标记\n            else if (ch == '['){\n                stack_num.push(-1);\n                stack_string.push(String.valueOf(\"[\"));\n            }\n\n            // 遇到 ] 开始出栈进行拼接 后入栈\n            else{\n\n                // 新建一个 StringBuilder 来记录一次解码\n                StringBuilder tmp = new StringBuilder();\n\n                // 当栈不为空且 没有到本次解码的头 即 左括弧 [ 时 在 tmp 前面插入该字符（串）保证顺序\n                while (!stack_string.isEmpty() && !\"[\".equals(stack_string.peek()))\n                    tmp.insert(0, stack_string.pop());\n\n                // 遇到左括弧 弹出一次\n                stack_string.pop();\n\n                // 同时弹出数字栈的 标记 -1\n                stack_num.pop();\n\n                // cnt 用于计数括弧前的数字来判断括弧里面的字符串重复几次\n                int cnt = 0;\n                StringBuilder cntString = new StringBuilder();\n\n                // 求出重复次数\n                while (!stack_num.isEmpty() && -1 != stack_num.peek())\n                    cntString.insert(0, stack_num.pop());\n                cnt = Integer.parseInt(cntString.toString());\n\n                // 根据 cnt 次数来重复字符串\n                StringBuilder pushBack = new StringBuilder();\n                while(cnt-- > 0)\n                    pushBack.append(tmp);\n\n                // 重复以后再压入栈\n                stack_string.push(pushBack.toString());\n            }\n        }\n\n        // 当字符串遍历结束以后再用插入的方式汇总\n        StringBuilder sb = new StringBuilder();\n        while(!stack_string.isEmpty())\n            sb.insert(0, stack_string.pop());\n        return sb.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089055356","body":"\n  ### 思路\n模拟一下就可以了\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> a;// 输入栈\n    private Stack<Integer> b;// 输出栈\n    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n        // 如果b栈为空，则将a栈全部弹出并压入b栈中，然后b.pop()\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091909931","body":"### 思路\n先遍历求得链表总长度count，同时将链表首尾相连；\n再找到原链表的倒数第k+1个节点，该节点的next就是新链表的头结点。\n\n### 代码\n\n\n```java\n\npublic ListNode rotateRight(ListNode head, int k) {\n\tif (head == null || head.next == null || k == 0) return head;\n    \n    int count = 1; // 用来统计链表总结点数\n    ListNode tmp = head;\n    while (tmp.next != null) {\n        count++;\n        tmp = tmp.next;\n    }\n    k %= count;\n    // 当k为0时，不需要旋转，\n    if (k == 0) return head;\n    \n    // 不满足上述条件，必将进行旋转，所以先将首尾相连\n    tmp.next = head;\n    // 现在只需要找到倒数第k+1个节点\n    for (int i = 0; i < count - k; i++) {\n        tmp = tmp.next;\n    }\n    ListNode newHead = tmp.next;\n    tmp.next = null;\n    return newHead; \n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086085454","body":"## 思路\r\n将A、K格式化为数组，反转，从低位开始相加，一直到最高位，注意处理进位\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const numArr = num.reverse();\r\n    const kArr = String(k).split('').reverse().map(Number);\r\n\r\n    let result = [];\r\n    let i = 0;\r\n    let curr = 0;\r\n    let carry = 0;\r\n    while(i < numArr.length || i < kArr.length || carry > 0) {\r\n        sum = (numArr[i] || 0) + (kArr[i] || 0) + carry;\r\n        curr = sum % 10;\r\n        carry = parseInt(sum / 10);\r\n        result[i] = curr;\r\n        i++;\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661461","body":"## 思路\n1. 遍历字符串，找出所有c的索引，成为索引数组\n2. 遍历字符串，每个字符串遍历索引数组求绝对值，取最小\n\n## code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    // 转换为数组\n    // 遍历找出所有c的索引\n    // 遍历数组，比较距离，取最小值\n    const strArray = s.split('');\n    let cIndexArray = [];\n\n    strArray.forEach((s, i) => {\n        if (s === c) {\n            cIndexArray.push(i);\n        }\n    })\n    let result = [];\n    strArray.forEach((s, i) => {\n        let diff = Infinity;\n        cIndexArray.forEach((cIndex) => {\n            diff = Math.min(diff, Math.abs(cIndex - i));\n        })\n\n        result.push(diff);\n    })\n\n    return result;\n};\n\n## 复杂度\n\n- 时间复杂度：O(n2)\n- 空间复杂度：O(n)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086101381","body":"var addToArrayForm = function (num, k) {\r\n    let k_array = [];\r\n    let length_cal = 0;\r\n    let cal_array = [];\r\n    while (k > 0) {\r\n        let yu = k % 10;\r\n        k_array.unshift(yu);\r\n        k = (k - yu) / 10;\r\n    }\r\n\r\n    if (k_array.length < num.length) {\r\n        length_cal = num.length;\r\n        const len = k_array.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            k_array.unshift(0);\r\n        }\r\n    } else {\r\n        length_cal = k_array.length;\r\n        const len = num.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            num.unshift(0);\r\n        }\r\n    }\r\n\r\n    for (let index = 0; index < length_cal; index++) {\r\n        const m = num.pop();\r\n        const n = k_array.pop();\r\n        if (m + n >= 10) {\r\n            cal_array.unshift((m + n) % 10);\r\n            k_array[k_array.length - 1] = k_array[k_array.length - 1] + 1;\r\n            if (index === length_cal - 1) {\r\n                cal_array.unshift(1);\r\n            }\r\n        } else {\r\n            cal_array.unshift(m + n)\r\n        }\r\n    }\r\n\r\n    return cal_array;\r\n};\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639124","body":"\n\n```JavaScript\nvar shortestToChar = function (s, c) {\n    let arr = s.split('');\n    for (let iterator in arr) {\n        if (arr[iterator] == c) {\n            arr[iterator] = 0\n        } else {\n            arr[iterator] = null;\n        }\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[j] === i) {\n                if (j > 0) {\n                    if (arr[j - 1] == null || arr[j - 1] > i + 1) {\n                        arr[j - 1] = i + 1;\n                    }\n                }\n                if (j < arr.length - 1) {\n                    if (arr[j + 1] == null || arr[j + 1] > i + 1) {\n                        arr[j + 1] = i + 1;\n                    }\n                }\n            }\n        }\n    }\n    return arr;\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(N^2)\n\\- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896296","body":"\n\n```JavaScript\nvar CustomStack = function (maxSize) {\n\n    this.stack = [];\n    this.maxSize = maxSize;\n\n    //for loop create array, value default null, size = maxSize\n    for (let index = 0; index < maxSize; index++) {\n        this.stack[index] = null;\n    }\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n\n    // stack's last one is not null, do not push\n    if (this.stack[this.maxSize - 1] !== null) {\n        return;\n    }\n\n    // for loop find the first index is null, push parameter at index\n    const indexCanPush = this.stack.findIndex(element => element === null);\n    this.stack[indexCanPush] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    // find the first one (called lastOne) is not null from the tail of stack\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    // the index value of lastOne set to null, return last one\n    if (lastOne !== -1) {\n        this.stack[lastOneIndex] = null\n    }\n\n    return lastOne;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n\n    // from tail to head, find the first one is not null\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    for (let index = lastOneIndex; index >= 0 && k > 0; index--, k--) {\n        this.stack[lastOneIndex] += val;\n    }\n};\n\nCustomStack.prototype.lastOne = function () {\n\n    // from tail to head, find the first one is not null\n    let lastOne = -1;\n    let lastOneIndex = -1;\n    for (let tail = this.maxSize - 1; tail >= 0; tail--) {\n        if (this.stack[tail] !== null) {\n            lastOne = this.stack[tail];\n            lastOneIndex = tail;\n            return { lastOne, lastOneIndex };\n        }\n    }\n\n    return { lastOne, lastOneIndex };\n\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087640793","body":"```javascript\nvar decodeString = function(s) {\n\n    let numStack = []; \n    let strStack = []; \n    let temp = ''; \n    let num = 0; \n    for(let i = 0; i < s.length; i++) { \n        const c = s[i];\n        if(/\\d/.test(c)) { \n            num = num * 10 + (c.charCodeAt() - '0'.charCodeAt()); \n        } else if(c === '[') {\n            strStack.push(temp); \n            numStack.push(num); \n            num = 0;\n            temp = '';\n        } else if(c ===']') { \n            let repeatTimes = numStack.pop();\n            temp = strStack.pop() + temp.repeat(repeatTimes); \n        } else {\n            temp += c; \n        }\n    }\n\n    return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088540596","body":"```javascript\nclass MyQueue {\n    stack: number[] = [];\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        const top = this.stack[0];\n        // this.stack.splice(0, 1);\n        for (let index = 1; index < this.stack.length; index++) {\n            this.stack[index - 1] = this.stack[index];\n        }\n        this.stack.pop();\n        return top;\n    }\n\n    peek(): number {\n        return this.stack[0]\n    }\n\n    empty(): boolean {\n        if (this.stack.length <= 0) {\n            return true;\n        }\n        return false;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090432330","body":"```javascript\nfunction maxChunksToSorted(arr: number[]): number {\n\n    let stack: number[] = [];\n\n    let headOutCount: number = 1;\n\n    stack.push(arr[0]);\n\n    for (let index = 1; index < arr.length; index++) {\n\n        if (stack[stack.length - 1] > arr[index]) {\n\n            stack.push(arr[index]);\n\n        } else if (stack[stack.length - 1] < arr[index]) {\n\n            while (stack[stack.length - 1] < arr[index]) {\n                stack.pop();\n            }\n\n            /*if (stack.length === 0) {\n                headOutCount++;\n            }*/\n\n        } else if (stack[0] === arr[index] && index === arr.length - 1) {\n            stack.pop();\n            headOutCount++;\n        }\n\n        if (stack.length === 0) {\n            stack.push(arr[index]);\n            headOutCount++;\n        }\n    }\n    return headOutCount;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091869146","body":"```javascript\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n    let len: number = 0;\n    let point: ListNode = head;\n    let newHead: ListNode = head;\n    let newTail: ListNode;\n    let tail: ListNode;\n    const realK = k % len;\n\n    if (head === null || realK === 0) {\n        return head;\n    }\n\n    while (point) {\n        len++;\n        point = point.next;\n    }\n\n    for (let index = 0; index < len - realK; index++) {\n\n        newTail = newHead;\n        newHead = newHead.next;\n\n    }\n\n    tail = newHead;\n    while (tail.next) {\n        tail = tail.next;\n    }\n\n    newTail.next = null;\n    tail.next = head;\n\n    return newHead;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092987111","body":"```typescript\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n    if (head === null || head.next === null) {\n        return head;\n    }\n\n    let point: ListNode = head;\n    let newHead: ListNode = point.next;\n    point.next = newHead.next;\n    newHead.next = point;\n\n    let pre: ListNode = point;\n    point = pre.next;\n\n    let len: number = 1;\n    head = newHead;\n    while (head.next) {\n        head = head.next;\n        len++;\n    }\n\n    let odd: boolean = len % 2 === 0 ? false : true;\n    let loopCount: number = odd ? Math.floor(len / 2) - 1 : Math.floor(len / 2) - 2;\n\n    while (loopCount > 0) {\n        pre.next = point.next;\n        point.next = point.next.next;\n        pre.next.next = point;\n\n        pre = point;\n        point = pre.next;\n        loopCount--;\n    }\n\n    if (!odd && point !== null) {\n        pre.next = point.next;\n        pre.next.next = point;\n        point.next = null;\n    }\n\n    return newHead;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094062508","body":"```javascript\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    let tree_root: TreeNode = new TreeNode();\n    let data_arr = [];\n\n    if (head === null) {\n        return null;\n    }\n\n    while (head !== null) {\n        data_arr.push(head.val);\n        head = head.next;\n    }\n\n    convertBST(data_arr, tree_root, 0, data_arr.length);\n    return tree_root;\n\n};\n\nfunction convertBST(arr_tree: number[], root: TreeNode, start_position: number, convert_length: number) {\n    let left_length: number;\n    let right_length: number;\n    let tree_left: TreeNode = new TreeNode();\n    let tree_right: TreeNode = new TreeNode();\n    root.left = null;\n    root.right = null;\n\n    root.val = arr_tree[start_position + Math.floor(convert_length / 2)];\n    left_length = Math.floor(convert_length / 2);\n    right_length = convert_length - left_length - 1;\n    if (left_length > 0) {\n        root.left = tree_left;\n        convertBST(arr_tree, root.left, start_position, left_length);\n    }\n    if (right_length > 0) {\n        root.right = tree_right;\n        convertBST(arr_tree, root.right, start_position + left_length + 1, right_length);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094288621","body":"```typescript\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n\n    if (!headA || !headB) {\n        return null;\n    }\n\n    let len_a: number = 0;\n    let len_b: number = 0;\n    let point_a: ListNode | null = headA;\n    let point_b: ListNode | null = headB;\n    let cutLen: number = 0;\n\n    while (point_a) {\n        len_a++;\n        point_a = point_a.next;\n    }\n    while (point_b) {\n        len_b++;\n        point_b = point_b.next;\n    }\n\n    point_a = headA;\n    point_b = headB;\n\n    cutLen = Math.abs(len_a - len_b);\n    if (cutLen > 0) {\n        if (len_a > len_b) {\n            while (cutLen > 0) {\n                point_a = point_a!.next;\n                cutLen--;\n            }\n        }\n\n        if (len_a < len_b) {\n            while (cutLen > 0) {\n                point_b = point_b!.next;\n                cutLen--;\n            }\n        }\n    }\n\n    for (let index = 0; index < Math.min(len_a, len_b); index++) {\n        if (point_a !== point_b) {\n            point_a = point_a!.next;\n            point_b = point_b!.next;\n        } else {\n            return point_a;\n        }\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095152566","body":"```javascript\nfunction detectCycle(head: ListNode | null): ListNode | null {\n\n    let cycleMap = new Map();\n    let point: ListNode | null = head;\n\n    while (point) {\n        if (!cycleMap.has(point)) {\n            cycleMap.set(point, 1);\n        } else {\n            return point;\n        }\n        point = point.next;\n    }\n    return null;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098268037","body":"```typescript\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n\n    const stack_p: TreeNode[] = [];\n    const stack_q: TreeNode[] = [];\n    if (p) {\n        stack_p.push(p);\n    }\n    if (q) {\n        stack_q.push(q);\n    }\n\n    while (stack_p.length > 0 && stack_q.length > 0) {\n        const top_p: TreeNode = stack_p.pop()!;\n        const top_q: TreeNode = stack_q.pop()!;\n        if (top_p.val !== top_q.val) {\n            return false;\n        }\n        if (top_p.right && top_q.right) {\n            stack_p.push(top_p.right);\n            stack_q.push(top_q.right);\n        } else if ((!top_p.right && top_q.right)\n            || (top_p.right && !top_q.right)) {\n            return false;\n        }\n        if (top_p.left && top_q.left) {\n            stack_p.push(top_p.left);\n            stack_q.push(top_q.left);\n        } else if ((!top_p.left && top_q.left)\n            || (top_p.left && !top_q.left)) {\n            return false;\n        }\n    }\n\n    if (stack_p.length === 0 && stack_q.length == 0) {\n        return true;\n    } else {\n        return false;\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100173365","body":"```typescript\nfunction sumNumbers(root: TreeNode | null): number {\n    let sumValue: number;\n    sumValue = 0;\n    if (root === null) {\n        sumValue = 0;\n    } else if (root.left === null && root.right === null) {\n        sumValue = root.val;\n    } else if (root.left === null && root.right !== null) {\n        sumValue = addNodeValue(root.right, root.val);\n    } else if (root.right === null && root.left !== null) {\n        sumValue = addNodeValue(root.left, root.val);\n    } else if (root.right !== null && root.left !== null) {\n        sumValue = addNodeValue(root.left, root.val) + addNodeValue(root.right, root.val);\n    }\n    return sumValue;\n};\n\nfunction addNodeValue(root: TreeNode, rootvalue: number): number {\n    let addValue: number;\n    addValue = 0;\n    if (root.left === null && root.right === null) {\n        addValue = root.val + rootvalue * 10;\n    } else if (root.left === null && root.right !== null) {\n        addValue = addNodeValue(root.right, root.val + rootvalue * 10);\n    } else if (root.right === null && root.left !== null) {\n        addValue = addNodeValue(root.left, root.val + rootvalue * 10);\n    } else if (root.right !== null && root.left !== null) {\n        addValue = addNodeValue(root.left, root.val + rootvalue * 10) + addNodeValue(root.right, root.val + rootvalue * 10);\n    }\n    return addValue;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100666909","body":"```typescript\nfunction findBottomLeftValue(root: TreeNode | null): number {\n\n    let queue: TreeNode[] = [];\n    let current_level: TreeNode[] = [];\n\n    if (root) {\n        queue.push(root);\n    }\n\n    while (queue.length > 0) {\n\n        current_level = queue;\n        queue = [];\n\n        for (let index = 0; index < current_level.length; index++) {\n            const element: TreeNode = current_level[index];\n            if (element.left) {\n                queue.push(element.left);\n            }\n            if (element.right) {\n                queue.push(element.right);\n            }\n        }\n\n    }\n\n    return current_level[0]!.val;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100905717","body":"```typescript\nfunction serialize(root: TreeNode | null): string {\n\n    let queue: any[] = [];\n    let result: any[] = [];\n\n    if (root) {\n        queue.push(root);\n    }\n\n    while (queue.length) {\n\n        const current_level: any[] = queue;\n        queue = [];\n\n        for (let index = 0; index < current_level.length; index++) {\n            const element: TreeNode | null = current_level[index];\n            if (element === null) {\n                result.push(null);\n                queue.push(null);\n                queue.push(null);\n                continue;\n            } else {\n                result.push(element.val);\n                queue.push(element.left);\n                queue.push(element.right);\n            }\n        }\n\n        if (queue.every(ele => ele === null)) {\n            break;\n        }\n\n    }\n\n    return result.join(',');\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n\n    let arr = data.split(',');\n    let rootNode: TreeNode;\n\n    if (arr.length === 0) {\n        return null;\n    }\n\n    //let level: number = Math.log2(arr.length + 1);\n    rootNode = new TreeNode(Number(arr[0]));\n    deserialize_sub(rootNode, arr, 0);\n\n};\n\nfunction deserialize_sub(node: TreeNode, arr: any[], index: number) {\n    let left_index = index * 2 + 1;\n    let right_index = index * 2 + 2;\n    if (arr[left_index]) {\n        let left_node: TreeNode = new TreeNode(arr[left_index]);\n        node.left = left_node;\n        deserialize_sub(left_node, arr, left_index);\n    } else {\n        node.left = null;\n    }\n    if (arr[right_index]) {\n        let right_node: TreeNode = new TreeNode(arr[right_index]);\n        node.right = right_node;\n        deserialize_sub(right_node, arr, right_index);\n    } else {\n        node.right = null;\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102789436","body":"```typescript\nfunction twoSum(nums: number[], target: number): number[] {\n\n    let hash_of_nums = new Map();\n\n    for (let index = 0; index < nums.length; index++) {\n\n        const element = nums[index];\n\n        if (!hash_of_nums.has(element)) {\n            hash_of_nums.set(target - element, index);\n        } else {\n            return [hash_of_nums.get(element), index];\n        }\n\n    }\n\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105365135","body":"```javascript\nvar numberOfBoomerangs = function (points) {\n    let count = 0;\n\n    points.forEach((a, i) => {\n        const map = {};\n\n        points.forEach((b, j) => {\n            if (a !== b) {\n                const dist = calcDistOf2Points(a, b);\n                map[dist] = (map[dist] || 0) + 1;\n            }\n        });\n\n        for (const dist in map) {\n            const num = map[dist];\n            if (num > 1) count += num * (num - 1);\n        }\n    });\n\n    return count;\n\n    function calcDistOf2Points([x1, y1], [x2, y2]) {\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106644802","body":"```javascript\nvar lengthOfLongestSubstring = function (s) {\n    const len = s.length;\n    let max = 0;\n    let str = '';\n    for (let i = 0; i < len; i++) {\n        if (str.indexOf(s[i]) < 0) {\n            str += s[i];\n        }\n        else {\n            str += s[i];\n            while (str.indexOf(s[i]) != str.length - 1) {\n                str = str.slice(1);\n            }\n        }\n        max = Math.max(max, str.length);\n    }\n    return max;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107519062","body":"```javascript\nvar findSubstring = function(s, words) {\n    let correct = {};\n    for (let i = 0 ; i < words.length; i++) {\n        correct[words[i]] = correct[words[i]] || 0;\n        correct[words[i]] ++;\n    }\n\n    let ret = [];\n\n    for (let start = 0; start < words[0].length; start ++) {\n        let map = {};\n        let len = words[0].length;\n        for (let i = start; i < s.length;) {\n            if (i + len > s.length) break;\n\n            let tmp = s.slice(i, i + len);\n            map[tmp] = map[tmp] || 0;\n            map[tmp] ++;\n\n            if (i - len * words.length >= 0) {\n                let prev = s.slice(i - len * words.length, i - len * words.length + len);\n                map[prev] = map[prev] || 0;\n                map[prev] --;\n            }\n\n\n            let flag = true;\n            for (let key in correct) {\n                if (correct[key] !== map[key]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                ret.push(i - (words.length - 1) * len);\n            }\n            i = i + len;\n        }\n    }\n\n    return ret;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108727046","body":"```typescript\nfunction middleNode(head: ListNode | null): ListNode | null {\n\n    let length: number = 0;\n    let point: ListNode | null = head;\n\n    while (point) {\n        length++;\n        point = point.next;\n    }\n\n    point = head;\n    length = Math.floor(length / 2);\n\n    for (let index = 0; index < length; index++) {\n        point = point!.next\n    }\n\n    return point;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109968288","body":"```typescript\nfunction removeDuplicates(nums: number[]): number {\n\n    for (let index = 0; index < nums.length; index++) {\n        while (nums[index + 1] !== undefined && nums[index] === nums[index + 1]) {\n            for (let n_index = index + 1; n_index < nums.length; n_index++) {\n                nums[n_index - 1] = nums[n_index];\n            }\n            nums.pop();\n        }\n    }\n\n    return nums.length;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112266769","body":"```javascript\nvar maxSlidingWindow = function(nums, k) {\n    const n = nums.length;\n    const q = [];\n    for (let i = 0; i < k; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n    }\n\n    const ans = [nums[q[0]]];\n    for (let i = k; i < n; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n        while (q[0] <= i - k) {\n            q.shift();\n        }\n        ans.push(nums[q[0]]);\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nancychien":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086108627","body":"# 思路: \n# 1. 寫一個 for loop 可以 Reverse input list\n# 2. 用 pow 10 乘以 x 並且累加\n# 3. 加 k\n# 4. convert this sum value to string\n# 5. loop this string and make it a list \n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        final = 0\n        for i in range(len(num)):\n            final += num[i]*pow(10,len(num)-i-1)\n        final = final + k\n        return [int(x) for x in str(final)]\n\n\n# time: O(n)\n# space: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086268399","body":"思路：\r\n1. 找出目標 index 位置並 save to a target list\r\n2. loop through 原來的字串和target list 並計算最小距離\r\n`\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        target = []\r\n        output = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target.append(i)\r\n\r\n        for i in range(len(s)):\r\n            output.append(min(abs(i-x) for x in target))\r\n\r\n        return output\r\n`\r\n\r\nTime complexity: O(n^2)\r\nSpace complexity:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086768346","body":"思路：\r\n用 list 去模擬出 stack 的操作\r\n`\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize  = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return -1\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: \r\n            return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n`\r\nTime Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(N)\r\nSpace Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088111025","body":"### 思路\r\nUse two stacks. One for pushing (stack_push), one for popping (stack_pop)\r\n`\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        # stack_pop is empty\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        result = self.stack_pop.pop()\r\n        return result\r\n        \r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n`\r\n\r\nTime complixiety:\r\npush - O(1)\r\npop  - O(n)\r\npeek - O(n)\r\nempty - O(1)\r\nSpace complixiety:\r\npush - O(n)\r\npop  - O(1)\r\npeek - O(1)\r\nempty - O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090780574","body":"思路:\n1. Find the old tail and connect it with the head (old_tail.next = head) to close the ring. Compute the length of the list n at the same time\n2. Find the new tail, which is (n - k % n - 1)th node from the head and the new head, which is (n - k % n)th node\n3. Break the ring new_tail.next = None and return new_head.\n\n`\nclass Solution:\n   def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: \n            return None\n        if not head.next: \n            return head\n        \n        cnt = 1\n        \n        slow, fast = head, head\n        \n        while fast.next:\n            fast = fast.next\n            cnt += 1\n        fast.next = head # circle the list\n        \n        for i in range(cnt - k%cnt - 1):\n            slow = slow.next\n        new_head = slow.next    \n        slow.next = None\n        \n        return new_head\n`\nTime complexity : O(N) \nSpace complexity : O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092545241","body":"思路：Iterative\n1. 兩個為一單位： firstNode and secondNode\n2. Swap the two nodes. The swap step is\n    firstNode.next  = secondNode.next\n    secondNode.next = firstNode\n3. We also need to assign the prevNode's next to the head of the swapped pair. This step would ensure the currently swapped pair is linked correctly to the end of the previously swapped list\n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Dummy node acts as the prevNode for the head node\n        # of the list and hence stores pointer to the head node.\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        prev_node = dummy\n\n        while head and head.next:\n\n            # Nodes to be swapped\n            first_node = head;\n            second_node = head.next;\n\n            # Swapping\n            prev_node.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n\n            # Reinitializing the head and prev_node for next swap\n            prev_node = first_node\n            head = first_node.next\n\n        # Return the new head node.\n        return dummy.next\n```\nTime complexity: O(n)\nSpace Complexity: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094164929","body":"思路:\n    用 hash table 先存一遍 list B. If we find the node pointed to by headA in our set containing nodes of B, \n    then return the node. If nothing, then return null\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        nodes_in_B = set()\n\n        while headB is not None:\n            nodes_in_B.add(headB)\n            headB = headB.next\n\n        while headA is not None:\n            if headA in nodes_in_B:\n                return headA\n            headA = headA.next\n\n        return None\n```\nTime: O(m+n)\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097240088","body":"思路:\n    Recursion: Height = 1 + Max(height(left), height(right))\n\n```\nclass Solution:\n    def maxDepth(self, root):\n        if root is None: \n            return 0 \n        else: \n            left_height  = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n```\nTime: O(n)\nSpace: worst case - O(n)\n            best case (more balanced) - O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098748406","body":"思路: Recursion\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"    \n        # if p and q are both None\n        if not p and not q:\n            return True\n        # one of p and q is None\n        if not q or not p:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and self.isSameTree(p.left, q.left)\n```\nTime: O(n)\nSpace: worst-O(n) when tree is imbalanced; best - O(log(n))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100576925","body":"ideas: DFS\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        level, leftmost = [root], root.val\n        while level:\n            leftmost = level[0].val\n            level = [c for n in level for c in [n.left, n.right] if c]\n        return leftmost\n```\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101670217","body":"思路: use dictionary to loop though the list. The key is the \"number to find\" (target - current number); the value is the index of this number. If we can find \"the number to find\" match the key, then we return the value and current index.\n```\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        mapper = {}\n        for i, num in enumerate(nums):\n            if target-num in mapper:\n                return [mapper[target - num], i]\n            else:\n                mapper[num] = i\n```\nTime: O(n)\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105401966","body":"思路: For each point, create a hashmap and count all points with same distance. \n     If for a point p, there are k points with distance d, number of boomerangs \n     corresponding to that are k*(k-1). Keep adding these to get the final result.\n\n```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for p in points:\n            cmap = {}\n            for q in points:\n                f = p[0]-q[0]\n                s = p[1]-q[1]\n                cmap[f*f + s*s] = 1 + cmap.get(f*f + s*s, 0)\n            for k in cmap:\n                res += cmap[k] * (cmap[k] -1)\n        return res\n```\nTime: O(n^2)\nSpace: O(n)    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105802875","body":"思路: use two pointers to move one by one. If we see the duplicates, we move left pointer and recalculate max length\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        l = 0\n        r = 0\n        max = 1\n        while r < len(s)-1:\n            str = s[l:r+1]\n            if s[r+1] not in str:\n                str = str + s[r+1]\n                r += 1\n                if len(str) > max:\n                    max = len(str)\n            else:\n                l += 1\n        if s == \"\":\n            max = 0\n        return max\n ```\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108750558","body":"Ideas: put all elements in a list A, Then the middle point should be A[A.length // 2]\n\n```\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        arr = [head]\n        while arr[-1].next:\n            arr.append(arr[-1].next)\n        return arr[len(arr) // 2]\n```\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109371002","body":"思路：双指针，一个負責讀取不同的值，一个負責寫入不同的值\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        fast, slow = 0, 0\n        while fast < len(nums):\n            if nums[slow]!=nums[fast]:\n                slow += 1\n                nums [slow] = nums[fast]\n            fast += 1\n        return slow + 1\n```\nTime: O(n)\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086421952","body":"### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length - 1;\n        List<Integer> res = new ArrayList<>();\n        int carry = 0;\n\n        while(len >= 0 || k != 0){\n            int x = len < 0 ? 0 : num[len];\n            int y = k == 0 ? 0 : k % 10;\n\n            int sum = carry + x + y;\n            res.add(sum % 10);\n            carry = sum / 10;\n            \n            len--;\n            k = k / 10;\n        }\n\n        if (carry > 0) res.add(1);\n\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086420045","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; //create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store \r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087119592","body":"### 代码\n```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        String str = recursive(s);\n        return str;\n    }\n\n    public String recursive(String s){\n        StringBuilder sb = new StringBuilder();\n        while(index < s.length()){\n            char cur = s.charAt(index);\n            index++;\n            if(cur >= '0' && cur <= '9'){\n                int num = cur - '0';\n                while(s.charAt(index) >= '0' && s.charAt(index) <= '9'){\n                    num = num * 10 + s.charAt(index) - '0';\n                    index++;\n                }\n                String str = recursive(s);\n                for(int i = 0; i < num; i++){\n                    sb.append(str);\n                }\n            }else if(cur == '['){\n                \n            }else if(cur == ']'){\n                break;\n            }else{\n                sb.append(cur);\n            }\n        }\n        return sb.toString();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pureryudo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1089648114","body":"### 思路\n\n逐位相加 从数组末尾向前遍历，每次与k的余数相加，若>10，则再取余数，并且k++，表示进位。最后将存放结果的list反转。\n\n### 代码\n\n```java\npublic static List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int sum = 0;\n    for (int i = num.length-1; i >= 0; i--){\n        sum = num[i]+k%10;\n        k = k/10;\n        if (sum>=10){\n            k++;\n            sum=sum-10;\n        }\n        result.add(sum);\n    }\n    for ( ; k>0; k=k/10){\n        result.add(k%10);\n    }\n    Collections.reverse(result);\n    return result;\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(N) N为数组长度和logk的较大值\n\n空间复杂度：O(N) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086506715","body":"### 思路\n\n进行两次遍历\n\n使用prev记录上一次出现的c的位置，初始值设为极小的负数。\n\n第一次从左到右遍历，记录当前位置i到prev的绝对值。\n\n第二次从右到左遍历，记录当前位置i到prev的绝对值，并与第一次遍历的结果取min存入结果数组，\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n    int[] result = new int[s.length()];\n    char[] chars = s.toCharArray();\n    /*记录当前遍历中上一个c出现的位置\n        初始值设置为极小的负数用于在比较时获得正确的值*/\n    int prev = Integer.MIN_VALUE/2;\n    /*第一次遍历 从左到右 记录与上一个c的距离*/\n    for (int i = 0; i < chars.length; i++){\n        //还没有出现过c\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.abs(i-prev);\n    }\n    /*第二次遍历 从右到左 记录与上一个c的距离*/\n    prev = -1;\n    for (int i = chars.length-1; i >= 0; i--){\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.min(result[i],Math.abs(prev-i));\n    }\n    return result;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N) N为数组长度\n\n额外空间复杂度：O(N) 新建了一个长度为N的数组用于存放结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1089762501","body":"### 思路\n\n优化前，increment时间复杂度操作是O(N)。\n\n使用一个add数组，存放每个位置上的增量。在pop操作时，pop出的值会加上这个增量。增量会从add[i]传递到add[i-1]位置，向下传递，并将add[i]的值变为0，防止再次increment时增量重叠。这样时间复杂度就变为O(1)\n\n### 代码\n\n```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;   //记录栈顶位置\n    }\n\n    public void push(int x) {\n        if (top < stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1){\n            return -1;\n        }\n        return stack[top--];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(stack.length,k); i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n**优化后**\n\n```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    int[] add;  //增量数组\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;   //记录栈顶位置\n        add = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top < stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1){\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        //增量向下传递\n        if (top!=0){\n            add[top-1] += add[top];\n        }\n        add[top] = 0;   //将传递过的位置变0 防止再次increment时增量异常\n        top--;\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k-1,top);\n        if (limit >= 0){\n            add[limit] += val;\n        }\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(1) 每次pop和push的时间复杂度都是O(1)\n\n空间复杂度：O(N) \tN为maxsize","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1091026409","body":"### 思路\n\n遍历 \n\n- 是数字，将数字整体进栈（数字范围1-300）\n\n- 是\"[\"进栈 \n\n- 是字母 进栈\n\n- 是']'开始出栈 直到'['\n\n  对出栈的[]中间的字符串 按顺序反转后组成新字符串。此时取栈顶（必是数字），次数相乘。\n\n  结果再放入栈\n\n再重复遍历\n\n### 代码\n\n```java\npublic static String decodeString(String s) {\n    Stack<String> stack = new Stack<>();\n    String num = \"\";    //用于拼接的字符串\n    char[] chars = s.toCharArray();\n\n\n    for (int i = 0; i < chars.length; i++){\n        char c = chars[i];\n        if (Character.isDigit(c)){\n            num = num + c;\n        }else if (c == '['){\n            stack.push(num);\n            num = \"\";\n            stack.push(\"[\");\n        }else if (Character.isLetter(c)){\n            stack.push(c+\"\");\n        }else if (c == ']'){\n            LinkedList<String> sub = new LinkedList<String>();\n            String temp = \"\";\n            while (!stack.isEmpty()){\n                temp = stack.pop();\n                if (\"[\".equals(temp)){\n                    break;\n                }\n                sub.addLast(temp);\n            }\n            Collections.reverse(sub);\n            String o = getString(sub);\n            stack.push(multStr(o,Integer.parseInt(stack.pop())));\n\n        }\n    }\n\n    String result = \"\";\n    String[] strings = new String[stack.size()];\n    int i = 0;\n    while (!stack.isEmpty()){\n        strings[i] = stack.pop();\n        i++;\n    }\n    for(i = strings.length-1; i >= 0; i--){\n        result = result + strings[i];\n    }\n    return result;\n}\n\npublic static String getString(LinkedList<String> v) {\n    StringBuffer ret = new StringBuffer();\n    for (String s : v) {\n        ret.append(s);\n    }\n    return ret.toString();\n}\n\n\npublic static String multStr(String str,int num){\n    String result = \"\";\n    for (int i = 0; i < num; i++){\n\n        result += str;\n    }\n    return result;\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1091118768","body":"### 思路\n\n使用两个stack\n\n一个是用作输入栈in 一个用作输出栈out\n\n- push\n\n  放入in内\n\n- pop\n\n  若out内为空，把in里的所有值弹出到in里，最后使out弹出一个值。\n\n- peek\n\n  同pop\n\n- empty\n\n  in和out都为空时 队列为空\n\n### 代码\n\n```java\npublic class MyQueue {\n    Stack<Integer> in;\n    Stack<Integer> out;\n\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n\n    public void push(int x) {\n        in.push(x);\n\n    }\n\n    public int pop() {\n        if (out.isEmpty()){\n            while (!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n\n    public int peek() {\n        if (out.isEmpty()){\n            while (!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：push是O(1)  每从in移动到out一次数据是O(N)，但pop和peek平均到N个数据上每个是O(1)\n\n空间复杂度：O(N) 使用了栈 长度为N","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091157320","body":"### 思路\n\n1. 找到尾结点 和 首节点相连组成一个循环链表。\n2. 若k>length 则k=k%length 这是head向左移动的次数，等同于向右移动length-k次。找到移动后的首节点。\n3. 再由length找到移动后的尾结点，将尾结点的next=null。断开。\n\n### 代码\n\n```java\npublic static ListNode rotateRight(ListNode head, int k) {\n    if (k == 0 || head == null || head.next == null){\n        return head;\n    }\n    //找到最后一个节点 连上首节点\n    ListNode temp = head;\n    ListNode result = null;\n    int length = 1;\n    while (temp.next != null){\n        temp = temp.next;\n        length++;\n    }\n    temp.next = head;\n    //n为head向右移动的次数\n    if (k >length){\n        k=k%length;\n    }\n    int n = length-k;\n    int i = 1;\n    temp = head;\n    while (i <= n){\n        temp = temp.next;\n        i++;\n    }\n\n    ListNode resultHead = temp;\n    temp = resultHead;\n    //从head数length个得到尾结点 断开\n    i = 1;\n    while (i < length){\n        temp = temp.next;\n        i++;\n    }\n    temp.next = null;\n\n    return resultHead;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n额外空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092371708","body":"### 思路\n\n使用pre next1 next2指针记录当前指针的前一个，下一个和下下一个结点。\n\n当前指针每次走两步。\n\n需要注意pre为null 和 剩下的是单个结点的情况。\n\n### 代码\n\n```java\npublic static ListNode swapPairs(ListNode head) {\n    if (head == null){\n        return null;\n    }\n    ListNode result = null;\n    ListNode temp = head;\n    ListNode pre = null;\n    ListNode next1 = null;\n    ListNode next2 = null;\n    while (temp != null){\n        next1 = temp.next;\n        if (pre == null){\n            result = next1;\n        }else {\n            pre.next = next1;\n        }\n        if (next1 == null){\n            if (pre != null){\n                pre.next = temp;\n            }else {\n                result = temp;\n            }\n            return result;\n        }else {\n            next2 = next1.next;\n        }\n        next1.next = temp;\n        temp.next = next2;\n        pre = temp;\n        temp = next2;\n    }\n    return result;\n}\n```\n\n\n\n### 复杂度分析\n\ntime: O(N)\n\nspace:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094840688","body":"### 思路\n\n双指针A和B 从两侧开始走。\n\n若A走到头，使A = headB,若B走到头，使B=headA。这样走两次总距离是相等的。\n\n假设相交点为N，A到N长度为a，B到N长度为b，b之后长度为c。\n\n距离都为a+b+c。如A=B则点为相交点。\n\n### 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null){\n        return null;\n    }\n    ListNode tempA = headA;\n    ListNode tempB = headB;\n    while (true){\n        if (tempA == tempB){\n            return tempA;\n        }else {\n            if (tempA == null){\n                tempA = headB;\n\n            }else{\n                tempA = tempA.next;\n            } \n\n            if(tempB == null){\n                tempB = headA;\n            }else{\n                tempB = tempB.next;\n            }\n        }\n    }\n\treturn null;\n}\n```\n\n\n\n### 复杂度分析\n\ntime:O(N)\n\nspace:O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094729263","body":"### 思路\n\n首先，快慢指针第一次相遇时，慢指针一定是一圈都没有走完的。\n\n<img src=\"https://assets.leetcode-cn.com/solution-static/142/142_fig1.png\" alt=\"fig1\" style=\"zoom: 33%;\" />\n\na为head到环入口的距离，b为环入口到第一次相遇的距离，b+c是环的长度。\n$$\n相遇时快慢指针走的距离： \\\\\nslow=a+b \\quad\nfast=a+n(b+c) \\qquad n为快指针走的圈数 \\\\\nfast = 2*slow\t\\\\\n可得：a = n(b+c)-b = (n-1)(b+c) + c\t\n$$\n在slow和fast的第一次相遇时，使用temp指向head。head和slow同时开始移动，他们必定会在环入口处相遇，因为此时slow要走(n-1)个完整的环再加c，正好到环入口，距离也是a。\n\n### 代码\n\n```java\npublic ListNode detectCycle(ListNode head) {\n    if (head == null || head.next == null){\n        return null;\n    }\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null){\n        slow = slow.next;\n        if (fast.next == null){\n            return null;\n        }else {\n            fast = fast.next.next;\n        }\n\n        if (slow == fast){\n            ListNode temp  = head;\n            while (temp != slow){\n                temp = temp.next;\n                slow = slow.next;\n            }\n            return temp;\n        }\n    }\n    return null;\n}\n```\n\n### 复杂度分析\n\ntime：O(N)\n\nspace：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096445896","body":"class LRUCache {\n    //数组的容量\n    public int capacity;\n    //数组\n    public Node[] array;\n    //双向循环链接的头结点(哨兵节点)\n    public Node head;\n    //存储的元素个数\n    public int num = 0;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        array = new Node[capacity];\n        head = new Node( -1,-1 );\n    }\n\n    public int get(int key) {\n        //根据key得到对应节点\n        Node node = getNode( key );\n        if (null==node) {\n            return -1;\n        }\n        //将此节点移动到双向循环链表的末尾\n        Node prefix = node.prefix;\n        Node next = node.next;\n        //先从双向循环链表中去掉自己 然后再拼到链接的末尾\n        prefix.next = next;\n        next.prefix = prefix;\n        Node p1 = head.prefix;\n        p1.next = node;\n        node.prefix = p1;\n        node.next = head;\n        head.prefix = node;\n        return node.getVal();\n\n    }\n\n    private Node getNode( int key ) {\n        //对key取capacity模然后得到数组下标\n        int hKey = key % capacity;\n        //拿到头结点\n        Node node = array[hKey];\n        if (null==node) {\n            return null;\n        }\n        //按链表往后查找\n        while (null!=node && node.key!= key) {\n            node = node.hNext;\n        }\n        return node;\n    }\n\n    public void put(int key, int value) {\n        //根据key得到对应节点\n        Node node = getNode( key );\n        if (null==node) {\n            //元素个数加加\n            num++;\n            //如果超过容量 则去掉链表头一个非哨兵节点\n            if (num>capacity) {\n                Node next = head.next;\n                if (null==next) {\n                    return;\n                }\n                int dKey = next.getKey();\n                //根据待删除节点的key求得节点所在的数组下标\n                int hdKey = dKey % capacity;\n                Node tmp = array[hdKey];\n                Node tPrefix = null;\n                while (null!=tmp && tmp.getKey()!=dKey) {\n                    tPrefix = tmp;\n                    tmp = tmp.hNext;\n                }\n                //删除数组槽位的链表中的此节点\n                if (null!=tPrefix) {\n                    tPrefix.hNext = next.hNext;\n                }else{\n                    array[hdKey] = next.hNext;\n                }\n                //删除循环双向链表中的此节点\n                node = head;\n                while (null!=node.next && node.next.getKey()!=dKey) {\n                    node = node.next;\n                }\n                node.next = next.next;\n                next.next.prefix = node;\n                num--;\n            }\n            //定义新节点 将节点插入到数组槽位中的链表 同时也插入双向循环链表\n            Node nNode = new Node( key,value );\n            int hKey = key % capacity;\n            Node prefix = array[hKey];\n            if (null==prefix) {\n                array[hKey] = nNode;\n            }else{\n                while (null!=prefix.hNext) {\n                    prefix = prefix.hNext;\n                }\n                prefix.hNext = nNode;\n            }\n            prefix = head.prefix;\n            if (null==prefix) {\n                head.prefix = nNode;\n                head.next = nNode;\n                nNode.prefix = head;\n                nNode.next = head;\n            }else{\n                prefix.next = nNode;\n                nNode.prefix = prefix;\n                nNode.next = head;\n                head.prefix = nNode;\n            }\n        }else{\n            //有此节点 则更新value 且将此节点移动到链表末尾\n            node.setVal( value );\n            node.prefix.next = node.next;\n            node.next.prefix = node.prefix;\n            Node prefix = head.prefix;\n            prefix.next = node;\n            node.prefix = prefix;\n            node.next = head;\n            head.prefix = node;\n        }\n    }\n    \n    //节点对象\n    class Node {\n        int key;\n        int val;\n        //双向循环链表的上个节点\n        Node prefix;\n        //双向循环链表的下个节点\n        Node next;\n        //数组槽位的链表的下个节点\n        Node hNext;\n        \n\n        public Node( int key, int val ) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        public void setVal( int val ) {\n            this.val = val;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097585410","body":"### 思路\n\n树的最大深度为 左右子树深度+1取max\n\n### 代码\n\n```java\n    public int maxDepth(TreeNode root) {\n        if (root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left)+1,maxDepth(root.right)+1);\n    }\n```\n\n### 复杂度分析\n\ntime：O（N）\n\nspace：O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098625989","body":"### 思路\n\n对两个树递归遍历比较值是否相等\n\n只有相等才继续向下递归\n\n### 代码\n\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        return process(p,q);\n    }\n\n    private boolean process(TreeNode p, TreeNode q) {\n\n        if (p == null && q == null){\n            return true;\n        }\n\n        if (p == null || q == null){\n            return false;\n        }\n\n        if (p.val == q.val){\n            return process(p.left,q.left)&&process(p.right,q.right);\n        }else {\n            return false;\n        }\n    }\n```\n\n\n\n### 复杂度分析\n\ntime & space: O(min(m,n)) m和n是两个树的节点数","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101940898","body":"### 思路\n\n枚举\n\n### 代码\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107685334","body":"代码：\n\n```JAVA\n    public int subarraysDivByK(int[] nums, int k) {\n        Map<Integer, Integer> record = new HashMap<Integer, Integer>();\n        record.put(0, 1);\n        int sum = 0, ans = 0;\n        for (int elem : nums) {\n            sum += elem;\n            int modulus = (sum % k + k) % k;\n            int same = record.getOrDefault(modulus, 0);\n            ans += same;\n            record.put(modulus, same + 1);\n        }\n        return ans;\n    }\n\n```\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109467441","body":"###双指针\n\n\n\n\n```JAVA\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        if (n == 0) {\n            return 0;\n        }\n        int fast = 1, slow = 1;\n        while (fast < n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n    }\n}\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoliz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1088212714","body":"### 思路\r\n逐位相加，大于10进位 Math.floor(k ) 向下取整加1\r\n\r\n### 代码\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = []\r\n    let leng = num.length\r\n    for(let i = leng - 1; i >= 0; --i) {\r\n        let nums = num[i] + (k % 10)\r\n        k = Math.floor(k / 10)\r\n        if( nums >= 10 )  {\r\n            k++;\r\n            nums -= 10;\r\n        }\r\n        res.push(nums)\r\n    }\r\n\r\n   while(k > 0) {\r\n        res.push(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n\r\n    res.reverse();\r\n    return res;\r\n}\r\n```\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(N)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086560188","body":"思路:   先查遍历找出C值对应的下标索引存储includesIndex中， 在进行一次循环 当前值等于C那么距离直接为0，内部进行二次循环 includesIndex arr 进行绝对值计算 \n\n\nvar shortestToChar = function(s, c) {\n\n    let includesIndex = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            includesIndex.push(i)\n        }\n    }\n\n    var res = Array(s.length).fill(0);\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0;\n            continue;\n        }\n\n        for(let val of includesIndex ) {\n            const dist = Math.abs(val - i)\n            \n            if (dist >= res[i]) break;\n            res[i] = dist;\n        }\n    }\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086754886","body":"### 思路\r\n数组实现栈\r\n\r\n### 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.number = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.number > this.stack.length) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(!this.stack.length) return -1;\r\n    return this.stack.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for( let i = 0; i < this.stack.length; i++) {\r\n        if (i < k) {\r\n            this.stack[i] += val\r\n        }   \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： push:O(1)、pop：O(1)  O(N)  N:  是k，需增量元素个数\r\n- 空间复杂度  O(N)   N: maxSize\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088188139","body":"### 思路\n看到这个题型首先想到数组增删改查\n\n### 代码\n```javascript\nvar MyQueue = function() {\n    this.tasck = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    return this.tasck.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.tasck.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.tasck.slice(0, 1)\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n   return !this.tasck.length;\n};\n```\n\n### 复杂度分析\n- 时间复杂度: O(1)\n- 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090405003","body":"\n## 题目地址(768. 最多能完成排序的块 II)\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n\n\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n-Aarry\n\n\n## 思路\n两个数组进行对比，新创建一个sort后的数组，两个数组进行遍历进行自加，如果相等count累加计数\n\n## 代码\n\n- 语言支持：JavaScript\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sorted = [...arr]\n    sorted.sort((a, b) => {\n        return a - b\n    })\n    \n    console.log(sorted, 'sorted')\n\n    let count = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i]\n        sum2 += sorted[i]\n\n        if(sum1 === sum2) {\n            count++\n            sum1 = 0;\n            sum2 = 0;  \n        }\n    }\n\n    return count;\n};\n\n```\n\n\n**复杂度分析**\n n 为数组长度。\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091814214","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 前置知识\n\n- \n\n\n## 思路\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head ||!head.next) return head;\n    let count = 0;\n    let now = head;\n\n    while(now) {\n        now = now.next;\n        count++;\n    }\n    k = k % count;\n\n    let slow = (fast = head);\n    while (fast.next) {\n        if(k-- <= 0) {\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n\n    let res = slow.next;\n    slow.next = null;\n\n    return res\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092961436","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n\n## 思路\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head ||!head.next) return head;\n    let count = 0;\n    let now = head;\n\n    while(now) {\n        now = now.next;\n        count++;\n    }\n    k = k % count;\n\n    let slow = (fast = head);\n    while (fast.next) {\n        if(k-- <= 0) {\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n\n    let res = slow.next;\n    slow.next = null;\n\n    return res\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenliangchen":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086416827","body":"## 思路：\r\n通过下标进行数组中内容的倒叙遍历，同时对于获取数字的个位数进行相加，使用%10即可。通过/10 达到进位 并保存余数。 再降结果加入到list中\r\n## 代码:\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0;\r\n        List<Integer> res = new ArrayList();\r\n        int i = num.length - 1;\r\n        \r\n        while(carry > 0 || k > 0 || i >= 0) {\r\n            int n = i >= 0 ? num[i--]: 0;\r\n            int a = k%10;\r\n            int sum = n + a + carry;\r\n            res.add(sum%10);\r\n            carry = sum/10;\r\n            k = k/10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n} \r\n```\r\n\r\n\r\n## Time : O(n)\r\n## Space:O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565399","body":"## 思路：\r\n先从左边遍历，每次遍历中 先找到对应的目标的下标，在过程中利用i的下标去减去最小值的二分之一，（目的是在没找到的情况下，通过减去最小值留下一个最大数值，最小值为负数 i - -则变为加法）。之后进行右边遍历，同理，在过程中进行大小的比较。对比两次遍历最小的值是哪个，这样即可得到正确答案。\r\n\r\n用最小值的目的是为了避免溢出\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] ans = new int[len];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n - 时间复杂度：O(N)\r\n - 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770200","body":"## 思路\r\n利用数组进行数据的存储，在push和pop时判断情况，并记录下标和最大容量\r\n\r\n## 代码\r\n\r\n```\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：push 和 pop 操作的时间复杂度为 O(1)，其余为O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087238550","body":"## 思路\r\n维护一个栈 和临时链表来进行括号匹配和字符串储存，当遇到右括号开始pop计算后形成新字符串，然后重新入栈\r\n\r\n\r\n## 代码\r\n```\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder();\r\n        Stack<Character> st = new Stack<>();\r\n        for(int i = 0; i < len;i++){\r\n            \r\n            char t = s.charAt(i);\r\n            if(t == ']'){                   \r\n                List<Character> temp = new ArrayList<>();\r\n                while(st.peek()!='['){\r\n                    temp.add(st.pop());\r\n                   } \r\n                \r\n                    st.pop(); // remove the '['\r\n                    int base =1;\r\n                    int k = 0;\r\n                    while( !st.empty() && Character.isDigit(st.peek() )){\r\n                         k = k + (st.pop() - '0' ) * base;\r\n                         base *= 10;\r\n                    }\r\n\r\n                    while(k!=0){\r\n                        for(int j = temp.size() -1; j >=0;j--){\r\n                            st.push(temp.get(j));\r\n                        }\r\n                        k--;\r\n                    }\r\n                \r\n            }else{\r\n                st.push(t);\r\n            }\r\n        \r\n        }\r\n        char[] ans = new char[st.size()];\r\n        int j = st.size()-1;\r\n        while(!st.empty()){\r\n            ans[j] = st.pop();\r\n            j--;\r\n        }\r\n\r\n        \r\n        return new String(ans);\r\n    }\r\n}\r\n\r\n```\r\n## 复杂度\r\n - 时间 O(K*K *N) \r\n - 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088372686","body":"## 思路\r\n维护两个栈，一个专门用来入，另一个在出时负责倒一下。\r\n\r\n## 代码\r\n\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> st;\r\n    Stack<Integer> ans;\r\n    int f;\r\n\r\n    public MyQueue() {\r\n        st = new Stack<>();\r\n        ans = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(st.empty()){\r\n            f =x;\r\n        }\r\n        \r\n        st.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(ans.empty()){\r\n            while(!st.empty()){\r\n                ans.push(st.pop());\r\n            }\r\n        }\r\n        return ans.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(!ans.empty()) return ans.peek();\r\n        \r\n        return f;\r\n    }\r\n    \r\n    public boolean empty() {\r\n\r\n        \r\n        return ans.empty() && st.empty();\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间  push: O(1) peek: O(n) pop: O(n) empty: O(1)\r\n- 空间   O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090121730","body":"## 思路\r\n用数组的差进行维护\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n                 int[] Left_max = new int[arr.length];\r\n        int[] right_min = new int[arr.length];\r\n        \r\n         //LEFT MAX array\r\n        Left_max[0]=arr[0];\r\n        for(int i=1;i<arr.length;i++){\r\n            if(arr[i]>Left_max[i-1]){\r\n                Left_max[i]=arr[i];\r\n            }else{\r\n               Left_max[i]=Left_max[i-1];\r\n            }\r\n        }\r\n        \r\n        //Right min Array\r\n        right_min[arr.length-1]=arr[arr.length-1];\r\n        for(int i=arr.length-2;i>=0;i--){\r\n            if(arr[i]<right_min[i+1]){\r\n                right_min[i]=arr[i];\r\n            }else{\r\n                right_min[i]=right_min[i+1];\r\n            }\r\n        }\r\n        \r\n        int chunk=1; \r\n        for(int i=0;i<arr.length-1;i++){\r\n            if(Left_max[i]<=right_min[i+1]){\r\n                chunk++;\r\n            }\r\n        }\r\n        return chunk;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n - 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091428737","body":"## 思路\r\n先统计有多少个数据，再通过k%len 得到需要的步数。使用双指针进行快慢K，来达到效果\r\n\r\n## 代码\r\n\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        int len = 0;\r\n        ListNode p = head;\r\n        while(p != null){\r\n            p = p.next;\r\n            len++;\r\n        }\r\n        \r\n        k = k % len;\r\n        ListNode s = head, f = head;\r\n        \r\n        while(f.next!=null){\r\n            \r\n            if( k <= 0){\r\n                s= s.next;\r\n                \r\n            }\r\n            k--;\r\n            f= f.next;\r\n                \r\n        }\r\n        f.next = head;\r\n        ListNode res  = s.next;\r\n        s.next = null;\r\n        return res;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092458658","body":"## 思路\r\n从原始链表的头节点开始递归。\r\n\r\n每个递归调用负责交换一对节点。让我们用firstNode和secondNode来表示要交换的两个节点。\r\n\r\n下一次递归是通过调用具有下一对节点头的函数来进行的。如果链表中还有节点，这个调用将交换接下来的两个节点，并进行进一步的递归调用。\r\n\r\n一旦我们从递归调用中获得指向剩余交换列表的指针，我们就可以交换firstNode和secondNode，即当前递归调用中的节点，然后将指针返回到secondNode，因为它将是交换后的新头。\r\n\r\n## 代码\r\n\r\n\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n\r\n        // If the list has no node or has only one node left.\r\n        if ((head == null) || (head.next == null)) {\r\n            return head;\r\n        }\r\n\r\n        // Nodes to be swapped\r\n        ListNode firstNode = head;\r\n        ListNode secondNode = head.next;\r\n\r\n        // Swapping\r\n        firstNode.next  = swapPairs(secondNode.next);\r\n        secondNode.next = firstNode;\r\n\r\n        // Now the head is the second node\r\n        return secondNode;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间O(N) \r\n- 空间O(N) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093771848","body":"## 思路\r\n用双指针方法来找出链表的中间元素, 断开中间元素左边的链表部分 作为左子树，同理右半边为右子树。\r\n## 代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        ListNode mid = findMid(head);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        \r\n        if(head == mid){\r\n            return root;\r\n        }\r\n        \r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(mid.next);\r\n\r\n        \r\n        return root;\r\n        \r\n    }\r\n    \r\n    private ListNode findMid(ListNode head){\r\n        ListNode s = head, p = null, f = head;\r\n\r\n        while(f!=null && f.next!=null){\r\n            p = s;\r\n            s = s.next;\r\n            f = f.next.next;\r\n        \r\n        }\r\n        \r\n        if(p!=null){\r\n            p.next = null;\r\n        }\r\n        \r\n        return s;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n## 复杂度\r\n-TC: O(N logN)\r\n-SC: O(Log N)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094178687","body":"## 思路\r\n双指针遍历，遇到相同即为相交\r\n## 代码\r\n\r\n```\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094549058","body":"## 思路\r\n直接HashSet添加，如果遇到重复就返回，遇不到就返回空\r\n\r\n## 代码\r\n\r\n```\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> ans = new HashSet<>();\r\n        if(head == null) return null;\r\n        while(head.next!=null){\r\n            if(ans.contains(head)){\r\n                return head;\r\n            }else{\r\n                ans.add(head);\r\n                head = head.next;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\ntime complexity: O(N)\r\nspace complexity: O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096056417","body":"## 思路\r\n哈希表跟踪双向链表中的键及其值,点可以在没有其他引用的情况下移除自身\r\n## 代码\r\n```\r\n\r\npublic class LRUCache {\r\n\r\n  class DLinkedNode {\r\n    int key;\r\n    int value;\r\n    DLinkedNode prev;\r\n    DLinkedNode next;\r\n  }\r\n\r\n  private void addNode(DLinkedNode node) {\r\n\r\n    node.prev = head;\r\n    node.next = head.next;\r\n\r\n    head.next.prev = node;\r\n    head.next = node;\r\n  }\r\n\r\n  private void removeNode(DLinkedNode node){\r\n\r\n    DLinkedNode prev = node.prev;\r\n    DLinkedNode next = node.next;\r\n\r\n    prev.next = next;\r\n    next.prev = prev;\r\n  }\r\n\r\n  private void moveToHead(DLinkedNode node){\r\n\r\n    removeNode(node);\r\n    addNode(node);\r\n  }\r\n\r\n  private DLinkedNode popTail() {\r\n\r\n    DLinkedNode res = tail.prev;\r\n    removeNode(res);\r\n    return res;\r\n  }\r\n\r\n  private Map<Integer, DLinkedNode> cache = new HashMap<>();\r\n  private int size;\r\n  private int capacity;\r\n  private DLinkedNode head, tail;\r\n\r\n  public LRUCache(int capacity) {\r\n    this.size = 0;\r\n    this.capacity = capacity;\r\n\r\n    head = new DLinkedNode();\r\n    // head.prev = null;\r\n\r\n    tail = new DLinkedNode();\r\n    // tail.next = null;\r\n\r\n    head.next = tail;\r\n    tail.prev = head;\r\n  }\r\n\r\n  public int get(int key) {\r\n    DLinkedNode node = cache.get(key);\r\n    if (node == null) return -1;\r\n\r\n    // move the accessed node to the head;\r\n    moveToHead(node);\r\n\r\n    return node.value;\r\n  }\r\n\r\n  public void put(int key, int value) {\r\n    DLinkedNode node = cache.get(key);\r\n\r\n    if(node == null) {\r\n      DLinkedNode newNode = new DLinkedNode();\r\n      newNode.key = key;\r\n      newNode.value = value;\r\n\r\n      cache.put(key, newNode);\r\n      addNode(newNode);\r\n\r\n      ++size;\r\n\r\n      if(size > capacity) {\r\n        // pop the tail\r\n        DLinkedNode tail = popTail();\r\n        cache.remove(tail.key);\r\n        --size;\r\n      }\r\n    } else {\r\n      // update the value.\r\n      node.value = value;\r\n      moveToHead(node);\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间 O(1)\r\n- 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097572899","body":"## 思路\r\n直接递归 然后判断最大值即可\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        \r\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098709030","body":"## 思路\r\n深度优先搜索（DFS），递归判断根节点和左右子树是否相等\r\n\r\n\r\n## 代码\r\n\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n\r\n        \r\n        if(p== null && q==null) return true;\r\n        \r\n        if(p== null || q==null) return false;\r\n        \r\n        if(p.val != q.val) return false;\r\n        \r\n        return isSameTree(p.left,q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n## 复杂:\r\n- Time : O(n)\r\n- Space:O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099875132","body":"class Solution {\n  int rootToLeaf = 0;\n\n  public void preorder(TreeNode r, int currNumber) {\n    if (r != null) {\n      currNumber = currNumber * 10 + r.val;\n      // if it's a leaf, update root-to-leaf sum\n      if (r.left == null && r.right == null) {\n        rootToLeaf += currNumber;\n      }\n      preorder(r.left, currNumber);\n      preorder(r.right, currNumber) ;\n    }\n  }\n\n  public int sumNumbers(TreeNode root) {\n    preorder(root, 0);\n    return rootToLeaf;\n  }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100584873","body":"## 思路\r\n队列BFS\r\n## 代码\r\n```\r\npublic int findBottomLeftValue(TreeNode root) {\r\n\r\n    int ans = 0;\r\n\t\r\n    Queue<TreeNode> q = new LinkedList();\r\n    q.add(root);\r\n    while(!q.isEmpty()){\r\n        int count = q.size();\r\n        for(int i = 0; i<count; i++){\r\n            TreeNode curr = q.poll();\r\n            if(i==0)\r\n                ans = curr.val;\r\n            if(curr.left!=null)\r\n                q.add(curr.left);\r\n            if(curr.right!=null)\r\n                q.add(curr.right);\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n```\r\n## 复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100818232","body":"## 思路\r\nBFS一把刷\r\n## 代码\r\n```\r\npublic String serialize(TreeNode root) {\r\n        if (root == null) return \"\";\r\n        String n = \"null\", sep = \",\";\r\n        Queue<TreeNode> dq = new LinkedList<>();\r\n        dq.offer(root);\r\n        int size = 0;\r\n        TreeNode cur;\r\n        StringBuilder sb = new StringBuilder();\r\n        \r\n        while (!dq.isEmpty()) {\r\n            size = dq.size();\r\n            for (int i = 0; i < size; ++i) {\r\n                cur = dq.poll();\r\n                if (cur != null) {\r\n                    sb.append(cur.val);\r\n                    dq.offer(cur.left);\r\n                    dq.offer(cur.right);\r\n                } else {\r\n                    sb.append(n);\r\n                }\r\n                sb.append(sep);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if (data == null || data.length() == 0) return null;\r\n        String[] vals = data.split(\",\");\r\n        if (vals == null || vals.length == 0) return null;\r\n        \r\n        String n = \"null\";\r\n        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));\r\n        TreeNode cur, next;\r\n        Deque<TreeNode> dq = new ArrayDeque<>();\r\n        int size = 0, index = 1;\r\n        dq.offer(root);\r\n        \r\n        while (!dq.isEmpty()) {\r\n            size = dq.size();\r\n            for (int i = 0; i < size; ++i) {\r\n                cur = dq.poll();\r\n                \r\n                for (int j = index; j < index + 2 && j < vals.length; ++j) {\r\n                    if (vals[j].equals(n)) {\r\n                        if (j % 2 == 1) {\r\n                            cur.left = null;\r\n                        } else {\r\n                            cur.right = null;\r\n                        }\r\n                    } else {\r\n                        next = new TreeNode(Integer.parseInt(vals[j]));\r\n                        dq.offer(next);\r\n                        if (j % 2 == 1) {\r\n                            cur.left = next;\r\n                        } else {\r\n                            cur.right = next;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                index += 2;\r\n            }\r\n        }\r\n        \r\n        return root;\r\n    }\r\n```\r\n## 复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101144829","body":"## Idea\r\nDFS Traversal\r\n\r\n## code\r\n```\r\nclass Triplet<F, S, T> {\r\n    public final F first;\r\n    public final S second;\r\n    public final T third;\r\n\r\n    public Triplet(F first, S second, T third) {\r\n        this.first = first;\r\n        this.second = second;\r\n        this.third = third;\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    List<Triplet<Integer, Integer, Integer>> nodeList = new ArrayList<>();\r\n\r\n    private void DFS(TreeNode node, Integer row, Integer column) {\r\n        if (node == null)\r\n            return;\r\n        nodeList.add(new Triplet(column, row, node.val));\r\n        // preorder DFS traversal\r\n        this.DFS(node.left, row + 1, column - 1);\r\n        this.DFS(node.right, row + 1, column + 1);\r\n    }\r\n\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> output = new ArrayList();\r\n        if (root == null) {\r\n            return output;\r\n        }\r\n\r\n        // step 1). DFS traversal\r\n        DFS(root, 0, 0);\r\n\r\n        // step 2). sort the list by <column, row, value>\r\n        Collections.sort(this.nodeList, new Comparator<Triplet<Integer, Integer, Integer>>() {\r\n            @Override\r\n            public int compare(Triplet<Integer, Integer, Integer> t1,\r\n                    Triplet<Integer, Integer, Integer> t2) {\r\n                if (t1.first.equals(t2.first))\r\n                    if (t1.second.equals(t2.second))\r\n                        return t1.third - t2.third;\r\n                    else\r\n                        return t1.second - t2.second;\r\n                else\r\n                    return t1.first - t2.first;\r\n            }\r\n        });\r\n\r\n        // step 3). extract the values, grouped by the column index.\r\n        List<Integer> currColumn = new ArrayList();\r\n        Integer currColumnIndex = this.nodeList.get(0).first;\r\n\r\n        for (Triplet<Integer, Integer, Integer> triplet : this.nodeList) {\r\n            Integer column = triplet.first, value = triplet.third;\r\n            if (column == currColumnIndex) {\r\n                currColumn.add(value);\r\n            } else {\r\n                output.add(currColumn);\r\n                currColumnIndex = column;\r\n                currColumn = new ArrayList();\r\n                currColumn.add(value);\r\n            }\r\n        }\r\n        output.add(currColumn);\r\n\r\n        return output;\r\n    }\r\n}\r\n\r\n```\r\n## Complexity\r\nO(NlogN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102186061","body":"## idea\r\ntwo for loop\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n  public int[] twoSum(int[] nums, int target) {\r\n        int n = nums.length;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = i + 1; j < n; ++j) {\r\n                if (nums[i] + nums[j] == target) {\r\n                    return new int[]{i, j};\r\n                }\r\n            }\r\n        }\r\n        return new int[0];\r\n  }\r\n}\r\n\r\n```\r\n## Complixity\r\n- Time:O(N^2)\r\n- SpaceO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103512344","body":"## Idea\r\nUse a map to store all elements as a key and their number of occurrences as values, and then use a PriorityQueue to sort them by frequency.\r\n## Code\r\n\r\n```\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        // O(1) time\r\n        if (k == nums.length) {\r\n            return nums;\r\n        }\r\n        \r\n        // 1. build hash map : character and how often it appears\r\n        // O(N) time\r\n        Map<Integer, Integer> count = new HashMap();\r\n        for (int n: nums) {\r\n          count.put(n, count.getOrDefault(n, 0) + 1);\r\n        }\r\n\r\n        // init heap 'the less frequent element first'\r\n        Queue<Integer> heap = new PriorityQueue<>(\r\n            (n1, n2) -> count.get(n1) - count.get(n2));\r\n\r\n        // 2. keep k top frequent elements in the heap\r\n        // O(N log k) < O(N log N) time\r\n        for (int n: count.keySet()) {\r\n          heap.add(n);\r\n          if (heap.size() > k) heap.poll();    \r\n        }\r\n\r\n        // 3. build an output array\r\n        // O(k log k) time\r\n        int[] top = new int[k];\r\n        for(int i = k - 1; i >= 0; --i) {\r\n            top[i] = heap.poll();\r\n        }\r\n        return top;\r\n    }\r\n\r\n```\r\n\r\n## Complexity\r\n\r\nO(NlogN)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104768695","body":"## Idea\r\nuse hash map to have the record, and then calculate the distance.\r\n\r\n\r\n## code\r\n```\r\nclass Solution {\r\npublic int numberOfBoomerangs(int[][] points) {\r\n    int res = 0;\r\n\r\n    Map<Integer, Integer> map = new HashMap<>();\r\n    for(int i=0; i<points.length; i++) {\r\n        for(int j=0; j<points.length; j++) {\r\n            if(i == j)\r\n                continue;\r\n            \r\n            int d = getDistance(points[i], points[j]);                \r\n            map.put(d, map.getOrDefault(d, 0) + 1);\r\n        }\r\n        \r\n        for(int val : map.values()) {\r\n            res += val * (val-1);\r\n        }            \r\n        map.clear();\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\nprivate int getDistance(int[] a, int[] b) {\r\n    int dx = a[0] - b[0];\r\n    int dy = a[1] - b[1];\r\n    \r\n    return dx*dx + dy*dy;\r\n}\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105982731","body":"## idea\r\nTwo Pointer\r\n## Code\r\n```\r\npublic class Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        Integer[] chars = new Integer[128];\r\n\r\n        int left = 0;\r\n        int right = 0;\r\n\r\n        int res = 0;\r\n        while (right < s.length()) {\r\n            char r = s.charAt(right);\r\n\r\n            Integer index = chars[r];\r\n            if (index != null && index >= left && index < right) {\r\n                left = index + 1;\r\n            }\r\n\r\n            res = Math.max(res, right - left + 1);\r\n\r\n            chars[r] = right;\r\n            right++;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107436782","body":"## Code\r\n\r\n```\r\nclass Solution {\r\n    private HashMap<String, Integer> wordCount = new HashMap<String, Integer>();\r\n    private int wordLength;\r\n    private int substringSize;\r\n    private int k;\r\n    \r\n    private boolean check(int i, String s) {\r\n        // Copy the original dictionary to use for this index\r\n        HashMap<String, Integer> remaining = new HashMap<>(wordCount);\r\n        int wordsUsed = 0;\r\n        \r\n        // Each iteration will check for a match in words\r\n        for (int j = i; j < i + substringSize; j += wordLength) {\r\n            String sub = s.substring(j, j + wordLength);\r\n            if (remaining.getOrDefault(sub, 0) != 0) {\r\n                remaining.put(sub, remaining.get(sub) - 1);\r\n                wordsUsed++;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return wordsUsed == k;\r\n    }\r\n    \r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        int n = s.length();\r\n        k = words.length;\r\n        wordLength = words[0].length();\r\n        substringSize = wordLength * k;\r\n        \r\n        for (String word : words) {\r\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\r\n        }\r\n        \r\n        List<Integer> answer = new ArrayList<>();\r\n        for (int i = 0; i < n - substringSize + 1; i++) {\r\n            if (check(i, s)) {\r\n                answer.add(i);\r\n            }\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109535934","body":"## Idea\r\nTwo pointer comparison.\r\n\r\n## code\r\n\r\n```\r\n\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int i = 0;\r\n        if(nums.length == 0) return 0;\r\n        \r\n        for(int j = 0; j<nums.length;j++){\r\n            if(nums[i]!=nums[j]){\r\n                i++;\r\n                nums[i]=nums[j];\r\n            }\r\n        }\r\n        \r\n        return i +1;\r\n        \r\n    }\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111702883","body":"## Idea\r\n\r\nUsing Deque\r\n\r\n## Code\r\n\r\n```\r\nclass Solution {\r\n  ArrayDeque<Integer> deq = new ArrayDeque<Integer>();\r\n  int [] nums;\r\n\r\n  public void clean_deque(int i, int k) {\r\n    // remove indexes of elements not from sliding window\r\n    if (!deq.isEmpty() && deq.getFirst() == i - k)\r\n      deq.removeFirst();\r\n\r\n    // remove from deq indexes of all elements \r\n    // which are smaller than current element nums[i]\r\n    while (!deq.isEmpty() && nums[i] > nums[deq.getLast()])                           deq.removeLast();\r\n  }\r\n\r\n  public int[] maxSlidingWindow(int[] nums, int k) {\r\n    int n = nums.length;\r\n    if (n * k == 0) return new int[0];\r\n    if (k == 1) return nums;\r\n\r\n    // init deque and output\r\n    this.nums = nums;\r\n    int max_idx = 0;\r\n    for (int i = 0; i < k; i++) {\r\n      clean_deque(i, k);\r\n      deq.addLast(i);\r\n      // compute max in nums[:k]\r\n      if (nums[i] > nums[max_idx]) max_idx = i;\r\n    }\r\n    int [] output = new int[n - k + 1];\r\n    output[0] = nums[max_idx];\r\n\r\n    // build output\r\n    for (int i  = k; i < n; i++) {\r\n      clean_deque(i, k);\r\n      deq.addLast(i);\r\n      output[i - k + 1] = nums[deq.getFirst()];\r\n    }\r\n    return output;\r\n  }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566581","body":"4.2算法题：\nIdea：\n1.找到指定字符在目标字符串的下标并放进一个数组记录。\n2.循环比较字符串中每个字符距离和指定字符的距离，记录下较小的一个，放入另一个数组。\n\nCode：\n\nvar shortestToChar = function(s, c) {\n    var nearstXb = [];\n    var absDis = [];\n\n    for(var i=0;i<s.length;i++){\n      if(s[i] == c){\n      nearstXb.push(i);}    \n    };\n\n    for(var i=0;i<s.length;i++){\n        var min2 = s.length;\n        for(var j=0;j<nearstXb.length;j++){\n            var min1 = Math.abs(i-nearstXb[j])\n            if(min1<min2){\n               min2 = min1;}\n        }\n        absDis.push(min2);\n    }\n\n    return absDis;\n\n}\n \n时间复杂度：O(N^2)\n空间复杂度：（1）\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088765863","body":"Idea: 双栈对放思路，彼此为镜像，出栈时先将1栈的数压入2栈，再将2栈打印，即可实现。\n\nCode:\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n\n  \nComplexity:\n时间：O(n）,空间：O（1）\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092375537","body":"Idea: 采用递归的方法进行两两转换，首先是针对头节点来说如果本身为空或者下一个为空，则直接返回（对于后续迭代的话的意思就是当剩下的只有一个节点或无节点时，结束迭代）\n单次迭代：首先是把将newHead赋为Head的next节点，\n再对head的下一个节点进行递归操作（此时head即将变为第二个节点）\n此时迭代的对象是newhead的下一个（就是head的下一个的下一个节点，第二组进行交换的节点）\n最后将newhead转为新头节点，下一个是head。\n\nCode：\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n\n};\n\nComplexity：\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097473188","body":"Idea:\n递归子树，找到最深.然后比较左右子树最深，提出最深+1\n\nCode:\nvar maxDepth = function(root) {\n    if(!root){\n        return 0;\n    }\n    else{\n        var left = maxDepth(root.left);\n        var right = maxDepth(root.right);\n        return Math.max(left,right) + 1;\n        }\n};\n\nComplicity:\n时间：O（n）\n空间：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098739144","body":"Idea:深度遍历，判断节点是否相等：1.都是否为空。2.是否一方为空。3.看节点的数值是否相等。\n\nCode：\n \nvar isSameTree = function(p, q) {\n    if(p == null && q == null) \n        return true;\n    if(p == null || q == null) \n        return false;\n    if(p.val != q.val) \n        return false;\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n};\n\nComplexity：\n时间：O（n）\n空间：O（n）\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101041228","body":"idea: 对我来说有点难，according to 题解写了一遍\ncode:\nvar verticalTraversal = function(root) {\n    const nodes = [];\n    dfs(root, 0, 0, nodes);\n    nodes.sort((tuple1, tuple2) => {\n        if (tuple1[0] !== tuple2[0]) {\n            return tuple1[0] - tuple2[0];\n        } else if (tuple1[1] !== tuple2[1]) {\n            return tuple1[1] - tuple2[1];\n        } else {\n            return tuple1[2] - tuple2[2];\n        }\n    });\n\n    const ans = [];\n    let lastcol = -Number.MAX_VALUE;\n    for (const tuple of nodes) {\n        let col = tuple[0], row = tuple[1], value = tuple[2];\n        if (col !== lastcol) {\n            lastcol = col;\n            ans.push([]);\n        }\n        ans[ans.length - 1].push(value);\n    }\n    return ans;\n}\n\nconst dfs = (node, row, col, nodes) => {\n    if (node === null) {\n        return;\n    }\n    nodes.push([col, row, node.val]);\n    dfs(node.left, row + 1, col - 1, nodes);\n    dfs(node.right, row + 1, col + 1, nodes);\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101948437","body":"Idea:采用双指针，双层循环\n'''\nvar twoSum = function(nums, target) {\n    var xb = [];\n\n    for(i=0;i<nums.length;i++){\n        for(j=i+1;j<nums.length;j++){\n            if((nums[i] + nums[j]) == target){\n                xb.push(i,j)\n            }\n        }\n    }\n    return xb;\n\n};\n\n'''\n\n复杂度：\n时间：O(n^2)\n空间：O(n)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107513051","body":"Idea：暴力穷举\n\nCode:\n'''\nvar findSubstring = function(s, words) {\n    if (!words || !words.length) return[];\n    let wordLen = words[0].length;\n    let allWordsLen = wordLen * words.length;\n    let ans = [], wordMap = {};\n    for (let w of words) {\n        wordMap[w] ? wordMap[w]++ :wordMap[w] = 1\n    }\n    for (let i = 0; i < s.length - allWordsLen + 1; i++) {\n        let wm = Object.assign({}, wordMap);\n        for (let j = i; j < i + allWordsLen - wordLen + 1; j += wordLen) {\n            let w = s.slice(j, j + wordLen);\n            if (wm[w]) {\n                wm[w]--\n            } else {\n                break;\n            }\n        }\n        if (Object.values(wm).every(n => n === 0)) ans.push(i);\n    }\n    return ans;\n};\n'''\n时间复杂度O（n）\n空间复杂度O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107689886","body":"```\r\nCode（python）：\r\ndef solve(nums, k):\r\n   rem = (sum(nums) + k) % k\r\n   if rem == 0:\r\n      return 0\r\n   n, presum = len(nums), 0\r\n   mp = {0: -1}\r\n   res = n\r\n   for i in range(n):\r\n      presum += nums[i]\r\n      m = (presum + k) % k\r\n      mp[m] = i\r\n      if (m - rem + k) % k in mp:\r\n         res = min(res, i - mp[(m - rem + k) % k])\r\n   return res if res != n else -1\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107978290","body":"Idda：快慢指针\r\n\r\nCode：\r\n```\r\nvar middleNode = function(head) {\r\n    var slow = head;\r\n    var fast = head;\r\n    while(fast && fast.next){\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n    }\r\n    return slow;\r\n};\r\n```\r\n\r\n时间复杂度O（n）\r\n空间复杂度O（1）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109220573","body":"Idea:还是双指针思路，快指针探路，慢指针留守。\n\nCode:\n```\nvar removeDuplicates = function(nums) {\n    if(nums.length == 0){\n        return 0 ;\n    }\n    var slow = 0, fast = 0;\n    while(fast < nums.length){\n        if(nums[slow] != nums[fast]){\n            slow++;\n            nums[slow] = nums[fast];\n        }\n        fast++;\n    }\n    return slow+1\n    // 数组长度为索引 + 1\n};\n```\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110499293","body":"Idea:二分查找\n\nCode:\n```\nvar searchInsert = function(nums, target) {\n    var left = 0 , right = nums.length-1;\n    while(left <= right){\n        var mid = ((right - left) >> 1) + left;\n        if(nums[mid] == target){\n            return mid;\n        }else if(nums[mid] < target){\n            left = mid + 1;\n        }else{\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n```\n\n时间复杂度：O（logn）\n空间复杂度：O（1）\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086582373","body":"### 思路\n\n第一想法是以当前字符为中心，然后向左右两边搜索，搜索到的第一个C即可得到当前字符到C的最小距离。\n但是这样的算法复杂度是O(N^2)\n\n第二想法是首先将C在S中的索引全部找出来，这样就可以用当前字符的索引直接减到C的索引，从而得到一个最小值\n这样的算法复杂度就是O(N)。下面的代码是这个想法的实现。\n\n后来又看了一下官方的题解，发现是遍历正、反二次就可以解决了。果然是我太菜了。。。。。。\n\n### 代码\n\n\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，最坏时，C和S的长度一样","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797464","body":"### 思路\n粗看还蛮简单的，直接使用数组来模拟，push和pop操作都在数组尾操作，时间上都是O(1)，inc操作是O(k)\n按此实现并提交，发现只击败40%，看来还有改进空间。\n\npush和pop都已经是O(1)了，那就只有inc可以改进。一时想不出来，查看是解后，发现只记录增量及位置，\n直到需要返回的栈顶元素的时候才计算真实的值，这样每个pop操作也只计算一次，不影响pop的执行效率。\n按此方法，inc的执行效率也改进为O(1)。\n\n### 代码\n\n\n```Go\ntype CustomStack struct {\n    data []int\n    add []int\n    idx int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{data: make([]int, maxSize), add: make([]int, maxSize), idx: 0}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.hasSpace() {\n        this.data[this.idx] = x\n        this.idx++\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if !this.hasElement() {\n        return -1\n    }\n    \n    this.idx--\n    element := this.data[this.idx] + this.add[this.idx]\n\n    if this.idx > 0 {\n        this.add[this.idx - 1] += this.add[this.idx]\n    }\n    this.add[this.idx] = 0\n\n    return element\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    // for i := 0; i < this.idx && i < k; i++ {\n        // this.data[i] += val\n    // }\n    if !this.hasElement() {\n        return\n    }\n\n    if k >= this.idx {\n        this.add[this.idx - 1] += val\n    } else {\n        this.add[k - 1] += val\n    }\n}\n\nfunc (this *CustomStack) hasSpace() bool {\n    return this.idx < cap(this.data)\n}\n\nfunc (this *CustomStack) hasElement() bool {\n    return this.idx > 0\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N), N为栈最大空间。因为需要一个额外的辅助数组add","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087604329","body":"### 思路\n一开始没看到有嵌套的情况，我还想这个题还蛮简单的，写出来的第一版当然不通过。\n第二版将待解析的字符串先入栈，碰到右括号才弹出，这样可以解析出最内层的字符串。\n若还有外层的字符串未解析，则继续将解析出来内层字符串写回到栈中，若已经到达最\n外层了，则可以将此解析后字符串写到结果中\n\n### 代码\n\n\n```Go\n\nfunc decodeString(s string) string {\n\tvar ret bytes.Buffer\n\tvar cache []byte\n\n\tfindRepeatNumString := func() (int, int, int, int) {\n\t\tnumBegin, numEnd, sBegin, sEnd  := -1, -1, -1, -1\n\n\t\tsEnd = len(cache) - 1\n\t\tfor j := sEnd; j >=0; j-- {\n\t\t\tif numEnd == -1 && cache[j] >= '0' && cache[j] <= '9' {\n\t\t\t\tsBegin = j + 2\n\t\t\t\tnumEnd = j + 1\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif numEnd != -1 && (cache[j] < '0' || cache[j] > '9') {\n\t\t\t\tnumBegin = j + 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif numBegin == -1 {\n\t\t\tnumBegin = 0\n\t\t}\n\n\t\treturn numBegin, numEnd, sBegin, sEnd\n\t}\n\n\tdecodeSubString := func() {\n\t\tvar subString bytes.Buffer\n\n\t\tnumBegin, numEnd, sBegin, sEnd := findRepeatNumString()\n\t\tnum, _ := strconv.Atoi(string(cache[numBegin:numEnd]))\n\t\tfor i := 0; i < num; i++ {\n\t\t\tsubString.Write(cache[sBegin:sEnd])\n\t\t}\n\n\t\tif numBegin == 0 {\n\t\t\tret.Write(subString.Bytes())\n\t\t\tcache = cache[:0]\n\t\t} else {\n\t\t\tcache = append(cache[:numBegin], subString.Bytes()...)\n\t\t}\n\t}\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif len(cache) == 0 && s[i] >= 'a' && s[i] <= 'z' {\n\t\t\tret.WriteByte(s[i])\n\t\t\tcontinue\n\t\t}\n\n\t\tcache = append(cache, s[i])\n\t\tif s[i] == ']' { decodeSubString() }\n\t}\n\n\treturn ret.String()\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：如果没有嵌套的情况，时间复杂度应该是O(S)，即解码后的长度。嵌套的情况我也不太确定\n- 空间复杂度：O(S)，即解码后的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088203400","body":"### 思路\n\n见代码\n\n### 代码\n\n\n```Go\ntype MyQueue struct {\n\tinput *MyStack\n\toutput *MyStack\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tinput: new(MyStack),\n\t\toutput: new(MyStack),\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.input.Push(x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\t// 题目保证不会在空的栈上面调用pop/peek\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Pop()\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Peek()\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif this.input.Size() != 0 || this.output.Size() != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (this *MyQueue) inputToOutput() {\n\tfor !this.input.IsEmpty() {\n\t\tthis.output.Push(this.input.Pop())\n\t}\n}\n\ntype MyStack struct {\n\tdata []int\n}\n\nfunc (receiver *MyStack) Pop() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\n\tv := receiver.data[len(receiver.data) - 1]\n\treceiver.data = receiver.data[:len(receiver.data) - 1]\n\treturn v\n}\n\nfunc (receiver *MyStack) Peek() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\n\treturn receiver.data[len(receiver.data) - 1]\n}\n\nfunc (receiver *MyStack) Push(v int) {\n\treceiver.data = append(receiver.data, v)\n}\n\nfunc (receiver *MyStack) Size() int {\n\treturn len(receiver.data)\n}\n\nfunc (receiver *MyStack) IsEmpty() bool {\n\treturn len(receiver.data) == 0\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty是O(1)。pop和peek由于有一个遍历动作，看上去是N(N), 但是随后的pop/peek就是O(1)了，所以，平摊一下的话，应该就是O(1)。综上，平均时间复杂度为O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1094232529","body":"### 思路\n\n参考题解，利用单调栈特性解决\n\n### 代码\n\n\n```Go\nfunc maxChunksToSorted(arr []int) int {\n\tvar cache []int\n\tfor _, item := range arr {\n\t\tlastIdx := len(cache) - 1\n\t\tif len(cache) != 0 && cache[lastIdx] > item {\n\t\t\tmax := cache[lastIdx]\n\t\t\tfor ; lastIdx >= 0; lastIdx-- {\n\t\t\t\tif cache[lastIdx] <= item {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache = append(cache[:lastIdx + 1], []int{max}...)\n\t\t} else {\n\t\t\tcache = append(cache, item)\n\t\t}\n\t}\n\treturn len(cache)\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091768715","body":"### 思路\n\n先计算链表长度，与k取模后得到真正需要旋转的次数，但是并不需要真的旋转这么多次。\n而是利用快慢指针直接找到旋转n次后的那个新的头节点，从该处断后，最后将原链表尾\n指向原链表头即可\n\n### 代码\n\n\n```Go\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil {return head}\n\n\tvar listLen int\n\tvar p1 = head\n\tfor p1 != nil {\n\t\tlistLen++\n\t\tp1 = p1.Next\n\t}\n\n\tdiff := k % listLen\n\tif diff == 0 {\n\t\treturn head\n\t}\n\tp2 := head\n\tp1 = head\n\tfor i := 0; i < diff; i++ {\n\t\tp1 = p1.Next\n\t}\n\tfor p1.Next != nil {\n\t\tp1 = p1.Next\n\t\tp2 = p2.Next\n\t}\n\n\tnewHead := p2.Next\n\tp2.Next = nil\n\tp1.Next = head\n\treturn newHead\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092916730","body":"### 思路\n\n见代码中的描述\n\n### 代码\n\n\n```Go\nfunc swapPairs(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\n\tnewHead := head.Next\n\t// 交换之前\n\t// ... -> 3 -> 4 -> 5 ->   6 -> 7 -> ...\n\t//        ^    ^    ^      ^\n\t//        l    p   pp     ppp\n\t// 交换之后\n\t// ... -> 3 -> 5 -> 4 ->   6 -> 7 -> ...\n\t//             ^    ^      ^    ^\n\t//             l    p      pp   ppp\n\tvar l *ListNode\n\tp := head\n\tpp := p.Next\n\tppp := pp.Next\n\tfor {\n\t\tp.Next = ppp\n\t\tpp.Next = p\n\t\tif l != nil {\n\t\t\tl.Next = pp\n\t\t}\n\t\tl = p\n\n\t\tif ppp == nil {\n\t\t\tbreak\n\t\t}\n\t\tp = ppp\n\t\tpp = p.Next\n\t\tif pp == nil {\n\t\t\tbreak\n\t\t}\n\t\tppp = pp.Next\n\t}\n\n\treturn newHead\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093600210","body":"### 思路\n\n有二种基本思路：<br>\n1. 将链表转换为数组，然后按二分法进行递归<br>\n2. 不转换为链表，每次都遍历链表找中点，按中点分为左右二个子链表递归<br>\n<br>\n第一种思路相当于使用空间换时间，时间复杂度为O(N) + O(N) = O(N)，第一O(N)为转换为链表的过程，第二个为构造树的过程<br>\n第二种思路的时间复杂度为O(NlogN)\n\n### 代码\n\n\n```Go\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tvar buildBST func([]int) *TreeNode\n\tbuildBST = func(data []int) *TreeNode {\n\t\tif data == nil || len(data) == 0 {return nil}\n\n\t\trootIdx := len(data) / 2\n\t\troot := &TreeNode{Val: data[rootIdx]}\n\t\tif rootIdx > 0 {\n\t\t\troot.Left = buildBST(data[:rootIdx])\n\t\t}\n\t\tif rootIdx < len(data) - 1 {\n\t\t\troot.Right = buildBST(data[rootIdx + 1:])\n\t\t}\n\n\t\treturn root\n\t}\n\n\tvar arr []int\n\tfor head != nil {\n\t\tarr = append(arr, head.Val)\n\t\thead = head.Next\n\t}\n\treturn buildBST(arr)\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094159652","body":"### 思路\n\n利用这样一条性质：若相遇，则经过的路径长度必相等\n\n### 代码\n\n\n```Go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    var aHead, bHead = headA, headB\n    for aHead != nil && bHead != nil {\n        if aHead == bHead {return aHead}\n        aHead = aHead.Next\n        bHead = bHead.Next\n\n        if aHead == nil && bHead != nil {\n            aHead = headB\n        } else if bHead == nil && aHead != nil {\n            bHead = headA\n        }\n    }\n    return nil\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N+M)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096828115","body":"### 思路\n\nGet要到达O(1)的时间复杂度，根据题意，可以使用一个数组cache来保存数据，key即为索引  \n\nPut要到达O(1)的时间复杂度，则必须在O(1)的时间复杂度内查找到待删除元素。自然的，\n按元素的访问时间排序，串成一个链表used，最近访问的排在最前面，依次类推，则该链表的\n最后一个元素就是待删除的元素。   \n\n这个想法很好，但是还有一个问题：如果某个元素被访问了，则该元素需要移到该链表头，此\n时怎么查找该元素在链表中的什么位置呢？  \n\n为了快速查找被访问元素在链表used中的位置，我们还需要有一个映射来用来维护元素到链表\nused中的位置关系，将这个关系命名为toUsed。从而得到如下更新算法:  \n\n1. 某元素被Get时，使用该元素作为key，从映射关系toUsed中查找该元素在used中的位置\n2. 将该元素移动到used链表头\n\n\n### 代码\n\n\n```Go\ntype LRUCache struct {\n\tcache []int\n\tused *list.List\n\ttoUsed map[int]*list.Element\n\tcap int\n\tlen int\n}\n\nconst MaxCacheNum = 10000\nconst NotFound = -1\n\nfunc Constructor(capacity int) LRUCache {\n\tcache := LRUCache{\n\t\tcache: make([]int, MaxCacheNum),\n\t\tused:  list.New(),\n\t\ttoUsed: make(map[int]*list.Element, 0),\n\t\tcap: capacity,\n\t\tlen: 0,\n\t}\n\tfor i := 0; i < MaxCacheNum; i++ {\n\t\tcache.cache[i] = -1\n\t}\n\treturn cache\n}\n\nfunc (this *LRUCache) Get(key int) int {\n\tvalue := this.cache[key]\n\tif value != NotFound {\n\t\tthis.access(key)\n\t}\n\treturn value\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\texist := this.cache[key]\n\tif exist != NotFound {\n\t\tthis.cache[key] = value\n\t\tthis.access(key)\n\t\treturn\n\t}\n\t // 不存在，需要判断是否溢出\n\tif this.len + 1 > this.cap {\n\t\tr := this.used.Remove(this.used.Back()).(int)\n\t\tdelete(this.toUsed, r)\n\t\tthis.cache[r] = -1\n\t\tthis.len--\n\t}\n\n\tthis.cache[key] = value\n\tthis.len++\n\tthis.access(key)\n\treturn\n}\n\nfunc (this *LRUCache) access(key int) {\n\tptr, ok := this.toUsed[key]\n\tif ok {\n        this.used.MoveToFront(ptr)\n\t\treturn\n\t}\n\tthis.used.PushFront(key)\n\tthis.toUsed[key] = this.used.Front()\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098078948","body":"### 思路\n\n后序直接递归即可\n\n\n### 代码\n\n\n```Go\nfunc maxDepth(root *TreeNode) int {\n    if root == nil {return 0}\n    return 1 + max(maxDepth(root.Left), maxDepth(root.Right))\n}\n\nfunc max(i, j int) int {\n    if i >= j {return i}\n    return j\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)，栈除外","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099779163","body":"### 思路\n\n按照二叉树结构同时递归比较二棵树即可\n\n### 代码\n\n\n```Go\n\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\n    if p == nil && q == nil { return true }\n    if p != nil && q != nil && p.Val == q.Val { return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right) }\n    return false\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)，不计堆栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100578102","body":"### 思路\n\n前序遍历，每找到一个叶子，判断是否大于之前找到的叶子节点的深度。\n若是大于的话，则替换为当前的叶子节点的深度和值，遍历完所有叶子\n节点即得到最左值\n\n\n### 代码\n\n\n```Go\nfunc findBottomLeftValue(root *TreeNode) int {\n    var height, value int\n\n    var search func(*TreeNode, int)\n    search = func(node *TreeNode, hh int) {\n        hh++\n        if node.Left == nil && node.Right == nil {\n            if hh > height {\n                height = hh\n                value = node.Val\n            }\n            return\n        }\n\n        if node.Left != nil { search(node.Left, hh) }\n        if node.Right != nil { search(node.Right, hh) }\n    }\n\n    search(root, 0)\n    return value\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)，栈除外","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100817765","body":"### 思路\n\n序列化时，按层遍历，此种方法需要一个队列来辅助遍历过程。初始时，将根节点入队列。\n后序每遍历到一个节点，执行二个操作：将该节点的值输出到最终的结果缓存中；将该节\n点的左、右孩子加入到队列中。最后，在输出之前截断末尾多余的分隔符即可。\n\n反序列化时，也按层来还原。对于每个节点，都从输入数据中取其左、右孩子节点，重复\n此步骤即可。唯一需要注意的是，当左、右孩子的值为空字符串时，不需要实际产生左、\n右孩子\n\n\n### 代码\n\n\n```Go\ntype Codec struct {\n    \n}\n\nfunc Constructor() Codec {\n    return Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n    if root == nil {return \"\"}\n\n\tret := strings.Builder{}\n\tqueue := list.New()\n\tqueue.PushBack(root)\n\tfor queue.Len() != 0 {\n\t\tnode := queue.Remove(queue.Front()).(*TreeNode)\n\t\tif node != nil {\n            ret.WriteString(strconv.Itoa(node.Val))\n            ret.WriteString(\",\")\n\t\t} else {\n            ret.WriteString(\",\")\n\t\t\tcontinue\n\t\t}\n\n\t\tqueue.PushBack(node.Left)\n\t\tqueue.PushBack(node.Right)\n\t}\n\n\treturn strings.Trim(ret.String(), \",\")\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {   \n    if data == \"\" {return nil}\n\t\n    var cache []*TreeNode\n\tnodes := strings.Split(data, \",\")\n\tnodeVal, _ := strconv.Atoi(nodes[0])\n\troot := &TreeNode{Val: nodeVal}\n\tcache = append(cache, root)\n    cacheIdx := 0\n    cur := cache[cacheIdx]\n    left := true\n\tfor i := 1; i < len(nodes); i++ {\n        if nodes[i] == \"\" {\n            if left {\n                left = false\n            } else {\n                left = true\n                cacheIdx++\n                cur = cache[cacheIdx]\n            }\n            continue\n        }\n\n\t    nodeVal, _ := strconv.Atoi(nodes[i])\n        node := &TreeNode{Val: nodeVal}\n        cache = append(cache, node)\n\n        if left {\n            cur.Left = node\n            left = false\n        } else {\n            cur.Right = node\n            left = true\n            cacheIdx++\n            cur = cache[cacheIdx]\n        }\n\t}\n\t\n\treturn root\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101503232","body":"### 思路\n\n中序遍历，给每个节点产生一个(row, col)坐标，然后收集坐标进行排序即可。\n但是排序那段代码看上去比较的啰嗦，后面看看其它答案优化一下吧\n\n\n### 代码\n\n\n```Go\nfunc verticalTraversal(root *TreeNode) [][]int {\n    // map[column]map[line][]int\n\tvar nodes = make(map[int]map[int][]int, 0)\n\n\tvar travel func(node *TreeNode, row, col int)\n\ttravel = func(node *TreeNode, row, col int) {\n\t\tif node == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := nodes[col]; !ok {\n\t\t\tnodes[col] = map[int][]int{row: {node.Val}}\n\t\t} else if _, ok = nodes[col][row]; !ok {\n\t\t\tnodes[col][row] = []int{node.Val}\n\t\t} else {\n\t\t\tnodes[col][row] = append(nodes[col][row], node.Val)\n\t\t}\n\n\t\ttravel(node.Left, row + 1, col - 1)\n\t\ttravel(node.Right, row + 1, col + 1)\n\t}\n\ttravel(root, 0, 0)\n    // fmt.Printf(\"nodes: %+v\\n\", nodes)\n\t\n\tret := make([][]int, 0, len(nodes))\n\t\n\t// 列排序\n\tcolKeys := make([]int, 0, len(nodes))\n\tfor k := range nodes {\n\t\tcolKeys = append(colKeys, k)\n\t}\n\tsort.Ints(colKeys)\n    // fmt.Printf(\"colKeys: %+v\\n\", colKeys)\n\tfor _, k := range colKeys {\n\t\t// 行排序\n\t\trowKeys := make([]int, 0, len(nodes[k]))\n\t\tfor i := range nodes[k] {\n\t\t\trowKeys = append(rowKeys, i)\n\t\t}\n\t\tsort.Ints(rowKeys)\n        // fmt.Printf(\"colKey: %d, rowKeys: %+v\\n\", k, rowKeys)\n\t\t\n        colRet := make([]int, 0)\n\t\tfor _, r := range rowKeys {\n\t\t\trowData := nodes[k][r]\n\t\t\tsort.Ints(rowData)\n\t\t\tcolRet = append(colRet, rowData...)\n\t\t}\n        ret = append(ret, colRet)\n\t}\n\t\n\treturn ret\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：分析不出来。。。。\n- 空间复杂度：O(N)。因为每个节点的坐标都需要保存，所以是O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102144800","body":"### 思路\n\n哈希记录差值与索引，遍历nums的同时，判断nums[i]的值是否在哈希表中，\n若在则找到二数之和等于目标值，返回二个数的索引即可\n\n### 代码\n\n\n```Go\n\nfunc twoSum(nums []int, target int) []int {\n    record := make(map[int]int, 0)\n\n    for idx, i := range nums {\n        if last, ok := record[i]; ok {\n            return []int{last, idx}\n        }\n        record[target - i] = idx\n    }\n\n    return nil\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1107317885","body":"### 思路\n\n一个很直接的想法就是找到所有的无重复子串，比较后即可得到最长的那个无重复子串。  \n\n每个子串的长度可以使用 **终点坐标 - 起点坐标** 得到，这提示我们需要二个指针。  \n而为了快速得到一个子串中是否有重复的字符，需要一个哈希表来保存当前子串中有哪些\n字符。  \n\n因此，可以得到下面的算法：  \n\n1. 使用maxLen来记录最大无重复字符串，初始为0；\n2. 右指针一直向左滑动，直到遇到第一个重复的字符或者到达字符串尾。\n3. 计算 **[左指针，右指针]** 所表示的字符串大小，并根据是否大于 maxLen 来更\n新 maxLen 的值\n4. 左指针向右滑到到重复字符的下一个字符位置，然后重复执行 步骤2\n\n\n### 代码\n\n\n```Go\nfunc lengthOfLongestSubstring(s string) int {\n\tvar cache [256]bool\n\tmaxLen := 0\n\tbegin, end := 0, 0\n\n\tfor end < len(s) {\n\t\tif !cache[s[end]] {\n\t\t\tcache[s[end]] = true\n\t\t\tend++\n\t\t\tcontinue\n\t\t}\n\n\t\ttmp := end - begin\n\t\tif tmp > maxLen {\n\t\t\tmaxLen = tmp\n\t\t}\n\n\t\t// begin需要前进到s[end]的下一个字符\n\t\tfor begin <= end {\n\t\t\tcache[s[begin]] = false\n\t\t\tif s[begin] == s[end] {\n\t\t\t\tbegin++\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tbegin++\n\t\t}\n\t}\n\ttmp := end - begin\n\tif tmp > maxLen {\n\t\tmaxLen = tmp\n\t}\n\n\treturn maxLen\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108253664","body":"### 思路\n\n快慢指针遍历一次即可\n\n### 代码\n\n\n```Go\n\nfunc middleNode(head *ListNode) *ListNode {\n    slow, fast := head, head\n    for {\n        if fast.Next != nil {\n            fast = fast.Next\n            slow = slow.Next\n        }\n        if fast.Next == nil {\n            break\n        }\n        fast = fast.Next\n    }\n\n    return slow\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109202330","body":"### 思路\n\n直接遍历，相当直接\n\n### 代码\n\n\n```Go\n\nfunc removeDuplicates(nums []int) int {\n    if len(nums) == 0 { return 0}\n\n    var pos int\n    for i := 1; i < len(nums); i++ {\n        if nums[i] != nums[pos] {\n            pos++\n            nums[pos] = nums[i]\n        }\n    }\n\n    return pos + 1\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111950320","body":"### 思路\n\n使用类似单调递减栈的单调减减队列，在该队列最大长度为K，保存每个窗口长度内的最大值及\n排在该最大值后面的所有较小的值。从而，队列首即为每个窗口内的最大值。\n\n\n### 代码\n\n\n```Go\n\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tvar ret []int\n\n\tqq := newMyQueue(k)\n\tfor i := 0; i < len(nums); i++ {\n\t\tqq.add(nums[i], i)\n\t\tif i >= k - 1 {\n\t\t\tret = append(ret, qq.peek())\n\t\t}\n\t}\n\n\treturn ret\n}\n\ntype dd struct{val int; idx int}\ntype myQueue struct {\n\tdata []*dd\n\twin int\n}\n\nfunc newMyQueue(win int) *myQueue {\n\treturn &myQueue{data: []*dd{{val: math.MinInt32, idx: 0}}, win: win}\n}\n\nfunc (q *myQueue) add(val, idx int) {\n\t// 弹出数组中所有小于val的值\n\tif idx - q.data[0].idx >= q.win {\n\t\tq.data = q.data[1:]\n\t}\n\n\tvar i int\n\tfor i = q.len() - 1; i >= 0; i-- {\n\t\tif q.data[i].val >= val {\n\t\t\tq.data = q.data[:i + 1]\n\t\t\tbreak\n\t\t}\n\t}\n\tif i == -1 {\n\t\tq.data = q.data[:0]\n\t}\n\tq.data = append(q.data, &dd{val: val, idx: idx})\n}\n\nfunc (q *myQueue) peek() int {\n\treturn q.data[0].val\n}\n\nfunc (q *myQueue) len() int {\n\treturn len(q.data)\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：maxSlidingWindow函数中的循环，每个元素都会被访问一次；而每个元素在\nq.add函数中最多会有K次循环，所以时间复杂度是 O(nk) ?? 如果一个元素在q.add中会循环\nk次，那么，在该元素之前的k个元素，其在q.add函数必须只循环一次，所以摊到每个元素中\n还是只循环一次，从而q.add可以认为是一个 O(1) 的操作。最终，时间复杂度为 O(N)\n- 空间复杂度：O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113296779","body":"### 思路\n\n对于trust数组中的任意一个值[ai, bi]，记录ai不是法官，同时记录\nbi被信任的票数。遍历完trust数组之后，查看是否有人没有信任过任\n何人并且被n-1个人信任\n\n\n### 代码\n\n\n```Go\nfunc findJudge(n int, trust [][]int) int {\n    var candidate = make([]bool, n+1)\n    var vote = make([]int, n+1)\n\n    for _, item := range trust {\n        candidate[item[0]] = true\n        vote[item[1]]++\n    }\n\n    for i := 1; i <= n; i++ {\n        if !candidate[i] && vote[i] == n - 1 {return i}\n    }\n\n    return -1\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winrunwang":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086593212","body":"思路:\n遍历一次，用2个临时变量存储指针信息。中间第二个for循环调整距离问题\npublic int[] shortestToChar(String s, char c) {\n        int first = -1;\n        int temp = -1;\n        int n  = s.length();\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            char t = s.charAt(i);\n            if(t == c){\n                res[i] = 0;\n                if(first == -1){\n                    first = i;\n                }\n                if(temp!= -1){\n                    for (int j = temp; j < i; j++) {\n                        res[j] = Math.min(i-j,res[j]);\n                    }\n                }\n                temp = i;\n            }\n            if(first != -1){\n                res[i] = i-temp;\n            }\n        }\n        for (int i = 0; i < first; i++) {\n            res[i] = first - i;\n        }\n        return res;\n    }\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088756960","body":"设立头尾。每次更新的时候头尾做个转换即可\n\n\nStack<Integer> head,tail;\n\n    public Solution232() {\n        head = new Stack<>();\n        tail = new Stack<>();\n\n    }\n\n    public void push(int x) {\n          tail.push(x);\n    }\n\n    public int pop() {\n         peek();\n         return head.pop();\n    }\n\n    public int peek() {\n        if (head.isEmpty())\n            // 把 s1 元素压入 s2\n            while (!tail.isEmpty())\n                head.push(tail.pop());\n        return head.peek();\n    }\n\n    public boolean empty() {\n      return head.isEmpty() && tail.isEmpty();\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091777103","body":"思路\n第一遍遍历链表得到链表长度和最后一个节点，判断链表长度和k的数量关系，将最后一个节点连接头节点，闭合成环，只需再遍历一次链表，找到需要断开的位置即可。\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null|| k == 0)  return head;\n        int n = 0;\t\t\t   //链表的长度\n        ListNode tail = null;  //尾节点\n        for(ListNode p = head; p != null ; p = p.next){\n            tail = p;\n            n++;\n        }\n        k %= n;\n        ListNode p = head;\n        for(int i = 0; i < n - k - 1; i++)  p = p.next;   //找到链表的第n-k个节点\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;  //返回新的头节点\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094272547","body":"思路:链表A走完后从B的起点开始走。B走完后从A的起点开始走。如果相遇说明相交。如果没有就说明没有。\n\n\n public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n         if(headA == null || headB == null){\n              return null;\n         }\n         ListNode PA = headA;\n         ListNode PB = headB;\n         while(PA != PB){\n             PA = PA == null?headB:PA.next;\n             PB = PB == null?headA:PB.next;\n         }\n         return PA;\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096898487","body":"就是hash表和链表，一般使用LinkedHashMap。代码太多了。不贴出来了\n\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101483321","body":"DFS + 优先级队列\n\n public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107437206","body":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int len = s.length();\n        int wordsNum = words.length;\n        int wordLen = words[0].length();\n        Map<String, Integer> map = new HashMap<>();\n        List<Integer> res = new LinkedList<>();\n        for (int i = 0; i < wordsNum; i++) {\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\n        }\n        for (int i = 0; i < len - wordLen * wordsNum + 1; i++) {\n            int left = i;\n            Map<String, Integer> tmp = new HashMap<>();\n            int count = 0;\n            while (left + wordLen <= len) {\n                String word = s.substring(left, left + wordLen);\n                if (!map.containsKey(word)) {\n                    break;\n                }\n                tmp.put(word, tmp.getOrDefault(word, 0) + 1);\n                if (tmp.get(word) > map.get(word)) {\n                    break;\n                }\n                count++;\n                left += wordLen;\n            }\n            if (count == wordsNum) {\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086601300","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n            char[] array = s.toCharArray();\n            int len = s.length();\n            int[] res = new int[len];\n            Arrays.fill(res, len);\n            int idx_c = -1;\n            for(int i = 0; i < len ; i++) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    res[i] = 0;\n                    continue;\n                }\n                if(idx_c != -1) {\n                    res[i] = i - idx_c;\n                }\n            }\n            for(int i = len - 1; i >= 0 ; i--) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    continue;\n                }\n                if(idx_c > i) {\n                    res[i] = Math.min(res[i], idx_c - i);\n                }\n                \n            }\n            return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086802767","body":"class CustomStack {\n\n    int[] data;\n    int[] add;\n    int maxSize;\n    int curSize;\n\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n        add = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n    \n    public void push(int x) {\n        if(curSize == maxSize){\n            return;\n        }\n        data[curSize++] = x;\n    }\n    \n    public int pop() {\n        if(curSize == 0) return -1;\n        int res = data[curSize - 1] + add[curSize - 1];\n        if(curSize > 1) {\n            add[curSize - 2] += add[curSize - 1]; \n        }\n        add[curSize - 1] = 0;\n        curSize--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        if(curSize == 0) return;\n        add[Math.min(k, curSize) - 1] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087293757","body":"class Solution {\n    public String decodeString(String s) {\n        // 碰到【 入栈字母  碰到 】出栈字母并计算\n        Deque<String> cStack = new LinkedList<>();   // 存储的是[ 后  数字前的字符串  如  2[ab3[cd4[ef]]] 中的ab  cd  依次入栈  \n        Deque<Integer> nStack = new LinkedList<>();  // 存储的是[ 前的数字  如上例中的 2 3 4\n        char[] arr = s.toCharArray();\n        // 难点  数字可能不止一位数\n        int num = 0;\n        String piece = \"\";\n        for(char c : arr) {\n            if ( c >= '0' && c <= '9') {\n                num = num * 10 + (c - '0');\n            } else if (c == '[') {\n                nStack.push(num);\n                cStack.push(piece);\n                num = 0;\n                piece = \"\";\n            } else if (c == ']') {\n                String inner = piece;\n                int cnt = nStack.pop() - 1;\n                for(int i = 0 ; i < cnt; i ++) {\n                    piece += inner;\n                }\n                piece = cStack.pop() + piece;\n            } else {\n                piece += c;\n            }\n        }\n        return piece;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088220824","body":"class MyQueue {\n\n    Deque<Integer> pushStack;\n    Deque<Integer> popStack;\n\n    public MyQueue() {\n        pushStack = new LinkedList<>();\n        popStack = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        if(popStack.isEmpty()){\n            transfer();\n        }\n        if(popStack.isEmpty()) \n        return -1;\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        if(popStack.isEmpty()){\n            transfer();\n        }\n        if(popStack.isEmpty()) \n        return -1;\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n\n    private void transfer() {\n        while(!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090356229","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n       Deque<Integer> stack = new LinkedList<>();\n       for(int i : arr) {\n           if(!stack.isEmpty() && i < stack.peek()) {\n               int top = stack.pop();\n               while(!stack.isEmpty() && i < stack.peek())  {\n                   stack.pop();\n               }\n               stack.push(top);\n           } else {\n               stack.push(i);\n           }\n       }\n       return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091476462","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0) return head;\n        int l = 1 ;\n        ListNode dummyHead = head;\n        while(head.next != null) {\n            head = head.next;\n            l++;\n        }\n        ListNode tail = head;\n        k = k % l;\n        if(k == 0) return dummyHead;\n        l -= k;\n\n        head = dummyHead;\n        while(--l > 0) {\n            head = head.next;\n        }\n\n        ListNode newHead = head.next;\n        head.next = null;\n        tail.next = dummyHead;\n        return newHead;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092709666","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(-1, head);\n        ListNode cur = dummyHead;\n        while(cur.next != null && cur.next.next != null) {\n            ListNode next2 = cur.next.next;\n            ListNode next3 = cur.next.next.next;\n            cur.next.next = next3;\n            next2.next = cur.next;\n            cur.next = next2;\n            cur = next2.next; // cur 指向两个要交换节点的前一个节点\n        }\n        return dummyHead.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093598085","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null ) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = null, slow = head, fast = head;\n        while(fast!= null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        pre.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094510782","body":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(fast != null && fast.next !=null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow) break;\n        }\n        if(fast == null || fast.next == null) return null;\n        // 相遇时 f = 2s  f = s + nb   s=nb  入口点为a + nb 因此slow 走a步到达入口点  两个指针再次一起走就行\n        fast = head;\n        while(fast != slow) {\n            fast =fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095834556","body":"class LRUCache {\n    // get put O1  -> hashMap\n    // LRU  -> list\n    Map<Integer, DoubleEndListNode> map; \n    DoubleEndList list;\n    int capacity;\n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        list = new DoubleEndList();\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n       DoubleEndListNode node = map.get(key);\n       if(node == null) return -1;\n       int val = node.val;\n       list.move2Head(node);\n       return val;\n    }\n    \n    public void put(int key, int value) {\n        DoubleEndListNode node = map.get(key);\n        if(node != null) {\n            node.val = value;\n            list.move2Head(node);\n            return;\n        }\n        if(map.size() == capacity) {\n            // remove tail\n            DoubleEndListNode remove = list.removeLast();\n            if(remove != null) {\n                map.remove(remove.key);\n            }\n        }\n        DoubleEndListNode newNode = new DoubleEndListNode(key, value);\n        list.addHead(newNode);\n        map.put(key, newNode);\n    }\n\n    // 双端链表用于将某个Node前后连接起来 \n    private class DoubleEndListNode{\n        DoubleEndListNode prev;\n        DoubleEndListNode next;\n        int val;\n        int key;\n\n        DoubleEndListNode() {}\n        DoubleEndListNode(int key, int val) {this.key = key; this.val = val;}\n    }\n\n    private class DoubleEndList{\n        DoubleEndListNode head;\n        DoubleEndListNode tail;\n        DoubleEndList() {\n            head = new DoubleEndListNode();\n            tail = new DoubleEndListNode();\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        public void move2Head(DoubleEndListNode node) {\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n            addHead(node);\n        }\n\n        public DoubleEndListNode removeLast() {\n            DoubleEndListNode remove = tail.prev;\n            DoubleEndListNode last = tail.prev.prev;\n            if(last == null) return null;\n            last.next = tail;\n            tail.prev = last;\n            return remove;\n        }\n\n        public void addHead(DoubleEndListNode node) {\n            node.next = head.next;\n            node.prev = head;\n            head.next = node;\n            node.next.prev = node;\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097685923","body":"class Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        if(root.left == null && root.right == null) return 1;\n        int leftDepth = maxDepth(root.left) ;\n        int rightDepth = maxDepth(root.right);\n        return Math.max(leftDepth, rightDepth) + 1; // 每次加上自身高度  否则一直往下递归  直到最终两种节点\n    }\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098689637","body":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true; // 都为空\n        else if( p == null || q == null) return false; // 一个空 一个不空\n        return p.val ==q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right); // 值相等且左右子树相等\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099795710","body":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return cursion(root, 0);\n    }\n\n    public int cursion(TreeNode node, int num) {\n        int cur = num*10 + node.val;\n        if(node.left == null && node.right == null) return cur;// 叶子节点\n        if(node.left == null) return cursion(node.right, cur); // 右分支\n        if(node.right == null) return cursion(node.left, cur); // 左分支\n        return cursion(node.left, cur) + cursion(node.right, cur); // 二叉\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100579142","body":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int[] res = new int[]{-1, 0};\n        dfs(root, res, 0);\n        return res[1];\n    }\n\n    // 二元组  level  val\n    public void dfs(TreeNode node, int[] bottomLeft, int h) { // h 水平坐标\n        if(h > bottomLeft[0]){\n            bottomLeft[0] = h;\n            bottomLeft[1] = node.val;\n        } \n        if(node.left != null) dfs(node.left, bottomLeft, h + 1);\n        if(node.right != null) dfs(node.right, bottomLeft, h + 1);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100903009","body":"public class Codec {\n    private static final String NULL = \"NULL\";\n    private static final String SPLITTER = \",\";\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) return NULL;\n        return root.val \n                + SPLITTER \n                + serialize(root.left)\n                + SPLITTER \n                + serialize(root.right);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(SPLITTER)));\n        return dfs(queue);\n    }\n\n    private TreeNode dfs(Queue<String> queue) {\n        String val = queue.poll();\n        // Integer 每次赋值或 ++ 引用会被改变 因此不能够 ++ 原因 内部是 final int value;\n        if(NULL.equals(val)) {\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        node.left = dfs(queue);\n        node.right = dfs(queue);\n        return node;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101059238","body":"package redo.mistakescollection;\n\nimport redo.base.TreeNode;\n\nimport java.util.*;\n\n/**\n * 本质 ： dfs or bfs遍历 + 排序\n */\npublic class 二叉树的垂序遍历_987 {\n\n    public static void main(String[] args) {\n\n        TreeNode _3 = new TreeNode(3);\n        TreeNode _9 = new TreeNode(9);\n        TreeNode _20 = new TreeNode(20);\n        TreeNode _15 = new TreeNode(15);\n        TreeNode _7 = new TreeNode(7);\n        _3.left = _9;\n        _3.right = _20;\n        _20.left = _15;\n        _20.right = _7;\n        Solution solution = new Solution();\n        solution.verticalTraversal(_3);\n\n    }\n\n\n    static class Solution {\n        public List<List<Integer>> verticalTraversal(TreeNode root) {\n            PriorityQueue<int[]> q = new PriorityQueue<int[]>((a, b) ->{\n                if(a[0] != b[0]) return a[0] - b[0];// x从小到大\n                if(a[1] != b[1]) return a[1] - b[1];// y从小到大\n                return a[2] - b[2]; // val 从小到大\n            });\n            dfs(root, q, 0, 0);\n            List<List<Integer>> res = new ArrayList<>();\n            while(!q.isEmpty()) {\n                List<Integer> tmp = new ArrayList<>();\n                int[] item = q.poll();\n                tmp.add(item[2]);\n                while(!q.isEmpty() && q.peek()[0] == item[0]) { // 同一列\n                    tmp.add(q.poll()[2]);\n                }\n                res.add(tmp);\n            }\n            return res;\n        }\n\n        private void dfs(TreeNode node, Queue<int[]> queue, int x, int y) {\n            if(node == null) return;\n            queue.add(new int[]{x,y,node.val});\n            dfs(node.left, queue, x - 1, y + 1);\n            dfs(node.right, queue, x + 1, y + 1);\n        }\n        private void bfs(TreeNode node, Queue<int[]> queue, int x, int y) {\n            \n        }\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101954537","body":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i< nums.length; i++) {\n            Integer other = map.get(nums[i]);\n            if(other != null) {\n                return new int[]{other, i};\n            }\n            map.put(target - nums[i], i);\n        }\n        return null;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103439132","body":"class Solution {\n   public int[] topKFrequent(int[] nums, int k) {\n            Map<Integer, Integer> frequencyMap = new HashMap<>();\n            for(int num : nums) {\n                frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n            }\n            PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(a -> -a[1]));\n            for(Map.Entry<Integer, Integer> e : frequencyMap.entrySet()) {\n                q.offer(new int[]{e.getKey(), e.getValue()});\n            }\n            int[] res = new int[k];\n            for (int i = 0; i < k; i++) {\n                res[i] = q.poll()[0];\n            }\n            return res;\n        }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104767576","body":"class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int res = 0;\n        for(int i = 0; i < points.length; i++) {\n            for(int j = 0; j <points.length; j++) {\n                if(i == j) continue;\n                int a = points[j][0] - points[i][0];\n                int b = points[j][1] - points[i][1];\n                int dist = b * b + a * a;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for(Integer c : map.values()) {\n                if(c > 1) {\n                    res += c * (c - 1); // Cn2 组合公式   n * (n - 1) / 2 这里就应该算是两种 因而去掉 / 2\n                }\n            }\n            map.clear();\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106046745","body":" package redo;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class 无重复字符的最长字串_3 {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.lengthOfLongestSubstring(\"tmmzuxt\");\n    }\n\n    static class Solution {\n        public int lengthOfLongestSubstring(String s) {\n            char[] arr = s.toCharArray();\n            int l = 0, r = 0, slen = arr.length, max = 1;\n            Map<Character, Integer> map= new HashMap<>(); // 保存字母的最大下标\n            while(r < slen ) {\n                Integer l1 = map.get(arr[r]);\n                if(l1 != null) {\n                    l = Math.max(l1 + 1, l);\n                }\n                map.put(arr[r], r);\n                max = Math.max(max, r - l + 1);\n                r ++;\n            }\n            return max;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107449456","body":"class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        int step = words[0].length();\n        int size = words.length;\n        int window = step * size;\n        int sLen = s.length();\n        List<Integer> res = new ArrayList<>();\n        if(window > sLen) return res;\n        Map<String, Integer> target = new HashMap<>();\n        for(String w : words) {\n            target.put(w, target.getOrDefault(w, 0) + 1);\n        }\n        Map<String, Integer> wordInWin = new HashMap<>();\n        int l = 0, r = 0;\n        // 初始化窗口\n        while(r < window)  {\n            String word = s.substring(r , r + step);\n            wordInWin.put(word, wordInWin.getOrDefault(word, 0) + 1);\n            r += step;\n        }\n        if(match(wordInWin, target)) res.add(l); // 添加完成先判断一次\n\n        // 同步移动 看窗口是否满足\n        while(r < sLen) { // 左闭右开 r不可达  因此r可到最大 + 1  仅仅作为不可达边界\n            wordInWin = new HashMap<>();\n            l ++;\n            r ++;\n            int tmp = l;\n            while(tmp < r) {\n                String w = s.substring(tmp, tmp + step);\n                wordInWin.put(w, wordInWin.getOrDefault(w, 0) + 1);\n                tmp += step;\n            }\n            if(match(wordInWin, target)) res.add(l); // 每次移动完判断一次\n        }\n\n        return res;\n    }\n\n    private boolean match(Map<String, Integer> window, Map<String, Integer> target) {\n        for(String word : target.keySet()) {\n            if(!target.get(word).equals(window.get(word)) ) return false;\n        }\n        return true;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107804707","body":"public static int solve(int[] nums, int k) {\n            int sum = 0, res = nums.length + 1;\n            for(int num : nums) {\n                sum += num;\n            }\n            int target = sum % k;\n            System.out.println(target);\n            sum = 0;\n            Map<Integer, Integer> map = new HashMap<>();\n            map.put(0, -1);\n            for(int i = 0; i < nums.length; i++) {\n                sum += nums[i];\n                int mod = sum % k;\n                Integer left = map.get(mod -target);\n                if(left != null) {\n                    System.out.println(left + \"-\" + i);\n                    res = Math.min(i - left, res);\n                }\n                map.put(mod - target, i);\n            }\n            return res == nums.length + 1 ? -1 : res;\n        }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107963123","body":"class Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow  = head, fast = head;\n        while(fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110933002","body":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int len = nums.length, l = 0, r = len;\n        while( l < r) {\n            int mid = l + ( (r - l) >> 1 );\n            if(nums[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111792193","body":"class Solution {\n   public int[] maxSlidingWindow(int[] nums, int k) {\n        int len = nums.length;\n        int[] res = new int[len - k + 1];\n        LinkedList<int[]> ll = new LinkedList<>();\n        for(int r = 0; r < len; r ++ ) {\n            while(!ll.isEmpty() && ll.peekFirst()[0] < nums[r]) {\n                ll.pollFirst();\n            }\n            if(!ll.isEmpty() && ll.peekLast()[1] < r - k + 1) {\n                ll.pollLast();\n            }\n            ll.addFirst(new int[]{nums[r], r}); // 最大放在Last  先进队的也放在Last\n            if(r - k + 1 >= 0) res[r - k + 1] = ll.peekLast()[0];\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ethanwlx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086617041","body":"思路：先从左往右，找每个index离左边最近的距离，再从右边往左，最后取左右的最小值。\n时间：O(n)\n空间：O(n)\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans_l = [float(inf)] * len(s)\n        ans_r = [float(inf)] * len(s)\n        ans = [0] * len(s)\n       \n        for i in range(len(s)):\n            if i == 0:\n                if s[i] == c:\n                    ans_l[i] = 0   \n            else:\n                ans_l[i] = ans_l[i-1] + 1 if s[i] != c else 0\n\n        for i in range(len(s) - 1, -1, -1):\n            if i == len(s) - 1:\n                if s[i] == c:\n                    ans_r[i] = 0          \n                ans[i] = min(ans_l[i], ans_r[i])\n            else:\n                ans_r[i] = ans_r[i+1] + 1 if s[i] != c else 0\n                ans[i] = min(ans_l[i], ans_r[i])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767347","body":"难点在于用O(1)时间处理增加量，假设我们记录增加量的值，指令分别为（1,20） （2,40） （4，40） （4，60）\n并画出图\n1##\n2####\n3\n4##########\n对于4 增加量就是 100\n对于3也是100\n对于2就是100+40=140\n对于1就是140+20= 160\n对于 i 位置就是上一个位置的值+自己本身的值\n把这张表格记录下来我们就可以做到线性时间得到每一个位置的增加量值\n时间： O（1）\n空间： O(maxsize)\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.addition = []\n        self.maxSize = maxSize\n        self.size = 0\n\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.addition.append(0)\n            self.size += 1\n\n\n    def pop(self) -> int:\n        if self.size > 0:\n            if self.size > 1:\n                self.addition[-2] += self.addition[-1]\n            st = self.stack.pop() + self.addition.pop()\n            self.size -= 1\n            return st\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0:\n            self.addition[min(k,self.size)-1] += val\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650773","body":"### 思路\n使用双指针，然后遍历字符串\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] result=new int[N];\n        int indexNext=S.indexOf(C);//双指针，indexNext表示下一个C的下标， \n        int index=indexNext;//index表示前一个C的坐标\n    // 通过这里的赋值使在只有左边有C字符的时候（此时index = indexNext）的时候\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(int i = 0; i < S.length(); i++){\n            if(S.charAt(i) == C){//每当遍历到C就更新index和indexNext\n                result[i] = 0;\n                index = i;\n                indexNext = S.indexOf(C, i+1);\n                //这里如果当前是最后一个C时，此时indexNext为-1，这也保证了上面的情况\n            }else{\n                result[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n       return result;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086854030","body":"### 思路\n使用栈实现\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1){\n            ++top;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top==-1)\n            return -1;\n        --top;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int li=Math.min(k,top+1);\n        for(int i=0;i<li;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n```\n### 复杂度分析\n时间复杂度：push和pop是0（1）,inc是O(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088759764","body":"### 思路\n使用双栈进行实现\n### 代码\n```java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack=new LinkedList<>();\n        outStack=new LinkedList<>();\n\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.pop();\n    }\n \n    public int peek() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.peek();\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tt-fantastic":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653492","body":"public int[] shortestDistance(String s, char c) {\n        int[] arr = new int[s.length()];\n        int distance = Integer.MIN_VALUE；\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distance = i;\n            }\n            arr[i] = i - distance;\n        }\n\n        distance = Integer.MAX_VALUE;\n        for (int j = s.length() - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                distance = j;\n            }\n            arr[j] = Math.min(arr[j], distance - j);\n        }\n       return arr;","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090319401","body":"```java\npublic int max(int arr[]) {\n        Stack<Integer> stack = new Stack();\n        for (int num: arr) {\n            int max = num;\n            while (!stack.isEmpty() && stack.peek() > num) {\n                max = Math.max(max, stack.pop());\n            }\n            stack.push(max);\n        }\n        return stack.size();\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091873831","body":"```java \npublic static void main(String[] args) {\n\n    }\n\n    public ListNode right(ListNode node, int k) {\n        if (node == null) {\n            return null;\n        }\n        ListNode current = node;\n        int count = 1;\n        //获取节点数\n        while (current.next != null) {\n            current = current.next;\n            count++;\n        }\n        current.next = node;\n        //节点数 - k % 节点数\n        for (int i = 1; i < count - (k % count); i++) {\n            current = current.next;\n        }\n        ListNode newNode = current.next;\n        current.next = null;\n        return newNode;\n    }\n    //定义节点\n    static class ListNode {\n        //数据 ：节点数据\n        int val;\n        //对象 ：引用下一个节点对象。\n        ListNode next;\n\n        public ListNode(int val) {\n            this.val = val;\n        }\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095152979","body":"```java \npublic ListNode detectCycle(ListNode head) {\n        if (head.next == null || head == null ) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n\n            if (fast == slow) {\n                ListNode node = fast;\n                while (node != slow) {\n                    node = node.next;\n                    slow = node.next;\n                }\n                return node;\n            }\n        }\n        return null;\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098164026","body":"```java \n public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            int leftHeight = maxDepth(root.left);\n            int rightHeight = maxDepth(root.right);\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n    }\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyh331":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658067","body":"### **Day2**  思路  \n\n两边都遍历，最后留下较小的值  \n\n### 代码  \n\n```\nc++\nclass Solution \n{\npublic:\n    vector<int> shortestToChar(string s, char c) \n    {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) \n        {\n            if (s[i] == c) \n            {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) \n        {\n            if (s[i] == c) \n            {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086862033","body":"### Day3 思路\n考虑用vector(本质为单端动态数组)容器实现。\n1. 构造函数中用m_Maxsize接收传入进来的maxSize。\n2. void push中判断数组元素个数<m_Maxsize？然后_.push_back(x)将x压入堆栈\n3. void pop中用_.empty()判断容器是否为空,不为空时先用**int top=_.back();保留引用，后续返回top**，再进行出栈操作。\n4. increment中for保证i < k && i < _.size()就可以\n### 代码\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int m_Maxsize;\n    //构造函数\n    CustomStack(int maxSize) {\n        m_Maxsize=maxSize;\n        //stack.resize(maxSize);\n    }\n    //入栈函数\n    void push(int x) {\n        if(stack.size()<m_Maxsize){\n            stack.push_back(x);\n        }\n    }\n    //出栈函数,弹出栈顶元素，并返回栈顶的值，栈为空时返回-1\n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        else{\n            //要返回的是出栈前的栈顶，所以需要先把栈顶保留引用，用 int top=stack.back();接收一下\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        }\n\n    }\n    //栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\n    void increment(int k, int val) {\n        for(int i=0 ; i<k && i<stack.size();i++){\n            stack[i]+=val;\n        }\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度\npush:O(1)\npop:O(1)\nincr:O(k)\n- 空间复杂度\npush:O(1)\npop:O(1)\nincr:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087681416","body":"### Day3 思路\n用栈来解决问题\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[') //将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else //遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算\n                                  //若是左括号，res会被压入strs栈，作为上一层的运算\n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088375886","body":"\n### Day5 思路\n使用两个栈来实现队列，一个是输入栈，一个是输出栈。\n1. push操作直接压入输入栈即可。输入栈的元素顺序是和队列相反的。\n2. pop操作需要先判断输出栈是否为空，然后将输入栈全部放入到输出栈，此时输出栈的**栈顶到栈底的元素排列**就和**队列中队头到队尾的元素排列**一致。\n3. peek操作，使用2中已有的pop函数,注意最后要将出栈的元素放回去。\n3. empty，只需判断两个栈是否为空即可\n### 代码\n```c++\nclass MyQueue {\npublic:\n    stack<int> StkIn, StkOut;\n    MyQueue() {\n\n    }\n    //入队，直接将数据x压入StkIn即可\n    void push(int x) {\n        StkIn.push(x);\n    }\n    //出队，\n    int pop() {\n        //当StkOut栈为空时，将StkIn的元素全部放入StkOut，\n        //这样做StkOut中从栈顶到栈底元素的排列就和队列中从队头到队尾一致。\n        if(StkOut.empty()){\n            while(!StkIn.empty()){\n                StkOut.push(StkIn.top());\n                StkIn.pop();\n            }\n        }\n        int result=StkOut.top();\n        StkOut.pop();\n        return result;\n    }\n    //返回队列首部的元素。\n    int peek() {\n        int res=this->pop();//直接使用已经写好的pop函数\n        StkOut.push(res);//pop函数中弹出了res，所以要添加回去\n        return res;\n\n    }\n    //返回队列是否为空，只需判断两个栈是否都为空即可\n    bool empty() {\n        return StkIn.empty()&&StkOut.empty();\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：push和empty是O(1)，pop和peek是O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090108751","body":"### Day6 思路\n1. 将原数组进行分块后，对各分块分别进行排序后的结果等于原数组排序后的结果。\n2. 每个分块中的数字相对于前一个分块都是递增的(因为有重复数字，所以也可能是相同，下一个分块中的所有数字都会大于等于上一个分块中的所有数字。\n3. 在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块。\n4. 如果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块(保持栈的单调递增)\n5. 涉及单调栈的知识\n6. 若数组元素>=单调栈栈顶元素，数组元素入栈。若数组元素<单调栈栈顶元素，先将栈顶元素保存，再栈非空且arr[i]<栈顶元素情况下，将栈顶元素弹出，即拿出来重新组成块，最后将最大值重新入栈\n### 代码\n```c++\nclass Solution \n{\npublic:\n    int maxChunksToSorted(vector<int>& arr)\n    {\n        //单调栈，\n        stack<int>maxStk;\n        //直接将数组的第一个入栈\n        maxStk.push(arr[0]);\n        //从第二个元素开始遍历数组\n        for(int i=1;i<arr.size();i++)\n        {\n            //若数组元素>=单调栈栈顶元素，数组元素入栈\n            if(arr[i]>=maxStk.top())\n            {\n                maxStk.push(arr[i]);\n            }\n            else\n            {\n                //若数组元素<单调栈栈顶元素，先将栈顶元素保存，再栈非空且arr[i]<栈顶元素情况下，将栈顶元素弹出，即拿出来重新组成块，最后将最大值重新入栈\n              int maxNum=maxStk.top();\n              while(!maxStk.empty()&&arr[i]<maxStk.top())\n              {\n                \n                maxStk.pop();\n              }\n              maxStk.push(maxNum);\n            }\n        }\n        return maxStk.size();\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091020616","body":"### Day7 思路\n假设链表的长度为n，为了将链表每个节点向右移动 k 个位置，我们只需要将链表的后 k % n个节点移动到链表的最前面，然后将链表的后k % n个节点和前 n - k个节点连接到一块即可。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || !k)  return head;\n        int n = 0;        //链表的长度\n        ListNode* nodelt=head;   //头节点\n        ListNode* Tail=head;\n        while(nodelt!=NULL){\n            n++;\n            Tail=nodelt;\n            nodelt=nodelt->next;\n        }\n        k %= n;  \n        ListNode* p = head;\n        for(int i = 0; i < n - k - 1; i++)   p = p->next;  //找到链表的第n-k个节点\n        Tail->next = head;\n        head = p->next;\n        p->next = nullptr;\n        return head;     //返回新的头节点\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度:O(N)\n- 空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093625682","body":"### Day8 思路\n递归方法\n### 代码\n```c++\nclass Solution {\n    public: ListNode* swapPairs(ListNode *head) {\n        if (head == NULL || head->next == NULL){\n            return head;\n        }\n        ListNode *next = head->next->next;\n        ListNode *pre = head;\n        head = head->next;\n        head->next = pre;\n        pre->next = swapPairs(next);\n        return head;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093832975","body":"### Day9 思路\n找到中点后递归+中序遍历\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* h; \n    TreeNode* sortedListToBST(ListNode* head) {\n        //if(!head ) return head;\n        h = head;\n        int n = 0;\n        for(auto p = head; p; p = p->next) n ++;\n        return build(0, n - 1);\n\n    }\n\n    TreeNode* build(int l, int r) {\n        if(l > r) return nullptr;\n        TreeNode *root = new TreeNode();\n        int mid = (l + r  +1) >> 1;\n        root->left = build(l, mid - 1);\n        root->val = h->val;   \n        h = h->next; \n        root->right = build(mid + 1, r);\n        return root;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094175652","body":"### Day3 思路\n双指针方法\n1. 只有当链表headA和headB 都不为空时，两个链表才可能相交。因此首先判断链表headA和headB是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。\n2. 当链表A和B 都不为空时，创建两个指针pA和pB，初始时分别指向两个链表的头节点headA和headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：\n3. 每步操作需要同时更新指针pA和pB。\n4. 如果指针pA 不为空，则将指针pA 移到下一个节点；如果指针pB 不为空，则将指针pB 移到下一个节点。\n5. 如果指针pA 为空，则将指针pA 移到链表headB的头节点；如果指针pB 为空，则将指针pB 移到链表headA 的头节点。\n6. 当指针pA和pB 指向同一个节点或者都为空时，返回它们指向的节点或者null。\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == NULL || headB == NULL) {\n            return NULL;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            if(pA!=NULL){\n                pA=pA->next;\n            }\n            else{\n                pA=headB;\n            }\n            if(pB!=NULL){\n                pB=pB->next;\n            }\n            else{\n                pB=headA;\n            }\n            //pA = pA == nullptr ? headB : pA->next;\n           // pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094485739","body":"### Day11 思路\n快慢指针，fast与slow，fast的速度是slow的两倍，起始位置都为链表头部，若链表中存在环，则快指针必在\n环中与慢指针相遇。相遇时，重新指定一个pre指针从链表头开始，当再次相遇时，返回pre即可。\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head;\n        ListNode *fast=head;\n        //让快慢指针开始运动，第一次相遇时跳出\n        while(fast!=NULL && fast->next!=NULL){\n            slow=slow->next;\n            fast=fast->next->next;\n            //快慢指针相遇，代表有环\n            if(slow==fast){\n                break;\n            }\n        }\n        //判断没环的情况下，返回null\n        if(fast==NULL || fast->next==NULL){\n            return NULL;\n        }\n        //重新指定一个pre指针从链表头部开始，让pre和slow同一速度，当相遇时，返回pre\n        ListNode *pre=head;\n        while(pre!=slow){\n            pre=pre->next;\n            slow=slow->next;\n        }\n        return pre;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096600764","body":"### Day12 思路\n1. O(1) get和put，因此可以使用hash\n2. O(1)插入，删除，因此用list，为啥不直接使用stl中的list，因为每次插入一个值，其他值的位置发啥生了变化，导致hash失效。\n3.  使用hash存放key和node的内存地址。\n4. get：从hash中获取节点的内存地址，然后从list中pop此节点，并将该节点push_front到列表的前面\n5. put：如果key存在，从hash中获取节点的内存地址，然后从list中pop此节点，并将该节点push_front到列表的前面。  如果key不存在，size==capcity，先pop_back最后一个节点，并新建节点，并将该节点push_front到列表的前面，更新mp。  否则，新建节点，并将该节点push_front到列表的前面，更新mp和size\n### 代码\n```c++\nclass LRUCache {\npublic:\nstruct DoubleList{\n    DoubleList *left;\n    DoubleList *right;\n    int key;\n    int val;\n    DoubleList():left(nullptr),right(nullptr),key(0),val(0){}\n    DoubleList(int k,int v):left(nullptr),right(nullptr),key(k),val(v){}\n};\n    LRUCache(int capacity) {\n        this->capacity=capacity;\n        size=0;\n        head=new DoubleList();\n        tail=new DoubleList();\n        head->right=tail;\n        tail->left=head;\n    }\n    \n    int get(int key) {\n        if(mp.count(key)){\n            DoubleList* node=mp[key];\n            int val=node->val;\n            pop(node);\n            push_front(node);\n            return val;\n        }\n        else{\n            return -1;\n        }\n    }\n    \n    void put(int key, int value) {\n        //cout<<key<<\" \"<<value<<\" \\n\";\n        if(mp.count(key)){\n            DoubleList* node=mp[key];\n            pop(node);\n            push_front(node);\n            node->val=value;\n        }\n        else{\n            if(size==capacity){\n                pop_back();\n                DoubleList* node=new DoubleList(key,value);\n                mp[key]=node;\n                push_front(node);\n            }\n            else{\n                size++;\n                DoubleList* node=new DoubleList(key,value);\n                mp[key]=node;\n                push_front(node);\n            }\n        }\n    }\n\n    void pop(DoubleList* node){\n        node->left->right=node->right;\n        node->right->left=node->left;\n    }\n    void push_front(DoubleList* node){\n        head->right->left=node;\n        node->right=head->right;\n        node->left=head;\n        head->right=node;\n    }\n    void pop_back(){\n        DoubleList* last_node=tail->left;\n        pop(last_node);\n        mp.erase(last_node->key);\n        delete last_node;\n    }\n    unordered_map<int,DoubleList*>mp;\n    DoubleList *head;\n    DoubleList *tail;\n    int capacity;\n    int size;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097484469","body":"### Day13 思路\n1. 原理：DFS，递归算法\n2. 找出终止条件：当前节点为空\n3. 找出返回值：节点为空时说明高度为 0，所以返回 0；节点不为空时则分别求左右子树的高度的最大值，同时加1表示当前节点的高度，返回该数值\n4. 某层的执行过程：在返回值部分基本已经描述清楚\n```c++\nclass Solution {\n    public: int maxDepth(TreeNode* root) {\n        if(root == nullptr) {\n            return 0;\n        } else {\n            int left = maxDepth(root->left);\n            int right = maxDepth(root->right);\n            return max(left,right) + 1;\n        }\n    }\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099237988","body":"### Day14 思路\nDFS思想\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        } else if (p == nullptr || q == nullptr) {\n            return false;\n        } else if (p->val != q->val) {\n            return false;\n        } else {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        }\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099903061","body":"### Day15 思路\nDFS算法+递归\n```c++\nclass Solution {\npublic:\n    int dfs(TreeNode* root, int prevSum) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root->val;\n        if (root->left == nullptr && root->right == nullptr) {\n            return sum;\n        } else {\n            return dfs(root->left, sum) + dfs(root->right, sum);\n        }\n    }\n\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100515431","body":"### Day16 思路\n思路：dfs+递归\n1. 确定递归函数的参数和返回值，参数为根节点和此时的深度。返回值为空。\n2. 确定终止条件，当遍历到是空节点，直接返回。\n3. 利用前序遍历。判断当前深度 curDepth 是否为大于最大深度 maxDepth ，若大于，则将当前的节点值赋给 left ，同时更新最大深度的值。这种做法可以保证，当遇到当前深度大于最大深度时，赋值给 left 的值一定是这一层最左边的节点值，因为后面的都是同一层，不满足大于条件。若是判断大于等于，则 left 将被赋为这一层的最右节点的值。\n```c++\nclass Solution {\npublic:\n    int left=0;\n    int maxDepth=0;\n    void dfs(TreeNode* root,int curDepth){\n        if(root==NULL)  return;\n        if(curDepth>maxDepth){\n            left=root->val;\n        }else{\n            left=left;\n        }\n        maxDepth = max(curDepth, maxDepth); \n        dfs(root->left, curDepth + 1);\n        dfs(root->right, curDepth + 1);\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        dfs(root,1);\n        return left;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100893244","body":"### Day17 思路\nDFS+递归+前序遍历+to_string()和stoic()\n```c++\nclass Codec {\npublic:\n    //序列化函数\n    void rserialize(TreeNode* root , string& str){\n        if(root==NULL){\n            str+=\"None,\";\n        }else{\n            //to_string函数是将数字常量转换为字符串\n            str+=to_string(root->val)+\",\";\n            //进行递归\n            rserialize(root->left,str);\n            rserialize(root->right,str);\n        }\n    }\n    // 序列化\n    string serialize(TreeNode* root) {\n        string ret;\n        //调用序列化封装函数\n        rserialize(root,ret);\n        return ret;\n    }\n\n    //反序列化函数,输出是树结构。所以用TreeNode\n    TreeNode* rdeserialize(list<string>& dataArray){\n        if(dataArray.front()==\"None\"){\n            dataArray.erase(dataArray.begin());\n            return NULL;\n        }\n        //stoi将字符串转化为int类型函数\n        TreeNode* root=new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        //将字符串转化为左右节点\n        root->left=rdeserialize(dataArray);\n        root->right=rdeserialize(dataArray);\n        return root;\n\n    }\n\n    //反序列化\n    TreeNode* deserialize(string data) {\n        //创建list容器，装字符串数据\n        list<string> dataArray;\n        string str;\n        for(auto& ch : data){\n            if(ch == ','){\n                dataArray.push_back(str);\n                str.clear();\n            }else{\n                str.push_back(ch);\n            }\n        }\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101039827","body":"### Day18 思路\n1. 遍历的顺序是先左后右，先上后下，对于行列相同的采取先小后大。\n2. 因为要对列排序并把不同的列放在不同的vector里，所以我们可以将它们保存在一个map里面，每个列值对应一个vector。\n3. 因为对于列相同的节点，我们对它们的行排序，行相同时还要对它们本身的value排序，所以我们调用STL里的pair帮助排序。pair排序时会先对它的first比对，first相同时再比对second\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);     //通过dfs遍历，把节点都安插到mymap里\n        vector<vector<int>> ans;  //用于保存答案\n        map<int, vector<pair<int, int>>>::iterator itB = myMap.begin(), itE = myMap.end();         //用于遍历mymap\n        while(itB != itE){\n            vector<pair<int, int>> &col = itB->second;   //取出mymap里的vector<pair>\n            sort(col.begin(), col.end());           //对其排序\n            const int length = col.size();         //它的长度\n            vector<int> tmp(length);              //准备将它转换成vector<int>\n            for(int i = 0; i < length; ++i)\n                tmp[i] = col[i].second;          //取出值\n            ans.push_back(tmp);                   //放入ans\n            ++itB;\n        }\n        return ans;\n    }\nprivate:\n    map<int, vector<pair<int, int>>> myMap;  //int是列，vector里存的是该节点的行数和值\n    void dfs(TreeNode* root, int row, int col){\n        if(root == nullptr)        //空指针就不用搜索下去了\n            return;\n        myMap[col].push_back({row, root->val}); //加入该列，first是行，second是值\n        dfs(root->left, row + 1, col - 1);   //继续搜索\n        dfs(root->right, row + 1, col + 1);\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O()\n- 空间复杂度：O()\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102282424","body":"### Day19 思路\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        //创建一个哈希表\n        unordered_map<int, int> hashtable;\n        for (int i = 0; i < nums.size(); ++i) {\n            //.find函数若找到返回元素的迭代器。通过迭代器的second属性获取值；若没找到返回unordered_map::end\n            auto it = hashtable.find(target - nums[i]);\n            if (it != hashtable.end()) {\n                return {it->second, i};\n            }\n            hashtable[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103362615","body":"### Day20 思路\n借助哈希表来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率\n```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n    //1.map记录元素出现的次数\n        unordered_map<int,int>map;//两个int分别是元素和出现的次数\n        for(auto& c:nums){\n            map[c]++;\n        }\n    //2.利用优先队列，将出现次数排序\n        //自定义优先队列的比较方式，小顶堆\n        struct myComparison{\n            bool operator()(pair<int,int>&p1,pair<int,int>&p2){\n                return p1.second>p2.second;//小顶堆是大于号\n            }\n        };\n        //创建优先队列,pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        priority_queue<pair<int,int>,vector<pair<int,int>>,myComparison> q;\n        //遍历map中的元素\n        //1.管他是啥，先入队列，队列会自己排序将他放在合适的位置\n        //2.若队列元素个数超过k，则将栈顶元素出栈（栈顶元素一定是最小的那个）\n        for(auto& a:map){\n            q.push(a);\n            if(q.size()>k){\n               q.pop(); \n            }\n        }\n        //将结果导出\n        vector<int>res;\n        while(!q.empty()){\n            res.emplace_back(q.top().first);\n            q.pop();\n        }\n        return res;\n\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(Nlogk)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104660846","body":"### Day21 思路\n哈希+排列数(是有顺序的考虑用A)\n1. 对每一个回旋镖中心i，先计算该点与其他点的距离，并以距离为键值通过哈希表记录这些点的数量，即哈希表key值为距离，value值相同距离下出现点的次数\n2. 计算完所有数组后，遍历哈希表，对每种距离下可以构造的回旋镖的数量num*(num-1)求和即可\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        //遍历每个点\n         unordered_map<int, int> m;\n        for (int i = 0; i < points.size(); i ++) {\n           \n            //遍历其他点\n            for (int j = 0; j < points.size(); j ++) {\n                //若是同一个点则开始下一轮循环，continue跳过当前循环中的代码，强迫开始下一次循环\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dis = x*x+y*y;\n                //将距离作为key值放入unordered_map容器中，\n                m[dis] ++;\n            }\n            //遍历m容器，将每个key值对应的可组合回旋镖的数量求出，并求和\n            for(auto &[key, num]: m){\n                ans += num * (num - 1);\n            }\n        }\n        return ans;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106125825","body":"### Day3 思路\n1. 输入s = \"abcabcbb\"\n2. windows.find(),若存在此元素返回一个指向该元素的迭代器,若不存在返回set.end()迭代器\n3. windows.end()返回指向最后一个元素之后的迭代器，不是最后一个元素\n\n4. 快被下面这段代码搞疯了，想了好久原来是我想错了，我一直以为set容器原本就有元素，把windows.end看成是最后一个元素下一位的迭代器，所以当\ni=0的时候我一直以为是while (windows.find(a) != windows.end())，一直处于循环中。\n\n5. 实际情况是：初始时windows容器为空，什么都没有。\n\n  i=0时，s[i]=a,windows.find(a)找不到a元素，返回windows.end()，windows.find(a) != windows.end()不成立，直接跳出while循环。此时maxStr=1,windows容器为[a]\n\n  i=1时,s[i]=b,windows.find(a)找不到b元素，返回windows.end()，windows.find(a) != windows.end()不成立，直接跳出while循环。此时maxStr=2,windows容器为[a,b]\n\n  i=2时，s[i]=c,windows.find(a)找不到c元素，返回windows.end()，windows.find(a) != windows.end()不成立，直接跳出while循环。此时maxStr=3,windows容器为[a,b,c]\n\n  i=3时，s[i]=a,windows.find(a)找到a元素，windows.find(a) != windows.end()成立，进入while循环,删除元素s[left]=a，更新left指向下一位b，此时maxStr=3,windows容器为[b,c,a]\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> windows;//哈希集合，相当于滑动窗口，用来存放无重复字符串\n        int maxStr = 0;//标记最大子串长度\n        int left = 0;//left为左指针，i相当于右指针，开始循环遍历字符串\n        for(int i = 0; i < s.size(); i++){\n            //while主要作用：查找“新进来的元素s[i]”与容器中原本的元素是否有重复，若有就将windows元素从左侧开始删除，\n            //一直删除到重复元素(包含它)才停止，此时就不满足while循环了，然后再将此元素放入windows中.\n            while (windows.find(s[i]) != windows.end()){\n                windows.erase(s[left]);\n                left ++;\n            }\n            maxStr = max(maxStr,i-left+1);\n            //当while循环没找到\"新进来的元素s[i]\"与容器中元素有重复时，就将其放入容器.\n            windows.insert(s[i]);\n    }\n        return maxStr;\n        \n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107349963","body":"### Day23 思路\n1. 输入：s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n2. 长度为n的字符串,大小为m的单词数组words,其中的所有单词长度相同为d。\n3. 维护两个哈希表，哈希表1:key(单词数组中出现的所有单词) value(单词出现的次数)\n4. 然后扫描字符串单词，若当前单词在哈希表1中，就将此单词存到哈希表2中，\n5. 哈希表2：key() value()\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n    vector<int> res;//?????????????????\n    //字符串长度n,words中单词个数m,单词长度d\n    int n=s.size(), m=words.size(), d=words[0].size();\n    int len=m*d;//表示words数组所能拼接的字符串长度，即滑动窗口的长度。\n    //哈希表1，存所有单词及其出现次数\n    unordered_map<string,int> allwords;\n    for(string w:words){\n        allwords[w]++;//这里需要再看一下map原理,是怎么将单词加入到hashmap中的\n    }\n    //初始化0~d-1滑动窗口对应的词频统计表\n    vector<unordered_map<string, int>> sm(d); \n    for(int i=0; i<d&&i+len<=n ; i++){\n        //substr(j,d)复制子字符串，要求从指定位置j开始，并具有指定的长度d.并且每次增加单词长度d\n        //j=i开始！！！\n        for(int j = i ; j < i+len ; j+=d){\n            string str=s.substr(j,d);\n            sm[i][str]++;//???????????????\n        }\n        if(sm[i]==allwords){\n            res.push_back(i);//????????????\n        }\n    }\n\n        //移动滑动窗口，每次出一个单词，进一个单词\n        for(int i=d; i+len<=n ; i++){\n            int r=i%d;\n            string str1=s.substr(i-d,d);//出窗字符串\n            string str2=s.substr(i+len-d,d);//出窗字符串\n            if(--sm[r][str1]==0)\n                sm[r].erase(str1);\n            sm[r][str2]++;\n            if(sm[r]==allwords)\n                res.push_back(i);\n         }   \n             return res;\n}\n};\n```\n### 复杂度分析\n- 时间复杂度：O((d+m)*n),其中 n 表示字符串 s 的长度，d 是 words 中单词的长度, m 是 words 中单词的个数。\n- 空间复杂度：O(L),其中 LL表示words 数组中所有单词的长度之和","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107852956","body":"### Day24 思路\n同余定理，前缀和，哈希表\n```c++\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        //计算nums所有元素和\n        long long allsum_nums=0;\n        for(int e:nums){\n            allsum_nums +=e;\n        }\n        //long long allsum_nums=nums.accumulate(nums.begin(),nums.end());\n        int mod=allsum_nums % p;\n        //所有元素和小于p ，不满足题目要求\n        if(allsum_nums<p) return -1;\n        //mod==0说明所有所有元素和 可直接被p整除，不需要移除数组\n        if(mod==0) return 0;\n        //创建哈希表，key:前缀和%p的余数，value：pos\n        unordered_map<int ,int> presum_mod_pos;\n        //??????????\n        presum_mod_pos[011]=-1;\n        int res=nums.size();\n        long long presum=0;\n        //开始遍历数组\n        for(int i = 0 ; i < res; i++){\n            presum +=nums[i];\n            int curmod=presum%p;\n            presum_mod_pos[curmod]=i;\n\n            int target=(curmod-mod+p)%p;//这里curMod - mod 需要 + p使其成为一个>p的数\n            if(presum_mod_pos.count(target)){\n                res = min(res,i-presum_mod_pos[target]);\n            }\n        }\n        return res == nums.size() ? -1 :res;\n\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108001494","body":"### Day25 思路\n快慢指针\n1. 两个指针遍历链表slow一次走一步，fast一次走两步。\n2. 循环条件fast != NULL && fast.next != NULL,\n3. 当结点个数为奇数时，slow落在中间结点；当结点个数为偶数时，slow落在“靠右的”中间结点；\n4. 若题目要求落在靠左的中间结点，该怎么办？ 此时循环条件应为 fast.next != NULL && fast.next.next != NULL,\n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast!=NULL && fast->next!=NULL){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        return slow;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n),n为链表长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109824655","body":"### Day26 思路\n1. 双指针，slow=0,fast=1，将不断重复的元素移到数组左侧\n2. 比较slow和fast是否相等，若相等：fast后移一位； 若不等：将fast位置的元素复制到slow+1上，且slow和fast都后移一位。知道fast等于数组长度\n3. 返回slow+1\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        //先判断一下nums是否为空\n        int n=nums.size();\n        if(n==0) return 0;\n        int fast=1 , slow=0;\n        while(fast<n){\n            if(nums[fast]!=nums[slow]){\n                nums[slow+1]=nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        //因为slow从0开始，所以最后+1\n        return slow+1;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110461427","body":"### Day27 思路\n1. 定义左右指针指向数组两头，计算mid值，并判断target和mid大小，选择区间\n2. 二分查找重点注意事项：while循环中的判断是否带=；更新区间时left和right +1 -1问题，左右区间开闭问题\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        //数组长度\n        int n=nums.size();\n        int tar=target;\n        //左指针从第1个数开始（下标0），右指针从最右侧（下标n-1）开始，折半查找\n        int left=0;\n        int right=n-1;\n        while(left<=right){\n            int mid=(left+right)/2;\n            if(tar==nums[mid]) return mid;\n            if(tar>nums[mid]) left=mid+1;\n            if(tar<nums[mid]) right=mid-1; \n        }\n        //跳出while循环，则代表left>right,说明没找到tar，返回left\n        return left;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111689416","body":"### Day28 思路\n使用具有单调性的双端队列。在窗口右移时，使用一个队列存储所有没有被移除的下标，并且这些下标从小到大排序。\n在窗口右移时，需要把一个新的元素放入队列，需要将新元素与队尾元素比较，若新元素>=队尾元素：删除队尾元素，将其弹出队列。不断进行此操作，知道队列为空 或 新元素<队尾元素。\n由于队列下标对应的元素是严格单调递减的，因此队首下标对应元素就是滑动窗口中的最大值。\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        //使用双向队列。\n        vector<int> res;\n        deque<int> dq;\n        for (int i = 0; i < nums.size(); ++i) {\n            //如果窗口长度已经超过了k，则将最左边的元素移除\n            if (!dq.empty() && dq.front() == i - k) dq.pop_front();\n            //从后往前移除所有队列中小于当前元素的元素\n            while (!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();\n            //在队列中添加当前元素\n            dq.push_back(i);\n            //如果窗口长度已经到达了k，则在结果中插入最大值(deque最前面的元素)\n            if (i >= k-1) res.push_back(nums[dq.front()]);\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112844923","body":"### Day29 思路\n根据题意找到出度为0且入度为n-1的那个人编号即可。\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        //定义长度为n+1的in和out，存放信任度\n        vector<int> in(n+1), out(n+1);\n        //遍历trust二维数组，第一个位置是代表信任别人，第二个位置代表被别人信任\n        for (auto &x : trust) {\n            in[x[1]]++; out[x[0]]++;\n        }\n       //若是法官，则入度为n-1，出度为0\n        for (int i = 1; i <= n; i++) {\n            if (in[i] == n-1 && out[i] == 0)\n                return i;\n        }\n        return -1;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennethalgol":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086659684","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new LinkedList<>();\r\n\t\tfinal int len = num.length;\r\n\t\tfor(int i = len - 1; i >= 0; i--) {\r\n\t\t\tint sum = num[i] + k % 10;\r\n\t\t\tk /= 10;\r\n\t\t\tif(sum >= 10) {\r\n\t\t\t\tk++;\r\n\t\t\t\tsum -= 10;\r\n\t\t\t}\t\r\n\t\t\tres.add(0, sum);\r\n\t\t}\r\n\t\tfor(; k > 0; k /= 10) {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086659398","body":"# 思路\r\n双指针\r\n# 语言\r\njava\r\n\r\n```java\r\npublic int[] shortestToChar(String S, char C) {\r\n        \r\n        int[] res = new int[S.length()];\r\n        int cur = S.indexOf(C), pre = cur;\r\n        for(int i = 0; i < S.length(); i++){\r\n            if(S.charAt(i) == C){//其实就是每当遍历到C就更新cur和pre\r\n                res[i] = 0;\r\n                pre = i;\r\n                cur = S.indexOf(C, i+1);//注意：这里如果当前是最后一个C时，此时cur为-1，这也保证了上面的情况3\r\n\r\n            }else{\r\n                res[i] = Math.min(Math.abs(pre - i), Math.abs(cur - i));//\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度分析\r\n时间 O(n) 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086660008","body":"# 思路\r\n模拟\r\n\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091455551","body":"# 思路\r\n快慢指针\r\n\r\n```java\r\nclass Solution {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (head == null) {\r\n                return head;\r\n            }\r\n            ListNode slow = head;\r\n            ListNode fast = head;\r\n            for (int i = 0; i < k; i++) {\r\n                if (fast.next == null) {\r\n                    //超过一轮时重新开始走,这边也可以优化成模(但是前提需要知道链表总长度至少要遍历一次),可以免去不停的循环遍历\r\n                    fast = head;\r\n                } else {\r\n                    fast = fast.next;\r\n                }\r\n            }\r\n            //快慢指针间距离为0，移动0个位置，直接返回head\r\n            if (fast == head) {\r\n                return head;\r\n            }\r\n            while (fast.next != null) {\r\n                slow = slow.next;\r\n                fast = fast.next;\r\n            }\r\n            ListNode newHead = slow.next;\r\n            fast.next = head;\r\n            slow.next = null;\r\n            return newHead;\r\n        }\r\n    }\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094715344","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode pos = head;\r\n        Set<ListNode> visited = new HashSet<ListNode>();\r\n        while(pos != null){\r\n            if(visited.contains(pos)){\r\n                return pos;\r\n            }else{\r\n                visited.add(pos);\r\n            }\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096843554","body":"```java\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode(){\r\n\r\n        }\r\n        public DLinkedNode(int _key, int _value){\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head;\r\n    private DLinkedNode tail;\r\n\r\n    public LRUCache(int capacity){\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        // 使用伪头部和伪尾部节点\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache.put(key, newNode);\r\n            // 添加至双向链表的头部\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode tail = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102470127","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; ++i) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                return new int[]{map.get(target - nums[i]), i};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103558922","body":"```java\r\npublic int[] topKFrequent(int[] nums, int k) {\r\n    Map<Integer, Integer> counter = new HashMap<>();\r\n    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(\r\n            Map.Entry.<Integer, Integer>comparingByValue());\r\n\r\n    for (int num : nums) {\r\n        counter.putIfAbsent(num, 0);\r\n        counter.put(num, counter.get(num) + 1);\r\n    }\r\n    for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\r\n        pq.offer(entry);\r\n        if (pq.size() > k) {\r\n            pq.poll();\r\n        }\r\n    }\r\n    int[] result = new int[k];\r\n    for (int i = 0; i < k; i++) {\r\n        result[i] = pq.poll().getKey();\r\n    }\r\n    return result;\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107517353","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> res = new ArrayList<>();\r\n        if (s == null || s.length() == 0 || words == null || words.length == 0) return res;\r\n        HashMap<String, Integer> map = new HashMap<>();\r\n        int one_word = words[0].length();\r\n        int word_num = words.length;\r\n        int all_len = one_word * word_num;\r\n        for (String word : words) {\r\n            map.put(word, map.getOrDefault(word, 0) + 1);\r\n        }\r\n        for (int i = 0; i < s.length() - all_len + 1; i++) {\r\n            String tmp = s.substring(i, i + all_len);\r\n            HashMap<String, Integer> tmp_map = new HashMap<>();\r\n            for (int j = 0; j < all_len; j += one_word) {\r\n                String w = tmp.substring(j, j + one_word);\r\n                tmp_map.put(w, tmp_map.getOrDefault(w, 0) + 1);\r\n            }\r\n            if (map.equals(tmp_map)) res.add(i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112048270","body":"# 思路\r\n双端队列\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int[] result = new int[nums.length - k + 1];\r\n        Deque<Integer> deque = new ArrayDeque<>();\r\n        \r\n        for (int i = 0; i < nums.length; i++){\r\n            if (!deque.isEmpty() && deque.peekFirst() + k <= i) {\r\n                deque.pollFirst();\r\n            }\r\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\r\n                deque.pollLast();\r\n            }\r\n            deque.offerLast(i);\r\n            if (i - k + 1 >= 0) {\r\n                result[i - k + 1] = nums[deque.peekFirst()];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtldtt":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666626","body":"### 思路\n\n把原数组str中的c的下标取出来单独放在一个数组中，作为判断的边界。相当于几个分割点，除了开头和末尾的特殊情况，每次只需要判断离前一个分界点近还是离后一个分界点近就可以了。\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n#define MIN(x,y) ((x)<(y) ? (x) : (y))\n    vector<int> shortestToChar(string str, char c) {\n        vector<int> flags;\n        vector<int> answer;\n        for(int i=0;i<str.size();i++){\n            if(str[i]==c) flags.push_back(i);\n        }\n        //print_vector(flags);\n        //cout<<\"end\\n\";\n        int current_flag=0;\n        for(int i=0;i<str.size();i++){\n            if(current_flag==flags.size()){\n            answer.push_back(i-flags[current_flag-1]);\n            continue;\n            }\n            if(i>flags[current_flag]) {current_flag++; i--; continue;}\n            else if(current_flag==0){\n            answer.push_back(flags[current_flag]-i);\n            continue;\n            }\n            answer.push_back(MIN(i-flags[current_flag-1],flags[current_flag]-i));\n        }\n        return answer;\n            }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086819738","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n\n### 思路\n\n就是用数组实现一个栈，标记对栈顶元素做好标记就好\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\nprivate:\n    int maxSize;\n    int *stack;\n    int num; //当前有几个数在栈中\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize=maxSize;\n        this->stack = new int[maxSize];\n        num=-1;\n    }\n    ~CustomStack(){\n        delete [] this->stack;\n    }\n    bool is_empty()\n{\n    return num==-1;\n}\n    \n    void push(int x) {\n        if(num<maxSize-1) stack[++num]=x;\n        else return;\n    }\n    \n    int pop() {\n        if(is_empty()) return -1;\n        return stack[num--];\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<=num;i++){\n          stack[i]+=val;\n        }\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087720258","body":"### [394. 字符串的解码](https://leetcode-cn.com/problems/decode-string/)\n\n\n### 思路\n\n用栈保存字符串，然后遇到中括号进行相应的处理\n\n### 代码\n\n\n```cpp\n\nstring decodeString(string s) {\n  stack<char> str_stack, tmp_stack;\n  for(int i=0;s[i];i++){\n    if(s[i]!=']') str_stack.push(s[i]);\n    else {\n      while(str_stack.top()!='['){\n        tmp_stack.push(str_stack.top());\n        str_stack.pop();\n      }\n      str_stack.pop();\n      string tmp_str=\"\";\n      while(!tmp_stack.empty()){\n        tmp_str+=tmp_stack.top();\n        tmp_stack.pop();\n      }\n      string single_str=\"\";\n      short times=str_stack.top()-'0';\n      str_stack.pop();\n      string final_str=\"\";\n      for(int j=0;j<times;j++){\n        final_str+=tmp_str;\n      }\n      for(int j=0;j<final_str.length();j++){\n        str_stack.push(final_str[j]);\n      }\n    }\n  }\n  string ret=\"\",ret_reverse=\"\";\n  while(!str_stack.empty()){\n    ret+=str_stack.top();\n    str_stack.pop();\n  }\n  for(int i=ret.length()-1;i>=0;i--){\n    ret_reverse+=ret[i];\n  }\n  return ret_reverse;\n}\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N2)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088699390","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n\n### 思路\n\n在push操作的时候处理一下，再使用一个临时栈，把栈中的内容反过来，这样永远保证栈是队列的反向，这样执行pop和peek都可以直接调用栈的pop和top。\n\n### 代码\n\n\n```cpp\n\n\nclass MyQueue {\nstack<int> my_queue;\npublic:\n    MyQueue() {\n      \n    }\n    \n    void push(int x) {\n      if(my_queue.empty()) my_queue.push(x);\n      else {\n        stack<int> tmp_queue;\n        while(!my_queue.empty()){\n          tmp_queue.push(my_queue.top());\n          my_queue.pop();\n        }\n        my_queue.push(x);\n        while(!tmp_queue.empty()){\n          my_queue.push(tmp_queue.top());\n          tmp_queue.pop();\n        }\n      }\n    }\n    \n    int pop() {\n      int ret=my_queue.top();\n      my_queue.pop();\n      return ret;\n    }\n    \n    int peek() {\n      return my_queue.top();\n    }\n    \n    bool empty() {\n      return my_queue.empty();\n    }\n};\n\n\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091905658","body":"## 2022-04-07\n\n### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n\n### 思路\n\n每次都遍历找到尾元素和尾元素的前一个元素，然后将前一个元素的next置空，将尾元素next指向head，head指向新的head（tail），然后继续循环。\n\n**关键点是**\n循环的次数要对链表元素个数取模，可以减少很多次循环。\n### 代码\n\n\n```cpp\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int list_size(ListNode *head){\n      int n=0;\n      while(head){\n        n++;\n        head=head->next;\n      }\n      return n;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n      if(!head || !(head->next)) return head;\n      k=k%list_size(head);\n      ListNode *tail=head->next;\n      ListNode *pre_tail=head;\n      \n      for(int i=0;i<k;i++){\n        while(tail->next){\n          pre_tail=tail;\n          tail=tail->next;\n      }\n        pre_tail->next=NULL;\n        tail->next=head;\n        head=tail;\n      }\n      return head;\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093032613","body":"## 2022-04-08\n\n### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n\n### 思路\n\n维护三个变量，分别指向pre,cur,post前中后三个节点，直接交换，认真一点儿做好每个节点的next归属就行\n\n\n### 代码\n\n\n```cpp\n\n\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      if(!head || !(head->next)) return head;\n      ListNode ptr(0,head);\n      ListNode *pre=&ptr, *cur=head,*post=cur->next;\n      do{\n        cur->next=post->next;\n        post->next=cur;\n        pre->next=post;\n        pre=cur;\n        if(cur==head) head=post;\n        cur=pre->next;\n        if(cur)\n          post=cur->next;\n      }while(pre && cur && post);\n      return head;\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094064568","body":"## 2022-04-09\n\n### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n\n### 思路\n\n主要是利用二叉搜索树的性质，二叉搜索树的中序遍历是一个有序数列。\n构建二叉树的前提是中序遍历+任何其他遍历，中序遍历确定左右子树，其他遍历确认根节点。这里已经知道中序遍历，所以只需要找根节点。因为要构建平衡二叉搜索树，所以需要两边一样多，所以根节点就是有序数列的中位数。\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    int getListSize(ListNode *head)\n{\n  int ret=0;\n  while(head){\n    ret++;\n    head=head->next;\n  }\n  return ret;\n}\n    TreeNode* sortedListToBST(ListNode* head) {\n      if(!head) return nullptr;\n      if(!(head->next)){\n        TreeNode *ret=new TreeNode(head->val);\n        return ret;\n      }\n      int size=getListSize(head);\n      int mid= size>>1;\n      int i=0;\n      ListNode* pre_list=head;\n      while(i<mid-1){\n        pre_list=pre_list->next;\n        i++;\n      }\n      ListNode *cur=pre_list->next;\n      ListNode *post=cur->next;\n      pre_list->next=nullptr;\n      TreeNode *root=new TreeNode(cur->val);\n      root->left=sortedListToBST(head);\n      root->right=sortedListToBST(post);\n      return root;\n    }\n};\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094255628","body":"## 2022-04-10\n\n### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n\n### 思路\n\n这个题最简单最直接的思路就是利用一个集合，把第一个链表的节点存进去，再遍历第二个链表，一个一个查看是不是重复的节点，第一个重复的节点就是相交的地方。但是这个的空间时间复杂度都较高，代码中注释部分就是这个解法。\n\n巧妙地是第**二个办法**，因为两个链表如果在某个节点重合，那么后续的部分是完全一样的。假设a链表先到达了重合点，那么他到了结尾，如果从b链表的开头开始，下次一定会和b在重合点见面。因为a+b-c=b+a-c. 这个时间复杂度是on，空间复杂度是o1.见代码未注释的部分。\n\n\n### 代码\n\n\n```cpp\n\n\n// class Solution {\n// public:\n//     int getSize(ListNode *head){\n//       int ret=0;\n//       while(head){\n//         ret++;\n//         head=head->next;\n//       }\n//       return ret;\n//     }\n//     ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n//       if(!headA || !headB) return nullptr;\n//       if(getSize(headA)>getSize(headB)){\n//         ListNode *tmp=headA;\n//         headA=headB;\n//         headB=tmp;\n//       }\n//       set<ListNode*> records;\n//       while(headA){\n//         records.insert(headA);\n//         headA=headA->next;\n//       }\n//       while(headB){\n//         if(records.count(headB))\n//           return headB;\n//         headB=headB->next;\n//       }\n//       return nullptr;\n//     }\n// };\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      if(!headA || !headB) return nullptr;\n      ListNode *A=headA, *B=headB;\n      bool flagA=true,flagB=true;\n      while(headA && headB){\n        if(headA==headB) return headA;\n        if(headA->next) headA=headA->next;\n        else if(flagA) {headA=B; flagA=false;}\n        else headA=nullptr;\n        if(headB->next) headB=headB->next;\n        else if(flagB) {headB=A; flagB=false;}\n        else headB=nullptr;\n      }\n      return nullptr;\n    }\n};\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096903377","body":"## 2022-04-12\n\n### [146. LRU缓存](https://leetcode-cn.com/problems/lru-cache/)\n\n\n### 思路\n\n这个题主要是选取数据结构吧。首先因为有键值对，所以肯定要有哈希表。至于怎么把最不常用的元素取出，我用了一个额外的哈希表和一个链表。额外的哈希表存储每一个key对应的在链表中的上一个节点的地址。链表存储key的访问情况，链表最开始的是最不常用的。\n基本策略是新添加的放在链表尾部，每访问一个也重新把该元素放到链表尾部。插入的时候如果满了，就把链表头部元素去掉。\n要注意index哈希表也就是额外的哈希表的更新情况，重点就是这个，可以看代码。\n\n\n### 代码\n\n\n```cpp\n\n\nclass List{\npublic:\n  int key;\n  List* next;\n};\n\nclass LRUCache {\nprivate:\n  map<int,int> cache;//cache本身\n  map<int,List *> index;//存放每个key在List中的前一个元素的地址。\n  List *sort;//链表开头代表最不常用的元素\n  List* last;\n  int size;\n  int num;\npublic:\n    LRUCache(int capacity) {\n      sort=new List();\n      sort->key=-1;\n      sort->next=nullptr;\n      last=sort;\n      size=capacity;\n      num=0;\n    }\n    \n    int get(int key) {\n      if(cache.count(key)){\n        List*tmp=index[key]->next;\n        if(tmp->next){\n            index[tmp->next->key]=index[key];\n            index[key]->next=tmp->next;\n            index[key]=last;\n            last->next=tmp;\n            tmp->next=nullptr;\n            last=tmp;\n        }\n        \n        return cache[key];\n      }\n      else return -1;\n    }\n    \n    void put(int key, int value) {\n      if(cache.count(key)){\n        cache[key]=value;\n        List*tmp=index[key]->next;\n        if(tmp->next){\n            index[tmp->next->key]=index[key];\n            index[key]->next=tmp->next;\n            index[key]=last;\n            last->next=tmp;\n            tmp->next=nullptr;\n            last=tmp;\n        }\n        return;\n      }\n      else if(num==size){\n        List* tmp=sort->next;\n        int remove=tmp->key;\n        if(tmp->next)\n            index[tmp->next->key]=index[remove];\n        sort->next=sort->next->next;\n        cache.erase(cache.find(remove));\n        index.erase(index.find(remove));\n        delete tmp;\n        num--;\n        if(!(sort->next)) last=sort;\n      }\n      \n        cache[key]=value;\n        List* tmp=new List();\n        tmp->key=key;\n        tmp->next=nullptr;\n        index[key]=last;\n        last->next=tmp;\n        last=tmp;\n        num++;\n      \n    }\n};\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n#### 备注\n看一下别人的解法，我这个根据提交记录看，比别人的慢很多。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1099972368","body":"## 2022-04-13\n\n### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n\n### 思路\n\n深度优先遍历\n\n\n### 代码\n\n\n```cpp\n\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int max(int a,int b){\n        return a>b?a:b;\n    }\n    int maxDepth(TreeNode* root) {\n      if(!root) return 0;\n      return 1+max(maxDepth(root->left),maxDepth(root->right));\n    }\n};\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(min(m,n))，其中  m,n 为树节点数。\n- 空间复杂度：O(min(m,n))\n\n#### 备注","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099218260","body":"## 2022-04-14\n\n### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n\n### 思路\n\n这个就简单的深度优先遍历，先判断俩结点都为空则返回TRUE，否则如果俩只有一个为空则返回false，如果都不为空，则判断结点的值是否相同&&左右子树是否一样。\n\n\n### 代码\n\n\n```cpp\n\n\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n      if(!p && !q) return true;\n      else if(!p || !q) return false;\n      else {\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right) ;\n      }\n    }\n};\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(min(m,n))，其中  m,n 为树节点数。\n- 空间复杂度：O(min(m,n))\n\n#### 备注","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100686221","body":"## 2022-04-16\n\n### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\n\n\n### 思路\n\n层序遍历，每到了新的一层记下第一个节点的值就好\n\n\n### 代码\n\n\n```cpp\n\n  struct TreeNode {\n      int val;\n      TreeNode *left;\n      TreeNode *right;\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n  };\n\nstruct QueueNode {\n  TreeNode *tree;\n  int layer;\n  QueueNode(): tree(nullptr),layer(0) {} \n  QueueNode(TreeNode *t, int cur):tree(t),layer(cur){}\n};\n\nclass Solution {\n    \npublic:\n    int cur_layer;\n    QueueNode *queue_node;\n    int findBottomLeftValue(TreeNode* root) {\n      if(!root) return 0;\n      queue_node=new QueueNode();\n      queue_node->layer=0;\n      queue_node->tree=root;\n      cur_layer=0;\n      int ret=root->val;\n      queue<QueueNode*> nodes;\n      nodes.push(queue_node);\n      while(!nodes.empty()){\n        QueueNode *tmp=nodes.front();\n        if(tmp->tree->left) {\n          QueueNode *tmp_queue=new QueueNode(tmp->tree->left,tmp->layer+1); \n          nodes.push(tmp_queue);\n        }\n        if(tmp->tree->right){\n          QueueNode *tmp_queue=new QueueNode(tmp->tree->right,tmp->layer+1); \n          nodes.push(tmp_queue);\n        }\n        if(cur_layer!=tmp->layer){\n          ret=tmp->tree->val;\n          cur_layer++;\n        }\n        nodes.pop();\n        delete tmp;\n      }\n      return ret;\n    }\n};\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(min(m,n))，其中  m,n 为树节点数。\n- 空间复杂度：O(min(m,n))\n\n#### 备注\n复杂度有点儿高，参考别人代码","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101387615","body":"## 2022-04-18\n\n### [987. 二叉树的垂序遍历](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)\n\n\n### 思路\n\n先dfs二叉树，把元素按照(col,row,val)的元组的形式存在一个vector中，然后对vector进行排序，按照先col后row后val的升序排列进行排序。也可以不用元组，自定义一个三个元素的struct，然后vector中存放这个struct，并自定义comapare函数，如果col小则小，col一样row小则小，都一样val小则小。最后遍历排序好的vector分别放在结果的vector中。\n\n\n### 代码\n\n\n```cpp\n\n  #include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n //* Definition for a binary tree node.\n  struct TreeNode {\n      int val;\n      TreeNode *left;\n      TreeNode *right;\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n      TreeNode(int x, TreeNode *left, TreeNode*right) : val(x), left(left), right(right) {}\n  };\n\nclass Solution {\npublic:\n    vector<tuple<int,int,int>> nodes;\n    void dfs(TreeNode *root,int row,int col){\n      if(!root) return;\n      nodes.emplace_back(col,row,root->val);\n      if(root->left) dfs(root->left,row+1,col-1);\n      if(root->right) dfs(root->right,row+1,col+1);\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root,0,0);\n        sort(nodes.begin(),nodes.end());\n        vector<vector<int>> ret;\n        vector<int> tmp;\n        tmp.emplace_back(get<2>(nodes[0]));\n        int last_col=get<0>(nodes[0]);\n        bool last_flag=false;\n        for(int i=1;i<nodes.size();i++){\n          if(get<0>(nodes[i])==last_col){\n            tmp.emplace_back(get<2>(nodes[i]));\n          }\n          else{\n            ret.push_back(tmp);\n            tmp.clear();\n            tmp.emplace_back(get<2>(nodes[i]));\n            last_col=get<0>(nodes[i]);\n            \n            \n          }\n          if(i==nodes.size()-1) last_flag=true;\n        }\n        if(last_flag) ret.push_back(tmp);\n      return ret;\n    }\n};\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(min(m,n))，其中  m,n 为树节点数。\n- 空间复杂度：O(min(m,n))\n\n#### 备注\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102580644","body":"## 2022-04-19\n\n### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)\n\n\n### 思路\n\n用哈希表存储值和下标的键值对。对每个值的(target-value)为key建立新的键值对，下次碰到这个值，直接返回两个下标。\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n      map<int,int> hash;\n      vector<int> ret;\n      for(int i=0;i<nums.size();i++){\n        if(hash.find(nums[i])==hash.end()){\n          hash[nums[i]]=i+1;\n          int diff=target-nums[i];\n          if(diff==nums[i]){\n            hash[diff]=-(i+1);\n          }\n          else{\n            hash[diff]=-1;\n          }\n        }\n        else{\n          if(nums[i]*2==target){\n            ret.emplace_back(-hash[nums[i]]-1);\n            ret.emplace_back(i);\n            break;\n          }\n          else if(hash[nums[i]]==-1){\n            ret.emplace_back(hash[target-nums[i]]-1);\n            ret.emplace_back(i);\n            break;\n          }\n        }\n      }\n      return ret;\n    }\n};\n```\n\n#### **复杂度分析**\n\n\n\n#### 备注","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107848884","body":"看了题解，同余和前缀和，这部分有些生疏，数学方面。\n\n``` cpp\nclass Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n\n        long long sum = 0;\n        for(int e: nums) sum += (long long)e;\n        long long mod = sum % (long long)p;\n\n        if(mod == 0ll) return 0;\n\n        int res = nums.size();\n        unordered_map<long long, int> table;\n        table[0ll] = -1;\n\n        sum = 0;\n        for(int i = 0; i < nums.size(); i ++){\n            sum += (long long)nums[i];\n            long long curmod = sum % (long long)p;\n            table[curmod] = i;\n\n            long long targetmod = curmod >= mod ? (curmod - mod) : (curmod - mod + p);\n            if(table.count(targetmod))\n                res = min(res, i - table[targetmod]);\n        }\n        return res == nums.size() ? -1 : res;\n    }\n};\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110775039","body":"## 2022-04-27\n\n### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n\n### 思路\n\n一个简单的二分查找，区别就是二分查找只看相等，这里比较大小。注意边界情况就可以，left==right和left>right是一样的，都是到了查找的出口。\n\n\n### 代码\n\n\n```cpp\n\n\nclass Solution {\npublic:\n    int binary_search(vector<int>& nums, int right,int left,int target)\n{\n  if(right==left || right<left) return nums[left]<target ? left+1 : left;\n  int middle=(left+right)>>1;\n  if(target>nums[middle])\n    return binary_search(nums,right,middle+1,target);\n  else if(target==nums[middle])\n    return middle;\n  else return binary_search(nums,middle-1,left,target);\n  \n}\n    int searchInsert(vector<int>& nums, int target)   {\n      if(nums[0]>target) return 0;\n      if(nums[nums.size()-1]<target) return nums.size();\n      return binary_search(nums,nums.size()-1,0,target);\n      \n  }\n};\n\n\n```\n\n#### **复杂度分析**\nO(logn)\n\n\n#### 备注\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113332198","body":"## 2022-04-29\n\n### [997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)\n\n\n### 思路\n\n这是一个典型的图的题，但我一开始没想到。\n我用的方法是一个集合数组，保存了每个人的被信任的集合，如果结合的个数为N-1（说明除了他自己都相信他），并且另外一个flag标志数组为true，则他是法官，否则没有法官。\n该方法时空复杂度都很高，还是要用图的方式。\n\n\n### 代码\n\n\n```cpp\n\n\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n      vector<set<int>> matrix(n);\n      vector<bool> flags(n,true);\n      for(int i=0;i<trust.size();i++){\n        matrix[trust[i][1]-1].insert(trust[i][0]-1);\n        flags[trust[i][0]-1]=false;\n      }\n      int ans=-1;\n      for(int i=0;i<n;i++){\n        if(matrix[i].size()==n-1 && flags[i]){\n          ans=i;\n          break;\n        }\n      }\n      return ans==-1?-1:ans+1;\n    }\n};\n\n\n```\n\n#### **复杂度分析**\n\n\n\n#### 备注\n使用图算法的入度出度会好很多。\n\n* * *","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086761350","body":"# Day 3: 1381. Design a Stack With Increment Operation (stack)\n\n- Problem Link\n  - [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n- Ideas\n  -  We could either use vanilla way to implement, or use an array to store the information. Use an additional array to record the increment value. inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack. Then inc[i-1]+=inc[i], so that we can accumulate the increment inc[i] for the bottom elements and the following pops.\n  \n- Complexity: hash table and bucket\n  - Time: O(1)\n  - Space: O(N)\n\n- Code\n\n```python\nclass CustomStack:\n    \n    def __init__(self, maxSize: int):\n        self.list = []\n        self.inc = [] #log inc value and add to the number when poping a number\n        self.maxsize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) >1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) -1] +=val\n```\n\n- other resources:\n    - ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087073148","body":"# Day 4: 394. Decode String (stack, dfs, bracket)\n\n- Problem Link\n  - [394. Decode String](https://leetcode.com/problems/decode-string/)\n  - Other useful links:\n\n- Ideas\n  -  ideas are from [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2). We could use stack to store the information before the first ']'. When we meet the first ']' we will get the string before it, then get all the numbers before the string. \n  -  Note the += might cause error since it is reversed order. and not that `stack[-1] != '[':` is required to avoid [ in the string.\n\n- Complexity: \n  - Time: O(len(decoded_string))\n  - Space:  O(len(decoded_string))\n\n- Code\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c ==']':\n                string_to_repeat = ''\n                repeat_times = ''\n                while stack and stack[-1] != '[':\n                    string_to_repeat  =stack.pop() + string_to_repeat\n                stack.pop()  #pop out [\n                while stack and stack[-1].isnumeric():\n                    repeat_times  = stack.pop() + repeat_times\n                stack.append(string_to_repeat * int(repeat_times))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```\n\n- other resources:\n  - [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092019966","body":"# Day 8: 24. Swap Nodes in Pairs (linked list)\n\n- Problem Link\n  - [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/submissions/)\n\n- Ideas\n  -  we could iterate the linked list to swap the nodes. We need a dummy pre head, and represent the first two nodes as pre-1-2-n. Then we point pre to 2, and point 1 to n, and then point 2 to 1. After that we locate to the original first node. So we have pre-2-**1**-n.\n\n- Complexity: \n  - Time: O(N)\n  - Space: O(1)\n\n- Code\n\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        if not head or not head.next: return head\n        ans = ListNode()\n        ans.next = head #previous dummy node of first node\n        pre = ans #pre is used to iterate all the nodes, while ans remains at the beginning.\n        #pre-1-2-n\n        while pre.next and pre.next.next:\n            firstNode = pre.next\n            secondNode = pre.next.next\n            pre.next = secondNode #prehead point to the second  -->pre-2-n; 1 \n            firstNode.next = secondNode.next #first point to the next of second  -->pre-2; 1-n\n            secondNode.next = firstNode #second point to the original first  -->pre-2-1-n\n            pre = pre.next.next #locate to the first node of the current pair need to be swapped.\n        return ans.next #next of prehead, which is the first node of transformed list.\n```\n\n- other resources:\n    - [solution in lc](https://leetcode.com/problems/swap-nodes-in-pairs/discuss/171788/Python-or-Dummynode)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1096937442","body":"# Day 13: 104. Maximum Depth of Binary Tree (binary tree, BFS)\n\n- Problem Link\n  - [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n- Ideas\n  - it is an easy problem. We just focus on the basic structure, focus on one root and use recursion to solve the problem.\n\n- Complexity:\n  - Time: O(# nodes)\n  - Space: O(depth of the tree) *(worst case is # nodes which degenerate to a linked list)*\n\n- Code\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return 1 + max( maxDepth(root.left) + maxDepth(root.right))\n```\n\n- other resources:\n    - ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100474519","body":"# Day 16: 513. Find Bottom Left Tree Value (binary tree, BFS, DFS)\n\n- Problem Link\n  - [513. Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/)\n\n- Ideas\n  - There are two solutions, DFS and BFS\n    - DFS: it is natural to use DFS to traverse from root to each leaf and locate the first node which is at the deepest layer. We could define a `DFS` function inside the `findBottomLeftValue` function. Note that we need both current position and current layer depth to be passed to the `DFS` function. The `tricky` part is we should maintain two global values to record the leftmost node and the deepest layer, outside the `DFS` but in `__init__`, so `DFS` doesn't need to return value. We could have recursion which requires root's both `left and right node. We won't update the two global values only if the new layer's depth is deeper than the global value! Complexity: Time: O(# nodes); Space: O(depth of the tree), *(worst case is # nodes which degenerate to a linked list)*\n    - BFS: use BFS template, we could have deque to record the current leftmost node. The while loop iterate through each layer. the for loop go over each node in one layer. we pop each node in the layer and append child nodes in the next layer for the next loop in while. Then the res is the bottom left value. Time: O(# nodes); Space: O(q), *(q is length of deque, the worst case is # nodes/2 if the BST is full, the deepest layer will have $\\frac{n}{2}$ nodes)*\n\n- Complexity: (DFS)\n  - Time: O(# nodes)\n  - Space: O(depth of the tree)\n\n- Code\n\n```python\n# DFS\nclass Solution:\n    def __init__(self):\n        self.result = 0\n        self.max_depth = 0\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.result = root.val\n        def DFS(node, depth):\n            if not node:\n                return\n            if depth > self.max_depth:\n                self.result = node.val\n                self.max_depth = depth\n            DFS(node.left, depth+1)\n            DFS(node.right, depth+1)\n        DFS(root, 0)\n        return self.result\n\n#BFS\nimport collections\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            length = len(queue)\n            #print ('length',length)\n            #print ('current value in deque',[i.val for i in queue])\n            res = queue[0].val\n            for _ in range(length):\n                cur = queue.popleft()\n                #print (cur.val)\n                if cur.left:\n                    queue.append(cur.left)\n                if cur.right:\n                    queue.append(cur.right)\n            #print ('current value in deque after append',[i.val for i in queue])\n        return res\n```\n\n- other resources:\n    - ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1100938795","body":"# Day 18: 987. Vertical Order Traversal of a Binary Tree (binary tree, BFS, DFS)\n\n- Problem Link\n  - [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/submissions/)\n\n- Ideas\n  - It is a very classic problem. We need to implement the list/string to BST and reversal process. We could use BFS or DFS.\n    - BFS: It is more straightforward for me to use BFS. Use the template, and one thing to note is that for the exact same position (same layer, same vertical position, we should sort the value too). If we only record one vertical position, we need to add another for loop to make sure we are dealing with one layer. Then iterate through pos keys in this layer, sort each position, we could satisfy the needs.  Time: O(NlogN); Space: O(N)\n    - DFS: We could also use DFS, in DFS, record the x, y position and value. Then after dfs, sort the dict! It is also very straightforward. Note that `collections.defaultdict(list)` could be used so that if the dict does not have a key, it could initiate an empty list for that new key; Time: O(NlogN); Space: O(N)\n\n- Complexity: (DFS)\n  - Time: O(NlogN)\n  - Space: O(N) \n\n- Code\n\n```python\n#BFS\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        pos = 0\n        res = collections.defaultdict(list) \n        q = deque()\n        q.append((root,pos))\n        prev_pos = 100\n        while q:\n            restmp = collections.defaultdict(list) \n            #print ('new run' )\n            for _ in range(len(q)):\n                node,pos = q.popleft()\n                if pos in restmp.keys():\n                    restmp[pos].append(node.val)\n                else:\n                    restmp[pos] = [node.val]\n                if node.left:\n                    q.append((node.left,pos-1))\n                if node.right:\n                    q.append((node.right,pos+1))\n            for key in restmp.keys():\n                #for the node in exact same position, should sort the value! we do this by sort the value with same pos(key)  and in the same layer.\n                res[key] += sorted(restmp[key])\n        return [ res[key] for key in sorted(res.keys()) ]\n```\n\n- other resources:\n    - ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105895795","body":"# Day 22: 3. Longest Substring Without Repeating Characters (hashtable, sliding window, two pointers)\n\n- Problem Link\n  - [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/submissions/)\n\n- Ideas\n  - Very classic sliding window problem. Note that we only need to record and return the max_length value. But The start point of the maximum length substring could change depend on if a letter has been seen before. If seen and the start point is `<=` the letter last seen, then we should update the start point (for example `\"tmmzuxt\"`, the first t is outdated, do not need to reset start). For novice like me, one tricky part which requires more thinking is that some cases like `aa` means the previous maximum substring is ruined, but it doesn't matter since it is recorded in max_length and `used`\n\n- Complexity: hash table and bucket\n  - Time: O(N)\n  - Space: O(s) worst case N\n\n- Code\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        start = 0\n        max_length = 0\n        used = {}\n        for count, string in enumerate(s):\n            if string in used and start <= used[string]: \n                start = used[string] + 1\n            else:\n                max_length = max(max_length, count - start+1)\n            used[string] =  count\n            print (used, start, used[string])\n        return max_length\n```\n\n- other resources:\n    - ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107675846","body":"# Day 24: 1590. Make Sum Divisible by P (hashtable, prefix sum, congruence)\n\n- Problem Link\n  - [1590. Make Sum Divisible by P](https://leetcode.com/problems/make-sum-divisible-by-p/submissions/)\n\n- Ideas\n  - We could use prefix sum and congruence to solve the problem, or not use prefix sum.\n  - Note that we are finding a contiguous subarray, where the value in the array are all positive. So the prefix sum monotonically increases. We need $ (sum−sub)\\%p=0->sum\\%p=sub\\%p $. If we have: $ mod=sum\\%pmod=sum\\%p $, then we are actually finding $ pre[j]\\%p−pre[i]\\%p=mod $. Then if we have a hashtable to store the key-value which is mod-position, we could find that at position $j$, if there exists: $pre[j]\\%p−mod$ in the hashtable. If yes then the $j-hashtable[(curmod - mod + p) \\% p]$ is the distance of a candidate subarray. Then we could compare with previous minimum res.\n  - We could even discard the prefix sum. Just use `cur = (cur + val) % p` and use `cur - remainder` as keys of the hashtable could do the trick!\n  - Note that `hashtable = {0: -1}`(as the pair before the first element) and `return res if res < n else -1` are small tricks\n- Complexity: hash table and bucket\n  - Time: O(N)\n  - Space: O(N)\n\n- Code\n\n```python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        pre = list(accumulate(nums, add))\n        mod = pre[-1] % p\n        hashT = {0:-1}\n        if mod == 0: return 0\n        res = len(nums)\n        for i in range(len(nums)):\n            curmod = pre[i] % p\n            hashT[curmod] = i\n            tarmod = (curmod - mod + p) % p\n            if tarmod in hashT:\n                res = min(res, i - hashT[tarmod])\n        return res if res < len(nums) else -1\n\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        remainder = sum(nums) % p\n        hashtable = {0: -1}\n        cur = 0\n        res = n = len(nums)\n        for i, val in enumerate(nums):\n            cur = (cur + val) % p\n            hashtable[cur] = i\n            if (cur - remainder) % p in hashtable:\n                res = min(res, i - hashtable[(cur - remainder) % p])\n        return res if res < n else -1\n```\n\n- other resources:\n    - https://leetcode.com/problems/make-sum-divisible-by-p/discuss/854197/JavaC%2B%2BPython-Prefix-Sum\n    - https://leetcode-cn.com/problems/make-sum-divisible-by-p/solution/shu-zu-zheng-chu-wen-ti-hui-zong-qian-zh-xzjc/\n    - the similar questions: 523, 974","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112763970","body":"# Day 29: 997. Find the Town Judge (array, hashtable, graph)\n\n- Problem Link\n  - [997. Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/)\n\n- Ideas\n  -  Count the in, and use set to judge if the vertex is seen in `out_vertex`. if count = N-1 and is not seen in `out_vertex` it is the judge. But we need to take care of several edge cases.\n  -  Use graph. We could use a graph, and count for each vertex, we have the edge as list. We count the in and out degrees for each vertex. And the judge satisfies the `in_degree == N-1` and `out_degree == 0`.\n  -  Optimize a little bit. We know that in this case, the difference between in and out should be exactly N-1. Since the max in is N-1 and the min out is 0. So if the difference is N-1, it must be the judge.\n  \n- Complexity: hash table and bucket\n  - Time: O(N)\n  - Space: O(N)\n\n- Code\n\n```python\n#need a n-1 trust and not trust for others. \nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        if len(trust) == n:\n            return -1\n        if len(trust) == 0: #only judge itself\n            return 1 if n == 1 else -1\n        count = Counter([i[1] for i in trust])\n        out_vertex = set([i[0] for i in trust])\n        res = list(map(lambda x: x[0], filter(lambda x: x[1] ==n-1, count.items())))\n        res = [i for i in res if i not in out_vertex]\n        return res[0] if len(res) >0 else -1\n\n#some similar idea: https://leetcode-cn.com/problems/find-the-town-judge/solution/997zhao-dao-xiao-zhen-de-fa-guan-ha-xi-b-x7eu/\nclass Solution:\n    def findJudge(self, n, trust):\n        people, judge = set(range(1, n + 1)), defaultdict(int)\n        for p, j in trust:\n            if p in people:\n                people.remove(p)\n            judge[j] += 1\n        if len(people) != 1:\n            return -1\n        person = people.pop()\n        return -1 if judge.get(person, 0) != n - 1 else person\n    \n#we could use graph, and count for each vertex, we have the edge as list. We count the in and out degrees for each vertex. And the judge satisfies the in degree == N-1 and out degree == 0\n\nclass Solution:\n     def findJudge(self, N, trust):\n        in_degree = [0] * (N + 1)\n        out_degree = [0] * (N + 1)\n        for a, b in trust:\n            in_degree[b] += 1\n            out_degree[a] += 1\n        for i in range(1, N + 1):\n            if in_degree[i] == N - 1 and out_degree[i] == 0:\n                return i\n        return -1\n    \n#to optimize, we know that in this case, the difference between in and out should be exactly N-1. Since the max in is N-1 and the min out is 0. So if the difference is N-1, it must be the judge.\nclass Solution:\n     def findJudge(self, N, trust):\n        count = [0] * (N + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, N + 1):\n            if count[i] == N - 1:\n                return i\n        return -1\n```\n\n- other resources:\n  - https://leetcode-cn.com/problems/find-the-town-judge/solution/997zhao-dao-xiao-zhen-de-fa-guan-ha-xi-b-x7eu/","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"floatingstarlight":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1089174724","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n\t\tfinal int len = num.length;\n\t\tfor(int i = len - 1; i >= 0; i--) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif(sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\t\n\t\t\tres.add(0, sum);\n\t\t}\n\t\tfor(; k > 0; k /= 10) {\n\t\t\tres.add(0, k % 10);\n\t\t}\n\t\treturn res;\n    }\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1089176229","body":"public int[] shortestToChar(String s, char c) {\n    int n = s.length();\n    int[] ans = new int[n];\n    int flag = 0, index_c = 0;\n    for(int i = 0; i < n; i++){\n        ans[i] = n;//赋初始最大值\n        if(s.charAt(i) == c){\n            flag = 1;\n            index_c = i;\n        }\n        if(flag == 1){\n            ans[i] = i - index_c;//赋距离值\n        }\n    }\n    flag = 0;\n    for(int i = n - 1; i >= 0; i--){\n        if(s.charAt(i) == c){\n            flag = 1;\n            index_c = i;\n        }\n        if(flag == 1){\n            if(index_c - i < ans[i])\n                ans[i] = index_c - i;//更新距离值\n        }\n    }\n    return ans;\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764343","body":"class CustomStack {\n\n    private final int maxSize;\n    private final int[] stack;\n    private final int[] inc;\n    private int top = -1;\n    private final int bottom = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top == maxSize - 1) {\n            return;\n        }\n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top < bottom) {\n            return -1;\n        }\n        int res = stack[top] + inc[top];\n        if (top > bottom) {\n            inc[top - 1] += inc[top];\n        }\n        inc[top] = 0;\n        top--;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k - 1, top);\n        if (i >= bottom) {\n            inc[i] += val;\n        }\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089174267","body":"class MyQueue {\n    private Stack<Integer> a;// \n    private Stack<Integer> b;// \n    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n  \n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094060347","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    //[start, end) \n    TreeNode build(ListNode start, ListNode end){\n        if(start == end){\n            return null;\n        }\n        \n        ListNode mid = findMid(start, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(start, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    //two pointers\n    ListNode findMid(ListNode start, ListNode end){\n        ListNode slow = start, fast = start;\n        while (fast != end && fast.next != end){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100750245","body":"\r\n   \r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        \"\"\"\r\n        Ideas: DFS -> have depth -> update ans\r\n        TC: O(n)\r\n        SC: O(h) = O(n)\r\n        \r\n        \"\"\"\r\n        max_depth = -1\r\n        ans = 0\r\n        def dfs(root, depth):\r\n            nonlocal max_depth, ans\r\n            if not root: return\r\n            if depth > max_depth:\r\n                ans = root.val\r\n                max_depth = depth\r\n            dfs(root.left, depth + 1)\r\n            dfs(root.right, depth + 1)\r\n        dfs(root, 0)\r\n        return ans","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100750082","body":"class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"        \n        def dfs(root):\n            if not root:\n                self.s.append('#')\n            else:\n                self.s.append(str(root.val))\n                dfs(root.left)\n                dfs(root.right)\n\n        self.s = []  \n        dfs(root)\n        return ' '.join(self.s)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs():\n            if data:\n                cur = data.popleft()\n                if cur == '#':\n                    return\n                node = TreeNode(int(cur))\n                node.left = dfs()\n                node.right = dfs()\n            return node\n                        \n        data = collections.deque(val for val in data.split())\n        return dfs()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101031412","body":"class Solution {\n    Map<Integer, Map<Integer, List<Integer>>> map = new TreeMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        tranverse(root, 0, 0);\n        List<List<Integer>> results = new ArrayList<>();\n        for (int col : map.keySet()) {\n            Map<Integer, List<Integer>> curColMap = map.get(col);\n            List<Integer> newList = new ArrayList<>();\n            for (int row : curColMap.keySet()) {\n                Collections.sort(curColMap.get(row));\n                newList.addAll(curColMap.get(row));\n            }\n            results.add(newList);\n        }\n        return results;\n    }\n    private void tranverse(TreeNode root, int column, int row) {\n        if (root == null) {\n            return;\n        }\n        map.putIfAbsent(column, new TreeMap<>());\n        Map<Integer, List<Integer>> curCol = map.get(column);\n        curCol.putIfAbsent(row, new ArrayList<>());\n        curCol.get(row).add(root.val);\n        tranverse(root.left, column - 1, row + 1);\n        tranverse(root.right, column + 1, row + 1);\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086775193","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = []\n        self.cnt = 0\n        self.size = maxSize\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.cnt < self.size:\n            self.stack.append(x)\n            self.cnt += 1\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.cnt != 0:\n            self.cnt -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, self.cnt)):\n            self.stack[i] += val\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093011965","body":"### 代码\n```python\nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097509865","body":"### 代码\n```python\nclass Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100807526","body":"### 代码\n```python\nclass Codec:\n    def serialize(self, root):\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n\n        return preorder(root)[:-1]\n\n    def deserialize(self, data: str):\n        nodes = data.split(\",\")\n\n        def preorder(i):\n            if i >= len(nodes) or nodes[i] == \"null\":\n                return i, None\n            root = TreeNode(nodes[i])\n            j, root.left = preorder(i + 1)\n            k, root.right = preorder(j + 1)\n            return k, root\n\n        return preorder(0)[1]\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105989270","body":"### 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        res,left = 0,0\n        hash = set()\n        for i in range(len(s)):\n            if s[i] not in hash:\n                hash.add(s[i])\n            else:\n                res = max(len(hash),res)\n                while True:\n                    hash.remove(s[left])\n                    left += 1\n                    if s[i] not in hash:\n                        hash.add(s[i])\n                        break\n        return max(res,len(hash))\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111726172","body":"### 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = collections.deque() # 本质就是单调队列\n        ans = []\n        for i in range(len(nums)):\n            while q and nums[q[-1]] <= nums[i]: q.pop() # 维持单调性\n            while q and i - q[0] >= k: q.popleft() # 移除失效元素\n            q.append(i)\n            if i >= k - 1: ans.append(nums[q[0]])\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"currybeefer":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086781771","body":"题目：【Day 3】1381. 设计一个支持增量操作的栈\r\n思路： 利用数组和一个指向数组顶部的指针就可以完成。但是注意边界条件的细节问题。\r\n我这里定义的cur指针指向的是下一个需要入栈的值应该存在的位置，所以初始值为0\r\n代码：\r\n```\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) \r\n    {\r\n        max=maxSize;\r\n        arr=new int[maxSize];\r\n        cur=0;\r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        if(cur>=max) return;\r\n        arr[cur]=x;\r\n        cur++;\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        if(cur==0) return -1;\r\n        cur--;\r\n        return arr[cur];\r\n    }\r\n    \r\n    void increment(int k, int val) \r\n    {\r\n        int count=0;\r\n        if(cur<=k-1)\r\n            count=cur;\r\n        else\r\n            count=k;\r\n        \r\n        for(int i=0;i<count;i++)\r\n            arr[i]+=val;\r\n    }\r\npublic:\r\n    int* arr;\r\n    int cur;\r\n    int max;\r\n};\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N) 主要是在 increment()中用了一次循环\r\n空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087057406","body":"思路：使用dfs递归，将字符串分解成字母序列+数字*[字母序列]的形式进行递归求解。括弧里边的表达式都需要放入递归里\r\n代码参考了一位老哥的结构\r\n代码：\r\n`string decodeString(string s) \r\n    {\r\n        int index=0;\r\n        return dfs(s, index);\r\n    }\r\n\r\n    string dfs(string& s, int& index)\r\n    {\r\n        string res;\r\n        while (index < s.size() && s[index] != ']')\r\n        {\r\n            if (s[index] >= 'a' && s[index] <= 'z' || s[index] >= 'A' && s[index] <= 'Z')\r\n            {\r\n                res += s[index];\r\n                index++;\r\n            }\r\n            else if (isdigit(s[index]))\r\n            {\r\n                int k = index;\r\n                while (isdigit(s[k]))\r\n                    k++;\r\n                int num = stoi(s.substr(index, k - index));//stoi string转换成int类型\r\n                index = k + 1;//去掉左括号\r\n                string val = dfs(s, index);//进一步递归，确认括号里的字符串\r\n                index++;\r\n                while (num > 0)\r\n                {\r\n                    res += val;\r\n                    num--;\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }   `\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088092050","body":"思路：这题的思路就是用两个栈模拟就好啦\r\n代码：\r\n` stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() \r\n    {\r\n        \r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        int res;\r\n        while(!stk1.empty())\r\n        {\r\n            int x = stk1.top();\r\n            stk1.pop();\r\n            stk2.push(x);\r\n        }\r\n        res=stk2.top();\r\n        stk2.pop();\r\n        while(!stk2.empty())\r\n        {\r\n            int x = stk2.top();\r\n            stk2.pop();\r\n            stk1.push(x);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    int peek() \r\n    {\r\n        int res;\r\n        while(!stk1.empty())\r\n        {\r\n            int x = stk1.top();\r\n            stk1.pop();\r\n            stk2.push(x);\r\n        }\r\n        res=stk2.top();\r\n        while(!stk2.empty())\r\n        {\r\n            int x = stk2.top();\r\n            stk2.pop();\r\n            stk1.push(x);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    bool empty() \r\n    {\r\n        return stk1.empty();\r\n    }`\r\n复杂度：\r\npeek()和pop()的时间复杂度是O(n)，其他都是O(1)\r\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089831099","body":"思路：按照官方题解说的计数排序的思想来做\r\n代码：C++代码\r\n`int maxChunksToSorted(vector<int>& arr) \r\n    {\r\n        int res=0;\r\n        vector<int> sorted_arr(arr);\r\n        sort(sorted_arr.begin(),sorted_arr.end());\r\n        \r\n        unordered_map<int,int> count_a;\r\n        unordered_map<int,int> count_sa;\r\n        \r\n        for(int i=0;i<arr.size();i++)\r\n        {\r\n            count_a[arr[i]]+=1;\r\n            count_sa[sorted_arr[i]]+=1;\r\n            \r\n            if(count_a==count_sa) res++;\r\n        }\r\n        return res;\r\n    }`\r\n时间复杂度：O(n^2)\r\n空间复杂度: O(n)\r\n脖子疼，我先打个卡，之后再研究剩下的解法....","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091095631","body":"思路： 分析可知，就是将链表的倒数第k个节点开始的部分接到头部就好。对于k大于链表个数的，应该取余后求解。那么用快慢指针法求得倒数第k个节点的位置，但是在此之前应该先计算链表的节点数量count，最后k=k%count。\r\n代码：\r\n` ListNode* rotateRight(ListNode* head, int k) \r\n    {\r\n        if(head==nullptr || head->next==nullptr || k==0) return head;\r\n        ListNode* p=head;\r\n        int count=0;\r\n        while(p!=nullptr)\r\n        {\r\n            count++;\r\n            p=p->next;\r\n        }\r\n        k=k%count;\r\n        \r\n        ListNode* fast=head;\r\n        ListNode* slow=head;\r\n        \r\n        for(int i=0;i<k;i++)\r\n        {\r\n            fast=fast->next;\r\n        }\r\n        while(fast->next!=nullptr)\r\n        {\r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        fast->next=head;\r\n        head=slow->next;\r\n        slow->next=nullptr;\r\n        \r\n        return head;\r\n    }`\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092385610","body":"思路：用双指针就能解决\r\n代码：\r\nListNode* swapPairs(ListNode* head) \r\n    {\r\n        if(head==nullptr || head->next ==nullptr) return head;\r\n        ListNode* vh=new ListNode();\r\n        vh->next=head;\r\n        ListNode* pre=vh;\r\n        ListNode* p1=head;\r\n        ListNode* p2=head->next;\r\n        while(p1!=nullptr && p2!=nullptr)\r\n        {\r\n            swap(pre,p1,p2);\r\n            pre=p1;\r\n            p1=p1->next;\r\n            if(p1==nullptr) break;\r\n            p2=p1->next;\r\n        }\r\n        return vh->next;\r\n    }\r\n    void swap(ListNode* pre, ListNode* p1,ListNode* p2)\r\n    {\r\n        p1->next=p2->next;\r\n        p2->next=p1;\r\n        pre->next=p2;\r\n    }\r\n复杂度：\r\n时间复杂度和空间复杂度都是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093420611","body":"思路：参考官方题解，由于链表已经排序了，所以以寻找到链表的中点，以链表中点为界限，中点左边是二叉搜索树的左孩子们，中点的右边是二叉树的右孩子们。进行递归地构造。\r\n寻找链表的中点当然就用快慢指针法就好啦。\r\nTreeNode* sortedListToBST(ListNode* head) \r\n    {\r\n        if(head==nullptr) return nullptr;\r\n        return sortedListToBST(head,nullptr);\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail)\r\n    {\r\n        if(head==tail) return nullptr;\r\n        ListNode* slow=head;\r\n        ListNode* fast=head;\r\n        //寻找链表中点，以中点为界构造二叉树\r\n        while(fast!=tail && fast->next!=tail)\r\n        {\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }\r\n        TreeNode* root=new TreeNode(slow->val);\r\n        root->left=sortedListToBST(head,slow);\r\n        root->right=sortedListToBST(slow->next,tail);\r\n        return root;\r\n    }\r\n复杂度分析：\r\n时间复杂度为O(nlogn)\r\n空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094135071","body":"思路：用双指针法，之前做过，具体解法看我写的博客：https://blog.csdn.net/Currybeefer/article/details/107434522\r\n代码：\r\n`  if(pHead1==nullptr)\r\n        {\r\n            return pHead1;\r\n        }\r\n        if(pHead2==nullptr)\r\n        {\r\n            return pHead2;\r\n        }\r\n        \r\n        ListNode* p1=pHead1;\r\n        ListNode* p2=pHead2;\r\n        while(p1!=p2)\r\n        {\r\n            p1=p1->next;\r\n            p2=p2->next;\r\n            if(p1!=p2)\r\n            {\r\n                if(p1==nullptr)\r\n                {\r\n                    p1=pHead2;\r\n                }\r\n                if(p2==nullptr)\r\n                {\r\n                    p2=pHead1;\r\n                }\r\n            }\r\n        }\r\n        return p1;\r\n    }`\r\n复杂度：\r\n时间复杂度O(m+n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094440160","body":"思路：这题真没啥好说的了，稍微刷过链表类题目的人应该都见过这个题目。当年第一次遇见是真的没有头绪。\r\n具体方法就看我博客吧，里边写了：https://blog.csdn.net/Currybeefer/article/details/107304915\r\n` ListNode *detectCycle(ListNode *head) \r\n    {\r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n\r\n        while (fast && fast->next) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if (slow == fast) {\r\n                fast = head;\r\n                while (slow != fast) {\r\n                    slow = slow->next;\r\n                    fast = fast->next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return nullptr;    \r\n    }`\r\n由于用了双指针，时间复杂度和空间复杂度都是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095290990","body":"思路：使用哈希链表这个数据结构来写。\r\n代码：\r\n```\r\nclass Node\r\n{\r\npublic:\r\n    int key;\r\n    int val;\r\n    Node* next;\r\n    Node* prev;\r\n    \r\n    Node(int i_key, int i_val)\r\n    {\r\n        key=i_key;\r\n        val=i_val;\r\n    }\r\n};\r\nclass DoubleList\r\n{\r\npublic:\r\n    Node* head;\r\n    Node* tail;\r\n    int size;\r\n    \r\n    DoubleList()\r\n    {\r\n        head=new Node(0,0);\r\n        tail=new Node(0,0);\r\n        head->next=tail;\r\n        tail->prev=head;\r\n        size=0;\r\n    }\r\n    void AddLast(Node* x)\r\n    {\r\n        x->prev=tail->prev;\r\n        x->next=tail;\r\n        tail->prev->next=x;\r\n        tail->prev=x;\r\n        size++;\r\n    }\r\n    void Remove(Node* x)\r\n    {\r\n        x->prev->next=x->next;\r\n        x->next->prev=x->prev;\r\n        size--;\r\n    }\r\n    Node* RemoveFirst()\r\n    {\r\n        if(head->next==tail)\r\n            return nullptr;\r\n        Node* first=head->next;\r\n        Remove(first);\r\n        return first;\r\n    }\r\n    int Size(){return size;}\r\n};\r\nclass LRUCache {\r\npublic:\r\n    unordered_map<int, Node*> map;\r\n    DoubleList cache;\r\n    int cap;\r\n    LRUCache(int capacity) {\r\n        cap=capacity;\r\n        //map=new unorder_map<int,Node*> ();\r\n        //cache=new DoubleList();\r\n    }\r\n    void MakeRecently(int key)\r\n    {\r\n        Node* x=map[key];\r\n        cache.Remove(x);\r\n        cache.AddLast(x);\r\n    }\r\n    void AddRecently(int key, int val) \r\n    {\r\n        Node* x=new Node(key,val);\r\n        cache.AddLast(x);\r\n        map[key]=x;\r\n    }\r\n    void DeleteKey(int key)\r\n    {\r\n        Node* x=map[key];\r\n        cache.Remove(x);\r\n        map.erase(key);\r\n    }\r\n    void RemoveLeastRecently()\r\n    {\r\n        Node* deleNode=cache.RemoveFirst();\r\n        int deleteKey=deleNode->key;\r\n        map.erase(deleteKey);\r\n    }\r\n    int get(int key) \r\n    {\r\n        if(map.find(key)==map.end())\r\n            return -1;\r\n        MakeRecently(key);\r\n        return map[key]->val;\r\n    }\r\n    \r\n    void put(int key, int value) \r\n    {\r\n        if(map.find(key)!=map.end())\r\n        {\r\n            DeleteKey(key);\r\n            AddRecently(key,value);\r\n            return;\r\n        }\r\n        if(cap==cache.Size())\r\n        {\r\n            RemoveLeastRecently();\r\n        }\r\n        AddRecently(key,value);\r\n    }\r\n};\r\n复杂度：\r\n时间复杂度为O(1)\r\n空间复杂度为O(n)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097416162","body":"思路： 这题没啥好说的呀，就是遍历二叉树，找最大的深度呗，很简单\r\n代码：\r\n```\r\n int maxDepth(TreeNode* root) \r\n    {\r\n        return dp(root);\r\n    }\r\n    int dp(TreeNode* root)\r\n    {\r\n        if(root==nullptr)\r\n            return 0;\r\n        \r\n        int a=dp(root->left);\r\n        int b=dp(root->right);\r\n        \r\n        return max(a,b)+1;\r\n    }\r\n    int max(int a, int b)\r\n    {\r\n        return a>b? a:b;\r\n    }\r\n```\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098328951","body":"思路：就是递归验证就好了\r\n代码：\r\n```\r\n    bool isSameTree(TreeNode* p, TreeNode* q) \r\n    {\r\n        if(p==nullptr && q==nullptr) return true;\r\n        if(p==nullptr || q==nullptr) return false;\r\n        \r\n        return ((p->val==q->val)&&isSameTree(p->left,q->left)&&isSameTree(p->right,q->right));\r\n    }\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099850114","body":"思路：就是用递归遍历做，在遍历到达叶子节点的时候将路径值加到全局变量sum中就OK了\r\n代码：\r\n` int sum=0;\r\n    int sumNumbers(TreeNode* root) \r\n    {\r\n        if(root==nullptr) return 0;\r\n        dp(root,0);\r\n        return sum;\r\n    }\r\n    \r\n    void dp(TreeNode* root,int currentSum)\r\n    {\r\n        if(root==nullptr)\r\n            return;\r\n        \r\n        currentSum=currentSum*10+root->val;\r\n        \r\n        if(root->left==nullptr && root->right==nullptr)\r\n            sum+=currentSum;\r\n        \r\n        dp(root->left,currentSum);\r\n        dp(root->right,currentSum);\r\n    }`\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100514351","body":"思路：层序遍历就好啦，用一个数组保存最后一组的row的信息，然后返回数组的第一个元素\r\n代码：\r\n```\r\nint findBottomLeftValue(TreeNode* root) \r\n    {\r\n        if(root==nullptr) return 0;\r\n        \r\n        vector<int> ans;\r\n        queue<TreeNode*> qe;\r\n        qe.push(root);\r\n        \r\n        while(!qe.empty())\r\n        {\r\n            vector<int> row;\r\n            int count=qe.size();\r\n            while(count!=0)\r\n            {\r\n                TreeNode* a=qe.front();\r\n                qe.pop();\r\n                \r\n                row.push_back(a->val);\r\n                \r\n                if(a->left!=nullptr)\r\n                    qe.push(a->left);\r\n                \r\n                if(a->right!=nullptr)\r\n                    qe.push(a->right);\r\n                \r\n                count--;\r\n            }\r\n            ans=row;\r\n        }\r\n        return ans[0];\r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(q)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100954849","body":"思路：这题没有做出来，参考了官方题解和网上的一些代码\r\n代码：\r\n```\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) \r\n    {\r\n         if (root == nullptr)\r\n            return \"#\";\r\n        string result;\r\n        std::queue<TreeNode*> nodeQueue;\r\n        TreeNode* cur = nullptr;\r\n        int isValid = false;\r\n        int size = 0;\r\n        nodeQueue.push(root);\r\n        while (!nodeQueue.empty())\r\n        {\r\n            size = nodeQueue.size();\r\n            for (int i = 0; i < size; ++i)\r\n            {\r\n                cur = nodeQueue.front();\r\n                nodeQueue.pop();\r\n                if (cur == nullptr)\r\n                {\r\n                    result.append(\"#,\");\r\n                    continue;\r\n                }\r\n                result.append(std::to_string(cur->val) + \",\");\r\n                nodeQueue.push(cur->left); \r\n                nodeQueue.push(cur->right); \r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) \r\n    {\r\n        if(data==\"#\") return nullptr;\r\n        vector<string> valArr;\r\n        toStrArr(data,valArr);\r\n        \r\n        TreeNode* root=new TreeNode(std::stod(valArr[0]));\r\n        TreeNode* parent=nullptr;\r\n        \r\n        queue<TreeNode*> qe;\r\n        qe.push(root);\r\n        \r\n        for(int i=1;i<valArr.size();i++)\r\n        {\r\n            parent=qe.front();\r\n            qe.pop();\r\n            \r\n            if(valArr[i].compare(\"#\"))\r\n            {\r\n                parent->left=new TreeNode(std::stod(valArr[i]));\r\n                qe.push(parent->left);\r\n            }\r\n            \r\n            if(valArr[++i].compare(\"#\"))\r\n            {\r\n                parent->right=new TreeNode(std::stod(valArr[i]));\r\n                qe.push(parent->right);\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n    void toStrArr(string data, vector<string> &resArr)\r\n    {\r\n        string node;\r\n        node.reserve(10);\r\n        for(char& ch:data)\r\n        {\r\n            if(ch==',')\r\n            {\r\n                resArr.push_back(node);\r\n                node.clear();\r\n            }\r\n            else\r\n            {\r\n                node+=ch;\r\n            }\r\n        }\r\n    }\r\n```\r\n复杂度：\r\n时间复杂度为：O(n)\r\n空间复杂度为：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101596060","body":"思路：这题已经给出提示了，所有的二叉树节点都可以用坐标表示。那么我们只需要DFS遍历一遍给所有节点标记对应的坐标并且加入到一个集合里，然后按照要求的排序方式输出就好啦\r\n代码：代码参考官方题解\r\n```\r\nstruct node\r\n    {\r\n        int val;\r\n        int x;\r\n        int y;\r\n        node(int i_val, int i_x,int i_y):val(i_val),x(i_x),y(i_y){};\r\n    };\r\n    static bool cmp(node a,node b)\r\n    {\r\n        if(a.x^b.x)\r\n            return a.x<b.x;\r\n        if(a.y^b.y)\r\n            return a.y<b.y;\r\n        \r\n        return a.val<b.val;\r\n    }\r\n    vector<node> nodeArr;\r\n    int minX=INT_MAX;\r\n    int maxX=INT_MIN;\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) \r\n    {\r\n        dfs(root,0,0);\r\n        sort(nodeArr.begin(),nodeArr.end(),cmp);\r\n        vector<vector<int>> res(maxX-minX+1);\r\n        for(node son:nodeArr)\r\n        {\r\n            res[son.x-minX].push_back(son.val);\r\n        }\r\n        return res;\r\n    }\r\n    void dfs(TreeNode* root,int x,int y)\r\n    {\r\n        if(root==nullptr) return;\r\n        \r\n        if(x<minX)\r\n            minX=x;\r\n        if(x>maxX)\r\n            maxX=x;\r\n        \r\n        nodeArr.push_back(node(root->val,x,y));\r\n        dfs(root->left,x-1,y+1);\r\n        dfs(root->right,x+1,y+1);\r\n    }\r\n```\r\n复杂度：\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101555227","body":"思路：这个用双指针解法就好了\r\n```\r\nvector<int> twoSum(vector<int>& nums, int target) {\r\n    // 先对数组排序\r\n    sort(nums.begin(), nums.end());\r\n    // 左右指针\r\n    int lo = 0, hi = nums.size() - 1;\r\n    while (lo < hi) {\r\n        int sum = nums[lo] + nums[hi];\r\n        // 根据 sum 和 target 的比较，移动左右指针\r\n        if (sum < target) {\r\n            lo++;\r\n        } else if (sum > target) {\r\n            hi--;\r\n        } else if (sum == target) {\r\n            return {nums[lo], nums[hi]};\r\n        }\r\n    }\r\n    return {};\r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103537638","body":"思路：参考官方题解，用priority_queue做，这个东西本质上是一个堆，这次构造一个小顶堆，然后只记录频率前k的数，最后输出\r\n代码：\r\n```\r\n    vector<int> topKFrequent(vector<int>& nums, int k) \r\n    {\r\n        unordered_map<int,int> count;\r\n        for(int i=0;i<nums.size();i++)\r\n        {\r\n            count[nums[i]]++;\r\n        }\r\n        \r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\r\n        \r\n        for(pair<int,int> son:count)\r\n        {\r\n            if(pq.size()!=k)\r\n            {\r\n                pq.push(make_pair(son.second,son.first));\r\n            }\r\n            else\r\n            {\r\n                if(son.second>pq.top().first)\r\n                {\r\n                    pq.pop();\r\n                    pq.push(make_pair(son.second,son.first));\r\n                }\r\n            }\r\n        }\r\n        \r\n        vector<int> res;\r\n        while(pq.size())\r\n        {\r\n            res.push_back(pq.top().second);\r\n            pq.pop();\r\n        }\r\n         return vector<int>(res.rbegin(), res.rend());\r\n    }\r\n```\r\n复杂度:\r\n时间复杂度：O(nlogk) k为k的长度\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104759081","body":"思路：我是彩笔，又参考了官方题解。\r\n总的来说就是需要寻找到三个点的组合，i，j，k，其中对于i来说，j和k于i的距离必须相等。\r\n暴力枚举法需要三重循环，这样的话时间复杂度是O(n^3)太不划算了。\r\n因此我们可以想到排列组合问题，如果将i点固定，在剩下的点中筛选出距离与i相等的点的集合。\r\n假设离i距离为a的点有n个，那么就是从n个里边选出顺序的两个点与i组合，即排列组合问题，An2。\r\n```\r\nint numberOfBoomerangs(vector<vector<int>>& points) \r\n    {\r\n        int res=0;\r\n\r\n        for(int i=0;i<points.size();i++)\r\n        {\r\n            unordered_map<int,int> map;\r\n            for(int j=0;j<points.size();j++)\r\n            {\r\n                int dis=Distance(points[i],points[j]);\r\n                map[dis]++;\r\n            }\r\n            for(auto p=map.begin();p!=map.end();p++)\r\n            {\r\n                res+=p->second*(p->second-1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    int Distance(vector<int> a, vector<int> b)\r\n    {\r\n        int x=a[0]-b[0];\r\n        int y=a[1]-b[1];\r\n        \r\n        return x*x+y*y;\r\n    }\r\n```\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105878644","body":"思路：滑动窗口解之\r\n```\r\nint lengthOfLongestSubstring(string s) \r\n    {\r\n        if(s.size()==0) return 0;\r\n        int res=1;\r\n        int left=0,right=0;\r\n        unordered_map<char,int> window;\r\n        while(right<s.size())\r\n        {\r\n            char c=s[right];\r\n            right++;\r\n            window[c]++;\r\n            while(window[c]>1)\r\n            {\r\n                char d=s[left];\r\n                left++;\r\n                window[d]--;\r\n            }\r\n            res=max(res,right-left);\r\n        }\r\n        return res;\r\n    }\r\n    int max(int a,int b)\r\n    {\r\n        return a>b? a:b;\r\n    }\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1106835311","body":"思路：参考了题解\r\n```\r\nvector<int> findSubstring(string s, vector<string>& words) \r\n    {\r\n        vector<int> res;\r\n        int wordNum=words.size();\r\n        int wordLen=words[0].size();\r\n        unordered_map<string,int> allWords;\r\n        \r\n        for(string it:words)\r\n            allWords[it]++;\r\n        \r\n        for(int i=0;i<s.size()-wordLen*wordNum+1;i++)\r\n        {\r\n            unordered_map<string,int> window;\r\n            int num=0;\r\n            while(num<wordNum)\r\n            {\r\n                string word=s.substr(i+num*wordLen,wordLen);\r\n                if(allWords[word]==0) break;\r\n                else\r\n                {\r\n                    window[word]++;\r\n                    if(window[word]>allWords[word]) break;\r\n                }\r\n                num++;\r\n            }\r\n            if(num==wordNum) res.push_back(i);\r\n        }\r\n    \r\n        return res;\r\n    }\r\n```\r\n时间复杂度：O(n+len)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107664864","body":"思路：参考官方题解，用前缀和以及同余数定理可解\r\n```\r\nint floorMod(const int& a, const int& b)\r\n{\r\n    return (a % b + b) % b;\r\n}\r\nint solve(vector<int>& nums, int k) {\r\n    int allSum = 0;\r\n    for (int& num : nums)\r\n        allSum += num;\r\n\r\n    allSum = floorMod(allSum, k);\r\n    unordered_map<int, int> dict;\r\n    dict[0] = -1;\r\n\r\n    int preSum = 0;\r\n    int minLen = nums.size();\r\n    for (int i = 0; i < nums.size(); i++) {\r\n        preSum += nums[i];\r\n        int mod = floorMod(preSum, k);\r\n        dict[mod] = i;\r\n\r\n        if (dict.count(floorMod(preSum - allSum, k)))\r\n            minLen = min(minLen, i - dict[floorMod(preSum - allSum, k)]);\r\n    }\r\n    return minLen == nums.size() ? -1 : minLen;\r\n}\r\n```\r\n复杂度：\r\n\r\n    时间复杂度：O(n)\r\n\r\n    空间复杂度：O(min(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107895975","body":"思路：快慢指针，快指针一次两步，慢指针一次一步，快指针到了结尾的时候慢指针就指向中心了\r\n```\r\n    ListNode* middleNode(ListNode* head) \r\n    {\r\n        ListNode* p1=head;\r\n        ListNode* p2=head;\r\n        \r\n        while(p2->next!=nullptr && p2->next->next!=nullptr)\r\n        {\r\n            p1=p1->next;\r\n            p2=p2->next->next;\r\n        }\r\n        if(p2->next!=nullptr) return p1->next;\r\n        return p1;\r\n    }\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109069832","body":"思路：双指针解法，方便快捷\r\n```\r\n    int removeDuplicates(vector<int>& nums) \r\n    {\r\n        if(nums.size()==0) return 0;\r\n        int fast=0;\r\n        int slow=0;\r\n        while(fast<nums.size())\r\n        {\r\n            if(nums[fast]!=nums[slow])\r\n            {\r\n                slow++;\r\n                nums[slow]=nums[fast];\r\n            }\r\n            fast++;\r\n        }\r\n        return slow+1;\r\n    }\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110448075","body":"思路：一遍搜索或者二分，这里用一遍搜索\r\n代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int l = 0, r = nums.size();\r\n\r\n        while (l <= r) {\r\n            int mid = l + (r - l)/2;\r\n            if (nums[mid] == target) return mid;\r\n\r\n            if (nums[mid] < target) l = mid + 1;\r\n            else\r\n                r = mid - 1;\r\n        }\r\n\r\n        return l;\r\n    }\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111696767","body":"思路：使用用链表连接的单调队列就可以解题\r\n代码：\r\n```\r\nclass MonotonicQueue\r\n    {\r\n    public:\r\n        list<int> lickedList;\r\n        void push(int n)\r\n        {\r\n            while(!lickedList.empty() && lickedList.back()<n)\r\n            {\r\n                lickedList.pop_back();\r\n            }\r\n            lickedList.push_back(n);\r\n        }\r\n        int max()\r\n        {\r\n           return lickedList.front(); \r\n        }\r\n        void pop(int n)\r\n        {\r\n            if(lickedList.front()==n)\r\n                lickedList.pop_front();\r\n        }\r\n    };\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \r\n    {\r\n        vector<int> res;\r\n        MonotonicQueue window;\r\n        for(int i=0;i<k-1;i++)\r\n        {\r\n            window.push(nums[i]);\r\n        }\r\n        for(int i=k-1;i<nums.size();i++)\r\n        {\r\n            window.push(nums[i]);\r\n            res.push_back(window.max());\r\n            window.pop(nums[i-k+1]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112896768","body":"```\r\nint findJudge(int n, vector<vector<int>>& trust) \r\n    {\r\n        if (trust.empty() && n == 1) \r\n            return 1;\r\n        unordered_map<int, int> count;\r\n        for (vector<int>& relation : trust)\r\n        {\r\n            count[relation[0]] += -1;\r\n            count[relation[1]] += 1;\r\n        }\r\n        int no_k = -1;\r\n        for (auto kvp : count)\r\n        {\r\n            if (kvp.second == (n-1)) \r\n                no_k = kvp.first;\r\n        }\r\n        return no_k;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113919047","body":"思路：染色法二分无向图，学习了\r\n代码：\r\n```\r\nvector<int> colors;\r\n    vector<vector<int>> G;\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \r\n    {\r\n        G=vector<vector<int>>(n);\r\n        for(auto& d:dislikes)\r\n        {\r\n            G[d[0]-1].push_back(d[1]-1);\r\n            G[d[1]-1].push_back(d[0]-1);\r\n        }\r\n        \r\n        colors=vector<int>(n,0);\r\n        \r\n        for(int i=0;i<colors.size();i++)\r\n        {\r\n            if(colors[i]==0 && !dfs(i,1))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    bool dfs(int cur, int color)\r\n    {\r\n        colors[cur]=color;\r\n        for(int next:G[cur])\r\n        {\r\n            if(colors[next]==color)\r\n                return false;\r\n            if(colors[next]==0 && !dfs(next,-color))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n```\r\n复杂度：\r\n时间复杂度：O(V+E)\r\n空间复杂度：O(V+E)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oldfashioneddog":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086831280","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087248552","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        res=\"\"\n        multi=0\n        for c in s:\n            if c=='[':\n                stack.append([multi,res])\n                res,multi=\"\",0\n            elif c==']':\n                cur_multi,last_res=stack.pop()\n                res=last_res+res*cur_multi\n            elif '0'<= c <='9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088636936","body":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # for i in range(0,n):\n        #     nums1[m+i]=nums2[i]#nums1[m:]=nums2\n        # nums1.sort()\n        # return nums1\n        k = m + n - 1  # 目标数组总长度\n        while m > 0 and n > 0:  # 只要两个数组任意一个遍历完\n            if nums1[m - 1] > nums2[n - 1]:  # 一数组最后一个比二最后一个大\n                nums1[k] = nums1[m - 1]  # 将一数组最后一个移到目标数组最后一个\n                m -= 1  # 一数组的指针左移\n            else:\n                nums1[k] = nums2[n - 1]  # 将二数组最后一个移到目标数组最后一个\n                n -= 1  # 将二数组的指针左移\n            k -= 1  # 目标数组指针左移\n        nums1[:n] = nums2[:n]  # 如果第二个数组未遍历完，说明一数组已排序好，将二数组剪切过来","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090402609","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        pre1,pre2=0,0\n        res=0\n        for a,b in zip(arr,sorted(arr)):\n            pre1+=a\n            pre2+=b\n            if pre1==pre2:\n                res+=1\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091899418","body":"class Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head :return head\n        tail = head\n        Len = 1\n        while tail.next:    # 计算长度\n            tail = tail.next\n            Len += 1\n        k = (Len - k) % Len # 计算余数\n        tail.next = head\n        while k > 0:        # 找到分割点及头节点\n            tail = tail.next\n            k -= 1\n        head = tail.next    # 断链并返回\n        tail.next = None\n        return head\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092940583","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        thead = ListNode(-1)\n        thead.next = head\n        c = thead\n        while c.next and c.next.next:\n            a, b=c.next, c.next.next\n            c.next, a.next = b, b.next\n            b.next = a\n            c = c.next.next\n        return thead.next\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094280803","body":"class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        # 链表A和B任一为空，链表不相交\n        if not headA or not headB:\n            return None\n\n        # 初始化headA、headB的指针和长度\n        flagA, flagB = headA, headB\n        lenA, lenB = 0, 0\n\n        # 求链表 A 的长度\n        while flagA:\n            flagA = flagA.next\n            lenA += 1\n\n        # 求链表 B 的长度\n        while flagB:\n            flagB = flagB.next\n            lenB += 1\n\n        # 重新指向表头\n        flagA, flagB = headA, headB\n\n        # 为了让大家看的明白点，我就不用华丽花哨的写法了，用最笨的写法表示。\n        # 当A是长链表，则指针flagA后移到和B链表同等长度的位置上。\n        if lenA > lenB:\n            d_value = lenA - lenB\n            while d_value:\n                flagA = flagA.next\n                d_value -= 1\n        # 当B是长链表，则指针flagB后移到和A链表同等长度的位置上。\n        else:\n            d_value = lenB - lenA\n            while d_value:\n                flagB = flagB.next\n                d_value -= 1\n\n        # 然后两个指针flagA和flagB同时遍历\n        while flagA:\n            if flagA == flagB:\n                return flagA\n            else:\n                flagA = flagA.next\n                flagB = flagB.next\n\n        # 如果没有相遇，返回 None\n        return None","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095196710","body":"class Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096902016","body":"class ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n    def move_node_to_tail(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到尾节点前\n            #                 hashmap[key]                 hashmap[key]\n            #                      |                            |\n            #                      V        -->                 V\n            # prev <-> tail  ...  node                prev <-> node <-> tail\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到末尾\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                # 去掉哈希表对应项\n                self.hashmap.pop(self.head.next.key)\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            # 如果不在的话就插入到尾节点前\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1098201775","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # 节点为空，高度为 0\n        if root == None:\n            return 0\n\n        # 递归计算左子树的最大深度\n        leftHeight = self.maxDepth(root.left)\n        # 递归计算右子树的最大深度\n        rightHeight = self.maxDepth(root.right)\n\n        # 二叉树的最大深度 = 子树的最大深度 + 1（1 是根节点）\n        return max(leftHeight, rightHeight) + 1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099300659","body":"class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n            #若两颗二叉树都是空，则两颗二叉树相同\n            if p==None and q==None :\n                return True\n            # 如果其中一棵二叉树为空，另一棵不为空，则一定不相同\n            if (p == None and q != None) or (p != None and q == None):\n                return False\n            # 如果两棵二叉树皆不为空，但是根节点的值不同，则一定不相同\n            if p.val != q.val:\n                return False\n            # 判断两棵二叉树的左子树是否相同\n            leftTree = self.isSameTree(p.left, q.left)\n            # 判断两棵二叉树的右子树是否相同\n            rightTree = self.isSameTree(p.right, q.right)\n\n            isSame = leftTree and rightTree\n\n            return isSame","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100194074","body":"class Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        val_list=[]\n        def dfs(node:TreeNode, cur_val):\n            if node:\n                cur_val=cur_val*10+node.val\n                if node.left is None and node.right is None:\n                    val_list.append(cur_val)\n                    return\n                dfs(node.left,cur_val)\n                dfs(node.right,cur_val)\n        dfs(root,0)\n        return sum(val_list)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100693241","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        li,queue=[],deque([[root,1]])\n        while queue:\n           for _ in range(len(queue)):\n                child,index=queue.popleft()\n                if len(li) < index:\n                   li.append(child.val)\n                index += 1\n                if child.left:\n                    queue.append([child.left,index])\n                if child.right:\n                    queue.append([child.right,index])\n        return li.pop()","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102390933","body":"class Solution():\n    def twoSum(self,list,target):\n        Hashtable=dict()   #创建哈希列表\n        for i,num in enumerate(list):  #遍历列表\n            if target-num in Hashtable:  #检测target-num在不在哈希表中\n                return [Hashtable[target-num],i]  #如果再返回对应的下标\n            Hashtable[list[i]]=i  #把num列表的元素添加到哈希表中\n        return [] #不存在返回空列表","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingchen77":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086881827","body":"#### 思路\n很简单的转变\n#### 代码\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        temp = 0\n        cur = 1\n        for i in range(len(num) - 1, -1, -1):\n            temp += int(num[i]) * cur\n            cur *= 10\n        temp += k\n        while temp > 0:\n            res.append(temp%10)\n            temp = temp // 10\n        return res[::-1]\n```\n#### 复杂度\n时间复杂度 O(n) \\\n空间复杂度O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086886903","body":"#### 思路\n先从左边往右边扫，然后再从右边往左边扫，中间加上比较条件\n\n#### 代码\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n        for i in range(1, n):\n            if res[i-1] != None and res[i] == None:\n                res[i] = res[i-1] + 1\n            \n        for i in range(n-2, -1, -1):\n            if res[i] == None or res[i] > res[i+1] + 1:\n                res[i] = res[i+1] + 1\n        return res\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877050","body":"#### 思路\n用两个数组模拟栈，一个存放每次push的数字，另外一个存放increment的内容，注意要更新increment出栈后的内容\n\n#### 代码\n```python\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.incremental = []\n        self.cur = 0\n        self.size = maxSize\n    def push(self, x: int) -> None:\n        if self.cur < self.size:\n            self.st.append(x)\n            self.cur += 1\n            self.incremental.append(0)\n    def pop(self) -> int:\n        if self.cur == 0:\n            return -1\n        if self.cur >= 2:\n            self.incremental[-2] += self.incremental[-1]\n        self.cur -= 1\n        return self.st.pop() + self.incremental.pop()\n    def increment(self, k: int, val: int) -> None:\n        if self.cur > 0:\n            self.incremental[min(self.cur, k) - 1] += val\n```\n#### 空间复杂度\n时间 O(1) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087081672","body":"#### 思路\n使用栈，通过对 “]” 的判断，进行出栈操作\n#### 代码\n```python\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                repeatStr = \"\"\n                repeatCount = \"\"\n                while stack and stack[-1] != \"[\":\n                    repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088566405","body":"#### 思路\n通过两个栈颠倒数据\n#### 代码\n```python\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n        self.help_stack.append(x)\n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n    def pop(self) -> int:\n        return self.stack.pop()\n    def peek(self) -> int:\n        return self.stack[-1]\n    def empty(self) -> bool:\n        if not self.stack:\n            return True\n        else:\n            return False \n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089819996","body":"#### 思路\n用数组的差表示arr和sorted(arr)的关系\n#### 代码\n```python\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = 0\n        count = collections.defaultdict(int)\n        non_zero_count = 0\n        for a, b in zip(arr, sorted(arr)):\n            if count[a] == -1:\n                non_zero_count -= 1\n            if count[a] == 0:\n                non_zero_count += 1\n            count[a] += 1\n            if count[b] == 1:\n                non_zero_count -= 1\n            if count[b] == 0:\n                non_zero_count += 1\n            count[b] -= 1\n            if non_zero_count == 0:\n                res += 1\n        return res \n```\n#### 复杂度 \n时间O(nlogn) \\\n空间O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091245452","body":"#### 思路\n通过设定p1以及p2的指针，进行移动，注意k%count，防止k大于链表长度\n\n#### 代码\n```python\n   def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        count = 1\n        p1 = head\n        while p1 and p1.next:\n            count += 1\n            p1 = p1.next\n        \n        offset = count - k % count\n\n        count = 1        \n        p2 = head\n        while count < offset:\n            p2 = p2.next\n            count += 1\n        p1.next = head\n        head = p2.next\n        p2.next = None\n        return head\n```\n#### 复杂度\n时间O(n) \\\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092397386","body":"#### 思路\n将交换的前一个节点pre，交换的两个节点head，head.next以及最后一个节点的head.next.next分别表示出来，直接交换即可\n\n#### 代码\n```python\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        res = ListNode(0)\n        res.next = head.next\n        pre = res\n        while head and head.next:\n            pre.next = head\n            p1 = head.next\n            p2 = p1.next\n\n            p1.next = head\n            head.next = p2\n            pre.next = p1\n\n            pre = head\n            head = p2\n        return res.next\n```\n\n#### 复杂度\n时间 O(n) \\\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093580373","body":"#### 思路\n寻找中间节点的位置，左右节点递归\n#### 代码\n```python\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre = ListNode()\n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n#### 复杂度\n时间 O(nlog(n)) \\\n空间 O(log(n))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094933958","body":"#### 思路\n经典的环问题，快慢指针相遇，再次出发\n####\n```python\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        \n        slow = fast = head\n        x = None \n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        x = head\n        while x != slow:\n            x = x.next\n            slow = slow.next\n        return slow\n```\n#### 复杂度\n时间O(n) \\\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095948516","body":"#### 思路\n双向链表进行移动，字典进行查询，\n#### 代码\n```python\nclass DlinkedNode:\n    def __init__(self, key = 0, value = 0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.head = DlinkedNode()\n        self.tail = DlinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DlinkedNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            node =self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def removeNode(self, node):\n        node.next.prev = node.prev\n        node.prev.next = node.next\n    \n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```\n#### 复杂度\n时间O(1) \\\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097502488","body":"#### 思路\n递归即可\n#### 代码\n```python\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n#### 复杂度\n时间：O(n) \\\n空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098594805","body":"#### 思路\n递归遍历即可\n#### 代码\n``` python\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(h) h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099778721","body":"#### 思路\nDFS或者BFS遍历\n#### 代码\n```python\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root, cur):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return root.val + cur * 10\n            return dfs(root.left, cur * 10 + root.val) + dfs(root.right, cur * 10 + root.val)\n        return dfs(root, 0)\n```\n#### 复杂度\n时间O(n) \\\n空间O(h) h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100656834","body":"#### 思路\n层次遍历\n#### 代码\n```python\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        q = deque()\n        q.append(root)\n        while q:\n            res = q[0].val\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if cur.left:\n                    q.append(cur.left)\n                if cur.right:\n                    q.append(cur.right)\n        return res \n```\n#### 复杂度\n空间 O(n) \\\n时间 O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101236290","body":"#### 思路\nDFS遍历，三层sorted输出\n#### 代码\n```python\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        seen = collections.defaultdict(lambda: collections.defaultdict(list))\n        def dfs(root, x = 0, y = 0):\n            if not root:\n                return \n            seen[x][y].append(root.val)\n            dfs(root.left, x - 1, y + 1)\n            dfs(root.right, x  + 1, y + 1)\n        dfs(root)\n\n        res = []\n        for x in sorted(seen):\n            level = []\n            for y in sorted(seen[x]):\n                level += sorted(v for v in seen[x][y])\n            res.append(level)\n        return res \n```\n#### 复杂度\n时间 O(nlongn) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101936615","body":"#### 思路\n用map存储target减去nums[i]的值\n#### 代码\n``` python\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        temp_res = {}\n        for i in range(len(nums)):\n            if target - nums[i] in temp_res:\n                return [i, temp_res[target - nums[i]]]\n            else:\n                temp_res[nums[i]] = i\n        return []\n```\n#### 复杂度\n空间 O(n) \\\n时间 O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105923968","body":"#### 思路\n使用两个指针，left以及right，使用set（）存储字符串并进行是否有重复的探测，发现有重复的，移动left指针到max(left, )\n#### 代码\n``` python\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left = right = res = 0\n        setting = {}\n        while right < len(s) and left + res < len(s):\n            if s[right] in setting:\n                left = max(left, setting[s[right]] + 1)\n            res = max(res, right - left + 1)\n            setting[s[right]] = right\n            right += 1\n        return res\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107513752","body":"#### 思路\r\n使用两个指针\r\n\r\n#### 代码\r\n```python\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        allWords = collections.Counter(words)\r\n        wordNum = len(words)\r\n        wordLen = len(words[0])\r\n        res = []\r\n        for i in range(len(s) - wordNum * wordLen + 1):\r\n            subWords = collections.defaultdict(int)\r\n            index = i\r\n            while index < i + wordNum * wordLen:\r\n                curWord = s[index : index + wordLen]\r\n                if curWord not in allWords or subWords[curWord] == allWords[curWord]:\r\n                    break\r\n                subWords[curWord] += 1\r\n                index += wordLen\r\n            if index == i + wordLen * wordNum:\r\n                res.append(i)\r\n        return res \r\n```\r\n#### 复杂度\r\n时间 O(n∗m)，n为字符串长度，m为单词个数 \\\r\n空间 O(m)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109413273","body":"#### 思路\n双指针移动，\n#### 代码\n```python\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```\n#### 复杂度\n时间 O(n)  \\\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110633334","body":"#### 思路\n左右指针，中间移动\n#### 代码\n```python\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086884935","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.size = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.size) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length != 0) {\n        let tmp = this.stack.pop();\n        return tmp;\n    } else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length && i < k; ++i) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087517926","body":"## 思路\n栈。除了']'一律入栈，遇']'开始出栈处理\n## 代码\n```js\nvar decodeString = function(s) {\n    let stack = [];\n    for (let char of s) {\n        if (char != ']') {\n            stack.push(char);\n        } else {\n            let repeatStr = stack.pop();\n            let tmpC = stack.pop();\n            while (tmpC != '[') {\n               repeatStr = tmpC + repeatStr;\n               tmpC = stack.pop();\n            }\n            let repeatTime = \"\";\n            while (stack.length && !isNaN(stack.slice(-1))) {\n                repeatTime = stack.pop() + repeatTime;\n            }\n            stack.push(repeatStr.repeat(+repeatTime));\n        }\n    }\n    return stack.join(\"\");\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088640899","body":"```js\n// 直接模拟\nvar MyQueue = function() {\n    this.stack = [];\n    this.helperStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while (this.stack.length) {\n        this.helperStack.push(this.stack.pop());\n    }\n    let ret = this.helperStack.pop();\n    while (this.helperStack.length) {\n        this.stack.push(this.helperStack.pop());\n    }\n    return ret;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while (this.stack.length) {\n        this.helperStack.push(this.stack.pop());\n    }\n    let ret = this.helperStack.slice(-1);\n    while (this.helperStack.length) {\n        this.stack.push(this.helperStack.pop());\n    }\n    return ret;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090431494","body":"## 思路\n题解中的计数法。\n1. 先拷贝输入数组并排序\n2. 同时遍历输入数组和排序数组并建立两个数组的计数\n    - 用一个hashMap计数，一个数组加，一个数组减\n3. 统计计数相同的次数\n## 代码\n```js\nvar maxChunksToSorted = function(arr) {\n    let res = 0;\n    let count = new Map();\n    let sortedArr = arr.slice();\n    sortedArr.sort((a, b) => a - b);\n    for (let i = 0; i < arr.length; i++) {\n        if (count.has(arr[i])) {\n            if (count.get(arr[i]) == -1) {\n                count.delete(arr[i]);\n            } else {\n                count.set(arr[i], count.get(arr[i]) + 1);\n            }\n        } else {\n            count.set(arr[i], 1);\n        }\n        if (count.has(sortedArr[i])) {\n            if (count.get(sortedArr[i]) == 1) {\n                count.delete(sortedArr[i]);\n            } else {\n                count.set(sortedArr[i],count.get(sortedArr[i]) - 1);\n            }\n        } else {\n            count.set(sortedArr[i], -1);\n        }\n        if (count.size == 0) {\n            res++;\n        }\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095931228","body":"```js\nvar LRUCache = function(capacity) {\n    this.map = new Map();\n    this.capacity = capacity;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.map.has(key)){\n        let value = this.map.get(key);\n        this.map.delete(key); // 删除后，再 set ，相当于更新到 map 最后一位\n        this.map.set(key, value);\n        return value\n    } else {\n        return -1\n    }\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 如果已有，那就要更新，即要先删了再进行后面的 set\n    if(this.map.has(key)){\n        this.map.delete(key);\n    }\n    this.map.set(key, value);\n    // put 后判断是否超载\n    if(this.map.size > this.capacity){\n        this.map.delete(this.map.keys().next().value);\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097478104","body":"```js\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    let res = 1;\n    let dfs = function(node, depth) {\n        if (node.left) {\n            dfs(node.left, depth + 1);\n        }\n        if (node.right) {\n            dfs(node.right, depth + 1);\n        }\n        res = Math.max(res, depth);\n    }\n    dfs(root, 1);\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098642186","body":"## 思路\n递归遍历树\n## 代码\n```js\nvar isSameTree = function(p, q) {\n    if (!p && !q) {\n        return true;\n    }\n    if (p && q) {\n        if (p.val !== q.val) {\n            return false;\n        }\n        return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));\n    }\n    return false;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1100655266","body":"## 思路\nDFS传的是累加的值\n## 代码\n```js\nvar sumNumbers = function(root) {\n    let res = 0;\n    function dfs(node, v) {\n        if (!node) {\n            return;\n        }\n        v = v * 10 + node.val;\n        if (!node.left && !node.right) {\n            res += v;\n            return;\n        }\n        dfs(node.left, v);\n        dfs(node.right, v);\n    }\n    dfs(root, 0);\n    return res;\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100651926","body":"## 思路\ndfs找深度最大的节点值记录\n## 代码\n```js\nvar findBottomLeftValue = function(root) {\n    let res;\n    let deepest = 0;\n    function dfs(node, depth) {\n        if (!node) {\n            return;\n        }\n        if (depth > deepest) {\n            res = node.val;\n            deepest = depth;\n        }\n        dfs(node.left, depth + 1);        \n        dfs(node.right, depth + 1);\n    }\n    dfs(root, 1);\n    return res;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101060451","body":"## 思路\n先dfs把所有节点的`[val, row, col]`存在一个数组里，再根据题目规则排序。最后将排好序的节点数组的`val`按照规则打包\n## 代码\n```js\nvar verticalTraversal = function(root) {\n    let nodes = new Array();\n    function dfs(node, row, col) {\n        if (!node) {\n            return;\n        }\n        nodes.push([node.val, row, col]);\n        dfs(node.left, row + 1, col - 1);\n        dfs(node.right, row + 1, col + 1);\n    }\n    dfs(root, 0, 0);\n    function sortNodes(a, b) {\n        if (a[2] != b[2]) {\n            return a[2] - b[2];\n        }\n        if (a[1] != b[1]) {\n            return a[1] - b[1];\n        }\n        return a[0] - b[0];\n    }\n    nodes.sort(sortNodes);\n    let res = new Array();\n    let start = 0;\n    for (let i = 1; i < nodes.length; i++) {\n        if (nodes[i][2] != nodes[start][2]) {\n            let tmp = new Array();\n            for (let j = start; j < i; j ++) {\n                tmp.push(nodes[j][0]);\n            }\n            res.push(tmp);\n            start = i;\n        }\n    }\n    let tmp = new Array();\n    for (let i = start; i < nodes.length; i++) {\n        tmp.push(nodes[i][0]);\n    }\n    res.push(tmp);\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101901904","body":"## 思路\n创建hashMap，`key`为数字数组中的具体元素值，`val`为对应下标。每次读取新数字都去寻找和它之和为`target`的元素是否存储过，存在则取出下标，将二者打包作为结果返回\n## 代码\n```js\nvar twoSum = function(nums, target) {\n    let hashMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (hashMap.has(target - nums[i])) {\n            return [hashMap.get(target - nums[i]), i];\n        }\n        hashMap.set(nums[i], i);\n    }\n};\n```\n## 复杂度\n时间 O(n)\n\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103411111","body":"## 思路\n1. 遍历输入并使用hashMap存入数字元素和其出现次数\n2. 把hashMap导入数组中按频次降序排列。\n3. 按照题目要求打包输出\n## 代码\n```js\nvar topKFrequent = function(nums, k) {\n    let res = [];\n    let hashMap = new Map();\n    for (let num of nums) {\n        if (hashMap.has(num)) {\n            hashMap.set(num, hashMap.get(num) + 1);\n        } else {\n            hashMap.set(num, 1);\n        }\n    }\n    let arr = Array.from(hashMap);\n    arr.sort((a, b) => b[1] - a[1]);\n    for (let i = 0; i < k; i++) {\n        res.push(arr[i][0]);\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105260171","body":"## 思路\r\n遍历节点，将所有节点与其距离存在哈希表中，取哈希表中的val值输出\r\n## 代码\r\n```js\r\nvar numberOfBoomerangs = function(points) {\r\n    let res = 0;\r\n    for (let i = 0; i < points.length; i++) {\r\n        let hashMap = new Map();\r\n        for (let j = 0; j < points.length; j ++) {\r\n            let dis = distance(i, j);\r\n            if (hashMap.has(dis)) {\r\n                hashMap.set(dis, hashMap.get(dis) + 1);\r\n            } else {\r\n                hashMap.set(dis, 1);\r\n            }\r\n        }\r\n        for (let val of hashMap.values()) {\r\n            res += val * (val - 1);\r\n        }\r\n    }\r\n    function distance(i, j) {\r\n        return Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\r\n    }\r\n    return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106044051","body":"## 思路\n滑动窗口 + 集合\n## 代码\n```js\nvar lengthOfLongestSubstring = function(s) {\n    let set = new Set();\n    let left = 0;\n    let right = 0;\n    let res = 0;\n    while (right < s.length) {\n        if (set.has(s[right])) {\n            while (set.has(s[right])) {\n                set.delete(s[left++]);\n            }\n        } else {\n            set.add(s[right++]);\n        }\n        res = Math.max(res, right - left);\n    }\n    return res;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107827690","body":"## 思路\n同余 + 哈希 + 前缀和\n## 代码\n```js\nlet floorMod = (a, b) => ((a % b) + b) % b;\nfunction solve(nums, k) {\n    let target = nums.reduce((sum, cur) => sum + cur, 0) % k;\n    if (!target) return 0;\n    let curSum = 0;\n    let hash = new Map();\n    hash.set(0, -1);\n    let res = Infinity;\n    for (let i = 0; i < nums.length; i ++) {\n        curSum = (curSum + nums[i]) % k;\n        let prev = floorMod(curSum - target, k);\n        hash.set(curSum, i);\n        if (hash.has(prev)) {\n            console.log(i, hash.get(prev));\n            res = Math.min(res, i - hash.get(prev));\n        }\n    }\n    return res === Infinity ? -1 : res;\n}\n```\n## 复杂度\n时间 O(n)\n\n空间 O(min(n, k))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086967880","body":"代码：\nJavaScript\n\n```js\nvar decodeString = function(s){\n    const stack = [];\n\n    for (let char of s) {\n        if (char !== ']') {\n            stack.push(char);\n            continue;\n        }\n\n        let cur = stack.pop();\n        let str = '';\n        while (cur !== '[') {\n            str = cur + str;\n            cur = stack.pop();\n        }\n\n        // now get the number here\n        cur = stack.pop();\n        let num = '';\n        // be careful here, how we count the number\n        while (cur >= '0' && cur <= '9') {\n            num = cur + num;\n            cur = stack.pop();\n        }\n        stack.push(cur);\n        stack.push(str.repeat(num));\n    }\n    return stack.join('');\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091027008","body":"# 思路\n使用数组模拟\n\n# 代码\n\n语言：JavaScript\n\n```js\nvar rotateRight = function(head, k) {\n    if (!head) return null;\n    let arr = [];\n    let p = head;\n    while (p) {\n        arr.push(p.val);\n        p = p.next;\n    }\n\n    k = k % arr.length;\n    while (k --) {\n        arr.unshift(arr.pop());\n    }\n\n    let dummy = new ListNode(-1);\n    let cur = dummy;\n    for (let i = 0; i < arr.length; i++) {\n        cur = cur.next = new ListNode(arr[i]);\n    }\n\n    return dummy.next;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1097626537","body":"```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        auto p1 = headA;\n        auto p2 = headB;\n        while (p1 != p2) {\n            p1 = p1 ? p1->next : headA;\n            p2 = p2 ? p2->next : headB;\n        }\n        return p1;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1097482312","body":"# 思路\n使用集合存储链表，如果出现过就返回该节点\n\n```js\nvar detectCycle = function(head) {\n    const set = new Set();\n    for (let p = head; p ; p = p.next) {\n        if (set.has(p)) {\n            return p;\n        }\n        set.add(p);\n    }\n\n    return null;\n};\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097480950","body":"# 思路\n递归\n\n# 代码\n语言：JavaScript\n```js\nvar maxDepth = function(root) {\n    if (!root) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098784323","body":"# 思路\n\n第一种，直接序列化\n第二种，递归\n\n# 代码\n\n```js\nvar isSameTree = function(p, q) {\n    return JSON.stringify(p) === JSON.stringify(q);\n};\n\nvar isSameTree = function(p, q) {\n    if (!q && !p) return true;\n    if (!p || !q) return false;\n\n    return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(q.right, p.right);\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100802932","body":"```ts\nfunction serialize(root: TreeNode | null): string {\n    return root as unknown as string;\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n    return data as unknown as TreeNode;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101907181","body":"```js\nvar twoSum = function(nums, target) {\n    const map = new Map();\n\n    for (let i = 0; i < nums.length; i++) {\n        const n = nums[i];\n        if (map.has(n)) {\n            return [map.get(n), i];\n        }\n        map.set(target - n, i);\n    }\n\n    return [-1, -1];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103399412","body":"# 思路\n\n使用哈希表存储每个数字出现的次数，然后排序。\n\n# 代码\n\n```js\nvar topKFrequent = function(nums, k) {\n    const map = new Map();\n\n    for (let i = 0; i < nums.length; i++) {\n        map.set(nums[i], -~map.get(nums[i]));\n    }\n\n    return Array.from(map).sort((a, b) => b[1] - a[1]).map(i => i[0]).slice(0, k);\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108015093","body":"# 思路\n快慢指针，两个指针同时从头指向尾\n一个走两步，一个走一步\n当走两步的指针到了末尾，那么走一步的指针就走到了 **中间**\n\n# 代码\n\n语言： JavaScript\n\n```js\nvar middleNode = function(head) {\n    let p1 = head, p2 = head;\n    while (p1 && p2 && p2.next) {\n        p1 = p1.next;\n        p2 = p2.next.next;\n    }\n\n    return p1;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110483345","body":"# 暴力\n\n```js\nvar searchInsert = function(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] >= target) {\n            return i;\n        }\n    }\n\n    return nums.length\n};\n```\n\n# 二分\n\n```js\nvar searchInsert = function(nums, target) {\n    let l = 0, r = nums.length - 1;\n    while (l <= r) {\n        const mid = Math.floor(l + (r - l) / 2);\n\n        if (l >= nums.length) return nums.length;\n        if (nums[mid] < target) l = mid + 1;\n        else r = mid - 1;\n    }\n\n    return l\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"geek-lx":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087052946","body":"思路：\n\n该题难点是括号嵌套括号，如：2[2[a]c]，应该输出aacaac，因为需要**从内向外**打开，所以可以使用stack FILO解题\n\n\n\n算法流程：见代码，已经很清晰了\n\n代码：\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c #当c为字母时，res尾后添加c\n        return res\n```\n\n复杂度：\n\nTime：O（n）\n\nSpace：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088185063","body":"思路：\n\nUse two stacks\n\n代码：\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            self.help_stack.append(x)\n            while self.help_stack:\n                self.stack.append(self.help_stack.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        return not bool(self.stack)\n\n```\n\n复杂度：\n\nTime complixiety:\npush - O(n)\npop - O(1)\npeek - O(1)\nempty - O(1)\nSpace complixiety:\npush - O(n)\npop - O(1)\npeek - O(1)\nempty - O(1)\n\n疑问：\n\n[->int 在Python函数定义中是什么意思？](https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions)\n\n只是告诉 返回一个整数（但它不会强制函数返回整数）。它被称为*返回批注*\n\n来自 <https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions> \n\n \n\n 峰顶的索引是-1，那栈的索引是怎样的呢？\n\n  def peek(self) -> int:\n\n​    return self.stack[-1]\n\n//我认为首先看stack是怎样实现的？\n\nList可以实现stack，dict更适合链表\n\n但是list可没有-1的索引？\n\n5.1.1. 將 List 作為 Stack（堆疊）使用\n\n来自 <https://docs.python.org/zh-tw/3/tutorial/datastructures.html#using-lists-as-stacks> ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090434624","body":"辅助栈法：\n\n判断是否是排序块只需要用到该块的 元素最大值 headhead 。我们联想到，是否可以遍历一遍数组 arrarr ，动态判断到目前数字 numnum 为止最多能分出多少排序块，并保存每个排序块的最大值 headhead 。每遍历到下个数字 numnum ，动态判断前面所有的排序块是否成立，并更新所有排序块：\n当某排序块 num < headnum<head ：将此排序块[A]与 num 合并，形成新排序块[A | num]，最大值仍为 headhead ；\n当某排序块 num >= headnum>=head ：原排序块保留，并新加排序块 [num] 。\n而对于整个数组的排序块，其 headhead 大小是从左到右递增的。例如：数组 [1,2,1,3,4,7,5,6][1,2,1,3,4,7,5,6] 最多可划分为 [1|2,1|3|4|7,5,6][1∣2,1∣3∣4∣7,5,6] ，headhead 为 [1,2,3,4,7][1,2,3,4,7] 。因此，若给数组尾部加入一个随机正整数 nn ，尾部的排序块更容易被合并（最先满足 num < headnum<head ）。当 nn 值较小时（ << 前面多个排序块的 headhead ），则需按尾部到首部的顺序合并多个排序块。\n这种先入（首部到尾部添加排序块）后出（尾部到首部判断并合并排序块）的特性，让我们联想到使用 栈 保存排序块最大值 headhead 。在遍历过程中，通过维护栈的 headhead 序列，实现排序。\n\n代码：\n\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n\n```\n\n复杂度分析：\n\n时间复杂度 O(N)O(N) ：遍历一遍 arrarr 为 O(N)O(N)，修正排序块最多遍历一遍 arrarr 为 O(N)O(N)；\n空间复杂度 O(N)O(N) ：极端情况下排序块数量等于数组长度，此时 stackstack 占用线性大小额外空间。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092832386","body":"4.8\n\n思路：递归\n\n终止条件：当前节点为null，或者下一个节点为 `null`\n函数内：将 2 指向 1，1 指向下一层的递归函数，最后返回节点 2\n\n```python\nclass Solution(object):\n\tdef swapPairs(self, head):\n\t\t# 递归的终止条件\n\t\tif not (head and head.next):\n\t\t\treturn head\n\t\t# 假设链表是 1->2->3->4\n\t\t# 这句就先保存节点2\n\t\ttmp = head.next\n\t\t# 继续递归，处理节点3->4\n\t\t# 当递归结束返回后，就变成了4->3\n\t\t# 于是head节点就指向了4，变成1->4->3\n\t\thead.next = self.swapPairs(tmp.next)\n\t\t# 将2节点指向1\n\t\ttmp.next = head\n\t\treturn tmp\n\n```\n\n空间复杂度 O(1)\n\n时间复杂度是 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093781861","body":"4.9\n\n思路：\n\n快慢指针起初都指向头结点，分别一次走两步和一步，当快指针走到尾节点时，慢指针正好走到链表的中间。断成两个链表，分而治之。\n\n代码：\n\n```python\n#快慢指针法\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow #保存slow前一个节点，因为链表没有前驱指针\n            slow = slow.next \n\n        if pre: #如果pre有值，则slow左边有节点\n            pre.next = None #切断pre\n            \n        node = TreeNode(slow.val) # 根据slow指向的节点值，构建节点\n\n        if slow == fast: #？？？\n            return node\n        node.left = self.sortedListToBST(head) #递归构建左子树\n        node.right = self.sortedListToBST(slow.next) #递归构建右子树\n        return node\n```\n\n复杂度：\n\n令 n 为链表长度。\n\n- 时间复杂度：递归树的深度为 lognlogn，每一层的基本操作数为 nn，因此总的时间复杂度为O(nlogn)O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)O(logn)\n\n//存在疑问：应该是不了解递归树\n\n\n\n### 4.9小结\n\n1.知道了通过快慢指针找到中点和结尾\n\n2.我知道左子树小于节点，右子树大于节点，但代码中封装好了，NEXT：预习树\n\nnode.left = self.sortedListToBST(head)\n\nnode.right = self.sortedListToBST(slow.next)\n\n\\3. slow和fast没有变化，这句代码不可少，需要提问\n\n if slow == fast:\n\n​      return node\n\n \n\n4.python return?//函数当然有，怎么if里也有？\n\n5.？复杂度计算不太理解\n\n![计算机生成了可选文字: Python 函 数 可 以 返 回 多 种 类 型 的 值  与 其 他 编 程 语 言 不 同 ， python 函 数 不 限 于 返 回 单 一 类 型 的 值 。 如 果 您 昏  它 没 有 任 何 有 关 它 可 以 返 回 的 内 容 的 信 息 。  让 我 们 看 一 个 示 例 ， 其 中 函 数 将 返 回 多 种 类 型 的 值 。  def get_demo_data(object_type):  if ' s t r '  object_type ：  return 'test'  elif 'tuple'  object_type:  （ 1 ， 2 ， 3 ）  object_type:  [ 1 ， 2 ， 3 ]  object_type ：  None  return  elif ' 1 i s t '  return  elif ' d i c t '  return  else:  return ](file:///C:/Users/lx2019/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)\n\n \n\n「手画图解」三种解法逐个吃透 | 109. 有序链表转换二叉搜索树\n\n \n\n来自 <https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/shou-hua-tu-jie-san-chong-jie-fa-jie-zhu-shu-zu-ku/> \n\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094193165","body":"####  4.10\n\n思路：双指针\n\n- 使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n- 当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n- 当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n- 若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n- 时间复杂度：O(N）\n\n- 空间复杂度：O(1)\n\n  \n\n补充资料：\n\n- [空间复杂度](https://www.cnblogs.com/lonely-wolf/p/15674526.html#空间复杂度)\n\n对于算法的空间复杂度也可以简单的进行总结一下：\n\n- 如果申请的是有限个数（常量）的变量，空间复杂度为 `O(1)`。\n- 如果申请的是一维数组，队列或者链表等，那么空间复杂度为 `O(n)`。\n- 如果申请的是二维数组，那么空间复杂度为 `O(n²)`。\n- 如果是在循环体中申请的数组等，可能就需要取嵌套的乘积来作为空间复杂度，这种就需要具体的进一步分析。\n\n来自 <https://www.cnblogs.com/lonely-wolf/p/15674526.html> ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095067730","body":"4.11\n\n思路:\n\n1. 定义一个 fast 指针,每次**前进两步**,一个 slow 指针,每次**前进一步**\n2. 当两个指针相遇时\n   1. 将 fast 指针**重定位**到链表头部,同时 fast 指针每次只**前进一步**\n   2. slow 指针继续前进,每次**前进一步**\n3. 当两个指针再次相遇时,当前节点就是环的入口\n\n代码：\n\n```python\n#快慢指针法\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096592945","body":"4.12 \n\n146. LRU 缓存机制：书写难度较大，当压轴题\n\n思路：\n\n使用哈希表查询，双向链表来记录，最新的在顶部\n\n\n\n```python\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n    def move_node_to_tail(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到尾节点前\n            #                 hashmap[key]                 hashmap[key]\n            #                      |                            |\n            #                      V        -->                 V\n            # prev <-> tail  ...  node                prev <-> node <-> tail\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到末尾\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                # 去掉哈希表对应项\n                self.hashmap.pop(self.head.next.key)\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            # 如果不在的话就插入到尾节点前\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n```\n\n复杂度：\n\n- 时间复杂度：各种操作平均都是 O(1)。\n- 空间复杂度：链表占用空间 O(N），哈希表占用空间也是 O(N)，其中 N 为容量大小","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099325892","body":"## 递归\n\n### 思路\n\n1. 分解为子问题，相同的树分解为左子是否相同，右子是否相同\n2. 递归出口: 当树高度为 1 时，判断递归出口\n\n```python\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)O(N)，其中 N 为树的节点数。\n- 空间复杂度：O(h)O(h)，其中 h 为树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1099945228","body":"4.15\n\n## 思路\n\n用python的队列deque，实现广度优先搜索\n\n## 代码\n\n```python\nfrom collections import deque\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        que1 = deque()\n        que2 = deque()\n        ls = []\n\n        que1.appendleft(root)\n        que2.appendleft(root.val)\n\n        while que1:\n            l = len(que1)\n            for _ in range(l):\n                node = que1.pop()\n                val = que2.pop()\n\n                if node.left:\n                    que1.appendleft(node.left)\n                    valleft = val*10 + node.left.val\n                    que2.appendleft(valleft)\n                \n                if node.right:\n                    que1.appendleft(node.right)\n                    valright = val*10 +node.right.val\n                    que2.appendleft(valright)\n\n                if not node.left and not node.right:\n                    ls.append(val)\n\n        sumre = sum(ls)\n\n        return sumre \n```\n\n## 复杂度\n\n时间复杂度：O(N) N为树中节点树\n空间复杂度： O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100902992","body":"思路：DFS\n代码：\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def serialize(self, root):\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n\n\n\n    def deserialize(self, data: str):\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        # 已经有 root 了，因此从 1 开始\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            i += 2\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n        return root\n\n复杂度分析\n\n时间复杂度：O(N)O(N)，其中 N 为树的节点数。\n\n空间复杂度：O(Q)O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树，此时和 N 同阶，其中 N 为树的节点总数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101508937","body":"4.18\n\n思路：\n\n记录每一个列出现的所有数字(带行数)，按列排序，按行排序，按值排序即可。\n\n代码：\n\n```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        hashmap = defaultdict(list)\n        def dfs(node, x, y):\n            if not node:\n                return\n            hashmap[y].append((x,node.val))\n            dfs(node.left, x+1, y-1)\n            dfs(node.right,x+1, y+1)\n        \n        dfs(root, 0, 0)\n        return [list(zip(*sorted(hashmap[i])))[1] for i in sorted(hashmap.keys())]\n\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102752126","body":"4.19\n\n#### 解题思路\n\n用哈希表记录所有已经遍历过的数字，判断 `target - num` 是否出现时，直接查表即可。\n\n#### 代码\n\n```\nclass Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            \n            if (map.containsKey(nums[i]))\n                return new int[]{map.get(nums[i]), i};\n            \n            map.put(target - nums[i], i);\n        }\n        \n        return new int[]{};\n    }\n}\n```\n\n#### 复杂度分析\n\n- 空间复杂度: O(n)O(n)\n- 时间复杂度: O(n)O(n)\n\n\n\n## 专题学习：Hash Map\n\n引入：既然哈希表查询和修改时间复杂度都是O（1），那数组和链表还有存在的价值么？\n\n### 哈希表重点结论：\n\n- 哈希表查询的精髓就在于数组，哈希表查找的平均时间复杂度 O(1)O(1) 就是因为这个。\n- 哈希表新增和删除的精髓就在于链表或树，哈希表修改和删除的平均时间复杂度 O(1)O(1) 就是因为这个。\n- 哈希表习惯被称为空间换时间的典范\n\n### 应用：哈希表常见题目类型\n\n1.统计 xx 出现次数/频率/** （见下方多人运动）\n\n该种题比较直观，若已知数据范围较小且比较连续，可以考虑用数组来实现。\n\n题目推荐：[811.子域名访问计数](https://leetcode-cn.com/problems/subdomain-visit-count/description/)\n\n\n\n2.**需要查找/增加/删除操作为 O(1)时间复杂度** （一些设计题）\n\n见到这种要求的题可以考虑一下是否需要 hash 表来做，比如 LRU，LFU 之类的题，题目中 要求了时间复杂度，就是用 hash 表+双向链表解决的。\n\n3.**题目类型为图数据结构相关** （比如并查集）\n\n这样可能需要构建有向图/无向图，这时可以用 hash 表来表示图并进行后续操作。\n\n4.**需要存储之前的状态以减少计算开销**（比如经典的两数和）\n\n相信大家做过 dp 的一些题目就知道，记忆化搜索，该方法就利用 hash 表来存储历史状态 ，这样可以大大减少重复计算。\n\n5.状态压缩（本质就是 bit 上的哈希结构）。参考 [状压 DP 是什么？这篇题解带你入门](https://mp.weixin.qq.com/s/ecxTTrRvUJbdWwSFbKgDiw) 推荐一个题目，难度为 Hard。[1601. 最多可达成的换楼请求数目](https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/)\n\n6.记录第一次出现的位置，以便求最远或者最近。比如题目 [697. 数组的度\n\n[](https://leetcode-cn.com/problems/degree-of-an-array/solution/li-kou-jia-jia-ha-xi-biao-chang-jian-yin-7jez/)\n\n### 原理理解：待补充","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1104103447","body":"解题思路：\n更新 0623： 更新为位操作，占位节点版本，简化的代码，方便记忆。\n\n这题是对 堆，优先队列 很好的练习，因此有必要自己用python实现研究一下。堆 处理海量数据的 topK，分位数 非常合适，优先队列 应用在元素优先级排序，比如本题的频率排序非常合适。与基于比较的排序算法 时间复杂度 O(nlogn)O(nlogn) 相比，使用 堆，优先队列 复杂度可以下降到 O(nlogk)O(nlogk)，在总体数据规模 n 较大，而维护规模 k 较小时，时间复杂度优化明显。\n\n堆，优先队列 的本质其实就是个完全二叉树，有其下重要性质\nps: 堆 heap[0] 插入一个占位节点，此时堆顶为 index 为 1 的位置，可以更方便的运用位操作。\n[1,2,3] -> [0,1,2,3]\n\n父节点 index 为 i\n左子节点 index 为 i << 1\n右子节点 index 为 i << 1 | 1\n大顶堆中每个父节点大于子节点，小顶堆每个父节点小于子节点\n优先队列以优先级为堆的排序依据\n因为性质 1，2，3，堆可以用数组直接来表示，不需要通过链表建树。\n堆，优先队列 有两个重要操作，时间复杂度均是 O(logk)O(logk)。以小顶锥为例：\n\n上浮 sift up: 向堆尾新加入一个元素，堆规模 +1，依次向上与父节点比较，如小于父节点就交换。\n下沉 sift down: 从堆顶取出一个元素（堆规模 -1，用于堆排序）或者更新堆中一个元素（本题），依次向下与子节点比较，如大于子节点就交换。\n对于 topk 问题：最大堆求topk小，最小堆求 topk 大。\n\ntopk小：构建一个 k 个数的最大堆，当读取的数小于根节点时，替换根节点，重新塑造最大堆\ntopk大：构建一个 k 个数的最小堆，当读取的数大于根节点时，替换根节点，重新塑造最小堆\n这一题的总体思路 总体时间复杂度 O(nlogk)O(nlogk)\n\n遍历统计元素出现频率 O(n)O(n)\n前k个数构造 规模为 k+1 的最小堆 minheap， O(k)O(k)， 注意 +1 是因为占位节点。\n遍历规模k之外的数据，大于堆顶则入堆，下沉维护规模为k的最小堆 minheap. O(nlogk)O(nlogk)\n(如需按频率输出，对规模为k的堆进行排序)\nPythonC++\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        def sift_down(arr, root, k):\n            \"\"\"下沉log(k),如果新的根节点>子节点就一直下沉\"\"\"\n            val = arr[root] # 用类似插入排序的赋值交换\n            while root<<1 < k:\n                child = root << 1\n                # 选取左右孩子中小的与父节点交换\n                if child|1 < k and arr[child|1][1] < arr[child][1]:\n                    child |= 1\n                # 如果子节点<新节点,交换,如果已经有序break\n                if arr[child][1] < val[1]:\n                    arr[root] = arr[child]\n                    root = child\n                else:\n                    break\n            arr[root] = val\n\n        def sift_up(arr, child):\n            \"\"\"上浮log(k),如果新加入的节点<父节点就一直上浮\"\"\"\n            val = arr[child]\n            while child>>1 > 0 and val[1] < arr[child>>1][1]:\n                arr[child] = arr[child>>1]\n                child >>= 1\n            arr[child] = val\n\n        stat = collections.Counter(nums)\n        stat = list(stat.items())\n        heap = [(0,0)]\n\n        # 构建规模为k+1的堆,新元素加入堆尾,上浮\n        for i in range(k):\n            heap.append(stat[i])\n            sift_up(heap, len(heap)-1) \n        # 维护规模为k+1的堆,如果新元素大于堆顶,入堆,并下沉\n        for i in range(k, len(stat)):\n            if stat[i][1] > heap[1][1]:\n                heap[1] = stat[i]\n                sift_down(heap, 1, k+1) \n        return [item[0] for item in heap[1:]]\n\n再附上堆排序(从小到大输出)，注意这里是大顶堆\n\n从后往前非叶子节点下沉，依次向上保证每一个子树都是大顶堆，构造大顶锥\n依次把大顶堆根节点与尾部节点交换(不再维护，堆规模 -1)，新根节点下沉。\n\ndef heapSort(arr):\n    def sift_down(arr, root, k):\n        val = arr[root]\n        while root<<1 < k:\n            chlid = root << 1\n            if chlid|1 < k and arr[chlid|1] > arr[chlid]:\n                chlid |= 1\n            if arr[chlid] > val:\n                arr[root] = arr[chlid]\n                root = chlid\n            else:\n                break\n        arr[root] = val\n\n    arr = [0] + arr\n    k = len(arr)\n    for i in range((k-1)>>1, 0, -1):\n        sift_down(arr, i, k) \n    for i in range(k-1, 0, -1):\n        arr[1], arr[i] = arr[i], arr[1]\n        sift_down(arr, 1, i)\n    return arr[1:]\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105378924","body":"4.21\n\n思路：\n\n使用哈希表进行预处理，在统计以 ii 为三元组第一位的回旋镖个数前，先计算出 ii 和其余点的距离，并以 { 距离 : 个数 } 的形式进行存储，然后分别对所有的距离进行累加计数。\n\n代码：\n\n```\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> map = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int x = points[i][0] - points[j][0], y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n            for (int dist : map.keySet()) {\n                int cnt = map.get(dist);\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n时间复杂度：O(n^2)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106529357","body":"#### 4.22\n\n思路：滑动窗法：只要把队列的左边的元素移出就行了，一直维持这样的队列，找出队列出现最长的长度时候，求出解！\n\n代码：\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_len -= 1\n            if cur_len > max_len:max_len = cur_len\n            lookup.add(s[i])\n        return max_len\n\n```\n\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107344243","body":"#### 4.23\n\n思路：滑动窗口法：一直在 `s` 维护着所有单词长度总和的一个长度队列！\n\n代码：\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:return []\n        one_word = len(words[0])\n        word_num = len(words)\n        n = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0, one_word):\n            cur_cnt = 0\n            left = i\n            right = i\n            cur_Counter = Counter()\n            while right + one_word <= n:\n                w = s[right:right + one_word]\n                right += one_word\n                cur_Counter[w] += 1\n                cur_cnt += 1\n                while cur_Counter[w] > words[w]:\n                    left_w = s[left:left+one_word]\n                    left += one_word\n                    cur_Counter[left_w] -= 1\n                    cur_cnt -= 1\n                if cur_cnt == word_num :\n                    res.append(left)\n        return res\n\n```\n\n时间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107996831","body":"#### 4.25\n\n思路：双指针法\n\n代码：\n\n```python\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n\n**复杂度分析**\n\n令 n 为链表长度\n\n- 时间复杂度: O(n)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109194341","body":"#### 4.26\n\n思路：\n\n- 用一个读指针，一个写指针遍历数组。\n- 遇到重复的元素 `读指针` 就继续前移。\n- 遇到不同的元素 `写指针` 就前移一步，写入那个元素。\n\n代码：\n\n```python\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return 0\n\n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```\n\n**复杂度分析**\n\n令 n 为数组长度\n\n时间复杂度: O(n) 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111002059","body":"#### 4.27\n\n思路：二分法\n\n代码：\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n\n**复杂度分析**\n\n令 n 为数组长度\n\n- 时间复杂度: O(logn)\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111690643","body":"#### 4.28\n\n思路：\n\n对滑动窗口建立一个大小为 k 的**大顶堆**。窗口滑动时，从堆中去除一个滑动窗口**最前的一个数，添加滑动窗口后一个数**。\n\n代码：\n\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        h=[]\n        ans=[]\n        for i in range(k):\n            heapq.heappush(h,(-nums[i],i))\n        ans.append(-h[0][0])\n        for i in range(k,len(nums)):\n            heapq.heappush(h,(-nums[i],i))\n            while h[0][1]<i-k+1:\n                heapq.heappop(h)\n            ans.append((-h[0][0]))\n        return ans\n```\n\n**复杂度分析**\n\n令 n 为数组长度\n\n- 时间复杂度: O(nlogk)\n- 空间复杂度: O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112981677","body":"#### 4.29\n\n思路：\n\n可以遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，我们可以直接返回结果；如果不存在符合条件的点，则返回 -1−1。\n\n代码：\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        inDegrees = Counter(y for _, y in trust)\n        outDegrees = Counter(x for x, _ in trust)\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)\n```\n\n复杂度：\n\n时间复杂度：O(n+m)\n\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087203278","body":"```go\r\nfunc decodeString(s string) (res string) {\r\n\tvar stack []string\r\n\tgetDigits := func(ptr *int) (ret string) {\r\n\t\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n\t\t\tret += string(s[*ptr])\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tgetStrings := func(strs []string) (ret string) {\r\n\t\tfor _, str := range strs {\r\n\t\t\tret += str\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tptr := 0\r\n\tfor ptr < len(s) {\r\n\t\tchr := s[ptr]\r\n\t\tif chr >= '0' && chr <= '9' {\r\n\t\t\tdigits := getDigits(&ptr)\r\n\t\t\tstack = append(stack, digits)\r\n\t\t} else if chr >= 'a' && chr <= 'z' || chr == '[' {\r\n\t\t\tstack = append(stack, string(chr))\r\n\t\t\tptr++\r\n\t\t} else {\r\n\t\t\tptr++\r\n\t\t\tvar sub []string\r\n\t\t\tfor stack[len(stack)-1] != \"[\" {\r\n\t\t\t\tsub = append(sub, stack[len(stack)-1])\r\n\t\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\t}\r\n\t\t\tn := len(sub)\r\n\t\t\tfor i := 0; i < n/2; i++ {\r\n\t\t\t\tsub[i], sub[n-i-1] = sub[n-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\trepTimes, _ := strconv.Atoi(stack[len(stack)-1])\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\tst := strings.Repeat(getStrings(sub), repTimes)\r\n\t\t\tstack =append(stack, st)\r\n\t\t}\r\n\t}\r\n\tres = getStrings(stack)\r\n\treturn\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maybetoffee":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087276903","body":"思路：需要从里到外获得substring和substring对应的次数，符合栈先进后出的特点。为什么需要讲左括号也推进去？因为我们压栈遇到右括号的时候就说明一个substring已经结束，可以弹出了，什么时候结束弹出？就是遇到左括号的时候。弹完substring之后，在弹出一次栈顶，就是将左括号弹出，然后如果当前栈顶是数字，那就是substring对应的次数。\npublic String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();//one of the subStr need to be multiplied\n                stack.pop();//should be a [\n                sb = new StringBuilder();//clean current sb\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }    \n                int count = Integer.parseInt(sb.toString());\n                while(count != 0){\n                    for(char elem: sub.toCharArray()){\n                        stack.push(elem);\n                    }\n                    count--;\n                }\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087917880","body":"class MyStack {\n    private Queue<Integer> q;\n    private int top_elem;\n\n    public MyStack() {\n        q = new LinkedList<>();\n        top_elem = 0; \n    }\n    \n    public void push(int x) {\n        q.offer(x);\n        top_elem = x;\n    }\n    \n    public int pop() {\n        int size = q.size();\n        while(size > 2){\n            q.offer(q.poll());\n            size--;\n        }\n        top_elem = q.peek();\n        q.offer(q.poll());\n        return q.poll();\n    }\n    \n    public int top() {\n        return top_elem;\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089328600","body":"```\npublic int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int num : arr){\n            if(!stack.isEmpty() && num < stack.peek()){\n                int chunkMax = stack.pop();\n                while(!stack.isEmpty() && num < stack.peek()){\n                    stack.pop();\n                }\n                stack.push(chunkMax);\n            }else{\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090440293","body":"今天才做过\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || k == 0){\r\n            return head;\r\n        }\r\n        int n = calculeLength(head);\r\n        k = k%n;\r\n        \r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n       \r\n        for(int i = 0; i < k; i++){\r\n            fast = fast.next;\r\n        }\r\n        \r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        fast.next = head;\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        return newHead;\r\n    }\r\n    \r\n    private int calculeLength(ListNode head){\r\n        int count = 0;\r\n        while(head != null){\r\n            head = head.next;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092090649","body":"``` \npublic ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode curr = dummy;\n    \n        while(curr.next != null && curr.next.next != null){\n            ListNode p1 = curr.next;\n            ListNode p2 = curr.next.next;\n            p1.next = p2.next;\n            curr.next = p2;\n            p2.next = p1;\n            curr = curr.next.next;\n        }\n        return dummy.next;\n    }\n````\n注意reference即可","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093472369","body":"双指针找终点\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    //[start, end) \n    TreeNode build(ListNode start, ListNode end){\n        if(start == end){\n            return null;\n        }\n        \n        ListNode mid = findMid(start, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(start, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    //two pointers\n    ListNode findMid(ListNode start, ListNode end){\n        ListNode slow = start, fast = start;\n        while (fast != end && fast.next != end){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094126350","body":"```\n\rpublic int[] intersection(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int[] res = new int[nums1.length];\n        int p1 = 0;\n        int p2 = 0;\n        int index = 0;\n        \n        while(p1 < nums1.length && p2<nums2.length){\n            if(nums1[p1] == nums2[p2]){\n                if(index ==0 || nums1[p1] != res[index-1]){\n                    res[index] = nums1[p1];\n                    index++;\n                }\n                p1++;\n                p2++;\n            }else if(nums1[p1] < nums2[p2]){\n                p1++;\n            }else{\n                p2++;\n            }\n        }\n        int[] result = new int[index];\n        for(int i = 0; i< index; i++){\n            result[i] = res[i];\n        }\n        return result;       \n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094372461","body":"```\npublic ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        \n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                break; //found the meet position\n            }\n        }\n        if(fast == null || fast.next == null) return null;\n        \n        fast = head;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096362672","body":"```\nclass LRUCache {\n    int cap;\n    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();\n    public LRUCache(int capacity) {\n        this.cap = capacity;        \n    }\n    \n    public int get(int key) {\n        if(!cache.containsKey(key)){\n            return -1;\n        }\n        makeKeyRecent(key);\n        return cache.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if(cache.containsKey(key)){\n            cache.put(key,value);\n            makeKeyRecent(key);\n            return;\n        }\n        if(cache.size() == this.cap){\n            int oldestKey = cache.keySet().iterator().next();\n            cache.remove(oldestKey);\n        }\n         cache.put(key,value);\n    }\n    \n    private void makeKeyRecent(int key){\n        int val = cache.get(key);\n        cache.remove(key);\n        cache.put(key, val);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097228223","body":"```\nclass Solution {\n    int res = 0;\n    int currDepth = 0;\n    public int maxDepth(TreeNode root) {\n        traverse(root);\n        return res;\n    }\n    \n    private void traverse(TreeNode root){\n        if(root == null) return;\n        \n        currDepth++;\n        res = Math.max(res, currDepth);\n        traverse(root.left);\n        traverse(root.right);\n        currDepth--;\n    }\n}\nclass Solution2 {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        \n        int depthLeft = maxDepth(root.left);\n        int depthRight = maxDepth(root.right);\n        return Math.max(depthLeft, depthRight)+1;       \n        \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098513381","body":"```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) return true;\n        if(p == null || q == null) return false;\n        if(p.val != q.val) return false;\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        \n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100643087","body":"```\nclass Solution {\n    //level traversal, when we reach the maxDepth, the first one is target\n    int currDepth = 0;\n    int maxDepth = 0;\n    TreeNode leftMost = null;\n    public int findBottomLeftValue(TreeNode root) {\n        traverse(root);\n        return leftMost.val;\n    }\n    \n    void traverse(TreeNode root){\n        if(root == null) return;\n        \n        currDepth++;\n        if(currDepth > maxDepth){\n            maxDepth = currDepth;\n            leftMost = root;\n        }\n        traverse(root.left);\n        traverse(root.right);\n        currDepth--;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100880221","body":"```\npublic class Codec {\n    String SEP = \",\";\n    String NULL = \"#\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n       StringBuilder res = new StringBuilder();\n        serialize(root, res);\n        return res.toString();\n    }\n    \n    void serialize(TreeNode root, StringBuilder res){\n        if(root == null){\n            res.append(NULL).append(SEP);\n            return;\n        }\n        res.append(root.val).append(SEP);\n        serialize(root.left, res);\n        serialize(root.right,res);\n    }\n    \n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        LinkedList<String> nodes = new LinkedList<>();\n        for(String s : data.split(SEP)){\n            nodes.addLast(s);\n        }\n        return deserialize(nodes);\n    }\n    \n    TreeNode deserialize(LinkedList<String> nodes){\n        if(nodes.isEmpty()) return null;\n        \n        String first = nodes.removeFirst(); //leftmost element is the root \n        if(first.equals(NULL)) return null;//to stop when the path is ended\n        TreeNode root = new TreeNode(Integer.parseInt(first));\n        root.left = deserialize(nodes);\n        root.right = deserialize(nodes);\n        return root;\n    }  \n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1102971676","body":"```\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int num : nums){\n            map.put(num, map.getOrDefault(num, 0)+1);\n        }\n        //int[]{num, freq}\n        //建一个小顶堆，堆顶最小，freq越大越优先\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(){\n           public int compare(int[] m, int[] n){\n               return m[1] - n[1];\n           } \n        });\n        \n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n            int num = entry.getKey(), freq = entry.getValue();\n            if(pq.size() == k){\n                if(pq.peek()[1] < freq){\n                    pq.poll();\n                    pq.offer(new int[]{num, freq});\n                }\n            }else{\n                pq.offer(new int[]{num, freq});\n            }\n        }\n        \n        int[] res = new int[k];\n        for(int i = 0; i < k; i++){\n            res[i] = pq.poll()[0];\n        }\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105687468","body":"```\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int left = 0, right = 0;\n        int res= 0;\n        \n        while( right < s.length()){\n            char rightChar = s.charAt(right);\n            map.put(rightChar, map.getOrDefault(rightChar,0)+1);\n            while(map.get(rightChar) > 1){\n                char leftChar = s.charAt(left);\n                left++;\n                map.put(leftChar, map.get(leftChar)-1);\n            }\n        \n            res = Math.max(res, right-left+1);\n            right++;\n            \n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107518125","body":"```\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        \n        int wordNum = words.length;\n        if(wordNum == 0) return res;\n        int wordLen = words[0].length();\n        //first map to store the target word and count\n        Map<String, Integer> mapTarget = new HashMap<>();\n        for(String word : words){\n            mapTarget.put(word, mapTarget.getOrDefault(word, 0)+1);\n        }\n        \n        //traverse all the subStrings in s\n        \n        for(int i = 0; i < s.length()-wordNum*wordLen+1; i++){\n            Map<String, Integer> mapCurr = new HashMap<>();\n            int num = 0;\n            while(num < wordNum){\n                String word = s.substring(i+wordLen*num, i+wordLen*(num+1));\n                if(mapTarget.containsKey(word)){\n                    mapCurr.put(word, mapCurr.getOrDefault(word,0)+1);\n                    if(mapCurr.get(word) > mapTarget.get(word)){\n                        break;\n                    }\n                }else{\n                    break;\n                }\n                num++;\n            }\n            if(num == wordNum){\n                res.add(i);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107890353","body":"```\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n        \n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111539770","body":"```\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums == null || nums.length == 0){\n            return nums;\n        }\n        Deque<Integer> queue = new LinkedList<>();\n        int[] res = new int[nums.length-k+1];\n        \n        for(int i = 0; i < nums.length; i++){\n            while(!queue.isEmpty() && nums[queue.peekLast()] < nums[i]){\n                queue.pollLast();\n            }\n            queue.addLast(i);\n            \n            if(queue.peek() <= i-k){\n                queue.poll();\n            }\n            \n            if(i+1 >= k){\n                res[i+1-k] = nums[queue.peek()];\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1087760883","body":"思路：\r\n数组，ripple adder\r\n其实用ripple adder 是最经典的解法，但是自从找到实习后没咋刷题，很久没做然后就自己想着什么写什么了\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        num = num[::-1]\r\n        while k:\r\n            mod = k % 10\r\n            k = k//10\r\n            if i < len(num):\r\n                num[i] += mod\r\n            else:\r\n                num.append(mod)\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n\r\n                num[i] -= 10\r\n            i+=1\r\n        while i < len(num):\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n                num[i] -= 10\r\n                i+=1\r\n            else:\r\n                break\r\n        return num[::-1]\r\n\r\n\r\n\r\n```\r\n时间 O(n)\r\n空间 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1087763394","body":"从左右各遍历一次\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left_c = -999999999\r\n        ans = [999999999]*len(s)\r\n        for i,v in enumerate(s):\r\n            if v == c:\r\n                left_c = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], i-left_c)\r\n        right_c = 99999999999\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_c = i\r\n            else:\r\n                ans[i] = min(ans[i], abs(right_c - i))\r\n        return ans\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1087783588","body":"思路：\r\n用两个stack，第二个stack 是记录 add 的值。这道题的最优解tiktok 实习OA 做过，当时不会导致oa没过。必须要求最优解\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    # in my implementation, top means the length of valid values in stack\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0]*maxSize\r\n        self.add = [0]*maxSize\r\n        self.top = 0\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack):\r\n            self.stack[self.top] = x\r\n            self.top += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top > 0:\r\n            ret = self.stack[self.top-1] + self.add[self.top-1]\r\n            # pass down the add value \r\n            if self.top > 1: # means there are items left in stack\r\n\r\n                # self.top - 2 refers to the element below the one just popped\r\n                self.add[self.top-2] += self.add[self.top - 1]\r\n            \r\n            # make the stack and add to default\r\n            self.stack[self.top-1] = 0 # unnecessary though\r\n            self.add[self.top-1] = 0 \r\n            self.top -= 1\r\n\r\n            return ret\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top)\r\n        if lim > 0:\r\n            self.add[lim-1] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n时间O(1)\r\n空间O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087790033","body":"# 思路\r\n这道题老经典了，用stack 做，记录遇到“[\"前遇到的string和”[“ 和”]\" 中间string需要乘的次数。\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        curNum = \"\"\r\n        curStr = \"\"\r\n        for i,v in enumerate(s):\r\n            if \"0\" <= v <=\"9\":\r\n                curNum += v\r\n            elif \"a\" <= v <= \"z\":\r\n                curStr += v\r\n            elif \"[\" == v:\r\n                stack.append((curNum, curStr))\r\n                curStr = \"\"\r\n                curNum = \"\"\r\n            else:\r\n                lastNum, lastStr = stack.pop()\r\n                curStr = lastStr + int(lastNum) * curStr\r\n        return curStr\r\n```\r\n时间 O(n)\r\n空间 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088086201","body":"用两个stack\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            else:\r\n                return -1\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            else:\r\n                return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\nTime: O(1)\r\n\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089134263","body":"这道题一直不太会做，今天看人家辅助栈解法一下就懂了。对于每一个chunk，重点是我们需要知道每个chunk 的最大值(local maximum) ，所以最后的答案是辅助栈的长度。我们要围护一个non-strict decreasing stack， 所以只有在小于栈顶才pop。\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # the length of the stack is the answer we want \r\n        # non-strict decreasing stack\r\n        stack = []\r\n        for i,v in enumerate(arr):\r\n            if stack:\r\n                ## larger or equal to is OK\r\n                if v < stack[-1]:\r\n\r\n                    # this is important, this denotes the max of the curr chunk\r\n                    # we need the local maximum of each chunk\r\n                    # so incoming elements can do the same procedure by comparing with the local maximum\r\n                    head = stack.pop() \r\n\r\n                    ## we need to group this chunk\r\n                    while stack and v < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(head)\r\n                else:\r\n                    stack.append(v)\r\n\r\n            else:\r\n                stack.append(v)\r\n        return len(stack)\r\n```\r\n时间 O(n)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090597514","body":"算是比较经典的一道题目：主要考察快慢指针。思路：先算链表长度，然乎对k做mudolo，然后把倒数第k个节点搬到第一个去就行\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n\r\n        cnt = 0\r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            cnt += 1\r\n        \r\n        k = k % cnt\r\n        if k == 0:\r\n            return head\r\n        prev = None\r\n        fast = slow = head\r\n        while k > 1:\r\n            fast = fast.next\r\n            k -=1\r\n        while fast and fast.next:\r\n            fast = fast.next\r\n            prev = slow\r\n            slow = slow.next\r\n        \r\n        prev.next = None\r\n        fast.next = head\r\n        return slow\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092264296","body":"没啥套路，就考虑两两节点如何swap，需要使用sentinel node 记录返回值\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        prev = ans = ListNode(0)\r\n        left = head\r\n        right = head.next\r\n        while left and right:\r\n            nextLeft = right.next \r\n            prev.next = right\r\n            right.next = left\r\n            left.next = nextLeft\r\n\r\n            prev = left\r\n            left = nextLeft\r\n            if left:\r\n                right = left.next\r\n\r\n        return ans.next\r\n\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095535457","body":" Linklist\r\n\r\n```python\r\nclass Node:\r\n    def __init__(self,key=0, value=0):\r\n        self.key = key\r\n        self.val = value\r\n        self.prev = None\r\n        self.next = None\r\n    \r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.hash = {}\r\n        self.head = Node()\r\n        self.last = Node()\r\n        self.head.next = self.last\r\n        self.last.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hash:\r\n            return -1\r\n        node = self.hash[key]\r\n\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        self.appendToHead(node)\r\n        return node.val\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hash:\r\n            node = self.hash[key]\r\n            node.val = value\r\n            \r\n            node.prev.next = node.next\r\n            node.next.prev = node.prev\r\n\r\n            self.appendToHead(node)\r\n            return\r\n        if self.size < self.capacity:\r\n            node = Node(key, value)\r\n            self.hash[key] = node\r\n            self.appendToHead(node)\r\n            self.size+=1\r\n        else:\r\n            self.replaceNode(key, value)\r\n    \r\n    def appendToHead(self, node):\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def replaceNode(self, newKey, newVal):\r\n        deleted = self.last.prev\r\n\r\n        del self.hash[deleted.key]\r\n        deleted.key = newKey\r\n        deleted.val = newVal\r\n        self.hash[newKey] = deleted\r\n\r\n        deleted.prev.next = deleted.next\r\n        deleted.next.prev = deleted.prev\r\n        self.appendToHead(deleted)\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100785438","body":"DFS\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        def recur(root, ans):\r\n            if not root:\r\n                ans.append(\"N\")\r\n                return\r\n            ans.append(str(root.val))\r\n            recur(root.left, ans)\r\n            recur(root.right, ans)\r\n        ans =[]\r\n        recur(root, ans)\r\n        return \"/\".join(ans)\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data = data.split(\"/\")\r\n        data = data[::-1]\r\n        def recur(data):\r\n            popped = data.pop()\r\n            if popped == \"N\":\r\n                return None\r\n            node = TreeNode(popped)\r\n            node.left = recur(data)\r\n            node.right = recur(data)\r\n            return node\r\n        return recur(data)\r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fhuang5":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1090932251","body":"```java\nimport java.util.Collections;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> array = new ArrayList<Integer>();\n        int carry = 0;\n        int i = num.length -1; \n        while (k != 0 || carry != 0 || i >= 0){\n            int cur =  k % 10 + carry;\n            if (i >=0){\n                cur += num[i];\n                i--;\n            }\n            array.add(cur % 10);\n            carry = cur / 10;\n            k = k / 10;\n        }\n        Collections.reverse(array);\n        return array;\n        \n    }\n```\nTime Complexity: O(n)\\\nSpace Complexity: O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1092483774","body":"```java\nimport java.util.*;\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] charArray = s.toCharArray();  \n        int[] result = new int[charArray.length];\n        \n        int prev = -charArray.length; \n        for (int i = 0; i < charArray.length; i++){\n            if (charArray[i] == c){\n                prev = i;\n            }\n            result[i] = i - prev;\n        }\n        \n        \n        prev = 2*charArray.length; \n        for (int i = charArray.length - 1; i>=0; i--){\n            if (charArray[i] == c) prev = i;\n            result[i] = Math.min(result[i], prev -i);\n        }\n        return result;\n    }\n}\n\n//Time Complexity: O(N)\n//Space Complexity: O(N)\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1092418989","body":"```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s){\n        StringBuilder result = new StringBuilder();\n        while (index < s.length() && s.charAt(index) != ']'){\n            if (!Character.isDigit(s.charAt(index))){\n                result.append(s.charAt(index));\n                index++;\n            }\n            else {\n                int k = 0;\n                // build k while next character is a digit\n                while (index < s.length() & Character.isDigit(s.charAt(index))){\n                    k = k * 10 + s. charAt(index) - '0';\n                    index++;\n                }\n                //ignore the '['\n                index++;\n                String decodedString = decodeString(s);\n                //ignore ']'\n                index++;\n                //build k[decodedString] and append the result\n                while (k-- > 0)\n                    result.append(decodedString);\n            }\n        }\n        return new String(result);\n    }\n}   \n\n// TC: O (max(n,length of output)) for extreme situations like 1[1[1[1[1[a]]]]] and 9[9[9[9[9[9[[a]]]]]]]\n// SC:  O(max(n,length of output))\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088158191","body":"(Java). Used helper function to avoid repeated code. O(1) amortized time and O(1) auxiliary space.\n```\nclass MyQueue {\n    \n    private Stack<Integer> pushStack = new Stack<Integer>();\n    private Stack<Integer> popStack = new Stack<Integer>();\n    \n    private void updatePopStack() {\n        if(popStack.isEmpty()) {\n            while(!pushStack.isEmpty()){\n                popStack.push(pushStack.pop());\n            }\n        }\n    }\n\n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        updatePopStack();\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        updatePopStack();\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return ( popStack.isEmpty() && pushStack.isEmpty() );\n        \n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089450902","body":"Key invariant: In each chunk, every element must greater than or equal to the maximum of the previous chunk.\n\nI kept a stack storing the maximums of each chunk so far. Each new element starts out in its own chunk, then adjacent chunks are unioned together from right to left (via popping off of the stack and updating the maximum) until the above invariant is satisfied. \n\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> maxInChunks = new Stack<Integer>();\n        for (int x: arr) {\n            int newMax = x;\n            while (!maxInChunks.isEmpty() && maxInChunks.peek() > x) {\n                newMax = Math.max(newMax, maxInChunks.pop());\n            }\n            maxInChunks.push(newMax);\n        }\n        return maxInChunks.size();\n    }\n}\n```\nTime complexity: O(n), since at most n-1 unions will take place\n\nAuxiliary space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090884355","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        ListNode cur = head;\n        int count = 1;\n        while (cur.next != null){\n            cur = cur.next;\n            count++;\n        }\n        cur.next = head;\n        for (int i = 1; i <= count - (k % count); i++){\n            cur = cur.next;\n        }\n        ListNode newHead = cur.next;\n        cur.next = null; \n        return newHead;              \n    }\n}\n```\nTime Complexity: O(n)\\\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092317701","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode secondNode = head.next;\n        ListNode subResult = swapPairs(secondNode.next);\n        secondNode.next = head;\n        head.next = subResult;\n        \n        return secondNode;\n        \n    }\n}\n\n#Time Complexity: O(n), where n is the number of nodes\n#Space Complexity: O(n/2) on the call stack\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093759747","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        int count = 0;\n        ListNode cur = head;\n        while (cur!= null){\n            cur = cur.next;\n            count++;\n        }\n        cur = head;\n        for (int i = 0; i< count/2-1; i++){\n            cur = cur.next;\n        }\n        TreeNode root = new TreeNode(cur.next.val);\n        root.right= sortedListToBST(cur.next.next);\n        cur.next = null;\n        root.left = sortedListToBST(head);\n        return root;     \n        \n    }\n}\n\n//TC: O(N logN) where N is the length of the linked list.\n//SC: O(Log N) on call stack, and O(N) on the heap.\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095892697","body":"Keeps track of key-value pairs in a map, and keeps track of the order of updates in a queue (with another map to keep track of how many times each key occurs in the queue). Not the slickest or fastest solution, but still amortized O(1) time for get() and put(). The queue size can be as large as the number of calls to put().\n\n```java\nclass LRUCache {\n    private int capacity;\n    private Map<Integer, Integer> cache = new HashMap<Integer, Integer>();\n    private Map<Integer, Integer> countInQueue = new HashMap<Integer, Integer>();\n    private Queue<Integer> updates = new LinkedList<Integer>();\n    \n    private void updateQueue(int key) {\n        updates.add(key);\n        if (countInQueue.containsKey(key)) {\n            countInQueue.put(key, countInQueue.get(key)+1);\n        }\n        else {\n            countInQueue.put(key, 1);\n        }\n    }\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            updateQueue(key);\n            return cache.get(key);\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        cache.put(key, value);\n        updateQueue(key);\n        if (cache.size() > capacity) {\n            while (true) {\n                int oldest = updates.remove();\n                countInQueue.put(oldest, countInQueue.get(oldest)-1);\n                if (countInQueue.get(oldest) == 0) {\n                    countInQueue.remove(oldest);\n                    cache.remove(oldest);\n                    break;\n                }\n            } \n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101928967","body":"Used a HashMap to quickly check if a given element is in the array.\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> seen = new HashMap<Integer, Integer>();\n        for(int i=0; i<nums.length; i++) {\n            int difference = target - nums[i];\n            if(seen.containsKey(difference)) {\n                return new int[]{seen.get(difference), i};\n            }\n            else {\n                seen.put(nums[i], i);\n            }\n        }\n        return null;\n    }\n}\n```\nTime: O(n)\\\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088190548","body":"```python\r\nclass MyQueue(object):\r\n\r\n    \"\"\"\r\n    Queue is fifo stack is lifo\r\n    \r\n    [1, 2, 3]\r\n    [3, 2, 1]\r\n    \r\n    [4] -> push\r\n    [3,2,1] -> peak and pop\r\n    if not queue:\r\n        push elem from first stack to sec\r\n    else:\r\n        pop or peek from the other    \r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.pushStack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        return self.popStack.pop()\r\n            \r\n            \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        print(self.pushStack)\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        print(self.popStack)\r\n        return self.popStack[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.pushStack) == 0 and len(self.popStack) == 0\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088280937","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stackpush = []\n        self.stackpop = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stackpush.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while not self.stackpop:\n            while self.stackpush:\n                self.stackpop.append(self.stackpush.pop())\n        return self.stackpop.pop()\n            \n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while self.stackpop:\n            self.stackpush.append(self.stackpop.pop())\n        return self.stackpush[0]\n    \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not(bool(self.stackpop) or bool(self.stackpush))\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092586336","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = ListNode(next = head)\r\n        cur = head\r\n        while cur and cur.next:\r\n            cur_val = cur.val\r\n            cur.val = cur.next.val\r\n            cur.next.val = cur_val\r\n            cur = cur.next.next\r\n\r\n        return dummy.next\r\n```\r\n\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095950002","body":"```python\r\n\r\nclass Node:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.value = v\r\n        self.next = None\r\n        self.prev = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.head = Node(0, 0)\r\n        self.tail = Node(0, 0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.data = {}\r\n        self.cur_size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            return node.value\r\n        else:\r\n            return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            node.value = value\r\n        else:\r\n            node = Node(key, value)\r\n            self.data[key] = node\r\n            if self.cur_size < self.capacity:\r\n                self.cur_size += 1\r\n            else:\r\n                key = self.removeTail()\r\n                del self.data[key]\r\n            self.append(node)\r\n\r\n    def remove(self, node: Node):\r\n        prev_n = node.prev\r\n        next_n = node.next\r\n        prev_n.next = next_n\r\n        next_n.prev = prev_n\r\n\r\n    def append(self, node: Node):\r\n        first = self.head.next\r\n        first.prev = node\r\n        self.head.next = node\r\n        node.next = first\r\n        node.prev = self.head\r\n\r\n    def removeTail(self) -> int:\r\n        key = self.tail.prev.key\r\n        self.remove(self.tail.prev)\r\n        return key\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102064623","body":"```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        hashdict = dict()\r\n        for i, num in enumerate(nums):\r\n            if target - num in hashdict:\r\n                return [hashdict[target - num], i]\r\n            hashdict[nums[i]] = i\r\n        return []\r\n```\r\n\r\n* Time: O(N)\r\n* Space O(N)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107987603","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while fast and fast.next:\n            fast, slow = fast.next.next, slow.next\n            \n        return slow\n```\n\n- Time: O(n)\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088371802","body":"```cpp\n// 4-5 cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    stack<int> stIn;\n    stack<int> stOut;\n\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (stOut.empty()) {\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        int res = this->pop();\n        stOut.push(res);\n        return res;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294097","body":"```cpp\n// 4-10 cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n\n        int lenA = 0;\n        int lenB = 0;\n\n        while (curA != NULL) {\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) {\n            lenB++;\n            curB = curB->next;\n        }\n\n        curA = headA;\n        curB = headB;\n        if (lenB > lenA) {\n            swap(curB, curA);\n            swap(lenB, lenA);\n        }\n        int gap = lenA - lenB;\n        while (gap--) {\n            curA = curA->next;\n        }\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100785699","body":"```c++\n// cpp 4-17\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (root == NULL) return \"\";\n        queue<TreeNode *> que;\n        que.push(root);\n        string ans;\n        while (!que.empty()) {\n            int len = que.size();\n            for (int i = 0; i < len; i++) {\n                TreeNode * Node = que.front();\n                que.pop(); \n                if (Node) {\n                    ans += to_string(Node->val) + \" \";\n                    que.push(Node->left);\n                    que.push(Node->right);\n                }\n                else ans += \"# \";       \n\n            }\n        }\n        return ans;   \n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if (data.empty()) return NULL;\n        stringstream ss(data);\n        string var;\n        ss >> var;\n        TreeNode * root = new TreeNode(stoi(var));\n        queue<TreeNode*> que;\n        que.push(root);\n        while (!que.empty()) {\n            int len = que.size();\n            for (int i = 0; i < len; i++) {\n                TreeNode * node = que.front();\n                que.pop();\n                string left, right;\n                ss>>left>>right;\n                if (left!=\"#\") {\n                    TreeNode *left_node = new TreeNode(stoi(left));\n                    node->left = left_node;\n                    que.push(left_node);\n                }\n                if (right!=\"#\") {\n                    TreeNode *right_node = new TreeNode(stoi(right));\n                    node->right = right_node;\n                    que.push(right_node);\n                }\n            }\n\n        }\n        return root;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107456997","body":"#### [30. 串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)\n\n```cpp\n// 4-23 cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        if (s.empty() || words.empty()) return {};\n        int len = s.size();\n        unordered_map<string, int> mp;\n        int a = 0;\n        vector<int> ans;\n        for (auto w : words) {\n            ++mp[w];\n        }\n        int wlen = words[0].size(), count = words.size();\n        int match = 0;\n        for (int i = 0; i < len - wlen * count + 1; i++) {\n            string cur = s.substr(i, wlen * count);\n            unordered_map<string, int> temp;\n            int j = 0, cnt = 0;\n            for (; j < cur.size(); j += wlen) {\n                string curword = cur.substr(j, wlen);\n\n                if (mp.count(curword) == 0) break;\n                temp[curword]++;\n                cnt++;\n                if (temp[curword] > mp[curword]) break;\n\n                if (cnt == count) ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zuoduozhongguo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088712753","body":"# 思路\r\n\r\n用列表来作为栈的存储空间，先入栈，后出栈入第二个栈，当需要输出时再从第二个栈输出，即可实现队列功能\r\n\r\n# 代码\r\n\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.b:\r\n            self.a.append(self.b.pop())\r\n        self.a.append(x)\r\n        while self.a:\r\n            self.b.append(self.a.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.b[-1] \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.b) == 0\r\n```\r\n\r\n# 复杂度\r\n时间：O(1)，空间：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094302359","body":"## 20220410 打卡\r\n## 思路\r\n双指针分别遍历两个链表，相同则返回，遍历到底则指向另一个链表的头结点\r\n\r\n## 代码\r\n```Python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headB or not headA:\r\n            return None\r\n        \r\n        p = headA\r\n        q = headB\r\n        while p!=q:\r\n            p = p.next if p else headB\r\n            q = q.next if q else headA\r\n        return p\r\n```\r\n\r\n## 复杂度\r\n时间：O(m+n) , 空间：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100802901","body":"##  思路\r\n层次遍历\r\n\r\n##  代码\r\n\r\n```Python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        if not root:\r\n            return ''\r\n        queue = collections.deque([root])\r\n        res = []\r\n        while queue:\r\n            node = queue.popleft()\r\n            if node:\r\n                res.append(str(node.val))\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                res.append('None')\r\n        return '[' + ','.join(res) + ']'\r\n\r\n    def deserialize(self, data):\r\n        if not data:\r\n            return []\r\n        dataList = data[1:-1].split(',')\r\n        root = TreeNode(int(dataList[0]))\r\n        queue = collections.deque([root])\r\n        i = 1\r\n        while queue:\r\n            node = queue.popleft()\r\n            if dataList[i] != 'None':\r\n                node.left = TreeNode(int(dataList[i]))\r\n                queue.append(node.left)\r\n            i += 1\r\n            if dataList[i] != 'None':\r\n                node.right = TreeNode(int(dataList[i]))\r\n                queue.append(node.right)\r\n            i += 1\r\n        return root\r\n```\r\n\r\n##  复杂度\r\n时间/空间：O(N)\r\n\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102599968","body":"# 20220419打卡\n\n## 思路\n在Python中，用字典构成hash表，查询target-num是否在表中\n\n## 代码\n```Python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        hashtable = {}  #字典-构建hash表\n        for i,num in enumerate(nums):\n            #if target - num in hashtable:\n            if hashtable.get(target - num) is not None:\n                return [hashtable[target - num],i]\n            hashtable[nums[i]] = i\n        return []\n\n        '''\n        #先排序再找数不行，因为破坏了原来的顺序\n        nums.sort(reverse = False)\n        i,j = 0,len(nums)-1\n        while i < j:\n            s = nums[i] + nums[j]\n            if s < target:\n                i += 1\n            elif s > target:\n                j -= 1\n            else:\n                return [i,j]\n        return []\n    \n        '''\n        '''\n        n = len(nums)\n        for ii in range(n):\n            nums2 = nums[ii+1:]\n            if target - nums[ii] in nums2:\n                jj = nums2.index(target - nums[ii]) + ii + 1\n                return [ii,jj]\n        return []\n        '''\n```\n\n## 复杂度\n时间/空间：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107706132","body":"## lc1590. 使数组和能被 P 整除\n## 思路\n前缀和，同余定理\n\n## 代码\n```Python\nclass Solution(object):\n    def minSubarray(self, nums, p):\n        \"\"\"\n        :type nums: List[int]\n        :type p: int\n        :rtype: int\n        \"\"\"\n        target = sum(nums) % p\n        if target == 0:\n            return 0\n\n        total = 0\n        dic = {0:-1}\n        ans = len(nums)\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % p\n            if (total - target) % p in dic:\n                ans = min(ans,j - dic[(total - target) % p])\n            dic[cur] = j\n        \n        return (-1 if ans == len(nums) else ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107997152","body":"#  链表中间结点\r\n## 方法一\r\n先遍历全部，再遍历到中间\r\n###  code\r\n```Python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        #先遍历链表，获得链表长度n\r\n        n,p = 0,head\r\n        while p:\r\n            n += 1\r\n            p = p.next\r\n        #再把链表遍历到中点的位置\r\n        k,q = 0,head\r\n        while k < n//2:  #从0开始，所以取<\r\n            k += 1\r\n            q = q.next\r\n        return q\r\n```\r\n### 复杂度\r\n时间：O(N)    空间：O（1）\r\n\r\n## 方法二\r\n快慢指针\r\n## code\r\n```Python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        #快慢指针\r\n        slow = fast = head\r\n        while fast and fast.next :\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        return slow\r\n```\r\n##  复杂度\r\n时间：O(N)   空间：O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112376492","body":"##  思路\r\n单调队列\r\n\r\n## 代码\r\n```Python\r\ndef maxSlidingWindow(nums: List[int], k: int) -> List[int]:\r\n    max_list = []\r\n    q = collections.deque()\r\n    for i in range(len(nums)):\r\n        #sub_nums = nums[i:i + k]\r\n        #ans = max(sub_nums)\r\n        #max_list.append(ans)\r\n        while q and nums[q[-1]] <= nums[i]:\r\n            q.pop()\r\n        while q and i - q[0] >= k:\r\n            q.popleft()\r\n        q.append(i)\r\n        if i - k + 1>= 0:\r\n            max_list.append(nums[q[0]])\r\n    return max_list\r\n```\r\n\r\n## 复杂度\r\n时间：O(N)    \r\n空间：O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bey11-h":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088779331","body":"class MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aibotao":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088859289","body":"class MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dqhe":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088948032","body":"# 思路\n将第一个栈的数字倒入第二个栈\n\n# 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_push=[]\n        self.stack_pop=[]\n\n    def push(self, x: int) -> None:\n        self.stack_push.append(x)\n\n    def pop(self) -> int:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop.pop()\n\n    def peek(self) -> int:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop[-1]\n\n    def empty(self) -> bool:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return not bool(self.stack_pop)\n```\n# 复杂度分析\n\n时间复杂度O(N)\n空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090582600","body":"# 思路\n用一个辅助栈存pop出来的值，pop出的数值前的块的最大值应当小于等于这个数值后的块的最小值，但是还是有bug\n\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: list[int])-> int:\n\n        num = 1\n        helparr=[]\n        for i in range(1, len(arr)):\n            s=arr.pop()\n            helparr.append(s)\n           # print(len(arr))\n            if len(arr)>0:\n               if s <= min(helparr) and max(arr) <= min(helparr):\n                  num=num+1\n            elif len(arr)==0:\n               break\n        if helparr[-1] < min(helparr[0:len(helparr)-2]):\n            num=num+1\n        return num\n\nm=Solution()\nprint(m.maxChunksToSorted([1,0,1,7,2]))\n\n```\n\n# 复杂度分析\n\n时间复杂度 以及空间复杂度 都是  O(N)\n","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095106256","body":"# 思路\n快慢指针法\n\n# 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n# 复杂度分析\n时间复杂度 O(N)\n空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089725657","body":"\r\n\r\n### 思路\r\n辅助栈牛逼\r\n\r\n### 代码\r\n\r\n```class Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094029871","body":"```\nclass Solution:\n    def __init__(self):\n        self.head = None\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        n, self.head = 0, head\n        while head:\n            head = head.next\n            n += 1\n        return self.to_bst(0, n - 1)\n    def to_bst(self, left, right):\n        if left > right: return\n        m = (left + right) // 2\n        left_child = self.to_bst(left, m - 1)\n        father = TreeNode(self.head.val)\n        self.head = self.head.next\n        father.left = left_child\n        father.right = self.to_bst(m + 1, right)\n        return father\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100513469","body":"```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = [root]\n        ans = root.val\n        while queue:\n            ans = queue[0].val\n            n = len(queue)\n            for i in range(n):\n                node = queue[0]\n                del queue[0]\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans\n```\n参考来自:hhh-v0大佬\n","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107614975","body":"class Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vuesch":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090208804","body":"## 代码\n```js\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n\n```\n## 复杂度分析\n\n时间复杂度：O(N)O(N)，其中 N 为数组长度。\n\n空间复杂度：O(N)O(N)，其中 N 为数组长度。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096299036","body":"## 代码\n```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1094199460","body":"## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const res = []\r\n  let i = num.length - 1\r\n  let carry = 0\r\n  while (i >= 0 || k > 0 || carry > 0) {\r\n    let cur = (num[i] || 0) + k % 10 + carry\r\n    res.push(cur % 10)\r\n    carry = cur / 10 | 0\r\n    i--\r\n    k = k / 10 | 0\r\n  }\r\n  return res.reverse()\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1094199614","body":"\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1094172593","body":"## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length === this.maxSize) return\r\n    this.list[this.list.length] = x\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (!this.list.length) return -1\r\n    return this.list.splice(this.list.length - 1, 1)[0]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for (let i = 0; i < (this.list.length < k ? this.list.length : k); i++) {\r\n         this.list[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：push$O(1)$， pop$O(1)$，increment$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1094193073","body":"## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const lstack = [], nstack = []\r\n  let num = 0\r\n  let res = ''\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    const item = s.substr(i, 1)\r\n    if (Number.isInteger(+item)) {\r\n      num = num * 10 + +item\r\n    } else if (item === '[') {\r\n      nstack.push(num)\r\n      num = 0\r\n      lstack.push(res)\r\n      res = ''\r\n    } else if (item === ']') {\r\n      let times = nstack.pop()\r\n      let temp = lstack.pop()\r\n      while (times--) {\r\n        temp += res\r\n      }\r\n      res = temp\r\n    } else {\r\n      res = res + item\r\n    }\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1094197362","body":"## 思路\r\n双栈\r\n1. 定义一个变量保存队首元素front，朴实时，s1栈空时，同时赋值给front\r\n2. pop时，s2栈空时，将s1元素出栈并push到s2，顺序翻转，此时s2栈顶元素为队首元素，s2pop\r\n3. peek时，若s2栈不为空，则取s2栈顶元素，反之，取front\r\n## 关键点\r\n\r\n- \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\nvar MyQueue = function() {\r\n  this.front = undefined\r\n  this.s1 = []\r\n  this.s2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  if (!this.s1.length) {\r\n    this.front = x\r\n  }\r\n  this.s1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (!this.s2.length) {\r\n    while (this.s1.length) {\r\n      this.s2.push(this.s1.pop())\r\n    }\r\n  }\r\n\r\n  return this.s2.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if (this.s2.length) {\r\n    return this.s2[this.s2.length - 1]\r\n  }\r\n  return this.front\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return !this.s1.length && !this.s2.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：push O(1), pop 均摊O(1), peek. O(1), empty O(1) \r\n- 空间复杂度：$O(n)$\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090291824","body":"/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  const stack = []\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\r\n      stack.push(arr[i])\r\n    } else {\r\n      const cur = stack.pop()\r\n      while(stack[stack.length - 1] > arr[i]) {\r\n        stack.pop()\r\n      }\r\n      stack.push(cur)\r\n    }\r\n  }\r\n  return stack.length\r\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094200547","body":"## 思路\r\n双指针，两个指针分别从A、B以相同速度出发，当某个指针走到尾后，将其指向另一个链表的头，继续走。当两个指针碰头时，就是相交点\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n\r\n    while (a && b) {\r\n      if (a === b) return a\r\n      a = a.next\r\n      b = b.next\r\n\r\n      if (!a) {\r\n        a = headB\r\n      }\r\n      if (!b) {\r\n        b = headA\r\n      }\r\n    }\r\n    return null\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(m+n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1101218307","body":"## 思路\r\n快慢针：\r\n1. 快针速度是慢针速度的两倍，则快针走过的总长度= 2 * 慢针走过总长度\r\n2. 当链表中存在环时，两个指针一定会在环中相遇\r\n3. 假设从起始点到环入口的长度为L，环的周长为R，快针走过的总长为LA, 慢针走过的总长为LB, 环入口到相遇点距离为S；LA = n1 * R + S + L; LB = n2 * R + S +L;\r\n4. LA = 2LB => LB = LA - LB => LB = (n1 - n2) * R；\r\n5, 由3,4可推出R = S + L， 故慢针再走L步就能抵达环入口\r\n6. 因为不确定L的长度，所以将快针重置到起始点，并且速度与慢针相同，这样两针相遇点即是环入口\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  let quick = head, slow = head;\r\n\r\n  while (quick && slow) {\r\n    quick = quick.next\r\n    if (!quick) return null\r\n    quick && (quick = quick.next)\r\n    slow = slow.next\r\n    if (quick === slow) {\r\n      quick = head\r\n      while (quick !== slow) {\r\n        quick = quick.next\r\n        slow = slow.next\r\n      }\r\n      return slow\r\n    }\r\n  }\r\n  return null\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(n) \r\n空间复杂度：O(1)","onTime":false},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101340370","body":"## 思路\ndfs + hashmap，dfs先将同列的节点放到一个数组，数组再按同行从小到大排\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n  if (!root) return []\n  const collection = {}\n\n  function dfs(node, row = 0, col = 0) {\n    if (!node) return\n\n    if (!collection[col]) {\n      collection[col] = [[row, node.val]]\n    } else {\n      collection[col].push([row, node.val])\n    }\n    \n    dfs(node.left, row + 1, col - 1)\n    dfs(node.right, row + 1, col + 1)\n  }\n\n  dfs(root)\n\n  let sorted =  Object.keys(collection).sort((a, b) => +a - +b).map(o => collection[o])\n\n  sorted = sorted.map(rows => {\n    return rows.sort((a, b) => {\n      if (a[0] === b[0]) {\n        return a[1] - b[1]\n      } else {\n        return +a[0] - +b[0]\n      }\n    }).map(o => o[1])\n  })\n\n  return sorted\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点个数。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1102648030","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const hash = new Map()\n    for (let i = 0; i < nums.length; i++) {\n        if (hash.has(target - nums[i])) {\n            return [hash.get(target - nums[i]), i]\n        }\n        hash.set(nums[i], i)\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107415970","body":"## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {string[]} words\r\n * @return {number[]}\r\n */\r\nvar findSubstring = function(s, words) {\r\n    let map = new Map()\r\n    words.forEach(o => map.set(o, (map.get(o) || 0) + 1))\r\n    const n = words.length\r\n    const len = words[0].length\r\n    const res = []\r\n\r\n    for (let i = 0; i <= s.length - n * len; i++) {\r\n        let subMap = {}\r\n        let num = 0\r\n        while (num < n) {\r\n            let cur = s.substr(i + num * len, len)\r\n            if (!map.has(cur) || subMap[cur] === map.get(cur)) break\r\n            subMap[cur] = (subMap[cur] || 0) + 1\r\n            num++\r\n        }\r\n        if (num === n) {\r\n            res.push(i)\r\n        }   \r\n    }\r\n    return res\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n+len)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112228720","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar maxSlidingWindow = function(nums, k) {\n    var left = 0\n    var res = []\n    for (var i = 0; i + k <= nums.length; i++) {\n        findMaxNum(nums, left, k)\n        left++\n    }\n    return res\n    \n    function findMaxNum(list, start, length) {\n        var max =  -Infinity;\n        for (var i = start; i < start + length; i++) {\n            max = Math.max( list[i] , max)\n        }\n        res.push(max)\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nealchristmas":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090304858","body":"```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    let currMax = arr[0]\r\n    const stack = [currMax]\r\n    for (let i = 1; i < arr.length; i++) {\r\n        if (arr[i] >= stack[stack.length - 1]) {\r\n            currMax = Math.max(currMax, arr[i])\r\n            stack.push(arr[i])\r\n\r\n        } else {\r\n            while (stack.length && arr[i] < stack[stack.length - 1]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(currMax)\r\n        }\r\n\r\n    }\r\n    return stack.length\r\n\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090880462","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        lenth = 1\n        pt = head\n        while pt.next != None:\n            pt = pt.next\n            lenth += 1\n        old_tail = pt\n        true_k = k % lenth\n        if true_k == 0: return head\n        num_to_move = lenth - true_k\n        cur = head\n        while num_to_move - 1:\n            cur = cur.next\n            num_to_move -= 1\n        new_tail = cur\n        new_head = cur.next\n        old_tail.next = head\n        new_tail.next = None\n        return new_head\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097684318","body":"```\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        '''\n        def dfs(node):\n            if not node:\n                return 0\n            return max(dfs(node.left), dfs(node.right)) + 1\n        \n        return dfs(root)\n        '''\n        if not root:\n            return 0\n        stack = []\n        max_depth = 0\n        stack.append([root, 1])\n        \n        while stack:\n            node, depth = stack.pop()\n            max_depth = max(max_depth, depth)\n            if node.left:\n                stack.append((node.left, depth + 1))\n            if node.right:\n                stack.append((node.right, depth + 1))\n            \n        return max_depth\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzq-666":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091735334","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        index = 0 \n        node = head\n        head = head\n        test = head\n        l = 0\n        if k == 0 or not head or not head.next:\n            return head\n        while test:\n            test = test.next\n            l += 1\n        k = k%l\n        while index <k:\n            flag  = node.next.next\n            if flag:\n                node = node.next\n                continue\n            else:\n                i = node.next\n                node.next = None\n                i.next = head\n                head = i\n                node  = head\n            index += 1\n        return head","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091817844","body":"### **思路**\n\n先计算链表的长度，记为cnt，k对链表长度取余是要旋转的次数，旋转几次，就是倒数第几个链表拆出来作为头，相当于找到要旋转断开的地方，拆成两个链表，把后面的链表拼到前面的链表上，后面链表指向头，前面链表指向None\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next:\n            cut += 1\n            if cut == cnt - k:\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n        return res if res else head\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1099239719","body":"### **思路：先序遍历+递归**\n\n前序地看每个节点是否相等，且输入是两个node\n\n（1）输入输出：输入是两个树的树节点，输出是节点是否相等\n\n（2）递归出口：如果有node是none，要么两个树相等的时候都是none，要么一个none一个不是none，前者是true后者是false\n\n（3）递归逻辑：要判断是否相等，要看当前节点相等，左节点相等、右节点相等\n\n### **代码**\n\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        def preorder(p_node, q_node):\n            # 先序地看p和q是否相等\n            if not p_node and not q_node:\n                return True\n            if not p_node or not q_node:\n                return False\n            cur_same = p_node.val == q_node.val\n            left_same = preorder(p_node.left, q_node.left)\n            right_same = preorder(p_node.right, q_node.right)\n            return cur_same and left_same and right_same\n        return preorder(p, q)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)每个节点遍历一次\n- 空间复杂度：O(h)递归栈大小是树的深度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weihaoxie":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091852920","body":"## 解题思路：\n先将链表连接成循环链表，并计算链表长度，然后将头指针往前移动链表长度-k%链表长度\n## 复杂度\n时间复杂度为O(N)\n## 实现\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        curNode = head\n        count = 1\n        while(curNode.next is not None):\n            curNode = curNode.next\n            count+=1\n        curNode.next = head\n        headNode = head\n        curNode = head\n        i = 0\n        while(i<count-k%count):\n            preNode = curNode\n            curNode = curNode.next\n            i+=1\n        preNode.next = None\n        return curNode\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092323168","body":"## 思路\n1. 按照朴素的思路，交换两个节点后连接回原来链表\n2. 按照该方式交换后续的节点\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        new_head = head.next\n        curNode = head\n        nextNode = new_head.next\n        curNode.next = nextNode\n        new_head.next = curNode\n        head = new_head\n\n        while( nextNode is not None and nextNode.next is not None):\n            new_head = nextNode.next\n            curNode.next = new_head\n            curNode = nextNode\n            nextNode = new_head.next\n            curNode.next = nextNode\n            new_head.next = curNode\n  \n        return head\n```\n## 复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094069157","body":"## 思路\n1. 用快慢指针找到中间节点\n2. 递归左右两部分\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getRootNode(self,head,tail):\n        if head is None :\n            return None\n        if head.next is None:\n            return TreeNode(head.val)\n        if head == tail:\n            return TreeNode(head.val)\n        premid = head\n        mid = head.next\n        if mid == tail:\n            t =tail\n        else:\n            t = mid.next\n        while(t != tail and t.next!=tail):\n            t = t.next.next\n            premid = mid\n            mid = mid.next\n        if mid == tail:\n            aftermid = None\n        else:\n            aftermid = mid.next\n        return TreeNode(mid.val,self.getRootNode(head,premid),self.getRootNode(aftermid,tail))\n        \n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            return TreeNode(head.val)\n        premid = head\n        mid = head.next\n        tail = mid.next\n        aftermid = tail\n        while(tail is not None and tail.next is not None):\n            tail = tail.next.next\n            premid = mid\n            mid = mid.next\n                \n        aftermid = mid.next\n        return TreeNode(mid.val,self.getRootNode(head,premid),self.getRootNode(aftermid,tail))\n```\n## 复杂度\n时间复杂度为O(nlogn)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094169477","body":"## 思路\n- 遍历链表将节点放到两个list中\n- 从后到前比对list中的节点\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        lista = []\n        listb = []\n        cur1 = headA\n        cur2 = headB\n        while(cur1 is not None):\n            lista.append(cur1)\n            cur1=cur1.next\n        while(cur2 is not None):\n            listb.append(cur2)\n            cur2=cur2.next\n        rhead = None\n        for i in range(min(len(lista),len(listb))):\n            if lista[len(lista)-1-i] == listb[len(listb)-1-i]:\n                rhead = lista[len(lista)-1-i]\n        return rhead\n```\n## 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094510867","body":"### 思路\n1. 先用快慢指针判断是否存在环\n2. 判断环的起点（假设head到环的起点距离为a，环的起点到相遇点为b，相遇点到环的起点为c，则有2a+2b=a+b+c+b，那么a=c，将其中一个指针放到head每次走一步相遇时的节点就是入口）\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = head\n        fast = head\n        while(fast is not None and fast.next is not None):\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                fast = head\n                while(fast!=slow):\n                    fast = fast.next\n                    slow = slow.next\n                return slow\n        return None\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1096767918","body":"### 思路\n采用哈希表加双向链表结构\n注意：构建伪头尾节点写代码的时候可以简化很多；需要调整的指针总共有6个，这里很容易漏掉出错\n### 代码\n```python\nclass NodeList(object):\n    def __init__(self,val=0,key=0,pre=None,next=None):\n        self.val = val\n        self.key = key\n        self.pre = pre\n        self.next = next\nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = dict()\n        self.head = NodeList()\n        self.tail = NodeList()\n        self.head.next = self.tail\n        self.tail.pre = self.head\n        self.size = 0\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        \n        if key in self.cache:\n            self.cache[key].pre.next = self.cache[key].next\n            self.cache[key].next.pre = self.cache[key].pre\n            self.cache[key].next = self.head.next\n            self.cache[key].pre = self.head\n            self.head.next.pre = self.cache[key]\n            self.head.next = self.cache[key]\n            return self.cache[key].val\n        else:\n            return -1\n        \n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if key in self.cache:\n            self.cache[key].val = value\n            self.cache[key].pre.next = self.cache[key].next\n            self.cache[key].next.pre = self.cache[key].pre\n            self.cache[key].next = self.head.next\n            self.cache[key].pre = self.head\n            self.head.next.pre = self.cache[key]\n            self.head.next = self.cache[key]\n\n        else:\n            \n            if self.size < self.capacity:\n                \n                curNode = NodeList(value,key)\n                self.cache[key] = curNode\n                curNode.next = self.head.next\n                curNode.pre = self.head\n                self.head.next.pre = curNode\n                self.head.next = curNode\n                self.size+=1\n             \n            else:\n                print(self.size)\n                print(self.tail.pre.key)\n                del self.cache[self.tail.pre.key]\n                self.cache[key] = self.tail.pre\n                self.tail.pre.val = value\n                self.tail.pre.key = key\n                curNode = self.tail.pre\n                \n                if self.capacity > 1:\n                    curNode.pre.next = curNode.next\n                    curNode.next.pre = curNode.pre\n                    curNode.next = self.head.next\n                    curNode.pre = self.head\n                    self.head.next.pre = curNode\n                    self.head.next = curNode\n```\n### 复杂度\n- 时间复杂度O(1)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097618284","body":"### 思路\n1. 如果当前节点为空则返回0\n2. 返回当前节点的左子树和右子树层两者的最大深度+1\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        else:\n            return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(深度)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098583070","body":"### 思路\n1. 采用深度优先搜索，判断当前节点是否一致，不一致则返回False，如果两个节点都为空则返回True\n2. 遍历左右子树，都返回True时，最终结果返回True，其它情况返回False\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n\n        if p is None and q is None:\n            return True\n        if p is None and q is not None:\n            return False\n        if p is not None and q is None:\n            return False\n        if p.val != q.val:\n            return False\n        \n        if self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right):\n            return True\n        else:\n            return False\n```\n### 复杂度\n- 时间复杂度O(节点数)\n- 空间复杂度O(深度)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1100674440","body":"### 思路\n1. 用两个变量记录当前遍历的最大层数，以及该层的第一个非空节点的值\n2. 采用DFS进行递归遍历\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def __init__(self):\n        self.maxdepth = -1\n        self.left = None\n    \n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.getBottomLeftValue(root,0)\n        return self.left\n    def getBottomLeftValue(self,root,depth):\n        if root is None:\n            return\n        if depth > self.maxdepth:\n            self.left = root.val\n            self.maxdepth+=1\n        self.getBottomLeftValue(root.left,depth+1)\n        self.getBottomLeftValue(root.right,depth+1)\n```\n### 复杂度\n- 时间复杂度为节点数O(n)\n- 空间复杂度为树的深度O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1100829777","body":"### 思路\n1.先序遍历将树结构转换成str\n2.利用队列结构，拿出队列的第一个数据，当数据为非空时，构建父节点，然后利用剩下的构建左子树，再构建右子树，当数据为空时返回空，递归该过程\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\nimport Queue\nclass Codec:\n    \n    def DFS(self,root,result):\n        if root is None:\n            result += \"|null\"\n            return result\n        if root is not None:\n            result+=\"|\"+str(root.val)\n            result = self.DFS(root.left,result)\n            result = self.DFS(root.right,result)\n        return result\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        result = self.DFS(root,result)\n        return result\n\n    def getTree(self,q):\n        val = q.get()\n        print(val)\n        if val == \"null\":\n            return None\n        node = TreeNode(int(val))\n        node.left = self.getTree(q)\n        node.right = self.getTree(q)\n        return node\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        l=data.split(\"|\")[1:]\n        q = Queue.Queue()\n        for i in l:\n            q.put(i)\n        return self.getTree(q)\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```\n### 复杂度\n- 时间复杂度为O(n)\n- 空间复杂度为O(h)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101346334","body":"### 思路\n1. 用dfs+hashmap,dfs将同列的放到一个数据里面，同列且同行的按照值从小到大排列\n2. 按照列数构建返回列表，根据列值顺序将结果放到返回列表中\n### 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getLocate(self,root,locate,row,col):\n        if root is not None:\n            if col in locate:\n                flag = False\n                for i in range(len(locate[col])):\n                    if row < locate[col][i][1]:\n                        locate[col].insert(i,(root.val,row))\n                        flag = True\n                        break\n                    elif row == locate[col][i][1]:\n                        if root.val < locate[col][i][0]:\n                            locate[col].insert(i,(root.val,row))\n                            flag = True\n                            break\n                if flag== False:\n                    locate[col].append((root.val,row))\n            else:\n                locate[col] = [(root.val,row)]\n            self.getLocate(root.left,locate,row+1,col-1)\n            self.getLocate(root.right,locate,row+1,col+1)\n\n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        locate = {}\n        self.getLocate(root,locate,0,0)\n        if len(locate) == 0:\n            return []\n        min_col = 0\n        max_col = 0\n        temp = {}\n        for item in locate:\n            if min_col > item:\n                min_col = item\n            if max_col < item:\n                max_col = item\n            \n        result = [[] for i in range(min_col,max_col+1)]\n        for item in locate:\n            j = item - min_col\n            for data in locate[item]:\n                result[j].append(data[0])\n        return result\n```\n### 复杂度\n- 时间复杂度O(nlogn)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101942781","body":"### 思路\n使用哈希表记录，key为值，value为下标\n### 代码\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        temp = {}\n        for i in range(len(nums)):\n            if target - nums[i] in temp:\n                return [temp[target - nums[i]],i]\n            temp[nums[i]] = i\n        return []\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103833806","body":"### 思路\n1. 用哈希表存储每个数值及其出现的个数\n2. 对出现次数进行排序，取前k个\n### 代码\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        d = dict()\n        for n in nums:\n            if n in d:\n                d[n]+=1\n            else:\n                d[n] = 1\n        new_d = sorted(d.items(),key=lambda x:x[1],reverse=True)\n        return [item[0] for item in new_d[:k]]\n```\n### 复杂度\n- 时间复杂度O(nlogn)\n- 空间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1105225131","body":"### 思路\n哈希表+排列组合\n### 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        all_count = 0\n        for p in points:\n            dist_2_count = {}\n            for b in points:\n                dist  = (p[0]-b[0])*(p[0]-b[0])+(p[1]-b[1])*(p[1]-b[1])\n                if dist in dist_2_count:\n                    dist_2_count[dist] += 1\n                else:\n                    dist_2_count[dist] = 1\n            for item in dist_2_count:\n                all_count += dist_2_count[item]*(dist_2_count[item]-1)\n        return all_count\n```\n### 复杂度\n- 时间复杂度O(n^2)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106550035","body":"### 思路\n1. 哈希表记录当前不重复片段的值，双指针记录当前判断的位置\n2.当当前值在哈希表中时，移动左指针至当前不重复片段，当不在哈希表中时，将当前值加入哈希表，判断当前长度是否为最大长度，更新最大长度值\n### 代码\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        i = 0\n        count = 0\n        temp = set()\n        for j in range(len(s)):\n            if i != j and s[j] in temp:\n                for k in range(i,j):\n                    if s[k]==s[j]:\n                        i=k+1\n                        break\n                    else:\n                        temp.remove(s[k])\n            else:\n                temp.add(s[j])\n            if j-i+1 > count:\n                count = j-i+1\n        return count\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108559228","body":"### 思路\n快慢指针\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        first = head\n        second = head\n        while(first is not None):\n            first = first.next\n            if first is not None:\n                first = first.next\n                second = second.next\n        return second\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109164958","body":"### 思路\n双指针\n### 代码\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) ==1:\n            return 1\n        if len(nums) == 0:\n            return 0\n        first = 0\n        for second in range(1,len(nums)):\n            if nums[first] != nums[second]:\n                first += 1\n                nums[first] = nums[second]\n        return first+1\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110376374","body":"### 思路\n双指针+二分查找\n### 代码\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        begin = 0\n        end = len(nums)-1\n        while begin < end:\n            if nums[int((end+begin)/2)] > target:\n                end = int((end+begin)/2) - 1\n            elif nums[int((end+begin)/2)] < target:\n                begin = int((end+begin)/2) + 1\n            else:\n                return int((end+begin)/2)\n        if target > nums[begin]:\n            return begin + 1\n        else:\n            return begin\n```\n### 复杂度\n- 时间复杂度O(logn)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112361504","body":"### 思路\n- 通过双端队列保存索引，并让对应的值递减\n- 每次滑动一个位置的时候，判断该位置是否大于前面的值是的话删掉前面的值\n- 每次滑动一个位置的时候，判断队列中是否有某些值超过了滑动窗口，是的话删掉滑动窗口外的值\n### 代码\n```python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = collections.deque() \n        ans = []\n        for i in range(len(nums)):\n            while q and nums[q[-1]] <= nums[i]: \n                q.pop() \n            while q and i - q[0] >= k: \n                q.popleft() \n            q.append(i)\n            if i >= k - 1: \n                ans.append(nums[q[0]])\n        return ans\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113426803","body":"### 思路\n将问题抽象成图结构，最终的目标变成找到出度为0，入度为n-1的节点\n### 代码\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        indegree = [0] * n\n        outdegree = [0] * n\n        for item in trust:\n            outdegree[item[0]-1] += 1\n            indegree[item[1]-1] += 1\n        for i in range(n):\n            if outdegree[i] == 0 and indegree[i] == n-1:\n                return i+1 \n        return -1\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1094274584","body":"### 题目\r\n[LC 989 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n### 思路一\r\n    每位数乘1,10,100\r\n    sum求和\r\n    转str型，for遍历\r\n\r\n### 代码一\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        val = 0\r\n        n = len(num)\r\n        for i in range(n):\r\n            val += num[i]*(10**(n-1-i))\r\n        val = str(val+k)\r\n\r\n        return [int(val[i]) for i in range(len(val))]\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n### 思路二\r\n    进位相加（数学竖式），对应位相加，满10进一位\r\n    取每一位数 取最后一位数k%10; 逐一往前取k//10\r\n    利用//取商；%取余数\r\n    需要考虑 K 位数比 num多的情况\r\n\r\n### 代码二\r\n```python\r\ndef addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n\r\n        ans = []\r\n        for i in range(len(num)-1,-1,-1):\r\n            val = num[i] + k % 10\r\n            k = k//10 # 个十百千，往前挪\r\n            if val >= 10:\r\n                ans.append(val%10)\r\n                k += 1 # 进了一位\r\n            else:\r\n                ans.append(val)\r\n\r\n        while k>0:\r\n            ans.append(k%10)\r\n            k = k//10\r\n\r\n        return ans[::-1] #逆序\r\n\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度O(n)\r\n    空间复杂度O(1)\r\n\r\n### 总结\r\n[加法模板](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/)\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1094285753","body":"### 题目\r\n[LC821字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n### 思路一\r\n1. 遍历一次把所有c的index找出来存成一个list\r\n2. s中的每一个与c_list 求绝对值，取最小\r\n\r\n### 复杂度一\r\n    时间复杂度 O(N2)\r\n    空间复杂度 O(1)\r\n\r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        c_ls = []\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                c_ls.append(i)\r\n\r\n        ans = []\r\n        for i, val in enumerate(s):\r\n            tmp = []\r\n            for j in c_ls:\r\n                tmp.append(abs(j-i))\r\n            ans.append(min(tmp))\r\n\r\n        return ans\r\n```\r\n\r\n\r\n### 思路二\r\n1. 绝对值 --> 双指针，左右遍历\r\n2. 大小比较时先设定inf\r\n3. 左右遍历时记得顺序\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = []\r\n        tar = float('-inf')\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                tar = i\r\n            left.append(i - tar)\r\n        \r\n        right = []\r\n        tar = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                tar = i\r\n            right.append(min(tar - i, left[i]))\r\n\r\n        return right[::-1]\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1094465154","body":"### 题目\r\n[LC1381设计栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n### 思路\r\n按要求操作\r\n\r\n### 代码\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.stack[-1]\r\n            del self.stack[-1]\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > len(self.stack):\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]+=val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 push O(1), pop O(1), increment O(maxSize)\r\n    空间复杂度 O(maxSize)\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1094554408","body":"### 题目\r\n[LC394字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n### 思路一\r\n    括号匹配\r\n    入栈，遇到右括号出栈，记录str，左侧加value，直到遇到左括号\r\n    重复数字n次，入栈\r\n    所有数据出栈合并\r\n    ------------\r\n    错误点，数字不仅是10以内的数\r\n    \r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                tmp = ''\r\n                while stack[-1] != '[':\r\n                    tmp = stack[-1] + tmp\r\n                    stack.pop()\r\n\r\n                stack.pop() # 去掉 [\r\n                # 获取数字\r\n                repeat,e = 0,0\r\n                while len(stack)>0 and stack[-1].isdigit():\r\n                    repeat += int(stack[-1]) * (10**e)\r\n                    e += 1\r\n                    stack.pop() # 去掉数字\r\n                stack.append(repeat*tmp)\r\n            else:\r\n                stack.append(s[i])\r\n\r\n        ans = ''\r\n        for v in stack:\r\n            ans += v\r\n        \r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)\r\n\r\n\r\n### 思路二\r\n    逆波兰式，字母一个栈，数字一个栈\r\n    巧妙点：上一个str和下一个要重复次数的数字，存成一个数组\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        num = 0\r\n        string = ''\r\n        stack = []\r\n        for i in s:\r\n            if i.isdigit():\r\n                num = num*10 + int(i)                                \r\n            elif i == '[':\r\n                stack.append((string, num))\r\n                string = ''\r\n                num = 0\r\n            elif i == ']':\r\n                pre, k = stack.pop()\r\n                string = pre + k * string\r\n            elif i.isalpha():\r\n                string += i\r\n        return string\r\n\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1094566829","body":"\r\n### 题目\r\n[LC23 队](https://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/)\r\n\r\n### 代码\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.queue.append(x)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        top = self.queue[0]\r\n        del self.queue[0]\r\n        return top\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.queue[0]\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.queue)==0\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1097524837","body":"### 题目\r\n[LC768 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n### 思路\r\n    当前数值比后面的都大就不能分块\r\n    栈中留下排序块的最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        stack = []\r\n        for i in range(len(arr)):\r\n            if stack and arr[i]<stack[-1]:\r\n                head = stack.pop() # 最后一位是最大值\r\n                while stack and arr[i]<stack[-1]: # 为了跟前面的值对比，排序\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1098951405","body":"### 题目\r\n[LC61 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n### 思路\r\n    穿针引线，双指针，找到关键节点abcd\r\n    头节点a，遍历直到遇到倒数第二个节点b和最后一个节点c\r\n    b.next = None\r\n    c.next = a\r\n    k -= 1\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n\r\n        def rotateRight(self, head, k):\r\n            \"\"\"\r\n            :type head: ListNode\r\n            :type k: int\r\n            :rtype: ListNode\r\n            \"\"\"\r\n            #首先考虑边界，特殊情况\r\n            if k == 0 or not head or not head.next:\r\n                return head\r\n            \r\n            n = 1\r\n            cur = head\r\n\r\n            while cur.next:\r\n                cur = cur.next # 这里cur更新后，head不会更新，因为cur被重新赋值了，如果cur.next=xxx，那么head.next也会变化\r\n                n += 1\r\n            \r\n            add = n - k % n # 断开的位置\r\n            if add == n:\r\n                return head\r\n            \r\n            cur.next = head # 连接闭环\r\n            while add:\r\n                print(add)\r\n                cur = cur.next\r\n                add -= 1\r\n            \r\n            ret = cur.next\r\n            cur.next = None\r\n            return ret\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n) 最多遍历两次链表\r\n    空间复杂度 O(1)\r\n\r\n\r\n\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1099157893","body":"### 题目\r\n[LC24 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n### 思路\r\n    虚拟头节点，减少边界的考虑。模拟+递归\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n\r\n        if head is None or head.next is None:\r\n            return head \r\n\r\n        # head = ListNode(-1,head) # 添加虚拟节点 也work，但是尽量不要更改原始链表\r\n        # tmp = head\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        tmp = dummyHead\r\n        \r\n        while tmp.next and tmp.next.next:\r\n            node1 = tmp.next\r\n            node2 = tmp.next.next\r\n            tmp.next = node2\r\n            node1.next = node2.next\r\n        return dummyHead.next\r\n\r\n    # 递归\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 迭代O(1) 递归O(n)\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1100820463","body":"### 题目\r\n[LC109 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n### 思路\r\n    首先通过快两步慢一步针的方式找到中点\r\n    递归的方式，根节点等于中点，左节点等于左子树中点，右节点等于右子树中点\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: Optional[ListNode]\r\n        :rtype: Optional[TreeNode]\r\n        \"\"\"\r\n        \r\n        def getMid(left, right):\r\n            fast = slow = left # initial 先都从左侧第一个开始\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next # 错误点，指针移动需用用自身，left.next一直是同一个，没有动\r\n                slow = slow.next\r\n            return slow\r\n\r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMid(left,right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n\r\n        return buildTree(head, None)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(nlogn)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094242148","body":"### 代码\r\n```python\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        cur = headA\r\n        visited = {}\r\n        while cur:\r\n            visited[id(cur)] = cur\r\n            cur = cur.next\r\n        \r\n        cur = headB\r\n        while cur:\r\n            if id(cur) in visited:\r\n                return visited[id(cur)]\r\n            cur = cur.next\r\n        return None\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1100837407","body":"### 题目\r\n[LC143 环形链表II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n### 思路一\r\n    哈希表，逐一放入元素，如果出现过了，return\r\n\r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        tmp_dict = {}\r\n        if head is None:\r\n            return None\r\n\r\n        while head:\r\n            if head not in tmp_dict:\r\n                tmp_dict[head] = head.val\r\n                head = head.next\r\n            else:\r\n                return head\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n\r\n### 思路二\r\n    快慢指针，快2慢1，环内相遇后，快回到头也1，两者再相遇，即为入还口\r\n    2(l+c) = l+2c+d --> l=d\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n\r\n        if head is None:\r\n            return None\r\n\r\n        slow = fast = head\r\n\r\n        while fast != None and fast.next != None:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n\r\n            if fast == slow:\r\n                fast = head\r\n                while fast != slow:\r\n                    fast = fast.next\r\n                    slow = slow.next\r\n                return slow\r\n        return None\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(1)\r\n\r\n\r\n\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1100846564","body":"### 题目\r\n[LC146 LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n### 思路\r\n    查询便捷：哈希表\r\n    有序的增删O(1)：链表，最新的在表头\r\n    如果需要链表、树等特殊的数据结构，要自己在class中写\r\n\r\n### 代码\r\n```python\r\nclass DLinkedNode(object):\r\n    def __init__(self,key=0,val=0):\r\n        self.key = key\r\n        self.val = val\r\n        self.pre = None\r\n        self.next = None\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = dict()\r\n        self.head  = DLinkedNode()\r\n        self.tail = DLinkedNode() # head, tail 都是虚拟节点，防止溢出\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node) # get了之后，当前的node就是最新的cache\r\n        return node.val\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.val = value\r\n            self.moveToHead(node)\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def addToHead(self, node):\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node # 这里的顺序尤其重要，如果颠倒，head.next就已经被改变了\r\n        self.head.next = node\r\n\r\n    def removeNode(self, node):\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n\r\n    def removeTail(self):\r\n        node = self.tail.pre\r\n        self.removeNode(node)\r\n        return node\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(1)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1102789273","body":"\"\"\"\r\n### 题目\r\n[LC104 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\r\n\r\n\r\n### 思路\r\n    DFS: 递归，节点为null结束递归\r\n    BFS: 迭代的方式，层次遍历，队列，错误点pop(0)才能模拟先进后出\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        # 递归\r\n        # if root is None:\r\n        #     return 0\r\n\r\n        # left_max = self.maxDepth(root.left)\r\n        # right_max = self.maxDepth(root.right)\r\n\r\n        # return max(left_max, right_max)+1\r\n\r\n        # 迭代\r\n        if root is None:\r\n            return 0\r\n\r\n        queue = [root]\r\n        height = 0\r\n\r\n        while queue:\r\n            for n in range(len(queue)):\r\n                node = queue.pop(0) # remove first value. 队列 先进先出\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n            height += 1\r\n\r\n        return height\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 递归O(hieght) 迭代 O(n)\r\n\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098594016","body":"### 思路：\r\n    深度优先+递归\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(min(m,n))\r\n    空间复杂度 O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/17#issuecomment-1103449018","body":"### 题目\r\n[LC129 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)\r\n\r\n### 思路一\r\n    根节点到叶子节点贯通\r\n    DFS，递归\r\n    1）终止条件：没有左右节点的时候返回，返回什么？返回根到叶子的数值。不是所有的递归终止条件返回的都是0或者null，要根据题意\r\n    2）返回值：已经处理好的父节点，没有左右节点后再求之和\r\n    3）本层要做的事情：前一个节点*10 + 本节点\r\n    什么时候需要helper()？\r\n    原始function输入的参数，无法满足需求。\r\n\r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def sumNumbers(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        # 这里代码的问题在于没循环起来，递归要自己调用自己\r\n        # def getRight(node):\r\n        #     if not node.right:\r\n        #         return 0\r\n        #     return 10*node + node.right       \r\n\r\n        # DFS\r\n        def helper(root, pre_ttl):\r\n            if not root:\r\n                return 0\r\n            ttl = pre_ttl*10 + root.val\r\n            if not root.left and not root.right:\r\n                return ttl\r\n            else:\r\n                return helper(root.left,ttl) + helper(root.right,ttl) # 不用担心左节点或者右节点没有，因为第一步会判断，return 0\r\n\r\n        return helper(root,0)\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n### 思路二\r\n    根节点到叶子节点贯通\r\n    迭代\r\n    先求出每个数，装到list里，一起求和\r\n    or\r\n    先求出每个数，走到叶子节点得到数之后+=\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def sumNumbers(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        # BFS\r\n        if not root:\r\n             return 0\r\n        \r\n        ans = 0\r\n        queue = [root]\r\n        nums = [root.val]\r\n\r\n        while queue:\r\n            node = queue.pop(0)\r\n            val = nums.pop(0)\r\n\r\n            if not node.left and not node.right:\r\n                ans += val\r\n            else:\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                    nums.append(val*10 + node.left.val)\r\n                if node.right: # 不能写elif，因为那样的话，如果有left，right就不执行了，left和right需要独立判断\r\n                    queue.append(node.right)\r\n                    nums.append(val*10 + node.right.val)\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/18#issuecomment-1107475627","body":"\"\"\"\r\n### 题目\r\n[LC513 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)\r\n\r\n### 思路\r\n    BFS 层次遍历，找到最下面一层就是要返回的值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def findBottomLeftValue(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        ans = root.val\r\n        queue = [root]\r\n\r\n        while queue:\r\n            ans = queue[0].val\r\n            for _ in range(len(queue)):\r\n                node = queue.pop(0)\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n        return ans\r\n\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\"\"\"\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/20#issuecomment-1107685476","body":"### 题目\r\n[LC297 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\r\n\r\n### 思路\r\n    \r\n\r\n### 代码\r\n```python\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if root is None:\r\n            return \"None\"\r\n        \r\n        left = self.serialize(root.left)\r\n        right = self.serialize(root.right)\r\n        return \"{},{},{}\".format(str(root.val),left,right)\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        def helper(nums):\r\n            num = nums.pop(0) # 从头pop\r\n            if num == \"None\":\r\n                return None\r\n            node = TreeNode(num)\r\n            node.left = helper(nums)\r\n            node.right = helper(nums)\r\n            return node \r\n        \r\n        values = data.split(',')\r\n        return helper(values)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1101910164","body":"### 题目\r\n[LC1 两数之和](https://leetcode-cn.com/problems/two-sum/)\r\n\r\n### 思路\r\n    逐一遍历，时间复杂度有些高O(n2)\r\n    遍历当前值与目标值的差，寻找dict中是否有该值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def twoSum(self, nums, target):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type target: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n\r\n        ind_dict = {}\r\n        for i in range(len(nums)):\r\n            diff = target - nums[i]\r\n            if diff in ind_dict:\r\n                return [i,ind_dict[diff]]\r\n            if nums[i] not in ind_dict:\r\n                ind_dict[nums[i]] = i \r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103517242","body":"### 题目\r\n[LC347 前K个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\r\n\r\n### 思路\r\n    自动：python counter，order by nums，取前k个\r\n    手动：遍历，用dict手动计数；按照计数排序，取前k个，排序不可取，因为时间复杂度是O(nlogn)\r\n    设置一个大小为k的堆，放进k个最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def topKFrequent(self, nums, k):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n\r\n        dict_counter = {}\r\n        for num in nums:\r\n            if num in dict_counter:\r\n                dict_counter[num] += 1\r\n            else:\r\n                dict_counter[num] = 1\r\n\r\n        # dict_counter = {k: v for k, v in sorted(dict_counter.items(), key=lambda item: item[1], reverse=True)} # leetcode让函数失效了\r\n        # return dict_counter.keys()[:k]\r\n\r\n        heap = []\r\n        for key, val in dict_counter.items():\r\n            if len(heap) >= k:\r\n                if val > heap[0][0]:\r\n                    heapq.heapreplace(heap, (val, key))\r\n            else:\r\n                heapq.heappush(heap, (val, key))\r\n        return [item[1] for item in heap]\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(nlogk)\r\n    空间复杂度 O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107957408","body":"### 题目\r\n[LC876 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)\r\n\r\n### 思路\r\n    加头节点\r\n    快慢指针，一个走两步，一个走一步\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def middleNode(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n\r\n        fast = slow = dummyHead\r\n\r\n        while fast:\r\n            if not fast.next:\r\n                fast = None\r\n            else:\r\n                fast = fast.next.next\r\n            slow = slow.next \r\n\r\n        return slow\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(1)\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112820006","body":"\"\"\"python\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        inDegrees = Counter(y for _, y in trust)\r\n        outDegrees = Counter(x for x, _ in trust)\r\n        return next((i for i in range(1, n + 1) if inDegrees[i] == n - 1 and outDegrees[i] == 0), -1)\r\n\"\"\"","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qq-jiang":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094403221","body":"### 方法一：hash\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set<ListNode*> set;\n        ListNode* temp = headA; \n\n        while(temp != NULL){ //向hash表中插入\n            set.insert(temp);\n            temp = temp->next;\n        }\n\n        temp = headB;\n        while(temp != NULL){ //判断是否已经存在\n            if(set.count(temp)){\n                return temp;\n            }\n            temp = temp->next;\n        }\n        return NULL;\n    }\n};","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/15#issuecomment-1097882099","body":"### DFS\n```\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        int L = maxDepth(root->left);\n        int R = maxDepth(root->right);\n        return std::max(L, R) +1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/16#issuecomment-1098576225","body":"```\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q == nullptr){\n            return true;\n        }else if(p == nullptr || q == nullptr){\n            return false;\n        }else if(p->val != q->val){\n            return false;\n        }\n        if(!isSameTree(p->left, q->left))\n            return false;\n        if(!isSameTree(p->right, q->right))\n            return false;\n        return true;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pong991":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/21#issuecomment-1101440045","body":"思路\n\nDFS, 先序遍历，记录每个节点的row和col，存储到map中，map中col为key值，value为对象数组[{row: row, val: root.val}]。\n\n对map的key排序，遍历key获取map的值，将取出来的数组根据row和val的值排序（先比较row的大小，row相同再比较val），再将排序好的数组push到结果数组res中。\n\nmap: { 0：[ {row: row, val: root.val} ] }\n\n代码\nvar verticalTraversal = function(root) {\n  let map = new Map();\n  let keys = [], res = [];\n  let preOrder = function(root, row, col) {\n    if (!root) return;\n    if (map.has(col)) map.get(col).push({row: row, val: root.val});\n    else {\n      map.set(col, [{row: row, val: root.val}]);\n      keys.push(col);\n    }\n    preOrder(root.left, row + 1, col - 1);\n    preOrder(root.right, row + 1, col + 1);\n  };\n  preOrder(root, 0, 0);\n  keys.sort((a,b) => { return a - b; });\n  for (let i = 0; i < keys.length; i++) {\n    let arr = map.get(keys[i]);\n    arr.sort((a,b) => {\n      if (a.row === b.row) return a.val - b.val;\n      else return a.row - b.row;\n    });\n    res.push(arr.map(val => {return val.val}));\n  }\n  return res;\n};\n复杂度分析\ntime: O(nlogn)\nspace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/22#issuecomment-1104630246","body":"# Idea\r\n- 用HashMap储存数值(key)和对应的index(value)\r\n- 或有target-key的key存在，则可达成两数之和\r\n- 此时返回两数的value也就是indexes\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        // Map: Key => number Value => index\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n\r\n        for (int i=0; i<nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                return new int[] {map.get(target - nums[i]), i};\r\n            } else {\r\n                map.put(nums[i], i);\r\n            }\r\n        }\r\n\r\n        return new int[] {};\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n- Time complexity: O(1)\r\n- Space complexity: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/23#issuecomment-1103477483","body":"# Idea\n- 使用HashMap将number和frequency绑定\n- 通过PriorityQueue历变出frequency最高的#k_pairs\n- 返回result_array\n# Code\n```\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // Create Map to store values and frequency\n        Map <Integer, Integer> valFrequency = new HashMap<Integer, Integer>();\n        // Create keys and store values\n        for (int num: nums) {\n            valFrequency.put(num, valFrequency.getOrDefault(num, 0) + 1); // Store the frequency\n        }\n\n        // Use PriorityQueue to allocate highest K-frequency\n        // int[0] is the keyVal, int[1] is the frequencyVal\n        PriorityQueue<int[]> rank = new PriorityQueue<int[]>(new Comparator<int[]>(){\n            public int compare(int[] first, int[] second) {\n                return first[1] - second[1]; // Compare the frequency, high freq at the end\n            }\n        });\n\n        // Compare every key&Val entry in HashMap, keep the top Kth element in Queue\n        for (Map.Entry<Integer, Integer> entry : valFrequency.entrySet()) {\n            int number = entry.getKey();\n            int frequency = entry.getValue();\n\n            if (rank.size() == k) {\n                if (rank.peek()[1] < frequency) {\n                    rank.poll();\n                    rank.offer(new int[] {number, frequency}); // Replace with pair that has higher freq\n                }\n            } else {\n                rank.offer(new int[] {number, frequency});\n            }\n        }\n\n        // Now we have top Kth freq items in queue, we want to return it\n        int[] result = new int[k];\n        for (int i=0; i<result.length; i++) {\n            result[i] = rank.poll()[0];\n        } \n        return result;\n    }\n}\n```\n# Time & Space Complexity\n- Time Complexity: O(N*logK)\n- Space Complexity: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104341618","body":"# Idea\r\n- Iterate through all points and calculate all Euclidean distances about that point, then store the distances with their frequency into HashMap.\r\n- Calculate the combinations for all possible Boomerangs, \"distFreq C 2\", then sum them and return.\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int result = 0;\r\n        // Empty input \r\n        if (points == null || points.length <= 2) {\r\n            return 0;\r\n        }\r\n        // Create HashMap to store \r\n        Map<Integer, Integer> count = new HashMap<>();\r\n\r\n        // Iterate through all points, find and count the # of repeated distances\r\n        for (int i=0; i<points.length; i++) {\r\n            for (int j=0; j<points.length; j++) {\r\n                int distance = getDistance(points[i], points[j]);\r\n                count.put(distance, count.getOrDefault(distance, 0) + 1);\r\n            }\r\n\r\n            for (int countNum : count.values()) {\r\n                result += countNum*(countNum-1);\r\n            }\r\n            count.clear();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public int getDistance (int[] a, int[] b) {\r\n        int xdiff = a[0] - b[0];\r\n        int ydiff = a[1] - b[1];\r\n        int distance = 0;\r\n        distance = xdiff * xdiff + ydiff * ydiff;\r\n        return distance;\r\n    }\r\n}\r\n```\r\n# Time & Space Complexity\r\n- Time Complexity: O(n^2)  // n is the number of points\r\n- Space Complexity: O(n)  // HashMap memory space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105923974","body":"# Idea\n- 利用HashSet只包含unique项的特性，使用set来记录不重复字段的长度，并保持更新最大所得长度\n# Code\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // Use Hash Set: the set that only contains distinct elements\n        Set<Character> set = new HashSet<>();\n        int maxSize = 0;\n        int left = 0;\n\n        // Iterate through all characters of string and record the max unique length\n        for (int i = 0; i < s.length(); i++) {\n            if (!set.add(s.charAt(i))) {\n                maxSize = Math.max(maxSize, set.size());\n                // Empty the Hashset\n                while (s.charAt(left) != s.charAt(i)) {\n                    set.remove(s.charAt(left));\n                    left++;\n                }\n                left = left +1;\n            }\n        } \n        // 上面的算法只有遇到重复项才会更新maxSize，所以若input为全部unique时，maxSize将一直为0\n        // 结尾需要再判断一次\n        return Math.max(maxSize, set.size());\n    }\n}\n```\n# Time & Space Complexity\n- Time Complexity: O(N) -> 历变string的所有characters\n- Space Complexity: O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107355199","body":"# Idea\r\n- HashMap 记录目标words的string和频次，用于后续滑动窗口比对\r\n- string s 滑动窗口历变，判断是否可能由words组成\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        // Result is a list of int coordinates\r\n        List<Integer> result = new ArrayList<Integer>();\r\n\r\n        // Empty 情况\r\n        if (words == null || words[0].length() == 0) {\r\n            return result;\r\n        }\r\n\r\n        // 储存所查找word为key，value为出现次数\r\n        Map<String, Integer> wordsFreq = new HashMap<>();\r\n        for (String word : words) {\r\n            wordsFreq.put(word, wordsFreq.getOrDefault(word, 0) + 1);\r\n        }\r\n\r\n        // 思路：滑动窗口比较\r\n        int wordLength = words[0].length();\r\n        int wordListLength = words.length;\r\n        int targetLength = wordLength * wordListLength;\r\n        int stringLength = s.length();\r\n\r\n        // 历变全部可能的窗口\r\n        for (int i = 0; i < stringLength - targetLength + 1; i++) {\r\n            String cur = s.substring(i, i + targetLength);\r\n\r\n            int length = 0;\r\n            Map<String, Integer> wordsFreqTmp = new HashMap<>();\r\n            // 每一个窗口都去比较是否由目标words组成\r\n            for (int j = 0; j < cur.length(); j = j + wordLength) {\r\n                String part = cur.substring(j, j + wordLength);\r\n                // 不包含目标words的情况\r\n                if (!wordsFreq.containsKey(part)) {\r\n                    break;\r\n                }\r\n                wordsFreqTmp.put(part, wordsFreqTmp.getOrDefault(part, 0) + 1);\r\n                // 目标words过多情况\r\n                if (wordsFreqTmp.get(part) > wordsFreq.get(part)) {\r\n                    break;\r\n                }\r\n                length = length + wordLength;\r\n            }\r\n            // 若上面的标准都通过，则为由目标words组成的string，窗口有效\r\n            if (length == targetLength) {\r\n                result.add(i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```\r\n# Time and Space Complexity\r\n- Time complexity: O(N^2) -> Double for loop\r\n- Space complexity: O(N) -> HashMap\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107716584","body":"# Thought \r\n- Prefix Sum\r\n- Confluence Rule\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int subarraysDivByK(int[] A, int K) {\r\n        Map<Integer, Integer> reminderFreq = new HashMap<>();\r\n        \r\n        reminderFreq.put(0, 1);\r\n        \r\n        int count = 0;\r\n        int prefixSumModK = 0;\r\n        \r\n        for (int num : A) {\r\n            prefixSumModK = (prefixSumModK + num) % K;\r\n            if (prefixSumModK < 0) { prefixSumModK = prefixSumModK + K; }\r\n            \r\n            count += reminderFreq.getOrDefault(prefixSumModK, 0);\r\n            reminderFreq.put(prefixSumModK, reminderFreq.getOrDefault(prefixSumModK, 0) + 1);\r\n        }\r\n        \r\n        return count;\r\n    }\r\n}\r\n```\r\n# Time & Space Complexity\r\n- Time Complexity: O(N)\r\n- Space Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107914350","body":"# Idea\r\n- Two Pointers\r\n- Fast Pointer and Slow Pointer\r\n# Code\r\n```java\r\n\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        \r\n        ListNode fastPointer = new ListNode();\r\n        ListNode slowPointer = new ListNode();\r\n        \r\n        fastPointer = head; slowPointer = head;\r\n        \r\n        //  In Java, \"null\" can be assigned to any variable of a reference type \r\n        //  Null Pointer Exception occurs when you trying to use the contents of the variable when it's null\r\n        while (fastPointer != null && fastPointer.next != null) {\r\n            fastPointer = fastPointer.next.next;\r\n            slowPointer = slowPointer.next;\r\n        }\r\n        \r\n        return slowPointer;\r\n    }\r\n}\r\n```\r\n# Time & Space Complexity\r\n- Time Complexity: O(N) -> Iteration\r\n- Space Complexity: O(1) -> Only references\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1108895888","body":"# Thoughts\r\n- 双指针：Read and Write\r\n- HashMap查重，移动 write 指针\r\n# Code\r\n```java\r\nclass Solution {\r\n        public static int removeDuplicates(int[] nums) {\r\n            Map<Integer, Integer> map = new HashMap<>();\r\n            int read = 0;\r\n            int write = 0;\r\n            int mapSize = 0;\r\n\r\n            for (int n=0; n<nums.length; n++) {\r\n                read = n;\r\n                map.put(nums[read], map.getOrDefault(nums[read], 0) + 1);\r\n                \r\n                if (mapSize >= 1 && map.size() > mapSize) {\r\n                    write++;\r\n                    nums[write] = nums[n];\r\n                }\r\n\r\n                mapSize = map.size();\r\n            }\r\n\r\n            return write + 1;\r\n    }\r\n}\r\n```\r\n👇更好的方法：不用HashMap，用双指针特性\r\n```java\r\nclass Solution {\r\n    // 双指针：读指针➕写指针\r\n    public static int removeDuplicates(int[] nums) {\r\n        int read = 0;\r\n        int write = 0;\r\n\r\n        for (int n=0; n<nums.length; n++) {\r\n            if (nums[write] == nums[read]) {\r\n                read++;\r\n            } else {\r\n                // 读写指针所指元素不同时\r\n                write++;\r\n                nums[write] = nums[read];\r\n                read++;\r\n            }\r\n        }\r\n        return write + 1;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110010547","body":"# Idea\r\n- Binary Search\r\n- Left, Right, Middle Pointer\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int l = 0;\r\n        int r = nums.length - 1;\r\n        int mid = (l + r) / 2;\r\n\r\n        if (nums.length == 0) return -1;\r\n\r\n        if (target > nums[r]) {\r\n            return r + 1;\r\n        } else if (target < nums[l]) {\r\n            return l;\r\n        } else {\r\n            while (l < r) {\r\n                if (target > nums[mid]) {\r\n                    l = mid + 1;\r\n                    mid = (l + r) / 2;\r\n                } else if (target < nums[mid]) {\r\n                    r = mid;\r\n                    mid = (l + r) / 2;\r\n                } else {\r\n                    return mid;\r\n                }\r\n            }\r\n            return mid;\r\n        }\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time Complexity: O(log(n))\r\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111517297","body":"# Idea\r\n- 滑动窗口\r\n- 及时drop超出窗口的index\r\n- 及时drop小于当先值的index，只保留最大值\r\n- deque.peek()的值即为每个window最大值\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        // Edge case\r\n        if (nums == null || k <= 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        int n = nums.length;\r\n        int[] res = new int[n - k + 1];\r\n        int right = 0;\r\n        // Queue to store index of array\r\n        Deque<Integer> q = new ArrayDeque<>();\r\n\r\n        for (int i=0; i<n; i++) {\r\n            // If index out of window, remove it\r\n            if (!q.isEmpty() && q.peek() < i-k+1) {\r\n                q.poll();\r\n            }\r\n            // Only retain the max number within window\r\n            while (!q.isEmpty() && nums[q.peekLast()] < nums[i]) {\r\n                q.pollLast();\r\n            }\r\n            // Add current element\r\n            q.offer(i);\r\n            // Input res\r\n            if (i > k-2) {\r\n                res[right] = nums[q.peek()];\r\n                right++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time Complexity: O(N)\r\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112542121","body":"# Idea\r\n- Graph\r\n- Judge <-- In-degree - out-degree = n-1\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int findJudge(int n, int[][] trust) {\r\n        // Array that counts the \"in-degree - out-degree\" of each point\r\n        int[] count = new int[n+1];\r\n\r\n        // Iterate through the trust relationship and count the degree differences\r\n        for (int[] i : trust) {\r\n            count[i[0]]--;\r\n            count[i[1]]++;\r\n        }\r\n\r\n        // Return the index of judge, if have\r\n        for (int i=1; i<=n; i++) {\r\n            if (count[i] == n-1) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time Complexity: O(N)\r\n- Space Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113916191","body":"# Idea\r\n- Graph + DFS\r\n- 染色法\r\n# Code\r\n```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int N, int[][] dislikes) {\r\n        int[][] graph = new int[N][N];\r\n        for (int[] d : dislikes) {\r\n            graph[d[0] - 1][d[1] - 1] = 1;\r\n            graph[d[1] - 1][d[0] - 1] = 1;\r\n        }\r\n        int[] group = new int[N];\r\n        for (int i = 0; i < N; i++) {\r\n            if (group[i] == 0 && !dfs(graph, group, i, 1)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    private boolean dfs(int[][] graph, int[] group, int index, int g) {\r\n        group[index] = g;\r\n        for (int i = 0; i < graph.length; i++) {\r\n            if (graph[index][i] == 1) {\r\n                if (group[i] == g) {\r\n                    return false;\r\n                }\r\n                if (group[i] == 0 && !dfs(graph, group, i, -g)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time Complexity: O(V+E)\r\n- Space Complexity: O(V+E)\r\n- V: vertices, E: edges\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beikelan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104558081","body":"### Idea\n1. calculate distance.  for each point i, calculate the distance from i to j (all points except itself).\n2. get same distance using hashmap. key: the position of current point. value: distance\n3. get all possible combinations. order matters.\n### Code\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if(points == null || points.length < 3)return 0;\n        int res = 0;\n        for(int i = 0; i < points.length; i++) {\n           Map<Integer, Integer> map = new HashMap<>();\n           for(int j = 0; j < points.length; j++) {\n               if(i == j)continue;\n               int x = points[i][0] - points[j][0];\n               int y = points[i][1] - points[j][1];\n               int dis = x * x + y * y;\n               map.put(dis, map.getOrDefault(dis, 0) + 1);\n           }\n            for(int key : map.keySet()) {\n                int fre = map.get(key);\n                res += fre * (fre - 1);\n            } \n       }\n     return res;   \n    }\n}\n```\n### Complexity\ntime=O(N^2)\nspace=O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105961586","body":"### Idea\nSliding window + hash table\n1. sliding window. Keeping track of the max length of substring without repeating characters.\n2. hashtable. Storing the frequency of each character. \n\n### Code\n``` java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s == null)return 0;\n        int slow = 0;\n        int fast = 0;\n        int res = Integer.MIN_VALUE;\n        HashMap<Character, Integer> map = new HashMap<>();\n        for(fast = 0; fast < s.length(); fast++) {\n            //check the window\n            char ch = s.charAt(fast);\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\n            while(map.getOrDefault(ch, 0) > 1) {\n                char slowchar = s.charAt(slow);\n                map.put(slowchar, map.getOrDefault(slowchar, 0) - 1);\n                slow++;\n            }\n            res = Math.max(res, fast - slow + 1);\n        }\n        return res == Integer.MIN_VALUE ? 0 : res;\n    }\n}\n```\n\n### Complexity\ntime=o(n)\nspace=o(m, n) \nn is the length of string, m is the number of distinct character. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107542371","body":"### Idea\nHashMap + Sliding window\n1. two maps. one for word count in Words array, one for word count in current window. check the word and frequency in two maps.\n2. sliding window. traverse the string (word.length times)  expand or shrink the window by cuurent word count\n\n### Code\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        if (s == null || s.length() == 0 || words == null || words.length == 0) {\n            return res;\n        }\n        \n        int wordLen = words.length;\n        int unitLen = words[0].length();\n        //word count\n        Map<String, Integer> allWords = new HashMap<>();\n        for (String str : words) {\n            allWords.put(str, allWords.getOrDefault(str, 0) + 1);\n        }\n        \n        //tranverse all start points\n        for (int i = 0; i < unitLen; i++) {\n            //two pointer\n            int left = i, right = i;\n            Map<String, Integer> hasWords = new HashMap<>();\n            int count = 0;\n            while(right <= s.length() - unitLen) {\n                String cur = s.substring(right, right + unitLen);\n                right += unitLen;\n                hasWords.put(cur, hasWords.getOrDefault(cur, 0) + 1);\n                if(allWords.containsKey(cur)) {\n                    count++;\n                    while (allWords.get(cur) < hasWords.get(cur)) {\n                        //shrink window\n                        String remove = s.substring(left, left + unitLen);\n                        hasWords.put(remove, hasWords.get(remove) - 1);\n                        count--;\n                        left += unitLen;\n                    }\n                } else {   \n                    //clear map/ start a new window/reset left pointer and count\n                    hasWords.clear();\n                    left = right;\n                    count = 0;\n                }\n                //check result every time\n                if(count == wordLen) {\n                    res.add(left);\n                }\n            }\n       \n        }\n        return res;\n    }\n}\n```\n\n###\nComplexity\ntime=o(n*m) space=o(m)\n###","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108129408","body":"### Idea\ntwo pointers\nslow one step ; fast two steps\n### Code\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n### complextiy\ntime=o(n) space=o(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110089949","body":"### Idea\nBinary Search\n\n### Code\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = (right - left) / 2 + left;\n            if (nums[mid] == target) return mid;\n            if (nums[mid] > target) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n### Complexity\ntime=o(logn) space=o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/24#issuecomment-1104714863","body":"**思路**\n1、三层循环优化为两层；\n2、哈希表的一个作用是空间换时间；\n3、统计以i为目标节点，其他节点与目标节点的距离，对不同距离的节点个数计数，比如距离为3的节点个数有n个，那么i为第一个节点，距离为3的组合下，第二个节点j有n种可能，第三个节点k有n-1种可能，整个距离为3的组合有n*(n-1)种可能。\n\n**代码**\n```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ## 排列组合 \n        n = len(points)\n        count = 0 \n        for i in range(n):\n            ## 计算与i的不同距离的个数\n            dic = collections.defaultdict(int)\n            for j in range(n): ##注意范围\n                dist = math.pow((points[i][0]-points[j][0]), 2) + math.pow((points[i][1]-points[j][1]), 2)\n                dic[dist] += 1 \n            for k,v in dic.items():\n                count += v*(v-1)\n        return count \n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1105936496","body":"**思路**\n双指针+滑动窗口+哈希表\n```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        window_dict = collections.defaultdict(int) \n        i, j = 0, 0 \n        max_len, start = 0, -1 \n        while j < len(s):\n            window_dict[s[j]] += 1 \n            while window_dict[s[j]] > 1:\n                window_dict[s[i]] -= 1 \n                i += 1 \n            if j - i + 1 > max_len:\n                max_len = j - i + 1 \n                start = i \n            j += 1 \n        return max_len \n```\n时间复杂度o(n)\n空间复杂度o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1107511866","body":"**思路**\n暴力解有两种思路：\n1、从words入手，排序组合生成xx种字符串，查看各个字符串在s中的位置\n排序组合的时间开销是 (words.length)! / (words 中单词重复次数相乘), 时间复杂度为 O(m!), m 为 words 长度。阶乘的时间复杂度基本不可能通过\n2、从s入手，遍历每个长度为 words.length*len(words[0]) 的字符串，转为子问题，判断长度为 words.length*len(words[0]) 的字符串是否可以由words组成\n关键问题：如何判断 s 的子串 Y 是否可以由 words 数组的构成\n- words数组中单词长度相同\n- words数组中单词长度不同 \n```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        need_dic = collections.defaultdict(int) \n        for word in words:\n            need_dic[word] += 1 \n        words_total = len(words) * len(words[0])\n        i, j = 0, words_total \n        result = []\n        while i < len(s) and j <= len(s):\n            cur_words = s[i : j + 1]\n            if self.is_same_words(cur_words, words, need_dic):\n                result.append(i)\n            \n            i += 1 \n            j = i + words_total \n        return result \n\n    def is_same_words(self, cur_words, words, need_dic):\n        find_dic = collections.defaultdict(int) \n        m = 0 \n        length = len(words[0])\n        for index in range(0, len(cur_words), length):\n            cur_word = cur_words[index : index + length]\n            if cur_word in need_dic:\n                find_dic[cur_word] += 1 \n                if find_dic[cur_word] == need_dic[cur_word]:\n                    m += 1 \n                if find_dic[cur_word] > need_dic[cur_word]:\n                    break \n            else:\n                break  \n        if m == len(need_dic):\n            return True \n        return False \n```\n时间复杂度 o(n*m*k) ，n为s长度，m为words数组长度，k为单词长度\n空间复杂度 o(m) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107709819","body":"**思路**\n前缀和求最小连续子数组\n```\nclass Solution:\n    def solve(self, nums, k):\n        # total sum, 找到最大的k的倍数，得到需要去除的subsum，再求最少个数（用前缀和） \n        total_sum = sum(nums)\n        div_num = total_sum // k \n        # nums_dic = collections.Counter(nums) \n        ## 前缀和 \n        subsum_list = []\n        add = 0 \n        for num in nums:\n            add += num \n            subsum_list.append(add)\n        \n        min_len = len(nums) + 1 \n        while div_num > 0:\n            remove_sum = total_sum - div_num * k \n            if remove_sum == 0:     ### [1,2],k=3 \n                min_len = 0 \n                break \n            pre_subsum = collections.defaultdict(int)\n            for idx in range(len(subsum_list)):\n                subsum = subsum_list[idx]\n                if subsum == remove_sum:\n                    min_len = min(min_len, idx + 1) \n                if subsum - remove_sum in pre_subsum:\n                    min_len = min(min_len, idx - pre_subsum[subsum - remove_sum]) \n                pre_subsum[subsum] = idx \n            div_num -= 1 \n            \n        if min_len == len(nums) + 1:\n            return -1 \n        return min_len \n```\n时间复杂度 o(nm), m=n//k \n空间复杂度 o(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108729258","body":"**代码**\n```\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        # 快慢指针 \n        if not head:\n            return head \n        first, second = head, head.next \n        while first is not None and second is not None:\n            first = first.next \n            second = second.next \n            if second is None:\n                return first \n            second = second.next \n        return first \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109247943","body":"**代码**\n```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        dic = collections.defaultdict(int) \n        i = 0 \n        for idx in range(len(nums)):\n            num = nums[idx] \n            if num in dic:\n                continue \n            else:\n                nums[i] = num \n                dic[num] = idx \n                i += 1 \n        return i \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111121059","body":"**思路**\n二分查找\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums) \n        left, right = 0, n - 1 \n        while left + 1 < right:\n            mid = (left + right) // 2 \n            if nums[mid] == target:\n                return mid \n            if nums[mid] < target:\n                left = mid \n            else:\n                right = mid \n        if nums[left] == target:\n            return left \n        if nums[right] == target:\n            return right \n        if nums[left] > target:\n            return left \n        if nums[right] < target:\n            return right + 1 \n        return right \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1112348876","body":"```\nclass MyQueue:\n    def __init__(self):\n        self.queue = [] \n    \n    def pop(self, value):\n        if self.queue and value == self.queue[0]:\n            self.queue.pop(0) \n    \n    def push(self, value):\n        while self.queue and value > self.queue[-1]:\n            self.queue.pop() \n        self.queue.append(value) \n    \n    def front(self):\n        return self.queue[0] \n\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or not k:\n            return [] \n        que = MyQueue() \n        for i in range(k):\n            que.push(nums[i]) \n        result = [que.front()] \n        for i in range(k, len(nums)):\n            que.pop(nums[i - k])    ## 保持que中元素为当前滑动窗口内元素 \n            que.push(nums[i]) \n            result.append(que.front()) \n        return result \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113452223","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # if not n or not trust:\n        #     return -1 \n        if not n:\n            return -1 \n        if n == 1 and not trust:    ## 1,[] => 1 \n            return 1 \n        if not trust:\n            return -1 \n        indegree_list = [0] * n \n        outdegree_list = [0] * n \n        ## 入度=n-1 \n        for item in trust:\n            first, second = item[0], item[1] \n            indegree_list[second - 1] += 1 \n            outdegree_list[first - 1] += 1 \n        for i in range(n):\n            if indegree_list[i] == n - 1 and outdegree_list[i] == 0:\n                return i + 1 \n        return -1 \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/25#issuecomment-1106503140","body":"# institution\r\n1. slide window\r\n2. hashmap\r\n\r\n# problem\r\n\r\nI thought the chars are lower cases, so I tired to use `vector<int> frq(26, 0)`\r\n\r\n# Solution\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        int res = 0;\r\n        unordered_map<char, int> frq;\r\n        for (int i = 0, j = 0; j < s.size(); j++) {\r\n            frq[s[j]]++;\r\n            while (frq[s[j]] > 1) frq[s[i++]]--;\r\n            res = max(res, j - i + 1);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\nTC: O(N)\r\nSP: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/26#issuecomment-1106706187","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        vector<int> res;\r\n        if (words.empty()) return res;\r\n        int m = words.size(), w = words[0].size(), mw = m * w, cnt = 0;\r\n        unordered_map<string, int> wf, wd;\r\n        for (auto& word : words) wf[word]++;\r\n        for (int i = 0; i < w; i++) {\r\n            for (int j = i; j + w <= s.size(); j += w) {\r\n                if (j >= i + mw) {\r\n                    string word = s.substr(j - mw, w);\r\n                    wd[word]--;\r\n                    if (wd[word] < wf[word]) cnt--;\r\n                }\r\n                string word = s.substr(j, w);\r\n                wd[word]++;\r\n                if (wd[word] <= wf[word]) cnt++;\r\n                if (cnt == m) res.push_back(j - (m - 1) * w);\r\n            }\r\n            wd.clear();\r\n            cnt = 0;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\nTC: O(N*Len)\r\nSC: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/27#issuecomment-1107536392","body":"prefix sum + hash table\r\n\r\n```cpp\r\nint solve(vector<int>& nums, int k) {\r\n    int n = nums.size();\r\n    if (!n) return -1;\r\n    int target = 0;\r\n    for (int& num : nums) target = (target + num) % k;\r\n    if (target == 0) return target;\r\n    unordered_map<int, int> memo{{0, 0}};\r\n    int prefixSum = 0, res = n;\r\n    for (int i = 0; i < n; i++) {\r\n        prefixSum = (nums[i] + prefixSum) % k;\r\n        int another = (prefixSum - target + k) % k;\r\n        if (memo.count(another)) res = min(res, i - memo[another] + 1);\r\n        memo[prefixSum] = i + 1;\r\n    }\r\n    return res == n ? -1 : res;\r\n}\r\n\r\n```\r\nTC: O(n)\r\nSC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1107876693","body":"two pointers\n\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n```\ntime complexity: o(n)\nspace complexity: o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1108984316","body":"# Intuition\ntwo pointers\n1. `res` means the index of unique number;\n2. `i` means the index of number;\nif `i` is 0 or `nums[i] != nums[i-1]` means there are a new unique number\n\n# code\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (!i || nums[i] != nums[i - 1]) nums[res++] = nums[i];\n        }\n        return res;\n    }\n};\n```\n## TC: O(n)\n## SC: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110151449","body":"# Intuition\r\n1. log(n) + sorted => binary search\r\n2. the numbers are unique, and the target maybe exists in array, so it is a standard binary search\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int l = 0, r = nums.size() - 1;\r\n        while (l <= r) {\r\n            int mid = l + r >> 1;\r\n            if (nums[mid] < target)\r\n                l = mid + 1;\r\n            else if (nums[mid] > target)\r\n                r = mid - 1;\r\n            else\r\n                return mid;\r\n        }\r\n        return l;\r\n    }\r\n};\r\n```\r\n\r\no(logn)\r\no(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111986702","body":"维护一个单调递减的双端队列\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> res;\n        deque<int> dq;\n        for (int i = 0; i < nums.size(); i++) {\n            if (dq.size() && i - k == dq.front()) dq.pop_front();\n            while (dq.size() && nums[i] > nums[dq.back()]) dq.pop_back();\n            dq.push_back(i);\n            if (i >= k - 1) res.push_back(nums[dq.front()]);\n        }\n        return res;\n    }\n};\n```\n\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1113159498","body":"想错了，一开始还打算用unionfind做\n结果就是计算出度入度就行\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> cnt(n + 1, 0);\n        for (auto t : trust) {\n            cnt[t[0]]--;\n            cnt[t[1]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (cnt[i] == n - 1) return i;\n        }\n        return -1;\n    }\n};\n```\n\nO(n)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/33#issuecomment-1113759057","body":"染色法\n1. 构建图\n2. DFS染色\n\n```c++\nclass Solution {\nprivate:\n    vector<int> colors;\n    vector<vector<int>> graph;\n\n    bool dfs(int v, int color) {\n        colors[v] = color;\n        for (int u : graph[v]) {\n            if (colors[u]) {\n                if (colors[u] == color) return false;\n            } else if (!dfs(u, color ^ 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        colors.resize(n + 1);\n        graph.resize(n + 1);\n        for (auto dislike : dislikes) {\n            graph[dislike[0]].push_back(dislike[1]);\n            graph[dislike[1]].push_back(dislike[0]);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            if (!colors[i] && !dfs(i, 0)) return false;\n        }\n\n        return true;\n    }\n};\n```\n\nO(m+n)\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"echoocking":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1107397968","body":"## 思路 \r\n遍历\r\n\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = []\r\n        tar = float('-inf')\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                tar = i\r\n            left.append(i - tar)\r\n        \r\n        right = []\r\n        tar = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                tar = i\r\n            right.append(min(tar - i, left[i]))\r\n\r\n        return right[::-1]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1107398447","body":"## 思路 \r\n使用一个add数组，存放每个位置上的增量。在pop操作时，pop出的值会加上这个增量。增量会从add[i]传递到add[i-1]位置，向下传递，并将add[i]的值变为0，防止再次increment时增量重叠。\r\n\r\n## 代码\r\n```python \r\nclass CustomStack {\r\n    private int[] arr;\r\n    private int top;\r\n    \r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top < arr.length - 1) {\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return top == -1 ? -1 : arr[top--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < k && i <= top ; i++) {\r\n            arr[i] += val; \r\n        }\r\n    }\r\n}\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muhongfan":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1089683832","body":"# 思路\n# 只有数字可以相加，将任何形式的输入转化为int形式，相加，然后转化为list形式\n\n\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        n = int(''.join(map(str, num)))\n        n = n + k\n        return [i for i in str(n)]\n    \n    ## Time complexity: O(N)\n    ## Space complexity: O(N)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gitbingsun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/28#issuecomment-1108047639","body":"解题思路\n此处撰写解题思路\ntwo pointers approach.\nslow pointer takes one step each time and fast pointer takes two steps each time.\nWhen the faster pointer reach the end, the slow point stop at the middle.\n\nO(n) time complexity\nconst space complexity\n\n代码\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if(head == nullptr || head->next == nullptr) return head;\n\n        int count = 0;\n        ListNode* cur = head;\n        while (cur != nullptr) {\n            cur = cur->next;\n            count++;\n        }\n\n        ListNode* p1 = head;\n        ListNode* p2 = head;\n        \n        while(p1 != nullptr && p2 != nullptr && p2->next != nullptr)  {\n            p1 = p1->next;\n            p2 = p2->next->next;\n        }\n        \n        if (count % 2 == 0) {\n             if (p1 != nullptr) return p1;\n        }  \n        return p1;\n    }\n};\n\n作者：gitbingsun\n链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/by-gitbingsun-4to9/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/29#issuecomment-1109284728","body":"\n## 题目地址(26. 删除有序数组中的重复项)\n\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n## 题目描述\n\n```\n给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。\n\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n\n不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n\n判题标准:\n\n系统会用下面的代码来测试你的题解:\n\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n如果所有断言都通过，那么您的题解将被 通过。\n\n \n\n示例 1：\n\n输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2：\n\n输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n\n \n\n提示：\n\n0 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums 已按 升序 排列\n```\n\n## 思路\nUse two pointers:\n  - it1 keeps track of the index where new different value should be copied to. \n  - it2 keeps moving forward until it encounters a different value that what it2 holds\n  - then copy it2 value to it1 and advance it1\n\n\n## 关键点\n\n-  two pointers\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.size() <= 1) return nums.size();\n\n        vector<int>::iterator it1 = nums.begin();\n        vector<int>::iterator it2 = nums.begin();\n        int len = 1;\n        while((it2+1) != nums.end()) {\n            while((it2+1) != nums.end() && *it1 == *it2) {\n                it2++;\n            }\n            if (*it1 != *it2) {\n                it1++;\n                *it1 = *it2;\n                len++;\n            }\n        }\n        return len;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1110477213","body":"\n## 题目地址(35. 搜索插入位置)\n\nhttps://leetcode-cn.com/problems/search-insert-position/\n\n## 题目描述\n\n```\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n请必须使用时间复杂度为 O(log n) 的算法。\n\n示例 1:\n\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n\n\n示例 2:\n\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n\n\n示例 3:\n\n输入: nums = [1,3,5,6], target = 7\n输出: 4\n\n提示:\n\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums 为 无重复元素 的 升序 排列数组\n-104 <= target <= 104\n```\n\n## 思路\n二分法寻找\n\n## 关键点\n比较target, nums[m] 后继续比较相邻的值\nif (nums[m] < target < nums[m+1] ) return m+1\nif (nums[m-1] < target < nums[m]) return m\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int size = nums.size();\n        if ( size == 0 ) return 0;\n\n        int l = 0;\n        int r = size-1;\n        if (nums[l] > target ) return l;\n        if (nums[r] < target ) return r+1;\n        while ( l < r ) {\n            int m = l + (r - l)/2;\n            if (nums[m] == target) \n                return m;\n            else if (nums[m] < target) {\n                if (m+1 < size && nums[m+1] > target) return m + 1;\n                l = m + 1;\n            } else {\n                if (m-1 >= 0 && nums[m-1] < target) return m;\n                r = m -1;\n            }\n        }\n        \n        return l;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/32#issuecomment-1112851634","body":"\n## 题目地址(997. 找到小镇的法官)\n\nhttps://leetcode-cn.com/problems/find-the-town-judge/\n\n## 题目描述\n\n```\n小镇里有 n 个人，按从 1 到 n 的顺序编号。传言称，这些人中有一个暗地里是小镇法官。\n\n如果小镇法官真的存在，那么：\n\n小镇法官不会信任任何人。\n每个人（除了小镇法官）都信任这位小镇法官。\n只有一个人同时满足属性 1 和属性 2 。\n\n给你一个数组 trust ，其中 trust[i] = [ai, bi] 表示编号为 ai 的人信任编号为 bi 的人。\n\n如果小镇法官存在并且可以确定他的身份，请返回该法官的编号；否则，返回 -1 。\n\n 示例 1：\n\n输入：n = 2, trust = [[1,2]]\n输出：2\n\n\n示例 2：\n\n输入：n = 3, trust = [[1,3],[2,3]]\n输出：3\n\n\n示例 3：\n\n输入：n = 3, trust = [[1,3],[2,3],[3,1]]\n输出：-1\n\n \n\n提示：\n\n1 <= n <= 1000\n0 <= trust.length <= 104\ntrust[i].length == 2\ntrust 中的所有trust[i] = [ai, bi] 互不相同\nai != bi\n1 <= ai, bi <= n\n```\n\n## 思路\n\n用一个vector size of n 存目前的人有被多少人trust, or set to be -1 if this person trust someone else\n-  \n\n## 代码\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        // edge case\n        if (n == 1 && trust.size() == 0)\n            return 1; \n\n        vector<int> num(n+1,0);\n        for (auto v : trust) {\n            // v[0] trust v[1] so v[0] cannot be the judge\n            num.at(v[0]) = -1; \n            num.at(v[1]) += 1;\n        }\n\n        for (int i = 0; i < num.size(); i++) {\n            if (num.at(i) == n-1) \n                return i;\n        }\n        return -1;\n\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snowballbears":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/30#issuecomment-1111162971","body":"## **题目**\n35. Search Insert Position\n\n## **思路**\n\nBinary Search\n\n## **代码**\n\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)-1\n        \n        while(l<=r):\n            mid = (l+r)//2\n            \n            if nums[mid]<target:\n                l = mid+1\n            elif nums[mid] > target:\n                r = mid-1\n            else:\n                return mid\n        \n        return l\n   \n```\n\n## **复杂度**\n\nSpace: O(log(1))\nTime: O(log(n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/31#issuecomment-1111741547","body":"\n## **题目**\n239. Sliding Window Maximum\n\n## **思路**\n\nDeque\n\n## **代码**\n\n```\nclass Solution:\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\nres = []\nq = collections.deque()\n\n    for i in range(len(nums)):\n        while(q and nums[q[-1]]<nums[i]):\n            q.pop()\n            \n        while(q and i-q[0]>=k):\n            q.popleft()\n        \n        q.append(i)\n        if i >= k-1:\n            res.append(nums[q[0]])\n    \n    return res\n   \n```\n\n## **复杂度**\n\nSpace: O(k)\nTime: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}