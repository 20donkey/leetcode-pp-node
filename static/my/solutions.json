{"577961141":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085986299","body":"## 题目思路\n解法一：假如，需要计算的数组为[1,2,3]和数字1095；首先向1095取余（以10），那么得到5再和数组3相加，得到8，将结果加入到新的数组；再将1095向下取整，再取余，得到9，在和数组的2相加，会发现得到的结果超过了10，那么就要将结果减10后加入新的数组，109还需要加一。重复以上步骤即可。\n\n解法二： 假如，需要计算的数组为[1,2,3]和数字1095；我们可以直接向1095加上数组的末尾的数，即1095+3然后取余，得到8，加入到新的数组中去，一直重复这个步骤即可。\n\n## 题目的题解code\n解法1：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $remainder = $k % 10;\n            $addVal = $remainder + $num[$i];\n\n            if ($addVal >= 10) {\n                $addVal = $addVal % 10;\n                $k = floor($k /10) + 1;\n            }else {\n                $k = floor($k /10);\n            }\n            $res[] = $addVal;\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n解法2：\n```PHP\nclass Solution {\n\n    /**\n     * @param Integer[] $num\n     * @param Integer $k\n     * @return Integer[]\n     */\n    function addToArrayForm($num, $k) {\n        $res = [];\n        for ($i = count($num) -1; $i >=0; $i--) {\n            $k = $num[$i] + $k;\n            $res[] = $k % 10;\n            $k = floor($k / 10);\n        }\n        while($k) {\n            $res[] = $k % 10;\n            $k = floor($k /10);\n        }\n        return array_reverse($res);\n    }\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(max(n,logk)),其中n为数组的长度，k为数值的长度\n空间复杂度：O(1),除了返回值之外，其余全是常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086643481","body":"## 题目思路\n1. 先遍寻左边，记录上一次字符C出现的位置```prev```,那么答案就是```i-prev```\n2. 再遍寻右边，记录上一次字符C出现的位置```prev```,那么答案就是```prev-i```\n3. 最后比较相同位置的数值，谁小取谁\n\n## 题目的题解code\n```PHP\n<?php\n\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $c\n     * @return Integer[]\n     */\n    function shortestToChar($s, $c) {\n        $ans = [];\n        $len = mb_strlen($s);\n\n        // 计算左边\n        $prev = PHP_INT_MIN / 2;\n        for ($i = 0; $i < $len; $i++) {\n            if ($s[$i] == $c) {\n                $prev = $i;\n            }\n\n            $ans[] = $i - $prev;\n        }\n\n        // 计算右边\n        $prev = PHP_INT_MAX / 2;\n        for ($j = $len - 1; $j >= 0; $j--) {\n            if ($s[$j] == $c) {\n                $prev = $j;\n            }\n\n            $ans[$j] = min($ans[$j], $prev - $j);\n        }\n\n        return $ans;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度： O(N),N是字符串的长度，我们需要遍历两次\n空间复杂度： O(N),ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858899","body":"## 题目思路\n额。思路没有挺简单的\n\n## 题目的题解code\n```PHP\n<?php\n\nclass CustomStack {\n    public $maxSize;\n    public $stack = [];\n    /**\n     * @param Integer $maxSize\n     */\n    function __construct($maxSize) {\n        $this->maxSize = $maxSize;\n    }\n\n    /**\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        if  (count($this->stack) < $this->maxSize) {\n            array_push($this->stack, $x);\n        }\n\n        return null;\n    }\n\n    /**\n     * @return Integer\n     */\n    function pop() {\n        if (count($this->stack) <= 0) {\n            return -1;\n        }\n\n        return array_pop($this->stack);\n    }\n\n    /**\n     * @param Integer $k\n     * @param Integer $val\n     * @return NULL\n     */\n    function increment($k, $val) {\n        for ($i = 0; $i < $k && $i < count($this->stack); $i++) {\n            $this->stack[$i] += $val;\n        }\n\n        return null;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * $obj = CustomStack($maxSize);\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $obj->increment($k, $val);\n */\n```\n\n## 时间和空间复杂度\n时间复杂度：所有操作的渐进时间复杂度均为O(1)。\n空间复杂度：这里用到了两个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为O(maxSize)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087609034","body":"## 题目思路\n用栈的方式进行题解\n1. 将`数字`、`字母`、`[`一个一个加入到栈中；\n2. 如果遇到`]`,就从栈中取出字母，直到遇到`[`\n3. 将`[`去掉，然后从栈中取出数字（判断是否为数字，因为可能有多个）\n4. 重复这些字母\n5. 重复上面的步骤\n\n## 题目的题解code\n```PHP\nclass Solution {\n\n    /**\n     * @param String $s\n     * @return String\n     */\n    function decodeString($s) {\n        $stack = [];\n        for ($i = 0; $i < mb_strlen($s); $i++) {\n             if ($s[$i] === \"]\") {\n                 $repeatStr = \"\";\n                 $repeatCount = \"\";\n\n                 while ($stack && end($stack) !== \"[\") {\n                     $repeatStr = array_pop($stack).$repeatStr;\n                 }\n\n                 // 去掉[\n                 array_pop($stack);\n\n                 while ($stack && is_numeric(end($stack))) {\n                     $repeatCount = array_pop($stack).$repeatCount;\n                 }\n\n                 $repeatStr = str_repeat($repeatStr, (int)$repeatCount);\n                 array_push($stack, $repeatStr);\n            } else {\n                 array_push($stack, $s[$i]); // 加入栈中\n             }\n        }\n        return implode('', $stack);\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 为解码后的 s 的长度。\n空间复杂度：O(N)，其中 N 为解码后的 s 的长度。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090131592","body":"## 题目思路\n贪心算法\n\n\n## 题目的题解code\n```GOLANG\nfunc maxChunksToSorted(arr []int) int {\n    // 排序后，对两个数组进行diff，偏移量为0时，表示可以分块\n\tb := append([]int{}, arr...)\n\tsort.Ints(b)\n\n\tret := 0\n\tdiff := 0\n\tm := map[int]int{}\n\tfor i := 0; i < len(arr); i++ {\n\t\tm[b[i]]++\n\t\tif m[b[i]] > 0 { //该数拉开了两个数组的差距，正向偏移（偏向b数组）\n\t\t\tdiff++\n\t\t} else { // 抵消了arr数组的偏移\n\t\t\tdiff--\n\t\t}\n\n\t\tm[arr[i]]--\n\t\tif m[arr[i]] < 0 { //该数拉开了两个数组的差距，负向偏移（偏向arr数组）\n\t\t\tdiff++\n\t\t} else { // 抵消了b数组的偏移\n\t\t\tdiff--\n\t\t}\n\n\t\tif diff == 0 {\n\t\t\tret++\n\t\t}\n\t}\n\treturn ret\n}\n```\n\n## 时间和空间复杂度\n时间复杂度：O(N^2)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091636667","body":"## 题目思路\n算法：快慢指针\n\n思路：\n1. 快指针与慢指针都以每一步一个节点的速度向后遍历\n2. 快指针比满指针先走K步\n3. 当快指针到达终点时，慢指针正好是倒数第K个节点\n\n伪代码：\n```PHP\n快指针 = 慢指针 = $head;\n\nwhile(快指针->next) {\n    if ($k-- <= 0) {\n        慢指针 = 满指针-> next;\n    }\n    快指针 = 快指针->next;\n}\n```\n\n经过这样的处理，我们旋转了一位，而题目是要旋转 k 位，实际上我们只需要将上面的算法微调即可。将 1 改成 k ， 2 改成 k + 1。\n\n算法描述：\n\n获取单链表的倒数第 k 与倒数第 k + 1 个节点\n\n将倒数第 k + 1 个节点的 next 指向 null\n\n将尾节点 next 指向 head（拼起来）\n\n返回倒数第 k 个节点\n\n例如链表 A -> B -> C -> D -> E 右移 2 位，依照上述步骤为：\n\n获取节点 C 与 D\n\nA -> B -> C -> null, D -> E\n\nD -> E -> A -> B -> C -> nul\n\n返回节点 D\n\n注意：假如链表节点长度为len，则右移K位与右移k%len效果是一样的，就像环形跑道为1000米，你跑100米和1100米是一样的位置\n\n伪代码如下：\n\n```PHP\n获取链表的长度\nk = k % 链表的长度\n获取倒数第K+1，倒数第K个节点与链表尾节点\n倒数第k+1节点.next = null\n链表尾节点.next = head\nreturn 倒数第k个节点\n```\n\n## 题目的题解code\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $k\n     * @return ListNode\n     */\n    function rotateRight($head, $k) {\n        if (!$head || !$head->next) return $head;\n        // 获取链表的长度\n        $count = 0;\n        $now = $head;\n        while ($now) {\n            $count++;\n            $now = $now->next;\n        }\n\n        // 获取实际上的$k\n        $k = $k % $count;\n\n        // 快指针获取链表的倒数第一个节点；慢指针获取倒数K+1个指针\n        $slow = $fast = $head;\n\n        while($fast->next) {\n            if ($k-- <=0) {\n                $slow = $slow->next;\n            }\n            $fast = $fast->next;\n        }\n\n        $fast->next = $head;\n        $res = $slow->next;\n        $slow->next = null;\n        return $res;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 链表的长度。\n空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092898594","body":"### 迭代\n\n假如原始链表为preA->A->B->nextB,我们需要修改为preA->B->A->nextB,接下来的元素按照这个逻辑交换就行\n\n那么修改指针的顺序为\n\n1. A节点的next指向nextB:\n> preA->A->nextB\n> \n> B->nextB\n\n2. B节点的next指向A\n>preA->A->nextB\n> \n> B->A\n\n3. preA->节点的next指向B\n> preA->B->A->nextB\n\n伪代码：\n```PHP\n$A.next = next.B;\n$B.next = $A;\npreA.next = B;\n```\n\n我们可以创建一个preHead，让其next指针指向A。\n\n## 题目的题解code\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function swapPairs($head) {\n        if (!$head || $head->next == null) { //为空或者只有一个节点\n            return $head;\n        }\n\n        $prevNode = new ListNode();// 前置节点\n        $prevNode->next = $head; // 前置节点的指针等于第一个节点\n        $oneNode = $head; // 第一个节点\n        $res = $oneNode->next; // 返回的结果（第二个节点就是要返回的节点）\n        while ($oneNode && $oneNode->next != null) { // 当前节点有值且有下一个节点\n            $twoNode = $oneNode->next; // 获取第二个节点\n            $afterPointer = $twoNode->next; // 第二个节点的指针\n\n            $oneNode->next = $afterPointer; // 第一个节点的下一个指针指向第二个节点的下一个指针\n            $twoNode->next = $oneNode; // 第二个节点的指针指向第一个节点\n            $prevNode->next = $twoNode;// 前置的指针改成是第二节点\n\n            $prevNode = $oneNode; // 前置节点等于第一个节点\n            $oneNode = $afterPointer; // 第一各节点修改为第二个节点的指针\n        }\n        return $res;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n时间复杂度：O(N)，其中 N 链表的长度。\n空间复杂度：O(1),没用到额外空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094010940","body":"## 题目思路\n\n### 解法一：快慢指针\n1. 获取当前链表的中点\n2. 以链表中点为根\n3. 中点左边的值都小于它，可以构造左子树\n4. 同理构造右子树\n5. 循环第一步\n\n具体： \n1. 定义一个快指针和一个慢指针，快指针步数为2，慢指针步数为1\n2. 当快指针到达尾部的时候，慢指针正好指到的点为中点\n\n### 解法二： 缓存法\n1. 以空间换时间，用一个数组存储链表的节点\n2. 然后去数组的中间点建立树\n3. 左右两边的子树按照这个方式遍寻\n\n## 题目的题解code\n### 解法一\n```PHP\n<?php\n\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param ListNode $head\n     * @return TreeNode\n     */\n    function sortedListToBST($head)\n    {\n        if (!$head) {\n            return null;\n        }\n        return $this->dfs($head, null);\n    }\n\n    /**\n     * @param ListNode $head 头结点\n     * @param ListNode $tail 尾节点\n     * @return TreeNode|null\n     */\n    private function dfs($head, $tail)\n    {\n        if ($head == $tail) { // 这个的作用是头尾节点相等的时候就不用遍寻了，说明就没有了\n            return null;\n        }\n\n        $fast = $head; // 快指针\n        $slow = $head; // 慢指针\n        while ($fast != $tail && $fast->next != $tail) { // 兼容奇数和偶数\n            $fast = $fast->next->next;\n            $slow = $slow->next;\n        }\n        $root = new TreeNode($slow->val);\n        $root->left = $this->dfs($head, $slow);\n        $root->right =$this->dfs($slow->next, $tail);\n\n        return $root;\n    }\n}\n```\n\n### 解法二\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution\n{\n\n    /**\n     * @param ListNode $head\n     * @return TreeNode\n     */\n    function sortedListToBST($head)\n    {\n        $res = [];\n        while ($head) {\n            $res[] = $head->val;\n            $head = $head->next;\n        }\n        return $this->dfs($res, 0, count($res) - 1);\n    }\n\n    private function dfs($res, $l, $r)\n    {\n        if ($l > $r) {\n            return null;\n        }\n        $mid = ceil(($r - $l)/2) + $l;\n        $root = new ListNode($res[$mid]);\n        $root->left = $this->dfs($res, $l, $mid-1);\n        $root->right = $this->dfs($res, $mid+1, $r);\n        return $root;\n    }\n}\n```\n\n\n## 时间和空间复杂度\n### 解法一：\n- 时间复杂度：递归树的深度为 lognlogn，每一层的基本操作数为 nn，因此总的时间复杂度为O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)\n### 解法二：\n- 时间复杂度：递归树每个节点的时间复杂度为 O(1)，每次处理一个节点，因此总的节点数就是 nn， 也就是说总的时间复杂度为O(n)。\n- 空间复杂度：使用了数组对链表的值进行缓存，空间复杂度为O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095138054","body":"# 142. 环形链表 II\n\n## 题目链接\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目思路\n### 解法一：使用哈希法\n1. 使用哈希表存储链表的每一个节点\n2. 遍寻每一个节点都要检查在哈希表里是否存在\n3. 存在就直接返回。如果不存在就返回null\n\n### 解法二：使用快慢指针\n1. 建立快慢指针，都在链表的原点\n2. 快指针的步长为2，慢指针的步长为1\n3. 当两个指针相遇时，快指针回到链表的原点\n4. 这时快指针的步长为1，这时候快慢指针相遇就是交点\n\n## 题目的题解code\n### 解法一：\n```PHP\n<?php\n\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function detectCycle($head) {\n        $data = [];\n        while ($head != null) {\n            if (in_array($head, $data)) {\n                return $head;\n            }else {\n                $data[] = $head;\n            }\n            $head = $head->next;\n        }\n        return null;\n    }\n}\n```\n\n### 解法二\n```PHP\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\n\nclass Solution {\n    /**\n     * @param ListNode $head\n     * @return ListNode\n     */\n    function detectCycle($head) {\n        $fast = $head; $slow = $head;\n\n        while($fast != null) {\n            $slow = $slow->next;\n            if ($fast->next != null) {\n                $fast = $fast->next->next;\n            } else {\n                return null;\n            }\n\n            if ($slow->val == $fast->val) {\n                $current = $head;\n                while ($current->val != $slow->val) {\n                    $current = $current->next;\n                    $slow = $slow->next;\n                }\n                return $current->val;\n            }\n        }\n        return null;\n    }\n}\n```\n## 时间和空间复杂度\n### 解法一：\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n### 解法二：\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1973719588":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085541708","body":"思路：将int型的数字变为str字符串型的就很好处理了\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        i = ''\r\n        for x in num:\r\n            i = i + str(x)\r\n        numi = int(i)\r\n        xx = numi + k\r\n        ls = []\r\n        for s in str(xx):\r\n            ls.append(int(s))\r\n\r\n        return ls\r\n```\r\n\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091654293","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        def rotate(head):\r\n            curl = head\r\n            while curl.next:\r\n                pre = curl\r\n                curl = curl.next\r\n            end = curl\r\n            end.next = head\r\n            pre.next = None\r\n            return end\r\n        \r\n        if head == None or head.next == None:\r\n            return head\r\n        \r\n        l = 1\r\n        curl = head\r\n        while curl.next:\r\n            l = l + 1\r\n            pre = curl\r\n            curl = curl.next\r\n        if k > l:\r\n            k = k % l\r\n\r\n        while k > 0:\r\n            head = rotate(head)\r\n            k = k - 1\r\n        \r\n        return head\r\n```\r\n空间复杂度：O(1)\r\n时间复杂度：max (k)O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094910697","body":"```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if head == None or head.next == None or head.next.next == None:\n            return None\n        \n        fast = head.next.next\n        slow = head.next\n        while fast.next and fast.next.next:\n            if slow != fast:\n                slow = slow.next\n                fast = fast.next.next\n            else:\n                while slow != head:\n                    slow = slow.next\n                    head = head.next\n                return head\n        \n        return None\n```\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085303351","body":"## Idea\nScan the array from end to begin. Use an extra variable to record the carry number.\n\n## Code\n```python 3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = k\n        for i in range(len(num) - 1, -1, -1):\n            total = (num[i] + carry)\n            carry = total // 10\n            A = total % 10\n            num[i] = A\n        if carry:\n            return [int(i) for i in str(carry)] + num\n        return num\n                \n```\n\n## Complexity:\nTime: O(N). N = max(len(num), len(k))\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642145","body":"## Idea\nDeque q for the index of character c. For each index i in s check whether abs(i - q[0])>abs(i - q[1]) and q has more than 1 element. If it is, pop the most front element from the q. \n\n## Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = collections.deque()\n        for i in range(len(s)):\n            if s[i] == c:\n                position.append(i)\n        ans = []\n        for i in range(len(s)):\n            if len(position)>1 and abs(i-position[0])>abs(i-position[1]):\n                position.popleft()\n            ans.append(abs(i-position[0]))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894362","body":"## Idea\nSimulation\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.cap = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.cap:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n\n```\n\n## Complexity:\nTime: Increment: O(k.) Others: O(1)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087668420","body":"## Idea\nStack\n\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l=[]\n        for i in s:\n            if i!=']':\n                l.append(i)\n            else:\n                if len(l)==0:\n                    break\n                temp=''\n                while l[-1]!='[':\n                    temp=l.pop()+temp\n                l.pop()\n                temp2=''\n                while len(l)>0 and l[-1].isdigit():\n                    temp2=l.pop()+temp2\n                res=temp*int(temp2)\n                l.append(res)\n        \n        ans=''\n        for i in l:\n            ans+=i\n        return ans\n```\n\n## Compexity:\nTime: O(maxK^Countk * N)\nSpace: O(sum(maxK ^CountK*n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088734659","body":"## Idea\nTwo stacks. One for push, one for peek and pop\n\n## Code\n\n```python\nclass MyQueue:\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n\n    def push(self, x: int) -> None:\n        self.instack.append(x)\n\n    def pop(self) -> int:\n        if not self.outstack:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack.pop()\n\n    def peek(self) -> int:\n        if not self.outstack:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n\n    def empty(self) -> bool:\n        return len(self.instack)==0 and len(self.outstack) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n## Complexity:\nSapce: O(N)\nTime: PushL O(1). Pop & peek: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090267640","body":"## Idea\nMonotonic stack. The element in the stack is the largest element of each chunk. Because it's monotonic stack, it ensures the element smaller than current chunk's largest element will be merged into current chunk. In other words, the smallest element of next chunk will not be smaller than current chunk's largest element.\n\n## Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091711239","body":"## Idea\nCircle list's tail to the head, then disconnect the list at the n-k%n-1 node. Return n-k%n node\n\n## Code\n```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n\n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n        # break the ring\n        new_tail.next = None\n        \n        return new_head\n```\n\n## Complexity:\nTime: O(N)\nSpace: o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092847190","body":"## Idea\nIterative\n\n## Code\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        new_head = None\n        pre, cur, nex = None, head, head.next\n        while nex:\n            tmp = nex.next\n            if pre:\n                pre.next = nex\n                nex.next = cur\n                cur.next = tmp\n            else:\n                new_head = nex\n                nex.next = cur\n                cur.next = tmp\n            if tmp:\n                pre, cur, nex = cur, tmp, tmp.next\n            else:\n                break\n        return new_head\n```\n## Complexity\nTIme: o(N)\nSapce: o(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094161147","body":"## Idea\nTwo pointers. Go through both linkedlists. If one of them reaches the end, change its pointer to the other linkedlist's head. After two turns and both pointers meet at the same node, return it. otherwise, return null\n\n## Code\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        d1 = headA\n        d2 = headB\n        r = 0\n        while r<=2:\n            while d1 and d2:\n                if d1 == d2:\n                    return d1\n                d1 = d1.next\n                d2 = d2.next\n            if not d1:\n                d1 = headB\n            if not d2:\n                d2 = headA\n            r+= 1\n        return None\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095086901","body":"## Idea\nTwo pointers. Floyd's Tortoise and Hare\n\n## Code\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        fast, slow = head, head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        if not fast or not fast.next:\n            return None\n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow=slow.next\n        return fast\n            \n```\n\n## Complexity:\nTime: O(N)\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085327382","body":"> 实现思路\n\n实际上就是一个模拟人工加法的过程\n\n> 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)\n\n> 代码实现\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> ans = new ArrayList<>();\n        num[n-1] += k;\n        int t  = 0;// 用 t 来表示进位 \n        for(int i = n - 1; i >=0 ; i--) {\n            // 比如说 now = 11， ans 的当前位就是 1，进位为 10\n            int now = num[i] + t; // 当前位 + 进位之后的结果\n            ans.add(now % 10);// ans 中当前位的结果是 now 的个位\n            t = now / 10; // 进位就是 除了个位 以上的为\n        }\n        if(t > 0){\n            while(t != 0) {\n                ans.add(t % 10);\n                t /= 10;\n            }\n        }\n        Collections.reverse(ans); \n        return ans;\n    }\n}\n\n```\n> [高精度加法](https://www.acwing.com/problem/content/description/793/)\n> Acwing\n\n```markdown\n给定两个正整数（不含前导 0），计算它们的和。\n\n # 输入格式\n \n共两行，每行包含一个整数。\n\n # 输出格式\n共一行，包含所求的和。\n\n# 数据范围\n1≤ 整数长度 ≤100000\n```\n\n```c\n#include<iostream>\n#include<cstring>\n#include<vector> \nusing namespace std;\nvector<int> add(vector<int> A,vector<int> B) {\n    if(A.size() < B.size()) return add(B,A);\n    vector<int> C;\n    int t = 0;// 表示进位\n    for(int i = 0 ;i < A.size(); i++) {\n        t += A[i];\n        if(i < B.size()) t+= B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    if(t > 0) {\n        while(t !=0 ) C.push_back(t % 10), t/=10;\n    }\n    return C;\n    \n}\nint main() {\n    string a,b;\n    vector<int> A,B;\n    cin>>a>>b;\n    for(int i = a.size()-1; i >=0 ;--i) {\n        A.push_back(a[i] - '0');\n    }\n    for(int i = b.size() - 1; i >= 0; --i) {\n        B.push_back(b[i] - '0');\n    }\n    auto C = add(A,B);\n    for(int i = C.size() - 1; i >= 0; i--){\n        cout<<C[i];\n    }\n    return 0;\n    \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086474703","body":"[原题链接](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n> 算法一\n1. 时间复杂度为：O(n ^ 2)\n2. 思路：暴力枚举，对于每个位置都向左右两个方向进行搜索，判断每个位置上的字符是否是c，如果是，进行相应的计算即可\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++){\n            int left = i;\n            int right = i+1;\n            int res  = Integer.MAX_VALUE;\n            while(left >= 0) {\n                if(s.charAt(left) == c) res = Math.min(res, Math.abs(i - left));\n                left --;\n            }\n            while(right < n) {\n                if(s.charAt(right) == c) res = Math.min(res, Math.abs(i - right));\n                right ++;\n            }\n            ans[i] = res;\n        }\n        return ans;\n    }\n}\n```\n> 算法二\n \n\n  - 时间复杂度：O(n)\n-  思路： 在算法一中，对于每个位置我们都要向左 和向右搜索距离这个位置最近的c，这种算法的时间复杂度很高，并且在做很多无用功。对于每个位置，我们如果说知道了他的前一位，距离最近的c    的位置，我们就不需要每个位置都进行枚举\n-  通过这种思想，我们只需要向左扫一遍，记住每个位置上，左边距离它最近的c的距离；在向右扫一遍，记住每个位置上，右边距离它最近的c的位置，就行。\n- 这里pre 除以2 的目的是为了，防止越界 \n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int pre = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for(int i = n -1; i >= 0; i--) {\n            if(s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i],pre- i);\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086787651","body":"[原题链接](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n@[toc]\n# 思路\n题目中已经确切的告诉了我们，数组中会放入多少个元素，这种情况并且只有添加操作，这种情况之下，使用数组模拟效率会更高一点。\n# 代码\n> 用数组模拟栈,击败100%\n```java\nclass CustomStack {\n    private int[] stack;\n    private int tt;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(tt == stack.length) return;\n        stack[tt++] = x;\n    }\n    \n    public int pop() {\n        if(tt == 0) return -1;\n        return stack[--tt];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < tt; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n#  用数组来模拟栈\n> 用一个数组来表示栈结构，并且加一个索引来方便操作,这里的 tt 指向的是 下一次要放的位置 \n\n```c\nconst int N  = 10010;\nint stack[N];\nint tt;\n// 向栈中添加元素\nstack[tt++] = x;\n// 弹出栈顶元素\n--tt;\n// 判断栈是否是空\ntt == 0;\n// 栈顶\nint top = tt;\nstack[top--];\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087502634","body":"```\nclass Solution {\n    public String decodeString(String s) {\n        //定义结果\n        StringBuffer buffer = new StringBuffer();\n        //用来 定义字符栈\n        LinkedList<String> listString = new LinkedList<>();\n        // 用来定义数字栈\n        LinkedList<Integer> listInt = new LinkedList<>();\n        for(int i = 0;i<s.length();){\n            if(s.charAt(i)!=']'){\n                char a = s.charAt(i);\n                if(a>'9' || a<'0'){\n                    //进入字符栈中\n                    listString.add(a+\"\");\n                    i++;\n                }else{\n                    //就是数字，进入数字栈中\n                    int j  = i+1;\n                    int tem = a-'0';\n                    while(s.charAt(j)<='9' && s.charAt(j)>='0' && j<s.length()){\n                        tem = tem *10 + (s.charAt(j)-'0');\n                        j++;\n                    }\n                    i = j;\n                    listInt.add(tem);\n                }\n            }else{\n                //用来取出字符栈中的元素\n                String temString = new String();\n                //用来拿出栈顶的数字\n                int temInt = listInt.getLast();\n                listInt.removeLast();\n                // 循环拿出 字符\n                while(!listString.isEmpty() && !listString.getLast().equals(\"[\")){\n                    temString = listString.getLast()+temString;\n                    listString.removeLast();\n                }\n                listString.removeLast();\n                StringBuffer sb = new StringBuffer();\n                for(int k = 1;k<=temInt;k++){\n                    sb.append(temString);\n                }\n                //如果说listInt不是空的，就将结果压在listString栈中\n                if(!listInt.isEmpty()){\n                    listString.add(sb.toString());\n                }else{\n                    //反之，加到结果中\n                    String ss = \"\";\n                    while(!listString.isEmpty()){\n                        ss = listString.getLast()+ss;\n                        listString.removeLast();\n                    }\n                    buffer.append(ss);\n                    buffer.append(sb);\n                }\n                i++;\n            }\n        }\n        if(!listString.isEmpty()){\n            for(int i =0;i<listString.size();i++){\n                buffer.append(listString.get(i));\n            }\n        }\n        return buffer.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088670739","body":"\n# 思路\n栈的特点是先进后出， 队列的特点是先进先出。 我们可以设计两个栈， 一个栈`stackPush`用来存放数据， 另一个栈`stackPop`用来存放`stackPush`栈中元素的倒序结果， 利用栈的特点，删除`stackPop`的栈顶， 就相当于进行了出队操作。 比如说：\n\n- `stackPush`: 栈底 1 2 3 4 5  栈头\n- `stackPop`:  栈底 5 4 3 2 1   栈头\n\n按照队列的顺序` 1 2 3 4 5 `。出队的话，就是出 1，相当于就是 `stackPop`的队头。\n\n\n\n> 向栈中添加元素\n\n- 向`stackPush`中添加即可\n\n> 删除队头元素\n - 当`stackPop`中仍然有元素的时候，直接返回头即可\n - 如果上一步没有执行，说明`stackPop`中没有元素，先判断一下 ，有没有向`stackPush`中添加元素，如果说没有，返回 -1\n - 最后，说明`stackPush`中有元素，但是没有倒在`stackPop`中，倒入\n - 返回 `stackPop`的栈顶\n\n# 代码\n```java\nclass MyQueue {\n    private LinkedList<Integer> stackPush;\n    private LinkedList<Integer> stackPop;\n    private int size;\n    public MyQueue() {\n        size = 0;\n        stackPop = new LinkedList<>();\n        stackPush = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        size++;\n        stackPush.add(x);\n    }\n    \n    public int pop() {\n        size--;\n        //移除队列开头的元素\n        if(!stackPop.isEmpty()) return stackPop.removeLast();\n        if(stackPush.isEmpty()) return -1;\n        while(!stackPush.isEmpty()) {\n            stackPop.addLast(stackPush.removeLast());\n        }\n        return stackPop.removeLast();\n    }\n    \n    public int peek() {\n        // 返回队列开头的元素\n        if(!stackPop.isEmpty()) return stackPop.getLast();\n        if(stackPush.isEmpty()) return -1;\n        while(!stackPush.isEmpty()) {\n            stackPop.add(stackPush.removeLast());\n        }\n        return stackPop.getLast();\n\n    }\n    \n    public boolean empty() {\n        return size == 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090160716","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        if(arr.length == 0 || arr == null){\n            return 0;\n        }\n        LinkedList<Integer> stack = new LinkedList<>();\n        for(int i = 0; i < arr.length; i++){\n            int temp  = -1;\n            while(!stack.isEmpty() && stack.getLast() > arr[i]){\n                temp = Math.max(temp,stack.getLast());\n                stack.removeLast();\n            }\n            if(temp !=-1){\n                stack.add(temp);\n            }else{\n                stack.add(arr[i]);\n            }\n        }\n        return stack.size();      \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091713641","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null || k==0  || head.next==null){\n            return head;\n        }\n        int num = 1;\n        // 形成一个环形链表\n        ListNode headTem = new ListNode();\n        headTem = head;\n        //寻找未节点\n        while(headTem.next!=null){\n            headTem= headTem.next;\n            num++;\n        }\n        if(num == k){\n            return head;\n        }\n        //形成 一个循环链表\n        headTem.next = head;\n  \n        ListNode l1 = head;\n        for(int i =1;i<=num-1-(k%num);i++){\n            l1 = l1.next;\n        }\n        ListNode res = l1.next;\n        l1.next = null;\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093006180","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094067670","body":"```java\nclass Solution {\n    static TreeNode build(int[] nums, int l, int r)\n    {\n        if(l > r) return null;\n        int k = (l + r) / 2;\n        TreeNode root = new TreeNode(nums[k]);\n        root.left = build(nums, l, k - 1);\n        root.right = build(nums, k + 1, r);\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int n = nums.length;\n        return build(nums,0,n - 1);\n    }\n    public TreeNode sortedListToBST(ListNode head) {\n        int k = 0;\n        ListNode p = head;\n        while(p != null)\n        {\n            k ++;\n            p = p.next;\n        }\n        int[] nums = new int[k];\n        p = head;\n        int t = 0;\n        while(p != null)\n        {\n            nums[t ++] = p.val;\n            p = p.next;\n        }\n        return sortedArrayToBST(nums);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094289140","body":"```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n\n        ListNode ha = headA;\n        ListNode hb = headB;\n\n        while(ha != hb) {\n            if(ha == null && hb == null) return null;\n            ha = ha == null ? headB:ha.next;\n            hb = hb == null ? headA:hb.next;\n        }\n        return ha;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094450441","body":"```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) return null;\n\n        ListNode s = head;\n        ListNode f = head.next;\n\n        while(f != null) {\n            s = s.next;\n            f = f.next;\n            if(f == null) return null;\n            f = f.next;\n            if(s == f) {\n                s = head;\n                f = f.next;\n                while(s != f) {\n                    s = s.next;\n                    f = f.next;\n                }\n                return s;\n            }\n        }\n        return null;\n        \n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tonylee017":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085338085","body":"#### 思路\n\n直接把k加到num[i]上，保留个位数在num[i]，k取为其他位数。\n\n#### 代码实现\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n```\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088864782","body":"#### 思路\n利用双栈进行模拟队列，stack_push作为输入的栈，保存所有元素，stack_pop作为输出的栈。\n\n#### 代码\nclass MyQueue:\n\n    def __init__(self):\n        # 使用两个栈. 一个用来push stack_push, 一个用来pop stack_pop.\n        self.stack_push = []\n        self.stack_pop = []\n\n    def push(self, x: int) -> None:\n        self.stack_push.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return -1\n        self.peek()\n        return self.stack_pop.pop()\n\n    def peek(self) -> int:\n        if not self.stack_pop:\n            while self.stack_push:\n                self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop[-1]\n\n    def empty(self) -> bool:\n        return not self.stack_push and not self.stack_pop\n\n#### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090416578","body":"#### 思路\n遍历一遍数组，动态判断到当前数字num为止最多能分出多少排序块，并保存每个排序块的最大值head。每遍历到下个数字num，动态判断前面所有的排序块是否成立，并更新所有排序块。\n\n#### 代码\n``` python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]:\n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n#### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094071438","body":"#### 解题思路\n先获取根节点，再利用分治方法构造左右子树。\n#### 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMid(left,right):\n            fast = slow = left\n            while fast!=right and fast.next!=right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n       \n        def buildTree(left,right):\n            if left == right:\n                return None\n            # 寻找根节点\n            mid = getMid(left,right)\n            # 构造根节点\n            root = TreeNode(mid.val)\n            # 构造左子树\n            root.left = buildTree(left,mid)\n            # 构造右子树\n            root.right = buildTree(mid.next,right)\n            return root\n        \n        return buildTree(head,None)\n```\n#### 复杂度分析\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094159819","body":"#### 解题思路\n使用双指针的方法。\n#### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        pA,pB = headA,headB\n        if pA == pB: return pA\n        while pA!=pB:\n            pA = pA.next\n            pB = pB.next\n            # 同时遍历完\n            if not pA and not pB:\n                return None\n            if not pA:\n                pA = headB\n            if not pB:\n                pB = headA\n        return pA\n```\n\n#### 复杂度分析\n- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094933698","body":"#### 解题思路\n使用双指针法求解\n#### 代码\n``` python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if slow == fast:\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        p =  head\n        while p != slow:\n            p = p.next\n            slow = slow.next\n        return p\n```\n#### 复杂度分析\n- 时间复杂度分析：O(n)\n- 空间复杂度分析：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youxucoding":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085341434","body":"### 思路\r\n\r\n模拟加法，类似链表两数相加那题，所以我使用的LinkedList。\r\n\r\n\r\n### 代码实现\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int vaild = 0;\r\n        int i = num.length-1;\r\n        while(i >= 0 || k > 0){\r\n            int cur = 0;\r\n            if(i < 0){\r\n                cur = (k % 10) + vaild;\r\n            }else if(k == 0){\r\n                cur = num[i] + vaild;\r\n            }else{\r\n                cur = num[i] + (k % 10) +vaild;\r\n            }\r\n            vaild = cur/10;\r\n            cur = cur % 10;\r\n            k = k / 10;\r\n            i--;\r\n            res.addFirst(cur);\r\n        }\r\n        if(vaild > 0){\r\n            res.addFirst(vaild);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086568629","body":"> 4月2日\n\n- 【day02】\n\n### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n难度简单218\n\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\n\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\n\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n```\n\n\n\n### 思路：\n\n1. 暴力解法：得到所有目标字符的下标，遍历字符串一一比较，获得最近距离\n2. 滑动窗口：按照目标字符重复出现的位置，将字符串划分为若干窗口，在窗口内就可以计算出当前下标与目标字符最近距离。\n\n### 代码实现：\n\n- 暴力解法：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> list = new ArrayList<>();\n        int res[] = new int[s.length()];\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        for(int j = 0;j < s.length();j++){\n            res[j] = Integer.MAX_VALUE;\n            for(Integer i : list){\n                res[j] = Math.min(res[j],Math.abs(j-i));\n            } \n        }\n        return res;\n    }\n}\n```\n\n- 滑动窗口：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int cur = 0;\n        int left = Integer.MAX_VALUE;\n        int right = -1;\n        int res[] = new int[s.length()];\n        while(cur < s.length()){\n            right++;\n            while((s.charAt(right) == c || right == s.length() - 1)&&cur <= right){\n               if((right == s.length() - 1) && (s.charAt(right) != c)){\n                   res[cur] = Math.abs(cur - left);\n                   cur++;\n               }else{\n                    res[cur] = Math.min(Math.abs(cur-left),Math.abs(cur-right));\n                    if(cur == right){\n                        left = cur;\n                    }\n                    cur++;\n                }\n                \n            }\n\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 暴力解法：\n  - 时间复杂度：O(m*n)\n  - 空间复杂度：O(n)\n- 滑动窗口：\n  - 时间复杂度：O(n)\n  - 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086783707","body":"> 4月3日\r\n\r\n- 【day03】\r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度  中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n### 思路：\r\n\r\n看到题目上的前缀和标签就尝试了使用差分数组思想，构建原数组（也就是本题中的栈）的差分数组。在差分数组目标区间起点增加值，在终点后一位减值。最后通过差分数组更新原数组。\r\n\r\n\r\n\r\n### 代码实现：\r\n\r\n```java\r\nclass CustomStack {\r\n    private int stack[];\r\n    private int top;\r\n    private int diff[];\r\n    public CustomStack(int maxSize) {\r\n        this.stack = new int[maxSize];\r\n        this.top = -1;\r\n        this.diff = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top > -1){\r\n            return stack[top--];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        diff[0] = stack[0];\r\n        for(int i = 1;i <= top;i++){\r\n            diff[i] = stack[i] - stack[i-1];\r\n        }\r\n        if(k > top+1){\r\n            diff[0] += val;\r\n        }else{\r\n        diff[0] += val;\r\n        diff[k] -= val;\r\n        }\r\n\r\n        stack[0] = diff[0];\r\n        for(int i = 1;i <= top;i++){\r\n            stack[i] = diff[i] + stack[i-1];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析：\r\n\r\n- 时间复杂度：O(N) N为题中方法 increment 参数k\r\n- 空间复杂度：O(N) N = maxSize\r\n\r\nps:使用差分数组思想不是最优解","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087489461","body":"> 4月3日\n>\n> - 【day03】\n\n#### [leetcode.394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n难度   中等\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n```java\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n**示例 2：**\n\n```java\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n```\n\n\n\n### 思路：\n\n使用栈辅助，数字字符也就是倍数需要一个栈维护，要重复的字符串需要一个栈维护，本题难点在于字符串中存在嵌套方括号，需要从里向外一层层抽丝剥茧一般解决问题，类似于递归，因此需要使用栈。\n\n细节：遍历字符串，每当遇到数字或字符记录到数字变量和字符串变量中，每个数字字符出现也意味着左括号的出现，每当遇到左括号时，数字变量和字符串变量压入相应的栈中，当遇到右括号时就是真正“解码”的时刻，当遍历到第一个右括号，此时计算的是 **最内层的结果** : 当前字符串变量重复刚刚入栈的倍数（也就是处于**栈顶的倍数**）再连接上当前左括号与前一个左括号中的字符串（**此字符串应在对应的字符串辅助栈顶**） 到此最内层括号中“解码”完毕，向外的每一层同理即可。\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\t\tDeque<Integer> num_stack = new LinkedList();\n        Deque<StringBuffer> string_stack = new LinkedList();\n        int num = 0;\n        StringBuffer res = new StringBuffer();\n        for(Character c : s.toCharArray()){\n            if(c == '['){\n                num_stack.push(num);\n                string_stack.push(res);\n                num = 0;\n                res = new StringBuffer();\n            }else if(c == ']'){\n                StringBuffer temp = new StringBuffer();\n                Integer cur_num = num_stack.pop();\n                for(int i = 0;i < cur_num;i++){\n                    temp.append(res);\n                }\n                res = string_stack.pop().append(temp);\n            }else if(c >= '0' && c <= '9'){\n             \tnum = num * 10 + Integer.parseInt(c+\"\");\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088233081","body":"\n> 4月5日 【day05】\n\n### [leetcode.232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n难度  简单\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n- ``void push(int x)`` 将元素 x 推到队列的末尾\n- `int pop()` 从队列的开头移除并返回元素\n- `int peek()` 返回队列开头的元素\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n**说明：**\n\n- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**示例 1：**\n\n```java\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\n\n\n### 思路：\n\n题目中明确需要使用**两个栈** 实现队列，队列的特点是先进先出，队尾进队头出，队尾进入我们可以使用压栈实现（栈头即队尾），关键点在于队头出队怎么实现？\n\n使用两个栈，一个称为stack_tail 即栈头是队尾，另一个成为stack_head 即栈头是队头，实现push() 直接向stack_tail压栈即可，当实现pop()时，将stack_tail栈中元素逐个弹出，并逐个压入stack_head，此时``stack_head.pop()``将弹出队头元素，再将此栈逐个弹出并压入stack_tail中，至此pop实现完成，stack_tai栈中的栈底元素（即队头）已经弹出。\n\n\n\n### 代码实现：\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack_head;\n    private Stack<Integer> stack_tail;\n    public MyQueue() {\n        stack_head = new Stack<Integer>();\n        stack_tail = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stack_tail.push(x);\n    }\n    \n    public int pop() {\n        int res = 0;\n        if(!stack_tail.empty()){\n            while(!stack_tail.empty()){\n                stack_head.push(stack_tail.pop());\n            }\n            res = stack_head.pop();\n            while(!stack_head.empty()){\n                stack_tail.push(stack_head.pop());\n            }\n        }\n        return res;\n    }\n    \n    public int peek() {\n        int res = 0;\n        if(!stack_tail.empty()){\n            while(!stack_tail.empty()){\n                stack_head.push(stack_tail.pop());\n            }\n            res = stack_head.peek();\n            while(!stack_head.empty()){\n                stack_tail.push(stack_head.pop());\n            }\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return stack_tail.empty();\n    }\n}\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：\n  - push：O(1)\n  - pop：O(N)\n  - peek：O(N)\n  - empty：O(1)\n- 空间复杂度：\n  - push：O(1)\n  - pop：O(N)\n  - peek：O(N)\n  - empty：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090281796","body":"\n#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n难度困难119\n\n*这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为`2000`，其中的元素最大为`10**8`。*\n\n`arr`是一个可能包含**重复元素**的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n**示例 1:**\n\n```java\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n```\n\n### 思路：\n\n使用单调栈\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091076135","body":"#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n难度  中等\n\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n\n```java\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n```\n\n\n\n### 思路：\n\n快慢指针可解，思路与**删除倒数第n个节点**大致相似，本题将每个节点向右移动k个位置，可看作将最后k个节点断掉并重新接到头部位置，所以只要找到倒数第k-1位置，将其后的节点“断开”，其中细节：当k大于链表长度时，可采用取模的方法。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        int len = 0;\n        ListNode cur = head;\n        while(cur != null){\n            len++;\n            cur = cur.next;\n        }\n        if(k == 0 || k % len == 0){\n            return head;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        for(int i = 0;i < k % len;i++){\n            fast = fast.next;\n        }\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092388533","body":"> 4月8日\n>\n> 【day08】\n\n#### [leetcode.24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n难度    中等\n\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n```java\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n### 思路：\n\n递归解法，类似与k个一组反转链表，本题可看作为两个一组反转链表，只要做过k个一组反转链表，这题基本就没什么问题了。\n\n### 代码实现：\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode a = head;\n        ListNode b = head.next.next;\n        ListNode newHead = swap(a,b);\n        a.next = swapPairs(b);\n        return newHead;\n    }\n    //反转相邻的两个节点\n    public ListNode swap(ListNode a,ListNode b){\n        ListNode newHead = a.next;\n        a.next.next = a;\n        a.next = null;\n        return newHead;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093895456","body":"> 4月9日\n>\n> 【day09】\n\n#### [leetcode.109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n难度  中等\n\n给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差不超过 1。\n\n \n\n**示例 1:**\n\n![img](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n\n```java\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n```\n\n\n\n### 思路：\n\n由于BST的性质可知，BST的中序遍历是单调递增的，题目中也说明了元素顺序递增，这样一来中序遍历构造二叉树即可，额外使用left,right,mid 三个元素规划左右子树空间，这样便免去寻找根节点的过程，借助一个辅助变量在链表中由前向后取值即可(链表顺序即为中序顺序)。\n\n\n\n### 代码实现：\n\n```java\nclass Solution {\n    ListNode node;\n    public TreeNode sortedListToBST(ListNode head) {\n        node = head;\n        ListNode cur = head;\n        int len = 0;\n        while(cur != null){\n            len++;\n            cur = cur.next;\n        }\n        return traverse(0,len-1);\n    }\n    TreeNode traverse(int left,int right){\n        if(left > right){\n            return null;\n        }\n        int mid = (left+right)/2;\n        TreeNode root = new TreeNode();\n        root.left = traverse(left,mid-1);\n        root.val = node.val;\n        node = node.next;\n        root.right = traverse(mid+1,right);\n        return root;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094285021","body":"> 4月10日\n>\n> 【day10】\n\n#### [leetcode.160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n难度  简单\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**自定义评测：**\n\n**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：\n\n- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`\n- `listA` - 第一个链表\n- `listB` - 第二个链表\n- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数\n- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。\n\n \n\n**示例 1：**\n\n[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n\n```java\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n\n\n### 思路：\n\n双指针解法，假设两条链表相交，如果两个指针齐头并进那么一定会在相交点相遇，如果a指针遍历完A链表后从B链表头部继续出发，同样b指针遍历完从A链表头部出发，你会发现在相交前两指针已经齐头并进了。\n\n### 代码实现：\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n        if(headA == null && headB ==null){\n            return null;\n        }\n        while(nodeA != null || nodeB != null){\n            if(nodeA == nodeB){\n                return nodeA;\n            }\n            nodeA = nodeA == null ? headB : nodeA.next;\n            nodeB = nodeB == null ? headA : nodeB.next;\n        }\n        return null;\n    }\n}\n```\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094969320","body":"\n>4月11日\n>\n>【day11】\n\n#### [leetcode.142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n难度中等1511\n\n给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n**不允许修改** 链表。\n\n\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\n```java\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n\n\n### 思路：\n\n本题有一个隐藏小技巧，假设链表存在环，使用快慢指针，当快指针与慢指针相遇时，定义一临时指针指向头部，与慢指针共同移动，必定会在成环节点相遇，具体数学推导移步官方题解\n\n\n\n### 代码实现：\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                ListNode res = head;\n                while(true){\n                    if(res == slow){\n                        return res;\n                    }\n                    res = res.next;\n                    slow = slow.next;\n                }\n            }\n            \n        }\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析：\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forestie9":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085353261","body":"### Idea\nConvert int item in list to get the first value, and add up with k. Then convert the final value to item in a list.\n\n### Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = ''.join([str(i) for i in num])\n        summ = str(int(s) + k)\n        return [int(i) for i in summ]\n```\n### Complexity\nTime O(n) <br>\nSpace O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086719398","body":"## Ideas\nUse addition array to make `increment` O(1)\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.len = maxSize\n        self.s = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.s) < self.len:\n            self.s.append(x)\n            self.inc.append(0)\n        \n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.s.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n```\n## Complexity\nO(1) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086905383","body":"## Ideas\nUse stack to track letter and count, reset values in every left bracket\n## Code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        num = 0\n        string = ''\n        stack = []\n        for i in s:\n            if i.isdigit():\n                num = num*10 + int(i)                                \n            elif i == '[':\n                stack.append((string, num))\n                string = ''\n                num = 0\n            elif i == ']':\n                pre, k = stack.pop()\n                string = pre + k * string\n            elif i.isalpha():\n                string += i\n        return string\n```\n## Complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087860594","body":"### Ideas\nUse two stacks. Push to one stack, in peek and pop, reversely push element in first stack to second to get O(1).\n### Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.top = []\n        \n    def push(self, x: int) -> None:\n        self.stack.append(x)        \n\n    def pop(self) -> int:\n        self.peek()\n        return self.top.pop()\n        \n    def peek(self) -> int:\n        if not self.top:\n            while self.stack:\n                self.top.append(self.stack.pop())\n        return self.top[-1]\n        \n    def empty(self) -> bool:\n        return not self.stack and not self.top \n```\n### Complexity\nO(1) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089300643","body":"不会做，看了discussion，用preSum来比较，如果面试遇到，应该怎么个思路啊？\n### Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        org, sort = 0, 0\n        arr_sort = sorted(arr)\n        ans = 0\n        for i in range(len(arr)):\n            org += arr[i]\n            sort += arr_sort[i]\n            if org == sort:\n                ans += 1\n        return ans\n```\n### Complexity  \nO(n) time and space\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090733255","body":"### Ideas\nUse two nodes, one to cycle the list, and another to check the movement of k%n steps\n### Code\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n        if not head.next: return head\n        cnt = 1\n        slow, fast = head, head\n        while fast.next:\n            fast = fast.next\n            cnt += 1\n        fast.next = head # circle the list\n        for i in range(cnt - k%cnt - 1):\n            slow = slow.next\n        new_head = slow.next    \n        slow.next = None\n        return new_head\n```\n### Complexity\nO(n) time, O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092166031","body":"### Ideas\nUse recursion to swap every two nodes\n### Code\n```python\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]: \n        if not head or not head.next: return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head            \n        return newHead\n```\n### complexity\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093525716","body":"### Ideas\nUse the list middle value as root, then recursively build the tree. Note the base case where only one element left in the recursion and should return node.\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        value = []\n        while head:\n            value.append(head.val)\n            head = head.next    \n\n        def convertBST(l, r):\n            if l > r: return None\n            mid = (l + r) // 2\n            node = TreeNode(value[mid])\n            \n            if l == r: return node # base case\n            \n            node.left = convertBST(l, mid - 1)\n            node.right = convertBST(mid + 1, r)\n            return node\n            \n        return convertBST(0, len(value)-1)\n```\nO(n) time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094150303","body":"### Ideas\n太赞了，相交的尾巴长度一样，所以俩个list绕回intersect一圈长度应该相等\n\n```python\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        # the \"tails\" is of the same length\n        nodeA = headA\n        nodeB = headB\n        while nodeA != nodeB:\n            nodeA = nodeA.next if nodeA else headB\n            nodeB = nodeB.next if nodeB else headA\n        return nodeA\n```\n### Complexity  \nO(n+m) time and O(1) space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094357305","body":"### Ideas\nUse slow and fast node to find intersect point, then adjust the speed to find the start of cycle.\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next    \n            fast = fast.next.next\n            if slow == fast:\n                slow = head\n                while slow != fast:\n                    slow = slow.next\n                    fast = fast.next\n                return slow                \n        return None\n```\n### Complexity\nO(n) Time, O(1) space","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houmk1212":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085369488","body":"# 思路\n用数组模拟加法运算，注意进位和数组的长度。\n\n# 代码\npublic class ClockIn20220401 {\n    public static void main(String[] args) {\n  \n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        if (i != j) {\n            nums[i] = nums[i] ^ nums[j];\n            nums[j] = nums[i] ^ nums[j];\n            nums[i] = nums[i] ^ nums[j];\n        }\n    }\n    public static int[] solution(int[] nums, int k) {\n        int upper = 0;\n        int exp = 1;\n        int n = nums.length;\n        int kLeng = 0;\n        // 先找最大的范围\n        for (int e = 1; k / e > 0; e *= 10) {\n            kLeng ++;\n        }\n        int maxLeng = Math.max(n , kLeng);\n        int[] result = new int[maxLeng + 1];\n        int i = 0;\n        int j = n-1;\n        while (i < n / 2) {\n            swap(nums, i , j);\n            i ++;\n            j --;\n        }\n        i = 0;\n        while (i < maxLeng || upper == 1) {\n            int left = i < n ? nums[i] : 0;\n            int right = k / exp > 0 ? (k / exp) % 10 : 0;\n            result[i] = (left + right + upper) % 10;\n            upper = left + right + upper >= 10 ? 1 : 0;\n            exp *= 10;\n            i ++;\n        }\n        int[] ans = new int[i];\n        int p = 0;\n        for (int q = i - 1; q >= 0; q--) {\n            ans[p ++] = result[q];\n        }\n        return ans;\n    }\n}\n\n# 复杂度\n时间复杂度: O(n + e)   n是数组的长度， e是k的位数;\n\n空间复杂度：O(max(n,e))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086508946","body":"# 思路\r\n因为是找左右侧距离目标字符的最短距离，想到类似单调栈的找右侧最小或者最大值的做法。左侧的目标字符的下表可以用一个变量存，右侧的目标距离可以用单调栈来得到。当目标元素入栈时，弹出所有栈中非目标字符，并得到他们的结果。\r\n# 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] ans = new int[s.length()];\r\n        int pre = - 1;\r\n        for (int i = 0 ; i < s.length(); i ++) {\r\n            if (s.charAt(i) == c) {\r\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\r\n                    int p = stack.pop();\r\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\r\n                }\r\n                pre = i;\r\n            }\r\n            stack.push(i);\r\n        }\r\n        while (!stack.isEmpty()) {\r\n            int p = stack.pop();\r\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度： 每个字符串s中的字符都要入栈一次，出栈一次，所以时间复杂度是O（N）， N是字符串的长度。\r\n空间复杂度：栈的大小，是O（N）。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086760827","body":"# 思路\n需要实现方便按索引存取的栈结构，所以用数组。\n\n# 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top >= stack.length) return;\n        stack[top ++] = x;\n    }\n\n    public int pop() {\n        if (top == 0) return -1;\n        int peek = stack[top - 1];\n        top --;\n        return peek;\n    }\n\n    public void increment(int k, int val) {\n        int tmp = Math.min(top, k);\n        for (int i = 0; i < tmp; i++) {\n            sta ck[i] += val;\n        }\n    }\n}\n```\n\n# 复杂度分析\n时间复杂度： push和pop  都是O(1)  inc是O(K)\n\n空间复杂度： O(N)  N是数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087030986","body":"# 思路\n类似于括号匹配。遇到数字、左括号、字母入栈，遇到右括号，把到上一个左括号之间的内容弹出，并重复最后弹出的数字次数，并将结果重新入栈。最后结果会放在栈中。\n\n# 代码\n```\nclass Solution {\n    public boolean isNumber(char c) {\n        return c >= '0' && c <= '9';\n    }\n\n    public boolean isWord(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    public String decodeString(String s) {\n        int index = 0;\n        Stack<String> stack = new Stack();\n        int n = s.length();\n        while (index < n) {\n            if (isNumber(s.charAt(index))) {\n                int to = s.indexOf('[', index);\n                stack.push(s.substring(index, to));\n                index = to - 1;\n            } else if (isWord(s.charAt(index))) {\n                stack.push(s.substring(index, index + 1));\n            } else if (s.charAt(index) == '[') {\n                stack.push(\"[\");\n            } else { // s.charAt(index) == ']'\n                String tmp = \"\";\n                while (!stack.peek().equals(\"[\")) {\n                    tmp = stack.pop() + tmp;\n                }\n                stack.pop(); //弹出'['\n                int times = Integer.parseInt(stack.pop()) ;  // 弹出数字 也就是重复次数\n                String result = \"\";\n                for (int i = 0; i < times; i++) {\n                    result += tmp;\n                }\n                stack.push(result);\n            }\n            index++;\n        }\n        String ans = \"\";\n        while (!stack.isEmpty()) {\n            ans = stack.pop() + ans;\n        }\n        return ans;\n    }\n}\n```\n\n# 复杂度\n时间复杂度：O(N)， N是字符串长度\n\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088196696","body":"# 思路\n使用两个栈，来实现队列的操作；入队时候，可以不管，直接入栈1。出队的时候，为了获得栈低的元素，需要把栈1中的元素出栈，并依次入栈2.  当栈2不空的时候，出队需要从栈2中弹栈。\n\n# 代码\n```\nclass MyQueue {\n    private ArrayDeque<Integer> stack1;\n    private ArrayDeque<Integer> stack2;\n    public MyQueue() {\n        stack1 = new ArrayDeque<Integer>();\n        stack2 = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int ans = stack2.pop();\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return ans;\n    }\n\n    public int peek() {\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int ans = stack2.peek();\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return ans;\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n# 复杂度\n时间复杂度：入队O(1)  peek和pop  O(N)\n\n空间复杂度：O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089704315","body":"# 思路\n参考了官方题解中的思路一，当前数组的最终期望是排序后的数组。 那么一个块中，需要和期望块中具有相同的元素个数。 还需要继续学习大家的做法\n\n# 代码\n```\nclass Solution768 {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\n        int[] tmp = arr.clone();\n        Arrays.sort(tmp);\n        int ans = 0;\n        int flag = 0;\n        for (int i = 0; i < n; i ++) {\n            hashMap.put(arr[i], hashMap.getOrDefault(arr[i], 0) + 1);\n            if (hashMap.get(arr[i]) == 0)\n                flag --;\n            if (hashMap.get(arr[i]) == 1)\n                flag ++;\n\n            hashMap.put(tmp[i], hashMap.getOrDefault(tmp[i], 0) - 1);\n            if (hashMap.get(tmp[i]) == 0)\n                flag --;\n            if (hashMap.get(tmp[i]) == - 1)\n                flag ++;\n\n            if (flag == 0)\n                ans ++;\n        }\n        return ans;\n    }\n}\n```\n\n# 复杂度\n时间复杂度O(nlogn)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091034465","body":"# 思路\n找到倒数第k个节点（双指针），作为新链表的头节点。原来的头节点，放到尾节点之后。注意处理k大于链表长度的情况。\n\n# 代码\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0)\n            return head;\n        int len = 0;\n        ListNode fast = head;\n        while (len < k && fast != null) {\n            fast = fast.next;\n            len ++;\n        }\n        if (len == k && fast == null)\n            return head;\n        if (len < k) {  // k比链表长度长\n            len = k % len;\n            if (len == 0) {\n                return head;\n            }\n            fast = head;\n            while (len > 0) {\n                len --;\n                fast = fast.next;\n            }\n        }\n        ListNode slow = head;\n        ListNode preSlow = null;\n        ListNode preFast = null;\n        while (fast != null) {\n            preFast = fast;\n            preSlow = slow;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        if (preFast != null && preSlow != null) {\n            preSlow.next = null;\n            preFast.next = head;\n        }\n\n        return slow;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度： O(N)  N是链表长度\n- 空间复杂度： O(1)  除了题目给的链表结构外，没有额外的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092374308","body":"# 思路\n用递归来求解。相邻两个节点交换。那么，也就是head和head.next交换，head.next的后面是交换后的链表就可以了。\n\n# 代码\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next.next;\n        ListNode pre = head;\n        head = head.next;\n        head.next = pre;\n        pre.next = swapPairs(next);\n        return head;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N)  N是链表的长度\n- 空间复杂度: O(N)  递归调用的栈空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093567389","body":"## 思路\n根据二叉搜索树的性质，升序链表的中间节点一定是一个局部二叉搜索子树的根。因此，可以先找到链表的中间节点，然后再递归构建树结构。\n\n## 代码\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return binaryCreate(head, null);\n    }\n    public TreeNode binaryCreate(ListNode l, ListNode r) {\n        if (l == null || l == r)\n            return null;\n        if (l.next == null || r == l.next)\n            return new TreeNode(l.val);\n        ListNode slow = l;\n        ListNode fast = l;\n        while (fast != r && fast.next != r) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = binaryCreate(l, slow);\n        root.right = binaryCreate(slow.next, r);\n        return root;\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(NlogN)\n- 空间复杂度： O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094159739","body":"# 思路\n相交链表，用双指针就可以。\n\n# 代码\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null)\n            return null;\n        ListNode p = headA;\n        ListNode q = headB;\n        while (p != q) {\n            if (p == null)\n                p = headB;\n            if (q == null)\n                q = headA;\n            if (p == q)\n                break;\n            p = p.next;\n            q = q.next;\n        }\n        return p;\n    }\n\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N) . N是两个链表的长度和\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094479822","body":"# 思路\nFloyd判环算法，设置快慢指针，可以判断链表是否有环，且能得到入环的第一个节点。\n\n# 代码\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null)\n            return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast)\n                break;\n        }\n        if (fast == null || fast.next == null)\n            return null;\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n\n# 复杂度\n- 时间复杂度: O(N); N是链表长度\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelving-611":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085375480","body":"### 思路\n\n思路1: 把A转化成数字. 再跟K求和. 最后把输出结果转化成数组. (这种方法感觉没什么意思, 就是来回调用几个函数)\n思路2: 双指针. 从A, K的\"尾巴\"开始, 从后往前移动, 然后每次把得到的和放进数组里(不要忘记carry). 返回数组颠倒过来之后的结果. 注意: 时刻要注意carry. 如果双指针最后走到头, 还需要考虑carry的情况. \n\n### 代码\n\n思路2\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        carry = 0\n        i, j = len(A) - 1, len(str(K)) - 1\n        res = []\n\n        while i >= 0 or j >= 0: \n            val_1 = A[i] if i >= 0 else 0\n            val_2 = int(str(K)[j]) if j >= 0 else 0\n            i -= 1\n            j -= 1\n            val = val_1 + val_2 + carry\n            carry = val // 10\n            val %= 10\n            res.append(val)\n\n        if carry: \n            res.append(carry)\n        return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(len(A), len(str(K)))) 也就是 O(A, str(K)之间较长的长度)\n- 空间复杂度：O(max(len(A), len(str(K)))) . 由于算法不是原地算法, 所以需要重新开辟空间. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658104","body":"# 思路\n分别记录两个数组: \n1. 当前位置到右边最近的c的距离\n2. 当前位置到左边最近的c的距离\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        occurrence = deque()\n        for idx, i in enumerate(s): \n            if i == c: \n                occurrence.append(idx)\n\n        # print(occurrence)\n        occ_1, occ_2 = copy.deepcopy(occurrence), copy.deepcopy(occurrence)\n\n        dis_right = []  # 当前距离右边最近的c的距离\n        right_pos = occurrence[0]\n        for idx, char in enumerate(s): \n            if char == c: \n                right_pos = occ_1.popleft()\n                dis_right.append(0)\n            else: \n                dis_right.append(abs(idx - occurrence[0]))\n        # print(dis_right)\n\n        dis_left = []  # 当前距离左边最近的c的距离\n        left_pos = inf\n        for idx, char in enumerate(s): \n            if char == c: \n                left_pos = occ_2.popleft()\n                dis_left.append(0)\n            else: \n                dis_left.append(abs(idx - left_pos))\n\n        res = []\n        for i in range(len(dis_left)): \n            res.append(min(dis_left[i], dis_right[i]))\n        # print(dis_left)\n        return res\n\n```\n# 复杂度\n时间. 空间复杂度: 都是O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086705756","body":"## 思路\r\n模拟栈操作. \r\n\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n```\r\n## 复杂度分析\r\n时间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(N)\r\n空间复杂度: \r\n`push`: O(1)\r\n`pop`: O(1)\r\n`increment`: O(1). 由于是原地算法所以不占空间. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086957495","body":"## 思路\n用栈来解决. 思路: 从头到尾遍历s, 只要当前不是`]`, 就往stack里面放. 当遇到`]`时, 开始pop, 在遇见stack里面的数字之前, 一直往外弹并且记录下来. 碰到数字后, 把得到的结果重新stack里. 最后把stack里面的值转化成字符串. \n\n重点1 🔴 : 怎么想到用栈来解决这个问题? \nTODO: 没有一个方法论. 只是手动模拟的时候感觉用stack容易些. \n\n\n重点2 🔴 : 一说到用栈, 我们接下来就要想 **什么时候push?** **什么时候pop?**\n1.  **什么时候push?** : 只要当前不是`]`, 就往stack里面放 (细节: 需要处理类似`100[leetcode]`里面的`100`)\n2.  **什么时候pop?**: 当前遇到`]`. \n\n**这道题的思路不重要, 只要动手试一试. 人脑是怎么得出答案的, 我们只需要把人脑的步骤翻译成代码就好了**\n\n## 代码\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        stack = []\n        for i in range(len(s)): \n            if s[i] == \"]\":\n                tmp = []\n                while not stack[-1].isnumeric(): \n                    cur = stack.pop()\n                    if cur == \"[\": \n                        continue\n                    else: \n                        tmp.append(cur)\n                times = stack.pop()\n                tmp_str = \"\".join(tmp[::-1])\n                for _ in range(int(times)): \n                    stack.append(tmp_str)\n            else: \n                # 专门处理 100[leetcode] 里面的\"100\"\n                if stack and s[i].isnumeric() and stack[-1].isnumeric(): \n                    tmp = stack.pop()\n                    stack.append(tmp + s[i])\n                else: \n                    stack.append(s[i])\n        return \"\".join(stack)\n```\n## 复杂度分析\n### 时间复杂度\n算法需要从头到尾遍历一遍. O(字符串长度)\n### 空间复杂度\n因为用了栈, 所以最差情况我们需要存全量的字符到stack中. 比如 `s = \"abcd\"`. O(字符串长度)\n\n## 反思\n1. 这个用例是真的绝了\"`100[leetcode]`\"! 🫡  学到了! 在push时不能无脑往里push. \n2. 栈操作push pop的逻辑中, 细节是魔鬼. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087814440","body":"## 思路\r\n> Tip: stack其实是一个**操作受限**的数据结构. 既只能对最后一个数(i.e.: 栈顶)进行pop, append操作. 如果我们解题用到list时, 操作stack[0]就有点不讲武德了. \r\n\r\n\r\n使用两个栈. 一个用来push `stack_push`, 一个用来pop `stack_pop`. \r\n\r\n\r\n1️⃣ push策略: 直接往stack_push里面append. 理论上, 你想怎么push都可以, 只要后面的pop, peek方法都正确就行. \r\n\r\n\r\n2️⃣ pop 策略: stack_pop里面的最后一个数 (也就是栈顶)一定是queue的第一个数. 所以我们需要确保`stack_pop`里面时刻\"有数可弹\". \r\n1. 如果`stack_pop`不为空, 我们就把最后一个(i.e.: 栈顶元素)取出来. \r\n2. 如果stack_pop为空, 我们就需要把stack_push里面的数一边弹出, 一边弹入. 操作结束后, 把`stack_pop`里面最后一个(i.e.: 栈顶元素)pop出来并且返回. \r\n\r\n\r\n3️⃣ peek策略: 核心理念跟pop相同. 我们需要确保`stack_pop`里面时刻\"有数可弹\". \r\n思路与`pop()`相同\r\n\r\n## 代码\r\n```python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        res = self.stack_pop.pop()\r\n        return res\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\npush - O(1)\r\npop  - max(O(1) or O(当前stack_push的大小)) = O(N)\r\npeek - 跟pop一样 O(N)\r\n### 空间复杂度\r\n用到了两个stack. O(最终队列的大小)\r\n\r\n## 反思\r\n🫡 不过不知道这道题的实际意义是什么? 没有办法把题目跟生产环境联系在一起. \r\n\r\n题解中有提到: \r\n>其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n\r\n> 当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n\r\nTODO: 可能需要改一下自己的code. 我的代码只有在pop, peek时, 才会进行\"倒腾\"","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089182175","body":"## 思路 \n思路来自于, 看到了\"前置知识\"里面的\"`单调栈`\"\n🤔 个人觉得难点是如何想到这道题需要使用\"单调栈\"\n\n举例: arr=[2,1,3,4,4]\n题目说,我们可以把arr分成两部分\nblock1: [2,1]\nblock2: [3,4,4] \n每个block排序 + 合并就变成 [1,2][3,4,4] 正好就是arr从大到小排好的顺序[1,2,3,4,4]\n\n根据上面, 我们\"很容易\"就能找到一个规律. 我们可以把一个arr分成两块, 当**前面的block的最大值 <= 后面紧接着的block的最小值**. \n于是, 我们就可以想到用两个stack. 来记录当前位置的最大值, 以及最小值\n`l_r_cur_max`: 从左到右看, 当前的最大值\n`r_l_cur_min`: 从右向左看, 当前最小值. \n所以上面的例子可以得到\n[2,1,3,4,4]\n`l_r_cur_max`: 2,2,3,4,4 其中, l_r_cur_max[1] = 1 代表从0到当前位置, 最大的值为1\n`r_l_cur_min`: 1,1,3,4,4  其中, r_l_cur_min[2] = 3 代表从数组最末尾到当前位置, 最小的值为3\n\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        l_r_cur_max, r_l_cur_min = [0 for _ in range(len(arr))], [0 for _ in range(len(arr))]\n        cur_max = -inf\n        for i in range(len(arr)): \n            if arr[i] > cur_max: \n                cur_max = arr[i]\n            l_r_cur_max[i] = cur_max\n\n        cur_min = inf\n        for j in range(len(arr) - 1, -1, -1): \n            if arr[j] < cur_min: \n                cur_min = arr[j]\n            r_l_cur_min[j] = cur_min\n        # print(l_r_cur_max, r_l_cur_min)\n\n        break_point_cnt = 0\n        for i in range(len(arr) - 1): \n            if l_r_cur_max[i] <= r_l_cur_min[i + 1]: \n                break_point_cnt += 1\n        # print(break_point_cnt)\n        return break_point_cnt + 1\n```\n## 复杂度分析\n### 时间复杂度\nO(n): 算法是从头到尾遍历两遍\n### 空间复杂度\nO(n): 算法是需要连个额外的栈空间来储存当前最大/最小值.\n\n## 反思\n**如何联系到生产环境**?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090685544","body":"## 思路\r\n> 被官方示例带节奏了. 以为要走一遍for循环,然后每次移动一个节点.谁知道只要保证最后结果对就行. \r\n\r\n实际上k代表的是将倒数第k个节点连根拔起, 然后接到最前面. \r\n注意: 如果k太大, 我们要取 k= (k mod 节点数)\r\n**例子** : 如果将1->2->3->4->5->NULL 翻转六次, 就相当于把最后一个放到最前面. \r\n\r\n那么我们就需要抓好两个重点: \r\n1. 谁是新的head? \r\n2. 谁是新的tail? \r\n\r\n在纸上画一画就能找到规律, 将头指针移动 节点数 - k % 节点数 - 1次 就能移动到新的tail. 那么新的tail.next就是新的head. \r\n另外为了确保不成环, 我们需要新的tail.next = None\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head: return None\r\n\r\n        tail = head\r\n        length = 1\r\n        while tail.next: \r\n            tail = tail.next\r\n            length += 1\r\n\r\n        tail.next = head\r\n\r\n        ptr = head\r\n        for _ in range(length - k % length - 1): \r\n            ptr = ptr.next\r\n\r\n        head = ptr.next\r\n        ptr.next = None\r\n        return head\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\nO(N). N是链表的长度. \r\n### 空间复杂度\r\nO(1)没有用到额外空间. \r\n\r\n## 反思\r\n1. 以后做题时要确定输出结果是什么. 同时思路不能被给出的例子带跑偏. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092088651","body":"## 思路\n需要实用虚拟节点. 然后画图模拟一遍就能有思路了. \n## 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        dummy.next = head\n        pre = dummy\n        cur = head\n\n        while cur and cur.next: \n            nxt = cur.next.next \n            pre.next = cur.next\n            cur.next.next = cur\n            cur.next = nxt\n\n            pre = cur\n            cur = nxt\n\n        return dummy.next\n```\n## 复杂度分析\n### 时间复杂度\nO(链表长度)\n### 空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093540722","body":"## 思路\r\n线索: BST + 高度平衡. 意味着左右两边的节点个数一致. 自然想到用递归的解法, \r\n\r\n递归函数的定义: 返回一个高度平衡的BST. \r\n\r\n递归函数的思路: 先找到中间点, 递归地把中间点的左边 接到中间点的left. 把中间点的右边 接到中间点的right. \r\n\r\n易错点: 每次递归调用时, 左侧的部分需要\"剪断\". 既, 应该剪断左侧部分与当前中间点的联系. `pre.next = None` 不然会进入死循环. \r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head: \r\n            return None\r\n        if not head.next: \r\n            return TreeNode(head.val)\r\n        # Find mid first\r\n        slow, fast = head, head\r\n        dummy = TreeNode()\r\n        dummy.next = head\r\n        pre = dummy\r\n        while fast and fast.next: \r\n            pre = pre.next\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        # Slow is mid or left_mid\r\n        root = TreeNode(slow.val)\r\n        pre.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n\r\n        return root\r\n```\r\n## 复杂度分析\r\n### 时间复杂度\r\nO(NlogN) - 每一层是操作数N * 层数logN \r\n### 空间复杂度\r\nO(logN): 递归树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094111781","body":"## 思路\n简单思路就是走完自己的路去走别人的路. 可以想象成把两条路拼接在一起. 所以两个人走的路总是一样的. 如果不想交那么最后一定是走到None. \n## 代码\n```python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a or b: \n            if a and a == b: \n                return a\n            a = a.next if a else headB\n            b = b.next if b else headA\n            \n\n        return None\n```\n## 复杂度分析\n### 时间复杂度\nO(两个链表长度和)\n### 空间复杂度\nO(1)\n## 反思\n1. 最开始提交时, 把判断条件放在后面了, 导致只有1个节点的情况直接报错. 想想也对, 如果把判断条件放在后面, 就会把最最最开始的情况跳过. \n```python\nif a and a == b: \n  return a\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094455210","body":"## 思路\n一个典型的脑筋急转弯题目. 先用快慢指针找到相遇点, 再根据数学推导找到规律, 既, 再次用双指针, 从头再开一个指针, 同时跟当前相遇的指针同时走一步, 相遇点就是最终的答案. \n## 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head \n\n        while fast and fast.next: \n            slow = slow.next\n            fast = fast.next.next\n\n            if slow == fast: \n                break\n\n        if not fast or not fast.next: \n            return None\n\n        ptr = head\n        while True: \n            if ptr == slow: \n                return ptr\n            ptr = ptr.next\n            slow = slow.next\n```\n## 复杂度分析\n### 时间复杂度\nO(N)\n### 空间复杂度\nO(1)\n## 反思\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lqyt2012":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085378454","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\n```python\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086634529","body":"## 思路\n两次遍历字符串，取其中较短的距离作为返回值\n## 代码\n```python\nclass Solution:\n    def find_smallest_dist(self, s:str, c:str) -> List[int]:\n         nearest_dist = len(s)\n         result = [0]*len(s)\n         for i in range(len(s)):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = nearest_dist\n         nearest_dist = len(s)\n         for i in range(len(s)-1, -1, -1):\n             nearest_dist = 0 if s[i] == c else nearest_dist + 1\n             result[i] = min(nearest_dist, result[i])\n         return result\n```\n## 复杂分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086864051","body":"## 思路\n用数组来模拟栈，因为increment函数涉及到随机读取\n## 代码\n```python\nclass CustomStack:\n    def __init__(self, Max_Size=None):\n        self.stack = []\n        self.size = Max_Size\n        self.length = len(self.stack)\n    \n    def push(self, val:int) -> None:\n        if self.length < Max_Size:\n            self.stack.append(val)\n            self.length += 1\n        return None\n    \n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop(-1)\n        return -1\n    \n    def increment(self, k:int, val:int) -> None:\n        if self.length > 0:\n            for i in range(min(k,self.length)):\n                self.stack[i] += val\n        return None\n```\n## 负责度分析\n空间复杂度：O(N)  \n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087601018","body":"## 思路\n左边中括号之前出现的数字字符是倍数，因为括号可能嵌套，所以需要倍数栈，用于存储倍数。右边括号出现时，从倍数栈去除栈顶元素，用于重复字符串。\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        number_stack = []\n        encoded_string_stack = []\n        number_string = ''\n        result = ''\n        encoded_string = ''\n        for char in s:\n            if char in '0123456789':\n                number_string += char\n            elif 'a' <= char and char <= 'z':\n                encoded_string += char\n            elif char == '[':\n                number_stack.append(int(number_string))\n                number_string = ''\n                encoded_string_stack.append(encoded_string)\n                encoded_string = ''\n            else:\n                number = number_stack.pop()\n                temp_string = encoded_string_stack.pop()\n                encoded_string = temp_string + number * encoded_string\n        result += encoded_string\n        return result\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088693712","body":"## 思路\n用两个栈模拟队列，stack模拟队尾，进行push，在队尾添加元素。help_stack模拟队头，用于peek操作和pop操作，查看队头和队头出队。\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if self.help_stack:\n            return self.help_stack.pop()\n        else:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            return self.help_stack.pop()\n\n\n    def peek(self) -> int:\n        if self.help_stack:\n            return self.help_stack[-1]\n        else:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            return self.help_stack[-1]\n\n    def empty(self) -> bool:\n        if len(self.stack) == 0 and len(self.help_stack) == 0:\n            return True\n        else:\n            return False\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：push：O(1),pop：O(N),peek：O(N),empty：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090337383","body":"## 思路\n应用单调栈来存储每个区块的最大值\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        current_max, stack = arr[0], [arr[0]]\n        for num in arr[1:]:\n            if num >= current_max:\n                current_max = num\n                stack.append(num)\n            else:\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(current_max)\n        return len(stack)\n```\n## 复杂度分析\n时间复杂度：O(N)   \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091828031","body":"## 思路\n先求出链表长度，在用k对length求余。用快慢指针找出旋转位置。\n## 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        k = k % length\n        if k == 0: return head\n        # 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # newHead 是倒数第 k 个节点，即新链表的头\n        newHead = slow.next\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n```\n时间复杂度：O(N)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092906280","body":"## 思路\n链表问题最好用一个*哑节点*dummy_head指向头节点，这种技巧可以使得链表交换操作推广，而且新的头节点就是dummy_head.next。\n## 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head == None or head.next == None:\n            return head\n        dummy_head = ListNode(0)\n        dummy_head.next = head\n        cur = dummy_head\n        while cur.next and cur.next.next:\n            first_node, second_node = cur.next, cur.next.next\n            first_node.next = second_node.next\n            second_node.next = first_node\n            cur.next = second_node\n            cur = first_node\n        return dummy_head.next\n```\n```go\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    dummyHead := &ListNode{0,nil}\n    dummyHead.Next = head\n    cur := dummyHead\n    for cur.Next != nil && cur.Next.Next != nil {\n        firstNode, secondNode := cur.Next, cur.Next.Next\n        firstNode.Next = secondNode.Next\n        secondNode.Next = firstNode\n        cur.Next = secondNode\n        cur = firstNode\n    }\n    return dummyHead.Next\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094040873","body":"## 思路\n将链表转为数组，然后递归构建平衡二叉树。在数组找到中点，即为根节点。左边为左子树，右边为右子树。\n## 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head == None:\n            return None\n        lists = []\n        cur = head\n        while cur:\n            lists.append(cur.val)\n            cur = cur.next\n        return self.createBST(lists, 0, len(lists)-1)\n    \n\n    def createBST(self, lists, start, end):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        root = TreeNode(lists[mid])\n        root.left = self.createBST(lists, start, mid-1)\n        root.right = self.createBST(lists, mid+1, end)\n        return root\n```\n\n```go\nfunc sortedListToBST(head *ListNode) *TreeNode {\n    if head == nil {\n        return nil\n    }\n    arrValue := []int{}\n    cur := head\n    for cur != nil {\n        arrValue = append(arrValue, cur.Val)\n        cur = cur.Next\n    }\n    return createBST(arrValue, 0, len(arrValue)-1)\n}\n\nfunc createBST(arrValue []int, start int, end int) *TreeNode {\n    if start > end {\n        return nil\n    }\n    mid := (start + end) / 2\n    root := &TreeNode{Val:arrValue[mid]}\n    root.Left = createBST(arrValue, start, mid-1)\n    root.Right = createBST(arrValue, mid+1, end)\n    return root\n}\n```\n## 复杂度分析\n空间复杂度：O(N)  \n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094272698","body":"## 思路\n假设公共链表长度为c，链表A在公共点之前的长度为a, 链表B在公共点之前的长度为b。a+c+b=b+c+a即当链表遍历到尾节点None时设置为对方的头节点接着遍历。两次遍历的相遇的地方为公共节点，没有交点的两个链表会在None处相遇。\n## 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        curA, curB = headA, headB\n        while curA != curB:\n            curA = curA.next if curA else headB\n            curB = curB.next if curB else headA\n        return curA\n```\n```go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    curA, curB := headA, headB\n    for curA != curB {\n        if curA != nil {\n            curA = curA.Next\n        } else {\n            curA = headB\n        }\n        if curB != nil {\n            curB = curB.Next\n        } else {\n            curB = headA\n        }\n    }\n    return curA\n}\n```\n## 复杂度分析\n空间复杂度：O(1)  \n时间复杂度：O(M+N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095102677","body":"## 思路\n利用快慢指针，快指针每一次走两步，慢指针每一次走一步。如果有环则快慢指针一定会相遇。此时，假设环之前的长度为a，环的长度为b。设快指针走过的路程为f，慢指针走过路程为s。有f=2s,f=s+nb。那么s=nb。那么，如果慢指针回到环的起点位置还需走a步。此时，可以将快指针重新设置为头节点，然后快慢指针每次都只向前走一步。那么快慢指针再次相遇时，即为环的入口。\n## 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow, fast = head, head\n        while True:\n            if not (fast and fast.next): return None\n            fast, slow = fast.next.next, slow.next\n            if slow == fast:\n                break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n```go\nfunc detectCycle(head *ListNode) *ListNode {\n    fast, slow := head, head\n    for {\n        if fast == nil || fast.Next == nil {\n            return nil\n        } else {\n            fast, slow = fast.Next.Next, slow.Next\n        }\n        if fast == slow {\n            break\n        }\n    }\n    fast = head\n    for fast != slow {\n        fast, slow = fast.Next, slow.Next\n    }\n    return fast\n}\n```\n## 复杂度分析\n时间复杂度：O(N)  \n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yz3516":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085380660","body":"### **思路**\r\n把k当做carry，从后往前遍历，每次加k的个位数值进res的头部并更新k；\r\n\r\n### **代码**\r\n```java\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        List res = new LinkedList<>();\r\n        for (int i = nums.length - 1; i >= 0 || k > 0; --i) { //这里可以用三元运算符简化；\r\n\t        if(i >= 0){\r\n\t\t\tres.add(0, (nums[i] + k) % 10);\r\n\t\t\tk = (nums[i] + k) / 10;\r\n\t\t} else {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}   \r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### **复杂度**\r\nTime: O(n), n is the length of nums;\r\nSpace: O(n), the res List uses extra space ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086526568","body":"### 思路\n先从左边往右扫，记录每个字符离C的距离；\n然后从右边往左扫，如果比第一次扫的距离小则替换掉，这样最后剩下的就是每个字符距离C最短的距离；\n\n### 代码\n```java\n        int[] result = new int[S.length()];\n        int currDist = S.length(); \n        for (int i = 0; i < S.length(); ++i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = currDist;\n        }\n\n        currDist = S.length();\n        for (int i = S.length() - 1; i >= 0; --i) {\n            currDist = S.charAt(i) == C ? 0 : currDist + 1;\n            result[i] = Math.min(result[i], currDist);\n        }\n        return result;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)， N 为数组长度;\n- 空间复杂度：O(N)，创建了新的array result;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086734511","body":"### 思路\n一般思路下increment的时间复杂度很高，每次inc的时候都要遍历inc对应的值；\\\n优化思路：只有在pop出来的时候才increment历史inc的值，这样inc是O(1)时间；这样需要一个inc array来储存历史上inc的值；\\\ninc[i]对应是的栈顶需要在pop时候inc的值，每次pop的时候需要更新inc[i - 1] = inc[i];\n\n### 代码\n```java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n    \n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() < n)\n            stack.push(x);\n    }\n\n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0)\n            inc[i] += val;\n    }\n}\n```\n**复杂度分析**\\\n初始化时空均为O(N)，push, pop, increment 时空均为 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086947266","body":"### 思路 & 复杂度\r\n1. 两个stack的做法，一个intStack存遇到的数字，一个strStack存需要decode的string，这样空间复杂度是O(m+n)，m为字母数n为数字数； \r\n2. Recursion的做法，base case是完成遍历整个string s 或者 遇到 ] 括号，空间复杂度是O(n)， n是string s 的长度；两个做法时间复杂度都是O(maxK*n), k是nested[]的数量；\r\n\r\n### 代码\r\ntwo stacks:\r\n```java\r\n    public String decodeString(String s) {\r\n        Stack<Integer> intStack = new Stack<>();\r\n        Stack<StringBuilder> strStack = new Stack<>();\r\n        StringBuilder cur = new StringBuilder();\r\n        int k = 0;\r\n        for (char ch : s.toCharArray()) {\r\n            if (Character.isDigit(ch)) {\r\n                k = k * 10 + ch - '0';\r\n            } else if ( ch == '[') {\r\n                intStack.push(k);\r\n                strStack.push(cur);\r\n                cur = new StringBuilder();\r\n                k = 0;\r\n            } else if (ch == ']') {\r\n                StringBuilder tmp = cur;\r\n                cur = strStack.pop();\r\n                for (k = intStack.pop(); k > 0; --k) cur.append(tmp);\r\n            } else cur.append(ch);\r\n        }\r\n        return cur.toString();\r\n    }\r\n```\r\nrecursion:\r\n```java\r\n    int index = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder result = new StringBuilder();\r\n        while(index < s.length() && s.charAt(index) != ']'){\r\n            if(!Character.isDigit(s.charAt(index)))\r\n                result.append(s.charAt(index++));\r\n            else {\r\n                int k = 0;\r\n                //build k while next character is a digit\r\n                while(index < s.length() && Character.isDigit(s.charAt(index)))\r\n                    k = k * 10 + s.charAt(index++) - '0';\r\n                \r\n                //ignore the opening bracket '['\r\n                index++;\r\n                String decodedString = decodeString(s);\r\n                //ignore the closing bracket ']'\r\n                index++;\r\n                //build k[decodedString] and append to the result\r\n                while(k-- > 0)\r\n                    result.append(decodedString);\r\n            }\r\n        }\r\n        return new String(result);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087982640","body":"### 思路\n用两个stack，一个inStack无脑存push进queue的element，另一个outStack负责pop和peek method；\n\n###代码\n```java\nclass MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n        \n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n```\n###复杂度\n空间复杂度都是O(1)；\\\n时间：\\\npush: O(1), 只需要push到inStack里\\\npop: O(1), worst case O(n)，需要call一次peek然后return outStack栈顶的元素\\\npeek: O(1), worst case O(n)\\\nemptu：O(1), 查看两个stack是否都为空都是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089418588","body":"### 思路\r\n对单调栈还是不熟；用的是两个array的做法来实现O(n)复杂度\\\r\n遍历input array，每次遇到比的元素的左边所有元素比在其右边的所有都大即有一个新的chunk\r\n\r\n### 代码\r\n```java\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] maxOfLeft = new int[n];\r\n        int[] minOfRight = new int[n];\r\n\r\n        maxOfLeft[0] = arr[0];\r\n        for (int i = 1; i < n; i++) {\r\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minOfRight[n - 1] = arr[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int i = 0; i < n - 1; i++) {\r\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\r\n        }\r\n\r\n        return res + 1;\r\n    }\r\n```\r\n### 复杂度\r\n时间: O(n) \r\n空间: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090792975","body":"### Idea\n三步走：\n1. 连接尾结点到头结点\n2. 找到反转后的新头结点和新尾结点\n3. 断开新尾结点，返回新头结点\n\n### Code\n```java\n  public ListNode rotateRight(ListNode head, int k) {\n    // base cases\n    if (head == null) return null;\n    if (head.next == null) return head;\n\n    // close the linked list into the ring\n    ListNode old_tail = head;\n    int n;\n    for(n = 1; old_tail.next != null; n++)\n      old_tail = old_tail.next;\n    old_tail.next = head;\n\n    // find new tail : (n - k % n - 1)th node\n    // and new head : (n - k % n)th node\n    ListNode new_tail = head;\n    for (int i = 0; i < n - k % n - 1; i++)\n      new_tail = new_tail.next;\n    ListNode new_head = new_tail.next;\n\n    // break the ring\n    new_tail.next = null;\n\n    return new_head;\n  }\n```\n\n### Complexity\nTime: O(n) \\\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092172760","body":"### Idea\r\n可以iteration不断交换node，更简洁的做法是recursion，也是作为学习和理解recursion很好的题目\r\n\r\n### Code\r\n```java\r\n    //Recursion 解法 先recursion call then do something\r\n    public ListNode swapPairs(ListNode head) {\r\n        //Base Case\r\n        if(head == null || head.next == null) return head;\r\n        ListNode postHead = swapPairs(head.next.next);\r\n        //第一层，swapPairs(1)\r\n            //过了第一行的if，然后到line15\r\n            //ListNode postHead = swapPairs(1.next.next),传进去的是3\r\n            //第二层，swapPairs(3)\r\n                //3 != null && 3.next.next != null，继续往下\r\n                //swapPairs(3.next.next) 传进去的是nulll\r\n                    //此时第三层的'head' == null，return head，返回上一层执行\r\n                //执行第二层的head.next.next = head，此层head = 3\r\n                //3.next.next = 3, 此时链表为 3<->4\r\n                //ListNode newHead = head.next, newHead = 4\r\n                //head.next = postHead, postHead是第三层return的null，此时链表为 4->3->null\r\n                //执行完第二层，return newHead，也就是4\r\n            //回到第一层，执行head.next.next = head, 第一层的head是1，此时链表为 1<->2\r\n            //执行ListNode newHead = head.next, newHead = 2\r\n            //执行head.next = postHead, postHead是第二层return的4->3->null，此时链表为 2->1->4->3->null\r\n            //最后return newHead, 也是就头结点是2的此时链表，2->1->4->3->null\r\n        head.next.next = head;\r\n        ListNode newHead = head.next;\r\n        head.next = postHead;\r\n        \r\n        return newHead;\r\n    }\r\n```\r\n\r\n### Complexity\r\nTime: O(n) \\\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093715787","body":"### Idea\n用recursion来做，先找到中点，然后左半边和右半边都call自己来construct\n\n### Code\n```java\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        return constructBST(0, checkLength(head) - 1, head);\n    }\n    \n    private int checkLength(ListNode head){\n        if(head == null) return 0;\n        return checkLength(head.next) + 1;\n    }\n    \n    private TreeNode constructBST(int start, int end, ListNode head){\n        if(start > end) return null;\n        \n        int mid = start + (end - start) / 2;\n        ListNode temp = head;\n        \n        for(int i = 0; i < mid; i++){\n            temp = temp.next;\n        }\n        TreeNode root = new TreeNode(temp.val);\n        root.left = constructBST(start, mid - 1, head);\n        root.right = constructBST(mid + 1, end, head);\n        return root;\n    }\n```\n\n#Complexity\nTime: O(n), 因为要遍历所有节点找到长度，再找到中点；\\\nSpace: O(logn), 每次同时call左右，recursion的次数是树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094121509","body":"### Idea\n        //a为短的不重复部分，b为长的不重复部分，c为共同部分；\n        //a + c + b = b + c + a\n        //p1先走完a然后走c再走b，p2先走完b然后走c再走a，一定会在connect处汇合；\n### Code\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode p1 = headA, p2 = headB;\n        while(p1 != p2){\n            p1 = p1 != null? p1.next : headB;\n            p2 = p2 != null? p2.next : headA;\n        }\n        return p1;\n    }\n```\n\n### Complexity\nTime: O(max(n,m)), 两个链表长度更长的一个\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094380265","body":"### Idea\r\n用的是lc官方解答第二种来实现O(1)空间复杂度\r\n\r\n### Code\r\n```java\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) return null;\r\n        ListNode dummy = new ListNode(-1);\r\n        dummy.next = head;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        \r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow == fast) break;\r\n        }\r\n        if(slow != fast) return null;\r\n        ListNode temp = head;\r\n        \r\n        while(temp != slow){\r\n            temp = temp.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        return slow;\r\n    }\r\n```\r\n\r\n### Complexity\r\nTime: O(n) \\\r\nSpace: O(1)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085383015","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))\nspace O(max(num和k的长度))","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091030984","body":"## 思路\n\n注意 corner case，head 为空，head 为 1 个节点，k 为 0 时要直接 return；k 取模后如果为 0 也要直接 return\n\n## 代码\n\n    # Definition for singly-linked list.\n    # class ListNode(object):\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    class Solution(object):\n        def rotateRight(self, head, k):\n            \"\"\"\n            :type head: ListNode\n            :type k: int\n            :rtype: ListNode\n            \"\"\"\n            if not head or k == 0 or head.next == None:\n                return head\n\n            newTail= head\n            cur = head\n            length = 0\n            while cur != None:\n                cur = cur.next\n                length += 1\n\n            k %= length\n            if k == 0:\n                return head\n\n            cur = head\n            for i in range(k):\n                cur = cur.next\n\n            while cur.next != None:\n                cur = cur.next\n                newTail = newTail.next\n\n            newHead = newTail.next\n            newTail.next = None\n            cur.next = head\n            head = newHead\n            return head\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094296130","body":"## 思路\n\nheadA, headB 分别指向链表 A, B 的头结点, 两个链表都分别遍历过，如果有交点就会返回。\n\n## 代码\n\n```python\n    class Solution:\n        def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n            p1, p2 = headA, headB\n            while p1 != p2:\n                p1 = p1.next if p1 != None else headB\n                p2 = p2.next if p2 != None else headA\n            return p1\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094309430","body":"## 思路\n\n先快慢指针直到相遇，相遇后把其中一指针放回起点，然后两指针同时向前走，直到相遇。相遇点就是环的开始点。否则不存在环\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (slow == fast) break;\n        }\n\n        if (fast == null || fast.next == null) return null;\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387672","body":"### 思路\n将k加到最后一位，取余放在当前位，接着/10继续向前加\n### 代码\n``` c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       //将K加到最后一位，依次向前\n       vector<int> res;\n       for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\n           //if(i>=0){\n           //    int sum=num[i]+k;\n           //    res.push_back(sum%10);\n           //}\n           //else{\n           //    res.push_back(k%10);\n          // }\n          //上面这一段还是没想清楚\n          if(i>=0){\n              k+=num[i];\n          }\n          res.push_back(k%10);\n       }\n       reverse(res.begin(),res.end());\n       return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）遍历一遍数组\n* 空间复杂度：O（n），建立了数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537714","body":"### 思路\n两次遍历，从左到右更新一遍，从右到左更新一遍\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res(s.size());\n        //方法二，只遍历两次，先从左到右，再从右到左\n        int prev=INT_MAX/2;//防止越界，所以除以2\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=i-prev;\n        }\n        prev=INT_MAX/2;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                prev=i;\n            }\n            res[i]=min(abs(res[i]),prev-i);\n        }\n    return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O（n）\n* 空间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767470","body":"### 思路\n利用数组，使用了三个参数，分别表示最大容量，当前栈顶位置和指向栈的指针\n### 代码\n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        size=maxSize;\n        arr=new int[size];\n        top=-1;\n    }\n    ~CustomStack(){//析构函数\n        delete [] arr;\n    }\n    void push(int x) {\n        if(top==size-1){//栈满\n            return ;\n        }\n        arr[++top]=x;\n    }\n    int pop() {\n        if(top==-1){//栈空\n            return -1;\n        }\n        return arr[top--];//弹出栈顶元素，并--\n    }\n    void increment(int k, int val) {\n        if(top+1<k){//所有元素都增加val\n            for(int i=0;i<=top;i++){\n                arr[i]+=val;\n            }\n        }\n        else{\n            for(int i=0;i<k;i++){\n                arr[i]+=val;\n            }\n        }\n    }\nprivate:\n    int size;//栈的最大容量\n    int top;//当前元素数量,栈顶\n    int* arr;//指向栈的指针\n};\n```\n### 复杂度分析\n* 时间复杂度：push,pop O(1)\n* 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087283863","body":"### 思路\n利用数组vector<string>构造栈，利用栈先进先出的结构来处理[],学习的leetcode题解\n### 代码\n``` C++\nclass Solution {\npublic:\n    string GetDigit(string& s,size_t& ptr){\n        string ret=\"\";\n        while(isdigit(s[ptr])){\n            ret.push_back(s[ptr++]);//此处要对Ptr做出改动，因此传入&\n        }\n        return ret;//将字符数字转化为字符串数字\n    }\n    string GetString(vector<string>& sub){\n        string tmp=\"\";\n        for(string& s:sub){\n            tmp+=s;\n        }\n        return tmp;\n    }\n    string decodeString(string s) {\n        //啊，好难啊，解法一，利用栈先进先出的特点来处理【】\n        //首先建立一个栈（使用数组）vector<string>\n        vector<string> stk;\n        size_t ptr=0;//size_t=unsigned_int\n        while(ptr<s.size()){//遍历字符串\n            char ch=s[ptr];\n            //1、处理数字\n            if(isdigit(ch)){\n                //取出的是字符，要压入的是string\n                stk.push_back(GetDigit(s,ptr));\n            }\n            //2、处理字母和\"[\",继续将字符转为string,压入栈中\n            else if(isalpha(ch) || ch=='['){\n                stk.push_back(string(1,s[ptr++]));\n            }\n            //3、处理‘]’开始弹栈\n            else{\n                ++ptr;\n                //建立处理子字符串的vector<string>\n                vector<string> sub;\n                while(stk.back()!=\"[\"){\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                //去掉\"[\"\n                stk.pop_back();\n                //逆转sub顺序\n                reverse(sub.begin(),sub.end());\n                //得到字符串\n                string tmp_0=GetString(sub);\n                //取出栈中数量,stoi函数将字符串转化为十进制\n                int repTime=stoi(stk.back());\n                stk.pop_back();//弹出数字\n                //新字符串\n                string tmp_1;\n                //构造字符串\n                while(repTime--){\n                    tmp_1+=tmp_0;\n                }\n                //将构造好的字符串压入栈中\n                stk.push_back(tmp_1);\n            }\n        }\n    return GetString(stk);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：O(n)，遍历字符串+一些额外操作\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088273931","body":"### 思路\n两个栈，一个进，一个出\n### 代码\n```C++\nclass MyQueue {\nprivate:\n    stack<int> instack;\n    stack<int> outstack;\n    void inout(){\n        //此处不可以用pop，pop是删除栈顶元素，无返回值，使用top返回\n        while(!instack.empty()){//empty空返回true,不空返回false\n            outstack.push(instack.top());\n            instack.pop();//删除\n        }\n    }\npublic:\n    //使用两个栈，一个instack,一个outstack\n    MyQueue() {\n        //stack栈后进先出，队列先进先出\n    }\n    //析构可以省略，因为数据都是容器，只有析构函数；\n    void push(int x) {\n        instack.push(x); \n    }\n    \n    int pop() {\n        if(outstack.empty()){\n            inout();\n        }\n        int temp=outstack.top();//读取栈顶元素\n        outstack.pop();//删除栈顶\n        return temp;//返回元素\n    }\n    \n    int peek() {\n        //返回队列开头元素\n        if(outstack.empty()){\n            inout();\n        }\n        return (outstack.top());//读取栈顶元素\n    }\n    \n    bool empty() {\n        return (instack.empty() && outstack.empty());\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：push-o(1),pop-o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089857736","body":"### 思路\n单调栈，下一块的最小值大于等于上一块的最大值，以每块最大值代表一块\n### 代码\n``` C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        //使用单调栈\n        stack<int> stack_1;\n        int max=-1;\n        //遍历数组\n        for(int num:arr){\n            if(num>=max){\n                max=num;\n                stack_1.push(num);\n            }\n            else{\n                while(!stack_1.empty() && num<stack_1.top()){\n                    stack_1.pop();\n                }\n                stack_1.push(max);\n            }\n        }\n    return stack_1.size();\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091026256","body":"### 思路\n将链表连成环，之后再移动head\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n       //1、排除0情况\n       if(k==0 || head==nullptr || head->next==nullptr){\n           return head;\n       }\n       //2、找到尾结点，获取节点数量\n       ListNode* tmp=head;\n       int size=1;\n       while(tmp->next){\n           tmp=tmp->next;\n           size++;\n       }\n       //3、连接尾结点和头结点\n       tmp->next=head;\n       //4、移动头结点\n       int num=abs(size-k%size)-1;\n       while(num--){\n           head=head->next;\n       }\n       //5、断开连接的前一个节点\n       ListNode*tmp_1=head->next;\n       head->next=nullptr;\n       return tmp_1;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092398656","body":"### 思路一（迭代）\n迭代（两两交换）+虚拟节点\n### 代码\n``` C++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n       //2022.4.8\n       //!!!!利用虚拟头结点，不需要单独处理头结点\n       //head就是virhead\n       //virhead要分配内存的\n       ListNode* virhead=new ListNode(0);\n       virhead->next=head;\n       ListNode* cur=virhead;//cur一定是在virhead的位置，而不能在virhead->next位置\n       //它要代表上一次迭代的尾结点\n       while(cur->next!=nullptr && cur->next->next!=nullptr){\n           ListNode* tmp_1=cur->next;\n           ListNode* tmp_2=cur->next->next;\n           tmp_1->next=cur->next->next->next;\n           tmp_2->next=tmp_1;\n           cur->next=tmp_2;\n           //移动cur到下一次迭代位置\n           cur=cur->next->next;\n       }\n       head=virhead->next;\n       delete virhead;\n       return head;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度为O(n)\n* 空间复杂度为O(1)\n### 思路二 （递归）\n每次交换两个节点内部的顺序，返回值为两个节点的头结点指针\n### 代码\n``` C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n       //2022.4.8\n       //递归,注意设立结束递归的条件\n       //每次处理两个节点，返回头结点\n       //没法用虚拟节点了\n       if(head==nullptr || head->next==nullptr){\n           return head;\n       }\n       ListNode* newhead=head->next;\n       head->next=swapPairs(newhead->next);\n       newhead->next=head;\n       return newhead;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度o(n)\n* 空间复杂度o(n),递归使用栈空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093665360","body":"### 思路\n快慢指针找中位数+递归建树；\n### 代码\n```C++\nclass Solution {\npublic:\n    //快慢指针找中位数，递归确定树的结构，从根节点开始\n    //左闭右开，因为链表，上一个节点不好找\n    //1、找中位数，在链表中,快慢指针\n    ListNode* findMid(ListNode* left,ListNode* right){\n        ListNode* low=left;\n        ListNode* fast=left;\n        while(fast!=right && fast->next!=right){\n            fast=fast->next->next;\n            low=low->next;\n        }\n        return low;\n    }\n    //2、形成递归，依次构建树节点\n    TreeNode* findRoot(ListNode* left,ListNode* right){\n        //递归结束条件\n        if(left==right){\n            return nullptr;\n        }\n        ListNode* mid=findMid(left,right);\n        TreeNode* root=new TreeNode(mid->val);//mid是链表节点指针，用值创建根节点\n        root->left=findRoot(left,mid);//左闭右开\n        root->right=findRoot(mid->next,right);\n        return root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        return findRoot(head,nullptr);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：T(n)=2T(n/2)+o(n);=o(nlog(n));\n* 空间复杂度：o(log(n)),平衡二叉树的深度为这个，因此空间复杂度为o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094164837","body":"### 思路\n确定两个链表长度，较长链表指针后移对齐，两个链表指针一起后移寻找交点\n### 代码\n``` C++\nclass Solution {\npublic:\n    //判断链表长度\n    int getLen(ListNode* head){\n        int size=0;\n        while(head!=nullptr){\n            head=head->next;\n            size++;\n        }\n        return size;\n    }\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        //是否相交，重点在于地址判断，\n        ListNode* tmpA=headA;\n        ListNode* tmpB=headB;\n        //确定长度\n        int sizeA=getLen(headA);\n        int sizeB=getLen(headB);\n        int sub=abs(sizeA-sizeB);\n        //对其头指针\n        if(sizeA>sizeB){\n            while(sub--){\n                tmpA=tmpA->next;\n            }\n        }\n        else{\n            while(sub--){\n                tmpB=tmpB->next;\n            }\n        }\n        //比较节点地址\n        while(tmpA!=nullptr){\n            if(tmpA==tmpB){\n                return tmpA;\n            }\n            tmpA=tmpA->next;\n            tmpB=tmpB->next;\n        }\n        return nullptr;\n    }\n};\n```\n### 复杂度分析\n时间复杂度：2o(m+n)\n空间复杂度：o(1)\n### 改进\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        //改进，都走相同的长度a+b\n        if(headA==nullptr || headB==nullptr){\n            return nullptr;\n        }\n        ListNode* tmpA=headA,*tmpB=headB;\n        while(tmpA!=tmpB){\n            tmpA=tmpA==nullptr?headB:tmpA->next;\n            tmpB=tmpB==nullptr?headA:tmpB->next;\n        }\n        return tmpA;\n    }\n};\n//时间复杂度：o(n+m)\n//空间复杂度：o(1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094508158","body":"### 思路（哈希表或者快慢指针）\n### 代码（快慢指针法）\n``` C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        //2、双指针，快慢指针\n        ListNode* fast=head,*slow=head;\n        while(slow!=nullptr && fast!=nullptr && fast->next!=nullptr){\n            fast=fast->next->next;\n            slow=slow->next;\n            if(fast==slow){\n                ListNode* tmp1=head;\n                ListNode* tmp2=fast;\n                while(tmp1!=tmp2){\n                    tmp1=tmp1->next;\n                    tmp2=tmp2->next;\n                }\n                return tmp2;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度分析：o(n)\n* 空间复杂度分析：o(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085387840","body":"### 思路： \n模拟加法，从后往前逐位相加\n\n### 代码：\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length\n    for (let i = len-1;i>=0;i--) {\n        let sum = num[i] + k%10\n        k = Math.floor(k/10)\n        if (sum >=10) {\n            k++\n            sum = sum-10\n        }\n        res.unshift(sum)\n    }\n    // k > 0 往数组上继续添加高位\n    while(k>0) {\n        res.unshift(k%10)\n        k = Math.floor(k/10)\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086647422","body":"### 思路： \n两头遍历，取较小值\n\n### 代码：\n```js\nvar shortestToChar = function(s, c) {\n    let len = s.length\n    let left = []\n    let right = []\n    for (let i = 0;i <len;i++) {\n        if (s.indexOf(c,i)==-1) {\n            left.push(Infinity)\n        } else {\n            left.push(s.indexOf(c,i)-i)\n        }  \n    }\n    for (let i = len-1;i >= 0;i--) {\n        if (s.lastIndexOf(c,i)==-1) {\n            right.unshift(Infinity)\n        } else {\n            right.unshift(i-s.lastIndexOf(c,i))\n        }\n        \n    }\n    for (let i = 0;i < len;i++) {\n        left[i] = Math.min(left[i],right[i])\n    }\n    return left\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086772995","body":"### 思路： \n数组模拟栈\n\n### 代码：\n```js\nvar CustomStack = function(maxSize) {\n    this.size = maxSize\n    this.data = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.data.length < this.size) {\n        this.data.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.data.length!=0) {\n        return this.data.pop()\n    }else {\n        return -1\n    }\n\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.data.length)\n    for (let i = 0;i < len;i ++) {\n        this.data[i] = this.data[i] + val\n    }\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087215010","body":"### 思路： \n两个栈分别保存字符和倍数\n\n### 代码：\n```js\nvar decodeString = function(s) {\n    let numStack = []\n    let strStack = []\n    let res = '' // 当前字符串\n    let num = 0  // 倍数\n    for (let c of s ) {\n        if (!isNaN(c)) {\n            num = num*10 + (c-'0')\n         }\n        else if (c == '[') {\n            numStack.push(num)\n            strStack.push(res)\n            num = 0\n            res = ''\n        }\n        else if (c == ']') {\n            res = strStack.pop()+res.repeat(numStack.pop())\n        } else {\n            res +=c\n        }\n    }\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088383482","body":"### 思路： \n两个栈实现队列，辅助栈翻转主栈中的元素，获取队列首部的元素，实现pop\n\n### 代码：\n```js\nvar MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\n\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\nMyQueue.prototype.peek = function() {\n    return this.stack2[this.stack2.length-1] || this.stack1[0]\n};\n\nMyQueue.prototype.empty = function() {\n    return this.stack2.length == 0 && this.stack1.length == 0\n};\n\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090420049","body":"### 思路： \n原数组与排序数组中，同一分块中的和是相等的。\n### 代码：\n```js\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n\n    return count;\n};\n```\n### 复杂度：\n时间复杂度: O(n)    \n空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091247189","body":"### 思路： \n找到切割的节点，把后面接在前面，完成旋转。\n\n### 代码：\n```js\nvar rotateRight = function(head, k) {\n    if (!head) return null\n    let len = 0\n    let cur = head\n    while(cur) {\n        len++\n        cur=cur.next\n    }\n    k = k%len\n    if (k==0) return head\n    let cur2 = head\n    for (let i = 0;i < len-k-1;i++) {\n        cur2 = cur2.next\n    }\n    let node = cur2.next\n    let res = node\n    cur2.next = null\n    for (let i = 0;i < k-1;i++) {\n        node = node.next\n    }\n    node.next = head\n    return res\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092411907","body":"### 思路： \n递归获取交换后需要连接的节点\n\n### 代码：\n```js\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let cur = head\n    let next = cur.next\n    cur.next = swapPairs(next.next)\n    next.next = cur\n    return next\n};\n```\n### 复杂度：\n时间复杂度: O(logN)    \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093669687","body":"### 思路： \n找到中间节点，构造二叉搜索树\n\n### 代码：\n```js\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { // 将链表节点的值逐个推入数组arr\n    arr.push(head.val);\n    head = head.next;\n  }\n  // 根据索引start到end的子数组构建子树\n  let buildBST = function(start,end) {\n      if (start>end) return null\n      let mid = (start+end) >>> 1\n      let root = new TreeNode(arr[mid])\n      root.left = buildBST(start,mid-1)\n      root.right = buildBST(mid+1,end)\n      return root\n  }\n  return buildBST(0,arr.length-1)\n};\n```\n### 复杂度：\n时间复杂度: O(nlogn)  \n空间复杂度: O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094175073","body":"### 思路： \n连接两个链表，双指针去遍历，最终两个指针相遇的节点必定是相交的点\n\n### 代码：\n```js\nvar getIntersectionNode = function(headA, headB) {\n    // 连接两个链表，双指针去遍历，最终两个指针相遇的节点必定是相交的点\n    if (!headA ||!headB) return null\n    let curA = headA\n    let curB = headB\n    while(curA!=curB) {\n        curA = curA!=null ? curA.next : headB\n        curB = curB!=null ? curB.next :headA\n    }\n    return curA\n};\n```\n### 复杂度：\n时间复杂度: O(m+n)  \n空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094512254","body":"### 思路： \n快慢指针，从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。\n\n### 代码：\n```js\nvar detectCycle = function(head) {\n    if (head === null) {\n        return null;\n    }\n    let slow = head, fast = head;\n    while (fast !== null) {\n        slow = slow.next;\n        if (fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            return null;\n        }\n        if (fast === slow) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n```\n### 复杂度：\n时间复杂度: O(n)  \n空间复杂度: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085396374","body":"### 思路\r\n\r\n从最后一位开始模拟加法进位计算， 注意不可以直接转化成数字相加会溢出 - Integer\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int len = num.length - 1;\r\n        //先将最后一位加入list，此时list为倒序\r\n        int sum = num[len] + k;\r\n        result.add(sum % 10);\r\n        int carry = sum / 10;\r\n        \r\n        //从倒数第二位开始循环\r\n        for(int i = len - 1; i >= 0; i --) {\r\n            sum = num[i] + carry;\r\n            result.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        \r\n        //如果carry还有进位\r\n        while(carry > 0) {\r\n            result.add(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        \r\n        //反转数组\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, log k))，其中 N 为数组num长度。\r\n- 空间复杂度：O(max(N, log k)), 储存结果的新数组\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086552671","body":"### 思路\n\n前序遍历数组找出与左侧的字母的最短距离，后序遍历数组找出与右侧字母的最短距离，两者取其最小为最终结果。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] result = new int[len];\n        int max = len - 1;\n        \n        int cur = max;\n        for(int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                cur = 0;\n            } else {\n                result[i] = Math.min(max, ++cur);\n            }\n        }\n        \n        cur = max;\n        for(int i = len - 1; i >= 0 ; i--) {\n            if (s.charAt(i) == c) {\n                cur = 0;\n            } else {\n                result[i] = Math.min(result[i], ++cur);\n            }\n        }\n        \n        return result;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String的长度。\n- 空间复杂度：O(N), 其中 N 为String的长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086709764","body":"### 思路\n\n用数组模拟栈操作\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int[] arr;\n    private int top;\n    \n\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < arr.length - 1) {\n            arr[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : arr[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top ; i++) {\n            arr[i] += val; \n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(K)\n- 空间复杂度：\npush: O(1)\npop: O(1)\nincrement: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087236725","body":"### 思路\n\n维护一个栈来进行括号匹配，当遇到右括号开始pop计算后形成新字符串，然后重新入栈。\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<String>();\n        int k = 0;\n        for(char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + Character.getNumericValue(c);\n            } else if (c == '[') {\n                stack.push(String.valueOf(k));\n                stack.push(\"[\");\n                k = 0;\n            } else if (c == ']') {\n                StringBuilder sb = new StringBuilder();\n                while(stack.peek() != \"[\") {\n                    sb.insert(0, stack.pop());\n                }\n                String str = sb.toString(); // Get string inside []\n                stack.pop(); // pop '['\n                int times = Integer.parseInt(stack.pop()); // Get times\n                \n                sb = new StringBuilder();\n                for(int i = 0; i < times; i++) {\n                    sb.append(str);\n                }\n                stack.push(sb.toString());// Push string: k[encoded_string] to stack\n            } else {\n                stack.push(String.valueOf(c));\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n        }\n        \n        return sb.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为String长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088333805","body":"### 思路\n\n用两个栈来实现队列。\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<Integer>();\n        stack2 = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int pop = stack2.pop();\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return pop;\n    }\n    \n    public int peek() {\n        while(!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        int peek = stack2.peek();\n        while(!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        return peek;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：\n\t◦\tpush：O(1)\n\t◦\tpop：O(N)\n\t◦\tpeek：O(N)\n\t◦\tempty：O(1)\n\n- 空间复杂度：\n\t◦\tpush：O(1)\n\t◦\tpop：O(N)\n\t◦\tpeek：O(N)\n\t◦\tempty：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090015125","body":"###思路\n\n单调递增栈, 储存的元素为当块不能被分割成更小的块时，每个块中的最大值。\n\n###代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<Integer>();\n        for(int i: arr) {\n            if(stack.isEmpty() || i >= stack.peek()) {\n                stack.push(i);\n            } else {\n                int peek = stack.peek();\n                while(!stack.isEmpty() && i < stack.peek() ) {\n                    stack.pop();\n                }\n                stack.push(peek);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n\n- 空间复杂度：O(N)，单调栈的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091191819","body":"### 思路\n\n先将链表变成环形链表，找到倒数第k个node当作新head。\n\n### 代码\n\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0) {\n            return head;\n        }\n        int len = 0;\n        ListNode tail = head; \n        //找到linked list的尾部和长度\n        while(tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        len++; //还要后移一位才是总长度\n        tail.next = head; //让tail指向head，首尾相连\n        k %= len; //k可能比length大\n        ListNode newHead = null;\n        for(int i = 0; i < len - k - 1; i++) {\n            head = head.next;\n        }//此时head是第len-k个node，\n        newHead = head.next;\n        head.next = null;\n        return newHead;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092568774","body":"### 思路\n\n利用dummy记录head, 两两交换节点\n\n### 代码\n\n``` Java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode temp = dummy;\n        while(temp.next != null && temp.next.next != null) {\n            //temp -> n1 -> n2 ---> temp -> n2 -> n1 then move temp to n1\n            ListNode n1 = temp.next;\n            ListNode n2 = temp.next.next;\n            temp.next = n2;\n            n1.next = n2.next;\n            n2.next = n1;\n            temp = n1;\n        }\n        return dummy.next;\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：O(n)，其中 n 是链表的节点数量\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093744200","body":"### 思路\n\n快慢指针找链表中点，然后通过递归得到左子树和右子树。\n\n### 代码\n\n``` Java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) {\n            return null;\n        } \n        if(head != null && head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode dummy = head;\n        ListNode slow = head;\n        ListNode fast = head;\n        ListNode pre = null;\n        while(fast != null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        pre.next = null;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(dummy);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：O(nlogn)，其中 n 是链表的节点数量\n  - n + 2 * n/2 + 4 * n/4 + ... + n * n/n = n * logn (二叉树的高度为logn)\n- 空间复杂度：O(logn) 递归的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094153734","body":"### 思路\n\n1. 计算出a,b的长度差，让长一点的链表先移动到两者长度相同的位置然后开始找相同的node。\n2. 改进：假设链表A =  a + c, 链表B = b + c, 让两者都移动a + b + c次, 最后都会停在interact point。\n\n### 代码\n\n``` Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0;\n        int lenB = 0;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a.next != null) {\n            a = a.next;\n            lenA++;\n        }\n        while(b.next != null) {\n            b = b.next;\n            lenB++;\n        }\n        a = lenA > lenB ? headA : headB;\n        b = lenA > lenB ? headB : headA;\n        int n = Math.abs(lenA - lenB);\n        while(n > 0) {\n            a = a.next;\n            n--;\n        }\n        while(a != b) {\n            a = a.next;\n            b = b.next;\n        }\n        return a;\n    }\n}\n```\n\n改进：\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b) {\n            a = a != null ? a.next : headB; \n            b = b != null ? b.next : headA; \n        }\n        return a;\n    }\n}\n```\n\n\n\n**复杂度**\n\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094421866","body":"### 思路\n\n1. 用哈希表记录，遇到重复的就是环起点\n2. 双指针  - 快慢指针，相步遇时fast比slow多走了n * c（c为cycle的长度），并且fast是slow的两倍，可以推出slow此时走了n * c步, 此时只需再走从head到环起点的步数(计为a步) slow就可以停在环起点，所以此时用一个指针从头开始和slow一起走a步就可以在环起点相遇。\n\n### 代码\n\n1. HashSet\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode n = head;\n        Set<ListNode> set = new HashSet<>();\n        while(n != null) {\n            if(set.contains(n)) {\n                return n;\n            } else {\n                set.add(n);\n            }\n            n = n.next;\n        }\n        return null;\n    }\n}\n```\n\n\n\n2. 快慢指针\n\n``` Java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast) { break; }\n        }\n        if(slow != fast) {\n            return null;\n        }\n        ListNode dummy = head;\n        while(dummy != slow) {\n            dummy = dummy.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n**复杂度**\n\n- 时间复杂度：O(n)\n- 空间复杂度：HashSet: O(n), 快慢指针：O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407589","body":"从尾到头 一位一位计算。 可以另开list 倒叙存 ｜｜ 直接修改原数组，多位的从头插入。\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # brute force, convert to int then to list\r\n        carry, i = 0, len(num) -1\r\n        while carry or i >= 0 or k:\r\n            temp = (num[i] if i >= 0 else 0) + (k % 10 if k else 0) +  carry            \r\n            carry = temp // 10\r\n            \r\n            if i >= 0:\r\n                num[i] = temp % 10\r\n            else:\r\n                num.insert(0,temp % 10)\r\n            \r\n            k //= 10\r\n            i -= 1\r\n\r\n        return num\r\n```\r\ntime complexity: O(N)   \r\nspace complexity: O(N) （不考虑返回值，额外使用O(1))","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091047670","body":"1. 先求出正确的k， 因为k可能大于size of linked list.  \r\n2. fast 先走k步， 然后slow， fast 同步开始走。\r\n3. 截断 拼接组成新的linkedlist. \r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head: return head\r\n        count, cur = 0, head\r\n        while cur:\r\n            count += 1\r\n            cur = cur.next\r\n            \r\n        k %= count\r\n        if k == 0: return head\r\n        \r\n        fast, slow = head, head \r\n        while k > 0:\r\n            fast = fast.next\r\n            k -= 1\r\n              \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n       \r\n        new_head = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        return new_head\r\n\r\n        \r\n```\r\ntime complexity:  O(N)   遍历了两遍  \r\nspace complexity: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092466544","body":"iteration 改变.next 就行了\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head: return head\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        \r\n        cur = dummy\r\n        while head and head.next:\r\n            node1, node2 = head, head.next\r\n            cur.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            \r\n            cur, head = node1, node1.next\r\n        return dummy.next\r\n        \r\n\r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(1) 不考虑答案\r\n\r\nrecursion\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next: return head\r\n        \r\n        first_node, second_node = head, head.next\r\n        first_node.next = self.swapPairs(second_node.next)\r\n        \r\n        second_node.next = first_node\r\n        return second_node\r\n        \r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(N) call stack ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094527624","body":"先判断是否有环，可以用141那道题的思路。  \r\n如果有环， 重置一个点回到头节点， 再同步运动，再一次相交的点就是第一个交点。\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            \r\n            if slow == fast:\r\n                break\r\n        \r\n        if not fast or not fast.next:\r\n            return None\r\n        \r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n            \r\n        return slow\r\n            \r\n        \r\n```\r\ntime complexity:  O(N)   \r\nspace complexity: O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ballerjay":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085407797","body":"### 解题思路\n\n默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n\n还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n\n\n\n```JavaScript\nfunction solution(num,k) {\n  // 默认人工计算的过程，k与数组最后一位相加，然后k去掉个位的数字；然后k与倒数第二位相加，也就是十位，然后去掉十位的数组；依次循环。。。\n  // 还有一些特殊的情况就是数组循环结束之后，k还存在值，所以需要继续往res中添加\n  const res = []\n  const len = num.length\n  for(let i = len - 1;i >= 0 || k > 0;i --, k = Math.floor(k / 10)) {\n    if(i >= 0) {\n      k += num[i]\n    }\n    res.unshift(k % 10)\n  }\n  return res\n}\n```\n\n### 时间复杂度\n\nO(max(n,k)),n为数组的长度,k为数字的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658551","body":"``` js\nvar shortestToChar = function(s, c) {\n    // 中心扩散法，从当前元素为中心，寻找左右两边的c值，然后找出最短距离\n    const res = [] \n    for(let i = 0;i < s.length;i ++) {\n    let l = r = i\n    while(l >= 0) {\n        if(s[l] == c) break\n        l--\n    }\n    while(r < s.length) {\n        if(s[r] == c) break\n        r++\n    }\n    if(l < 0) l = -10000\n    if(r === s.length) r = 10000\n    res.push(Math.min(i - l, r - i))\n    }\n    return res\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088609608","body":"### 思路\n在js中利用数组的方法实现队列\n### 代码\nfunction MyQueue() {\n  this.items = [];\n  this.push = function (x) {\n    this.items.push(x);\n  };\n  this.pop = function () {\n    this.items.shift();\n  };\n  this.peek = function () {\n    return this.items[0];\n  };\n  this.empty = function () {\n    return this.items.length == 0 ? true : false;\n  };\n}\n\nlet queue = new MyQueue();\nqueue.push(1);\nqueue.push(2);\nqueue.peek(); // 返回 1\nqueue.pop(); // 返回 1\nqueue.empty(); // 返回 false","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091067462","body":"### 代码\nvar rotateRight = function (head,k) {\n  if(k == 0 || !head || !head.next) {\n    return head\n  }\n  let n = 1;\n  let cur = head\n  while(cur.next) {\n    // 计算链表的长度\n    cur = cur.next\n    n ++\n  }\n  let add = n - k % n\n  if(add === n) {\n    // 当k是链表的长度n的倍数时，直接返回原始链表\n    return head\n  }\n  cur.next = head // 此操作就是把链表连成一个环\n  while(add) {\n    cur = cur.next\n    add --\n  }\n\n  // 移动了k位之后，断开形成的环，并记录当前的next值，也就是返回链表中的head\n  const resHead = cur.next\n  cur.next = null\n  return resHead\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092400216","body":"## 思想\n用 head  表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead\n```javascript\n   var swapPairs = function(head) {\n  // 当链表为空或者只有一个元素时\n  if(!head || !head.next) {\n    return head\n  }\n  const newHead = head.next\n  head.next = swapPairs(newHead.next)\n  newHead.next = head\n  return newHead\n};\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094819620","body":"## 思路\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现\n-- -\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    const set = new Set()\n    while(head !== null) {\n    if(set.has(head)) {\n        return head\n    }\n    set.add(head)\n    head = head.next\n    }\n\n    return null\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"magua-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085412418","body":"思路\n模拟加法，本质上是以到高精度加法。先把数组翻转，从最后一位开始加，最后在翻转过来\n\n代码实现\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n\n        for(auto& x : num) {\n            k += x;\n            x = k % 10;\n            k /= 10;\n        }\n\n        while(k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度O(n)\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086550335","body":"思路\n分析一下可知，只有两种情况，即c在这个数的左边或者右边，所以我们遍历两次，一次从前向后，一次从后向前，最后把两次遍历的结果取min\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for(int i = 0, j = -1; i < n;  i ++){\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = i - j;\n        }\n        for(int i = n , j = -1; i >= 0; i --) {\n            if(s[i] == c) j = i;\n            if(j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n\n    }\n};\n```\n复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)结果数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086762515","body":"思路\n使用数组实现栈\n\n代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int mx;\n    CustomStack(int maxSize) {\n       // stk.resize(maxSize);\n        mx = maxSize;\n    }\n    \n    void push(int x) {\n        if(stk.size() < mx)\n            stk.push_back(x);\n    }\n    \n    int pop() {\n        if(!stk.empty()){\n            int val = stk.back();\n            stk.pop_back();\n            return val;\n        }else {\n            return -1;\n        }\n        \n        \n    }\n    \n    void increment(int k, int val) {\n        if(stk.size() < k) {\n            for(int i = 0; i < stk.size(); i ++)\n                stk[i] += val;\n        }else if(stk.size() >= k){\n            for(int i = 0; i < k; i ++)\n                stk[i] += val;\n        }\n    }\n};\n\n\n复杂度分析\n时间复杂度： push:O(1)、pop：O(1)\n空间复杂度 O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087041845","body":"思路\n使用递归，遇见数字就递归进去，遇见字母就加到res后面\n\n代码\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while(u < s.size() && s[u] != ']') {\n            if(s[u] >= 'a' && s[u] <= 'z' || s[u] >= 'A' && s[u] <= 'Z') res += s[u ++];//\n            else if(s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while(s[k] >= '0' && s[k] <= '9') k ++;\n                int x = stoi(s.substr(u, k - u));//stoi string转换成int类型\n                u = k + 1;//去掉左括号\n                string y = dfs(s, u);//进一步递归，确认括号里的字符串\n                u ++;\n                while(x --) res += y;\n            }\n        }\n        return res;\n    }\n};\n\n复杂度\n空间：O(2^n) ?指数级别，具体表达式不清楚\n时间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088198934","body":"思路\n用两个stack模拟\n\n代码\n```C++\nclass MyQueue {\npublic:\n    stack<int> stk, num;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    \n    int pop() {\n        if(!stk.empty() && num.empty()) {\n            while(!stk.empty()) {\n                num.push(stk.top());\n                stk.pop();\n            }\n        }\n        int res = num.top();\n            num.pop();\n            return res;\n    }\n    \n    int peek() {\n        if(!stk.empty() && num.empty()) {\n            while(!stk.empty()) {\n                num.push(stk.top());\n                stk.pop();\n            } \n        }\n        int res = num.top();\n\n            return res;\n    }\n    \n    bool empty() {\n        if(stk.empty() && num.empty()) \n            return true;\n        else return false;\n    }\n};\n复杂度\n空间复杂度都是O(n)；\n时间：\npush: O(1),\npop: O(n) \npeek: O(n)\nemptu：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090296298","body":"```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& a) {\n        auto b = a;\n        sort(b.begin(), b.end());\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0, s = 0; i < a.size(); i ++ ) {\n            if (cnt[a[i]] == 1) s -- ;\n            else if (cnt[a[i]] == 0) s ++ ;\n            cnt[a[i]] -- ;\n            if (cnt[b[i]] == -1) s -- ;\n            else if (cnt[b[i]] == 0) s ++ ;\n            cnt[b[i]] ++ ;\n            if (!s) res ++ ;\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091090221","body":"思路\n求size, tail，假设size的大小为n，那么找到第n- k个位置，将其指向空，tail指向head\n\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head) return head;\n        ListNode* tail = new ListNode();\n        int n = 0;\n        for(auto p = head; p; p = p->next){\n            tail = p;\n            n ++;\n        }\n        k %= n;//如果k过大，对n取余\n        auto p = head;\n        for(int i = 0; i < n - k - 1; i ++) p = p->next;\n        tail->next = head;\n        head = p->next;\n        p->next = nullptr;\n        return head;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092356509","body":"思路\n简历虚拟头节点模拟\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        for(auto p = dummy; p->next && p->next->next;) {//从dymmy开始\n            auto a = p->next, b = a->next;\n            p->next = b;\n            a->next = b->next;\n            b->next = a;\n            p = a;\n        }\n        return dummy->next;\n    }\n};\n复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093589421","body":"思路\n找中点后递归 + 中序遍历\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode* h; \n    TreeNode* sortedListToBST(ListNode* head) {\n        //if(!head ) return head;\n        h = head;\n        int n = 0;\n        for(auto p = head; p; p = p->next) n ++;\n        return build(0, n - 1);\n\n    }\n\n    TreeNode* build(int l, int r) {\n        if(l > r) return nullptr;\n        TreeNode *root = new TreeNode();\n        int mid = (l + r  +1) >> 1;\n        root->left = build(l, mid - 1);\n        root->val = h->val;   \n        h = h->next; \n        root->right = build(mid + 1, r);\n        return root;\n    }\n};\n复杂度\n时间复杂度：O(nlogn)\n空间复杂度： O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094152790","body":"思路\n使用双指针，遍历两个分支，当为空时，就指向另一条链表的头节点，相遇时即为相交点\n\n代码\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA == NULL || headB == NULL)  return NULL;\n        auto p = headA, q = headB;\n        while(p != q) {\n            p = p == NULL ? headB : p->next;\n            q = q == NULL ? headA : q->next;\n        }\n        return q;\n    }\n};\n复杂度分析\n时间复杂度 O(m + n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094511377","body":"```C++\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head || !head->next) return NULL;\n        auto s = head, f = head;\n        while(true){\n            if(f == NULL || f->next == NULL) return NULL;\n            s = s->next, f = f->next->next;\n            if(s == f) break;\n        }\n\n        f = head;\n        while(s != f){\n            s = s->next, f = f->next;\n        }\n        return f;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085420206","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int resLen = fmax(numSize + 1, 5); // k 的取值范围 [1, 10^4]，加上进位最多是 5 位数\n    int* res = malloc(sizeof(int) * resLen);\n    int r, w;\n\n    w = resLen - 1;\n    r = numSize - 1;\n\n    while (k || r >= 0) {\n        if (r >= 0) k += num[r--];\n        res[w--] = k % 10;\n        k /= 10;\n    }\n\n    int realStart = w + 1;\n    *returnSize = resLen - realStart;\n    return res + realStart;\n}\n```\n- ****Time:**** $O(max(N,logk))$\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086484326","body":"```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* shortestToChar(char * s, char c, int* returnSize) {\n    int len = strlen(s);\n    int* res = malloc(sizeof(int) * len);\n\n    res[0] = s[0] == c ? 0 : len;\n\n    for (int i = 1; i < len; ++i)\n        res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n    for (int i = len - 2; i >= 0; --i)\n        res[i] = fmin(res[i], res[i + 1] + 1);\n\n    *returnSize = len;\n    return res;\n}\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ****Space:**** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883763","body":"```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : maxSize_(maxSize), top_(-1) {\n        stack_.resize(maxSize);\n        inc_.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top_ < maxSize_ - 1) stack_[++top_] = x;\n    }\n    \n    int pop() {\n        if (top_ == -1) return -1;\n        if (top_ > 0) inc_[top_ - 1] += inc_[top_];\n        int val = stack_[top_] + inc_[top_];\n        inc_[top_--] = 0;\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        int idx = min(k - 1, top_);\n        if (idx >= 0) inc_[idx] += val;\n    }\nprivate:\n    vector<int> stack_;\n    vector<int> inc_;\n    int maxSize_;\n    int top_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087473885","body":"```cpp\nclass Solution {\npublic:\n    bool isNumber(const string& str) {\n        for (char const &c : str) {\n            if (std::isdigit(c) == 0) return false;\n        }\n        return true;\n    }\n\n    string repeat(const string& s, int t) {\n        string res;\n        while (t-- > 0) res += s;\n        return res;\n    }\n\n    string decodeString(string s) {\n        string res;\n        stack<string> stk;\n\n        for (char c : s) {\n            if (c != ']') {\n                stk.push(string(1, c));\n                continue;\n            }\n\n            string p = \"\";\n            while (!stk.empty() && stk.top() != \"[\") {\n                p = stk.top() + p; stk.pop();\n            }\n            stk.pop(); // pop out '['\n\n            string t = \"\";\n            while (!stk.empty() && isNumber(stk.top())) {\n                t = stk.top() + t; stk.pop();\n            }\n            stk.push(repeat(p, stoi(t)));\n        }\n\n        while (!stk.empty()) {\n            res = stk.top() + res; stk.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089692923","body":"```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        for (auto n : arr) {\n            if (stk.empty() || n >= stk.top())\n                stk.push(n); // new chunk\n            else {\n                int temp = stk.top(); stk.pop();\n                // combine chunks\n                while (!stk.empty() && stk.top() > n)\n                    stk.pop();\n                stk.push(temp);\n            }\n        }\n        return stk.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091730222","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0) return head;\n\n        int n = 1;\n        ListNode* p = head;\n        while (p->next != nullptr) {\n            p = p->next;\n            n++;\n        }\n        // 首尾相连\n        p->next = head;\n        k = n - k % n;\n        // 走 n-k 步，断开\n        while (k-- > 0) {\n            p = p->next;\n        }\n        ListNode* newHead = p->next;\n        p->next = nullptr;\n        return newHead;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092392992","body":"```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (!head || !head->next) return head;\n        auto nextPair = swapPairs(head->next->next);\n        auto p1 = head, p2 = head->next;\n        p2->next = p1;\n        p1->next = nextPair;\n        return p2;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dzwhh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085428758","body":"### 思路\n逐位相加,当数组不为空或者k不为0，从末位数字开始，加k当前位(k%10)+进位(carry初始是0),加和后push到开辟的数组去同时只push当前位，循环结束最后判断一次是否还有进位，如果有再push一次，最后反转数组得到最终结果\n\n### 关键点\n- 处理当前位是 num % 10\n- 处理进位是 num / 10\n- 需要判断数组是空，或者k是0的情况\n\n### 代码\n- js版本\n```js\nconst addToArrayForm = (num, k) => {\n  let res = []; // 最终输出结果数组\n  let carry = 0; // 标记进位\n  let tail = num.length - 1; // 数组末位元素，代表各个位的数字\n  let sum = 0; // 各个位加和的结果\n\n  while(tail >= 0 || k != 0) {\n    let x = tail >= 0 ? num[tail] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    sum = x + y + carry; //num数组当前位+k当前位+进位\n    res.push(sum % 10); //sum 可能有进位 取模 10 剔除掉进位数字\n    tail--; //数组向前挪动\n    k = Math.floor(k/10);  // k向高位数字挪动\n    carry = Math.floor(sum / 10); //记录进位数字\n  }\n  if(carry === 1)\n    res.push(carry); //最后一次加和如果有进位最后的1push到数组\n  return res.reverse(); // 从后往前添加的数组，需要反转得到最终结果\n}\n\n```\n### 复杂度分析\n时间复杂度: O(max(n,k))\n空间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086588218","body":"### 思路\n先把字符串中等于c字符的对应下标存到数组res中，作为对比项使用，同时设置指向c字符下标数组的指针p，然后在遍历字符串每个字符，把每个字符的下标数值与res的c字符下标相减，得到距离，每次只比较c字符下标当前值和后继值，如果发现当前值的差值比后继值的差值大，那就把p指针向后挪一位，因为这时候当前值不需要在以后的判断中使用，因为肯定比后面的c字符位置要远,同时把字符串当前字符位置和c字符下标数组对应位置的差异存到dist最终结果数组中\n\n### 关键点\n- 下标差值的比较\n- 当前字符位置与c字符前后2个位置的距离比较，大的代表距离远，需要移动指针\n\n### 代码\n\n- js 版本\n\n```js\nconst shortestToChar = (s, c) => {\n  let res = []; // c字符下标数组\n  let p = 0; // 指向c字符下标数组的指针\n  let dist = []; // 最终结果\n\n  // 把字符串中等于c字符的对应下标存在res数组中\n  for(let i = 0; i < s.length; i++) {\n    if (s[i] ===  c)\n      res.push(i)\n  }\n  \n  // 遍历字符串字符，比较每个字符下标与对应c字符下标的差值\n  for(let j = 0; j < s.length; j++) {\n    // 数组元素和c下标数组前后两个值对比,如果前一个比较值比后一个比较值大，p指针向后挪一位\n    if (p < res.length && Math.abs(j - res[p]) > Math.abs(j - res[p+1])) \n      p++; \n    dist.push(Math.abs(j - res[p]));\n  }\n  return dist;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(m+n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839940","body":"## 1381. Design a Stack With Increment Operation「设计一个支持增量操作的栈」\n- 题目地址: https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n### 题目描述\n请你设计一个支持下述操作的栈。\n实现自定义栈类 CustomStack ：\n- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n### 前置知识\n- 数组、栈\n\n### 思路\n用数组模拟栈操作，maxSize 数组容量也是栈容量，设置一个top指针，作为指向栈顶的指针，每次向栈增加一个元素就是向top位置下标添加一个元素，同时top向后挪一位,pop栈顶操作就是返回top前一位元素; inc 操作可以判断k和top谁小，就遍历范围定到谁作为边界添加val\n\n### 关键点\n- top指针的前后移动，如果初始值为0，那push是先添加元素在挪动top，pop是返回top-1位置的元素\n\n### 代码\n- js 版本\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.stack = new Array(maxSize);\n  this.top = 0;\n};\n\n/** \n* @param {number} x\n* @return {void}\n*/\nCustomStack.prototype.push = function(x) {\n  if (this.top === this.stack.length)\n      return;\n  else   \n      this.stack[this.top++] = x;\n};\n\n/**\n* @return {number}\n*/\nCustomStack.prototype.pop = function() {\n  if (this.top === 0)\n    return -1\n  return this.stack[--this.top];\n  \n};\n\n/** \n* @param {number} k \n* @param {number} val\n* @return {void}\n*/\nCustomStack.prototype.increment = function(k, val) {\n  let len = Math.min(k,this.top)\n  for(let i = 0; i < len; i++){\n      this.stack[i] += val\n  }\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087652609","body":"## 394.Decode String「字符串解码」\n- 题目地址: https://leetcode-cn.com/problems/decode-string/\n\n### 题目描述\n> 给定一个经过编码的字符串，返回它解码后的字符串。\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n**示例 1:**\n>输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n**示例 2:**\n>输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n**示例 3:**\n>输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n### 前置知识\n- 栈\n\n### 思路\n从左往右遍历，遇到\"[\"代码前面如果有数字就是重复次数，把数字压入数字栈， 如果遍历到是字符，把字符压入字符栈中，直到遇到“[”, 把数字和字符临时变量清零，最后遇到\"]\"时，先出栈数字栈，得到要repeat字符串的次数，然后构建子字符串\n\n\n\n### 代码\n- js 版本\n```js\nconst decodeString = s => {\n  let numStack = [];\n  let strStack = [];\n  let num = 0;\n  let res = '';\n\n  for(let c of s) {\n    if (!isNaN(c)){\n      num = num * 10 + Number(c);\n    } else if(c === '[') {\n      strStack.push(res);\n      res = '';\n      numStack.push(num);\n      num = 0;\n    }else if (c === ']') {\n      let repeatTimes = numStack.pop();\n      res = strStack.pop() + res.repeat(repeatTimes);\n\n  }else {\n    res += c;\n  }\n}\nreturn res;\n```\n\n### 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(n)\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088543061","body":"## DAY 5 232. Implement Queue using Stacks「用栈生成队列」\n\n- 题目地址: https://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n### 题目描述\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n> 实现 MyQueue 类：\n> void push(int x) 将元素 x 推到队列的末尾\n> int pop() 从队列的开头移除并返回元素\n> int peek() 返回队列开头的元素\n> boolean empty() 如果队列为空，返回 true ；否则，返回 false\n> 说明：\n> 你 只能 使用标准的栈操作 —— 也就是只有  push to top, peek/pop from top, size, 和  is empty  操作是合法的。\n> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n**示例 1:**\n\n> 输入：\n> [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n> [[], [1], [2], [], [], []]\n> 输出：\n> [null, null, null, 1, 1, false]\n> 解释：\n> MyQueue myQueue = new MyQueue();\n> myQueue.push(1); // queue is: [1]\n> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\n> myQueue.peek(); // return 1\n> myQueue.pop(); // return 1, queue is [2]\n> myQueue.empty(); // return false\n\n### 前置知识\n\n- 栈\n\n### 思路\n\n使用两个栈，通过组合使用 FIFO 的特征，从第一个栈 push 进去，然后 pop 出第一个栈的元素，再 push 到第二栈，最后从第二个栈 pop 出去所有元素，这样就实现了先进先出的逻辑\n\n### 关键点\n\n- pop 需要判断第二个栈是否是空，如果是空需要先进行栈 1 导入栈 2 的操作\n\n### 代码\n\n- js 版本\n\n```js\nvar MyQueue = function () {\n  this.inStack = [];\n  this.outStack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (this.outStack.length === 0) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  return this.outStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (this.outStack.length === 0) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return this.inStack.length === 0 && this.outStack.length === 0;\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090249026","body":"## DAY6 768. Max Chunks To Make Sorted II「最多能完成排序的块 II」\n- 题目地址: https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n### 题目描述\n>这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n我们最多能将数组分成多少块？\n\n**示例1**\n>输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n\n**示例2**\n>输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数\n\n### 前置知识\n- 单调栈\n\n### 思路\n根据题目描述，块与块之间一定是单调递增的，如果出现了比之前块小的元素，那就需要合并到前面的块中去，通过单调递增栈的方式，把每块的最大值压入栈，最后统计栈中元素个数，就是排序块\n\n### 代码\n- js 版本\n\n```js\nconst maxChunksToSorted = arr => {\n  const stack = [];\n\n  for(let i = 0; i < arr.length; i++){\n    if(stack.length === 0 || stack[stack.length - 1] <= arr[i]){\n      stack.push(arr[i]);\n    } else {\n      const maxTemp = stack.pop();\n      while(stack[stack.length - 1] < arr[i]){\n        stack.pop();\n      }\n      stack.push(maxTemp);\n    }\n  }\n  return stack.length;\n}\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091389048","body":"## DAY7 Rotate List「旋转链表」\n- 题目地址: https://leetcode-cn.com/problems/rotate-list/\n\n### 题目描述\n> 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置\n\n**示例1**\n>输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n**示例2**\n>输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n### 前置知识\n- 求单链表的倒数第 N 个节点\n\n### 思路\n先遍历链表得出节点个数，然后通过快慢指针，先让快指针遍历k步，接着快慢指针同时开始遍历，直到快指针走到尾部时，把快指针的后继指针指向head，形成环，然后head指针指向慢指针的后续指针，最后把慢指针的后继指针置null断开环，完成旋转的过程\n\n### 代码\n- js版本\n```js\nconst rotateRight = (head, k) => {\n  if(head === null || head.next === null) return head;\n  let len = 0,tail = head;\n  // 遍历链表获得链表长度\n  while(tail){\n    tail = tail.next;\n    len++;\n  }\n  // 需要移动的步数，由于可能出现k大于len的情况所以取模获取步数\n  k = k % len;\n\n  // 定义快慢指针都指向head初始化\n  let slow = head;\n  let fast = head;\n\n  // 快指针先向前移动k步\n  for(let i = 0; i < k; i++){\n    fast = fast.next;\n  }\n\n  // 快慢指针同时移动，直到快指针移动到tail\n  while(fast.next != null){\n    fast = fast.next;\n    slow = slow.next;\n  }\n\n  fast.next = head; // 快指针后续节点指向head形成环\n  head = slow.next; // 慢指针后续节点变成head\n  slow.next = null; // 断开慢指针的后续节点\n  return head;\n};\n```\n\n### 复杂度分析\n时间复杂度: O(n)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092587250","body":"## 【Day 8】24.Swap Nodes in Pairs「两两交换链表中的节点」\n- 题目地址: https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n### 题目描述\n\n> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\n**示例 1**\n\n> 输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n**示例 2**\n\n> 输入：head = []\n输出：[]\n\n**示例 3**\n\n> 输入：head = [1]\n输出：[]\n\n### 前置知识\n\n- 链表\n\n### 思路\n通过迭代的方式，构建虚拟指针，先预存第二个节点和第三个节点指针，每次迭代过程是第二个节点next指向第一个节点，第一个节点next指向，第三个节点也就是head.next.next，虚拟指针prev的next指向第二个节点，完成节点交换，同时更新指针把prev 变为当前指针，当前指针指向下一个交换节点\n\n### 代码\n\n- js 版本\n\n```js\nconst swapPairs = head => {\n  if (head === null || head.next === null) \n    return head;\n\n  let dummyNode = new ListNode(0,head);\n  let prev = dummyNode, cur = head;\n\n  while(cur !== null && cur.next != null){\n    // 保存下一次反转节点指针\n    let nextPair = cur.next.next \n    let second = cur.next;\n\n    // 开始反转节点\n    second.next = cur;\n    cur.next = nextPair;\n    prev.next = second;\n\n    // 更新指针\n    prev = cur;\n    cur = nextPair;\n  }\n\n  return dummyNode.next;\n}\n```\n\n### 复杂度分析\n\n时间复杂度: O(n)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094034907","body":"## 【Day 9】109. Convert Sorted List to Binary Search Tree「有序链表转换二叉搜索树」\n- 题目地址: https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n### 题目描述\n> 给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n**示例1**\n> 输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n**示例2**\n> 输入: head = []\n输出: []\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n### 前置知识\n- 链表\n- 二叉树\n\n### 思路\n先把有序链表转成有序数组，由于题目中描述元素是按升序排序，那意味着中间值天然左边小，右边大，所以只要每次找中间点进行左右递归进行BST构建即可\n\n\n### 代码\n\n- js 版本\n\n```js\nconst sortedListToBST = head => {\n  let arr = [];\n  while(head){\n    arr.push(head.val);\n    head = head.next;\n  }\n\n  // 通过索引start 和 end 构建子树\n  const buildBST = (start, end) => {\n    if(start > end) \n      return null;\n    const mid = (start + end) >>> 1;\n    const root = new TreeNode(arr[mid]);\n    root.left = buildBST(start, mid - 1);\n    root.right = buildBST(mid + 1, end);\n    return root;  \n  };\n\n  return buildBST(0, arr.length - 1);\n};\n```\n\n### 复杂度分析\n\n时间复杂度:O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094278427","body":"## 【Day 10】160. Intersection of Two Linked Lists「相交链表」\n- 题目地址: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n### 题目描述\n>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n自定义评测：\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n\n**示例1**\n![pic](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)\n>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n**示例2**\n![pic](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\n)\n\n>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n### 前置知识\n\n- 链表\n\n### 思路\n遍历A链表节点，同时把节点放入集合, 再遍历B链表判断是否节点在集合中存在，存在即代表两个链表相交，返回该节点，否在返回null\n\n### 关键点\n- 相交节点后面的链表节点都相同\n\n\n### 代码\n\n- js 版本\n\n```js\nconst getIntersectionNode = (headA, headB) => {\n  const visited = new Set();\n  let tmp = headA;\n  while(tmp != null){\n    visited.add(tmp);\n    tmp = tmp.next;\n  }\n  tmp = headB;\n  while(tmp != null){\n    if(visited.has(tmp))\n      return tmp;\n    tmp = tmp.next;\n  }\n\n  return null;\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度:O(m+n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094659376","body":"## 【Day 11】142. Linked List Cycle II 「环形链表 II」\n\n- 题目地址: https://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n### 题目描述\n\n> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n\n**示例 1**\n![pic](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n>输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n### 前置知识\n\n- 链表\n\n### 思路\n#### 方法1-哈希表\n遍历每个节点，如果该节点不在哈希表，就先放入哈希表，然后继续向后遍历，如果遇到当前节点已经在哈希表，就证明出现环入口了，随即返回该节点\n\n\n### 代码\n\n- js 版本\n\n```js\nconst detectCycle = head => {\n    const visited = new Set();\n    while(head != null){\n      if(visited.has(head))\n        return head;\n      visited.add(head);\n      head = head.next;\n    }\n    return null;\n};\n```\n\n### 复杂度分析\n\n时间复杂度: O(n)\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lyuliangliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085434802","body":"\n### 思路\nAdding from rear to front until both num and k are exhausted.\n### Code\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int digitFromK = k % 10;\n            int currentDigit = digitFromK + (i >= 0 ? num[i] : 0) + carry;\n            if (currentDigit >= 10) {\n                carry = 1;\n                currentDigit -= 10;\n            } else {\n                carry = 0;\n            }\n            result.add(0, currentDigit);\n            k /= 10;\n            i--;\n        }\n        if (carry == 1) {\n            result.add(0, 1);\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n* Time: O(N) \n* Space: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086543333","body":"### Idea\n* Go forward: record the distance between each letter and the latest c in its left;\n* Go backward: update the distance if a letter is closer to the latest c in its right\n### Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int lastIndexC = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                lastIndexC = i;\n            } else if (lastIndexC == Integer.MAX_VALUE) {\n                ans[i] = Integer.MAX_VALUE;\n            } else {\n                ans[i] = i - lastIndexC;\n            }\n        }\n        lastIndexC = Integer.MAX_VALUE;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                lastIndexC = i;\n            } else if (lastIndexC - i < ans[i]) {\n                ans[i] = lastIndexC - i;\n            }\n        }\n        return ans;\n    }\n}\n```\n### Complexity\n* Time: 2N\n* Space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086707378","body":"###Idea\nInitialize an array of size maxSize. Use a pointer top to indicate current stack top.\n### Code\n```\nclass CustomStack {\n    \n    int[] stack;\n    int top;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < this.maxSize - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        return top == -1 ? -1 : stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i <= top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\nComplexity:\n* Time: push/pop O(1), inc O(K)\n* Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087235208","body":"### Idea\nUse one stack. Push both number and string. When meets ']', pop and calculate. Always push the results back to the stack. If the next peek is a string, append to it and put it at the top.\n### Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        \n        StringBuilder result = new StringBuilder();\n        Stack<String> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i ++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                int end = i;\n                while (end < s.length() && s.charAt(end) >= '0' && s.charAt(end) <= '9') {\n                    end ++;\n                }\n                stack.push(s.substring(i, end));\n                i = end - 1;\n            } else if (c >= 'a' && c <= 'z') {\n                int end = i;\n                while (end < s.length() && s.charAt(end) >= 'a' && s.charAt(end) <= 'z') {\n                    end ++;\n                }\n                if (!stack.isEmpty() && isLetterSeq(stack.peek())) {\n                    stack.push(stack.pop() + s.substring(i, end));\n                } else {\n                    stack.push(s.substring(i, end));\n                }\n                i = end - 1;\n            } else if (c == '[') {\n                continue;\n            } else if (c == ']') {\n                String top = stack.pop();\n                int count = Integer.valueOf(stack.pop());\n                String cur = \"\";\n                for (int j = 0; j < count; j ++) {\n                    cur += top;\n                }\n                if (!stack.isEmpty() && isLetterSeq(stack.peek())) {\n                    stack.push(stack.pop() + cur);\n                } else {\n                    stack.push(cur);\n                }\n            }\n        }\n        return stack.pop();\n    }\n    \n    private boolean isLetterSeq(String s) {\n        if (s.charAt(0) >= 'a' && s.charAt(0) <= 'z') {\n            return true;\n        }\n        return false;\n    }\n}\n```\n### Complexity\n* time: 2N\n* space: N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088344631","body":"### Idea\nPush to stack1: O(1); Pop: reversely move all from stack1 to stack2. For every n pops, only the first takes O(N), the rest take O(1) each.\n### Code\n```\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    \n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n### Complexity\n* push: O(1)\n* pop: amortized O(1)\n* empty(): O(1)\n* peek(): If use another variable to keep track of the front: O(1); Otherwise amortized O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091125806","body":"### Idea\nStraight forward. Get size, k%size = offset. Then just find the new head by moving size - offset.\n### Code\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        int size = 1;\n        ListNode tail;\n        for (tail = head; tail.next != null; tail = tail.next) {\n            size++;\n        }\n        int move = k % size;\n        if (move == 0) {\n            return head;\n        }\n        ListNode newTail = head;\n        for (int i = 0; i < size - move - 1; i ++) {\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        tail.next = head;\n        return newHead;\n    }\n}\n```\n### Complexity\nTime: O(N); Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092333435","body":"```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        ListNode pre = newHead;\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode toSwap = cur.next;\n            cur.next = toSwap.next;\n            pre.next = toSwap;\n            toSwap.next = cur;\n            pre = cur;\n            cur = cur.next;\n        }\n        return newHead;\n    }\n}\n```\n### Complexity\n* Time: O(N)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093707393","body":"### Idea\nRecursive. For every list, use fast-slow pointers to find the mid one as root. Do the same for left half of the list; Do the same for the right half.\n### Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode preMid = null;\n        while (fast != null && fast.next != null) {\n            fast = fast.next;\n            fast = fast.next;\n            preMid = slow;\n            slow = slow.next;\n        }\n        preMid.next = null;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }\n}\n```\n### Complexity\nTime: O(NlogN)\nSpace: O(logN) for recursion.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094148637","body":"### Idea\nUse 2 pointers. First go through both lists to know the size difference. Then move the pointer for the longer list so that 2 pointers are at the same start. Then move 2 pointers together until they are pointing to the same node.\n### Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int sizeA = 0;\n        int sizeB = 0;\n        ListNode pA = headA;\n        ListNode pB = headB;\n        while (pA != null) {\n            pA = pA.next;\n            sizeA++;\n        }\n        while (pB != null) {\n            pB = pB.next;\n            sizeB++;\n        }\n        pA = headA;\n        pB = headB;\n        for (int i = 0; i < Math.abs(sizeA - sizeB); i++) {\n            if (sizeA > sizeB) {\n                pA = pA.next;\n            } else {\n                pB = pB.next;\n            }\n        }\n        while (pA != null && pA != pB) {\n            pA = pA.next;\n            pB = pB.next;\n        }\n        return pA;\n    }\n}\n```\n### Complexity\n* Time: O(M+N)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094423283","body":"### Idea\n1. Fast and Slow will meet in circle: If when slow enters circle, fast is K past the circle entrance, it means fast is behind slow by C - K, when C is circle length. Then after diff(distance) / diff(speed) = (C - K) / (2-1) = C-K iterations, fast will catch slow. Thus, they will meet within 1 circle after slow enters circle, at C-K past entrance.\n2. a+n*C+b = 2(a+b) => a+b = n*C. Therefore, when fast and slow meet at b past circle entrance, fast continues to go a, it will be a+b = n*C, which means fast will be at the circle entrance. At the same time slow goes a from head, it will also be at circle entrance.\n### Code\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        if (fast != slow) {\n            return null;\n        }\n        slow = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```\n### Complexity\n* Time: O(N)\n* Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085443568","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\r\n\r\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\r\n\r\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：num = [1,2,0,0], k = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：num = [2,7,4], k = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：num = [2,1,5], k = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum 不包含任何前导零，除了零本身\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n数组 取模 取余 列表相加\r\n\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  见代码\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        # 从低位到高位进行加法\r\n        # 判断是否需要进位\r\n        # 如果num比k大 就可以结束了\r\n        for i in range(len(num)-1,-1,-1):\r\n            num[i],carry  = (num[i] + k%10 + carry)%10,(num[i] + k%10 + carry)//10\r\n            k //= 10\r\n        # 如果num比k小 考虑继续进位\r\n        high = []\r\n        k = k + carry\r\n        if k:\r\n            high = [int(i) for i in str(k)]\r\n        return high + num\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086516918","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n窗口的左右边界\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n将字符c作为窗口的边界 每次记录窗口的左右边界 然后开始计算距离\r\n\r\n## 关键点\r\n\r\n-  如何确定第一个窗口？\\\r\n  由于第一个窗口可能不存在左边界，因此先从索引位置0开始判断左边界是否存在，如果不存在可以将左边界置为n，那么第一个窗口可以不考虑左边界\r\n- 如何更换窗口？\\\r\n  随着对字符串的遍历，一定会遍历到窗口右边界，那么新窗口的左边界就是当前索引i\r\n- 如何使用字符串查找函数？ \\\r\n  s.find(c,beg=i,end=n)，该函数会从字符串s中查找字符c，然后beg表示开始的索引，end表示结束的索引（左闭右开）；如果找不到返回-1\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \"\"\"寻找距离最近的字符的长度 \r\n\r\n        Args:\r\n            s(str):字符串\r\n            c(str):字符\r\n        \r\n        Returns:\r\n            ans(List[int]):返回结果列表\r\n\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n        \r\n        # 寻找左边界 如果没有左边界 那么直接将左边界设置为字符串长度\r\n        l = 0 if s[0] == c else n\r\n        # 从索引位置1开始搜索字符c\r\n        r = s.find(c,1) \r\n\r\n        for i in range(n):\r\n            # 取距离两个边界的最小距离\r\n            ans[i] = min(abs(i-l),abs(r-i))\r\n            # 考虑移动边界的问题\r\n            if i == r:\r\n                l = i\r\n                r = s.find(c,i+1)\r\n        return ans\r\n        \r\n\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086815684","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n设置三个类的成员变量，分别存储栈，栈的最大长度以及栈的当前长度，然后实现push、pop以及inc操作\r\n\r\n## 关键点\r\n\r\n-  用到列表的append函数，向后添加元素\r\n-  用到列表的pop()函数，可以返回列表中对应索引的元素\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.size = maxSize\r\n        self.len = len(self.stack)\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.size:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len > 0:\r\n            self.len -= 1\r\n            return self.stack.pop(-1)\r\n        else:\r\n            return -1 \r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.len < k:\r\n            self.stack = [i+val for i in self.stack]\r\n        else:\r\n            self.stack[:k] = [i+val for i in self.stack[:k]]\r\n        \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$ O(1) $\r\n- 空间复杂度：$ O(n) $ \r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087051498","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= s.length <= 30\r\ns 由小写英文字母、数字和方括号 '[]' 组成\r\ns 保证是一个 有效 的输入。\r\ns 中所有整数的取值范围为 [1, 300] \r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n解码时会遇到四种情况，'[',']','数字','字符'  \r\n遇到右括号就去匹配左括号   \r\n匹配左括号过程中，就需要维护两个变量，一个是重复字符串，另一个是重复次数\r\n## 关键点\r\n\r\n-  注意判断重复的字符串以及重复次数的条件\r\n- 得到重复子字符串后，可以加入栈，然后继续处理后面的']'\r\n- ''.join() 列表拼接成字符串的用法\r\n- list[-1].isnumeric()判断当前元素是否是数字类型\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \"\"\"解码字符串\r\n        Args:\r\n            s(str):编码后的字符串\r\n        Returns:\r\n            res(str):解码后的字符串\r\n        \"\"\"\r\n        stack = []\r\n        for char in s:\r\n            if char == ']':\r\n                # 进行括号匹配\r\n                reapetStr = ''\r\n                reapetCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    reapetStr = stack.pop() + reapetStr\r\n                # 找到左括号\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    reapetCount = stack.pop() + reapetCount\r\n                # 匹配好字符串后 重新入栈\r\n                stack.append(reapetStr * int(reapetCount))\r\n            else:\r\n                stack.append(char)\r\n        return ''.join(stack)\r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n## 思路\r\n\r\n采用递归的解法  \r\n遇到数字开始计算重复次数；  \r\n遇到左括号开始新的递归；  \r\n遇到右括号开始结束一次递归；  \r\n遇到字符添加在重复字符子串  \r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \"\"\"解码字符串\r\n        Args:\r\n            s(str):编码后的字符串\r\n        Returns:\r\n            res(str):解码后的字符串\r\n        \"\"\"\r\n        def dfs(start):\r\n            reapteStr,reapteCount = '',''\r\n            while start < len(s):\r\n                if s[start].isnumeric():\r\n                    reapteCount += s[start]\r\n                elif s[start] == '[':\r\n                    start, t_str = dfs(start+1)\r\n                    reapteStr += t_str * int(reapteCount)\r\n                    reapteCount = ''\r\n                elif s[start] == ']':\r\n                    return start, reapteStr\r\n                else:\r\n                    reapteStr += s[start]\r\n                start += 1\r\n            return reapteStr\r\n        return dfs(0)\r\n        \r\n            \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088273433","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n说明：\r\n\r\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n```\r\n\r\n\r\n\r\n## 思路\r\n由于栈是先进后出的特性，一个栈无法实现队列操作，因此需要两个栈。  \r\n其中一个栈用于进入队列，栈依然保持了入队的顺序  \r\n出队时，如果出栈为空，将入栈的元素反向放入出栈；如果出栈不为空，输入出栈的栈顶元素  \r\n判空条件就是两个栈同时为空  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n    \"\"\"\r\n    使用两个栈来实现队列的操作，将两个栈分为输入栈和输出栈\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None \r\n        if self.outstack:\r\n            return self.outstack.pop()\r\n        else:\r\n            self.outstack = self.instack[::-1]\r\n            self.instack = []\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outstack:\r\n            return self.instack[0]\r\n        else:\r\n            return self.outstack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.instack and not self.outstack:\r\n            return True\r\n        return False \r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089814987","body":"\r\n## 前置知识\r\n\r\n- 单调栈\r\n\r\n## 思路\r\n采用单调栈存储每个块的最大值，如果新的块的最小值小于栈中最大值，那么就出栈进行块的合并\r\n\r\n## 关键点\r\n\r\n-  单调栈的使用\r\n- 块的合并\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \"\"\"\r\n        使用单调栈来完成，栈中每个元素对应每个块的最大值，找到最大值的个数，就找到最多的块的个数\r\n\r\n        Args:\r\n            arr(List[int]):数组\r\n        Returns:\r\n            n(int):单调栈长度\r\n        \"\"\"\r\n        stack =[]\r\n        for element in arr:\r\n            if not stack:\r\n                stack.append(element)\r\n                continue\r\n            # 首先判断这个元素时候可以入栈\r\n            if stack and stack[-1] <= element:\r\n                stack.append(element)\r\n            else:\r\n                cur = stack[-1] # 需要保留栈中的最大值，然后才能合并块\r\n                while stack and stack[-1] > element: stack.pop()\r\n                stack.append(cur)\r\n        return len(stack)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(k)$ \r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091136329","body":"## 思路\r\n  如果k<n，只要找到倒数第k+1个元素(顺着数n-k)，然后从这里断开成两个链表，并将前面的链表拼接到后面的链表；  \r\n  如果k==n，那么不需要改变  \r\n  如果k>n,k=k%n，继续第一种情况  \r\n## 关键点\r\n\r\n-  链表遍历\r\n- 虚拟头\r\n- 链表拼接\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        \"\"\"旋转链表\r\n        链表中最后一个元素向链表头移动，链表其他元素向后移动\r\n\r\n        Args:\r\n            head(Optional[ListNode]):链表头\r\n            k(int):移动k个位置\r\n        \r\n        Returns:\r\n            new_head(Optional[ListNonde]):新的链表头\r\n        \"\"\"\r\n        n,pre = 0,head\r\n        while pre: n,pre = n+1,pre.next\r\n        # 边界判断\r\n        if not n:\r\n            return \r\n        k = k%n\r\n        if not k:\r\n            return head\r\n        else:\r\n            dummy_node = ListNode(-1,head)\r\n            for _ in range(n-k):\r\n                dummy_node = dummy_node.next\r\n            new_head = start = dummy_node.next\r\n            dummy_node.next = None\r\n            while start:\r\n                if start.next:\r\n                    start = start.next\r\n                else:\r\n                    break\r\n            start.next = head\r\n            return new_head\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092350120","body":"## 思路\r\n\r\n如果链表中节点大于等于2，维护两个变量，pre(ListNode)指向交换后链表的尾部，cur(ListNode)指向未交换链表头部;  \r\n那么  \r\npre.next = cur.next  \r\ncur.next = cur.next.next  \r\ncur.next.next = cur  \r\n## 关键点\r\n\r\n-  虚拟头\r\n- 节点修改\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        两两交换链表中相邻的节点\r\n\r\n        Args:\r\n            head(ListNode):链表头节点\r\n        \r\n        Returns:\r\n            new_head(ListNode):虚拟链表头节点\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        pre,cur = ListNode(-1,head),head\r\n        new_head = pre\r\n        while cur:\r\n            if cur.next:\r\n                pre.next = cur.next\r\n                if cur.next.next:\r\n                    next = cur.next\r\n                    cur.next = next.next\r\n                    next.next = cur\r\n                    pre = cur \r\n                    cur = cur.next\r\n                else:\r\n                    cur.next.next = cur \r\n                    cur.next = None\r\n                    cur = cur.next \r\n            else:\r\n                pre.next = cur\r\n                cur = cur.next\r\n        return new_head.next \r\n            \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093830302","body":"## 前置知识\r\n\r\n- 快慢指针\r\n- 二叉搜索树，左子树小于根节点小于右子树，而且是平衡的\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n使用快慢指针，找到链表的中点，那么这就是树的根节点；    \r\n该节点左边就是左子树，对于左子树，再使用快慢指针，就能发现左子树根节点；    \r\n右子树同理；    \r\n\r\n## 关键点\r\n\r\n- 快慢指针，三个指针pre,slow,fast\r\n- 树的递归\r\n- 边界判断\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \"\"\"\r\n        将有序链表变换为二叉搜索树\r\n\r\n        Args:\r\n            head(ListNode):头节点\r\n        Returns:\r\n            new_head(ListNode):返回新的头节点\r\n        \"\"\"\r\n        \"\"\"\r\n        使用快慢指针，找到链表的中点，那么这就是树的根节点；  \r\n        该节点左边就是左子树，对于左子树，再使用快慢指针，就能发现左子树根节点；  \r\n        右子树同理；  \r\n        \"\"\"\r\n        if not head:\r\n            return head\r\n        pre,slow,fast = None,head,head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n## 思路\r\n因为在链表中，找到中间节点的时间复杂度为O(n),如果换成数组，就可以在O(1)时间复杂度内找到中点；  \r\n这也是一种空间换时间的方法  \r\n\r\n\r\n## 关键点\r\n\r\n-  递归函数调用时，边界要保持一直，左闭右开、左闭右闭、左开右闭\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \"\"\"\r\n        将有序链表变换为二叉搜索树\r\n\r\n        Args:\r\n            head(ListNode):头节点\r\n        Returns:\r\n            new_head(ListNode):返回新的头节点\r\n        \"\"\"\r\n        def dfs(nodeList,l,r):\r\n            # 这里设计一个递归的边界问题，\r\n            # 例如：这里规定的区间是左闭右开的，那么l一定要小于r；\r\n            # 而且每次递归调用时，都是遵循左闭右开的原则\r\n            if l>=r:\r\n                return \r\n            mid = int((r+l)/2)\r\n            root = TreeNode(nodeList[mid])\r\n            root.left = dfs(nodeList,l,mid)\r\n            root.right =dfs(nodeList,mid+1,r)\r\n            return root \r\n        nodeList = []\r\n        while head:\r\n            nodeList.append(head.val)\r\n            head = head.next\r\n        return dfs(nodeList,0,len(nodeList))\r\n        \r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(nlogn)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094162902","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\r\n\r\n图示两个链表在节点 c1 开始相交：\r\n\r\n题目数据 保证 整个链式结构中不存在环。\r\n\r\n注意，函数返回结果后，链表必须 保持其原始结构 。\r\n\r\n自定义评测：\r\n\r\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\r\n\r\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\r\nlistA - 第一个链表\r\nlistB - 第二个链表\r\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\r\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\r\n\r\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Intersected at '8'\r\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\r\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n\r\n\r\n示例 2：\r\n\r\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\n输出：Intersected at '2'\r\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\r\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\r\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r\n\r\n\r\n示例 3：\r\n\r\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\n输出：null\r\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\r\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r\n这两个链表不相交，因此返回 null 。\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\nlistA 中节点数目为 m\r\nlistB 中节点数目为 n\r\n1 <= m, n <= 3 * 104\r\n1 <= Node.val <= 105\r\n0 <= skipA <= m\r\n0 <= skipB <= n\r\n如果 listA 和 listB 没有交点，intersectVal 为 0\r\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\r\n\r\n \r\n\r\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        \"\"\"\r\n        通过两个链表的头节点，判断两个链表是否相交\r\n\r\n        Args:\r\n            headA(ListNode):链表A头节点\r\n            headB(ListNode):链表B头节点\r\n        \r\n        Returns:\r\n            overlap(ListNode):相交的初始节点\r\n            或者 null\r\n        \"\"\"\r\n        # 将链表转为列表，然后从列表逆序一一比较\r\n        nodeListA ,nodeListB = [],[]\r\n        while headA:\r\n            nodeListA.append(headA)\r\n            headA = headA.next \r\n        while headB:\r\n            nodeListB.append(headB)\r\n            headB = headB.next\r\n        overlap = None\r\n        for nodeA,nodeB in zip(nodeListA[::-1],nodeListB[::-1]):\r\n            if nodeA == nodeB:\r\n                overlap = nodeA\r\n            else:\r\n                break \r\n        return overlap\r\n            \r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n## 前置知识\r\n\r\n- 双指针\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n如果两个链表相交，那么可以将整个链表看成三部分，将链表从相交节点分开  \r\n链表A的长度就是A+C  \r\n链表B的长度就是B+C  \r\n采用双指针的方法，两个指针分别指向两个链表头，然后分别以相同的速度向后遍历，直到遍历到链表尾部；  \r\n如果链表A上指针遍历到尾部后，开始重置到链表B的头节点，同理链表B上的指针也是如此；  \r\n那么当这两个指针首次相遇时，它们的行程就是A+B+C  \r\n\r\n## 关键点\r\n\r\n-  双指针处理相遇问题\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        \"\"\"\r\n        通过两个链表的头节点，判断两个链表是否相交\r\n\r\n        Args:\r\n            headA(ListNode):链表A头节点\r\n            headB(ListNode):链表B头节点\r\n        \r\n        Returns:\r\n            overlap(ListNode):相交的初始节点\r\n            或者 null\r\n        \"\"\"\r\n        nodeA,nodeB = headA, headB\r\n        for _ in range(2):\r\n            while nodeA and nodeB:\r\n                nodeA = nodeA.next\r\n                nodeB = nodeB.next\r\n            if not nodeA:\r\n                nodeA = headB\r\n            elif not nodeB:\r\n                nodeB = headA\r\n        while nodeA!= nodeB:\r\n            nodeA,nodeB = nodeA.next,nodeB.next\r\n        return nodeA if nodeA == nodeB else None \r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094476663","body":"## 前置知识\r\n\r\n- 链表的遍历\r\n- 快慢指针\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n如果链表有环，假设环前长度为a，环的长度为b；  \r\n那么采用快慢指针，就会存在以下关系式子：  \r\nfast = 2 * slow;  slow = nb;如果两个指针相遇一定是在环内相遇，而且是fast指针领先n圈  \r\n相遇后，再将fast指针置为头节点，和slow指针同时移动a，那么两个指针就会相遇，相遇点就是入环口(slow = a + nb)    \r\n或者说如果两个指针同时移动，再次相遇时，就是入环口\r\n\r\n\r\n## 关键点\r\n\r\n-  快慢指针\r\n-  链表中的环\r\n-  判断环的方法\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \"\"\"\r\n        判断是否环形链表， 如果是，则返回开始入环的第一个节点；如果不是，则返回None\r\n\r\n        Args:\r\n            head(ListNode):头节点\r\n        Returns:\r\n            loop_node(ListNode):入环第一个节点\r\n            或者None\r\n        \"\"\"\r\n        # 边界判断，如果只有一个节点，那么就是无环的\r\n        if not head or not head.next:\r\n            return None \r\n        # 由于存在整个链表就是一个环的时候 可以采用一个虚拟头\r\n        fast = slow = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                break\r\n        if not fast or not fast.next:\r\n            return None \r\n        fast = head\r\n        while fast!=slow:\r\n            fast,slow = fast.next,slow.next\r\n        return fast if fast==slow else None \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085447103","body":"## 思路\n    将数组的最后一位加到k上，然后k对10取余，得到的结果放到linkedList的第一位。数组长度不足时则只操作k。直到k小于0并且数组遍历结束。\n## 复杂度分析\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```\npublic List<Integer> addToArrayForm2(int[] num, int k) {\n    LinkedList<Integer> ans = new LinkedList<>();\n    int i = num.length - 1;\n    while (k >= 1 || i >= 0) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        i--;\n        ans.addFirst(k % 10);\n        k /= 10;\n    }\n    return ans;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086581512","body":"##   思路\r\n    预设一个初始为0的k来记录上一次c出现的下标，循环将i-k当做答案。\r\n    当c再次出现的时候 只需要将(i+k)/2到i的下标重新赋值即可。\r\n    使用flag标记来解决当0下标为c的时候只会对0到下一个下标之前的全部数据赋值的错误\r\n##   复杂度\r\n    时间复杂度O(n) 空间复杂度O(n)\r\n##  代码\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n    int k = 0;\r\n    int[] ans = new int[s.length()];\r\n    boolean flag = false;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        if (s.charAt(i) == c) {\r\n            for (int j = i; flag && j > (i + k) >> 1 || !flag && j >= k; j--) {\r\n                ans[j] = i - j;\r\n            }\r\n            k = i;\r\n            flag = true;\r\n        }\r\n        ans[i] = i - k;\r\n    }\r\n    return ans;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764486","body":"##   思路\n      数组实现，使用两个值分别保存最大长度和当前长度，添加和移除的时候就从当前长度位上操作\n##  代码\n```\nclass CustomStack {\n    int[] value;\n    int maxSize;\n    int current = 0;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.value = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(current==maxSize){\n            return;\n        }\n        value[current++]=x;\n    }\n    \n    public int pop() {\n        if(current==0){\n            return -1;\n        }\n        return value[--current];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<current;i++){\n            value[i]+=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087232122","body":"## 思路\n    双栈思路，将倍数放入倍数栈内，对应层级的字符串放在对应的字符串栈中，当遇到]时处理这一对中括号之间的数据，从倍数栈中取出倍数，将当前的字符串扩展到倍数长，再讲对应的字符串栈中的字符串拼接到扩展之后的字符串之前。\n\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```\npublic String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088295111","body":"##  思路\n    向其中一个栈推数据会出现在栈顶，如果需要读取的时候，需要读取最后一个，这时候只需要将栈翻转即可。\n    在队列的先进先出规则上，只会操作栈的最后一个，所以将栈翻转之后保存即时队列的操作顺序。\n    当用于输出的栈数据为空的时候，将用于保存的栈的数据翻转给输出栈。\n\n##  复杂度\n    时间复杂度O(1) 对于双栈中的每个数据 均进行两次入栈 两次出栈的操作  空间复杂度O(1)除双栈外不需要额外的空间 \n\n##  代码\n```\nclass MyQueue {\n        private Stack<Integer> headStack = new Stack<>();\n        private Stack<Integer> tailStack = new Stack<>();\n        \n        public MyQueue() {\n        }\n\n        public void push(int x) {\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090402641","body":"## 思路\n\n    分块，当循环时当前的值大于等于栈中最大的值的时候，即证明这个值可以被单独分成一块，如果这个值小于栈顶的值时，记录栈顶的值，向栈下面遍历直到找到小于等于这个值的栈中值，并将记录的栈顶值再次插入栈，最后栈的长度即为结果\n\n## 复杂度\n\n    时间复杂度O(n*n) 最坏的情况是每个值都要重新重新遍历一次栈  空间复杂度O(n)额外的栈保存数据\n\n## 代码\n\n```\npublic int maxChunksToSorted(int[] arr) {\n    Deque<Integer> stack = new LinkedList<>();\n    stack.push(arr[0]);\n    int head;\n    for (int i = 1; i < arr.length; i++) {\n    if (arr[i] >= stack.peek()) {\n        stack.push(arr[i]);\n    } else {\n    head = stack.pop();\n    while (!stack.isEmpty() && stack.peek() > arr[i]) {\n        stack.pop();\n    }\n    stack.push(head);\n    }\n}\nreturn stack.size();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091836216","body":"## 思路\n\n    将链表首尾相接形成环，再后移n-k对n的余数-1位 在新的接口处断开环\n## 复杂度\n\n    时间复杂度O(n)  空间复杂度O(n)\n\n## 代码\n\n```\npublic ListNode rotateRight(ListNode head, int k) {\n    if (head == null || head.next == null || k == 0) {\n        return head;\n    }\n    ListNode tail = head, newtail = head;\n    ListNode newhead;\n    int n = 1;\n    while (tail.next != null) {\n        tail = tail.next;\n        n++;\n    }\n    tail.next = head;\n    for (int i = 0; i < (n - k % n - 1); i++) {\n        newtail = newtail.next;\n    }\n    newhead = newtail.next;\n    newtail.next = null;\n    return newhead;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092382467","body":"\n\n\n##  思路\n    采用虚拟头接点，将虚拟头接点之后的接点两两交换，直到下两个节点出现null\n##  复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n##   代码\n```\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode ans = new ListNode(0, head);\n        ListNode temp = ans;\n        ListNode next;\n        ListNode node2;\n        while (temp.next != null && temp.next.next != null) {\n            //保留1\n            next = temp.next;\n            //保留2\n            node2 = next.next;\n            //pre-->2\n            temp.next = node2;\n            //1-->3\n            next.next = node2.next;\n            //2-->1\n            node2.next = next;\n            temp = next;\n        }\n        return ans.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094074164","body":"## 思路\n\n    分治\n\n## 复杂度\n    时间复杂度：O(n log n) 空间复杂度：O(log n)\n\n## 代码\n```\npublic TreeNode sortedListToBST(ListNode head) {\nreturn buildTree(head, null);\n}\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094284948","body":"\n## 思路\n\n    双指针:一个指针从遍历A->B 另一个指针遍历B->A 这样无论AB那个更长，总会在二次遍历的时候相遇(如果有交点)\n\n## 复杂度\n\n    时间复杂度：O(n+m) 空间复杂度：O(1)\n\n## 代码\n\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    ListNode tailA = headA;\n    ListNode tailB = headB;\n    while(tailA!=tailB){\n        tailA = tailA==null?headB:tailA.next;\n        tailB = tailB == null? headA:tailB.next;\n    }\n    return tailA;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094439989","body":"##  思路\r\n    双指针 快指针比慢指针快两倍速，如果链表内有环则必然相遇。当快慢指针相遇时，快指针走过非环部分+慢指针走过的部分*2 + 自己走的剩余的环的部分 \r\n    慢指针走过 非环部分 + 慢指针走过的部分  快指针 = 慢指针的两倍 可以得出  快指针多走的部分(即从相遇点到环起点) = 非环部门\r\n    这是启用一个新指针 指向头指针 新指针和慢指针一起移动  这两个指针相遇的点即为环起点\r\n##  复杂度\r\n    时间复杂度O(n) 空间复杂度O(1)\r\n##  代码\r\n\r\n```\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast!=null&&fast.next!=null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(fast == slow){\r\n                ListNode pre = head;\r\n                while(pre!=slow){\r\n                    slow = slow.next;\r\n                    pre = pre.next;\r\n                }\r\n                return pre;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085449145","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n## 前置知识\n\n- 数组遍历、逐位相加的方法\n\n\n## 思路\n1、数组输出，需要通过for循环将数组输出\n2、将数组和整数依次相加，整数获取位数上的数可通过依次进行求余运算\n\n## 关键点\n\n-  熟悉整数获取位数上的方法\n- 熟悉数组的API，push（）、reverse（）\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    let n = num.length;\n    for(let i = n -1; i >= 0; i--)\n    {\n        let sum = num[i] + k%10;\n        k = Math.floor(k/10);\n        if(sum>=10)\n        {\n            k++;\n            sum = sum -10;\n        }\n        res.push(sum);\n    }\n    for(;k>0;k = Math.floor(k/10))\n    {\n        res.push(k%10);\n    }\n    res.reverse();\n    return res;\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，\n- 空间复杂度：$O(1)$，没有额外增加空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086657535","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- 数组的API\n- 双指针\n\n\n## 思路\n（本题参考了其他人的代码）\n- 主要需要解决的问题是取离c最小的距离\n\n## 关键点\n\n-  判断离c最小的距离\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let num = [];\n    num.length === s.length;\n    let indexNext=s.indexOf(c);//indexNext表示下一个c的下标， \n    let index=indexNext;//index表示前一个c的坐标\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(let i = 0; i < s.length; i++){\n            if(s[i] == c){//每当遍历到C就更新index和indexNext\n                num[i] = 0;\n                index = i;\n                indexNext = s.indexOf(c, i+1);\n            }else{\n                num[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n    return num;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888061","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- 栈\n\n\n## 思路\n主要难点在于void inc(int k, int val)，但暂时只会使用for循环进行完成，但复杂度较高\n\n## 关键点\n\n-  需要考虑个数需求以及栈的元素是否为0\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.Stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.Stack.length >= this.maxSize)\n    {\n        return;\n    }\n    this.Stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.Stack.length == 0)\n    {\n        return -1;\n    }\n    return this.Stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.Stack.length <= k)\n    {\n        for(let i = 0; i < this.Stack.length ;i++)\n    {\n            this.Stack[i] += val;\n    }\n    }\n    else\n    {\n        for(let j = 0; j < k ; j++)\n        {\n            this.Stack[j] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087727938","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n\n \n\n提示：\n\n1 <= s.length <= 30\ns 由小写英文字母、数字和方括号 '[]' 组成\ns 保证是一个 有效 的输入。\ns 中所有整数的取值范围为 [1, 300] \n```\n\n## 前置知识\n\n- 栈前后匹配的运行\n\n\n## 思路\n- 本题最初的思路仅有本题与栈有关，而其余毫无思路，通过讲义知道应该使用栈的匹配方法将此题目进行完成\n\n## 关键点\n\n-  数字只运用于重复的倍数，而字符串则代表重复的字符串内容\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let numStack = [];        // 存倍数的栈\n    let strStack = [];        // 存 待拼接的str 的栈\n    let num = 0;              // 倍数\n    let result = '';          // 字符串\n    for (const char of s) {   // 逐字符扫描\n        if (!isNaN(char)) {   // 遇到数字\n            num = num * 10 + Number(char); // 算出倍数\n        } else if (char == '[') {  // 遇到 [\n            strStack.push(result); // result串入栈\n            result = '';           // 入栈后清零\n            numStack.push(num);    // 倍数num进入栈等待\n            num = 0;               // 入栈后清零\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n        } else {                   \n            result += char;        // 遇到字母，追加给result串\n        }\n    }\n    return result;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088860064","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n示例 1：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n```\n\n## 前置知识\n\n- 栈（先进后出）、队列（先进先出）\n\n\n## 思路\n通过两个栈进行实现队列，解决的关键在于数据进与出的问题\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function() {\n    //使用两个栈实现队列，创建栈\n    this.stack1 = [];//将一个栈当作输入栈，用于push操作，通过push 传入数据\n    this.stack2 = [];//将一个栈当作输出栈，用于pop 和peek操作\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\n //将元素x推到队列的末尾\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\n //从队列的开头移除并返回元素\n //碰到pop/peek，把所有输入栈的内容放到输出栈去\nMyQueue.prototype.pop = function() {\n    if(!this.stack2.length)\n    {\n        while(this.stack1.length)\n        {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\n //返回队列开头的元素\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length)\n    {\n        while(this.stack1.length)\n        {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function(){\n    if(this.stack1.length == 0 && this.stack2.length == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push-O（1）pop-O（n） peek-O（n）empty-O（1）\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090430264","body":"\n## 题目地址(768. 最多能完成排序的块 II)\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n\n\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n- 数组排序\n- 滑动窗口算法\n\n## 思路\n构建新的数组，新数组为原数组排序后的结果，而后对比之和数来判断分块的结果\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    //将arr浅拷贝复制给sorted\n    const sorted = [...arr];\n    //将sorted进行排序\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        //比较之和数的大小进行判断分块结果\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n            sum1 = sum2 = 0;\n        }\n    }\n\n    return count;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，运用了for循环\n- 空间复杂度：$O(n)$，创建了新的数组sorted","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091908577","body":"## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094071851","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n \n\n示例 1:\n\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n\n示例 2:\n\n输入: head = []\n输出: []\n\n\n \n\n提示:\n\nhead 中的节点数在[0, 2 * 104] 范围内\n-105 <= Node.val <= 105\n```\n\n## 前置知识\n\n- 链表、树、递归\n\n\n## 思路\n通过判断当前节点处于左指针还是右指针\n\n## 关键点\n\n-  构建树的要求\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = (head) => {\n  const arr = [];\n  while (head) { // 将链表节点的值逐个推入数组arr\n    arr.push(head.val);\n    head = head.next;\n  }\n  // 根据索引start到end的子数组构建子树\n  const buildBST = (start, end) => {\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\n    const mid = Math.floor((start+end)/2);     // 求中间索引 中间元素是根节点的值\n    const root = new TreeNode(arr[mid]); // 创建根节点\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\n    return root;                          // 返回当前子树\n  };\n\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，while循环\n- 空间复杂度：$O(n)$，构建了新的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294672","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 链表，哈希表\n\n\n## 思路\n1、A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表\n2、遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let data = new Set();\n    while (headA !== null) {\n    data.add(headA);\n    headA = headA.next;\n}\n    while (headB !== null) {\n    if (data.has(headB)) \n    return headB;\n    headB = headB.next;\n}\nreturn null;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095231435","body":"\n## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n## 前置知识\n\n- 双指针、链表\n\n\n## 思路\n使用快慢指针进行解决此问题，当快慢指针第二次相遇时则找到该节点\n## 关键点\n\n-  快慢指针相遇的问题\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null)\n    {\n        return null;\n    }\n    let fast = (slow = head);\n    do{\n        if(fast != null && fast.next != null)\n        {\n            fast = fast.next.next;\n        }\n        else{\n            fast = null;\n        }\n        slow = slow.next;\n    }\n    while(fast!=slow);\n    if(fast == null)\n    return null;\n    fast = head;\n    while(fast != slow){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454092","body":"### 思路\n\n- 将整型列表拼接为字符串后，再转为int型与k相加\n- 将相加后的结果转为字符串后遍历，生成整型列表\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = int(\"\".join(list(map(str, num))))\n        return [int(i) for i in str(num + k)]\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650955","body":"### 思路\n\n1. 先遍历列表s，找到每一个元素c的索引位置，并添加到一个c_pos列表中\n2. for循环len(s)，如果当前位置的索引i小于c_pos[0]，即在c_pos[0]的左侧， 那么就往ans列表中添加“c_pos[0] - i“\n3. 如果当前的位置索引i大于c_pos[-1]，机在c_pos[-1]的右侧，那么就往ans列表中添加“i - c_pos[-1]”\n4. 如果当前的位置索引等于c_pos[p], p=0, 即当前的索引对于的就是元素c，那么就往ans列表中添加“0”, 同时p+=1\n5. 否则，如果恰巧当前位置前后都有元素c的索引，那么就判断离着谁更近，就往ans列表中“min(c_pos[p]-i, i-c_pos[p-1])”\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086763675","body":"### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        self.length = 0\n        \n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        \n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(self.length, k)):\n            self.stack[i] += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1) / O(K)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087687918","body":"### 思路\n1. 遇到的元素不是]，那么就先压入栈中\n2. 遇到 ] 时，逐个弹栈，直到遇到 [\n3. 继续弹出 [ 前的数字\n4. 将 string 重复 num次压入栈中\n5. 重复上述过程，直到栈空\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \n        stack = []\n        \n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                string = \"\"\n                while len(stack) > 0 and stack[-1] != '[':\n                    string = stack.pop() + string\n                # 弹出左括号\n                stack.pop()\n                \n                # 弹出重复数字\n                num_string = \"\"\n                while len(stack) > 0 and stack[-1].isdigit():\n                    num_string = stack.pop() + num_string\n                    \n                num = int(num_string)\n                stack.append(string * num)\n        return \"\".join(stack)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088850661","body":"### 思路\n- 用两个堆栈 stack1 和 stack2 来模拟队列\n- 入队列时：向 stack1 中压入元素\n- 出队列时：将 stack1 中的元素依次弹出堆栈，并压入 stack2 中，最后弹出 stack2 的栈顶元素\n\n### 代码\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            while self.stack1:\n                tmp = self.stack1.pop()\n                self.stack2.append(tmp)\n            return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if len(self.stack1)==0 and len(self.stack2)==0:\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089849941","body":"### 思路\n参考的官方解说的栈思路\n### 代码\n\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        \n        for i in arr:\n            if not stack:\n                max_num = i\n                stack.append(i)\n            else:\n                if i < stack[-1]:\n                    tmp = stack[-1]\n                    while stack and stack[-1] > i:\n                        stack.pop()\n                    stack.append(tmp)\n                else:\n                    stack.append(i)\n                    \n        return len(stack)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091880808","body":"### 思路\n使用双指针\n\n### 代码\n\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        if head is None:\n            return None\n    \n        tmp = head\n        length = 0\n        while tmp.next is not None:\n            length += 1\n            tmp = tmp.next\n        tail = tmp\n        length += 1\n        \n        k %= length\n        # 不需要移动\n        if k == 0:\n            return head\n\n        i = head\n        j = head\n\n        for l in range(k):\n            j = j.next\n\n        while j.next is not None:\n            j = j.next\n            i = i.next\n        i_next = i.next\n        tail.next = head\n        i.next = None\n\n        return i_next\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092971875","body":"### 思路\n- 添加一个头结点，方便操作\n- 遍历链表，调整指针指向\n- 返回头结点\n\n### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 创建头结点\n        cur = ListNode(0)\n        cur.next = head\n        \n        first = cur\n        while cur.next and cur.next.next:\n            n1 = cur.next\n            n2 = n1.next\n            n3 = n2.next\n            \n            cur.next = n2\n            n2.next = n1\n            n1.next = n3\n            \n            cur = n1\n        return first.next\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094068556","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        \r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094300324","body":"### 思路\n核心思想就是消除长度差。\n\n### 代码\n\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        length_a = 0\n        length_b = 0\n        \n        a = headA\n        b = headB\n        \n        while a:\n            a = a.next\n            length_a += 1\n        while b:\n            b = b.next\n            length_b += 1\n        \n        step = abs(length_a - length_b)\n        \n        a = headA\n        b = headB\n        \n        if length_a > length_b:\n            while step > 0:\n                a = a.next\n                step -= 1\n                \n        if length_a < length_b:\n            while step > 0:\n                b = b.next\n                step -= 1\n                \n        while a != b:\n            a = a.next\n            b = b.next\n            \n        return a\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095241582","body":"```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maggiexie00":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085454513","body":"### 思路\r\n\r\n从尾部开始，原地更新num中的数值，k处理完则break\r\n\r\n***把k当作carry\r\n***题目已知num长度最多10^4，k最多5位数，若开辟新数组，则极大增加时间复杂度（遍历num），因而选择原地更新num数组，最坏情况是进行6次操作。\r\n*** key point 是k处理完就停止，无需遍历num。\r\n\r\n### 代码\r\n\r\n\r\n    def addToArrayForm(self, num, k) :\r\n\r\n        p=len(num)-1\r\n        while p>-1 and k!=0:\r\n            tmp=num[p]+k%10\r\n            num[p]=tmp%10\r\n            k=k//10+tmp//10\r\n            p-=1    \r\n\r\n        while k:\r\n            num=[k%10]+num\r\n            k//=10\r\n\r\n        return num\r\n\r\n### 复杂度\r\n空间复杂度 O(1)\r\n时间复杂度 O(N）其中N为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086642755","body":"### 思路\r\n\r\n两次遍历\r\n\r\n记录上一个字符c出现的位置，从头走一遍，计算距离，再从尾部走一遍，更新距离为两次计算中的较小值。\r\n\r\n### 代码\r\n\r\n\r\n    def shortestToChar(self, s, c):\r\n        last=-10000\r\n        ans=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                last=i\r\n            ans.append(i-last)\r\n        last=10000\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                last=i\r\n            ans[i]=min(ans[i],last-i)\r\n        return ans\r\n            \r\n\r\n\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086716724","body":"### 思路\r\n一句话总结：只有pop操作时才真正进行增量操作，使得increment操作时间复杂度也是O(1)。\r\n\r\npush操作时，用[x，y]代替x。y用于increment操作，初始值均为0。\r\nincrement操作时，找到最后一个需要更新数值的位置，将该数值对应的y加上val。\r\npop操作时，返回x+y，并更新栈顶元素的y。\r\n### 代码\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[]\r\n        self.size=0\r\n        self.maxSize=maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.stack.append([x,0])\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        self.size-=1\r\n        a,b=self.stack.pop(-1)\r\n        if self.stack:\r\n            self.stack[-1][1]+=b\r\n        return a+b\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        idx=min(k,self.size)-1\r\n        if idx>-1:\r\n            self.stack[idx][1]+=val\r\n\r\n### 复杂度\r\n时间 O(1)\r\n空间 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087126743","body":"### 思路\r\nkey point: 栈中保存的是last_res（上个 [ 与当前 [ 之间的字符串）与cur_multi（当前 [ 与 ] 中字符串的重复次数）\r\n\r\ndetail：\r\n遇到字母，直接加到res后；\r\n遇到数字，计算multi；\r\n遇到左括号，将[multi，res]入栈，并重置multi，res；\r\n遇到右括号，出栈并进行拼接：将当前字符串乘上multi，拼接至之前字符串后。\r\n\r\nthinking: 因为遇到括号嵌套时，需要从内向外解码，即需要先入后出，因而想到用栈。值得注意的是，并非无脑入栈。手动解码的过程是先乘再拼接，因此入栈也是保存 [ 当前的倍数，待拼接的之前字符串 ]。\r\n\r\n### 代码\r\n    def decodeString(self, s: str) -> str:\r\n        stack,multi,res=[],0,''\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi=10*multi+int(c)\r\n            elif c=='[':\r\n                stack.append([multi,res])\r\n                multi,res=0,''\r\n            elif c==']':\r\n                curr_multi,last_res=stack.pop()\r\n                res=last_res+curr_multi*res\r\n            else:\r\n                res+=c\r\n        return res\r\n### 复杂度\r\n时间 O(N) \r\n空间 O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088870974","body":"### 思路\r\n入队：新的元素总是压入stack1栈顶，第一个进入的元素赋值给记录队首元素的front变量。\r\n出队：当stack2为空，将stack1内元素全部弹出，再压入stack2。若非空，则直接返回stack2栈顶元素。\r\n取队首元素：若stack2非空，返回stack2栈顶元素值。否则返回front变量值。\r\n### 代码\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n        self.front=None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.stack1:\r\n            self.front=x\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            return self.front\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n### 复杂度\r\n入队：时间O(1)    空间O(N)\r\n出队：平均时间复杂度O(1)    空间O(1)\r\n判空：时间O(1)    空间O(1)\r\n队首：时间O(1)    空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089631067","body":"### 思路    \r\nkey point: 每一段的最大值代表当前段。\r\n\r\n观察可得：每个“块”中max_val小于下一个“块”中min_val。\r\n因此我们可以想到维护一个单调递增栈，栈内存储每个“块”的max_val，最后栈的长度即为“块“的个数。\r\n\r\ndetail：当前元素大于等于栈顶元素，则入栈（暂时找到一个新分段），\r\n当前元素小于栈顶元素，则保留栈顶元素，将剩余元素中大于当前值的出栈。\r\n### 代码\r\n\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s=[]\r\n        for c in arr:\r\n            if s and c<s[-1]:\r\n                while len(s)>1 and s[-2]>c:\r\n                    s.pop(-2)\r\n            else:\r\n                s.append(c)\r\n        return len(s)\r\n### 复杂度\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091035172","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k==0 or not head or not head.next:\n            return head\n        p=head\n        n=1\n        while p.next:\n            p=p.next\n            n+=1\n        k%=n\n        if k==0:\n            return head\n        slow,fast=head,head\n        for _ in range(k):\n            fast=fast.next\n        while fast.next:\n            slow,fast=slow.next,fast.next\n        newHead=slow.next\n        slow.next=None\n        fast.next=head\n        return newHead","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092471974","body":"\r\n    def swapPairs(self, head) :\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        newhead=head.next\r\n        head.next=self.swapPairs(newhead.next)\r\n        newhead.next=head\r\n        \r\n        return newhead","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072035","body":"\r\n    def sortedListToBST(self, head):\r\n        def findmid(head,tail):\r\n            slow,fast=head,head\r\n            while fast!=tail and fast.next!=tail:\r\n                fast=fast.next.next\r\n                slow=slow.next\r\n            return slow\r\n        def helper(head,tail):\r\n            if head==tail:return\r\n            node=findmid(head,tail)\r\n            root=TreeNode(node.val)\r\n            root.left=helper(head,node)\r\n            root.right=helper(node.next,tail)\r\n            return root\r\n        return helper(head,None)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094179996","body":"### 思路\r\n设链表A长度为a，链表B长度为b，假设相交部分长度为c，则a+b-c==b+a-c，所以只需同时移动两个指针，移到链表结束则到另一个链表头。如果不存在相交部分，则a+b==b+a，同样在经过指针移动后，最后都到达空节点，返回空节点。\r\n\r\n***注意点：只需p1不为空节点就移到下一个节点（不要求p1.next非空），这样两个链表没有相交部分时，才能最终同时到达空节点。\r\n### 代码\r\n    def getIntersectionNode(self, headA, headB):\r\n        p1, p2=headA, headB\r\n        while p1!= p2:\r\n            p1= p1.next if p1 else headB\r\n            p2= p2.next if p2 else headA\r\n        return p1\r\n### 复杂度\r\n时间 o(n) 其中n为链表长度\r\n空间 o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095223253","body":"\r\n    def detectCycle(self, head):\r\n        if not head or not head.next:\r\n            return None\r\n            \r\n        slow,fast=head,head\r\n        flag=True\r\n        while flag or fast!=slow:\r\n            if fast and fast.next:\r\n                flag=False                \r\n                slow,fast=slow.next,fast.next.next\r\n            else:\r\n                return None\r\n\r\n        fast=head\r\n        while fast!=slow:\r\n            fast,slow=fast.next,slow.next\r\n        return slow\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085464204","body":"## 思路\n低位往高位加。\n进位放到k里处理。\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resultSta = new ArrayList<>();\n        \n        //进位放到k里处理\n        for(int i=num.length-1; i>=0;i--){\n\n            int sum =  num[i] +k%10;\n            k = k/10;\n\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n\n\n            resultSta.add(sum);\n        }\n\n        while(k!=0){\n            resultSta.add(k%10);\n            k = k/10;\n        }\n\n        Collections.reverse(resultSta);\n        return resultSta;\n    }\n}\n```\n\n## 复杂度\n时间：o(n+k)\n控件：o(n+k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558958","body":"## 思路\n同时正向和反向遍历\n## code\n```java\nclass Solution {\n    //同时正向和反向遍历\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        for(int i=0;i<s.length();i++){\n            int head = i;\n            int tail = i;\n            while(true){\n                if(head>=0 && s.charAt(head) == c) break;\n                if(tail<s.length() && s.charAt(tail) == c) break;\n                head--;\n                tail++;\n            }\n            result[i] = (i-head)<(tail-i)?(i-head):(tail-i);\n        }\n        return result; \n\n    }\n}\n```\n\n## 复杂度\n时间：o(n^2)\n空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885319","body":"```java\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087732939","body":"##思路  \n\n双栈，存放数组和字符串\n\n\n##code\n```java\npublic String decodeString(String s) {\n    Deque<Integer> stack_digit = new LinkedList<>();\n    Deque<StringBuilder> stack_string = new LinkedList<>();\n    int digit = 0;\n    StringBuilder res = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n        char ch = s.charAt(i);\n        if (ch == '[') {\n            stack_digit.push(digit);\n            stack_string.push(res);\n            digit = 0;\n            res = new StringBuilder();\n        }else if (ch == ']') {\n            StringBuilder temp = stack_string.poll();\n            int count = stack_digit.poll();\n            for (int j = 0; j < count; j++) {\n                temp.append(res.toString());\n            }\n            res = temp;\n        }else if (Character.isDigit(ch)) {\n            digit = digit*10 + ch - '0';\n        }else {\n            res.append(ch);\n        }\n    }\n    return res.toString();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088814153","body":"## 思路 \n双栈  \npush：先检查pop栈中是否有元素，如果有，先倒到push栈再进行新元素的push操作  \npop：先检查push栈中是否有元素，如果有，先倒到pop栈再进行新元素的pop操作  \n\n## 代码\n```java\nclass MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}\n```\n\n## 复杂度  \n空间：O(n)  \n时间：O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090425231","body":"## 思路  \n单调栈，记录每个区块的最大值\n\n## code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n## 复杂度  \n时间：O(N)   \n空间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092714169","body":"## 思路\n虚拟头，遍历，指针操作  \n\n## code\n```java \npublic ListNode swapPairs(ListNode head) {\n    //三个节点ABC之间的指针操作(涉及四个节点，但是最后一个节点只是被指,可以用C.next替代)\n    //算法专注三个节点间的操作，补充虚拟头节点\n\n    if(head==null || head.next == null) return head;\n\n    //构造虚拟头\n    ListNode preHead = new ListNode(-1,head);\n\n    //init A B C\n    ListNode A,B,C;\n    A = preHead;\n    B = A.next;\n    C = B.next;\n\n    while(true){\n        //System.out.println(\"B: \"+B.val+\", C: \"+C.val);\n        //BC交换\n        B.next = C.next;\n        C.next = B;\n        A.next = C;\n\n        //指针后移\n        A = B;\n        if(A.next !=null && A.next.next !=null){\n            B = A.next;\n            C = B.next;\n        }else{\n            break;\n        }\n    }\n    return preHead.next;\n}\n```\n\n## 复杂度  \n空间：O(1)  \n时间：O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072957","body":"## 思路  \n快慢指针，分割，递归\n\n## Code\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        ListNode fast = head, slow = head, pre = null;\n        while(fast != null && fast.next != null){\n            fast =  fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        pre.next = null;\n        ListNode rightList = slow.next;\n        TreeNode root = new TreeNode(slow.val);\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(rightList);\n        return root;\n    }\n}\n```   \n\n## 复杂度  \n时间：O(nlogn)     \n空间：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094299698","body":"## 思路\nHashMap，两个链表同时遍历，put时key如果相同就返回此节点\n## code\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        HashMap<ListNode,Integer> map = new HashMap<>();\n        while(headA != null || headB != null){\n            if(headA != null && map.put(headA,0)!=null){\n                return headA;\n            }else if(headB != null && map.put(headB,0)!=null){\n                return headB;\n            }else {\n                headA = headA==null?null: headA.next;\n                headB = headB==null?null: headB.next;\n                if(headA==null && headB==null){\n                    break;\n                }\n            }\n            \n        }\n        return null;\n    }\n}\n```\n## 复杂度\n时间：O(n)  \n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095231353","body":"## 思路\n快慢指针，相遇后快指针从头开始\n\n## code\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carrieyqzhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085470672","body":"### 思路\r\n从个位数求两数之和，carry= 1 如果sum大于10.\r\nsum % 10 得到的结果就是当位数的值\r\nwhile 结束loop如果num[]里没有元素，而且k 等于0\r\n\r\n### 代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length -1;\r\n        while (l1 >= 0 || k != 0){\r\n            int a = l1 < 0 ? 0 : num[l1]; //get last element in num[]\r\n            int b = k <= 0 ? 0 : k % 10; //get last digit in k            \r\n            int sum = a + b + carry;\r\n            res.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            l1--;\r\n            k /= 10;\r\n        }\r\n        if (carry != 0) res.add(0,carry);\r\n    \r\n        return res;     \r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667323","body":"### 思路\n左右遍历一遍\n\n### 代码\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] out_arr = new int[n];\n        int cPos = -n;\n        \n        for(int i =0; i <n; i++){\n            if(s.charAt(i) == c){\n                cPos = i;\n            }\n            out_arr[i] = i - cPos;\n        }\n        for(int i = n-1; i >=0; i--){\n            if(s.charAt(i) == c){\n                cPos = i;\n                \n            }\n            out_arr[i] = Math.min(out_arr[i], Math.abs(i-cPos));\n        }\n        return out_arr;\n        \n    }\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086790288","body":"### 思路\n用stack实现CustomStack\ninc[] 用来存储increment value,每pop一个值，加上inc[i]的值返回，inc[i-1]=inc[i],以便后面pop时可以加上increment value值\n\n### 代码\n\n```Java\nclass CustomStack {\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        if( stack.size() < n){\n            stack.push(x);\n        }\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0 )return -1;\n        if(i > 0){\n            inc[i-1] += inc[i]; //store the increment value for bottom use\n        }\n        int res = stack.pop() + inc[i];\n        inc[i] = 0; //set current increment to 0 since its poped\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val; //inc[i] means increment val for all stack[0]-> stack[i]\n        \n    }\n}\n\n```\n\n时间/空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087146894","body":"### 思路\n用栈存所有不是】的character， 等遇到后括号开始pop存在栈里characters, 遇到数字就append multiple times of substr\n\n### code\n\n``` python\ndef decodeString(self, s: str) -> str:\n        stack = []\n        \n        for i in range(len(s)):\n            if s[i] != \"]\":\n                stack.append(s[i])\n            else:\n                substr = \"\"\n                while stack[-1] != \"[\":\n                    substr = stack.pop() + substr\n                stack.pop()\n                    \n                k = \"\"\n                while stack and stack[-1].isdigit():\n                    k = stack.pop() + k\n                stack.append(int(k) * substr)\n                    \n        return \"\".join(stack)\n```\n\n时间空间复杂度： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088282981","body":"### 思路\n\n用两个栈来实现，push的时候用input stack, pop的时候如果output栈有元素，直接pop,如果为空，把input栈所有元素push到output栈再pop\npeek()也先检查output栈是否为空，不为空直接peek,空的话把input栈所有元素push到output栈再peek\n如果两个栈都为空的话那么empty（）返回空\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Stack<Integer> input;\n    Stack<Integer> output;\n\n    public MyQueue() {\n        input = new Stack<>();\n        output = new Stack<>();\n        \n    }\n    \n    public void push(int x) {\n        input.push(x);\n        \n    }\n    \n    public int pop() {\n        if(output.isEmpty()){   //must check if it's empty   \n            while(!input.isEmpty()){\n                output.push(input.pop());\n            }     \n        }\n          return output.pop();\n        \n    }\n    \n    public int peek() {\n        if(output.isEmpty()){//must check empty\n            while(!input.isEmpty()){\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return output.isEmpty() && input.isEmpty();\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089838566","body":"### 思路\n\n//在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块。\n//如果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块(保持栈的单调递增)。\n\n### 代码\n\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n         LinkedList<Integer> stack = new LinkedList<>();\n        for(int i = 0; i < arr.length; i++){\n            if(!stack.isEmpty() && arr[i] < stack.getLast()){\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && arr[i] < stack.getLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            }else{\n                stack.addLast(arr[i]);\n            }\n            \n        }\n        return stack.size();\n\n        \n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091086383","body":"### 思路\n1.求size, tail\n2.找到cutoff节点，用curr node标记第一段最后一个node\n3. swap 两段位置： \n        tail.next = head; \n        head = curr.next; //new head \n        curr.next = null;\n\n### 代码\n\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        //edge case check\n        if(head == null) return head;\n\n        ListNode tail = head;\n        int size = 1;\n        while(tail.next != null){\n            tail = tail.next;\n            size++;\n        }\n\n        //k might be greater than size\n        k = k % size;\n\n        ListNode curr = head;\n        int n = 0;\n        while(n < size-k-1){\n            curr = curr.next;\n            n++;\n        }\n       \n        tail.next = head; \n        head = curr.next; //new head \n        curr.next = null;\n\n        return head;\n   \n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092474755","body":"### 思路\n两两swap，用while循环\n\n### 代码\n\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null)\n            return head;\n\n        //add a dummyhead\n        ListNode dummyhead = new ListNode();\n        dummyhead.next = head;\n\n        //create a temp node to traverse the list\n        ListNode temp = dummyhead;\n\n        //at least two nodes in the list to start with\n        while(temp.next != null && temp.next.next != null){\n            //swap temp.next and temp.next.next\n            //step 1: find the two nodes\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n\n            //step 2: start swap\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n\n            //step 3: now temp points to temp.next.next\n            temp = node1;\n        \n        }\n\n        return dummyhead.next;\n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093725398","body":"### 思路\n    recursive method to create tree -> sortedListBST(ListNode head)\n        - if head = null, return null\n        - find mid Node: call getMid(head)\n        - create root with value of mid.val\n        - if head = mid, just return root\n        - root.left = recursive call sortedListToBST(head)\n        - root.right = recursive call sortedListToBST(mid.next)\n\n    Find mid and break previous links ->getMid(ListNode head)\n        - initialize slow, fast, prev to head\n        - while (fast not null && fast.next not null)\n            - prev = slow;\n            -slow = slow.next;\n            - fast = fast.next.next;\n        -break the link if prev != null\n        -return slow    \n\n### 代码\n\n```java\npublic TreeNode sortedListToBST(ListNode head) {\n\n        if(head == null) return null;\n\n        ListNode mid = getMid(head);\n        TreeNode root = new TreeNode(mid.val);\n\n        if(head == mid)\n            return root;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(mid.next);\n        return root;       \n    }\n\n    public ListNode getMid(ListNode head){\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode prev = head;\n        while(fast != null && fast.next != null){\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        //break the link before the mid point\n        if(prev != null)\n            prev.next = null;\n        return slow;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094186296","body":"### 思路\n\n定义两个指针l1, l2,分别指向headA, headB\n     - while l1, l2的值不等，既没有焦点：\n           1. l1 not null, go to next node, else go to the other list head\n           2. l1 not null, go to next node, else go to the other list head\n    - loop breaks, return l1\nlogic: nodes of headA + nodes of headB = nodes of headB + nodes of headA, 所以注定会相遇，要么在末尾null, 要么在中途某个node\n\n\n\n### 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null) return null;\n\n        ListNode l1 = headA;\n        ListNode l2 = headB;\n\n        while( l1 != l2){\n            l1 = l1 == null ? headB : l1.next;\n            l2 = l2 == null ? headA : l2.next;\n        }\n        return l1;      \n    }\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N + M),  两个链表的长度\n- 空间复杂度：O(1)， 只有指针移动","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094609100","body":"```Java\npublic ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {// 有环\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口\n                while (index1 != index2) {\n                    index1 = index1.next;\n                    index2 = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085485310","body":"/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let len = num.length-1;\n    while(len>=0&&k>0){\n        const sum = k+num[len]\n        num[len] = sum%10\n        k=~~(sum/10)\n        len--\n    }\n    if(k>0) return [...k.toString().split(''),...num]\n    return num\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770679","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.queue = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.queue.length<this.maxSize) this.queue.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.queue.length==0) return -1;\n    return this.queue.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<this.queue.length;i++)this.queue[i] += val\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090157685","body":"```js\r\n/**\r\n\r\n@param {number[]} arr\r\n\r\n@return {number}\r\n*/\r\nvar maxChunksToSorted = function (arr) {\r\nconst sorted = [...arr];\r\nsorted.sort((a, b) => a - b);\r\n\r\nlet count = 0,\r\nsum1 = 0,\r\nsum2 = 0;\r\n\r\nfor (let i = 0; i < arr.length; i++) {\r\nsum1 += arr[i];\r\nsum2 += sorted[i];\r\n\r\n if (sum1 === sum2) {\r\n     count++;\r\n }\r\n}\r\n\r\nreturn count;\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091164409","body":"```js\n\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092441241","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    if (!head || !head.next) return head\n    let node = new ListNode('head')\n    node.next = head\n    let prev = node\n    let curr = node.next\n    let next = node.next.next\n    while(next) {\n        let nextNode = next.next\n        curr.next = nextNode\n        next.next = curr\n        prev.next = next\n        if(!nextNode) break\n        prev = curr\n        curr = nextNode\n        next = nextNode.next\n    }\n    return node.next\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094165256","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let left = headA,right=headB;\n    while(left||right){\n        if(left == right) return left;\n        if(!left) left=headB\n        else left=left.next\n        if(!right) right=headA\n        else right = right.next\n    }\n    return null\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094737266","body":"```js\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(!head) return null\n    let prev = head\n    let curr = head\n    while(curr) {\n        prev = prev.next\n        if(curr.next!=null){\n            curr = curr.next.next\n        }else{\n            return null\n        }\n        if(prev==curr){\n            let ptr = head;\n            while (ptr !== prev) {\n                ptr = ptr.next;\n                prev = prev.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xil324":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491089","body":"思路: 先把数组转换为正数,然后再把两个数相加，最后再把得到的整数转换为数组。 时间复杂度o(n), 空间复杂度O(n) , n取决于num 和结果数组的最大值。 \r\n```\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        number = self.convert_array_to_integer(num);\r\n        print(number)\r\n        sum_two_numbers = number + k\r\n        res = [];\r\n        while sum_two_numbers >= 10:\r\n            res.append(sum_two_numbers % 10);\r\n            sum_two_numbers = sum_two_numbers // 10; \r\n        res.append(sum_two_numbers)\r\n        return res[::-1]; \r\n        \r\n            \r\n    \r\n    def convert_array_to_integer (self, arr):\r\n        result = 0;\r\n        for i in range(len(arr)):\r\n            if arr[i] == '0': \r\n                result - result * 10;\r\n            else:\r\n                result = result * 10 + arr[i]; \r\n            \r\n        return result; \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086540900","body":"```\r\nclass Solution(object):\r\n    #数组的遍历(正向遍历和反向遍历)\r\n    #思路： 遍历两次，每次遍历，更新target到i的距离， 取两次遍历的最小值，也就是查看，左右target哪一个离i更近，更新result（返回数组）\r\n    #result[target] = 0\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        \r\n        result = [float('inf')] * len(s); \r\n        target = -len(s);\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i)); \r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                target = i; \r\n            result[i] = min(result[i], abs(target-i));\r\n        return result;\r\n```\r\n时间复杂度： o(n)\r\n空间复杂度： o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086776798","body":"```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize; \r\n        self.stack = []; \r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x);\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack) != 0:\r\n            temp = self.stack[-1];\r\n            self.stack.pop(); \r\n            return temp;\r\n        else:\r\n            return -1; \r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        i = 0; \r\n        while i < k and i < len(self.stack):\r\n            self.stack[i] += val;\r\n            i+=1; \r\n    \r\n        \r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086938297","body":"使用栈， 对于给定的数组，把元素依次入栈，遇到 \"]”， 则将元素依次出栈直到遇到\"[\"， 把得到的string放回栈，然后处理\"[\"前的数字。 在处理数字（重复的次数时），要注意多位数的情况(>=10). 时间复杂度： O(n). 空间复杂度:O(n)\r\n```\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []; \r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                temp = []; \r\n                while stack[-1] != '[':\r\n                    temp.append(stack.pop());\r\n                stack.pop(); \r\n                counter = 0\r\n                base = 1\r\n                while stack and stack[-1].isdigit():\r\n                    counter += (ord(stack.pop()) - ord('0')) * base\r\n                    base *= 10\r\n                print('counter is', counter)\r\n                str = ''.join(temp[::-1])\r\n                stack.append(str * counter); \r\n            else:\r\n                stack.append(s[i]); \r\n        return ''.join(stack);\r\n                    \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088316192","body":"思路： 使用两个栈，栈A正常操作，在pop的时候，看栈B是否为空，如果为空，则将元素依次pop出，然后加入栈B， 这样栈B的元素就是先进先出\n\n···\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = [];\n        self.stack2 = [];\n        \n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x); \n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek(); #check if self.stack2 is empty \n        return self.stack2.pop(); \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2) == 0:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop()); \n        return self.stack2[-1]; \n        \n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1)==0 and len(self.stack2)==0; \n  ···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090357090","body":"```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        count_first = collections.defaultdict(int); \r\n        count_second = collections.defaultdict(int);\r\n        arr_sorted = sorted(arr); \r\n        ans = 0; \r\n        for a, b in zip(arr, arr_sorted):\r\n            count_first[a] += 1;\r\n            count_second[b] += 1; \r\n            if count_first == count_second:\r\n                ans+=1; \r\n        return ans; \r\n```\r\n**#time complexity: o(n^2)**\r\n\r\n优化： 使用一个counter，来记录arr和arr_sorted的区别\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        count = collections.defaultdict(int); \r\n        arr_sorted = sorted(arr); \r\n        counter = 0; \r\n        ans = 0; \r\n        for a, b in zip(arr, arr_sorted):\r\n            if count[a] == -1: #diff 减小\r\n                counter -= 1;\r\n            if count[a] == 0: #diff 增大\r\n                counter +=1; \r\n            count[a] +=1;\r\n            if count[b] == 1: #diff 减小\r\n                counter -= 1;\r\n            if count[b] == 0:#diff 增大\r\n                counter += 1;\r\n            count[b] -= 1;\r\n            if counter == 0: #遇到当arr, arr_sorted的数组全部相等是，ans++\r\n                ans += 1\r\n        return ans;\r\n```\r\n**#time complexity: o(nlogn) time for sorting**\r\n\r\n使用单调栈(单调递增）， 只用单调递增是，才能拆开，如果遇到比栈顶元素小的，则需要\r\n把栈里比该元素大的都pop出来，然后加入原来栈顶的元素。 \r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = [];\r\n        stack.append(arr[0]);\r\n        for i in range(1, len(arr)):\r\n            if stack and stack[-1] > arr[i]:\r\n                temp = stack[-1]; \r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop();\r\n                stack.append(temp); \r\n            else:\r\n                stack.append(arr[i]); \r\n        return len(stack)\r\n```\r\n**time complexity: o(n)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091842111","body":"\r\n思路： 让快指针先走k步，然后慢指针和快指针一起走走到尾部，此时慢指针就是在倒数K的位置。然后让快指针\r\n指向head，慢指针指向None. 返回倒数第k个点\r\n```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return head\r\n        length = 0; \r\n        curr = head; \r\n        slow = head;\r\n        fast = head; \r\n        while curr:\r\n            curr = curr.next;\r\n            length += 1;\r\n        k = k % length;\r\n        while fast.next:\r\n            fast = fast.next;\r\n            k -= 1;\r\n            if k < 0:\r\n                slow = slow.next; \r\n            \r\n        fast.next = head;\r\n        ans = slow.next;\r\n        slow.next = None;\r\n        return ans;\r\n\r\n```\r\ntime complexity: O(n)\r\nspace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092972337","body":"```\r\n Definition for singly-linked list.\r\n class ListNode(object):\r\n   def __init__(self, val=0, next=None):\r\n         self.val = val\r\n         self.next = next\r\n```\r\n思路： 指针的两辆交换，pre- A- B- next; \r\n交换过后为 pre-B-A-next,经过如下操作\r\nA.next = next; B.next = A, pre.next = B. \r\n时间复杂度： O(n)\r\n\r\n```\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head;\r\n        dummy = ListNode();\r\n        dummy.next = head\r\n        pre = dummy; \r\n        while head and head.next:\r\n            first_node = head;\r\n            second_node = head.next;\r\n            first_node.next = second_node.next;\r\n            second_node.next = first_node;\r\n            pre.next = second_node;\r\n            pre = first_node;\r\n            head = first_node.next;\r\n        return dummy.next;\r\n```\r\n\r\n\r\n```\r\n#recursive\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head;\r\n        first_node = head;\r\n        second_node = head.next;\r\n        first_node.next = self.swapPairs(second_node.next); \r\n        second_node.next = first_node;\r\n        print(second_node.val)\r\n        \r\n        return second_node; #returning second node in the original list \r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094194845","body":"```\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        node_list = set();\r\n        while headA:\r\n          node_list.add(headA);\r\n          headA = headA.next;\r\n        while headB:\r\n          if headB in node_list:\r\n            return headB; \r\n          headB = headB.next;\r\n        return None; \r\n```\r\n时间复杂度: O(n)\r\n\r\n\r\n```\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        a = headA;\r\n        b = headB;\r\n        while a != b:\r\n          a = a.next if a else headB;\r\n          b = b.next if b else headA;\r\n        return a; \r\n```\r\n时间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095164477","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        slow = fast = head;\r\n        while fast and fast.next:\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if fast == slow:\r\n                break;\r\n        if fast is None or fast.next is None:\r\n            return None; \r\n        fast = head; \r\n        while slow != fast:\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        return fast; \r\n```\r\n                \r\n#时间复杂度: O(n)， 空间复杂度: O(1)\r\n            ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085491869","body":"/* 求和的方法始终会溢出，故不可采取\r\n        size_t sum = 0, max_size = num.size();\r\n        // get the sum\r\n        for(int i(0); i < max_size; ++i)\r\n            // sum += num[i] * pow(10, max_size-i-1);\r\n            sum  = sum * 10 + num[i];\r\n        sum += k;\r\n        // int count(1), level(0);\r\n        // while(sum % count) {\r\n        //     level++;\r\n        //     count *= 10;\r\n        // }\r\n        // vector<int> tmp_vec[level];\r\n        // int i(0);\r\n        // while(level){\r\n        //     tmp_vec.push_back(sum / power(10, level-1));\r\n            \r\n        //     --level;\r\n        // }\r\n\r\n        // 对于数值的位的操作有：移位操作，不过基于十进制的移位可能需要重新设计；\r\n        // 转化为string类型；\r\n        // 通过for循环取余或除提取\r\n\r\n        string str_sum = to_string(sum);  //将int型转化为string，从而可以单独操作每一位；\r\n        const size_t length = str_sum.size();\r\n        vector<int> tmp_vec;\r\n        for(int i(0); i < length; ++i)\r\n            tmp_vec.push_back(str_sum[i]-48);\r\n\r\n        return tmp_vec;\r\n        */\r\n\r\n        string str_k = to_string(k);\r\n        size_t length_num = num.size();\r\n        size_t length_k = str_k.size();\r\n        int i = length_num-1;\r\n        int j = length_k-1;\r\n        int carry = 0;\r\n        while((i+1) && (j+1)){\r\n            num[i] = num[i] + str_k[j] - 48 + carry;\r\n            carry = 0;\r\n            if(num[i] >= 10){\r\n                carry = 1;\r\n                num[i] %= 10;\r\n            }\r\n            --i;\r\n            --j;\r\n        }\r\n\r\n        if(carry){\r\n            \r\n        }\r\n    }\r\n\r\n只能说 尝试了相加的方法，但是用了size_t后还是溢出，又采取了逐位相加，结果在判断上理解还是不够到位，对情况的分析很卡。最后没忍住看了官方题解，那么这题也就作废了。留此记录。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pfyyh":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085499940","body":"### 思路\r\n\r\n模拟加法\r\n\r\n按照低位求和，大于等于十则进一。\r\n\r\n\r\n\r\n存储结构，使用的是LinkedList。底层是链表结构，往链表头插入元素。低位先进入链表，高位最后。减少一次反转\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //以num数组为基准\r\n        LinkedList<Integer> deque = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            //计算当前位\r\n            int value = num[i] + k % 10;\r\n            //丢弃最低位\r\n            k /= 10;\r\n            //如果结果大于10，k进1\r\n            if (value >= 10) {\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            deque.addFirst(value);\r\n        }\r\n        //如果数组用完了，将K剩下的高位放进去\r\n        for (; k > 0; k /= 10) {\r\n            deque.addFirst(k % 10);\r\n        }\r\n        return deque;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(N+M,N))，其中 N 为数组长度,M=K长度-N长度。\r\n- 空间复杂度：O(max(N+M,N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086630219","body":"### 思路\n\n借鉴了滑动窗口算法，找到第一个和第二个出现字符的位置。\n\n比较下标-头的距离和尾巴-下标的距离，填入数组。\n\n当下标到达尾巴的时候，说明已经\n\n当S字符串只有一个符合的c的时候，从符合位置点往两边填充距离。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //存储结果\n        int[] result = new int[s.length()];\n        //判断滑动窗口\n        int head = s.indexOf(c);\n        int tail = s.indexOf(c, head + 1);\n        //说明没有窗口，直接填充两边值即可\n        if(tail==-1){\n            int absLength = 0;\n            int lP = head;\n            int rP = head;\n            //从唯一的下标开始往两边扩展\n            while(lP>=0||rP<s.length()){\n                if(lP>=0){\n                    result[lP]=absLength;\n                    lP--;\n                }\n                if(rP<s.length()){\n                    result[rP]=absLength;\n                    rP++;\n                }\n                absLength++;\n            }\n            return result;\n\n        }\n        char[] chars = s.toCharArray();\n        \n        for (int i = 0; i < chars.length; i++) {\n            result[i] = Math.min(Math.abs(head - i), Math.abs(tail - i));\n            //遍历到了尾巴，尾巴变头，找下一个尾巴。\n            if (i == tail) {\n                head = tail;\n                //如果尾巴没了，tail = -1 tail-i的绝对值永远大于head-i的绝对值,永远是head-i\n                tail = s.indexOf(c, tail + 1);\n            }\n        }\n        return result;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086863323","body":"### 思路\n\n最开始想的是直接使用LinkedList，用着用着越不对劲。\n\n用数组重写，重要的就是当前栈顶所在位置的管理。\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int iPoint;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        iPoint = -1;\n    }\n    \n    public void push(int x) {\n        //如果到了最后\n        if (iPoint == stack.length-1) {\n            return;\n        }\n        //向右偏移一位\n        iPoint++;\n        //存值\n        stack[iPoint] = x;\n    }\n    \n    public int pop() {\n        //栈底\n        if (iPoint == -1) {\n            return iPoint;\n        }\n        --iPoint;\n        //直接返回即可，后面直接覆盖\n        return stack[iPoint + 1];\n    }\n    \n    public void increment(int k, int val) {\n        //影响数量\n        int num = Math.min(k, iPoint + 1);\n        //修改值\n        for (int i = 0; i < num; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 时间复杂度\n\npush和pop都是栈顶直接操作，O(1)\n\nincrement遍历的数组O(num),num为临时的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087376958","body":"### 思路\n\n使用一个LinkedList作为栈，依次遍历S\n\n情况1：数字，如果是数字，有可能接下来几位都是数字，遍历到不是数字为止。\n\n情况2：字母和\"[\",直接入栈即可。\n\n情况3：\"]\",出栈到临时栈，直到出现\"[\"。然后再出一次必定是数字n。把栈转字符串循环n次。然后在放进linkedList。\n\n### 代码\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            //如果是数字接下来几位都有可能是数字\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：解析后的字符串长度O(n)\n\n空间复杂度：没有多余的空间，存储解析后的字符串长度。O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088657676","body":"### 思路\n\n就有点类似于最开始学编程的时候，两个塔，左边塔321，右边空。然后依次取出放到右边的塔就是123。\n\n### 代码\n\n```java\nimport java.util.LinkedList;\nimport java.util.List;\n\nclass MyQueue {\n\n\n    int head = -1;\n    LinkedList<Integer> result;\n\n    public MyQueue() {\n        result = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (result.isEmpty()) {\n            head = x;\n        }\n        LinkedList<Integer> integers = new LinkedList<>();\n        while (!result.isEmpty()) {\n            integers.push(result.pop());\n        }\n        integers.push(x);\n        while (!integers.isEmpty()) {\n            result.push(integers.pop());\n        }\n    }\n\n    public int pop() {\n        int value = result.pop();\n        if (!result.isEmpty()) {\n            head = result.peek();\n        }\n        return value;\n    }\n\n    public int peek() {\n//        不能使用 result.getFirst();\n        return head;\n    }\n\n    public boolean empty() {\n        return result.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n### 复杂度分析\n\n时间复杂度：\n\n1. push:O(n)\n2. pop:O(1)\n3. peek:O(1)\n4. empty:(1)\n\n空间复杂度：\n\n1. push用了额外空间，*O*(*n*)\n2. pop:O(1)\n3. peek:O(1)\n4. empty:(1)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090395075","body":"### 思路\r\n\r\n想了排序块想了半天，才理解题解里面的while。\r\n32132     5\r\n3,5\r\n\r\n##### 排序块定义\r\n\r\n当某块后面的元素都大于此块内的元素，那么此块为排序块\r\n\r\n每块长度最少为 1，即每个元素可单独成块.\r\n\r\n###### 前提\r\n\r\n前一个块的最大值，小于后一个块的最小值\r\n\r\n如果当前值 num 大于等于 前面块的最大值，那么 num 就可以单独成块\r\n\r\n如果当前值 num 小于 前面块的最大值，那么我们需要往前一直找，直到找到一个块 block 的最大值小于等于当前值\r\n\r\n作者：suan-tou-wang-ba\r\n链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/leetcode-768-wo-gan-jio-jiang-de-ying-gai-xiang-xi/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for (int num : arr) {\r\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if(!stack.isEmpty()){\r\n                stack.addFirst(num);\r\n            }else if (!stack.isEmpty() && num < stack.getFirst()) {\r\n                //栈里面的元素都是块里面的最大值，获取最大值。\r\n                int cur = stack.removeFirst();\r\n                // 一直获取栈整\r\n                while (!stack.isEmpty() && num < stack.getFirst()) {\r\n                    stack.removeFirst();\r\n                }\r\n                stack.addFirst(cur);\r\n            } else {\r\n                stack.addFirst(num);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stack.size();\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)O(N)，其中 N 为数组长度。\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091640700","body":"### 思路\n\n今天比昨天好多了。首位相连，然后当k为0,就相当于尾巴在length的地方，刚好转一圈。其余时间遍历到length-(k%length)即可。k%length表示最后一圈，偏移位置。\n\n### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode cur = head;\n        int length = 1;\n        //找到末尾\n        while(cur.next!=null){\n            length++;\n            cur = cur.next;\n        }\n        //成环\n        cur.next = head;\n        //遍历次数 length -(k%length),k%length表示一圈内\n        //从头开始\n        for(int i=0;i<length-(k%length);i++){\n            cur = cur.next;\n        }\n        head = cur.next;\n        cur.next = null;\n        return head;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(n+(length-(k%length))),n为链表长度，length-(k%length),最坏情况O(2n)\n\n空间复杂度：没有额外空间，O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093026145","body":"## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n\r\n\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n最小单位两个节点。两个节点为一组，进行交换，通过递归的方式获取每组的开头，并交换每组的顺序。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode firstNode) {\r\n        //如果只有一个节点，直接返回\r\n        if (firstNode == null || firstNode.next == null) {\r\n            return firstNode;\r\n        }\r\n        //获取第下个节点如果只有1 ，2 。值为2\r\n        ListNode secondNode = firstNode.next;\r\n        //通过方法获取第三个节点，如果只有1，2。返回结果null,如果有1，2，3，4。当前层交换了，1和2。通过方法获取下两个节点交换数据。\r\n        firstNode.next = swapPairs(secondNode.next);\r\n        //下个节点指向第一个节点\r\n        secondNode.next = firstNode;\r\n        //返回下个节点就是头\r\n        return secondNode;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094250692","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 链表的遍历\n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  链表A = 链表A独特节点长度+AB重合节点长度。链表B = 链表B独特节点长度+AB重合节点长度，可以得出A+AB+B = B+AB+A。\n描述就是两个指针分别指向两个头。然后同速度跑，其中一个到了尾部（假设A链表跑完了，说明A短于B）以后，切换到另一个链表(B)进行奔跑。因为是同速，都跑了已经跑了A+AB的距离。还差B(B链表独特节点终点位置)就能到达相交点。\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA==null||headB==null){\n            return null;\n        }\n        ListNode pA = headA;\n        ListNode pB = headB;\n        //同速度前进\n        while(pA!=pB){\n            //换条跑道,追pB，独特A距离+相同距离C+独特B距离\n            if(pA==null){\n                pA=headB;\n            }else{\n                //没到跑到终点,继续跑\n                pA = pA.next;\n            }\n            //换条跑道,追pA，独特A距离+相同距离C+独特B距离\n            if(pB==null){\n                pB=headA;\n            }else{\n                //没到跑到终点,继续跑\n                pB = pB.next;\n            }\n        }\n        return pA;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\nm为A链表长度，n为B链表长度\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095132510","body":"\n## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  哈希表\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n         //如果没有节点或者只有一个节点，不构成环直接返回。\n        if (head == null || head.next == null) {\n            return null;\n        }\n        HashSet<Integer> set = new HashSet<>();\n        ListNode cur = head;\n        while (cur!=null){\n            boolean result = set.add(cur.hashCode());\n            //说明存在环\n            if (!result){\n                return cur;\n            }\n            cur = cur.next;\n        }\n        return null;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085515819","body":"```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        p = len(num) - 1\n        while k:\n            k += num[p]            \n            v = k % 10    \n            num[p] = v\n            \n            k //=10\n            p -= 1\n        \n            if p < 0:\n                break\n        \n        while k:\n            v = k % 10\n            num = [v] + num\n            k //= 10\n        \n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086570363","body":"```python\nclass Solution:\n    def shortestToChar(self, S, C):\n        def letter_get(letter, dr):\n            n = len(S)\n            res, cur = [0]*n, -n\n            for i in range(n)[::dr]:\n                if S[i] == letter: cur = i\n                res[i] = abs(i - cur)\n            return res\n        \n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797319","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:        \n        if self.inc:\n            self.inc[min(k, len(self.inc)) - 1] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087138877","body":"1. recursion\n\n``` python\n\nclass Solution:\n    \n    def decodeString(self, s: str) -> str:  \n        closePos = {}   \n        stack = []\n        for i, c in enumerate(s):\n            if c == '[':\n                stack.append(i)\n            elif c == ']':\n                closePos[stack.pop()] = i\n\n        def solve(l, r):\n            num = 0\n            ans = []\n\n            while l <= r:\n                c = s[l]\n                if c.isdigit():\n                    num = num * 10 + int(c)\n                elif c == '[':\n                    ans.append(num * solve(l + 1, closePos[l] - 1))\n                    num = 0\n                    l = closePos[l]\n                else:\n                    ans.append(c)\n                l += 1\n            return \"\".join(ans)\n        return solve(0, len(s) - 1)\n\n```\n\n2. stack\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:        \n        stack = []\n        num = 0\n    \n        stack.append(\"\")\n        \n        for c in s:\n            #print(c)\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append(num)\n                num = 0\n                stack.append(\"\")\n            elif c == ']':\n                str2 = stack.pop()\n                n = stack.pop()\n                str1 = stack.pop()                \n                stack.append(str1 + n * str2)                \n                \n            else:               \n                stack[-1] += c\n            \n            #print(tmp)\n            #print(stack)\n        return stack[0]\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088258264","body":"### Analysis\nUse two stacks to reverse output order. Only move elements from input stack to output stack when previous elements in output are all popped out. \n### Code\n``` Python\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []\n        self.output = []\n\n    def push(self, x: int) -> None:\n        self.input.append(x)\n    \n    def pop(self) -> int:\n        self.move()\n        return self.output.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.output[-1]\n        \n    def empty(self) -> bool:\n        return not self.input and not self.output\n    def move(self):\n        if not self.output:\n            while self.input:\n                self.output.append(self.input.pop())\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### Complexity:\nTime Complexity: O(1) \nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089928397","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:        \n        stack = []\n        \n        for a in arr:\n            if stack and stack[-1] > a:\n                curr = stack[-1]\n                \n                while stack and stack[-1] > a:\n                    stack.pop()\n                \n                stack.append(curr)\n            \n            else:\n                stack.append(a)\n                \n        return len(stack)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091155478","body":"### Analysis:\nconnect head with tail, move l-k%l steps, then break\n\n### code\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0:\n            return head\n        \n        dummy = ListNode()\n        \n        dummy.next = head\n        l = 0\n        while dummy.next:\n            dummy = dummy.next\n            l += 1\n        \n        k = k % l\n        m = l - k\n        \n        dummy.next = head\n        \n        for i in range(m):\n            head = head.next\n            dummy = dummy.next\n        \n        dummy.next = None\n        \n        return head\n```\n\n### Complexity\nTime: O(N)\nSpace:O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094167922","body":"``` python\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        node_in_B = set()\n        \n        while headB:\n            node_in_B.add(headB)\n            headB = headB.next\n        \n        while headA:\n            if headA in node_in_B:\n                return headA\n            else:\n                headA = headA.next\n        \n        return None\n```\n\n```python\n\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        \n        pA = headA\n        pB = headB\n        \n        while pA != pB:\n            if not pA:\n                pA = headB\n            else:\n                pA = pA.next\n            if not pB:\n                pB = headA\n            else:            \n                pB = pB.next\n        \n        return pA\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095208146","body":"```python \nclass Solution:\n \n    \"\"\"\n    def detectCycle(self, head: ListNode) -> ListNode:\n        visited = set()\n        \n        while head:\n            if head in visited:\n                return head\n            visited.add(head)\n            head = head.next\n        return None\n    \"\"\"\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast = slow = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                break\n        else:\n            return None\n        \n        while head != slow:\n            head = head.next\n            slow = slow.next\n            \n        return head\n    \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085517916","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] =divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry \r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\nspace `O(M+N)` time `O(N)`","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086798751","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.add = []\r\n        self.size = 0\r\n        self.max_size = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            v = self.stack.pop()\r\n            i = self.add.pop()\r\n            self.size -= 1\r\n            if self.size > 0:\r\n                self.add[-1] += i\r\n            return v+i\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        if n >= 1:\r\n            self.add[n-1] += val\r\n```\r\ntime `O(1)`, space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086969087","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c != ']':\r\n                stack.append(c)\r\n            else:\r\n                seg = \"\"\r\n                while True:\r\n                    if stack:\r\n                        val = stack.pop()\r\n                        if val != \"[\":\r\n                            seg += val\r\n                        else:\r\n                            break\r\n                k = \"\"\r\n                while True:\r\n                    if stack and stack[-1] in \"0123456789\":\r\n                        k += stack.pop()\r\n                    else:\r\n                        break\r\n                for i in range(int(k[::-1])):\r\n                    for s in seg[::-1]:\r\n                        stack.append(s)\r\n        return \"\".join(stack)\r\n```\r\ntime `O(N)` space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087904031","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        self.push_stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.pop_stack.pop()\r\n        \r\n        \r\n\r\n    def peek(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if self.pop_stack or self.push_stack:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\ntime `O(1)` space `O(N)`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089927561","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        chunk = []\r\n        for val in arr:\r\n            if chunk:\r\n                if chunk[-1] <= val:\r\n                    chunk.append(val)\r\n                else:\r\n                    max = chunk[-1]\r\n                    while len(chunk)>0 and chunk[-1] > val:\r\n                        chunk.pop()\r\n                    chunk.append(max)\r\n            else:\r\n                chunk.append(val)\r\n        return len(chunk)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091162606","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        head_copy = head\r\n        n = 1\r\n        while head_copy.next:\r\n            head_copy = head_copy.next\r\n            n += 1\r\n            \r\n        if k%n == 0:\r\n            return head\r\n        \r\n        head_copy = head\r\n        acc = 1\r\n        while head_copy.next:\r\n            if acc == n-k%n:\r\n                new_head = head_copy.next\r\n                head_copy.next = None\r\n            else: \r\n                head_copy = head_copy.next\r\n                acc += 1\r\n        help_head = new_head\r\n        while help_head.next:\r\n            help_head = help_head.next\r\n        help_head.next = head\r\n        return new_head\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092541360","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            return head\r\n        \r\n        old_head = head\r\n        acc = 1\r\n        while old_head.next:\r\n            if acc % 2 != 0:\r\n                # need swap\r\n                if acc == 1:\r\n                    next_node = old_head.next\r\n                    old_head.next = next_node.next\r\n                    next_node.next = old_head\r\n                    result = next_node\r\n                    pre_node = next_node\r\n                else:\r\n                    next_node = old_head.next\r\n                    old_head.next = next_node.next\r\n                    next_node.next = old_head\r\n                    pre_node.next = next_node\r\n                    pre_node = next_node\r\n            else:\r\n                pre_node = old_head\r\n                old_head = old_head.next\r\n            acc += 1\r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093801416","body":"```\r\nclass Solution:\r\n    \r\n    def tolist(self, head):\r\n        val = []\r\n        while head:\r\n            val.append(head.val)\r\n            head = head.next\r\n        return val\r\n    \r\n    def genTree(self, vals, start, end):\r\n        \r\n        if start > end:\r\n            return None\r\n        mid = (start + end)//2\r\n        node = TreeNode(val=vals[mid])\r\n        if start == end:\r\n            return node\r\n        node.left = self.genTree(vals, start, mid-1)\r\n        node.right = self.genTree(vals, mid+1, end)\r\n        return node\r\n        \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        vals = self.tolist(head)\r\n        return self.genTree(vals, 0, len(vals)-1)\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094662719","body":"```\r\nclass Solution:\r\n    \r\n    def getIntersect(self, head):\r\n        fast, slow = head, head\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return None\r\n        \r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if not slow or not fast:\r\n                return None\r\n            if slow == fast:\r\n                return slow\r\n        return None\r\n        \r\n        \r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \r\n        slow = self.getIntersect(head)\r\n        fast = head\r\n        if slow == None:\r\n            return None\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return fast\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085528745","body":"## 代码\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086470126","body":"## 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const sArr = s.split('');\r\n    const keyArr = [];\r\n    const ans = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        if(ele === c){\r\n            keyArr.push(i);\r\n        }\r\n    }\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        const ele = sArr[i];\r\n        let minLen = sArr.length;\r\n        for (let j = 0; j < keyArr.length; j++) {\r\n            const keyEle = keyArr[j];\r\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\r\n        }\r\n        ans.push(minLen);\r\n    }\r\n    return ans;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086839680","body":"## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.length = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.length) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  return this.stack.pop() || -1;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (let i = 0; i < k; i++) {\n    if (!this.stack[i]) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087183681","body":"## code\n```js\nvar decodeString = function(s) {\n    const stack = [];\n    const strArr = s.split('');\n    while(strArr.length){\n        if (strArr[strArr.length-1] !== '[') {\n            stack.push(strArr.pop());\n        }else {\n            strArr.pop() // 去除 '['\n            let num = '';\n            while(!Number.isNaN(Number(strArr[strArr.length-1]))){\n                num = strArr.pop() + num;\n            }\n            let str = '';\n            while(stack[stack.length-1] !== ']'){\n                str = str + stack.pop();\n            }\n            stack.pop() // 去除 ']'\n            stack.push(str.repeat(Number(num)));\n        }\n    }\n    return stack.reverse().join('');\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088634322","body":"## code\n\n```js\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089926902","body":"## 思路\r\n值得思考的题目，看了答案半天，才懂\r\n## code\r\n```js\r\nclass Stack {\r\n    constructor() {\r\n        this.list = [];\r\n    }\r\n    push(val) {\r\n        this.list.push(val);\r\n    }\r\n    pop() {\r\n        return this.list.pop();\r\n    }\r\n    empty() {\r\n        return this.list.length === 0;\r\n    }\r\n    peek() {\r\n        return this.list[this.list.length - 1];\r\n    }\r\n    size() {\r\n        return this.list.length;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    const stack = new Stack();\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (stack.empty() || stack.peek() <= arr[i]) {\r\n            stack.push(arr[i]);\r\n        } else {\r\n            const temp = stack.pop();\r\n\r\n            while (stack.peek() > arr[i]) {\r\n                stack.pop();\r\n            }\r\n\r\n            stack.push(temp);\r\n        }\r\n    }\r\n    return stack.size();\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091003058","body":"## code\n```js\nvar rotateRight = function(head, k) {\n    let length = 1;\n    let cur = head;\n    if(cur === null) return null\n    while(cur.next){\n        length ++;\n        cur = cur.next; \n    }\n    cur.next = head; // 尾部续接\n    let node = {\n        val:head.val,\n        next:null,\n    }\n    let cur2 = head;\n    for(let i = 0;i<length-(k%length)-1;i++){\n        cur2 = cur2.next;\n    } \n    node.val = cur2.next.val;\n    node.next = cur2.next;\n    cur2.next = null;\n    \n    // head.val = node.val;\n    // head.next = node.next;\n    return node.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092348328","body":"## code\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {return head;}\r\n    let cur = head;\r\n    while(cur && cur.next){\r\n        let temp;\r\n        temp = cur.val;\r\n        cur.val = cur.next.val;\r\n        cur.next.val = temp;\r\n        cur = cur.next.next;\r\n    }\r\n    return head;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093744104","body":"## code\n```js\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094287436","body":"## code\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  let a = headA,\r\n    b = headB;\r\n  while (a != b) {\r\n    a = a === null ? headB : a.next;\r\n    b = b === null ? headA : b.next;\r\n  }\r\n  return a;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094447229","body":"## code\n```js\n var detectCycle = function(head) {\n     if (!head || !head.next) {\n         return null;\n     }\n     let node = head;\n     const nodeSet = new Set();\n     while (node) {\n        if (nodeSet.has(node)) {\n            return node;\n        }else{\n            nodeSet.add(node);\n            node = node.next;\n        }\n     }\n     return null;\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085530541","body":"## 思路\n1. 比较intuitive的想法就是先转换成字符串-> 数字+k ->字符串 \n2.  \n## 代码\n1. \n’‘’\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n                \n        int_str = ''\n\n        for i in num:\n            int_str += str(i)\n        \n        int_str = str(int(int_str) + k)\n\n        res=[int(i) for i in int_str]\n\n        return res\n‘’‘\n## 复杂度分析\n1. Time complexity: On; Space complexity On.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086603805","body":"## 思路\n先建造一个index list 存储target character相应的index\n\n在用index list 里面的值分别减去字符串单个的index，取最小值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        index = [i for i, j in enumerate(s) if j==c]\n\n        result = []\n        for i in range(len(s)):\n            a=[]\n            for ind in index:\n                b = abs(ind - i)\n                a.append(b)\n            min_num = min(a)\n            result.append(min_num)\n\n        return result\n\n```\n\n## 复杂度分析\n时间：最差On^2, 正常O(mn)    m 为index list 长度(最差m=n)  \\\n空间： On, index list 的worst case, On, result index 也是On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086742469","body":"## 思路一：暴力求解\n\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            stack[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\nTIME COMPLEXITY:  push 和 pop 都为O(1)，increment 为O(k),最差为O1 \\\nSPACE COMPLEXITY: O(maxSize)\n\n## 思路二：优化思路一的increment\n这里是参考了答案和评论区\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack= []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        if len(self.inc)>1:\n            self.inc[-2] +=self.inc[-1]\n           \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.inc))-1] += val\n```\n## 复杂度分析\nTIME COMPLEXITY: 都为O1 \\\nSPACE COMPLEXITY:  O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086937390","body":"## 思路 使用Stack和匹配括号的思想\npush value 进stack 直到碰到 ']', pop出value 进行相应数字的操作\n需要注意k的大小，不一定是个位数\n\n主要是string的需要很多细节处理，append pop出来的值什么时候需要reverse，pop出来的数字是以string形式出现，怎么转换成数字，reversed 不能和数字直接相乘，需要‘’。join()等等\n## 代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n\n        for char in s:\n            if char !=']':\n                stack.append(char)\n                continue\n\n            string = []\n            # 把 需要重复的值 pop出来，这个while循环结束之后stack.peek()是'['\n            while stack and stack[-1]!='[':\n                string.append(stack.pop())\n\n            # 去掉 '['    \n            stack.pop()\n\n\n            #这里我们要考虑k的值是多位数的情况, 第一个pop出来的的是个位数，再是十位数，百位数\n            #用repeat记录最终要repeat的次数\n            #用base记录有几位数，第一个数字 + 10 * 第二个数字 + 100* 第三个数字.....\n            repeat = 0\n            base = 1\n\n\n            #stack.pop()出来是数字的string形式，所以用ord()方法得到相应的数字\n            # ‘’join() 之后才能以string的形式进行运算\n            while stack and stack[-1].isdigit():\n                repeat = repeat + (ord(stack.pop())-ord('0')) * base\n                base = base * 10\n            stack.append(''.join(reversed(string))*repeat)\n\n            #现在得到的stack是 分开的 string element 例如 ['aaa', 'bcbc']\n\n\n        return ''.join(stack)\n        \n```\n## 复杂度分析\n不怎么会算复杂度，这里猜的 \\\n时间：O(n)\\\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087948715","body":"## 思路：第一次只用了一个stack，不符合题目要求两个stack\n还是先把想法留下\n\n## 代码\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        return self.queue.pop(0)\n\n    def peek(self) -> int:\n        return self.queue[0]\n\n    def empty(self) -> bool:\n        return self.queue ==[]\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n\n## 思路二：两个stack\noutqueue stack 直接 append inqueue pop 出来的值\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.inqueue = []\n        self.outqueue =[]\n\n    def push(self, x: int) -> None:\n        self.inqueue.append(x)\n        self.outqueue.append(self.inqueue.pop())\n\n    def pop(self) -> int:\n        return self.outqueue.pop(0)\n\n    def peek(self) -> int:\n        return self.outqueue[0]\n\n\n    def empty(self) -> bool:\n        return (not self.inqueue) and (not self.outqueue)\n        \n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## 复杂度分析 \n时间：\\\nPush - On \\\nPop - On \\\nPeek - O1 \\\nempty -O1 \\\n空间： \\\nPush - On \\\nPop - O1 \\\nPeek - O1 \\\nempty -O1 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089835794","body":"## 思路一： 先sorted，比较 sum\narr =              [2,2,1,3,4,4]\nsorted=\t\t\t\t\t[1,2,2,3,4,4]\n\n我们可以看出 \n* 2+2+1 = 1+2+3\n* 3 = 3\n* 4 = 4\n\n另一个例子\n\narr =            [1,1,2,1,1,3,4,5,1,6]\nsorted =      [1,1,1,1,1,2,3,4,5,6]\n\n* 1=1\n* 1=1\n* 2+1+1+3+4+5+1 = 1+1+1+2+3+4+5\n* 6=6\n\n只要到目前index的和是一样的话，就可以当成一个块\n\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sor = arr.copy()\n        sor.sort()\n        sum1= 0\n        sum2 =0\n\n        j=0\n        for i in range(len(arr)):\n            sum1 += arr[i]\n            sum2 += sor[i]\n\n            if sum1==sum2:\n                j+=1\n                sum1 = 0\n               #print(f'sum1: {sum1}')\n                sum2 = 0\n               # print(f'sum2: {sum2}')\n             \n        return j\n```\n## 复杂度分析\n时间：Onlogn \\\n空间：On\n\n## 思路二：左边chunk的最大值肯定小于等于右边chunk的最大值\n\n\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        n = len(arr)\n        res = 1\n        \n        max_ = arr[0]\n        \n        \n        for i in range(1,n,1):\n            min_ = arr[i]\n            for j in range(i+1 ,n ,1):\n                min_ = min(min_,arr[j])\n            if max_ <= min_:\n                res+=1\n            max_ = max(arr[i],max_)\n        \n        return res\n```\n## 复杂度分析\n时间：O(n^2), for every i loop 都会遍历 j:n 来找最小值 \\\n空间：O1\n\n\n## 思路三:  用Stack\n一开始先去做了 769\n没想到用stack， 看了tag 有monotonic stack，才意识到要这么做\n以后要记住 这种单调递增的想到栈\n\n-_-  没写出来，看了官方题解的。。。还是要多加练习\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # [1,1,2,1,1,3,4,5,1,6]\n        # [1,1,5,6]\n        \n        stack = []\n        \n        for num in arr:\n            if stack and stack[-1] > num:\n                curr_max = stack[-1]\n                \n                while stack and stack[-1]>num:\n                    stack.pop()\n                stack.append(curr_max)\n            else:\n                stack.append(num)\n                \n        return len(stack)\n            \n```\n## 复杂度分析\n时间：On \\\n空间：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091303058","body":"## 思路\n尾结点连到头结点，并在相应的cutoff位置，让cutoff.next指向None\n\n## 代码\n\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n\n        \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        tail = head \n        n = 1\n        \n        while tail.next:\n            tail = tail.next\n            n+=1 # 找到尾结点\n        \n        # 尾结点连到头部\n        tail.next = head\n        \n        # 接下来找新的断点\n        \n        cut_off = head\n        for i in range(n-k%n-1):\n            cut_off = cut_off.next\n            \n        # 断掉之前记录下新head的值\n        head = cut_off.next\n        \n        cut_off.next = None\n            \n        return head\n        \n```\n\n## 复杂度分析\n时间：On，这里的小优化就是当k很大的时候，旋转的次数 = k%长度 \\\n空间：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092512534","body":"## 思路：Iterative\n关键是要记录好指针的位置\n## 代码\n```\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        # [1] [2] [3] [4]\n        # [2] [1] [4] [3]\n        dummy = ListNode(0,head)\n        \n        # [dummy]   [1]   [2]   [3]   [4]\n        #  temp    node1 node2\n        temp = dummy\n        \n        # 因为是两两交换，所以是 while temp.next and temp.next.next:\n        while temp.next and temp.next.next:\n            \n            #[dummy] 指向[2]的时候，会丢掉[1]的位置，所以要记住\n            # node_1 为 [1]\n            node_1 = temp.next\n            # node_2 为 [2]\n            node_2 = temp.next.next\n            \n            # [temp] 指向 [2]\n            temp.next = node_2\n            # [2] 指向 [1] 的时候， 会丢掉 [3] 的位置，所以要先让[1] 指向 [3]\n            node_1.next = node_2.next\n            # 把 [2] 指向 [1]\n            node_2.next = node_1\n            \n            # 现在是这样\n            #[dummy] [2] [1] [3] [4]\n            \n            # 把 temp 移动到 [1]\n            # [dummy] [2] [1]   [3]     [4]\n            #             temp node1 node2\n            temp = node_1\n            \n        return dummy.next\n\n```\n## 复杂度\nTime Complexity : O(N) where N is the size of the linked list. /\n\nSpace Complexity : O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093349206","body":"## 思路一： linked list换成sorted list\n先去做了108  Convert Sorted Array to Binary Search Tree\n## 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n          \n        def buildBSTfromList(nums,l,r) -> TreeNode:\n\n            if l>r:\n                return None\n            m = l + (r-l)//2\n            root = TreeNode(nums[m])\n            root.left = buildBSTfromList(nums,l,m-1)\n            root.right = buildBSTfromList(nums,m+1,r)\n\n            return root\n        \n        res = []\n        while head:\n            res.append(head.val)\n            head = head.next\n        \n        return buildBSTfromList(res,0,len(res)-1)\n        \n```\n\n## 复杂度\n时间：On /\n空间：On\n\n## 思路二：双指针\n思路我有了，但是代码一直没搞明白 /\n答案参考了评论区，官方题解 /\n还是要多多学习 /\n## 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n          \n        if not head:\n            return head\n        \n        pre = None\n        slow = head\n        fast = head\n      \n        # 找中间节点\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n            \n            \n        # 如果slow = head的情况：\n        if pre:\n            pre.next = None\n        \n        node = TreeNode(slow.val)\n        \n        if slow == fast:\n            return node\n        \n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        \n        return node\n```\n## 复杂度分析\n令 n 为链表长度。 /\n\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)O /\n\n空间复杂度：空间复杂度为O(logn)O\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094215958","body":"## 思路一：hash table\n把b出现过的node存到set里面，遍历a，如果出现相同的node，那个node就是交点，如果没有返回None\n\n## 代码\n\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \n        b_nodes = set()\n        \n        while headB:\n            b_nodes.add(headB)\n            headB = headB.next\n            \n        while headA:\n            \n            if headA in b_nodes:\n                return headA\n            headA = headA.next\n        \n        return None\n```\n\n## 复杂度分析\n时间：O（m+n） \\\n空间：O（m) / O（n） 看哪个链表更长\n\n## 思路二：two pointers\n假设 Linked List， A，B 有相交点\n\na = Linked List A 在相交点之前的长度\nb = Linked List B 在相交点之前的长度\nc = 相交点之后的长度\n\n那么\n\na + b + c = b + a + c\n\n我们用两个指针分别指向A,B，在遍历完A,B之后，交换遍历，相遇的node就是相交的node，要是没有的话说明不相交。\n\n这里我们就不需要占用额外space去存储出现过的值了\n## 代码\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \n        dummy_a = headA\n        dummy_b = headB\n        \n        while dummy_a != dummy_b:\n            \n            dummy_a = headB if dummy_a is None else dummy_a.next\n            dummy_b = headA if dummy_b is None else dummy_b.next\n            \n                \n        return dummy_a\n```\n## 复杂度\n时间: O(n+m) \\\n空间：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094353120","body":"## 思路一：Hash Table\n\n## 代码\n```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return None\n        \n        memo = set()\n        \n        p = head\n        \n        while p:\n            if p in memo:\n                return p\n            else:\n                memo.add(p)\n                p = p.next\n```\n\n## 复杂度分析\n时间：On \\\n空间：On\n\n## 思路二：双指针\n快慢双指针\n一开始快指针每次前进两步，慢指针前进一步。当两个指针相遇之后，把快指针放回head，并以一步的速度前进。直到下次相交的地方就是入口\n\n1. 首先要判断环存不存在\n\t\t* \t有环的话，快慢指针必然相遇\n\t\t* \t没有环的时候，快指针会visit None，会catch error\n\t\t\n2. 知道有环之后，判定entry point\n    *   假设 a 是链表开始到entry point的距离\n    *   假设 b 是entry point到快慢指针第一次相遇的距离\n    *   假设 c 是 快慢指针第一次相遇到entry point的距离，也就是周长-b\n\n* \t\t慢指针 的 路程为 a+b\n* \t\t快指针 的 路程为 2（a+b），也可以写成 a + b + c + a\n\n\n2(a+b) = 2a + b + c\n\n2b = b + c\n\nb = c\n\n因此当快慢指针相遇之后，我们把快指针放回head，每次走一步，下一次和慢指针相交的时候就是entry point\n\n## 代码：\n```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        if not head or not head.next:\n            return None\n        \n        slow = head\n        fast = head\n        \n        while fast is not None and fast.next is not None:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        else:\n            return None\n            \n        fast = head\n        \n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        \n        return fast\n```\n## 复杂度：\n时间：On \\\n空间：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095338909","body":"## 哈希表+双向链表\n看到O1的get和put时间就想到Hash Table\n移动新建的和删除最不常使用的想到 linked list\n这道题之前没写过双向链表\n所以看了答案写的。。\n\n## 代码\n```\nclass DoubleLinkedListNode():\n    # 创建一个双向链表\n    def __init__(self,key=None,value=None):\n        self.key = key\n        self.value = value\n        self.prev= None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 初始化链表\n        self.head = DoubleLinkedListNode()\n        self.tail = DoubleLinkedListNode()\n        \n        self.head.next = self.tail\n        self.tail.prev= self.head\n        \n    def move_node_to_head(self,key):\n        # 先把哈希表指向的node提出来\n        node = self.hashmap[key]\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        # 把这个node插入头结点前面\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n        \n    def add_node_to_head(self,key,value):\n        new = DoubleLinkedListNode(key,value)\n        self.hashmap[key] = new\n        new.prev = self.head\n        new.next = self.head.next\n        self.head.next.prev = new\n        self.head.next = new\n        \n    def pop_tail(self):\n        # 哈希表去掉最后一个节点\n        last_node = self.tail.prev\n        self.hashmap.pop(last_node.key)\n        # 去掉节点\n        last_node.prev.next = self.tail\n        self.tail.prev= last_node.prev\n        return last_node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            self.move_node_to_head(key)\n        res = self.hashmap.get(key,-1)\n        if res ==-1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            self.hashmap[key].value = value\n            self.move_node_to_head(key)\n        else:\n            if self.capacity <= len(self.hashmap):\n                self.pop_tail()\n            self.add_node_to_head(key,value)\n```\n\n## 复杂度分析\n时间：O1 for put，get \\\n空间复杂度： O（capacity）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuyingliu2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085533007","body":"三种方法\n```\n暴力\n时间复杂度O(n)\n空间复杂度O(n)\n先把k转为字符串 然后转成int 和k相加再慢慢转回来\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,num))) + k)))\n```\n\n```\n模拟\n时间复杂度O(n)\n空间复杂度O(n)\n模板真好用hh\n```\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lstk = list(int(i) for i in str(k))\n        i = len(num) -1\n        j = len(lstk) -1\n        carry = 0\n        \n        res = []\n        while i >=0 or j >=0:\n            x = num[i] if i >=0 else 0\n            y = lstk[j] if j >=0 else 0\n            \n            sum = x + y + carry  \n            \n            keep = sum % 10\n            carry = sum // 10\n    \n            res.append(keep)\n               \n            i = i -1\n            j = j -1\n            \n        if carry != 0:\n            res.append(carry)\n        return res[::-1]\n```\n\n```\n把k加进去 这个和模拟差不多 \n看了别人的答案 感觉也不错\n```\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086542553","body":"两种方法\r\n```\r\n暴力\r\n把s中和c相等的index取出来 之后一个个和s中的index相减 max(abs(差))\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lst = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lst.append(i)\r\n        res= []\r\n        for i in range(len(s)):\r\n            dis = [] \r\n            for j in lst:\r\n                dis.append(abs(i-j))\r\n            res.append(min(dis)) \r\n        return res \r\n```\r\n\r\n```\r\n一个指针\r\n当满足两个条件p+=1\r\n1. p还没有走完\r\n2. i 到  p 的绝对距离 > 到p + 1的绝对距离\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n\r\n```\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        p = 0\r\n        lst = list(i for i in range(len(s)) if s[i] == c)\r\n\r\n        for i, j in enumerate(s):\r\n            if p < len(lst) -1 and abs(lst[p] -i) > abs((lst[p+1]) -i):\r\n                p+=1\r\n            res.append(abs(lst[p]-i))\r\n            \r\n        return res\r\n        \r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086744260","body":"```\r\n时间复杂度：O(1)\r\n空间复杂度：O(maxSize)\r\n```\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.stack.append(x)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            self.length -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.length)):\r\n            self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087213701","body":"```\r\n#时间复杂度 O(N)\r\n#空间复杂度 O(N)\r\n```\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        #注意可能有嵌套的中括号\r\n        stack = []\r\n        res = \"\"\r\n        mul = 0\r\n        \r\n        for ch in s:\r\n            if ch == \"[\":\r\n                stack.append([mul, res])\r\n                mul, res = 0, \"\"\r\n            elif ch == \"]\":\r\n                cur_mul, last_res = stack.pop()\r\n                res = last_res + cur_mul *res\r\n            elif \"0\" <= ch <= \"9\":\r\n                mul = mul * 10 + int(ch)\r\n            else:\r\n                res += ch\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088171826","body":"```\r\n时间复杂度:  O(N)\r\n空间复杂度:  O(N)\r\n```\r\n```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.outstack) == 0:\r\n            while len(self.instack) !=0:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n            \r\n    def peek(self) -> int:\r\n        if len(self.outstack) == 0:\r\n            while len(self.instack) !=0:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n        \r\n    def empty(self) -> bool:\r\n        if len(self.instack) == 0 and len(self.outstack) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089834866","body":"两种方法\r\n```\r\n前缀和\r\narr 和 sorted(arr) 如果如果两个数组的前缀和相等，说明到此可以划分为一段\r\n时间复杂度：O(NlogN) \r\n空间复杂度：O(N)\r\n\r\n```\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        presum1 = 0\r\n        presum2 = 0\r\n        res = 0\r\n        for a,b in zip(arr,sorted(arr)):\r\n            presum1 += a\r\n            presum2 += b\r\n            if presum1 == presum2:\r\n                res+=1\r\n        return res\r\n```\r\n```\r\n指针+滑动窗口 思路和前缀和一样\r\n\r\n```\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        left = 0\r\n        res = 0\r\n        nums = sorted(arr)\r\n        for right in range(1, len(arr) + 1):\r\n            if sum(nums[left:right]) == sum(arr[left:right]):\r\n                res +=1\r\n                left = right\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091124147","body":"``` \r\n#先形成环，再移动，再断开\r\n#时间复杂度：O(n)\r\n#空间复杂度：O(1)\r\n```\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        tail = head\r\n        length = 1\r\n        while tail.next:\r\n            length += 1\r\n            tail = tail.next\r\n        tail.next = head\r\n\r\n        k = k % length\r\n        for _ in range(length - k):\r\n            tail = tail.next\r\n\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092341986","body":"```\r\n看了答案明白了\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(1)\r\n```\r\n```\r\n\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        dummy = ListNode()\r\n        dummy.next = head\r\n        cur = head\r\n        pre = dummy\r\n \r\n        \r\n        while cur and cur.next:\r\n            nex = cur.next\r\n\r\n            cur.next = nex.next\r\n            nex.next = cur\r\n            pre.next = nex\r\n\r\n            pre = cur\r\n            cur = cur.next\r\n        return dummy.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093641484","body":"```\r\n先找出链表的中点 然后再建树 （中点就是树的根）\r\n时间复杂度: O(NlogN) \r\n空间复杂度: O(logN) \r\n```\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n\r\n        def findmid(start, end):\r\n            slow = start\r\n            fast = start\r\n            \r\n            while fast != end and fast.next != end:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        \r\n        \r\n        def buildtree(start, end):\r\n            if start == end:\r\n                return\r\n            \r\n            mid = findmid(start, end)\r\n            \r\n            root = TreeNode(mid.val) #root = TreeNode(findmid(start, end).val)\r\n            root.left = buildtree(start, mid)\r\n            root.right = buildtree(mid.next, end)\r\n            \r\n            return root\r\n        return buildtree(head, None)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094165704","body":"```\r\n#solution 1\r\n#要用到哈希表 先将其中一个链表存到哈希表中，此时再遍历另外一个链表查找重复结点\r\n#尝试用列表但是超时了 因为列表判断元素是否存在比集合慢很多\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N)\r\n```\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        s = set()\r\n        p,q = headA, headB\r\n        while p:\r\n            s.add(p)\r\n            p= p.next\r\n        while q:\r\n            if q in s:\r\n                return q\r\n            q= q.next\r\n        return None\r\n```\r\n```\r\n\r\n#solution2  栈\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(N)\r\n#注意 这里比的是内存地址 不仅仅是node里的数字 is/==\r\n#最后== 是从后往前找直到找到最后一个相同的点\r\n```\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        s1, s2 = [], []\r\n        p, q = headA, headB\r\n        while p:\r\n            s1.append(p)\r\n            p = p.next\r\n        while q:\r\n            s2.append(q)\r\n            q = q.next\r\n        ans = None\r\n        i, j = len(s1) - 1, len(s2) - 1\r\n        while i >= 0 and j >= 0 and s1[i] == s2[j]:\r\n            ans = s1[i]\r\n            i, j = i - 1, j - 1\r\n        return ans\r\n```\r\n```    \r\n#solution 3 计算长度\r\n#时间复杂度: O(N)\r\n#空间复杂度: O(1)\r\n```\r\n```\r\n        s1, s2 = 0, 0\r\n        p, q = headA, headB\r\n        # 计算长度\r\n        while p:\r\n            p = p.next\r\n            s1 += 1\r\n        while q:\r\n            q = q.next\r\n            s2 += 1\r\n        # 长链表先走，但不确定AB谁长，所以有两个循环，但实际上有至少一个循环不会执行\r\n        p, q = headA, headB\r\n        for i in range(s1 - s2):\r\n            p = p.next\r\n        for i in range(s2 - s1):\r\n            q = q.next\r\n        while p and q and p != q:\r\n            p = p.next\r\n            q = q.next\r\n        return p\r\n```\r\n```\r\nsolution4 走过你来时的路 \r\n```\r\n```\r\n         A, B = headA, headB\r\n         while A != B:\r\n             A = A.next if A else headB\r\n            B = B.next if B else headA\r\n         return A\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094577876","body":"```\r\nSolution1: 用set\r\n时间复杂度: O(N)\r\n空间复杂度: O(N) 和题目要求不符合了 题目想要用O(1) 就是下面的方法\r\n```\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        seen = set()\r\n        while head:\r\n            if head in seen:\r\n                return head\r\n            seen.add(head)\r\n            head= head.next\r\n        return head\r\n\r\n```\r\n```\r\nSolution 2:\r\n先用两个指针 快慢指针找相遇的点\r\n再定义第二个慢指针从头开始走和前一个慢指针一起走 相遇的点就是入环的点\r\n时间复杂度: O(N)\r\n空间复杂度: O(1)\r\n```\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        slow = head\r\n        fast = head\r\n        slow2 = head\r\n        \r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                while slow2 != slow:\r\n                    slow2 = slow2.next\r\n                    slow = slow.next\r\n                return slow\r\n        return None\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"futurefields":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085538554","body":"Idea:high precision addition\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n    reverse(num.begin(), num.end());\n        for(auto&t : num){\n            k+= t;\n            t= k % 10;\n            k/= 10;\n        }\n        while(k) num.push_back(k % 10), k/= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\nSpace O(n) Time O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086576973","body":"Idea: scan from left to right, and reverse\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> answer(s.size());\r\n        int prev = -100000;\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                prev = i;\r\n            }\r\n            answer[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        for (int i = s.size() - 1; i >= 0; i--) {\r\n            if (s[i] == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = min(answer[i], prev - i);\r\n        }\r\n        return answer;\r\n    }\r\n};\r\n\r\nspace O(N), time O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087047463","body":"Idea: Stack\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int len = s.size();\r\n        int num = 0;\r\n        stack<int> numstack;\r\n        stack<string> strstack;\r\n        string cur = \"\";\r\n        string result = \"\";\r\n        for(int i=0; i<len; ++i)\r\n        {\r\n            if(s[i]>='0' && s[i]<='9')\r\n            {\r\n                num = 10*num + s[i] - '0';\r\n            }\r\n            else if(s[i] == '[')\r\n            {\r\n                numstack.push(num);\r\n                strstack.push(cur);\r\n                num = 0;\r\n                cur.clear();\r\n            }\r\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\r\n                cur += s[i];\r\n            else if(s[i] == ']')\r\n            {\r\n                int k = numstack.top();\r\n                numstack.pop();\r\n                for(int j=0; j<k; ++j)\r\n                    strstack.top() += cur;\r\n                cur = strstack.top();\r\n                strstack.pop();\r\n            }\r\n        }\r\n        result = result + cur;\r\n        return result;     \r\n    }\r\n};\r\nSpace: O(n), Time: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088206006","body":"Idea: Stack push and pop\r\n\r\n\r\nclass MyQueue {\r\n    private:\r\n    stack<int> a;\r\n    stack<int> b;\r\npublic:\r\n    MyQueue() {\r\n    }\r\n   void push(int x) {\r\n        a.push(x);\r\n    }\r\n    int pop() {\r\n        int num = 0;\r\n        if (b.empty())\r\n        {\r\n            while(!a.empty())\r\n            {\r\n                b.push(a.top());\r\n                a.pop();\r\n            }\r\n        }\r\n        if (!b.empty())\r\n        {\r\n            num = b.top();\r\n            b.pop();\r\n        }\r\n        return num;\r\n    }    \r\n int peek() {\r\n        int num = 0;\r\n        if (b.empty())\r\n        {\r\n            while(!a.empty())\r\n            {\r\n                b.push(a.top());\r\n                a.pop();\r\n            }\r\n        }\r\n        if (!b.empty())\r\n            num = b.top();\r\n         return num;\r\n    }  \r\nbool empty() {\r\n        if (a.empty() && b.empty())\r\n            return true;\r\n        return false;\r\n    }\r\n};\r\n\r\nspace: O(1), time: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094260636","body":"Idea: May revise the data\n\n'''\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *ans=NULL;\n        ListNode *p;\n        p=headA;\n        while(p!=NULL){\n            p->val=-p->val;\n            p=p->next;\n            }\n            p=headB;\n        while(p!=NULL){\n            // cout<<p->val<<\" \";\n            if (p->val<0){\n                ans=p;\n                break;\n            }\n            p=p->next;\n        }\n        p=headA;\n        while(p!=NULL){\n            p->val=-p->val;\n            p=p->next;\n        }\n        return ans;\n\n    }\n};\n\"'\n\nSpace: O(m+n), Time: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094462898","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n      if(head==nullptr) return nullptr;\n        unordered_set<ListNode*> visited;\n        ListNode* n1=head;\n        while(n1!=nullptr)\n        {\n            if(visited.count(n1)) return n1;\n            visited.insert(n1);\n            n1=n1->next;\n        }\n        return nullptr;   \n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wwang4768":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085550862","body":"***Idea***  \nTo convert the int k to string, and then can leverage math functions to add. Finally converting the result back to list. However this is very brute force. \n\n***Code***\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        numInt = int(''.join((str(i) for i in num)))\n       \n        temp = numInt + k\n        result = [int(j) for j in str(temp)]\n        \n        return result\n```\n\n***Complexity***  \nTime: O(n)  \nMemory usage: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665384","body":"***Idea***\n1) Loop through the string s and note down and note down the index of occurance of target char c \n2) Loop through s and array of all c occurance index again, create a temp int that stores the distance between current digit and each c occurance. If there is a shorter distance, update temp ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088816676","body":"***Idea***  \nTo use the two helper functions to implement pop() and push()\n\n***Code***  \n\n***Complexity***  \nTime complexity:   \nMemory complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090025745","body":"***Idea***  \nTo leverage hash table and stack to implement \n\n***Code***  \n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count=0\n        minarr=[]\n        prev=999999999\n        for item in arr[::-1]:\n            minarr.append(min(prev,item))\n            prev=min(prev,item)\n        minarr.reverse()\n        temp=0\n        for i in range(0,len(arr)-1):\n            temp=max(temp,arr[i])\n            if temp<=minarr[i+1]:\n                temp=0\n                count+=1\n        return  count+1\n```\n\n***Complexity***  \nTime: O(n)  \nMemory: O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093723639","body":"***Idea***  \nUse vector to facilitate calculations in left and right branches via a mid point  \n\n***Code***  \n```\nclass Solution {\npublic:\n    vector<int>v;\n    TreeNode*balance(vector<int>v){\n        if(v.size()==0){\n            return NULL;\n        }\n        if(v.size()==1){\n            return new TreeNode(v[0]);\n        }\n        int mid = v.size()/2;\n        TreeNode* node = new TreeNode(v[mid]);\n        vector<int>lnode(v.begin(), v.begin()+mid);\n        vector<int>rnode(v.begin()+mid+1, v.end());\n        node->left = balance(lnode);\n        node->right = balance(rnode);\n        return node;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n        while(head){\n            v.push_back(head->val);\n            head=head->next;\n        }\n        return balance(v);\n        \n    }\n};\n```\n\n***Complexity***  \nTime: \nMemory: ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085553826","body":"- ### 思路\n\t- 将数组转换成字符串，然后转换成整数\n\t- 然后做加法\n\t- 然后再将结果转换成数组\n- ### Code\n\t  ```python\t  \t  \n              class Solution:\n\t  \t      def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t  \t          str1 = ''.join([str(x) for x in num])\n\t  \t          number = int(str1)\n\t  \t          newNumber = number + k\n\t  \t          newList = list(map(int,str(newNumber)))\n\t  \t          return newList\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 O(n)\n\t- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086648516","body":"- Name: Leetcode No.821 字符的最短距离\n- ### 题目描述\n  ```\n  对给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n  \n  返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n  \n  两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n  \n  \n  示例 1：\n  输入：s = \"loveleetcode\", c = \"e\"\n  输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n  解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n  距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n  距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n  对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n  距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n  \n  \n  示例 2：\n  输入：s = \"aaab\", c = \"b\"\n  输出：[3,2,1,0]\n  \n  提示：\n  \t1 <= s.length <= 104\n  \ts[i] 和 c 均为小写英文字母\t\n  \t题目数据保证 c 在 s 中至少出现一次\n  ```\n- ### 思路\n\t- 遍历字符串，双指针，同时计算正反两个方向的字符的距离\n\t- 然后将得到的两个数组，对应位置进行比较，选择小的留下来\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**字符的遍历**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def shortestToChar(self, s: str, c: str) -> List[int]:\n\t  \t          prev1, prev2 = 2*len(s), 2*len(s)\n\t  \t          ans1,ans2 = [len(s)]*len(s), [len(s)]*len(s)\n\t  \t          j = len(s)-1\n\t  \t          for i in range(len(s)):\n\t  \t              if s[i] == c:\n\t  \t                  prev1 = i\n\t  \t              ans1[i] = abs(i - prev1)\n\t  \t              if s[j] == c:\n\t  \t                  prev2 = j\n\t  \t              ans2[j] = abs(j - prev2)\n\t  \t              j -= 1\n\t  \t          for i in range(len(s)):\n\t  \t              ans1[i] = min(ans1[i],ans2[i])\n\t  \t          return ans1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度 $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `min`\n\t\t- min选两个数中小的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086830285","body":"- ### 题目描述\n- 请你设计一个支持下述操作的栈。\n 实现自定义栈类`CustomStack`  ：\n `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\n  `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 x 添加到栈顶。\n  `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  `void inc(int k, int val)`：栈底的 k 个元素的值都增加 `val` 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 `val` 。\n 请你设计一个支持下述操作的栈。\n    \n  实现自定义栈类 CustomStack ：\n    \n  CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\n  void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\n  int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\n  void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n    \n    \n  示例 1：\n  输入：\n  [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n  [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n  输出：\n  [null,null,null,2,null,null,null,null,null,103,202,201,-1]\n  解释：\n  - CustomStack customStack = new CustomStack(3); // 栈是空的 []\n  - customStack.push(1);                          // 栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\n  - customStack.push(2);                          // 栈变为 [1, 2]\n  - customStack.push(3);                          // 栈变为 [1, 2, 3]\n  - customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\n  - customStack.increment(5, 100);                // 栈变为 [101, 102, 103]\n  - customStack.increment(2, 100);                // 栈变为 [201, 202, 103]\n  - customStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\n  - customStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\n  - customStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\n  - customStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n    \n    \n    \n  提示：\n  1 <= maxSize <= 1000;\n  1 <= x <= 1000;\n  1 <= k <= 1000;\n  0 <= val <= 100;\n  每种方法 increment，push 以及 pop 分别最多调用 1000 次\n- ### 思路\n\t- 设计初始函数，传入所需的变量数组的`maxSize`\n\t- 然后写入入栈，出栈，对栈中元素进行操作的函数\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈**这种数据结构的相关概念。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class CustomStack:\n\t  \t  \n\t  \t      def __init__(self, maxSize: int):\n\t  \t          self.maxSize = maxSize\n\t  \t          self.customStack = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          if len(self.customStack) < self.maxSize:\n\t  \t              self.customStack.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if self.customStack == []:\n\t  \t              return -1\n\t  \t          else:\n\t  \t              return self.customStack.pop(-1)\n\t  \t  \n\t  \t      def increment(self, k: int, val: int) -> None:\n\t  \t          for i in range(min(len(self.customStack), k)):\n\t  \t              self.customStack[i] += val\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your CustomStack object will be instantiated and called as such:\n\t  \t  # obj = CustomStack(maxSize)\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # obj.increment(k,val)\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: `push`: O(1); `pop`: O(1); `increment`: $O(min(k, maxSize))$\n\t- 空间复杂度 $O(maxSize)$ 我们产生了一个额外的 $maxSize$ 维的空间\n- ### 知识汇总\n\t- #### `类`\n\t\t- 类是抽象的概念，是一类东西的抽象化表述\n\t\t- 类的具体化实例化就是具体对象\n\t\t- 实例化对象可以调用类中所有函数\n\t\t- 在类中还有一个初始化函数，将一些特殊的属性值（变量），传入类","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087717362","body":"- ### 题目描述\n\t- 给定一个经过编码的字符串，返回它解码后的字符串。\n\t  编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n\t  你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n\t  此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n- ### 思路\n\t- 在字符串编码的过程中因为[]中的运算是先算里后外，也就是先进去的后出来。因此，可以利用**栈**这种数据结构。\n\t- 题目中的字符串，可以分成四种类型：数字，左中括号, 右中括号，字母\n\t- 遍历字符串\n\t\t- 如果字母存在临时变量res中\n\t\t- 数字存在Multi变量中\n\t\t- 如果遇到左中括号，将Multi和res入栈\n\t\t- 如果遇到右中括号，将顶端的数据出栈\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈-先入后出**，**子组合-递归**。\n- ### Code\n\t\n\t  ``` python\n\t  \t  class Solution:\n\t  \t      def decodeString(self, s: str) -> str:\n\t  \t          stack, res, multi = [], \"\", 0\n\t  \t          for c in s:\n\t  \t              if c == '[':\n\t  \t                  stack.append([multi, res])\n\t  \t                  res, multi = \"\", 0\n\t  \t              elif c == ']':\n\t  \t                  cur_multi, last_res = stack.pop()\n\t  \t                  res = last_res + cur_multi * res\n\t  \t              elif '0' <= c <= '9':\n\t  \t                  multi = multi * 10 + int(c)            \n\t  \t              else:\n\t  \t                  res += c\n\t  \t          return res\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$\n\t- 空间复杂度 $O(n)$\n- ### 知识汇总\n\t- #### `栈`\n\t\t- 栈是实现深度遍历的基础，栈在实例中有很多应用：\n\t\t\t- 函数调用栈\n\t\t\t- 浏览器前进后退\n\t\t\t- 匹配括号\n\t\t\t- 单调栈用来寻找下一个更大（更小）元素 推荐题目：Every-Sublist-Min-Sum","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088903262","body":"- ### 题目描述\n\t- 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\t  实现 MyQueue 类：\n\t  void push(int x) 将元素 x 推到队列的末尾\n\t  int pop() 从队列的开头移除并返回元素\n\t  int peek() 返回队列开头的元素\n\t  boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n\t  说明：\n\t  你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n\t  你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n- ### 思路\n\t- 这个题必修要用两个栈，来构造一个队列的结构。\n\t- 想法就是将第一个栈，出栈进入到第二个栈。这样的话第一个栈的栈顶就变成了第二个栈的栈底，此时，我们让第二个栈的数据出栈，就能达到整体数据先进先出的效果。\n- ### 题目考察点分析\n\t- 我觉得这个题，主要考查**栈-先入后出**，**队列-先进先出**。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class MyQueue:\n\t  \t  \n\t  \t      def __init__(self):\n\t  \t          self.stack1 = []\n\t  \t          self.stack2 = []\n\t  \t  \n\t  \t      def push(self, x: int) -> None:\n\t  \t          self.stack1.append(x)\n\t  \t  \n\t  \t      def pop(self) -> int:\n\t  \t          if len(self.stack2) == 0:\n\t  \t              for i in range(len(self.stack1)):\n\t  \t                  self.stack2.append(self.stack1.pop(-1))\n\t  \t          pop_number = self.stack2.pop(-1)\n\t  \t          return pop_number\n\t  \t  \n\t  \t      def peek(self) -> int:\n\t  \t          if len(self.stack2) == 0:\n\t  \t              for i in range(len(self.stack1)):\n\t  \t                  self.stack2.append(self.stack1.pop(-1))\n\t  \t          peek_number = self.stack2[-1]\n\t  \t          return peek_number\n\t  \t  \n\t  \t      def empty(self) -> bool:\n\t  \t          return  len(self.stack1)==0 and len(self.stack2)==0\n\t  \t  \n\t  \t  \n\t  \t  \n\t  \t  # Your MyQueue object will be instantiated and called as such:\n\t  \t  # obj = MyQueue()\n\t  \t  # obj.push(x)\n\t  \t  # param_2 = obj.pop()\n\t  \t  # param_3 = obj.peek()\n\t  \t  # param_4 = obj.empty()\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(2n)$ ，n是push的次数\n\t- 空间复杂度 $O(2n)$\n- ### 知识汇总\n\t- #### `栈`\n\t\t- 栈是实现深度遍历的基础\n\t\t\t- 函数调用栈\n\t\t\t- 浏览器前进后退\n\t\t\t- 匹配括号\n\t\t\t- 单调栈用来寻找下一个更大（更小）元素 推荐题目：Every-Sublist-Min-Sum\n\t\t- 对栈的操作\n\t\t\t- push\n\t\t\t- pop\n\t\t\t- top\n\t\t\t- 读取栈内元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090390783","body":"- ### 题目描述\n\t- 这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\t  arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。我们最多能将数组分成多少块？\n\n\t  示例 1:\n\t  输入: arr = [5,4,3,2,1]\n\t  输出: 1\n\t  解释:\n\t  将数组分成2块或者更多块，都无法得到所需的结果。\n\t  例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n\n\t  示例 2:\n\t  输入: arr = [2,1,3,4,4]\n\t  输出: 4\n\t  解释:\n\t  我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n\t  然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\n\n\t  注意:\n\t  arr的长度在[1, 2000]之间。\n\t  arr[i]的大小在[0, 10**8]之间。\n- ### 思路\n\t- #### 思路1\n\t\t- 用字典（ `collections.defaultdict(int)`）记录key数及出现的次数。\n\t\t- arr经过这个函数之后会编程排序了的arr(sorted(arr))\n\t\t- 如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的。\n\t- #### 思路2\n\t\t- 遍历数组\n\t\t- 将数组分成左右两个子数组，左边的数组的最大值，小于等于右边数组的最小值，就是一个子数组。\n- ### Code\n\t-\n\t  ``` python\n\t  \t  class Solution(object):\n\t  \t      def maxChunksToSorted(self, arr):\n\t  \t          count_a = collections.defaultdict(int)\n\t  \t          count_b = collections.defaultdict(int)\n\t  \t          ans = 0\n\t  \t  \n\t  \t          for a, b in zip(arr, sorted(arr)):\n\t  \t              count_a[a] += 1\n\t  \t              count_b[b] += 1\n\t  \t              if count_a == count_b: ans += 1\n\t  \t  \n\t  \t          return ans\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n^2)$ ，\n\t- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091911659","body":"- ### 思路\n\t- 链表跟数组差别还是蛮大的\n\t- 将链表的最后一个节点指向头节点\n\t- 找到切断的位置，(l-k%l)处指向`None`\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  #class ListNode:\n\t  \t  #    def __init__(self, val, next):\n\t  \t  #        self.val = val\n\t  \t  #        self.next = next\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def rotateRight(self, head, k):\n\t  \t          if k == 0 or not head  or not head.next: \n\t  \t              return head\n\t  \t          \n\t  \t          l = 1\n\t  \t          tail_node = head\n\t  \t          while tail_node.next:\n\t  \t              l += 1\n\t  \t              tail_node = tail_node.next\n\t  \t  \n\t  \t          \n\t  \t          cut = l - k%l\n\t  \t          if cut == l:\n\t  \t              return head \n\t  \t          cut_node = head\n\t  \t          for _ in range(cut-1):\n\t  \t              cut_node = cut_node.next\n\t  \t          \n\t  \t          re_headNode = cut_node.next\n\t  \t          cut_node.next = None\n\t  \t          tail_node.next = head\n\t  \t  \n\t  \t          return re_headNode\n\t  \t  \n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$ ，\n\t- 空间复杂度 $O(1)$ ，没有使用额外的空间资源","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093032970","body":"- ### 题目描述\n\t- 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n\t  \n\t  示例 1：\n\n\t  ```\n\t  输入：head = [1,2,3,4]\n\t  输出：[2,1,4,3]\n\t  ```\n\t  示例 2：\n\t  ```\n\t  输入：head = []\n\t  输出：[]\n\t  ```\n\t  \n\t  示例 3：\n\t  ```\n\t  输入：head = [1]\n\t  输出：[1]\n\t  ```\n- ### 思路\n\t- 两两交换的操作是可以分解求每一个子组合的问题，所以可以用递归的思想来做这个题\n\t- 比如前两个节点，作为一组组合两两交换。\n\t- 首先需要将第二个节点指向第一个节点，第二个节点作为新的头节点\n\t- 然后第一个节点指向第二组交换完了之后的头节点（这里用到了递归的思想）\n- ### Code\n\t- ``` python\n\t  # Definition for singly-linked list.\n\t  #class ListNode:\n\t  #    def __init__(self, val, next):\n\t  #        self.val = val\n\t  #        self.next = next\n\t  \n\t  class Solution:\n\t      def swapPairs(self, head: ListNode) -> ListNode:\n\t          if not head or not head.next:\n\t              return head\n\t          subResult = self.swapPairs(head.next.next)\n\t          newHead = head.next \n\t          newHead.next = head\n\t          head.next = subResult\n\t          return newHead\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(n)$，每个栈的节点都需要更新。\n\t- 空间复杂度 $O(n)$，栈空间的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094074315","body":"### 解题思路\r\n用快慢指针和递归\r\n\r\n### 代码\r\n```\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n＃\r\ndef\r\ninit (self, val=0, next=None) :\r\n＃\r\nself. val = val\r\n＃self.next = next\r\n# Definition for a binary tree node .\r\n# class TreeNode :\r\n＃def init_ (self, val=0, left=None, right=None) \r\n＃self.val = val\r\n#self.left = left\r\n＃self. right = right\r\nclass Solution:\r\ndef sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\nif not head:\r\nreturn head\r\nfast, slow, pre = head, head, None\r\nwhile fast and fast.next:\r\nfast = fast.next.next\r\npre = slow\r\nslow = slow.next\r\nif pre:\r\npre.next = None\r\nnode = TreeNode(slow,val)\r\nif slow == fast:\r\nreturn node\r\nnode. left = self.sortedListToBST (head)\r\nnode.right = self.sortedListToBST(slow.next)\r\nreturn node\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094300351","body":"- ### 题目描述\n\t- 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\t- 图示两个链表在节点 c1 开始相交：\n\t- 题目数据 保证 整个链式结构中不存在环。\n\t- 注意，函数返回结果后，链表必须 保持其原始结构 。\n- ### 思路\n\t- 利用双指针思想，一个指针从链表A出发，一个指针从链表B出发，当他们到达尾部的时候将指针指向彼此的头部，继续遍历，如果能相遇就是他们相交的位置，就是他们的头节点，如果不能相遇，那么就是没有相交\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  #class ListNode:\n\t  \t  #    def __init__(self, x):\n\t  \t  #        self.val = x\n\t  \t  #        self.next = None\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\t  \t          if not headA or not headB:\n\t  \t              return None\n\t  \t          pointer1 = headA \n\t  \t          pointer2 = headB\n\t  \t          while(pointer1 != pointer2):\n\t  \t              pointer1 = pointer1.next if pointer1 else headB\n\t  \t              pointer2 = pointer2.next if pointer2 else headA\n\t  \t          return pointer1\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(m+n)$ ，m,n 分别是两个链表的节点数。\n\t- 空间复杂度 $O(1)$ ，没有使用额外的空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095238273","body":"- ### 题目描述\n\t- 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\t- 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\t- 不允许修改 链表。\n\t- ![image.png](../assets/image_1649691428068_0.png)\n\t-\n- ### 思路\n\t- 利用双指针思想，快慢指针，快指针如果没遇到None，那么他和慢指针总是会在环上相遇\n\t- 但是相遇的点不一定是环的起始点，所以我们接下来还需要确定环的起始点\n\t\t- ![image.png](../assets/image_1649691529960_0.png)\n\t- 我们将指针走过的路程分为三段\n\t\t- 头到环的起始点，环的起始点到快慢指针相遇点m，相遇点到环的起始点\n\t\t- 快指针的节点数 = 2*慢指针的节点数(k)\n\t\t- 那么头到起始环点：k-m\n\t\t- 相遇点到起始环点：k-m\n\t\t- （都是以顺时针的顺序来计算）\n\t\t- 画图，找到等式关系\n\t\t- ![image.png](../assets/image_1649691939346_0.png)\n\t-\n- ### Code\n\t-\n\t  ``` python\n\t  \t  # Definition for singly-linked list.\n\t  \t  # class ListNode:\n\t  \t  #     def __init__(self, x):\n\t  \t  #         self.val = x\n\t  \t  #         self.next = None\n\t  \t  \n\t  \t  class Solution:\n\t  \t      def detectCycle(self, head: ListNode) -> ListNode:\n\t  \t          if not head or not head.next:\n\t  \t              return None\n\t  \t          Pointer1 = head\n\t  \t          Pointer2 = head.next.next\n\t  \t          if Pointer1 == Pointer2:\n\t  \t              return Pointer1\n\t  \t          if not Pointer1 or not Pointer2:\n\t  \t              return None\n\t  \t          while Pointer1 != Pointer2:\n\t  \t              if not Pointer1 or not Pointer2:\n\t  \t                  return None\n\t  \t                  break\n\t  \t              Pointer1 = Pointer1.next\n\t  \t              Pointer2 = Pointer2.next.next\n\t  \t              if Pointer1 == Pointer2:\n\t  \t                  return Pointer1\n\t  \t                  break\n\t  \t          return None\n\t  ```\n- ### 复杂度\n\t- 时间复杂度: $O(2k-m)$ ，k是慢指针的步数, m是其实环点到相遇点的位置。\n\t- 空间复杂度 $O(1)$ ，没有使用额外的空间\n- ### 知识点汇总\n\t- #### 双指针解决链表问题题型汇总\n\t\t- https://labuladong.github.io/algo/2/17/16/","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo660":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085579178","body":"* ### 思路\n\n最开始想着将num数组变为数字，再加K，但是数组的长度最大为1w，变量接收不了这么大的数。\n\n最后用数组从后向前遍历，加上k的值，注意进位与整除。\n\n* ### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for (int i=num.size()-1; i>=0 ;i--){\n            int temp = 0;\n            temp = (num[i] + k)%10;\n            k = (num[i] + k)/10;\n            res.insert(res.begin(), temp);\n        }\n        while (0 != k){\n            res.insert(res.begin(), k%10);\n            k /= 10;\n        }\n        return res;\n    }\n};\n```\n\n* ### 复杂度\n    * 时间复杂度O(max(n,c)) n为num的长度，c为k的位数\n    * 空间复杂度O(max(n,c)) n为num的长度，c为k的位数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086519518","body":"### 思路\n先从左向右遍历，再从右向左遍历取最小值\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size());\n        int pre = INT32_MIN/2;\n        for (int i = 0; i < s.size() ; i++){\n            if (s[i] == c) pre = i;\n            answer[i] = i - pre;\n        }\n        pre = INT32_MAX;\n        for (int i = s.size()-1 ; i >= 0 ; i--){\n            if (s[i] == c) pre = i;\n            if (answer[i] > (pre - i))\n                answer[i] = pre - i;\n        }\n        return answer;\n    }\n};\n```\n### 复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086890399","body":"```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        top = maxSize;\r\n        now = -1;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (now < top-1){\r\n            ++now;\r\n            stack[now] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (-1 == now) return -1;\r\n        int popNum = stack[now];\r\n        --now;\r\n        return popNum;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, now+1);\r\n        for (int i = 0; i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> stack;\r\n    int top;\r\n    int now;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087652562","body":"### 思路\n递归\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string r;\n        for (int i = 0; i < s.size(); i++){\n            int move = 0;\n            if (isdigit(s[i])){\n                i += cString(&s[i],r);\n            }else if(']' != s[i]){\n                r.push_back(s[i]);\n            }\n        }\n        return r;\n    }\n\n    int cString(string s, string &r){\n        int count = 0;\n        int num = 0;\n        int renum = 0;\n        while (isdigit(s[count])){\n            num = num*10 + (s[count] - '0');\n            count++;\n        }\n        count++;//'['计数加一\n        for (int i = 0; i < num; i++){\n            renum = count;\n            while (']' != s[renum]){\n                if (isdigit(s[renum])) {\n                    renum += cString(&s[renum],r);\n                }else{\n                    r.push_back(s[renum]);\n                }\n                renum++;\n            }\n        }\n        return renum;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088806024","body":"### 思路\r\n使用两个栈，一个进栈一个出栈，push时直接放入进栈，pop时若出栈为空，就将进栈全部push进入出栈。\r\n\r\n### 代码\r\n```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> stkin,stkout;\r\n    void in2out(){\r\n        while (!stkin.empty())\r\n        {\r\n            int a = stkin.top();\r\n            stkout.push(a);\r\n            stkin.pop();\r\n        }\r\n    }\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        stkin.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int topNum = 0;\r\n        if (stkout.empty()) in2out();\r\n        topNum = stkout.top();\r\n        stkout.pop();\r\n        return topNum;\r\n    }\r\n    \r\n    int peek() {\r\n        int topNum = 0;\r\n        if (stkout.empty()) in2out();\r\n        topNum = stkout.top();\r\n        return topNum;\r\n    }\r\n    \r\n    bool empty() {\r\n        return ((stkin.empty()) & (stkout.empty()));\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090361196","body":"### 思路\r\n使用哈希计数排序\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n//哈希解法\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        map<int,int> a;\r\n        map<int,int> b;\r\n        vector <int> sortArr = arr;\r\n        int renum = 0;\r\n        sort(sortArr.begin(), sortArr.end());\r\n        for (int i = 0; i <arr.size(); i++){\r\n            a[arr[i]] += 1;\r\n            b[sortArr[i]] += 1;\r\n            if (a == b) renum++;\r\n        }\r\n        return renum;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091811824","body":"### 思路\r\n* 旋转闭环链表\r\n* 快慢指针\r\n\r\n### 代码\r\n```c++\r\nclass Solution{\r\n//环形链表\r\n/* \r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k){\r\n        int size = 0;\r\n        if (nullptr == head) return head;\r\n        ListNode *ptr = head;\r\n        while (nullptr != ptr->next){\r\n            size++;\r\n            ptr = ptr->next;\r\n        }\r\n        size++;\r\n\r\n        int num = size - (k%size);\r\n\r\n        ptr->next = head;\r\n\r\n        for (int i = 0;i < num; i++){\r\n            ptr = ptr->next;\r\n        }\r\n        head = ptr->next;\r\n        ptr->next = nullptr;\r\n        return head;\r\n    } */\r\n//双指针快慢指针\r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k){\r\n        ListNode *fastPtr = head;\r\n        ListNode *lowPtr = head;\r\n        ListNode *tmp = head;\r\n        int size = 0;\r\n        if (nullptr == head) return head;\r\n        \r\n        while (nullptr != tmp){\r\n            size++;\r\n            tmp = tmp->next;\r\n        }\r\n        k = k%size;\r\n        while(nullptr != fastPtr->next){\r\n            if(k-- <=0) lowPtr = lowPtr->next;\r\n            fastPtr = fastPtr->next;\r\n        }\r\n        fastPtr->next = head;\r\n        head = lowPtr->next;\r\n        lowPtr->next = nullptr;\r\n        return head;\r\n    } \r\n};\r\n```\r\n### 复杂度\r\n* 时间复杂度On\r\n* 空间复杂度O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092919323","body":"### 思路\r\n在链表前面加上一个pre节点，然后进行交换\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (nullptr == head || nullptr == head->next) return head;\r\n        ListNode* preHead = new ListNode(-1,head);\r\n        ListNode* tmpPtr = preHead;\r\n        ListNode *cur = preHead->next;\r\n        while (nullptr != cur && nullptr != cur->next){\r\n            ListNode *second = cur->next;\r\n            cur->next = second->next;\r\n            second->next = cur;\r\n            tmpPtr->next = second;\r\n            tmpPtr = cur;\r\n            cur = cur->next;\r\n        }\r\n        return preHead->next;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094059006","body":"### 思路\r\n快慢指针递归\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (nullptr == head) return nullptr;\r\n        return getTree(head, nullptr);\r\n    }\r\n    TreeNode* getTree(ListNode* startPtr, ListNode* endPtr){\r\n        if (startPtr == endPtr) return nullptr;\r\n        ListNode* lowPtr = startPtr;\r\n        ListNode* fastPtr = startPtr;\r\n        while(endPtr != fastPtr && endPtr != fastPtr->next){\r\n            lowPtr = lowPtr->next;\r\n            fastPtr = fastPtr->next->next;\r\n        }\r\n        TreeNode* root = new TreeNode(lowPtr->val);\r\n        root->left = getTree(startPtr,lowPtr);\r\n        root->right = getTree(lowPtr->next,endPtr);\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094298690","body":"### 思路\r\n双指针，分别遍历两张表，两张表的总路程是一定的\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (nullptr == headA || nullptr == headB) return nullptr;\r\n        ListNode *ptrA = headA;\r\n        ListNode *ptrB = headB;\r\n        while (ptrA != ptrB){\r\n            ptrA = ptrA==nullptr?headB:ptrA->next;\r\n            ptrB = ptrB==nullptr?headA:ptrB->next;\r\n        }\r\n        return ptrA;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095124333","body":"### 思路\r\n使用快慢指针，快指针两步，慢指针一步，若链表有环，则快慢指针在环中相遇后，快指针重新指向head，一步一步的走，在快慢再次相遇时，就为环的入口。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slowPtr = head;\r\n        ListNode *fastPtr = head;\r\n        while(1){\r\n            if (nullptr == fastPtr || nullptr == fastPtr->next) return nullptr;\r\n            slowPtr = slowPtr->next;\r\n            fastPtr = fastPtr->next->next;\r\n            if (slowPtr == fastPtr) break;\r\n        }\r\n        fastPtr = head;\r\n        while(fastPtr != slowPtr){\r\n            slowPtr = slowPtr->next;\r\n            fastPtr = fastPtr->next;\r\n        }\r\n        return fastPtr;\r\n    }\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085584434","body":"## 思路\n将数组转换成整数，然后与整数K做加法，之后再转换成数组返回\n## 代码\nclass Solution:\n    def add_array_with_num(self, num: List[int], k: int) -> List[int]:\n        sum = 0\n        digit = 1\n        for i in range(len(num)-1, -1, -1):\n            sum += num[i]*digit\n            digit *= 10\n        sum += k\n        result = [0]*len(str(sum))\n        for i in range(len(result)-1, -1, -1):\n            result[i] = sum % 10\n            sum //= 10\n        return result\n## 复杂度分析\n空间复杂度：O(N) 时间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566322","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        Stack<Integer> stack = new Stack<>();\n        int[] ans = new int[s.length()];\n        int pre = - 1;\n        for (int i = 0 ; i < s.length(); i ++) {\n            if (s.charAt(i) == c) {\n                while (!stack.isEmpty() && s.charAt(stack.peek()) != c) {\n                    int p = stack.pop();\n                    ans[p] = pre >= 0 ? Math.min(Math.abs(p - i) , Math.abs(p - pre)) : Math.abs(p - i);\n                }\n                pre = i;\n            }\n            stack.push(i);\n        }\n        while (!stack.isEmpty()) {\n            int p = stack.pop();\n            ans[p] = s.charAt(p) == c ? 0 : Math.abs(p - pre);\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085594873","body":"```\r\nimport java.util.*;\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n      List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum =sum% 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(N) 时间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087227648","body":"```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n         String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = 10 * count + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            }\r\n            else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            }\r\n            else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder (resStack.pop());\r\n                int repeatTimes = countStack.pop();\r\n                for (int i = 0; i < repeatTimes; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            }\r\n            else {\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088300622","body":"```\r\nclass MyQueue {\r\n    private Stack<Integer> s1 = new Stack<>();\r\n    private Stack<Integer> s2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!s2.isEmpty()) {\r\n            s1.push(s2.pop());\r\n        }\r\n        s1.push(x);           \r\n    }\r\n    \r\n    public int pop() {   \r\n        while (!s1.isEmpty()) {\r\n       s2.push(s1.pop());\r\n       }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while(!s1.empty())\r\n       { s2.push(s1.pop());} \r\n        \r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s2.empty()&&s1.empty();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094034854","body":"参考官方题解\r\n```\r\nif(head == null) return null;\r\n      return dfs(head,null);\r\n  }\r\n  private TreeNode dfs(ListNode head, ListNode tail){\r\n      if(head == tail) return null;\r\n      ListNode fast = head, slow = head;\r\n      while(fast != tail && fast.next != tail){\r\n          fast = fast.next.next;\r\n          slow = slow.next;\r\n      }\r\n      TreeNode root = new TreeNode(slow.val);\r\n      root.left = dfs(head, slow);\r\n      root.right = dfs(slow.next, tail);\r\n      return root;\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wychmod":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085602602","body":"### 思路\n大体上是先将数组遍历一遍，将其转换为数字，然后与k相加，再将数字转换为数组\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = ''.join([str(n) for i, n in enumerate(num)])\n        sum = int(sum) + k\n        return [int(i) for i in str(sum)]\n```\n### 时间复杂度\n空间复杂度：O(n) 在将数字转换为数组的时候创建了数组\n\n时间复杂度：O(n) 遍历了有限次的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086544108","body":"### 思路\n（比较暴力）先把所有的e找出来下标放入数组中，然后将原数组的每一个点与所有e的下标对比取最小的那个。\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        el = []\n        for i, n in enumerate(s):\n            if n == c:\n                el.append(i)\n        res = [0]*len(s)\n        for i in range(len(s)):\n            less = abs(i-el[0])\n            for j in el:\n                less = min(abs(i-j), less)\n            res[i] = less\n        return res\n```\n### 复杂度分析\n时间复杂度：O(n*目标字符在数组中出现的次数)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086888495","body":"### 思路\n数组进行模拟，同时设置两个变量当前长度（不设也行）和最大长度，然后数组天生有pop函数\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = 0\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.stack.append(x)\n            self.length += 1\n\n\n    def pop(self) -> int:\n        if self.length > 0:\n            self.length -= 1\n            return self.stack.pop()\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(self.length, k)\n        for i in range(k):\n            self.stack[i] += val\n```\n### 复杂度分析\n时间复杂度：push O1 popO1 incOk\n\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087070949","body":"### 思路\n使用栈来进行括号匹配，遇到右括号将数字字母弹出，然后形成字符串，然后重新入栈。\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = ''\n        for i in s:\n            if i == ']':\n                tmp = stack.pop()\n                sem = ''\n                while tmp != '[':\n                    sem = tmp + sem\n                    tmp = stack.pop()\n                \n                num = ''\n                while stack and stack[-1].isdigit():\n                     tmp = stack.pop()\n                     num = tmp + num\n\n                res = int(num) * sem\n                stack.append(res)\n                \n            else:\n                stack.append(i)\n\n        return ''.join(stack)\n```\n### 复杂度分析\n时间复杂度：On\n\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088196794","body":"### 思路\n两个栈来回倒\n### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        self.stack2 = self.stack1[::-1]\n        res = self.stack2.pop()\n        self.stack1 = self.stack2[::-1]\n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return True if len(self.stack1) == 0 else False\n```\n### 复杂度分析\n时间复杂度pop On 其他O1\n空间复杂度 On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089739793","body":"### 思路\n单调栈，融合栈，一开始有这个思路想不到这么实现，就想到左边比右边大的要放一块，可是出现了新的小的不知道怎么写，单调栈立马实现。\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and stack[-1] > i:\n                m = stack[-1]\n                while stack and stack[-1] > i:\n                    stack.pop()\n                stack.append(m)\n            else:\n                stack.append(i)\n        return len(stack)    \n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091031084","body":"### 思路\n先算出链表的长度n，然后将尾部与头部相连，然后走n-（k%n）步，将尾部断开，然后将断开的尾部当头返回。\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        pre = dummy = cur = ListNode(-1, head)\n        n = 0\n        while pre.next:\n            n += 1\n            pre = pre.next\n        pre.next = head\n        k = k%n\n        for _ in range(n-k):\n            dummy = dummy.next\n        cur.next = dummy.next\n        dummy.next = None\n        return cur.next\n\n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092392211","body":"### 思路\n每次将两个原地交换，遍历一次\n### 代码\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        dummy = pre = ListNode(-1, head)\n        while pre.next and pre.next.next:\n            tmp = pre.next.next\n            pre.next.next = tmp.next\n            tmp.next = pre.next\n            pre.next = tmp\n            pre = pre.next.next\n        return dummy.next\n```\n### 复杂度分析\n时间复杂度：On\n空间复杂度：O1（始终只有交换时产生了一个中间变量）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094058945","body":"### 思路\n找到每次中间的节点，然后断开链接，两边选中点，递归。\n### 代码\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def process(head):\n            if not head:\n                return head\n            if not head.next:\n                return TreeNode(head.val)\n            fast = slow = head\n            pre = None\n            while fast and fast.next:\n                fast = fast.next.next\n                pre = slow\n                slow = slow.next\n            pre.next = None\n            tree = TreeNode(slow.val)\n            tree.right = process(slow.next)\n            tree.left = process(head)\n            return tree\n        return process(head)\n```\n### 复杂度\n空间复杂度 Ologn\n时间复杂度 Onlogn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094158000","body":"### 思路\na和b在节点相交之前的路径长度是不一样的，只要让a和b都走相同长度，那么最后相同的就是交点。\n### 代码\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        if not headA or not headB:\n            return None\n        a, b = headA, headB\n        while a!=b:\n            a = headB if a==None else a.next\n            b = headA if b== None else b.next\n        return a\n```\n### 复杂度分析\n时间复杂度 On\n空间复杂度 O1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094485523","body":"### 思路\n快慢指针，当两个相遇时，说明有环，然后让其中一个指针回到起点，两个同样速度走，再次相遇就是那个节点。\n### 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head or not head.next or not head.next.next:\n            return None\n        fast = head.next.next\n        slow = head.next\n        while slow != fast:\n            if not fast.next or not fast.next.next:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow = head\n        while slow != fast:\n            slow = slow.next\n            fast = fast.next\n        return slow\n```\n### 复杂度\n时间复杂度On\n空间复杂度O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085608090","body":"\n### 题目：\n\n【Day 1】989. 数组形式的整数加法 \n\n[力扣地址：989](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路：\n\n用的 python 语言\n\n- 用 c 作为进位记录值，用当前的 num 作为结果数组\n- 当 num 和 k 都没有结束的时候，进行 num[i] + 个位数 + 进位值\n- 当 k 没有结束的时候，进行将 k 剩下的转为 数组进行想加\n- 当 num 没有结束的时候，将当前的 i 和进位值加起来然后前面数组保留\n- 当 进位值 还未归 0 的时候，将 进位值增加到 数组最前面\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0  #进位\n        i = len(num) - 1 #数组位置\n\n       # 当num没结束 and k 没结束\n        while(k and i > -1):\n            n = num[i] + (k % 10) + c \n            k //= 10\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1\n        \n        # 当 k 没有结束的时候\n        while(k): \n            num = [(k % 10 +c)%10] + num \n            c = (k % 10 +c) // 10   \n            k = k // 10 \n           \n        # 当 数组没有结束的时候\n        while(i > -1):\n            n = c + num[i]\n            c = n // 10\n            num[i] = n % 10\n            i = i - 1  \n        # 当进位没有结束的时候\n        while(c):\n            num = [c] + num \n            c = 0\n\n        return num\n```\n\n\n\n### 时间复杂度：O（N）\n\n### 空间复杂度：O（N）\n\n反思：我可太笨了，思维不够缜密，最终还是写出垃圾冗长的代码，还得再学习一下...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665920","body":"### 题目：【Day 2】821. 字符的最短距离\n[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路1\n1. 新建列表存放字符 c 存在的位置\n2. 在 result 列表中，存放两次循环找出的最小 diff 距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        L = []\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                L.append(i)\n        for i in range(len(s)):\n            diff = 10000\n            for j in L:\n                if (abs(j - i)) < diff:\n                    diff = abs(j - i)\n            result.append(diff)\n        return result\n```\n### 复杂度\n时间复杂度：O(N^2)\n空间复杂度：O(N)\n\n\n### 思路2\n1. 循环找到字符 c 存在的位置\n2. 前后循环找到最短的距离\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = [99999 for i in s]\n        n = len(s)\n        for i in range(n):\n            if s[i] != c:\n                continue\n            result[i] = 0\n            for j in range(i-1, -1, -1):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n            if i == n-1:\n                break\n            for j in range(i+1, n):\n                if s[j] == c:\n                    result[j] = 0\n                    break\n                result[j] = min(abs(i-j), result[j])\n        return result\n```\n\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086780406","body":"### 题目：【Day 3】1381. 设计一个支持增量操作的栈\n\n[1381.设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 思路：\n\n用列表模拟栈的操作\n\n### 代码：\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.L = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if(len(self.L)<self.maxSize):\n            self.L.append(x)\n\n    def pop(self) -> int:\n        if(len(self.L) > 0):\n            return self.L.pop(-1)\n        else:\n            return -1\n        \n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i >= len(self.L):\n                break\n            self.L[i] += val\n```\n\n### 复杂度\n\n时间复杂度：O(N)  主要是在 increment()中用了一次循环\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087676518","body":"### 394.字符串的解码\n\n[394.字符串的解码](https://leetcode-cn.com/problems/decode-string/)\n\n### 思路\n\n用栈来模拟，首先除了 ] 都全部入栈，遇到 ] ，查找直到 [ ，之间需要重复的字符串，然后进行重复，重复变量 k（此处有坑，数字不一定是个位数）。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = []\n        for i in s:\n            if i == ']':\n                # 重复的字符串\n                s = ''\n                # 重复变量\n                k = '' \n                while(res[-1] != '['):\n                    s = res.pop() + s\n                res.pop()\n                while(res and res[-1].isdigit()):\n                    k = res.pop() + k\n                res.append(int(k) * s) #此处有坑\n                continue\n            res.append(i)\n        return ''.join(res)\n     \n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N) 遍历一遍，但是里面重复次数的时间不太确定\n\n空间复杂度：O(N) 列表\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088738141","body":"### 232. 用栈实现队列\n\n[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n### 思路\n\n用列表模拟栈，再模拟队列\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.L = []\n\n    def push(self, x: int) -> None:\n        self.L.append(x)\n\n    def pop(self) -> int:\n        print(self.L)\n        return self.L.pop(0)\n\n    def peek(self) -> int:\n        return self.L[0]\n\n\n    def empty(self) -> bool:\n        if(len(self.L) == 0):\n            return True\n        else:\n            return False\n\n```\n\n\n\n### 复杂度\n\n时间：O(1)\n\n空间：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090390665","body":"### 题目 ： 768. 最多能完成排序的块 II\n\n#### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n### 思路\n\n单调栈，单调增加栈\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = []\n        # 单调增栈\n        for i in arr:\n            if not res or i >= res[-1]:\n                res.append(i)\n            else:\n                max = res.pop()\n                while res and i< res[-1]:\n                    res.pop()\n                res.append(max)\n        return len(res)\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091836132","body":"### 题目： **【Day 7】61. 旋转链表** \n\n#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n### 思路\n\n1. 循环将最后一个节点和头节点连起来，顺便计算链表长度\n2. 计算边界值，k%长度，head为空和只有head一个节点\n3. 右边 l-k%l 长度后的节点断掉，头节点为下一个，返回头节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        p = head\n        l = 1\n        if not head or not head.next:\n            return head\n        while p.next:\n            l += 1\n            p = p.next\n        k %= l\n        if k == 0:\n            return head\n        p.next = head\n        for i in range(l - k):\n            p = p.next\n        head = p.next\n        #print(head.val)\n        p.next = None\n        return head\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092470808","body":"### 题目\n\n### 【Day 8】24. 两两交换链表中的节点 \n\n### 思路\n\n循环，每两个间隔的节点交换，使用递归，将子链递归，继续计算，直到节点为空或者只有一个节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        while not head or not head.next:\n            return head\n        next = head.next\n        head.next = self.swapPairs(next.next)\n        next.next = head\n        return next\n```\n\n\n\n### 复杂度\n\n时间复杂度: O(N)\n\n空间复杂度: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094036432","body":"### 题目\n\n【Day 9】109. 有序链表转换二叉搜索树 \n\n[109. 有序链表转换二叉搜索树 ](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/submissions/)\n\n### 思路\n\n快慢指针\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294694","body":"### 题目\n\n【Day 10】160. 相交链表 \n\n[【Day 10】160. 相交链表 ](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n### 思路\n\n1. 判断是否相交\n\n如果两个链表相交，则最后一个结点一定 是共有的，可以分别遍历2个链表，记录其最后一个 结点和链表长度。\n\n若2个链表最后一个结点相等，则 相交，否则不相交。\n\n2. 找相交结点\n\n用指针pA指向较长的那个链表，pB指向 较短的那个链表，pA先向后移动|L1-L2|步，然后pA 和pB同时向后移动，每移动一步比较pA和pB是否相 等，当二者相等时，其指向的结点即为交点。\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        while not headA or not headB:\n            return None\n        pA = headA\n        countA = 1\n        pB = headB\n        countB = 1\n        while pA.next:\n            pA = pA.next\n            countA += 1\n        while pB.next:\n            pB = pB.next\n            countB += 1\n        if pB != pA:\n            return None\n        if countA >= countB:\n            pA = headA \n            pB = headB\n        else:\n            pA = headB\n            pB = headA\n        for i in range(abs(countB - countA)):\n            pA = pA.next\n        while pA != pB:\n            pA = pA.next\n            pB = pB.next\n        return pA\n```\n\n\n\n### 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095177939","body":"### 题目\n\n **【Day 11】142. 环形链表 II** \n\n[ **【Day 11】142. 环形链表 II** ]( [61. 旋转链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rotate-list/submissions/) )\n\n### 思路\n\n快慢指针\n\n1. 判断是否是环\n2. 找到入环的第一个节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n\n\n### 复杂度\n\n时间复杂度：O（N）\n\n空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tensorstart":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085612304","body":"### 思路\n类似于第二题，按位倒叙相加，注意进位\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    res=[];\n    l=num.length;\n    for (let i = l-1; i >=0 ; i--) {\n        let pos_num=0;\n        pos_num=num[i]+k%10;\n        k=Math.floor(k/10);\n        if (pos_num>=10){\n            pos_num-=10;\n            k+=1;\n        }\n        res.push(pos_num);\n    }\n    while (k){\n        res.push(k%10);\n        k=Math.floor(k/10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n**复杂度分析**\n- 时间复杂度：$O(k,n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664861","body":"### 思路\n用的双指针循环部分有待优化\n### 代码\n\n\n```javascript\n\nvar shortestToChar = function(s, c) {\n    const res=[];\n    let l=0,r=0,pos=0;\n    let length=s.length;\n    for (let i = 0; i < length; i++) {\n        let array_abs=0;\n        l=r=pos=i;\n        for (let j = r; j < length; j++) {\n            if (s[j]===c) {\n                r=j;\n                break;\n            }\n        }\n        for (let j = l; j >=0 ; j--) {\n            if (s[j]===c){\n                l=j;\n                break;\n            }\n        }\n        if (s[l]===c && s[r]===c)\n            array_abs=Math.min(Math.abs(l-pos),Math.abs(r-pos));\n        else if (s[l]===c && s[r]!==c)\n            array_abs=Math.min(Math.abs(l-pos));\n        else\n            array_abs=Math.min(Math.abs(r-pos));\n        res.push(array_abs);\n    }\n    return res;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N^2)$\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086892427","body":"### 思路\njs刚开始学，还是用的不好，java的思路写的\n### 代码\n\n\n```javascript\n/**\n * @param {number} maxSize\n */\nlet stack;//创建栈\nlet pos;//创建指针\nvar CustomStack = function(maxSize) {\n    stack=new Array(maxSize);\n    pos=-1;\n};\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (pos!==stack.length-1){\n        pos++;\n        stack[pos]=x;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (pos !== -1) {\n        let pos_value = stack[pos];\n        stack[pos] = undefined;\n        pos--;\n        return pos_value;\n    } else return -1;\n}\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if (k>pos+1){\n        for (let i = 0; i <=pos; i++) {\n            stack[i]+=val;\n        }\n    }else {\n        for (let i = 0; i < k; i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087454057","body":"### 思路\n使用栈往里存数，使用正则判断数字和字母是不是连续，遇到]弹出来做拼接，最后将栈里面的数据倒出来拼接\n\n### 代码\n\n\n```java（此处换成你的语言，比如js，py 等）\nclass Solution {\n    public static String decodeString(String s) {\n    String res = \"\";\n    Stack<String> stack = new Stack<>();\n    for (int i = 0; i < s.length(); i++) {\n    String middle = s.substring(i, i + 1);\n    if (middle.matches(\"[0-9]\")) {\n    String num = middle;\n    while (i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[0-9]\")) {//判断是不是个连续的数\n    num += s.substring(i + 1, i + 2);\n    i++;\n}\nstack.add(num);\n\n} else if (middle.matches(\"[a-z]\") || middle.equals(\"[\") || middle.matches(\"[A-Z]\")) {//使用正则表达式\n    if (middle.equals(\"[\"))\n        stack.add(middle);\n    else {\n        String ele = middle;\n        while (i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[a-z]\") ||\n        i + 1 < s.length() && s.substring(i + 1, i + 2).matches(\"[A-Z]\")) {//判断是不是个连续的数\n            ele += s.substring(i + 1, i + 2);\n            i++;\n        }\n        stack.add(ele);\n    }\n\n} else if (middle.equals(\"]\")) {\n    String temp = \"\";//中间变量\n    while (!stack.peek().equals(\"[\"))\n        temp = stack.pop()+temp;\n    stack.pop();\n    int count = Integer.parseInt(stack.pop());\n    String mid = temp;\n    for (int j = 0; j < count - 1; j++) {\n        temp += mid;\n    }\n    stack.add(temp);\n\n}\n}\nwhile (!stack.empty()) { //最后把栈里的东西倒出来\n    String middle2 = \"\";\n    middle2 = stack.pop() + middle2;\n    res = middle2 + res;\n}\n\nreturn res;\n}\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：$O(N)$\n- 空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088741684","body":"## 思路\n使用两个栈，一个存，一个取\n## 代码\n```javascript\nvar MyQueue = function() {\n    this.in_stack=[];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.in_stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.out_stack=[];\n    while (this.in_stack.length>0){\n        this.out_stack.push(this.in_stack.pop());\n    }\n    for (let i = this.out_stack.length-2; i >-1; i--) {\n        this.in_stack.push(this.out_stack[i]);\n    }\n    return this.out_stack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.in_stack[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.in_stack.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n复杂度分析\n时间$O(n)$\n空间$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090368342","body":"\n## 思路 暴力解法\n没想出啥好方法来，只会暴力硬解\n根据排序块定义，排序块的左边部分的最大值要小于右边部分的最小值。\n## 代码\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\n//暴力\nvar maxChunksToSorted = function(arr) {\n    let length=arr.length;\n    let res=0;\n    let max_l=arr[0];\n    for (let i = 0; i < length; i++) {\n        max_l=Math.max(max_l,arr[i]);\n        let min_r=Infinity;\n        for (let j = i+1; j < length; j++) {\n            min_r=Math.min(arr[j],min_r);\n        }\n        if (max_l<=min_r){\n            res++;\n        }\n    }\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度$O(n^2)$\n空间复杂度$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091669179","body":"先打个卡\n## 思路\n暴力硬解，每次找到链表最后一个值，将这个值移到队首，k-1，判断k>0\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n    if (!head||!head.next) return head;\n    while (k) {\n        let temp=head.next;\n        let pre=head;\n        while (temp.next){\n            temp=temp.next;\n            pre=pre.next\n        }\n        temp.next=head;\n        pre.next=null;\n        head=temp;\n        k--;\n    }\n    return head;\n};\n```\n## 复杂度分析\n时间复杂度$O(n^2)$\n空间复杂度$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093016452","body":"## 思路\n分奇偶讨论，前后交换\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if (!head||!head.next) return head;\n    let length=1;\n    let temp=head;\n    while (temp.next){\n        length++;\n        temp=temp.next;\n    }\n    let rear=head;\n    let pre=head.next;\n    let times=Math.floor(length/2);\n    head=pre;\n    //长度为偶数\n    if (length%2===0){\n        while (times){\n            temp=pre.next\n            if (!pre.next){\n                pre.next=rear;\n                rear.next=null;\n                return head;\n            }else {\n                pre.next=rear;\n                rear.next=temp.next;\n            }\n            rear=temp;\n            pre=temp.next;\n            times--;\n        }\n    }else {\n        while (times){\n            temp=pre.next\n            if (!temp.next){\n                pre.next=rear;\n                rear.next=temp;\n                return head;\n            }else {\n                pre.next=rear;\n                rear.next=temp.next;\n            }\n            rear=temp;\n            pre=temp.next;\n            times--;\n        }\n    }\n};\n```\n## 复杂度分析\n时间复杂度$O(n)$\n空间复杂度$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094073606","body":"## 思路\n参考第108，先把链表的值拷贝到数组中，再对数组进行递归。\n##代码\n```javascript\nvar sortedListToBST = function(head) {\n    let arr=[];\n    let temp=head;\n    while (temp){\n        arr.push(temp.val);\n        temp=temp.next;\n    }\n    return dfs(0,arr.length-1,arr);\n};\nfunction dfs(l,r,arr){\n    //let mid=Math.floor(l+(r-l)/2);\n    let mid=parseInt(r+(l-r)/2);\n    if (l>r) return null;\n    let root=new TreeNode(arr[mid]);\n    root.left=dfs(l,mid-1,arr);\n    root.right=dfs(mid+1,r,arr);\n    return root;\n}\n```\n## 复杂度\n空间复杂度O{n}\n时间复杂度O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094279379","body":"## 思路\n将链表a或者链表b的值放到集合中，遍历另一个链表，检验集合中有没有这个结点\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let tempA=headA;\n    let set=new Set();\n    while (tempA){\n        set.add(tempA);\n        tempA=tempA.next;\n    }\n    let tempB=headB;\n    while (headB){\n        if (set.has(headB))\n            return headB;\n        headB=headB.next;\n    }\n    return null;\n};\n```\n# 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095096984","body":"## 思路\n哈希，遍历一遍链表，并将结果存入集合，如果集合中再次出现存入的集合，返回这个结点，否则返回空\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    if (!head||!head.next) return null;\n    let temp=head;\n    let set =new Set();\n    while (temp){\n        if (set.has(temp)){\n            return temp;\n        }\n        set.add(temp);\n        temp=temp.next;\n    }\n    return null;\n};\n```\n## 复杂度分析\n时间复杂度$O(n)$\n空间复杂度$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085682784","body":"## 思路\n按位求和，用flag保存进位，加到下一轮\n## 代码\n```js\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  let order = num.length - 1;\n  // 进位\n  let flag = 0;\n  while (order >= 0 || k != 0) {\n    let x = order >= 0 ? num[order] : 0;\n    let y = k != 0 ? k % 10 : 0;\n    let sum = x + y + flag;\n    // 保存余数\n    res.push(sum % 10);\n    flag = Math.floor(sum / 10);\n    k = Math.floor(k / 10);\n    order--;\n  }\n  if (flag) res.push(flag);\n  return res.reverse();\n};\n```\n## 复杂度\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665965","body":"## 思路\r\n中心扩展\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    const res=Array(s.length).fill(0);\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i]===c) continue\r\n        let l=i,r=i,shortest=Infinity;\r\n        while (l>=0){\r\n            if(s[l]===c){\r\n                shortest=Math.min(shortest,i-l)\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest=Math.min(shortest,r-i);\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res\r\n};\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086823118","body":"## 思路\r\n\r\n直接按着题意即可。\r\n\r\n## 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.stack = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length === this.maxSize) {\r\n    return null;\r\n  }\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  var x = this.stack.pop();\r\n  return x === undefined ? -1 : x;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.stack.length; i++) {\r\n    this.stack[i] = this.stack[i] + val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087098004","body":"## 思路 \n维护一个栈，遍历判断\n## 代码\n```js\n// 维护一个栈\nvar decodeString = function (s) {\n  const stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] != \"]\") {\n      stack.push(s[i]);\n      continue;\n    }\n    let str = \"\";\n    let cur = stack.pop();\n    while (cur != \"[\") {\n      // 加在当前的后面\n      str = cur + str;\n      cur = stack.pop();\n    }\n    let num = \"\";\n    // 排除 \"[\"\n    cur = stack.pop();\n    // 对于数字\n    while (!isNaN(cur)) {\n      // 字符串相加\n      num = cur + num;\n      cur = stack.pop();\n    }\n    // 字母 或者 \"[\"\n    stack.push(cur);\n    stack.push(str.repeat(num));\n  }\n  return stack.join(\"\");\n};\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087800339","body":"## 思路\nrust 双栈实现队列\n## 代码\n```rust\nstruct MyQueue {\n    input: Vec<i32>,\n    output: Vec<i32>,\n}\n\n\nimpl MyQueue {\n\n    fn new() -> Self {\n        Self {\n            input: vec![],\n            output: vec![],\n        }\n    }\n    \n    fn push(&mut self, x: i32) {\n        self.input.push(x);\n    }\n    \n    fn pop(&mut self) -> i32 {\n        self.peek();\n        self.output.pop().unwrap()\n    }\n    \n    fn peek(&mut self) -> i32 {\n        if self.output.is_empty() {\n            while self.input.len() > 0 {\n                self.output.push(self.input.pop().unwrap());\n            }\n\n        }\n        self.output.last().cloned().unwrap()\n    }\n    \n    fn empty(&mut self) -> bool {\n        self.input.is_empty() && self.output.is_empty()\n    }\n}\n```\n## 复杂度\npush ：\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n\npop ：\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n\npeek：\n- 时间复杂度：最好的情况O(1) 最坏的情况O(n)\n- 空间复杂度：O(1)\n\nempty：\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089877763","body":"## 思路\n\n前缀和\n\n## 代码\n```rust\nimpl Solution {\n    pub fn max_chunks_to_sorted(arr: Vec<i32>) -> i32 {\n        let mut sum1 = 0;\n        let mut sum2 = 0;\n        let mut ans = 0;\n        let mut arr_sorted = arr.to_vec();\n        arr_sorted.sort();\n        for i in 0..arr.len(){\n            sum1 = sum1 + arr[i];\n            sum2 = sum2 + arr_sorted[i];\n            if sum1 == sum2 {\n                ans +=1;\n                sum1 = 0;\n                sum2 = 0;\n            }\n        }\n        ans\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091049318","body":"## 思路\nrust 实现，每个节点向右移动 k%n个位置\n## 代码\n\n```rust\nimpl Solution {\n    pub fn rotate_right(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        let mut v: Vec<i32> = Vec::new();\n        let mut node = &head;\n        // 获取总长度\n        while let Some(n) = node {\n            v.push(n.val);\n            node = &n.next;\n        }\n        // 缓存新链表\n        let mut answer = None;\n        // 构建链表\n        for i in (0..v.len()).rev() {\n            let j = k as usize % v.len();\n            answer = Some(Box::new(ListNode {\n                val: v[(v.len() + i - j) % v.len()],\n                next: answer,\n            }))\n        }\n        answer\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092422509","body":"## 思路\n\nrust写链表题很不方便，同一时刻，只能拥有一个可变引用，所以下面的代码没办法编译通过：\n```rust\nlet mut prev = head;\nlet mut current = prev.next.unwrap();\n```\n所以需要利用take() 取出Option<T>后在原来位置放入None来“打断”链表，这样就能获得两个拥有所有权的变量，一个是前面部分，一个是后面部分\n\n## 代码\n\n```rust\nimpl Solution {\n  pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n    let mut list = ListNode::new(0);\n    let mut tail = &mut list.next;\n    let mut temp = None;\n    while let Some(mut node) = head.take() {\n        head = node.next.take();\n        \n        match temp.take() {\n            None => temp = Some(node),\n            Some(temp) => {\n                node.next = Some(temp);\n                *tail = Some(node);\n                tail = &mut tail.as_mut().unwrap().next.as_mut().unwrap().next;\n            }\n        }\n    }\n    *tail = temp;\n    list.next.take()\n  }\n}\n```\n\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093697673","body":"## 思路\n\nrust版本，递归数组，取中间节点，构建bst\n\n## 代码\n\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn sorted_list_to_bst(mut head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut stack = Vec::new();\n        // 收集链表节点值\n        while let Some(node) = head {\n            stack.push(node.val);\n            head = node.next;\n        }\n        Solution::s(&stack[..])\n    }\n    pub fn s(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut n = nums.len();\n        if n == 0 {\n            return None;\n        }\n        let mid = n / 2;\n        let mut node = TreeNode::new(nums[mid]);\n        // 递归创建左子树\n        node.left = Solution::s(&nums[..mid]);\n        // 递归创建右子树\n        node.right = Solution::s(&nums[mid + 1..]);\n        Some(Rc::new(RefCell::new(node)))\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094252581","body":"## 思路\n\n双指针，两个指针的遍历总长度是一样的\n\n## 代码\n```js\nvar getIntersectionNode = function (headA, headB) {\n  let a = headA,\n    b = headB;\n  while (a !== b) {\n    a = a === null ? headB : a.next;\n    b = b === null ? headA : b.next;\n  }\n  return a;\n};\n```\n## 复杂度\n- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次\n- 空间复杂度：0(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094587731","body":"## 思路\n\n快慢指针，slow走1步，fast走2步，假设最终相遇slow走了k步，则fast走了2k步，从head到入环点是k-m，从入环点到相遇点是m，所以fast从相遇点再到入环点走了k-m\n\n## 代码\n```js\nvar detectCycle = function (head) {\n  let slow = head;\n  let fast = head;\n  while (fast) {\n    if (fast.next == null) {\n      // fast.next走出链表了，说明无环\n      return null;\n    }\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow == fast) {\n      fast = head;\n      while (true) {\n        if (slow == fast) {\n          return slow;\n        }\n        slow = slow.next;\n        fast = fast.next;\n      }\n    }\n  }\n  return null;\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m908":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085689040","body":"### 思路\n从后往前遍历数组，按位与K相加\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        for(int i = num.size() - 1; i >= 0; i--)\n        {\n            int curNumber = num[i] + k % 10;\n            k /= 10;\n            if(curNumber >= 10)\n            {\n                curNumber -= 10;\n                k += 1;\n            }\n            result.push_back(curNumber);\n        }\n        \n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597840","body":"### 思路\r\n\r\n先保存目标字符出现的所有位置，逐个与字符串比对距离\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> result(s.size());\r\n        vector<int> targetChars;\r\n\r\n        for(int i = 0; i < s.size(); i++)\r\n        {\r\n            if(s[i] == c)\r\n                targetChars.push_back(i);\r\n        }\r\n\r\n        for(int i=0; i < result.size(); i++)\r\n        {\r\n            int minDistance = INT_MAX;\r\n            for(int j=0; j < targetChars.size(); j++)\r\n            {\r\n                if(minDistance > abs(i - targetChars[j]))\r\n                    minDistance = abs(i - targetChars[j]);\r\n            }\r\n            result[i] = minDistance;\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：O(m * n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086887598","body":"```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        mMaxSize=maxSize;\n    }\n    \n    void push(int x) {\n        if(mNumbers.size()<mMaxSize)\n        {\n            mNumbers.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(!mNumbers.empty())\n        {\n        int result=mNumbers.back();\n        mNumbers.pop_back();\n        return result;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(mNumbers.size()<k)\n        {\n            for(int i=0;i<mNumbers.size();i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i=0;i<k;i++)\n            {\n                mNumbers[i]+=val;\n            }\n        }\n    }\n    \nprivate:\n    vector<int> mNumbers;\n    int mMaxSize;     \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087651573","body":"```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string result;\n        int num;\n        stack<int> numbers;\n        stack<string> strs; \n        for(int i=0;i<s.size();i++)\n        {\n            if(s[i] <= '9' && s[i] >= '0')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                result += s[i];\n            }\n            else if(s[i] == '[')\n            {\n                numbers.push(num);\n                num = 0;\n                strs.push(result);\n                result = \"\";\n            }\n            else\n            {\n                int loop = numbers.top();\n                numbers.pop();\n                for(int j = 0; j<loop; j++)\n                {\n                    strs.top() += result;\n                }\n                result = strs.top();\n                strs.pop();\n            }\n        }\n        return result;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088345808","body":"### 思路\n一个栈保存输入数据，一个栈作为输出，当需要输出时判断输出栈是否为空，不为空直接输出栈顶，为空则从输入栈中获取数据\n### 代码\n``` c++\nclass MyQueue {\npublic:\n    MyQueue() {    \n    }\n    \n    void readFromInput() {\n        int index = mStackInput.size();\n        for(int i = 0; i < index; i++)\n        {\n            mStackOutput.push(mStackInput.top());\n            mStackInput.pop();\n        }\n    }\n\n    void push(int x) {\n        mStackInput.push(x);\n    }\n    \n    int pop() {\n        int result = -1;\n        if(!mStackOutput.empty())\n        {\n            result = mStackOutput.top();\n            mStackOutput.pop();\n        }\n        else if(mStackOutput.empty() && !mStackInput.empty())\n        {\n            readFromInput();\n            result = mStackOutput.top();\n            mStackOutput.pop();\n        }\n        return result;\n    }\n    \n    int peek() {\n        if(!mStackOutput.empty())\n        {\n            return mStackOutput.top();\n        }\n        else if(mStackOutput.empty() && !mStackInput.empty())\n        {\n            readFromInput();\n            return mStackOutput.top();\n        }\n        else\n            return -1;\n    }\n    \n    bool empty() {\n        if(mStackOutput.empty() && mStackInput.empty())\n            return true;\n        else\n            return false;\n    }\n\nprivate:\n    stack<int> mStackInput;\n    stack<int> mStackOutput;\n};\n```\n### 复杂度\n#### 时间复杂度\n- push() :O(1)\n- pop():O(n)\n- peek():O(n)\n- empty():O(1)\n#### 空间复杂度\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090246358","body":"``` c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> addStack;\n        addStack.push(arr[0]);\n        for(int i = 1; i < arr.size(); i++)\n        {\n            if(arr[i] >= addStack.top())\n            {\n                addStack.push(arr[i]);\n            }\n            else\n            {\n              int maxNumber = addStack.top();\n              while(!addStack.empty() && arr[i] < addStack.top())\n              {\n              addStack.pop();\n              }\n              addStack.push(maxNumber);\n            }\n        }\n        return addStack.size();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091429226","body":"``` c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr)\n            return head;\n        \n        if(head->next == nullptr)\n            return head;\n        \n        if(k == 0)\n            return head;\n\n        vector<ListNode *> nodes;\n        while(head != nullptr)\n        {\n            nodes.push_back(head);\n            head = head->next;\n        }\n        if(nodes.size() == k)\n        {\n            return nodes[0];\n        }\n        else\n        {\n            while(nodes.size() <= k)\n                k -= nodes.size();\n\n            if(k == 0)\n                return nodes[0];\n\n            if(nodes.size() > k)\n            {\n                nodes[nodes.size() - 1]->next = nodes[0];\n                head = nodes[nodes.size() - k];\n                nodes[nodes.size() - k - 1]->next = nullptr;\n            }\n        }\n        return head;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092777188","body":"### 思路\n两两交换节点\n### 代码\n``` c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head)\n            return head;\n\n        if(!head->next)\n            return head;\n        \n        int n = 0;\n        ListNode *iter = head;\n        while(iter->next != nullptr){\n            iter = iter->next;\n            n++;\n        }\n\n        ListNode* node = new ListNode();\n        node = head;\n        head = head->next;\n        node->next = head->next;\n        head->next = node;\n        ListNode* result = new ListNode();\n        result = head;\n        head = node->next;\n\n        ListNode* preNode = new ListNode();\n        preNode = node;\n        \n        for(int i = 0; i<n; i++)\n        {\n            if(!head)\n                return result;\n            if(!head->next)\n                return result;\n            ListNode* node = new ListNode();\n            node = head;\n            head = head->next;\n            node->next = head->next;\n            head->next = node;\n            preNode->next = head;\n            preNode = node;\n            if(node->next)\n                head = node->next;\n            else\n                break;\n        }\n        return result;\n    }\n};\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093827888","body":"``` c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n\n        if (head->next == nullptr) \n        {\n            return new TreeNode(head->val);\n        }\n\n        ListNode *p = head, *q = head, *pre = nullptr;\n        while (q != nullptr && q->next != nullptr) \n        {\n            pre = p;\n            p = p->next;\n            q = q->next->next;\n        }\n        pre->next = nullptr;\n       \n        TreeNode *root = new TreeNode(p->val);\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(p->next);\n        return root;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094299755","body":"``` c++\nclass Solution {\npublic:\n\tListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n\n\t\tif (!headA || !headB)\n            return NULL;\n\n\t\tstd::unordered_set<ListNode*> set;\n\t\tListNode* node = headA;\n\t\twhile (node)\n\t\t{\n\t\t\tset.insert(node);\n\t\t\tnode = node->next;\n\t\t}\n\t\tnode = headB;\n\t\twhile (node)\n\t\t{\n\t\t\tif (set.count(node))\n\t\t\t\treturn node;\n\t\t\tnode = node->next;\n\t\t}\n\n\t\treturn NULL;\n\n\t}\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094488758","body":"``` c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head)\n            return head;\n\n        std::unordered_set<ListNode*> set;\n        ListNode* node = head;\n\t\twhile (node)\n\t\t{\n            if(set.count(node))\n                return node;\n\t\t\tset.insert(node);\n\t\t\tnode = node->next;\n\t\t}\n\n        return nullptr;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085691561","body":"思路\n\n    二者从低位相加，满10进位即可\n\n代码\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0; --i) {\n                int sum = num[i] + k % 10;\n                k /= 10;\n                if (sum >= 10) {\n                    k++;\n                    sum -= 10;\n                }\n                res.add(sum);\n            }\n            for (; k > 0; k /= 10) {\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086620620","body":"思路\n\n    左右两次遍历，找出最小值即可\n\n代码\n\n    class Solution {\n        public int[] shortestToChar(String S, char C) {\n            int N = S.length();\n            int[] ans = new int[N];\n            int prev = Integer.MIN_VALUE / 2;\n    \n            for (int i = 0; i < N; ++i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = i - prev;\n            }\n    \n            prev = Integer.MAX_VALUE / 2;\n            for (int i = N-1; i >= 0; --i) {\n                if (S.charAt(i) == C) prev = i;\n                ans[i] = Math.min(ans[i], prev - i);\n            }\n    \n            return ans;\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090066080","body":"思路\n\n    遍历整个数组，将块进行融合，比栈顶小的就移走，其它的进\n\n代码\n\n    class Solution {\n        public int maxChunksToSorted(int[] arr) {\n            LinkedList<Integer> stack = new LinkedList<Integer>();\n            for (int num : arr) {\n                if (!stack.isEmpty() && num < stack.getLast()) {\n                    int cur = stack.removeLast();\n                    while (!stack.isEmpty() && num < stack.getLast()) {\n                        stack.removeLast();\n                    }\n                    stack.addLast(cur);\n                } else {\n                    stack.addLast(num);\n                }\n            }\n            return stack.size();\n        }\n    }\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085696335","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 思路\n\n- 从后向前逐位相加\n\n## 关键点\n\n-  不能直接把num转成数字相加，数字过大时会越界被截取\n-  考虑进位\n-  考虑k的长度大于num\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let add = k\n    for (let i=num.length-1;i>=0;i--) {\n        if(!add) {\n          break;\n        }\n        let sum = num[i] + add%10\n        add = Math.floor(add/10)\n        if (sum >= 10) {\n            add++\n            num[i] = sum%10\n        } else {\n          num[i] = sum\n        }\n    }\n    while(add > 0) {\n        num.unshift(add%10)\n        add = Math.floor(add/10)\n    }\n    return num\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090199811","body":"## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n\r\n## 关键点\r\n\r\n-  块中数字相同，块中数字和相同\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    const sort = [...arr].sort((a,b)=>a-b)\r\n    \r\n    let num = 0\r\n    let sum1 = 0\r\n    let sum2 = 0\r\n    \r\n    for(let i = 0; i < sort.length; i++) {\r\n        sum1 += arr[i]\r\n        sum2 += sort[i]\r\n        if (sum1 === sum2) {\r\n            num++\r\n        }\r\n    }\r\n\r\n    return num\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091836661","body":"## 思路\n把链表改成环形链表，再从length - k % length 处切开\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next || !k) {\n        return head\n    }\n    let length = 1\n    let cur = head\n    \n    while(cur.next) {\n        length++\n        cur = cur.next  // 最后cur指向最后一个node\n    }\n    \n    if(k % length === 0) {\n        return head\n    }\n    cur.next = head // 形成环形链表\n    let index = length - (k % length)\n    \n    while(index) {\n        cur = cur.next\n        index--\n    }\n    let head2 = cur.next\n    cur.next = null\n    return head2\n    \n};\n```\n### 复杂度分析\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085699745","body":"## 思路\r\n从低位相加，`num`结束后继续判断`k`即可。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for digit in num[::-1]:\r\n            if k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = digit + add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n            else:\r\n                digit += carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if k > 0:\r\n            while k > 0:\r\n                add = k % 10\r\n                k = k // 10\r\n                digit = add + carry\r\n                carry = digit // 10\r\n                res.append(digit%10)\r\n        if carry == 1:\r\n            res.append(1)\r\n        return res[::-1]\r\n```\r\n## 复杂度\r\n时间：O(n)，n为数组长度\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086534623","body":"### 思路\r\n\r\n正反两次遍历，分别记录当前字符是`c`的index，初始值使用`inf`。第二次遍历时比较存入最小值。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        idx = -float('inf')\r\n        res = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = min(res[i], idx - i)\r\n        return res \r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`s`长度\r\n\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086850004","body":"## 方法一\r\n\r\n### 思路\r\n\r\n直观做法，定义`self.stack`来作为这个栈。每次增加时index为0～min(k, len(self.stack))的元素增加`val`.\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return\r\n        self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else: \r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        n = min(k, len(self.stack))\r\n        for i in range(n):\r\n            self.stack[i] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：初始，push, pop 为O(1)；increment为O(k)\r\n\r\n空间复杂度：O(maxSize)\r\n\r\n## 方法二\r\n\r\n### 思路\r\n\r\n为了减小方法一中的increment的时间复杂度，设计一个增量数组，只记录增加值的边界，在pop时一并加上作为返回值，之后将增量向栈底进行传递。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        res = self.stack[self.top] + self.add[self.top]\r\n        self.stack[self.top] = 0\r\n        if self.top > 0:\r\n            self.add[self.top-1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1 \r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        tmp = min(k-1, self.top)\r\n        if tmp > -1:\r\n            self.add[tmp] += val\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：全部操作都为O(1)\r\n\r\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087078688","body":"### 思路\r\n\r\n数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        i = 0\r\n        while i < len(s):\r\n            if s[i] != ']':\r\n                stack.append(s[i])\r\n                i += 1\r\n            else:\r\n                tmp = ''\r\n                mul = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp\r\n                if stack:\r\n                    stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul\r\n                tmp *= int(mul)\r\n                stack.append(tmp)\r\n                i += 1\r\n        return ''.join(stack)\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为解码出来后的字符串长度\r\n\r\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089781613","body":"### 思路\r\n\r\n使用单调栈来记录`arr`从后往前的最小值，当再次从头遍历时，维护一个当前最大值变量`maximum`，每次比较栈顶元素与`maximum`，如果栈顶元素大于等于`maximum`，说明后面的最小值已经大于等于了前面的最大值，此时可以切分，`res`增加1。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        res = 0\r\n        stack = []\r\n        minimum = float('inf')\r\n        maximum = -float('inf')\r\n        for num in arr[::-1]:\r\n            minimum = min(minimum, num)\r\n            stack.append(minimum)\r\n        for num in arr:\r\n            if maximum <= stack[-1]:\r\n                res += 1\r\n            maximum = max(maximum, num)\r\n            stack.pop()\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度：O(n)，n为`arr`长度\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091597217","body":"### 思路\r\n\r\n遍历一遍链表得到总长度，将尾节点和头节点连起来成环。利用长度和k算出环形链表断开的位置，找到该位置断开即可。\r\n\r\n### 代码\r\n\r\n```Python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        length = 1\r\n        node = head\r\n        while node.next:\r\n            length += 1\r\n            node = node.next\r\n        cut = length - k % length\r\n        node.next = head\r\n        while cut > 0:\r\n            node = node.next\r\n            cut -= 1\r\n        head = node.next\r\n        node.next = None\r\n        return head\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)，n为链表长度。\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085702964","body":"## 思路\r\n转换为字符串后再进行处理\r\n![image](https://user-images.githubusercontent.com/30134501/161241442-d66bc6e2-aaee-41a4-ba25-072de0f524be.png)\r\n\r\n## 代码（python）\r\n\r\n```python\r\nclass Solution:\r\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n      return list(map(int, list(str(int(''.join(list(map(str, num))))+k))))\r\n```\r\n**复杂度分析**\r\n- 时间复杂度： O(n) , n 为数组长度。\r\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086539562","body":"## 思路\r\n暴力解法，遍历找到index；将`answer`里的值设置很大，循环`range(0, len(s))`+循环`index`，作差求绝对值，跟`answer[i]`比较大小\r\n\r\n## 代码 （python3）\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index = [i for i,si in enumerate(s) if si==c]\r\n        answer = [len(s)]*len(s)\r\n        for i in range(0, len(s)):\r\n            for j in index:\r\n                if abs(i-j)<answer[i]:\r\n                    answer[i] = abs(i-j) \r\n        return answer\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度： O(n^2)， n为`s`长度, 套了两个循环\r\n- 空间复杂度： O(n)，n为`answer`数组长度\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792048","body":"- ## 思路\r\n\t- 正常list操作，push对应append()，pop对应pop()\r\n- ### 代码（python3）\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > 0: \r\n            for i in range(min(k, len(self.stack))):\r\n                self.stack[i] += val\r\n```\r\n- ### 复杂度分析\r\n  - 时间复杂度：O(n), n是`stack`长度\r\n  - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087685866","body":"### 思路\r\n- 遍历`s`，往栈内不断push\r\n  * 如果遇到`]`，就开始一直pop，直到遇到`[`（用一个数组来存pop出来的字母）\r\n  * pop出`[`后，再继续pop，直到遇到非数字 or 栈为空 （用一个数组来存pop出来的数字）\r\n  * 解码这部分字符串，然后放入栈内\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n        stemp = []\r\n        ntemp = []\r\n        for si in s:\r\n            if si != ']':\r\n                stk.append(si)\r\n            else:\r\n                while True:\r\n                    # get letters in []\r\n                    if stk[-1] == '[':\r\n                        # remove [\r\n                        stk.pop()\r\n                        break\r\n                    else:\r\n                        # append letters\r\n                        stemp.append(stk.pop())\r\n                while True:\r\n                    # get numbers before [\r\n                    if stk:\r\n                        if not stk[-1].isnumeric():\r\n                            break\r\n                        else:\r\n                            # append numbers\r\n                            ntemp.append(stk.pop())\r\n                    else:\r\n                        break\r\n                stk.extend(list(reversed(stemp)) * int(''.join(reversed(ntemp))))\r\n                stemp = []\r\n                ntemp = []\r\n        return ''.join(stk)\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n^2), n为`s`长度，外循环遍历一遍`s`push到栈内，内循环又pop出来\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088251957","body":"### 思路\r\n- push: 新数据来了就 push 到 栈1，\r\n- pop: 需要 pop 的时候（如果 栈2 不为空），就把 栈1 反转（等价于pop后再append）存到 栈2，从栈2 pop\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack2 == []:\r\n            self.stack2 = list(reversed(self.stack1))\r\n            self.stack1 = []\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2 == []:\r\n            return self.stack1[0]\r\n        else:\r\n            return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return self.stack2 == [] and self.stack1 == []\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1), python中reversed的时间复杂度好像是O(1)\r\n- 空间复杂度：O(n), n为stack长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089908758","body":"### 思路\r\n- 遍历一遍`arr`，如果左边的最大<=右边的最小，chunk数就加一\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        num = 1\r\n        # from the second index to the last index\r\n        for i in range(1,len(arr)):\r\n            # if max of left < min of right\r\n            if  max(arr[:i]) <= min(arr[i:]):\r\n                num += 1\r\n        return num\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O(n^2), n是`arr`长度，遍历一遍，遍历时取 max/min 要O(n)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091903629","body":"### 思路\r\n- 从head遍历到最后的元素，记录list长度为`n`\r\n- 成环 ：（如果list长度`n`不是`k`的倍数）本来指向`None`的最后元素指向head\r\n- 断开：再遍历一次，找到第`n - k mod n`个元素，它后面的元素作为要输出的list的新head，它自己指向None\r\n\r\n### Code (python)\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head == None or head.next == None or k == 0:\r\n            return head\r\n\r\n        # count the length of list\r\n        n = 1\r\n        cnt = head\r\n        while cnt.next != None:\r\n            cnt = cnt.next\r\n            n += 1\r\n            \r\n        if k % n == 0:\r\n            return head\r\n            \r\n        # last element points to the first one\r\n        cnt.next = head\r\n\r\n        # find the second (k-th) to last one\r\n        for i in range(n - k % n):\r\n            cnt = cnt.next\r\n\r\n        # use its next as new head\r\n        output = cnt.next\r\n        # point to None\r\n        cnt.next = None\r\n\r\n        return output\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n), n为list长度\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092612321","body":"- ## 思路\r\n\t- 要`swapPairs`整个list，先swap前俩nodes：前2个nodes (`one`和`two`) 互换（`two`为head，指向`one`，再指向后面）；\r\n\t- 前俩nodes弄好后，list变短为从第3个node开始，把第3个node作为head输入`swapPairs`，依次递归\r\n\t- ### 代码\r\n\t\t-\r\n\t\t  ``` python\r\n\t\t  \t\t  class Solution:\r\n\t\t  \t\t      def swapPairs(self, head: ListNode) -> ListNode:\r\n\t\t  \t\t          if not head or not head.next:\r\n\t\t  \t\t              return head\r\n\t\t  \t\t  \r\n\t\t  \t\t          one = head\r\n\t\t  \t\t          two = one.next\r\n\t\t  \t\t          one.next = self.swapPairs(two.next)\r\n\t\t  \t\t          two.next = one\r\n\t\t  \t\t          \r\n\t\t  \t\t          return two\r\n\t\t  ```\r\n\t- ### 复杂度分析\r\n\t\t- 时间复杂度：O(n), n为list长度，每次递归n-2，也就是递归了n/2次，每次递归为O(1)\r\n\t\t- 空间复杂度：O(n)，递归深度为n/2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094069910","body":"### 思路\r\n先把链表转化为数组，找到中间位置作为root，再对左右递归\r\n\r\n### Code (python3)\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        arr = []\r\n        while head:\r\n            arr.append(head.val)\r\n            head = head.next\r\n        def buildBST(start, end):\r\n            if start > end: return None\r\n            mid = (start + end) // 2\r\n            root = TreeNode(arr[mid])\r\n            root.left = buildBST(start, mid - 1)\r\n            root.right = buildBST(mid + 1, end)\r\n            return root\r\n        return buildBST(0, len(arr)-1)\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，n为链表长度，遍历链表存为数组；递归的时间复杂度忽略（每次递归分一半，也就是递归了log n次，每次递归为O(1), 总共为O(log n)）\r\n- 空间复杂度：O(n), 多来了个长度为n的数组；递归的空间复杂度忽略，为O(log n), 因为递归深度为 log n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094293095","body":"### 思路\r\n两个指针分别遍历两个链表，并走一遍对方走过的路，如果有交点相遇点为交点，如无交点，相遇点为None\r\n\r\n### Code\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB: return None\r\n        p1 = headA\r\n        p2 = headB\r\n        while p1 != p2:\r\n            if p1: p1 = p1.next\r\n            else: p1 = headB\r\n            if p2: p2 = p2.next\r\n            else: p2 = headA\r\n        return p1\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(m+n), m+n为两个链表长度和\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095133996","body":"### 思路\r\n- 找环：快慢指针，慢指针走一步，快指针走两步，如果快指针遇到None则无环，如果快指针遇到慢指针则有环\r\n- 找成环节点：这个太巧妙了，看了别人的解法才明白。在相遇节点，一个指针继续一步步走，一个指针从头开始走，当再次相遇，相遇节点为成环节点。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        p1 = p2 = head\r\n        # 判断是否有环, 有环break，无环p2就会碰到None\r\n        while True:\r\n            # 如果 p2 or p2.next 是 None\r\n            if not p2 or not p2.next:\r\n                return None\r\n            p1 = p1.next\r\n            p2 = p2.next.next \r\n            if p1 == p2: break\r\n\t\t\r\n        p1 = head\r\n        while p1 != p2:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n\r\n        return p1\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n), n为链表长度\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinhaoti":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085717791","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \"\"\"\n        Idea:\n            case1: len(num) > len(str(k)):\n                add two digital -> get result & carry\n                left move 1 digital of k\n            case2: len(num) < len(str(k)):\n                k += carry\n                while: add k to new array / convert k to array\n        Topic: Array enumerate\n        TC: O(N + max(0, (K-N)^2)\n        SC: O(max(1,K-N))\n        \"\"\"\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            add_result = carry + num[i] + k % 10\n            num[i] = add_result % 10\n            carry = add_result // 10\n            k = k // 10\n        \n        re = []\n        k = k + carry\n        while k:\n            re.insert(0, k % 10)\n            k = k // 10\n        \n        return re + num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086549709","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Brute-force\n        TC: O(n^2)\n        SC: O(n)\n        \"\"\"\n        re = [-1] * len(s)\n\n                \n        for i in range(len(s)):\n            shortest = float('inf')\n            count = 0\n            for j in range(i, -1, -1):\n                if s[j] != c:\n                    count += 1\n                if s[j] == c:\n                    shortest = min(shortest, count)\n            \n            count = 0\n            for k in range(i, len(s)):\n                if s[k] != c:\n                    count += 1\n                if s[k] == c:\n                    shortest = min(shortest, count)\n            re[i] = shortest\n        \n        return re\n    \n    \n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \"\"\"\n        Topic: Array enumerate\n        Idea: enumerate 3times\n            [-1] * n\n            1st: put 0\n            2nd: left->right, 0+1\n            3rd: right->left, 0+1\n        \n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        l = len(s)\n        re = [-1] * l\n        \n        for i in range(l):\n            if s[i] == c:\n                re[i] = 0\n        \n        cur_d = -1\n        for i in range(l):\n            print(re[i], cur_d)\n\n\n            if re[i] == 0:\n                cur_d = 0\n            re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n        # reversed enumerate\n        cur_d = float('inf')\n        for i in range(l-1, -1, -1):\n            if re[i] == 0:\n                cur_d = 0\n                \n            if cur_d < re[i] or re[i] == -1:\n                re[i] = cur_d\n            if cur_d != -1:\n                cur_d += 1\n\n\n        return re\n\n                \n                \n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868202","body":"```python\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Idea: \n        init: []-> stack, n->size\n        push: append\n        pop: pop()\n        increment: for -> increase\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(min(k, len(self.stack)))\n    SC: O(1)\n    \n    Improve: prefix-sum -> make increment O(1)\n    \"\"\"\n    \n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        \n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        return self.stack.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i == len(self.stack):\n                break\n            self.stack[i] += val\n\n            \nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    Improve: prefix-sum -> make increment O(1)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(n)\n    Improve: SC -> O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = [0] * maxSize\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop()\n        re += self.incrementals[n - 1]\n        self.incrementals[n - 1] = 0\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n\nclass CustomStack:\n    \"\"\"\n    Topic: Stack\n    SC -> O(size of stack)\n    Idea: \n        prefix-sum to record\n    TC:\n        push: O(1)\n        pop: O(1)\n        increment: O(1)\n    SC: O(size of stack)\n    \"\"\"\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.incrementals = []\n     \n           \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.max_size:\n            return\n        self.stack.append(x)\n        self.incrementals.append(0)\n    \n    def pop(self) -> int:\n        if len(self.stack) == 0: return -1\n        n = len(self.stack)\n        if n >= 2:\n            self.incrementals[n-2] += self.incrementals[n - 1]\n        re = self.stack.pop() + self.incrementals.pop()\n        return re\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) > 0:\n            self.incrementals[min(k, len(self.stack)) - 1] += val\n        \n        \n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090425887","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        chunks -> count is same -> can sort to get same result\n        TC: O(n^2) ; compare two dict need O(n)\n        SC: O(n)\n        Improve: compare two dict\n        \"\"\"\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            # print(a,b)\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \"\"\"\n        TC: O(nlogn)\n        SC: O(n)\n        \"\"\"\n        count = collections.defaultdict(int)\n        non_zero_cnt = 0\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            if count[a] == -1: non_zero_cnt -= 1 # diff 从 -1 变成 0 ，non_zero_cnt 减一\n            if count[a] == 0: non_zero_cnt += 1 # diff 从 0 变成 1 ，non_zero_cnt 加一\n            count[a] += 1\n            if count[b] == 1: non_zero_cnt -= 1 # diff 从 1 变成 0 ，non_zero_cnt 减一\n            if count[b] == 0: non_zero_cnt += 1 # diff 从 0 变成 -1 ，non_zero_cnt 加一\n            count[b] -= 1\n            if non_zero_cnt == 0: ans += 1 # ，non_zero_cnt 等于 0 表示 diff 全部相等\n\n        return ans\n    \n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094019547","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Keywords: LinkedList, BST, convert\n        Ideas: \n            recurssion\n            get mid value\n            fast & slow pointer -> build treeNode\n        TC: O(logn * n) = O(nlogn)\n        SC: O(logn * 1) = O(logn)\n        \"\"\"\n        def dfs(head, tail):\n            if head == tail: return None\n            slow, fast = head, head\n            while fast!= tail and fast.next != tail:\n                fast = fast.next.next\n                slow = slow.next\n            root = TreeNode(slow.val)\n            root.left = dfs(head, slow)\n            root.right = dfs(slow.next, tail)\n            return root\n        if not head: return head\n        return dfs(head, None)\n        \n        \n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \"\"\"\n        Use list to improve, no need find mid value in linkedlist\n        Improve: O(n)\n        \n        TC: O(n)\n        SC: O(n)\n        \"\"\"\n        res = []\n        while head:\n            res.append(head.val)\n            head = head.next\n        \n        def dfs(res, l, r):\n            if l > r: return None\n            m = (l + r) // 2\n            root = ListNode(res[m])\n            root.left = dfs(res, l, m - 1)\n            root.right = dfs(res, m + 1, r)\n            return root\n            \n        return dfs(res, 0, len(res) - 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094198327","body":"```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \"\"\"\n        Ideas: map\n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        seen = set()\n        while headA:\n            seen.add(headA)\n            headA = headA.next\n            \n        while headB:\n            if headB in seen:\n                return headB\n            headB = headB.next\n        return None\n    \n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        \"\"\"\n        Improve: two pointers fast, slow\n        TC: O(n)\n        SC: O(1)\n        \"\"\"\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n        \n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085768414","body":"## 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086627537","body":"## 思路\n两遍循环，先从左到右遍历s, 找到值左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。取两个值中的最小值。\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let cIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) cIndex = i;\n    res[i] = i - cIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086786982","body":"## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087143843","body":"## 思路\n栈，遇到 ']' 开始出栈，直到遇到 '[' 时停止，此时获取到字符串c，再出栈获取重复数量n，c.repeat(parseInt(n))得到重复之后的数，入栈\n\n## 代码\n```javascript\nvar decodeString = function(s) {\n  let stack = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === ']') {\n      let c = '';\n      let pre = stack.pop();\n      while(pre !== '[') {\n        c = pre + c;\n        pre = stack.pop();\n      }\n      let n = '';\n      let preN = stack.pop();\n      while(!isNaN(preN)) {\n        n = preN + n;\n        preN = stack.pop();\n      }\n      stack.push(preN);\n      stack.push(c.repeat(parseInt(n)));\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088277164","body":"## 思路\n定义两个栈，pop的时候，将stack1的数据全部pop到stack2，返回stack2栈顶的值，再将stack2全部pop回stack1\n\n## 代码\n```javascript\n\nvar MyQueue = function() {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this.stack1.length > 0) {\n    this.stack2.push(this.stack1.pop());\n  }\n  let res = this.stack2.pop();\n  while (this.stack2.length > 0) {\n    this.stack1.push(this.stack2.pop());\n  }\n  return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack1[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack1.length === 0;\n};\n\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090089935","body":"## 思路\n* 单调栈\n* 栈中存储每个块的最大值\n* 前一块的最大值不大于后一块的任意值，如果不是，要合并成同一块\n* 当前值小于栈顶元素时，说明当前元素是属于栈顶元素那一块，此时pop出栈顶元素，记录下当前块的最大值\n* 一直pop直到值小于等于当前值，再将当前块的最大值入栈\n* 最后返回栈的长度\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n  let stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (stack.length > 0 && arr[i] < stack[stack.length - 1]) {\n      let peek = stack.pop();\n      while (stack.length !== 0 && stack[stack.length - 1] > arr[i]) stack.pop();\n      stack.push(peek);\n    } else {\n      stack.push(arr[i]);\n    }\n  }\n  return stack.length;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091709146","body":"## 思路\n先遍历链表，获取链表的长度length，和尾节点tail。将尾节点指向头，形成环。向右旋转K位，意味着头指针要向前走 length - K 步。\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n  if (head === null || head.next === null) return head;\n  let tail = head;\n  let length = 1;\n  while (tail.next) {\n    tail = tail.next;\n    length++;\n  }\n  tail.next = head;\n  let num = length - k % length;\n  while (num > 0) {\n    head = head.next;\n    tail = tail.next;\n    num--;\n  }\n  tail.next = null;\n  return head;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092724134","body":"## 思路\n定义一个pre节点和next节点，位置分别在要交换的两个节点的前后。遍历交换节点。\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n  if (head === null || head.next === null) return head;\n  let res = new ListNode(0);\n  let p1 = head;\n  let p2 = head.next;\n  let pre = res;\n  pre.next = head;\n  while (p1 && p2) {\n    let next = p2.next;\n    p1.next = next;\n    p2.next = p1;\n    pre.next = p2;\n    pre = p1;\n    p1 = next;\n    p2 = p1 === null ? null : p1.next;\n  }\n  return res.next;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094060612","body":"## 思路\n用快慢指针查找链表的中间节点，中间节点就是父节点。\n\n从中间节点分成左右两个链表，再分别查找左右两个链表的中间节点作为左右子节点，以此类推\n\n\n## 代码\n```javascript\nvar sortedListToBST = function(head) {\n  if (head === null) return head;\n  if (head.next === null) return new TreeNode(head.val);\n  return getRoot(head, null);\n};\n\nlet getRoot = function(start, end) {\n  if (start === end) return null;\n  let fast = start, slow = start;\n  while (fast !== end && fast.next !== end) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return new TreeNode(slow.val, getRoot(start, slow), getRoot(slow.next, end));\n}\n```\n\n## 复杂度分析\n\n* time: O(nlogn), 递归二分 logn, 每一层递归的基本操作为n。\n* space: O(logn), 递归，递归栈的开销是递归的深度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094179521","body":"## 思路\na,b两个指针分别指向两个链表的头，相同的速度移动。a到达尾部时重新定位到B链表的头，b到达尾部时重新定位到A链表的头。a,b相遇的点就是起始交点。\n\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n  let pA = headA, pB = headB;\n  while (pA !== pB) {\n    pA = pA.next;\n    pB = pB.next;\n    if (pA === null && pB !== null) pA = headB;\n    if (pB === null && pA !== null) pB = headA;\n  }\n  return pA;\n};\n```\n\n## 复杂度分析\n\n* time: O(n)\n* space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095037648","body":"## 思路\n寻找环的入口，定义快慢指针，快指针每次走两步，慢指针每次走一步。\n\n两个指针第一次相遇时，将快指针指向头部，改成每次走一步。两个指针第二次相遇是就是环的入口。\n\n注意如果第一次相遇是在头部，说明头就是入口，直接返回\n\n## 代码\n```javascript\nvar detectCycle = function(head) {\n  if (head === null || head.next === null) return null;\n  let fast = head, slow = head;\n  let count = 0;\n  while (fast && fast.next) {\n    slow = slow.next;\n    if (count === 0) fast = fast.next.next;\n    else fast = fast.next;\n    if (slow === fast) {\n      if (head === fast) return head;\n      if (count === 0) {\n        fast = head;\n        count++;\n      } else {\n        return fast;\n      }\n    }\n  }\n  return null;\n};\n```\n\n## 复杂度分析\n\n* time:  O(n)\n* space:  O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sallyrubyjade":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085802765","body":"### 思路\n从数组最后一位开始遍历，并取出k的个位数进行相加，再对k进行除10处理来保证每次取出的都是最末位，然后对判断相加数是否大于10，是的话要进一位（记得把这个进位带进下一次数组循环里），把相加数的个位数放在要返回数组的开头。最后判断k或者进位是否处理干净，因为可能k的位数比num数组长度大，进行循环，直到k为0。\n\n### 代码\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let ans = [];\n    let carry = 0;\n    for (let i = num.length - 1; i >= 0; i--) {\n        let temp = num[i] + (k % 10) + carry;\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    while (carry != 0 || k > 0){\n        let temp = carry + (k % 10);\n        k = Math.floor(k / 10);\n        if (temp >= 10) {\n            temp = temp % 10;\n            carry = 1;\n        }else {\n            carry = 0;\n        }\n        ans.unshift(temp);\n    }\n\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086623359","body":"### 思路\n遍历字符串，对每一个字符元素，使用左右指针思想，分别向左和向右寻找最近的字符c，使用Math.min()进行对比，找到最短距离，把值放进数组中，再对下一个字符元素进行相同操作，直到遍历结束。\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let ans = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            ans.push(0);\n            continue;\n        }\n\n        let left = i;\n        let right = i;\n        let shortest = Number.MAX_VALUE;\n\n        while(left >= 0) {\n            if(s[left] === c) {\n                shortest = Math.min(shortest, i - left);\n                break;\n            }\n            left--;\n        }\n\n        while(right <= s.length - 1) {\n            if (s[right] === c) {\n                shortest = Math.min(shortest, right - i);\n                break;\n            }\n            right++;\n        }\n        ans.push(shortest);\n    }\n    return ans;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086792767","body":"### 思路\n用数组模拟栈，push和pop直接用数组的原生方法，但要对数组的长度进行判断，increment方法要比较数组长度大小与k值大小，选择偏小值对这个范围内的数组元素加上增量。\n\n### 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize) this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.list.length > 0) {\n        return this.list.pop();\n    }else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(this.list.length <= k) {\n        for(let i = 0; i < this.list.length; i++) {\n            this.list[i] += val;\n        }\n    }else {\n        for(let i = 0; i < k; i++) {\n            this.list[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度分析\n- 时间复杂度：初始化对象CustomStack O(1)，push操作 O(1)，pop操作 O(1)，increment操作 O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087584892","body":"### 思路\n遇到`]`字符之前所有元素都入栈，碰到`]`之后，一个个出栈判断，构建好内层顺序\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = [];\n    for(let char of s) {\n        if(char !== ']') {\n            stack.push(char);\n            continue;\n        }\n        // 当遇到‘]’后\n        let temp = stack.pop();\n        let str = '';\n        while(temp !== '[') {\n            str = temp + str;\n            temp = stack.pop();\n        }\n        let number = '';\n        temp = stack.pop();\n        while(!isNaN(temp)) {\n            number =  temp + number;\n            temp = stack.pop();\n        }\n        stack.push(temp);\n        stack.push(str.repeat(Number(number)));\n    }\n    return stack.join('');\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088635019","body":"### 思路\n利用两个栈实现队列，javascript中没有栈结构，用数组模拟栈。重点在于peek和pop操作时，两个栈怎么互动：将之前push到一个栈中的元素，依次弹出，放入另一个空的栈中，就可以保证最先加进的元素，在第一个栈的栈底变成另一个栈的栈顶，达到先出的效果。\n\n### 代码\n```javascript\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    this.peek();\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length) {\n        while (this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length-1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    let ans1 = true;\n    let ans2 = true;\n    if (this.stack1.length) {\n        ans1 = false;\n    }\n    if(this.stack2.length) {\n        ans2 = false;\n    }\n\n    return ans1 && ans2;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n### 复杂度分析\n- 时间复杂度：pop操作和peek操作为O(n)，push和empty为O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090183055","body":"### 思路\n将现有数组和排序后数组比较，因为如果满足分块条件，此时的数组和应该一致，比如[3, 7, 5] 与 [3, 5, 7]，可以分成两块[3]、[7, 5]，因为index为0时，数组和相等，index到2时，数组和又一次相等 。遍历数组，逐位检查数组和，相等多少次，就可以分成多少块。\n\n### 代码\n```javascript\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let sortedArr = arr.slice().sort((a, b) => a - b);\n\n    let num = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sortedArr[i];\n\n        if(sum1 === sum2) {\n            num++;\n        }\n    }\n\n    return num;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091692399","body":"### 思路\n第一遍遍历链表得到链表长度和最后一个节点，判断链表长度和k的数量关系，将最后一个节点连接头节点，闭合成环，只需再遍历一次链表，找到需要断开的位置即可。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head || !head.next) {\n        return head;\n    }\n    let cur = head;\n    let len = 1;\n\n    while(cur.next) {\n        len++;\n        cur = cur.next;\n    }\n\n    let num = k % len;\n    if (num === 0) {\n        return head;\n    }\n    \n    cur.next = head;\n    cur = head;\n    for (let i = 0; i < len - num - 1; i++) {\n        cur = cur.next;\n    }\n    let newHead = cur.next;\n    cur.next = null;\n    return newHead;\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093838514","body":"### 思路\n递归建立左右子树\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (head == null) return null;\n    let len = 0;\n    let h = head;  \n    while (head) { \n        len++;\n        head = head.next;\n    }\n\n    const buildBST = (start, end) => {\n        if (start > end) return null;     \n        const mid = (start + end) >>> 1;  \n        const left = buildBST(start, mid - 1); \n\n        const root = new TreeNode(h.val);      \n        h = h.next;                \n        root.left = left;  \n\n        root.right = buildBST(mid + 1, end);\n        return root;\n    };\n\n    return buildBST(0, len - 1);\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094261757","body":"### 思路\n双指针法，cursorA和cursorB同时从A，B出发，分别遍历俩链表，到达链表尾时，再分别从另个一链表头再开始从头遍历，如果两个链表有相交节点，那么两个指针一定会碰到一起，因为时间相同，走的路程长度相同。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) {\n        return null;\n    }\n    let cursorA = headA;\n    let cursorB = headB;\n    let count1 = 0;\n    let count2 = 0;\n\n    while (cursorA != cursorB) {\n        cursorA = cursorA.next;\n        cursorB = cursorB.next;\n        if (!cursorA) {\n            count1++;\n            cursorA = headB;\n            if (count1 > 1) {\n                break;\n            }\n        }\n        if (!cursorB) {\n            count2++;\n            cursorB = headA;\n            if (count2 > 1) {\n                break;\n            }\n        }\n    }\n    if (count1 > 1 || count2 >1) {\n        return null;\n    }else {\n        return cursorA;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094801347","body":"### 思路\n快慢指针，设定快指针一次走的长度是快指针的两倍，如果存在环的话，快指针一定会在环内超过慢指针，假设此时慢指针走的路程为k，那么快指针走的路程为2k，多走的k是环长度的n倍。假设入环点到相遇点的距离为m，那么链表头到入环点的距离为k - m，而根据之前的分析，从相遇点再走k - m步我们也可以确定来到入环点，那么让一个指针从头开始，一个链表从相遇点开始，从头开始的链表走到入环点时，两者一定会相遇。\n\n### 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    let slow = head;\n    let fast = head;\n\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n\n        if (slow == fast) {\n            fast = head;\n\n            while (fast != slow) {\n                fast = fast.next;\n                slow = slow.next;\n            }\n            \n        return fast;\n        }\n    }\n\n    return null;   \n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"meemx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085804058","body":"### 思路\r\n从最低位（num数组最后一位开始），逐位相加\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        length = len(num)\r\n        result = []\r\n\r\n        for i in range(length - 1, -1, -1):\r\n            sum = num[i] + k % 10\r\n            k = k // 10\r\n            if sum >= 10:\r\n                k = k + sum // 10\r\n                sum = sum % 10\r\n            result.append(sum)\r\n\r\n        # 若A长度小于整数K\r\n        while k > 0:\r\n            sum = k % 10\r\n            k = k // 10\r\n            result.append(sum)\r\n\r\n        # 逆序输出\r\n        return result[::-1]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086569073","body":"### 思路\r\n\r\n- 第一遍：从左向右遍历\r\n- 第二遍：从右向左遍历，同时取最小值\r\n\r\n### 代码\r\n\r\n```pthon3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        # 第一遍 从左向右遍历\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n\r\n        # 第二遍 从右向左遍历 同时取最小值\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086883737","body":"### 思路\r\n\r\n使用数组进行模拟，操作即较为简单与高效\r\n\r\n### 代码\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```\r\n\r\n### 时间复杂度\r\n\r\n- 时间复杂度：push是O(1)、pop是O(1)、increment是O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087195117","body":"### 思路\r\n\r\n使用栈\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                strs = ''\r\n                repeat = ''\r\n                while stack[-1] != '[':\r\n                    strs = stack.pop() + strs\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    repeat = stack.pop() + repeat\r\n                stack.append(int(repeat) * strs)\r\n                continue\r\n            stack.append(i)\r\n        return ''.join(stack)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088189776","body":"### 思路\r\n\r\n使用两个栈，如同两个杯子倒水一样进行操作\r\n\r\n### 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        res = self.stack_pop.pop()\r\n        return res\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(1) O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090375779","body":"### 思路\r\n将数组进行排序，随后计算加和，比较原数组和排序后数组的累积和\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        pre1,pre2=0,0\r\n        res=0\r\n        for a,b in zip(arr,sorted(arr)):\r\n            pre1+=a\r\n            pre2+=b\r\n            if pre1==pre2:\r\n                res+=1\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度：取决于排序算法\r\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moonlee001":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085808810","body":"## 思路\n将k转化为数组，利用双指针倒序相加。\n## 代码\nvar addToArrayForm = function(num, k) {\n    const arrK = k.toString().split('');\n    const n = num.length;\n    const m = arrK.length;\n    let p1 = n - 1, p2 = m - 1;\n    let res = [];\n    let carry = 0;\n    while (p1 >= 0 || p2 >= 0) {\n        const num1 = p1 < 0 ? 0 : num[p1];\n        const num2 = p2 < 0 ? 0 : arrK[p2] - 0;\n        const sum = num1 + num2 + carry;\n        const mode = sum % 10;\n        carry = Math.floor(sum / 10);\n        res.unshift(mode);\n        p1--;\n        p2--;\n    }\n    if (carry) {\n        res.unshift(carry);\n    }\n    return res;\n};\n\n## 复杂度\n时间：O(n)\n空间： O(m) m为数字个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597227","body":"### 思路\n两次遍历字符串，取最小值。\n\n### 代码\n\n\n```js\nvar shortestToChar = function(S, C) {\n  let n = S.length;\n  let prev = -Infinity;\n  let ans = [];\n  for (let i = 0; i < n; i++) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = i - prev;\n  }\n  \n  prev = Infinity;\n  for(let i = n - 1; i >= 0; i--) {\n    if (S.charAt(i) == C) {\n      prev = i;\n    }\n    ans[i] = Math.min(prev - i, ans[i]);\n  }\n  \n  return ans;\n\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797204","body":"### 思路\n使用数组模拟栈，inc使用空间换取时间，存储增量，如果需要pop的时候再将增量加到对应的值\n\n### 代码\n\n```javascript\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = stack;\n  this.map = new Map();\n}\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n}\n\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  } \n  const inc = this.map.get(this.stack.length) || 0;\n  this.map.set(this.stack.length - 1, (this.map.get(this.stack.length - 2) || 0) + inc);\n  this.map.set(this.stack.length, 0);\n  return this.stack.pop() + inc;\n}\n\nCustomStack.prototype.increment = function(k, val) {\n  const index = Math.min(k, this.stack.length) - 1;\n  if (index < 0) {\n    return;\n  }\n  this.map.set(index, (this.map.get(index) || 0) + val);\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(1)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087492216","body":"### 思路\r\n使用栈存储S，如果遇到右括号，则栈出，然后将处理好的字符在存入栈。\r\n\r\n### 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    const n = s.length;\r\n    let res = '';\r\n    for (let i = 0; i < n; i++) {\r\n        const cur = s.charAt(i);\r\n        if (cur == ']') {\r\n            let str = '';\r\n            while (stack.length && stack[stack.length - 1] !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            stack.pop();\r\n            let num = '';\r\n            while(stack.length && !isNaN(stack[stack.length - 1])) {\r\n                num = stack.pop() + num;\r\n            }\r\n            console.log(str, num);\r\n            stack.push(str.repeat(num));\r\n        } else {\r\n            stack.push(cur);\r\n        }\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(N)\r\n- 空间复杂地：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088366994","body":"### 思路\n使用两个数组实现\n\n### 代码\n\n```javascript\nvar MyQueue = function() {\n  this.in = [];\n  this.out = [];\n}\nMyQueue.prototype.push = function (x) {\n  this.in.push(x);\n}\nMyQueue,prototypt.peek = function() {\n  if (this.out.length == 0) {\n    const n = this.in.length;\n    for (let i = 0; i < n; i++) {\n      this.out.push(this.in.pop());\n    }\n  }\n  return this.out[this.out.length - 1];\n}\nMyQueue,prototypt.pop = function() {\n  if (this.out.length == 0) {\n    const n = this.in.length;\n    for (let i = 0; i < n; i++) {\n      this.out.push(this.in.pop());\n    }\n  }\n  return this.out.pop();\n}\nMyQueue,prototypt.empty = function() {\n  return this.in.length === 0 && this.out.length === 0;\n}\n```\n\n### 复杂度分析\n- 时间复杂度： push: O(1) peek: O(n) pop: O(n) empty: O(1)\n- 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089915588","body":"### 思路\n使用单调栈存储每个分块的最大值，遍历数组的每个值，如果遇到小于栈顶的值，依次栈出。\n### 代码\n```js\nvar maxChunksToSorted = function(arr) {\n    let stack = [arr[0]];\n    const n = arr.length;\n    for (let i = 1; i < n; i++) {\n        const cur = arr[i];\n        if (cur >= stack[stack.length - 1]) {\n            stack.push(cur);\n        } else {\n            const top = stack.pop();\n            while (cur < stack[stack.length - 1]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n        \n    }\n    return stack.length;\n};\n```\n### 复杂度分析\n- 时间复杂度： O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091016658","body":"### 思路\n\n1. k % n 计算出需要移动的步数\n2. 组成环形链表，在n - k的位置断开即可\n\n### 代码\n```js\nvar rotateRight = function (head, k) {\n  if (head == null) {\n    return head;\n  }\n  let n = 1, cur = head;\n  while (cur.next) {\n    cur = cur.next;\n    n++;\n  }\n  \n  let step = n - k % n;\n  if (step == n) {\n    return head;\n  }\n  \n  cur.next = head;\n  while (step > 0) {\n    cur = cur.next;\n    step--;\n  }\n  const next = cur.next;\n  cur.next = null;\n  return next;\n\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092370495","body":"### 思路\n有可能更改头结点，使用哑结点，使用p1、p2、next分别记录更改的两个指针，及后面未更改的串，进行穿针引线。\n### 代码\n```js\nvar swapPairs = function(head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    const dummy = new ListNode(-1);\n    dummy.next = head;\n    let cur = dummy;\n    \n    while (cur.next && cur.next.next) {\n        let p1 = cur.next;\n        let p2 = cur.next.next;\n        let next = cur.next.next.next;\n\n        cur.next = p2;\n        p2.next = p1;\n        p1.next = next;\n\n        cur = p1;     \n    }\n    \n    return dummy.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093581530","body":"### 思路\n1.利用双指针找到链表的中间节点作为root\n2.利用中间节点断开链表\n3.分别在左右两部分链表进行从步骤1开始递归操作\n\n### 代码\n```js\nvar sortedListToBST = function(head) {\n    if (head == null) {\n        return null;\n    }\n\n    let pre = null;\n    let slow = fast = head;\n\n    while (fast != null && fast.next != null) {\n        pre = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n\n    if (pre != null) {\n        pre.next = null;\n    } else {\n        head = null;\n    }\n    const next = slow.next;\n    slow.next = null;\n    const root = new TreeNode(slow.val);\n    root.left = sortedListToBST(head);\n    root.right = sortedListToBST(next);\n    return root;\n};\n```\n\n### 复杂度分析\n- 时间复杂度： O(nlogn)\n- 空间复杂度： O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094148240","body":"### 思路\n使用双指针，遍历两个分支，当两个指针指向同一个节点时，即使交叉节点，如果没有交叉节点，两个指针则同时指向空\n\n### 代码\n```js\nvar getIntersectionNode = function(headA, headB) {\n    if (!headA || !headB) {\n        return null;\n    }\n\n    let p1 = headA, p2 = headB;\n\n    while(p1 != p2) {\n        p1 = p1 == null ? headB : p1.next;\n        p2 = p2 == null ? headA : p2.next;\n    }\n\n    return p1;\n\n};\n```\n### 复杂度分析\n- 时间复杂度 O(m + n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094420298","body":"### 思路\n遍历链表，遍历的过程中将每个节点存储在set里，每次遍历尝试查看set里是否有相同节点，有则返回，直到链表指向空\n\n### 代码\n```js\nvar detectCycle = function(head) {\n    const set = new Set();\n    let cur = head;\n    while (cur) {\n        if (set.has(cur)) {\n            return cur;\n        }\n        set.add(cur);\n        cur = cur.next;\n    }\n    return null;\n};\n```\n\n### 复杂度分析\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085811348","body":"# 思路\r\n先将数组转换成数字 再将结果转换为数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = 0\r\n        digit = 1\r\n        for i in num[::-1]:\r\n            sum += i * digit\r\n            digit *= 10\r\n        sum += k\r\n        res = []\r\n        while sum:\r\n            res.append(sum % 10)\r\n            sum = sum // 10\r\n        return res[::-1]\r\n        \r\n```\r\n# 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086538280","body":"# 思路\r\n先正序遍历 再倒着遍历一遍 \r\n# 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = -float(\"inf\")\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i \r\n            # i - 负无穷 = 正无穷\r\n            res.append(i - idx)\r\n        idx = float(\"inf\")\r\n        for i in range(len(s) - 1, -1 , -1):\r\n            if s[i] == c:\r\n                idx = i \r\n            res[i] = min(idx - i, res[i])\r\n        return res\r\n```\r\n# 时间复杂度\r\n时间：0(n)\r\n空间：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091691548","body":"# 思路\r\n先得到链表的长度和尾部的指针，然后头尾拼接。然后找到需要翻转的节点的上一个节点，head指向他的next节点，然后将其指向None。\r\n# 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head: return None\r\n        count = 1\r\n        tail = head\r\n        while tail.next:\r\n            count += 1\r\n            tail = tail.next\r\n        k %= count\r\n        if k == 0: return head\r\n        tail.next = head\r\n        ptr = head\r\n        # just before the new head\r\n        for i in range(count - k - 1):\r\n            ptr = ptr.next\r\n\r\n        head = ptr.next\r\n        ptr.next = None\r\n        return head\r\n```\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095050236","body":"#思路\r\n快慢指针\r\n#代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if fast == slow:\r\n                break\r\n        if fast == None or fast.next == None :\r\n            return None\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"momomoi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085818993","body":"**思路** \r\n把num列表数据合并为数字和k相加然后再拆分还原\r\n\r\n**时间复杂度** \r\n单循环O(N)\r\n\r\n**代码实现**\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n       cmt_num = ''.join((str(i) for i in num))\r\n       add_sum = int(cmt_num) + k\r\n       split_sum = [int(l) for l in str(add_sum)]\r\n       return split_sum\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651671","body":"# 思路\r\n### 第一次遍历进行位置确认，第二次遍历进行选最小值\r\n\r\n# 复杂度\r\n### 时间复杂度O(N)\r\n### 空间复杂度O(N)\r\n# 代码\r\n```\r\nclass demo:\r\n    def test(self, S:str, C:str) -> List[int]:\r\n         sums = -1\r\n         zero_sums = [0]*len(S)\r\n         for i in range(len(S)):\r\n            if S[i] == C:\r\n                 sums = 0\r\n            else:\r\n                sums += 1\r\n            zero_sums[i] = sums\r\n         sums = -1\r\n         for j in range(len(S)-1, -1, -1):\r\n            if S[j] == C:\r\n                 sums = 0\r\n            else:\r\n                sums +=1\r\n            zero_sums[j] = min(sums, zero_sums[j])\r\n         return sums\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874668","body":"###看了题解和评论，因为在外面没法写就直接复用一下了\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087578922","body":"\n### 代码\n```\ndef decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                repeatStr = \"\"\n                repeatCount = \"\"\n                while stack and stack[-1] != \"[\":\n                    repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n### 复杂度\n#### 时间 O(N)\n#### 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088572928","body":"### 思路：\n刚开始觉得题目很简单，写了下代码，但是随后看了下题解的思路，发现push这块没考虑清楚，复用了下代码\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_1 = []\n        self.stack_2 = []\n\n    def push(self, sum):\n\n        while self.stack_1:\n            self.stack_2.append(self.stack_1.pop())\n        self.stack_2.append(sum)\n        while self.stack_2:\n            self.stack_1.append(self.stack_2.pop())\n\n    def pop(self):\n        return self.stack_1.pop()\n\n    def peek(self):\n        return self.stack_1[-1]\n\n    def empty(self):\n        return False if not bool(self.stack_1) else True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090256536","body":"### 解题思路\n#### 记录每个块中的最大值，最大值的个数就是分块数\n\n### 代码\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091689480","body":"### 思路\r\n#### 先遍历获得链表的长度以及链表尾部的指针，然后头尾拼接起来。 随后我们只要从头遍历k - k % length步就能够找到旋转后链表的头指针，断开尾指针和头指针，返回头指针。\r\n\r\n### 代码\r\n```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head is None:\r\n            return None\r\n        cur = head \r\n        length = 1\r\n        while cur.next:\r\n            cur = cur.next\r\n            length += 1\r\n        cur.next = head\r\n        k = length - k % length\r\n        while k:\r\n            k -= 1\r\n            cur = cur.next\r\n        head = cur.next\r\n        cur.next = None\r\n        return head\r\n```\r\n#### 时间复杂度O（N）\r\n#### 空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092965269","body":"### 递归\n\n### 代码\n```\nclass ListNode(object):\n    def swapPairs(self,head):\n        if not head or not head.next:\n            return head\n        first = head\n        second = head.next\n        third = head.next.next\n        second.next = first\n        first.next = self.swapPairs(third)\n        return second\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094039770","body":"### 解题思路\n #### 递归+快慢指针\n\n### 代码\n```\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left, right):\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n\n        def buildTree(left, right):\n            if left == right:\n                return\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        return buildTree(head, None)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085860307","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639221","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086876043","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087643862","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088800545","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090369863","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091686462","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092660972","body":"### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094042411","body":"### 解题思路\n    分治 \n### 代码实现\njavaScript\n\n```\nvar sortedListToBST = function(head) {\n  if(!head) return null;\n  let length = 0;\n  let current = head;\n  while(current){\n    current = current.next\n    length++\n  }\n\n  var buildBST = function(start, end){\n    if(start > end) return null;\n\n    const mid = start + ((end - start)>> 1)\n    const leftSide = buildBST(start, mid - 1);\n\n    const root = new TreeNode(head.val)\n    head = head.next;\n    root.left = leftSide\n\n    root.right = buildBST(mid+1, end)\n    return root;\n  }\n\n  return buildBST(0, length - 1)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(logN)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094276559","body":"### 解题思路：\n1. 使用pA、pB两个指针分别指向A、B两个链表，两个指针以相同的速率向后移动\n2. 当pA指针移动到了A链接的末尾、令指针pA指向B链表的头部\n3. 当pB指针移动到了A链接的末尾、令指针pB指向A链表的头部\n4. 当pA、pB指针相遇时即为两个指针相遇的起点，否则两个指针不相交\n\n```\nvar getIntersectionNode = function(headA, headB) {\n    let pA = headA;\n    let pB = headB;\n    while (pA != pB) {\n        pA = pA === null ? headB : pA.next;\n        pB = pB === null ? headA : pB.next;\n    }\n    return pA;\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095095463","body":"### 解题思路\n\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // 定义快慢两个指针、只想链表头部\n    let fast = head;\n    let slow = head;\n    // 快指针走两步，满指针走一步\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // 相遇后将快指针指向链表头部\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"quieter2018":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085861308","body":"**思路**\r\n从num的个位开始与k逐个相加，与10相除，余数为当前位的数值，商为下次循环的k，求完后再倒序即可。\r\n\r\n**代码实现**\r\n```C++\r\nclass Solution {\r\n  public:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> out;\r\n        int sum = 0;\r\n        for(int i = num.size()-1; i >= 0 || k > 0; i--) {\r\n            if(i >= 0){\r\n                sum = k + num[i];\r\n                out.push_back(sum % 10);\r\n                k = sum /10;\r\n            }else{\r\n                out.push_back(k % 10);\r\n                k = k /10;\r\n            }\r\n        }\r\n        reverse(out.begin(),out.end());\r\n        return out;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(max(n,k))  n：num的数据长度；k：k的数据长度\r\n空间复杂度：同上","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090372653","body":"**思路**\r\n使用单调栈，分析可知当前值小于之前块的最大值时，则当前值为下一个分块的起点。\r\n\r\n**代码**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> max;\r\n        int top=0;\r\n        int top_tmp =0;\r\n        if(arr.empty()){\r\n            return 0;\r\n        }\r\n        for(int i=0; i<arr.size()-1;i++){\r\n          if(i==0){\r\n              max.push(arr[i]);\r\n          }\r\n\r\n          if(arr[i+1]>=max.top()){\r\n            max.push(arr[i+1]);\r\n          }else{\r\n            top = max.top();\r\n            top_tmp = max.top();\r\n            while(arr[i+1]< top_tmp && (!max.empty() )){\r\n                if(max.size()>1){\r\n                  max.pop();\r\n                  top_tmp = max.top();\r\n                }else{\r\n                    max.pop();\r\n                }\r\n            }\r\n            max.push(top);\r\n          } \r\n        }\r\n        if(max.empty()){\r\n            return 1;\r\n        }\r\n        return max.size();\r\n\r\n    }\r\n};\r\n```\r\n\r\n**复杂度**\r\n时间复杂度：O(n);\r\n空间复杂度：O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhulin1110":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873537","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n首先想到的是将数组转换成数，再和K相加，但会发生内存溢出的情况。\n- **改进** \n从个位数开始考虑，依次与 k 相加，（和 % 10） 存入输出数组 ，（和 / 10）取出进位位（更新后的k包含进位）。最后考虑 k 超出数组长度的部分，依次加到输出数组里即可。\n## 代码(JavaScript)\n```JavaScript\nvar addToArrayForm = function(num, k) {\n    var res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        res.push((num[i] + k) % 10);  //个位数存入数组\n        k = Math.floor((num[i] + k) / 10);  //更新k, 进位位包含在k中\n    }\n    // 对超出数组长度的 k 进行处理\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n## 复杂度\n- 时间复杂度\n> O(n) ，for循环遍历数组长度n，后面的可以忽略不计\n- 空间复杂度\n> O(n) ， 创建一个新的数组res存放结果，后面有循环但是没有分配新的内存空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646686","body":"## 题目\n\n字符的最短距离 https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 思路1（菜鸡的我自己写的，吐了）\n\n找到 s 中所有与 c 相同的字符，并将其索引存放到一个数组中。将数组中的元素索引依次与相同字符的索引做差，并比较得出最小值。值得注意的是，当 s 中与 c 相同的字符只有一个时，无需比较，直接做差即可。\n\n## 代码1（JavaScript）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    if (curr.length == 1) {\n        for (let i = 0; i < s.length; i++) {\n            res[i] = Math.abs(i - curr[0]);\n        }\n        return res;\n    }\n    for (let i = 0; i < s.length; i++) {\n        let j = 0;\n        let data = Math.abs(curr[j] - i);\n        while (curr && (j < curr.length - 1)) {\n            data = Math.min(data, (Math.abs(curr[j + 1] - i)));\n            j++;\n            res[i] = data;\n        }\n    }\n    return res;\n};\n```\n\n \t\t### 代码1改进（看了题解，稍稍改进）\n\n```javascript\nvar shortestToChar = function(s, c) {\n    var curr = [];\n    var res = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            curr.push(i);\n        }\n    }\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == c) {\n            res[i] = 0;\n            continue;\n        }\n        for (const j of curr) {\n            const dist = Math.abs(j - i);\n            if (dist >= res[i]) break; // 小小剪枝，跟上次存的比较，j是不断增大的，目的就是为了找最小值，设置阈值\n            res[i] = dist;\n        }  \n    }\n    return res;\n};\n```\n\n\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n * n) 前面for循环是n，后面for循环嵌套while，while内最大是n，时间复杂度就是n*n，前面的n可以忽略不记\n\n- 空间复杂度\n\n  > O(n) res 和 curr \n\n## 思路2 （看了题解-贪心算法）\n\n两遍循环，先从左到右遍历s，找到左边第一个c的距离。再从右到左遍历，找到值右边第一个c的距离。最后，取两个值中的最小值。\n\n## 代码2 （评论区大佬的）\n\n```javascript\nvar shortestToChar = function(s, c) {\n  let res = [];\n  let lcIndex = -Infinity;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) lcIndex = i;\n    res[i] = i - lcIndex;\n  }\n  let rcIndex = Infinity;\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === c) rcIndex = i;\n    res[i] = Math.min(res[i], rcIndex - i);\n  }\n  return res;\n};\n```\n\n## 复杂度2\n\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086837506","body":"## 题目\n\n设计一个支持增量操作的栈 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 思路1\n\n根据题目要求的直觉栈操作\n\n## 代码1（JavaScript）\n\n```javascript\nvar CustomStack = function(maxSize) {\n    this.max = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n   if (this.stack.length < this.max) {\n        this.stack.push(x); \n   }\n\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.stack.pop();\n    if (res == null) {\n        return -1;\n    } else {\n        return res;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length; i++) {\n        if (i < k) {\n            this.stack[i] += val;\n        }\n    }\n   \n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(1)  未定义新的数组存放结果\n\n## 思路2 （题解学习）\n\n前缀和（没看懂，待补充）。。。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087573823","body":"## 题目\n\n字符串解码 https://leetcode-cn.com/problems/decode-string/\n\n## 思路1\n\n定义两个栈，一个用来存放倍数，一个用来存放字符串。具体操作看程序注释\n\n## 代码1（JavaScript）\n\n```javascript\nvar decodeString = function(s) {\n   // 存倍数的栈\n    let numStack = [];\n    // 存待拼接的str的栈     \n    let strStack = [];\n    // 倍数   \n    let num = 0;\n    // 字符串\n    let result = '';\n    //  逐字符扫描\n    for (let char of s) {\n        // 遇到数字\n        if (!isNaN(char)) {\n            // 算出倍数\n            num = num * 10 + Number(char); \n        } \n        // 遇到 [\n        else if (char === '[') {\n            // 将result已经拼接完成的放到strStack当中\n            strStack.push(result);\n            // 入栈后清零 \n            result = '';\n            // 倍数num进入栈等待\n            numStack.push(num);\n            // 入栈后清零\n            num = 0;\n            \n        } \n        // 遇到 ]，两个栈的栈顶出栈\n        else if (char === ']') {\n            // 获取拷贝次数\n            let repeatTimes = numStack.pop();\n            // 构建子串\n            result = strStack.pop() + result.repeat(repeatTimes); \n        } \n        // 遇到字母，追加给result串\n        else {\n            result += char;\n        }\n    }\n    // 最终返回结果\n    return result;\n};\n```\n\n## 复杂度1\n\n- 时间复杂度\n\n  > O(n ) \n\n- 空间复杂度\n\n  > O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088752873","body":"## 题目\r\n\r\n用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 思路1\r\n\r\n用两个栈实现队列：将一个栈当做输入栈，另一个栈当做输出栈。注意输出栈不为空的情况的处理。\r\n\r\n## 代码1（JavaScript）\r\n\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n    this.res = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length == 0) {\r\n        while (this.stack1.length !== 0) {\r\n            this.stack2.push(this.stack1.pop());\r\n        }\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack2.length == 0) {\r\n        while (this.stack1.length !== 0) {\r\n            this.stack2.push(this.stack1.pop());\r\n        }\r\n    }\r\n    return this.stack2[this.stack2.length - 1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if (this.stack1.length !== 0 || this.stack2.length !== 0) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度1\r\n\r\n- 时间复杂度\r\n\r\n  > O(n) \r\n\r\n- 空间复杂度\r\n\r\n  > O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090366513","body":"## 题目\n768. 最多能完成排序的块 II  https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n## 思路 （参照大佬答案，留下思路，与程序不符）\n- 利用单调递减栈来解题\n- 遍历数组，将元素存入栈中，再利用max记录当前栈顶的最大值\n- 如果遇到比当前栈元素大的值，那么可以直接入栈，因为可以单独分一块；但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素依次出栈，直到遇到小于等于该值的元素停止出栈，然后将max再push入栈（push的这个max就代表了这一个块）\n  - 例如：有该数组 {1, 1, 3, 4, 5, 2, 6, 7}，此时栈为{1, 1, 3, 4, 5}\n  - 接下来遍历到2了，2比max即5小，所以开始出栈，顺序是：5、4、3，由于1小于2，所以停止出栈，接下来将max(5)入栈，此时栈为：{1, 1, 5}\n- 不断遍历，直到数组遍历结束，此时栈中有多少个元素就代表有多少个块了\n- 分块规则：后一块元素的最小值大于等于前一块元素的最大值\n## 代码 (Javascript) 未用栈来做，待修改\n``` javascript\nvar maxChunksToSorted = function(arr) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let res = 0;\n    let arr2 = [...arr].sort((a, b) => a - b);\n    for (let i in arr) {\n        sum1 = sum1 + arr[i];\n        sum2 = sum2 + arr2[i];\n        if (sum1 == sum2) {\n            res += 1;\n            sum1 = 0;\n            sum2 = 0;\n        }\n    }\n    return res;\n};\n```\n没有用栈来做，待修改","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091431781","body":"## 题目 \n     旋转链表 https://leetcode-cn.com/problems/rotate-list/submissions/\n## 思路 1 (自己写的)\n     首先获取链表的长度 length，同时将单向链表转化成循环链表，遍历 length - k % length 找到倒数第k个节点并将其作为head，同时将 length - k % length 的下一个指向 null，断开链表\n## 代码1 (Javascript)\n```Javascript\nvar rotateRight = function(head, k) {\n    let length = 0;\n    let curr1 = head;\n    let curr2 = head;\n    if (head == null) {\n        return head;\n    }\n    while (curr1.next !== null) {\n        curr1 = curr1.next;\n        length++;\n    }\n    length++;\n    curr1.next = head;\n    let temp = length - k % length;\n    while (temp) {\n        curr2 = curr2.next;\n        temp--;\n        curr1 = curr1.next;\n    }\n    curr1.next = null;\n    return curr2;\n};\n```\n## 复杂度分析1\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n## 思路2 (快慢指针)\n     快指针比慢指针多走k步，当快指针到达原链表终点时，慢指针到达旋转后链表的尾节点。将快指针接到头节点形成循环链表，慢指针指向头节点，不要忘记断开循环链表。\n## 代码2 (Javascript)\n```Javascript\nvar rotateRight = function(head, k) {\n   let slow = head;\n   let fast = head;\n   let curr = head;\n   let length = 0;\n   if (!head || !head.next) {\n       return head;\n   }\n   while (curr) {\n       curr = curr.next;\n       length++;\n   }\n   k = k % length;\n   while (fast.next) {\n       if (k-- <= 0) {\n           slow = slow.next;\n       }\n       fast = fast.next; \n   }\n   fast.next = head;\n   let res = slow.next;\n   slow.next = null;\n   return res;\n};\n```\n## 复杂度分析2\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092590450","body":"## 题目\r\n\r\n两两交换链表中的节点 https://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 思路1（迭代法）\r\n\r\n![](https://img-blog.csdnimg.cn/fd8ea430a8c94651a489f0ba29ae8ab9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Lmf5rKh5Zyw5pa55Y67,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\r\n\r\n## 代码1（JavaScript）\r\n\r\n```javascript\r\nvar swapPairs = function(head) {\r\n     if (!head || !head.next) {\r\n        return head;\r\n    }\r\n    let prehead = new ListNode();\r\n    prehead.next = head;\r\n    let temp = prehead;\r\n    while (temp.next !== null && temp.next.next !== null) {\r\n        const node1 = temp.next;\r\n        const node2 = temp.next.next;\r\n        temp.next = node2;\r\n        node1.next = node2.next;\r\n        node2.next = node1;\r\n        temp = node1;\r\n    }\r\n    return prehead.next;\r\n};\r\n```\r\n\r\n## 复杂度1\r\n\r\n- 时间复杂度\r\n\r\n  > O(n) 所有的节点都需要遍历一遍\r\n\r\n- 空间复杂度\r\n\r\n  > O(1) \r\n\r\n## 思路2 （迭代法）\r\n\r\n在分析迭代的过程中就能体会到递归的思路\r\n\r\n## 代码2（JavaScript）\r\n\r\n```Javascript\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) {\r\n        return head;\r\n    }\r\n    let res = new ListNode();\r\n    res = head.next;\r\n    head.next = swapPairs(res.next);\r\n    res.next = head;\r\n    return res;\r\n};\r\n```\r\n\r\n## 复杂度分析2\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093912602","body":"\n## 题目地址(109. 有序链表转换二叉搜索树)\n\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\n\n## 题目描述\n\n```\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。\n\n \n\n示例 1:\n\n输入: head = [-10,-3,0,5,9]\n输出: [0,-3,9,-10,null,5]\n解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n\n\n示例 2:\n\n输入: head = []\n输出: []\n\n\n \n\n提示:\n\nhead 中的节点数在[0, 2 * 104] 范围内\n-105 <= Node.val <= 105\n```\n\n## 前置知识\n\n- 二叉搜索树\n- 递归\n\n## 思路1\n- 观察题目发现，升序排列的链表相当于二叉树的中序遍历，其中根节点正好处于中间节点处，由此想到快慢指针可以用于找中间节点，快指针一次前进两节点，慢指针一次前进一个节点，当快指针到达尾节点处时，慢指针恰好处于中间节点。**以上思路确定根节点**\n- 由于二叉搜索树的左子树节点都小于根节点，右子树节点都大于根节点。链表恰好是升序排列，中间节点的左侧均小于中间节点，中间节点的右侧均大于中间节点，创建左右子树即可。\n\n## 代码1\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if (!head) return null;\n    return dfs(head,null);\n};\nfunction dfs(head, tail) {\n    if (head == tail) {\n        return null;\n    }\n    let fast = head;\n    let slow = head;\n    while (fast != tail && fast.next != tail) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    let root = new TreeNode(slow.val);\n    root.left = dfs(head, slow);\n    root.right = dfs(slow.next, tail);\n    return root;\n}\n\n```\n\n\n**复杂度分析1**(不太会。。。)\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(nlog(n))$ 递归树的深度为 lognlogn，每一层的基本操作数为 nn，因此总的时间复杂度为O(nlogn)\n- 空间复杂度：$O(log(n))$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094218461","body":"## 题目地址(160. 相交链表)\n\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- 哈希表\n- 双指针\n\n## 思路1 哈希表\n将链表A中的节点存到set中，判断链表B中有没有相同节点即可。\n\n## 代码1\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let data = new Set();\n    while (headA !== null) {\n        data.add(headA);\n        headA = headA.next;\n    }\n    while (headB !== null) {\n        if (data.has(headB)) {\n            return headB;\n        }\n        headB = headB.next;\n    }\n    return null;\n};\n\n```\n\n\n**复杂度分析1**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n## 思路2 双指针\nA链表的长度为a，B链表的长度为b，重合部分长度为c。根据 a - c + b == b - c + a。指向A、B链表头的指针每次前移一位，遇到相同的节点则结束循环。其中，如果A链表的指针走到null，则使其为headB，如果B链表的指针走到null，则使其为headA。\n\n## 代码2\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) { \n    let a = headA;\n    let b = headB;\n    while (a !== b) {\n        if (a !== null) {\n            a = a.next;\n        } else {\n            a = headB;\n        }\n        if (b !== null) {\n            b = b.next;\n        } else {\n            b = headA;\n        }\n    }\n    // while (a != b) {\n    //     a = a === null ? headB : a.next;\n    //     b = b === null ? headA : b.next;\n    // }\n    return a;\n};\n\n```\n\n\n**复杂度分析2**\n\n- 时间复杂度：$O(n)$   A、B链表各遍历一次\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094502484","body":"## 题目地址(142. 环形链表 II)\n\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n## 题目描述\n\n```\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n不允许修改 链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。\n\n\n \n\n提示：\n\n链表中节点的数目范围在范围 [0, 104] 内\n-105 <= Node.val <= 105\npos 的值为 -1 或者链表中的一个有效索引\n\n \n\n进阶：你是否可以使用 O(1) 空间解决此题？\n```\n\n## 前置知识\n\n- 快慢指针\n\n## 思路\n![在这里插入图片描述](https://img-blog.csdnimg.cn/e5dd0404b3844c0b89943e085978415e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Lmf5rKh5Zyw5pa55Y67,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if (head == null ||head.next == null) {\n        return null;\n    }\n    let slow = head;\n    let fast = head;\n    do {\n        if (fast != null && fast.next != null) {\n            fast = fast.next.next;\n        } else {\n            fast = null;\n        }\n        slow = slow.next;  \n    } while (slow != fast);\n    if (fast == null) {\n        return null;\n    }\n    fast = head;\n    while (slow != fast) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    return fast;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为链表长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizimu0709":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085873737","body":"- 思路\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\nAB两数都加完后判断进位 , 进位不为 0 加在前面。\r\n\r\n- 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] res, int K) {\r\n        List<Integer> Arr = new ArrayList<>();\r\n        int n = res.length;\r\n        int i = n-1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while(i >= 0 || K != 0){\r\n            int x = i >= 0 ? res[i] : 0;\r\n            int y = K >= 0 ? K%10 : 0;\r\n            sum = x + y +carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n             --i;\r\n             Arr.add(0,sum%10);\r\n        }\r\n        if(carry != 0)\r\n            Arr.add(0,carry);\r\n        return Arr;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091746423","body":"- 分析\r\n与链表长度成整数倍的旋转前后链表不变\r\n使用快慢指针找到倒数第 k 个节点，然后完成基本的链接与断开与断开操作\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || k == 0) return head;\r\n        // 计算有效的 k 值：对于与链表长度成整数倍的「旋转」都是没有意义的（旋转前后链表不变）\r\n        int tot = 0;\r\n        ListNode tmp = head;\r\n        while (tmp != null && ++tot > 0) tmp = tmp.next;\r\n        k %= tot;\r\n        if (k == 0) return head;\r\n\r\n        // 使用「快慢指针」找到倒数第 k 个节点（新头结点）：slow 会停在「新头结点」的「前一位」，也就是「新尾结点」\r\n        ListNode slow = head, fast = head;\r\n        while (k-- > 0) fast = fast.next;\r\n        while (fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        // 保存新头结点，并将新尾结点的 next 指针置空\r\n        ListNode nHead = slow.next;\r\n        slow.next = null;\r\n        // 将新链表的前半部分（原链表的后半部分）与原链表的头结点链接上\r\n        fast.next = head;\r\n        return nHead;\r\n    }\r\n}\r\n```\r\n复杂度\r\n\r\n- 时间复杂度：O(n)\r\n\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085898822","body":"## Idea\r\nIterate through the number array backwards. Add each element to k, remove the last digit from k and add it to the list.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086368202","body":"## Idea\r\nIterate through the string for 3 times. Locate all occurrences of c in the first iteration. Update distance based on distance on the left side in the second iteration and update distance based on distance on the right side in the third iteration.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int[] ans = new int[str.length];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        for (int i = 0; i < str.length; i++) {\r\n            if (str[i] == c) {\r\n                ans[i] = 0;\r\n            }\r\n        }\r\n        \r\n        for (int i = 0; i < str.length - 1; i++) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i+1] = Math.min(ans[i] + 1, ans[i+1]);\r\n            }\r\n        }\r\n        \r\n        for (int i = str.length-1; i > 0; i--) {\r\n            if (ans[i] != Integer.MAX_VALUE) {\r\n                ans[i-1] = Math.min(ans[i] + 1, ans[i-1]);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866023","body":"## Idea\r\nStore the element in an array and use an int variable to represent the actual size.\r\n\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int cur = 0;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur < arr.length) {\r\n            arr[cur++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) {\r\n            return -1;\r\n        }\r\n        return arr[--cur];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, cur); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: push: O(1); pop: O(1); increment: O(min(k, cur))\r\nSpace: O(maxSize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087575778","body":"## Idea\r\nUse a queue and delegate the nested encoded string to recursion\r\nUse a int variable to store k and delegate decoding to recursion when there is a '[', and a ']' indicates that the job is done and should continue.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] str = s.toCharArray();\r\n        Queue<Character> q = new LinkedList<>();\r\n        for (char c : str) {\r\n            q.add(c);\r\n        }\r\n        return process(q);\r\n    }\r\n    \r\n    public String process(Queue<Character> q) {\r\n        int num = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!q.isEmpty()) {\r\n            char c = q.poll();\r\n            if (Character.isDigit(c)) {\r\n                num *= 10;\r\n                num += c - '0';\r\n            }\r\n            else if (c == '[') {\r\n                String s = process(q);\r\n                for (int i = 0; i < num; i++) {\r\n                    sb.append(s);\r\n                }\r\n                num = 0;\r\n            }\r\n            else if (c == ']') {\r\n                break;\r\n            }\r\n            else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088690453","body":"## Idea\r\nuse stack s1 for push and stack s2 for pop and peek\r\nWhenever pop or peek is invoked, we pop all elements from s1 into s2 if s2 is empty.\r\n\r\n## Code\r\n```\r\nclass MyQueue {\r\n    public Stack<Integer> s1;\r\n    public Stack<Integer> s2;\r\n    \r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    private void update() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        update();\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        update();\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Complexity\r\nTime: \r\npush O(1)\r\npop O(n)\r\npeek O(n)\r\nempty O(1)\r\n\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090409687","body":"## Idea\r\nUse increasing monotonic stack. If the next element to push is smaller than the element at the top, find the largest elements that is smaller than the current element. Every elements between this largest element(exclusive) and the current element(inclusive) will be considered in a chunk and we push the largest one among these elements back to the stack.\r\n\r\n## Code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        int num = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (!s.isEmpty()) {\r\n                if (arr[i] >= s.peek()) {\r\n                    s.push(arr[i]);\r\n                }\r\n                else {\r\n                    int max = -1;\r\n                    while (!s.isEmpty() && s.peek() > arr[i]) {\r\n                        max = Math.max(max, s.pop());\r\n                    }\r\n                    s.push(max);\r\n                }\r\n            }\r\n            else {\r\n                s.push(arr[i]);\r\n            }\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094043729","body":"## Idea\nuse the middle point of the linkedlist as the root, the left part to the middle point is the left subtree and the right part to the middle point is the right subtree. Use two pointers to find out the middle point.\n\n## Code\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head, prev = null;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        if (slow != head) {\n            prev.next = null;\n            root.left = sortedListToBST(head);\n        }\n        root.right = sortedListToBST(slow.next);\n        return root;\n    }   \n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094313047","body":"## Idea\r\nUse two pointers to find the cycle, if any.\r\n\r\n## Code\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return null;\r\n        ListNode fast = head, slow = head;\r\n        while (true) {\r\n            // if any pointer reaches null, there is no cycle\r\n            slow = slow.next;\r\n            if (slow == null) return null;\r\n            fast = fast.next;\r\n            if (fast == null) return null;\r\n            fast = fast.next;\r\n            if (fast == null) return null;\r\n            \r\n            // if two pointers meet, there is a cycle\r\n            if (slow == fast) {\r\n                break;\r\n            }\r\n        }\r\n        // slow pointer restarts at head and fast remains its own position, find the cycle\r\n        slow = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiayuhui231":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085901627","body":"## 题目\n数组形式的整数加法\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n   - 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\n   - 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\n## C++代码\n``` class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int t = k, idx=0;\n        vector<int> ans;\n        while(t)\n        {\n            if(idx<num.size()) t+=num[idx++];\n            ans.push_back(t%10);\n            t /= 10;\n        }\n        while(idx<num.size()) ans.push_back(num[idx++]);\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```\n## 复杂度\n     时间：O(n）\n     空间：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086558705","body":"## 题目\n字符的最短距离\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n## 思路\n- 前后各遍历一次，找最短距离\n## 代码\n``` class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n            vector<int> pos(s.size(),-1);\n        int pre = -1;\n        for(int i = s.size() -1;i >= 0;i--)\n            if(s[i] == c){\n                pre = i;\n                pos[i] = 0;\n            }else if(pre != -1) pos[i] = pre - i;\n        pre = -1;\n        for(int i = 0;i < s.size();i++){\n            if(s[i] == c){\n                pre = i;\n        }else if(pos[i] == -1 && pre != -1){\n            pos[i] = i - pre;\n        }else if(pos[i] != -1 && pre != -1){\n            pos[i] = min( i - pre, pos[i]);\n        }\n        }\n        return pos;\n    }\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086872513","body":"# 代码\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top;\n\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if (top != stk.size() - 1) {\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for (int i = 0; i < lim; ++i) {\n            stk[i] += val;\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087671554","body":"## 题目\n字符串解码\nhttps://leetcode-cn.com/problems/decode-string/\n## 思路\n     可以结合分配律，先将括号里的字母结合起来\n\n## 代码\n``` \nclass Solution {\npublic:\n    string decodeString(string s) {\n         int len = s.size();\n        int num = 0;\n        stack<int> numstack;\n        stack<string> strstack;\n        string cur = \"\";\n        string result = \"\";\n        for(int i=0; i<len; ++i)\n        {\n            if(s[i]>='0' && s[i]<='9')\n            {\n                num = 10*num + s[i] - '0';\n            }\n            else if(s[i] == '[')\n            {\n                numstack.push(num);\n                strstack.push(cur);\n                num = 0;\n                cur.clear();\n            }\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\n                cur += s[i];\n            else if(s[i] == ']')\n            {\n                int k = numstack.top();\n                numstack.pop();\n                for(int j=0; j<k; ++j)\n                    strstack.top() += cur;\n                cur = strstack.top();\n                strstack.pop();\n            }\n        }\n        result = result + cur;\n        return result;     \n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088804924","body":"## 代码\n```\nclass MyQueue {\npublic:\n    stack<int> stIn;\n    stack<int> stOut;\n    /** Initialize your data structure here. */\n    MyQueue() {\n\n    }\n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）\n        if (stOut.empty()) {\n            // 从stIn导入数据直到stIn为空\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n    }\n\n    /** Get the front element. */\n    int peek() {\n        int res = this->pop(); // 直接使用已有的pop函数\n        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n        return res;\n    }\n\n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090438471","body":"## 代码\n```\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> premax(n), sumin(n);\n        // 前缀最大\n        for (int i = 0; i < n; i++) {\n            if (i == 0) premax[i] = arr[i];\n            else premax[i] = max(premax[i - 1], arr[i]);\n        }\n        // 后缀最小\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1) sumin[i] = arr[i];\n            else sumin[i] = min(sumin[i + 1], arr[i]);\n        }\n        int ans = 1;\n        // 如果当前位置的前缀最大值小于等于下一个位置的后缀最小，说明当前位置小于等于后面所有位置，可分一块，ans++\n        for (int i = 0; i < n - 1; i++) {\n            if (premax[i] <= sumin[i + 1]) ans++;\n        }\n        return ans;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091892765","body":"## 题目\n旋转链表 \nhttps://leetcode-cn.com/problems/rotate-list/comments/\n## 思路\n     先遍历求得总长度，再找到原表倒数第k+1个节点，该节点next个节点就是新的头结点\n## 代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head == nullptr || head->next == nullptr || k==0) return head;\n        int count = 1;\n        ListNode* tail = head;\n        //ListNode* tmp = head;\n        while(tail->next != nullptr){\n            count++;\n            tail = tail->next;\n        }\n        k %= count;\n\n        if(k == 0) return head;\n        // 不满足上述条件，必将进行旋转，所以先将首尾相连\n        tail->next = head;\n        // 现在只需要找到倒数第k+1个节点\n        for(int i = 0; i< count-k; i++){\n            tail = tail->next;\n        }\n        ListNode* newHead = tail->next;\n        tail->next = nullptr;\n        return newHead;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092651388","body":"## 题目\n两两交换链表中的节点\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/\n\n## 思路\n    利用递归，先将每一级的链表交换，返回交换后的链表，上一级就接着整理好的链表继续递归，每一层只改动两个节点，head、next\n\n## 代码\n```\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr) return head;\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        return next;\n    }\n};\n```\n## 复杂度\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094076416","body":" 代码\r\n\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        TreeNode* root;       \r\n        if(!head)\r\n            return nullptr;\r\n        \r\n        if(!head->next){\r\n            root = new TreeNode(head->val);\r\n            return root;\r\n        }        \r\n        \r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n        ListNode *prev = head;\r\n        \r\n        while(fast != NULL && fast->next != NULL){\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        \r\n        while(prev->next != slow)\r\n            prev = prev->next;      \r\n        root = new TreeNode(slow->val);\r\n        ListNode* headRight = slow->next;\r\n        prev->next = nullptr;\r\n        root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(headRight);\r\n        \r\n        return root;\r\n        \r\n    } \r\n\r\n};\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094167873","body":"## 题目\n相交链表\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n## 思路\n两链表总会走相同的路程，故只需A走完，走B，B走完走A，他们总会相遇的。\n\n##代码\n``` \nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) {\n            return NULL;\n        }\n        ListNode* node1 = headA, * node2 = headB;\n        while(node1 != node2){\n            node1 = node1 ? node1->next : headB;\n            node2 = node2 ? node2->next : headA;\n        }\n        return node1;\n    }\n};\n```\n\n## 复杂度\n时间复杂度：O(m+n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095028658","body":"## 题目\n环形链表\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\n## 思路\n   快慢指针，总会相遇则交点为起始点，反之则无\n## 代码\n```\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head, * fast = head;\n        while(fast && fast->next){\n            slow = slow -> next;\n            fast = fast->next->next;\n            if(slow == fast){\n                ListNode* cur = head;\n                while(cur != slow){\n                    cur = cur->next;\n                    slow = slow->next;\n                }\n                return cur;\n            }\n        }\n        return NULL;\n        \n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085906678","body":"# Plan:\r\n```\r\niterate from end of num, last digit of k, insert to the head of the linkedlist, update carry, curSum\r\n\r\nedge cases: k is longer, num is longer, carry == 1 in the end\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int numIndex = num.length - 1;\r\n        int curSum = 0, carry = 0;\r\n        \r\n        while (numIndex >= 0) {\r\n            curSum = num[numIndex] + k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n            numIndex--;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            curSum = k % 10 + carry;\r\n            carry = curSum / 10;\r\n            curSum %= 10;\r\n            sum.addFirst(curSum);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) sum.addFirst(carry);\r\n        return sum;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity:\r\n```\r\nTime: O(max(num.length, log_10_k))\r\nSpace: O(max(num.length, log_10_k)) for the linkedlist\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086537211","body":"# Plan & Complexity: \n\n```\nIt is guaranteed that c occurs at least once in s.\n1 <= s.length <= 10^4\n\ns = \"loveleetcode\", c = \"e\"\n\nl o v e l e e t c o d e\nm m m 0 1 0 0 1 2 3 4 0\n3 2 1 0 1 0 0 1 2 2 1 0\n\nidea: two traversals, left-> right, right -> left\n\nTime: O(s.length())\nSpace: O(s.length()) for the distances array\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] distances = new int[s.length()];\n        int toCompare = Integer.MAX_VALUE;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.abs(toCompare - i);\n            }\n        }\n        \n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distances[i] = 0;\n                toCompare = i;\n            } else {\n                distances[i] = Math.min(distances[i], Math.abs(toCompare - i));\n            }\n        }\n        \n        return distances;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897041","body":"```java\n/*\nBruteforce:\nsimulate with an array\n\n\nOptimization:\nprefix sum\n\nwhen pop, adjust the inc for the previous cell\n\ninc list and stack list\n\nTime: O(1) \nSpace: O(1) per element\n\n*/\n\nclass CustomStack {\n\tint capacity;\n\tint size;\n\tList<Integer> stack = new ArrayList<>();\n\tList<Integer> inc = new ArrayList<>();\n\n\tpublic CustomStack(int maxSize) {\n\t\tcapacity = maxSize;\n\t\tsize = 0;\n\t}\n\n\tpublic void push(int x) {\n\t\tif (size < capacity) {\n\t\t\tstack.add(x);\n\t\t\tinc.add(0);\n\t\t\tsize++;\n\t\t}\n\t}\n\n\tpublic int pop() {\n\t\tif (size == 0) return -1; // empty check\n\t\tint ans = stack.get(size - 1) + inc.get(size - 1);\n\t\tif (size >= 2) {\n\t\t\tinc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n\t\t}\n\t\tinc.remove(size - 1);\n\t\tstack.remove(size - 1);\n\t\tsize--;\n\t\treturn ans;\n\t}\n\n    // index - > inc at that index\n\tpublic void increment(int k, int val) {\n\t\tif (size > 0) { \n\t\t\tinc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n\t\t}\n\t}\n\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087730751","body":"# Logic:\ntwo stacks, one for freq, one for str\n[: push cur freq, str to each stack, reset\n]: pop freq, str from each stack, pass curStr to temp and append\n\n# Complexity:\nTime: O(n), n = decoded len\nSpace: O(n), for two stacks and output\n\n# Code:\n```java\nclass Solution {\n    public String decodeString(String s) {\n        if (s.length() == 1) return s;\n        \n        StringBuilder decoded = new StringBuilder();\n        Stack<Integer> numStack = new Stack<>();\n        \n        Stack<StringBuilder> stack = new Stack<>();\n        int index = 0;\n        int curNum = 0;\n        StringBuilder curS = new StringBuilder();\n        \n        while (index < s.length()) {\n            if (Character.isDigit(s.charAt(index))) {             \n                curNum = curNum * 10 + s.charAt(index) - '0';\n                index++;\n            }\n            else if(s.charAt(index) == '[') {\n                numStack.push(curNum);\n                curNum = 0;\n                \n                stack.push(curS);\n                curS = new StringBuilder();\n                \n                index++;\n            }\n            else if (Character.isLetter(s.charAt(index))) {\n                curS.append(s.charAt(index));\n                index++;\n            }\n            else if (s.charAt(index) == ']') {\n                \n                StringBuilder temp = curS;\n                int freq = numStack.pop();\n                curS = stack.pop();\n                \n                for (int i = 0; i < freq; i++) {\n                    curS.append(temp);\n                }\n                index++;\n            }\n            \n        }\n        return curS.toString();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088905443","body":"# Plan:\r\ntwo stacks, one for pop only, one for push only, transfer elements before each operation\r\n\r\n# Complexity:\r\n```\r\nTime: O(N), N = total number of elements\r\nSpace: O(N) for N elements\r\n```\r\n# Code:\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack = new Stack<>();\r\n    Stack<Integer> popStack = new Stack<>();\r\n    \r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return popStack.isEmpty() && pushStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090434006","body":"# Plan:\n```\n5 5 5 -> 3\n1 5 5 -> 3\n5 1 5 -> 2\n6 1 5 -> 1\n[5,4,3,2,1] -> 1\n\n\n[1,1,0,0,1]-> 2\n\nIdea:\nmerge if the current num <= stack top \nstack stores the representatives (largest for that chunk)\nfrom stack bottom to top: increasing or equal\n\n-> 2 cases within the for loop\n```\n\n# Complexity:\n```\nTime: O(n), n = array.length, at most two operations on each element\nSpace: O(n)\n```\n# Code:\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> monoStack = new Stack<>();\n        for (int num : arr) {\n            if (monoStack.isEmpty() || monoStack.peek() <= num) {\n                monoStack.push(num);\n            }\n            else {\n                int curMax = monoStack.peek();\n                while (!monoStack.isEmpty() && monoStack.peek() > num) {\n                    monoStack.pop();\n                }\n                monoStack.push(curMax);\n            }\n        }\n        return monoStack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091905475","body":"# Idea:\n```\n\ncorner case: head == null, k == 0\nget len first, k = k % len, k==0 corner case\n\nfast and slow pointer\n```\n# Complexity:\n```\nTime: O(len of linkedlist)\n\nspace: O(1)\n```\n\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) return head;\n        int len = getLen(head);\n        k = k % len;\n        \n        if (k == 0) return head;\n        \n        ListNode fast = head, slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        \n        slow.next = null;\n        fast.next = head;\n        \n        return newHead;\n    }\n    \n    private int getLen(ListNode head) {\n        ListNode cur = head;\n        int len = 0;\n        while (cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        return len;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093021196","body":"# Idea:\n```\nfirst, second pointer, pre, dummy head\n```\n# Complexity:\n```\nTime: O(n), n = len of list\nSpace: O(1)\n```\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, first = head, second = first.next;\n        \n        while (second != null) {\n            ListNode newFirst = second.next;\n            pre.next = second;\n            second.next = first;\n            first.next = newFirst;\n            \n            if (newFirst == null) { // edge case\n                break;\n            }\n            \n            // update three pointers\n            pre = first;\n            first = newFirst;\n            second = first.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094073161","body":"# Idea: \n```\nuse dummy head, find mid, break into halves, disconnect, recursively build the tree\n```\n# Complexity:\n```\nTime:\n\nT(1) = T(0) = 1\nT(n) = 2 * T(n/2) + O(n/2)  -> extra linear traversal\n     = 2 * [2 * T(n/4) + O(n/4)] + O(n/2)\n     = 4 * T(n/4) + O(n)\n     = 4 * [2 * T(n/8) + O(n/8)] + O(n)\n     = 8 * T(n/8) + 3 * O(n/2)\n     = x * T(n/x) + log x * O(n/2)\n\nn/x = 1, n = x\nT(n) = n * T(1) + logn * O(n) = n + nlogn = nlogn\n\nSpace: \ntree: O(n), n = len of linkedlist\nstack: O(height) = O(logn)\n```\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        // must deal with the one node case as the base case\n        if (head.next == null) return new TreeNode(head.val, null, null);\n        ListNode dummy = new ListNode(0, head);\n        ListNode fast = head, slow = dummy;\n        while (fast != null && fast.next != null) { // 1-2-3-4\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        ListNode rootList = slow.next;\n        ListNode nextHead = rootList.next;\n        slow.next = null;\n        rootList.next = null;\n        \n        TreeNode root = new TreeNode(rootList.val);\n        \n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(nextHead);\n        \n        return root;\n    }\n    \n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094301369","body":"# Idea: \n```\ntwo pointers, restart from the other head if reaches null\n```\n\n# Complexity:\n```\na.   \n     b\nc\nTime: O(a + b + c), a, b, c represents len, a + b = lenA, b + c = lenB in case of intersection\n\nif node in segment b == null, no intersection, len of b = 1\n\nSpace: O(1)\n```\n\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode curA = headA, curB = headB;\n        while (curA != curB) {\n            curA = curA == null ? headB : curA.next;\n            curB = curB == null ? headA : curB.next;\n        }\n        return curA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095142802","body":"# Idea:\n```\n     *____c\n d   |     |\n----------|-------\n  a.    b\n\nmeet at *\n\nfast covers: a + b + c + d + b + c\nslow covers: a + b + c\n\n2 * (a + b + c) = a + b + c + d + b + c\n\na = d\nrestart fast from the origin, slow from *, one step for each this time\n\nthe cycle starts at where they meet\n```\n\n# Complexity:\n```\nTime: O(a + b + c + d) if circle exists, otherwise, O(len of list)\n\nSpace: O(1)\n```\n# Code:\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                break;\n            }\n        }\n        if (fast == null || fast.next == null) return null;\n        \n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return fast;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bin214":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085914856","body":"####思路\n\n按位取出数字k，依次加到数组A内，需注意产生的进位，如果数组首位仍有进位，则数组首部加一位\n\n\n\n#### 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> ans = new ArrayList<>();\n    int n = num.length;\n    int sum = 0, flag = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        sum = (k % 10) + num[i] + flag;\n        k = k / 10;\n        if (sum >= 10) {\n            sum = sum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        ans.add(sum);\n    }\n    while (k != 0){\n        ans.add(k % 10 + flag);\n        k = k / 10;\n        if(flag != 0) flag = 0;\n    }\n    if(flag != 0)\n        ans.add(1);\n    Collections.reverse(ans);\n    return ans;\n}\n```\n\n\n\n#### 复杂度分析\n\n时间复杂度：O(m + n)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090236394","body":"## 思路\n最开始想到的是窗口法，左部分序列的最大值小于右部分序列的最小值就能划分，另最左边的值为最小值，最右边的值为最大值时都可以被划分，但是没能想出比较简洁的写法，题解的计数排序的思路比较清晰，感觉会比较适合面试\n\n## 代码\n```java\npublic int maxChunksToSorted(int[] arr) {\n        int chunkNumber = 0, n = arr.length;\n        int[] arrSort = (int[])arr.clone();\n        Arrays.sort(arrSort);\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int nonzero = 0;\n        for(int i = 0; i < n; i++){\n            int x = arr[i];\n            int y = arrSort[i];\n            map.put(x, map.getOrDefault(x, 0) + 1);\n            if(map.get(x) == 0) nonzero--;\n            if(map.get(x) == 1) nonzero++;\n\n            map.put(y, map.getOrDefault(y, 0) - 1);\n            if(map.get(y) == 0) nonzero--;\n            if(map.get(y) == -1) nonzero++;\n\n            if(nonzero == 0) chunkNumber++;\n        }\n        return chunkNumber;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091635028","body":"## 思路\n使用快慢指针，快指针先走k步，快慢指针一起走到快指针到头，快指针指向原链表头，慢指针指向变成新链表头（被虐了几天终于能AC一道题了）\n\n## 代码\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        ListNode fast = head, slow = head, headCopy = head;\n        for(int i = 0; i < k; i++){//防止k大于链表长度，可以改成先求链表长度再求余的形式\n            if(fast.next != null)\n                fast = fast.next;\n            else\n                fast = head;\n        }\n        while (fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        fast.next = headCopy;\n        ListNode newHead = slow.next;\n        slow.next = null;\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092609446","body":"## 思路\n同样是快慢指针法，但需要额外的指针指向慢指针的前驱方便交换，另外链表的长度为奇数或偶数时都需要做判别\n\n## 代码\n```java\npublic ListNode swapPairs(ListNode head) {\n        if(head == null) return null;\n        if(head.next == null) return head;\n        ListNode preHead = new ListNode();\n        preHead.next = head;\n        ListNode pre = preHead, slow = head, fast = head.next;\n        while(true){\n            pre.next = fast;\n            slow.next = fast.next;\n            fast.next = slow;\n\n            if(slow.next != null)\n                slow = slow.next;\n            else return preHead.next;\n            if(slow.next != null)\n                fast = slow.next;\n            else return preHead.next;\n            pre = pre.next.next;\n        }\n    }\n```\n\n## 复杂度\n时间复杂度：O(n)，遍历一遍链表\n空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095059114","body":"# 代码\n```java\npublic ListNode detectCycle(ListNode head) {\n        HashMap<ListNode, Integer> hash = new HashMap<>();\n        while (head != null){\n            if(!hash.containsKey(head)){\n                hash.put(head, 1);\n            }else {\n                return head;\n            }\n            head = head.next;\n        }\n        return null;\n    }\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oision-hub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085926377","body":"### 思路\n逐位相加，若大于10则进位。\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int len = num.size();\n        for (int i = len - 1; i >= 0; i--) {\n            int temp = num[i] + k % 10;\n            k = k / 10;\n            if (temp >= 10) {\n                k += 1;\n                temp = temp % 10;\n            }\n            result.push_back(temp);\n        }\n        while (k != 0) {\n            result.push_back(k % 10);\n            k = k / 10;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n```\n### 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650727","body":"### 思路\n将两边遍历的结果存入数组，留下较小的值\n### 解答\n``` c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) {\n            if (s[i] == c) {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) {\n            if (s[i] == c) {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```\n###  复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085927113","body":"func addToArrayForm(num []int, k int) []int {\n    for i := len(num) - 1; i >= 0; i-- {\n        num[i] += k % 10\n        k /= 10\n\n        // if overflow\n        if num[i] > 9 {\n            k++\n            num[i] -= 10\n        }\n    }\n\n    // if k length more than num length\n    for k > 0 {\n        num = append([]int{k % 10}, num...)\n        k /= 10\n    }\n\n    return num\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666125","body":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestShortestDistanceToACharacter(t *testing.T) {\n\ts := \"loveleetcode\"\n\tvar c byte = 'e'\n\n\tchars := shortestDistanceToACharacter(s, c)\n\n\tfor _, v := range chars {\n\t\tfmt.Print(v, \"\\t\")\n\t}\n\tfmt.Println()\n\n}\n\nfunc shortestDistanceToACharacter(s string, c byte) []int {\n\tres := make([]int, len(s))\n\n\t// prevent overflow\n\tleft, right := math.MinInt32/2, math.MaxInt32/2\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] == c {\n\t\t\tleft = i\n\t\t}\n\t\tres[i] = i - left\n\t}\n\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tright = i\n\t\t}\n\t\tres[i] = min(res[i], right-i)\n\t}\n\n\treturn res\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086868863","body":"```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack {\r\n        make ([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n   if len(this.stack) > 0  {\r\n       res := this.stack[len(this.stack) - 1]\r\n       this.stack = this.stack[:len(this.stack) - 1]\r\n       return  res\r\n   } else {\r\n      return -1 \r\n   }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    } \r\n\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088720831","body":"```go\ntype MyQueue struct {\n    inStack, outStack []int\n}\n\n\nfunc Constructor() MyQueue {\n    return MyQueue{\n        inStack : make([]int, 0),\n        outStack : make([]int, 0),\n    }\n}\n\n\nfunc (q *MyQueue) Push(x int)  {\n    q.inStack = append(q.inStack, x)\n}\n\n\nfunc (q *MyQueue) Pop() int {\n    if len(q.outStack) == 0 {\n        for len(q.inStack) > 0 {\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\n            q.inStack = q.inStack[:len(q.inStack) - 1]\n        }\n    }\n    x := q.outStack[len(q.outStack) - 1]\n    q.outStack = q.outStack[:len(q.outStack) - 1]\n\n    return x\n}\n\n\nfunc (q *MyQueue) Peek() int {\n    if len(q.outStack) == 0 {\n        for len(q.inStack) > 0 {\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\n            q.inStack = q.inStack[:len(q.inStack) - 1]\n        }\n    }\n    x := q.outStack[len(q.outStack) - 1]\n    return x\n}\n\n\nfunc (q *MyQueue) Empty() bool {\n    return len(q.outStack) == 0 && len(q.inStack) == 0\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092336991","body":"```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\n // 迭代实现\nfunc swapPairs(head *ListNode) *ListNode {\n    dummyHead := &ListNode{0, head}\n    temp := dummyHead\n\n    // 后一个结点和后两个结点不为nil\n    for temp.Next != nil && temp.Next.Next != nil {\n       nodeBefore := temp.Next\n       nodeAfter := temp.Next.Next\n\n       temp.Next = nodeAfter\n       nodeBefore.Next = nodeAfter.Next\n       nodeAfter.Next = nodeBefore\n       temp = nodeBefore\n    }\n\n    return dummyHead.Next\n\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095084862","body":"```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    // 创建头结点和尾结点\n    slow, fast := head, head\n\n    // 快慢指针\n    for fast != nil {\n        slow = slow.Next\n        if fast.Next == nil {\n            return nil\n        }\n        fast = fast.Next.Next\n        //\n        if fast == slow {\n            p := head\n            for p != slow {\n                p = p.Next\n                slow = slow.Next\n            }\n            return p\n        }\n    }\n    return nil\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhishinaigai":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085936068","body":"### 思路\r\n浅抄一手答案\r\n\r\n### 代码\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector <int> ans;\r\n        int len=num.size();\r\n        \r\n        for(int i=len-1;i>=0;i--){\r\n            int s=num[i]+k%10;\r\n            k/=10;\r\n            if(s>=10){\r\n                k++;\r\n                s-=10;\r\n            }\r\n            ans.push_back(s);\r\n        }\r\n        while(k>0){\r\n            ans.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n        return ans;\r\n    }\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652806","body":"### 思路\r\n今天也是抄答案的一天呢\r\n### 代码\r\n```\r\nvector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(),-1);\r\n        int len=s.size();\r\n        int p=-1;\r\n        for(int i=0;i<len;i++){\r\n            if(s[i]==c){\r\n                p=i;\r\n                ans[i]=0;\r\n            } \r\n            else if(p!=-1) ans[i]=i-p;\r\n        }\r\n        p=-1;\r\n        for(int i=len-1;i>=0;--i){\r\n            if(s[i]==c) p=i;\r\n            if(p!=-1) ans[i]=min(ans[i],p-i);\r\n            if(ans[i]==-1) ans[i]=p-i;\r\n             \r\n        }\r\n        return ans;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086847912","body":"### 思路\r\n使用vector实现\r\n### 代码\r\n```c\r\nclass CustomStack {\r\npublic:\r\n    vector <int> stk;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=stk.size()-1){\r\n            ++top;\r\n            stk[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1) return -1;\r\n        --top;\r\n        return stk[top+1];\r\n\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim=min(k,top+1);\r\n        for(int i=0;i<lim;++i){\r\n            stk[i]+=val;\r\n        }\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087532217","body":"思路\r\n---\r\n\r\n抄答案都没看懂哇，字符串一生之敌\r\n\r\n代码\r\n---\r\n```c\r\nstring getDigits(string &s,size_t &ptr){\r\n        string ret=\"\";\r\n        while(isdigit(s[ptr])){\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n    string getString(vector<string> &v){\r\n        string ret;\r\n        for(const auto &s:v){\r\n            ret+=s;\r\n        }\r\n        return ret;\r\n    }\r\n    string decodeString(string s) {\r\n        int len=s.size();\r\n        vector <string> stk;\r\n        size_t i=0;\r\n\r\n        while(i<len){\r\n            char cur=s[i];\r\n            if(isdigit(cur)){\r\n                string digits=getDigits(s,i);\r\n                stk.push_back(digits);\r\n            }\r\n            else if(isalpha(cur)||cur=='['){\r\n                stk.push_back(string(1,s[i++]));\r\n            }\r\n            else{\r\n                ++i;\r\n                vector<string> sub;\r\n                while(stk.back()!=\"[\"){\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(),sub.end());\r\n                stk.pop_back();\r\n                int reptime=stoi(stk.back());\r\n                stk.pop_back();\r\n                string t,o=getString(sub);\r\n                while(reptime--) t+=o;\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n        return getString(stk);\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088858579","body":"思路\r\n---\r\n\r\n两个栈一个in一个out\r\n\r\n代码\r\n---\r\n\r\n```c\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> ins,outs;\r\n    void in2out(){\r\n        while(!ins.empty()){\r\n            outs.push(ins.top());\r\n            ins.pop();\r\n        }\r\n    }\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        ins.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outs.empty()){\r\n            in2out();\r\n        }\r\n        int x=outs.top();\r\n        outs.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outs.empty()){\r\n            in2out();\r\n        }\r\n        return outs.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return ins.empty() && outs.empty();\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090237216","body":"思路\r\n---\r\n\r\n- 使用栈存储每个块最大的元素\r\n- 若arr[i]大于栈顶元素则直接入栈\r\n- 若arr[i]小于栈顶元素则将大于arr[i]的元素从栈中弹出\r\n\r\n代码\r\n---\r\n\r\n```c\r\nint maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> maxstk;\r\n        maxstk.push(arr[0]);\r\n        for(int i=1;i<arr.size();i++){\r\n            if(arr[i]<maxstk.top()){\r\n                int maxnum=maxstk.top();\r\n                while(!maxstk.empty()&&maxstk.top()>arr[i]) maxstk.pop();\r\n                maxstk.push(maxnum);\r\n            }\r\n            else{\r\n                maxstk.push(arr[i]);\r\n            }\r\n        }\r\n        return maxstk.size();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091887734","body":"思路\r\n---\r\n将链表变成环再在相应位置切断\r\n\r\n代码\r\n---\r\n```c\r\nListNode* rotateRight(ListNode* head, int k) {\r\n        if(k==0||head==nullptr||head->next==nullptr) return head;\r\n        int n=1;\r\n        ListNode *iter=head;\r\n        while(iter->next!=nullptr){\r\n            iter=iter->next;\r\n            n++;\r\n        }\r\n        int add=n-k%n;\r\n        if(add==n) return head;\r\n        iter->next=head;\r\n        while(add--){\r\n            iter=iter->next;\r\n        }\r\n        ListNode *ret=iter->next;\r\n        iter->next=nullptr;\r\n        return ret;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092790544","body":"思路\r\n---\r\n迭代实现\r\n\r\n代码\r\n---\r\n```c\r\nListNode* swapPairs(ListNode* head) {\r\n        ListNode * dhead=new ListNode(0);\r\n        dhead->next=head;\r\n        ListNode* temp=dhead;\r\n        while(temp->next!=nullptr&&temp->next->next!=nullptr){\r\n            ListNode* n1=temp->next;\r\n            ListNode* n2=temp->next->next;\r\n            temp->next=n2;\r\n            n1->next=n2->next;\r\n            n2->next=n1;\r\n            temp=n1;\r\n        }\r\n        return dhead->next;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094157906","body":"思路\r\n---\r\n双指针\r\n\r\n代码\r\n---\r\n```c\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA==nullptr||headB==nullptr){\r\n            return nullptr;\r\n        }\r\n        ListNode *a=headA;\r\n        ListNode *b=headB;\r\n        while(a!=b){\r\n            a= a==nullptr ? headB : a->next;\r\n            b= b==nullptr ? headA : b->next;\r\n        }\r\n        return a;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094939531","body":"思路\r\n---\r\n快慢指针\r\n\r\n代码\r\n---\r\n```c\r\nListNode *detectCycle(ListNode *head) {\r\n        ListNode *fast=head,*slow=head;\r\n        do{\r\n            if(!fast||!fast->next) return nullptr;\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }while(fast!=slow);\r\n        fast=head;\r\n        while(fast!=slow){\r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        return fast;\r\n    }\r\n```\r\n\r\n复杂度\r\n---\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jasonhe-wq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938194","body":"思路：将列表中的数转化为整数，与k相加，再转化为可迭代对象，加入数组输出\n代码：\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s=''.join(str(i) for i in num)\n        n = str(eval(s)+k)\n        l = []\n        for i in n:\n            l.append(eval(i))\n        return l\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086649828","body":"思路：\n对于每一个等于c的字符，在其两侧分别计算距离，而对于每个字符，距离取最小值\n优化方向：\n将等于c的字符分为首个，中间，末尾，分别控制不同的区域\n代码：\n'''\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        ans = [l for i in range(l)]\n        for i in range(l):\n            if s[i] == c:\n                for j in range(l):\n                    ans[j]=min(ans[j],abs(i-j))\n        return ans\n'''","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877618","body":"思路：\n构建数组作为栈，再用一个额外的变量存储maxsize，对于每个要相加的值，先判断长度是否小于k，再遍历\n```\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.num = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.num:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087712391","body":"思路：\n每次遇到[记录下来位置，遇到]则将片段重复mul次，并将指针重新移动到最左端，重复操作\n对于数字，每次遇到时判断，如果与[相邻，则记为mul，否则舍去\n最后通过列表将序列中的数字全部去除\n代码：\n```class Solution:\n    def decodeString(self, s: str) -> str:\n        left = []\n        num = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        n = \"\"\n        s0 = \"\"\n        mul = 0\n        i = 0\n        ans =\"\"\n        nu = \"\"\n        while i <len(s):\n            if s[i] == \"[\":\n                left.append(i)\n                n = s[:i]\n                for j in n:\n                    if j in num:\n                        nu += j\n                    else:\n                        nu =\"\"\n                mul = eval(nu)\n                nu = \"\"\n                i += 1\n            elif s[i] == \"]\":\n                s0 = s[:left[-1]]+s[left[-1]+1:i] * mul+s[i+1:]\n                s = s0\n                i = 0\n            else:\n                i +=1\n        l = list(s)\n        for i in range(len(l)):\n            if l[i] in num:\n                pass\n            else:\n                ans += l[i]\n        return ans\n复杂度：O(n)还是O(n^2)我也不知道","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088377130","body":"思路：\n创建入栈和出栈列表，向入栈队列添加元素，当都为空时返回空，当出栈为空时，依次将入栈元素压入，再返回\n代码：\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.inStack = []\n        self.outStack = []\n\n\n    def push(self, x: int) -> None:\n        self.inStack.append(x)\n\n    def pop(self) -> int:\n        if not self.empty():\n            if self.outStack:\n                return self.outStack.pop()\n            else:\n                while self.inStack:\n                    self.outStack.append(self.inStack.pop())\n                return self.outStack.pop()\n        else:\n            return 0\n\n    def peek(self) -> int:\n        if self.empty():\n            return 0\n        if not self.outStack:            \n            while self.inStack:\n                self.outStack.append(self.inStack.pop())\n        val = self.pop()\n        self.outStack.append(val)\n        return val\n\n\n\n    def empty(self) -> bool:\n        if not (self.inStack or self.outStack):\n            return True\n        return False","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091732167","body":"思路：\n先判断是否满足旋转条件，再求出链表长度，对k取余数，为真正需要移位次数k0\n再将指针转移到倒数第二个，将其定义为最后一个，最后一个移到第一个，重复k0次\n复杂度：\nO(n)\n代码：\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        index = 0 \n        node = head\n        head = head\n        test = head\n        l = 0\n        if k == 0 or not head or not head.next:\n            return head\n        while test:\n            test = test.next\n            l += 1\n        k = k%l\n        while index <k:\n            flag  = node.next.next\n            if flag:\n                node = node.next\n                continue\n            else:\n                i = node.next\n                node.next = None\n                i.next = head\n                head = i\n                node  = head\n            index += 1\n        return head","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092541812","body":"思路：\n用多个变量分别记录各个位置的链表，再重新排序\n私以为关键点在于最后如何跳出循环，如果为偶数个节点，直接跳出，如果为奇数个节点，需要额外的判断，可以使用not的特性，直接跳出\n代码\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        node = ListNode(0,head)\n        h0 = node\n        while node.next.next:\n            next2 = node.next.next.next\n            next0 = node.next\n            next1 = node.next.next\n            node.next = next1\n            node.next.next = next0\n            node.next.next.next = next2\n            node = node.next.next\n            re = h0.next\n            if not node.next or not node.next.next:\n                return re\n        return h0.next\n            \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094008518","body":"思路：\n说实话，我一开始根本没有思路，这类递归都不太会\n我看了l神的答案，觉得题目难点就在于要想到递归\n代码：\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        l = 0\n        stack = []\n        cut, slow, fast = None, head, head\n        if not head:\n            return head\n        while fast and fast.next:\n            cut = slow\n            slow = slow.next           \n            fast = fast.next.next\n        if cut:\n            cut.next = None   \n        midTree = TreeNode(slow.val)\n        if slow==fast:\n            return midTree\n        midTree.left = self.sortedListToBST(head)\n        midTree.right = self.sortedListToBST(slow.next)\n        return midTree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094173688","body":"思路：\r\n交叉遍历，当第一次取到末尾时，相互交换，heada到headb链上，headb到heada链上，如果再次走到末尾且两者没有相同的节点，返回空，否则返回相等的节点\r\n代码：\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        vala = []\r\n        valb = []\r\n        ha = headA\r\n        hb = headB\r\n        flaga = False\r\n        flagb = False\r\n        while True:\r\n            if headA == headB:\r\n                return headB           \r\n            if not headA.next and not flaga:\r\n                pre = headA\r\n                headA.next = hb\r\n                headA = headA.next\r\n                pre.next = None\r\n                flaga = True\r\n            elif not headA.next and flaga:\r\n                return None\r\n            else:\r\n                headA = headA.next\r\n            if not headB.next and not flagb:\r\n                pre = headB\r\n                headB.next = ha\r\n                headB = headB.next\r\n                pre.next = None\r\n                flagb = True\r\n            elif not headB.next and flagb:\r\n                return None\r\n            else:\r\n                headB = headB.next\r\n复杂度：\r\nO(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094463378","body":"思路：\n创建列表，如果里面没有对应结点，则加入，如果有，则返回\n代码：\n```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        l = []\n        if not head or not head.next:\n            return None\n        while head:\n            if head not in l:\n                l.append(head)\n                head = head.next\n            else:\n                return head","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938263","body":"## 989. Add to Array-Form of Integer\n### 1. 思路\n- 基础思考点：transform a number to an int array\n```C\n// 代码实现\nvar array = [];\nvar k = 123;\nwhile (k >= 1) {\n  array.push(Math.floor(k % 10));\n  k /= 10;\n}\n// array: [1, 2, 3]\n```\n拓展上述代码，思路变为：\n> k 或 num 还有剩余位数时，resultArray 不断添加剩余数位\n### 2. 细节处理\n- 相加的结果会进位（这里我用了 num 来存储进位数据）\n  - 如果 num 数组还有数字，给数组的最后一位+1\n  - 如果 num 数组没有数字了，将数组的最后一位赋为 1\n- num 代表的数字，其位数和 k 的位数不一致\n  - 判断一下，确保 getK 和 getN 不会越位\n\n### 3. 复杂度\n- 时间：O(n)  \n  - while 的长度为 max(k的位数，num的位数);  \n  - while 内部涉及的数组操作:     \narray.pop(), array.push(), array[i] =，三者的时间复杂度为 O(1)\n- 空间：O(n)\n  - 新开了一个数组，O(n)\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nconst addToArrayForm = (num, k) => {\n  let temp = 0;\n  const resultArray = [];\n  while (k >= 1 || num.length) {\n    temp = getK(Math.floor(k % 10)) + getN(num);\n    resultArray.push(handleTemp(temp, num));\n\n    temp = 0;\n    k /= 10;\n  }\n  return resultArray.reverse();\n};\n\nconst getK = (kNum) => kNum >= 1 ? kNum : 0;\nconst getN = (num) => num.length ? num.pop() : 0;\nconst handleTemp = (temp, num) => {\n  if (temp >= 10) {\n    temp -= 10;\n    if (num.length) {\n      num[num.length - 1] += 1;\n    } else {\n      num[0] = 1;\n    }\n  }\n  return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086504869","body":"821. Shortest Distance to a Character\n### 1. 思路\n- 基础思路\n  - 求数组中两个元素 i, j 的距离: i - j\n- 拓展\n  - 求 i 到左右两边 j、h 的最短距离  \n### 2. 细节\n  - j 的位置未知：\n    - 开一个线性数据结构，记录 j 的位置\n  - 离 i 最近的元素不一定是 j，i 可能还有左相邻、且距离更近的元素 h：\n    - 求最短距离时，比较 Math.min(Math.abs(i - j), Math.abs(i - h))\n  - i - j、i - h，索引不应越界  \n### 3. 复杂度\n- 时间：O(n)\n  - 遍历 s，且遍历内部无 O(n) 及以上层级的操作\n- 空间：O(n)\n  - 新开了 resultArr 数组\n\n```javascript\nvar shortestToChar = function(s, c) {\n  const cHash = new Array(s.length).fill(0);\n  let cHashStart = 0;\n  const resultArr = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      cHash[cHashStart] = i;\n      cHashStart++;\n      resultArr[i] = 0;\n    }\n  }\n  cHashStart = 0;\n  cHashPrev = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (i !== cHash[cHashStart]) {\n      cHashPrev = cHashStart > 0 ? cHashStart - 1 : 0;\n      const shortestGap = Math.min(\n        Math.abs(cHash[cHashPrev] - i),\n        Math.abs(cHash[cHashStart] - i)\n      );\n      resultArr[i] = shortestGap;\n    } else {\n      cHashStart++;\n    }\n  }\n  return resultArr;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086889454","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length < this.maxSize) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.pop() || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (this.stack[i]) { this.stack[i] += val; }\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n### Complexity\n- time\n  - inc: O(n), pop/push: O(1)\n- space\n  - O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088214516","body":"## 232. 用栈实现队列\n\n## 思路\n- 基本思路\n  - 问题：删除数组开头元素，时间复杂度相对较高\n  - 解决办法：用两个栈实现队列\n- 两个栈实现队列细节\n  - 栈 2、栈 1 的作用\n    - 栈 1 用于入栈，栈 2 用于出栈\n  - 栈 2 、栈 1 的关系\n    - 栈 2 即倒过来的栈 1：栈 1 最前面的元素，会被推到栈 2 末尾\n  - 栈 2 和栈 1 联合，对消减时间复杂度的贡献\n    - 删除栈 1 的开头元素，即变为删除栈 2 的末尾元素，O(N) => O(1)\n\n## 复杂度\n- 空间复杂度 O(N)\n- 时间复杂度\n  - 摊还时间复杂度 O(1)\n    - 最坏情况 O(N)：栈 2 为空，需要 for loop 挤压栈 1 时 \n    - 最好情况 O(1)\n\n## 摊还分析\n- 摊还分析的核心\n  - 高频次操作的时间复杂度小 + 低频次操作的时间复杂度高，二者均摊了每次操作的代价\n  - 即，每 n 次入队才能产生一次代价为 n 的出队操作\n- 所有操作的总时间复杂度\n  >  O(2N) = n(所有的入队操作产生） + 2 * n(第一次出队操作产生） + n - 1(剩下的出队操作产生）\n- 综上所述，每次操作的平均时间复杂度为 O(2N/2N)=O(1)\n\n## 代码\n```\nvar MyQueue = function() {\n  this.queue1 = [];\n  this.queue2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.queue1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  this.cleanQ1();\n  return this.queue2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  this.cleanQ1();\n  return this.queue2[this.queue2.length - 1];\n};\n\nMyQueue.prototype.cleanQ1 = function() {\n  if (this.queue2.length === 0) {\n    const q1Len = this.queue1.length;\n    for (let i = 0; i < q1Len; i++) {\n      this.queue2.push(this.queue1.pop());\n    }\n  }\n}\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.queue1.length === 0 && this.queue2.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090014593","body":"## 769. Max Chunks To Make Sorted\r\n\r\n## 思路\r\n- 基本思路\r\n  - 何时满足分区条件\r\n    - 下一个分区中的所有数字 >= 上一个分区的最大值    \r\n      > 数组遍历中的当前元素 >= 上一个分区的最大值\r\n  - 如何存储上一个分区的最大值\r\n    - 维护一个单调递增栈，栈顶即为上一个分区的最大值  \r\n- 实现：遍历数组 + 单调栈 \r\n  - 满足分区条件时 (当前元素 >= 栈顶元素）\r\n    - 将当前元素压入单调栈中\r\n  - 不满足分区条件时（当前元素 < 栈顶元素）\r\n    - 需将之前的分区和当前元素合为一个新的分区：\r\n      - 保存栈顶元素 stackTop（上一个分区中的最大值）\r\n      - 将单调栈中大于当前元素的元素出栈，直到当前元素 >= 栈顶元素\r\n      - 将已保存的栈顶元素 stackTop 压入单调栈中\r\n- 数组能分成的最多块数量\r\n  - 单调栈中的元素个数，即每一分区的最大值\r\n\r\n## 复杂度\r\n- 空间： O(N)\r\n- 时间： O(N)\r\n  - 为数不多的最坏情况下，while 内部的运行次数也无法达到 O(N)  \r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  const stack = [arr[0]];\r\n  for (let i = 1; i < arr.length; i++) {\r\n    const stackTop = getStacktop(stack);\r\n    if (arr[i] >= stackTop) { // 满足条件，找到新的分区\r\n      stack.push(arr[i]);\r\n      continue;\r\n    }\r\n    while (stack.length && arr[i] < getStacktop(stack)) {\r\n      stack.pop(); // 将大于当前元素的所有元素出栈\r\n    }\r\n    stack.push(stackTop); // \r\n  }\r\n  return stack.length;\r\n};\r\n\r\nvar getStacktop = function(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091769680","body":"## 61. 旋转链表\r\n\r\n## 思路\r\n- 向右旋转链表  \r\n=> 1. 使旧链表首尾相连  \r\n=> 2. 遍历到旋转后的链表尾节点 t （第 n - k % n 个节点）     \r\n=> 3. 存储新链表首节点 res = t.next    \r\n=> 4. 切开环型链表 delete t.next  \r\n\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(1)\r\n\r\n## 代码\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!k || !head?.next) {\r\n        return head;\r\n    }\r\n    // 存储链表尾部，链表长度\r\n    let n = 1;\r\n    let tail = head;\r\n    while (tail.next) {\r\n      n++;\r\n      tail = tail.next;\r\n    }\r\n    \r\n    // 计算旋转后链表尾节点的位置\r\n    let rotatedEndDistance = n - k % n;\r\n    if (rotatedEndDistance === n) {\r\n        return head;\r\n    }\r\n\r\n    // 连接链表首尾\r\n    tail.next = head;\r\n\r\n    // 找到旋转后链表尾节点的位置\r\n    while (rotatedEndDistance) {\r\n      tail = tail.next;\r\n      rotatedEndDistance--;\r\n    }\r\n\r\n    // 存储旋转后链表头节点的位置\r\n    const res = tail.next;\r\n    // 切断前述尾节点和新头节点的连接\r\n    tail.next = null;\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092869447","body":"## 24. 两两交换链表中的节点\r\n## 思路\r\n- 两两交换，实际有三个节点在动态变化：\r\n- 实现\r\n   - 设置头中、尾、节点\r\n   - 修改头、中、尾三个节点的 next \r\n   - 更新头、尾节点的位置\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(1)\r\n\r\n## 代码\r\n```javascript\r\nconst swapPairs = (curr) => {\r\n  const res = new ListNode(0);\r\n  res.next = curr;\r\n  let head = res;\r\n  while (curr?.next) {\r\n    const tail = curr.next;\r\n    curr.next = tail.next;\r\n    tail.next = curr;\r\n    head.next = tail;\r\n\r\n    head = curr;\r\n    curr = curr.next;\r\n  }\r\n  return res.next;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094033202","body":"## 109. 有序链表转换二叉搜索树\r\n## 思路\r\n- 将链表转化成数组后，不断寻找数组的中间元素，再依此反复分配左右子树\r\n\r\n## 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n  const linkedListArr = [];\r\n  while (head) {\r\n    linkedListArr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  \r\n  return formBST(0 , linkedListArr.length - 1, linkedListArr);\r\n};\r\n\r\nconst formBST = (start, end, arr) => {\r\n  if (start > end) {\r\n    return null;\r\n  }\r\n  const mid = (start + end) >>> 1;\r\n  const root = new TreeNode(arr[mid]);\r\n  root.left = formBST(start, mid - 1, arr);\r\n  root.right = formBST(mid + 1, end, arr);\r\n  return root;\r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095207543","body":"## 142. 环形链表 II\n## 思路\n- 链表是否有环\n  - slow、fast 指针可相遇，说明链表有环\n- 如何寻找环的入口\n  - 从头节点发出一个指针，再从 slow、fast 相遇节点发出一个指针\n  - 两个指针不断往前走（每次走一个节点）\n  - 两个指针在环的入口相遇\n<img width=\"389\" alt=\"image\" src=\"https://user-images.githubusercontent.com/51183663/162776567-24f7b0e2-5cac-46df-a711-e0069299d62f.png\">\n\nslow pointer moved steps * 2 = fast pointer moved steps\n```\n(x + y) * 2 = x + y + n(y + z)\nx = n(y + z) - y\nx = (n - 1)(y + z) + z\n```\n> 从相遇点到入环点的距离 z，加上 n-1 圈的环长(y + z)，等于从链表头部到入环点的距离 x\n\n\n## 复杂度\n- 时间：O(N)\n- 空间：O(1)\n\n## 代码\n```javascript\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    var slow = head;\n    var fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (fast == slow) {\n            var cycleFinder = head;\n            while (slow != cycleFinder) {\n                slow = slow.next;\n                cycleFinder = cycleFinder.next;\n            }\n            return cycleFinder;\n        }\n    }\n    return null;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"divingcub":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085938282","body":"## Idea\r\nBackward iteration, 考虑位进.\r\n\r\n## Code \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> sum = new ArrayList<Integer>();\r\n        int length = num.length;\r\n        num[length - 1] += k;\r\n        for (int i = length - 1; i > 0; i--) {\r\n            int curNum = num[i];\r\n            if (curNum > 9) {\r\n                num[i - 1] += curNum / 10;\r\n                num[i] %= 10;\r\n            }\r\n            sum.add(num[i]);\r\n        }\r\n        do {\r\n            sum.add(num[0] % 10);\r\n            num[0] /= 10;\r\n        } while (num[0] > 0);\r\n        Collections.reverse(sum);\r\n        return sum;\r\n    }\r\n}\r\n\r\n## Complexity\r\nTime:O(n)\r\nSpace: O(1)\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087690980","body":"## 思路\n\n遇见非 ']' 都直接进行进栈操作，见 ']' 则进行扫描栈内，和上面一个匹配 ']' 的 '['，然后统计出匹配括号内的所有字符，接着将 匹配到 '[' 最近的数字出栈，然后再按照数字倍数 重新将统计到的字符进行进栈操作，最后只要依次出战所有元素。\n\n##代码\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c == ']'){\n          \n                StringBuilder temp = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek())){\n                    temp.insert(0,stack.pop());\n                }\n            \n                String tempString = temp.toString();\n                stack.pop();\n            \n                temp = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    temp.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(temp.toString());\n              \n                while(count > 0){\n                    for(char ch : tempString.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }else{\n            \n                stack.push(c);\n            }\n        }\n    \n        StringBuilder ans = new StringBuilder();\n        while(!stack.isEmpty()){\n            ans.insert(0,stack.pop());\n        }\n        return ans.toString();\n    }\n}\n\n\n##复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088900557","body":"## 思路部分\n\n双栈实现的思想\n\n## 代码实现部分\n\n```\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!stack1.isEmpty()){\n            stack2.push(stack1.pop());\n        }\n        stack1.push(x);\n        while (!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n\n    public int pop() {\n        return stack1.pop();\n    }\n\n    public int peek() {\n        return stack1.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n\n## 复杂度\n\n1. O(N)  -- 时间复杂度\n2. O(N) --  空间复杂度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090437546","body":"## idea\n\n要计算分割点位置用于唯一确定分块, 其中分割点右端点是从左到右遍历需要确定的.\n\n分割点很显然 分割点左边都比分割点右边的值小, 这样排序完成才会有序, 所以需要设计一个前缀数组记录左侧最大值信息,记录范围为[0,index]. 使用后缀数组记录右侧最小值信息, 范围为(index,arr.length).\n如果满足左侧最大值小于右侧最小值, 显然是一个分割点, 记录即可.\n\n## Code\n\n```java\nclass Solution {\n\n \n    public int maxChunksToSorted(int[] arr) {\n        if(arr.length==1)\n            return 1;\n        int[] prefix=new int[arr.length];\n        int[] suffix=new int[arr.length];\n\n        prefix[0]=arr[0];\n        suffix[arr.length-1]=Integer.MAX_VALUE;\n        for(int i=1;i<arr.length;i++){\n            prefix[i]=Math.max(prefix[i-1],arr[i]);\n            suffix[arr.length-i-1]=Math.min(suffix[arr.length-i],arr[arr.length-i]);\n        }\n        int ans=0;\n        for(int i=0;i<arr.length;i++){\n            if(prefix[i]<=suffix[i]){\n                ans++;\n            }\n        }\n        return ans;\n\n    }\n}\n\n\n```\n\n## Complexity\n\n时间复杂度:O(N)\n 空间复杂度:O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091902653","body":"## idea\r\n首尾相连，循环 length - (k % length）的次数，利用新尾部打断点。\r\n\r\n## code\r\n```\r\npublic ListNode rotateTRight(ListNode head, int k){\r\n  \r\n  if(head == null || head.next == null || k ==0) return head;\r\n  \r\n  ListNode tem = head;\r\n  int count = 1;\r\n \twhile(tem.next != null){\r\n  \ttem = tem.next;\r\n    count ++ ;\r\n  }\r\n  \t\r\n  \tk = k% count;\r\n  \r\n  if(k == 0) return head;\r\n  \r\n   tem.next =head;\r\n  \r\n  for(i=0; i<count-k; i++){\r\n    \r\n    tem = tem.next;\r\n    \r\n  }\r\n  \r\n  ListNode latestHead = tem.next;\r\n  tem.next = null;\r\n  return latestHead;\r\n  \r\n}\r\n\r\n```\r\n\r\n## Complexity\r\n时间复杂度 O(n)\r\n空间复杂度O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094162872","body":"## idea \n跑两次，相交会出交点的\n\n##Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n     \n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n      \n        while(pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n\n## Complexity\nTime (Max(m,n))\nSpace O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaru-zhang":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085944030","body":"# 思路\r\n- 由于直接循环将数组取出来相加长度可能会超出，所以按倒序取出数组，依次相加取余放进数组\r\n- 可能会出现加完后k值为个位数的情况，所以多加个判断，将剩余数也加入数组\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        n = len(A)\r\n        ans = []\r\n\r\n        for i in range(n-1, -1, -1):\r\n            total = A[i] + K % 10\r\n\r\n            K //= 10\r\n            \r\n            if total >= 10:\r\n                #当前位相加结果大于 10 时，进位 1 加入下一位计算\r\n                K += 1\r\n\r\n            ans.append(total % 10)\r\n            \r\n        # 这里考虑数组 A 的长度小于整数 K 位数个数的情况\r\n        while K > 0:\r\n            ans.append(K % 10)\r\n            K //= 10\r\n        # 因为添加进来是由低位往高位，输出时进行逆序输出\r\n        return ans[::-1]\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086878823","body":"# 思路\r\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n# 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087655547","body":"# 思路\r\n将数字、字母、[一个一个加入到栈中；\r\n如果遇到],就从栈中取出字母，直到遇到[\r\n将[去掉，然后从栈中取出数字（判断是否为数字，因为可能有多个）\r\n重复这些字母\r\n重复以上\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n# 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088709573","body":"# 思路\r\n采用辅助栈\r\n# 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n```\r\n# 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cshowww":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085951022","body":"## 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for(int i=n-1;i>=0;i--){\n            int sum = k%10 + num[i];\n            k = k/10;\n            if(sum >= 10){\n                sum = sum-10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n\n        while(k > 0){\n            res.add(0,k%10);\n            k = k/10;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661223","body":"## 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int prev = Integer.MIN_VALUE/2;\n        int n = s.length();\n        int ans[] = new int[n];\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n        prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(n)\n\n## 思路\n双指针，两次遍历，一次从头到尾，一次从尾到头。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896699","body":"## 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n\n## 复杂度\n时间： O(1)  \n空间： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086899934","body":"## 思路\n使用栈，遇到‘]’弹出元素，对字母和数字分别转成string和int，然后再运算结果压栈。\n\n## 代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }\n            else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();\n\n                stack.pop();\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());\n                }\n                int count = Integer.parseInt(sb.toString());\n\n                while(count > 0){\n                    for(char ch : sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n\n## 复杂度\n空间：O(n)  \n时间：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090433524","body":"## 代码\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n\n```\n\n## 复杂度\n时间、空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091862825","body":"## 思路\n快慢指针\n\n## 代码\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return head;\n        }\n        if(k == 0){\n            return head;\n        }\n        ListNode dummy = head;\n        int len = 0;\n        while(head != null){\n            head = head.next;\n            len++;\n        }\n        int index = k%len;\n\n        ListNode slow = dummy;\n        ListNode fast = dummy;\n        for(int i=0;i<index;i++){\n            fast = fast.next;\n        }\n        ListNode newHead = fast;\n        \n        while(fast.next != null){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        \n        fast.next = dummy;\n        dummy = slow.next;\n        slow.next = null;\n        return dummy;\n       \n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093008712","body":"## 代码：\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094297346","body":"## 代码（以前做过）\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n        while(head1 != head2){\n            head1 = head1==null?headB:head1.next;\n            head2 = head2==null?headA:head2.next;\n        }\n        return head1;\n    }\n}\n```\n\n## 复杂度\n时间：O(A+B)  \n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095210198","body":"## 代码\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode node = findNode(head);\n        if(node == null){\n            return null;\n        }\n\n        int num = 1;\n        \n        for(ListNode cur=node;cur.next!=node;cur=cur.next){\n            num++;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n        for(int i=0;i<num;i++){\n            fast = fast.next;\n        }\n\n        \n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n        \n    }\n\n    public ListNode findNode(ListNode head){\n        if(head==null || head.next==null){\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head.next;\n        \n        while(fast!=null && fast.next!=null){\n            if(fast == slow){\n                return slow;\n            }\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return null;\n    }\n}\n```\n\n## 复杂度\n时间：O(n)  \n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kesucaso":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085955510","body":"#思路\n\nnum数组中的每个数字与k中的对应位置的数字相加，然后如果对应位置相加大于10，则进位到高位的位置上去。\n\n#代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        for i in range(len(num)-1,-1,-1):\n            n = num[i]+k%10\n            k=k//10\n            if n>=10:\n                ans.append(n%10)\n                k+=1\n            else:\n                ans.append(n)\n        while k>=1:\n            ans.append(k%10)\n            k=k//10\n        return ans[::-1]\n```\n\n#复杂度分析\n\n时间复杂度：O(n) （遍历数组）\n\n空间复杂度：O(n) （返回的数组大小）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661051","body":"# 思路\n\n从后往前遍历，遇到等于C的字符就把pre指针置为当前的索引，然后对答案数组进行修改。再从前往后遍历，也是遇到等于C的字符就把pre指针置为当前的索引，对答案数组修改的时候需要对比刚刚已经修改的值和当前赋的值的中选最小值。\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [0]*len(s)\n        pre = float(\"inf\")\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                pre = i\n            ans[i]=pre-i\n        pre = float(\"-inf\")\n        for i in range(len(s)):\n            if s[i]==c:\n                pre = i\n            ans[i]=min(abs(pre-i),ans[i])\n        return ans\n```\n\n# 复杂度分析\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886054","body":"# 思路\n\n因为栈的大小固定，所以可以根据索引方便定位每个元素。简单模拟就行。\n\n# 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            x = self.stack.pop()\n            return x\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i>=len(self.stack):\n                break\n            else:\n                self.stack[i]+=val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087716035","body":"# 思路\n\n使用栈。如果遇到”[“，那就把之前的字符和数字压入栈中，然后将字符置零，任何遇到”]“就把刚刚存在栈里面的字符加上括号里的字符。依次这样做。\n\n# 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        num = 0\n        ans = \"\"\n        for i in s:\n            if i.isdigit():\n                num = num*10+int(i)\n            elif i==\"[\":\n                stack.append([ans,num])\n                # print(stack)\n                ans = \"\" #保存了之后就清零，开始存储括号里面的字符\n                num = 0\n            elif i==\"]\":\n                content = stack.pop()\n                ans = content[0]+content[1]*ans\n            else:\n                ans+=i\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088876125","body":"# 思路\n\n用两个栈来实现队列。一个栈用来push，一个栈用来pop。\n\n# 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.pushstack = []\n        self.popstack = []\n\n    def push(self, x: int) -> None:\n        self.pushstack.append(x)\n\n    def pop(self) -> int:\n        if self.popstack:\n            ans = self.popstack.pop()\n            return ans\n        while self.pushstack:\n            temp = self.pushstack.pop()\n            self.popstack.append(temp)\n\n        return self.popstack.pop()\n\n    def peek(self) -> int:\n        if self.popstack:\n            ans = self.popstack[-1]\n            return ans\n        while self.pushstack:\n            temp = self.pushstack.pop()\n            self.popstack.append(temp)\n\n        return self.popstack[-1]\n\n    def empty(self) -> bool:\n        return self.pushstack==[] and self.popstack==[]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090384711","body":"# 思路\n\n我们需要的是找出每个排序块中的最大值，如果后序元素不存在比当前最大的元素更小的元素，那么当前的元素就可以分块。利用单调栈来存储最大的元素，并且依次弹出更小的元素。\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] #单调栈\n\n        for i in range(len(arr)):\n            if stack and stack[-1]>arr[i]:\n                max_value = stack.pop() #存排序块中最大的数字\n                #如果出现了比当前更小的数字，插入到栈中合适的位置\n                while stack and stack[-1]>arr[i]:\n                    stack.pop()\n                stack.append(max_value)\n            else:\n                stack.append(arr[i])\n        # print(stack)\n        return len(stack)\n```\n\n# 复杂度\n\n时间：O(n)；空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091892018","body":"- 思路\r\n\r\n先统计链表长度，然后对旋转次数取余数。快指针先走K步，然后慢指针一起走，直到快指针走到链表尾部。慢指针的下一个节点就是新的链表头，然后截断连接上去。\r\n\r\n- 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head==None or k==0 or head.next==None:\r\n            return head\r\n        cur = head\r\n        length = 0\r\n        while cur:\r\n            length+=1\r\n            cur = cur.next\r\n        k = k%length\r\n        if k==0: return head\r\n        fast = head\r\n        for i in range(k):\r\n            fast = fast.next\r\n        slow = head\r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        newhead = slow.next\r\n        slow.next=None\r\n        fast.next=head\r\n        return newhead\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092989882","body":"- 思路\n\n非递归地去交换两个节点。新建一个虚拟头结点，然后依次交换虚拟头结点之后的两个节点，\n\n- 代码\n\n```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n\n        dummy = ListNode(-1)\n        dummy.next = head\n        temp = dummy\n        while temp.next!=None and temp.next.next!=None:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n\n        return dummy.next\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072465","body":"- 思路\n\n一个函数找中点，一个函数递归构造左右子树。\n\n- 代码\n\n```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def findMid(left,right):\n            fast,slow = left,left\n            while fast!=right and fast.next!=right:\n                fast=fast.next.next\n                slow=slow.next\n            return slow\n\n        def bulidTree(left,right):\n            if left==right:\n                return None\n          \n            mid = findMid(left,right)\n            root = TreeNode(mid.val)\n            root.left=bulidTree(left,mid)\n            root.right=bulidTree(mid.next,right)\n            return root\n\n        # root = bulidTree(head,None)\n        return bulidTree(head,None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094228554","body":"<aside>\n💡 双指针。如果链表相交，一个长a一个长b，如果两个指针走到链表结尾就又从另一个链表的头开始移动，那么一定会在a+b相遇。\n\n</aside>\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        curA = headA\n        curB = headB\n        while curA!=curB:\n            curA = curA.next if curA!=None else headB\n            curB = curB.next if curB!=None else headA\n        #如果是没有环的话 curA==curB==None 也会退出循环\n        return curA\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095232748","body":"<aside>\n💡 双指针。如果有环，假设环外长度为a，第一次相遇慢指针在环内走了b，快指针走了b+n*(b+c)，所以(a+b)*2=a+b+(b+c)*n，a=n*(b+c)-b=c+(n-1)*(b+c)；所以在第一次相遇之后，将快指针重新指向链表头部，然后和慢指针同步走，相遇的时候则为环开始的节点。\n\n</aside>\n\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = head\n        fast = head\n        while True:\n            if fast==None or fast.next == None:\n                return None\n            slow = slow.next\n            fast = fast.next.next\n            if slow==fast:\n                break\n\n        fast = head\n        while fast!=slow:\n            fast = fast.next\n            slow = slow.next\n\n        return fast\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085957096","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int tmp = 0;\n        for(int i = num.size() - 1; i >= 0; i--){\n            tmp = num[i] + k % 10;\n            k /= 10;\n            if(tmp >= 10){\n                tmp = tmp % 10;\n                k++;\n            }\n            res.push_back(tmp);\n        }\n\n        for( ; k > 0; k/=10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088755614","body":"\n```c++\nclass MyQueue {\nprivate:\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        int top_v = s2.top();\n        s2.pop();\n        return top_v;\n    }\n    \n    int peek() {\n        if(s2.empty()){\n            while(!s1.empty()){\n                int tmp = s1.top();\n                s1.pop();\n                s2.push(tmp);\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085962315","body":"##思路\r\nnum从后向前进行运行，每次都用k和对应位置上数字进行相加，若相加结果大于10，则携带进位前往下一位。\r\n如果num结束后，k中仍然剩余部分数字，直接进行求余即可。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans= new ArrayList<>();\r\n        for(int i=num.length-1;i>=0;i--)\r\n        {\r\n            ans.add(0,(num[i]+k)%10);\r\n            k=(k+num[i])/10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            ans.add(0,k%10);\r\n            k=k/10;\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n##复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092934604","body":"**代码**\r\n```\r\npublic ListNode swapPairs(ListNode head) {\r\n         ListNode dummy = new ListNode();  // 哨兵节点\r\n        dummy.next = head;\r\n        ListNode cur = dummy;\r\n        while (cur.next != null && cur.next.next != null) {\r\n            ListNode node1 = cur.next;\r\n            ListNode node2 = cur.next.next;\r\n            cur.next = node2;\r\n            node1.next = node2.next;\r\n            node2.next = node1;\r\n            cur = node1;\r\n        }\r\n        return dummy.next;\r\n    }\r\n```\r\n**复杂度**\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094265311","body":"**思路**\r\n利用set集合中的数据都是唯一的特性，将其中一个链表加入到set中，另一个链表进行遍历，如果set中存在相同的地址则说明存在交点\r\n**代码**\r\n```Java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A=headA;\r\n        ListNode B=headB;\r\n        HashSet<ListNode> set=new HashSet<>();\r\n        while (A!=null)\r\n        {\r\n            set.add(A);\r\n            A=A.next;\r\n        }\r\n        while (B!=null)\r\n        {\r\n            if(set.contains(B))\r\n            {\r\n                return B;\r\n            }\r\n            B=B.next;\r\n        }\r\n        return null;\r\n    }\r\n```\r\n**复杂度**\r\n+ 时间复杂度 \b\bO(n)\r\n+ 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095006917","body":"**思路**\n将Listnode加入到list中，当Listnode为空后，在list中进行查找如果可以查找相同的结点则说明有环。\n**代码**\n```java\npublic ListNode detectCycle(ListNode head) {\n        if(head==null)\n        {\n            return null;\n        }\n        List<ListNode> node=new ArrayList<>();\n        ListNode temp=head;\n        while(temp!=null && node.contains(temp)!=true)\n        {\n            node.add(temp);\n            temp=temp.next;\n        }\n        for(int i=0;i<node.size();i++)\n        {\n            if(node.get(i)==temp)\n            {\n                return temp;\n            }\n        }\n        return null;\n    }\n```\n**复杂度**\n+ 时间复杂度O(n)\n+ 空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085969554","body":"**Thoughts**\nAdding up by digits.\nIn the array, we start from the last element.\nFor the integer k, each time we use the last digit (k % 10),\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\n\n**Code**\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n               k += 1;\n               sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Time Complexity**\nTime: O(N), one for loop\nSpace: O(1), use one arraylist as result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086529915","body":"**Thoughts**\n1. Get all indices of c, go through s to compare i with indices of c\n2. Traverse s from left side and right side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\n\n**Code**\n```jave\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        ArrayList<Integer> list = new ArrayList<>();\n        int[] res = new int[n];\n        int p = 0; \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\n                p++;\n            }\n            res[i] = Math.abs(list.get(p) - i);\n        }\n        return res;\n    }\n```\n**Time Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767250","body":"**Thoughts**\n\nUse an array to simulate the stack, top var to record the index of the top value\nAlso, use another array to record the value needed to be added. Addition only happens with Popping, if PoP() is called, we start from the top value, add stack\\[top] with add\\[top], then we add the val in add\\[top] to the previous one add\\[top - 1], make sure the index in two array are  consistent\n\n**Code**\n```java\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        add = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int ret = stack[top] + add[top];\n        if (top != 0) {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0; \n        top--;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k - 1, top);\n        if (limit >= 0) {\n            add[limit] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**Complexity**\nTime: O(1) for all operations\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086926037","body":"**Thoughts**\n1. Using two stacks to record the number and characters\n2. Traversing s, when it's number(digit), push(c);\n\t\t\twhen it's `[`, save current sb to stack;\n\t\t\twhen it's `]`, do the multiplication;\n\t\t\twhen it's char, append to sb\n\t\t\t\n**Code**\n```java\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        Deque<Integer> stack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        for (Character c: s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                stack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = sbStack.pop();\n                int count = stack.pop();\n                for (int i = 0; i < count; i++) {\n                    tmp.append(sb.toString());\n                }\n                sb = tmp;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087854700","body":"**Thoughts**\nUsing two stacks to stimulate the FIFO sequence, one var to record the front element of the queue\n\n**Code**\n```java\nclass MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}\n```\n**Complexity**\n* Time: O(1), Push and Pop are constant time\n* Space: O(1) no extra space used","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090286989","body":"**Thoughts**\n\nIf the element in the array is greater then it's following elements, then it's the start of the chunk. So the problem turns into finding such \"start\" of chunks. Use a stack, each time we compare one number with the top of the stack, if !stack.isEmpty() && num < top, we remove the number in the stack which is < num\n\n**Code**\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        for (int num: arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**Complexity**\nTime: O(n)\nSpace: O(n) number of chunks","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091884729","body":"**Thoughts**\n\n1. traverse the list to locate tail of the list\n2. find the node to be the new head\n3. connect the tail and head to make the list a ring\n4. depart the ring at the new head\n\n**Code**\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || k == 0) {\n            return head;\n        }\n        int n = 0;\n        ListNode tail = null, tmp = head;\n        // to get the length of list, and locate tail node\n        while (tmp = null) {\n            tail = tmp;\n            n++;\n            tmp = tmp.next;\n        }\n        k %= n; // in case k > n\n        ListNode p = head;\n        // locate (n - k)th node \n        for (int i = 0; i < n - k - 1; i++) {\n            p = p.next;\n        }\n        // create a ring, then depart it at p.next, which is the new head\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092862412","body":"**Thoughts**\nUsing dummy head, and keep swapping every two nodes\n\n**Code**\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        while (pre.next != null && pre.next.next != null) {\n            ListNode start = pre.next;\n            ListNode end = pre.next.next;\n            pre.next = end;\n            start.next = end.next;\n            end.next = start;\n            pre = start;\n        }\n        return dummy.next;\n    }\n```\n\n**Complexity**\nTime: O(n)\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093664992","body":"**Thoughts**\n\nSplit the linkedlist intor three parts:\n* the mid node, which will be the root of tree\n* the left part, will be left subtree\n* the right part, will be right subtree\nUse fast and slow pointers to locate the mid point(root), use recursion to genarate left and right subtrees\n\n**Code**\n\n```java\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        } else if (head.next == null) {\n            return new TreeNode(head.val);\n        }\n\n        ListNode fast = head;\n        ListNode slow = head;\n        ListNode pre = slow;\n        while (fast != null && fast.next != null) {\n            pre = slow; // pre is the previous node of slow\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.right = sortedListToBST(slow.next);\n        slow.next = null;\n        pre.next = null;\n        root.left = sortedListToBST(head);\n        return root;\n    }\n```\n\n**Complexity**\n\n* Time: O(nlogn), each level traverse n/2, logn is the height of tree\n* Space: O(logN), height of the tree","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094284355","body":"**Code**\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return headA == null ? headB : headA;\n        }\n        ListNode pa = headA, pb = headB;\n        while (pa != pb) {\n            pa = pa == null ? headB : pa.next;\n            pb = pb == null ? headA : pb.next;\n        }\n        return pa;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095050636","body":"**Thoughts**\n\nThis is a problem based on judging if a list has cycle, so the first half part would be the same by using fast and slow pointer. If cycle exists, fast pointer will meet slow finally.\n\nSo when fast meet slow, the position is the start of cycle. Use another pointer points to head, and start a loop, when pointer catch slow, return.\n\n**Code**\n```java\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n```\n\n**Complexity**\n* Time:O(n)\n* Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"antmup":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085970492","body":"### 思路\n1、首先将数组转换为对应的数字；\n2、将两个数字相加；\n3、将最终的数字拆解为数组；\n\n### 代码\n\n``` js\nfunction intSumOfArray(initNumArray, Addend) {\n  // 第一步\n  const initNum = +initNumArray.join('');\n\n  // 第二步\n  const tempSum = String(initNum + Addend);\n  console.log(tempSum, 'tempSum');\n  // 第三步\n  return  tempSum.split('').map(Number);\n}\n\nconsole.log(intSumOfArray([1, 2, 0, 0], 34));\nconsole.log(intSumOfArray([2, 7, 4], 181));\nconsole.log(intSumOfArray([2, 1, 5], 806));\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086651757","body":"### 思路\n1、首先找到字符在数组中的下标数组；\n2、先处理第一个字符之前的，以及最后一个字符之后；\n3、如果当前元素等于目标字符，在数组中 push 0；\n4、处理两个字符中间的距离问题；\n\n### 代码\n\n``` js\nfunction beelineOfCharacter(targetString, targetCharacter) {\n  // 判断目标字符是否处在数组字符串的末尾\n  const isEnd = targetString[targetString.length - 1] === targetCharacter;\n  console.log(isEnd);\n\n  // 寻找目标字符在数组当中的位置\n  let targetCharIndex = [];\n  for (let i = 0; i < targetString.length; i++) {\n    if (targetString[i] === targetCharacter) {\n      targetCharIndex.push(i);\n    }\n  }\n  console.log(targetCharIndex, 'targetCharIndex');\n\n  let finalArray = [];\n  for (let j = 0; j < targetString.length; j ++) {\n    const item = targetString[j];\n    console.log(targetString[j], '1111');\n    // 等于目标元素就push0\n    if (item === targetCharacter) {\n      finalArray.push(0);\n    }\n\n    // 处理第一个目标字符之前的元素\n    const firstCharIndex = targetCharIndex[0];\n    if (j < firstCharIndex) {\n      const tempArray = numberToIndex(firstCharIndex);\n      finalArray.concat(tempArray);\n    }\n    \n  }\n  \n}\n\nfunction numberToIndex(number) {\n  let indexArray = [];\n  for (let i = 0; i < number; i++) {\n    indexArray.unshift(i);\n  }\n  indexArray.pop()\n\n  return indexArray;\n}\n\n\nbeelineOfCharacter('acd', 'c')\n\n```\n\n** 复杂度分析 **\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090945410","body":"### 思路\n1、首先判断当前的链表长度是否为1，如果是1，直接返回表头就好；\n  2、获取链表的长度；\n  3、制造快慢指针\n\n### 代码\n\n``` js\nfunction fastSlowPointer(head, k) {\n  /*\n    1、判断链表的长度和 k 值是否合法\n  */\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  // 获取链表的长度\n  let linkedListLength = 0;\n  let now = head;\n  while (now) {\n    now = now.next;\n    linkedListLength ++;\n  }\n\n  // 当前的 k 值获取的是链表的第几位\n  k = k % linkedListLength;\n\n  // 制造快慢指针\n  let slow = (fast = head);\n  while(fast.next) {\n    if (k-- <= 0) {\n      // 慢指针\n      slow = slow.next;\n    }\n    // 快指针\n    fast = fast.next;\n  }\n\n  // 开始查数\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  \n  return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092314887","body":"### 思路\n1、保证两个节点的交换；\n  2、其余节点的交换两两进行；\n\n### 代码\n``` js\nfunction swapPairs(head) {\n  // 当链表为空或者链表只有一个元素的时候，直接返回该链表\n  if (!head || !head.next) {\n    return head;\n  }\n\n  // 准备循环的素材\n  let res = head.next;\n  let now = head;\n  let preNode = new ListNode();\n  preNode.next = head;\n\n  while(now && now.next) {\n    // 创建第二个节点和尾节点\n    let secondNode = now.next;\n    let tailNode = secondNode.next;\n\n    // 两个节点两两交换\n    now.next = tailNode;\n    secondNode.next = now;\n    preNode.next = secondNode;\n\n    // 创建下一次循环的条件 ～ 前置节点\n    preNode = now;\n    now = tailNode;\n  }\n  \n  return res;\n}\n\n```\n** 复杂度 **\n- 时间复杂度：只遍历了一遍链表，O(N);\n- 空间复杂度：借用了一个pre节点，常量级的O(1);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085972190","body":"## idea\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(max(len(num), digit(k))\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646210","body":"## idea\n左右遍历数组\n## code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n## complexity\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874987","body":"## idea\n数组实现栈\n## code\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n## complexity\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087174643","body":"## 辅助栈\n解码顺序是由内向外，先解码里面的括号再解码外面的括号，而遍历字符串是先遇到外面的括号再遇到里面的括号，符合栈先进后出原则，需要用到两个辅助栈multiStack、resStack，一个由存字符串，一个存数字，两个变量mutil、res存储将要存进栈的元素，则遍历思路为：\n1. 遇到 \\[ 将multi、res存进栈待用，变量重置\n2. 遇到 \\] 从multiStack获取解码倍数，从resStack获取解码字符串的前缀，得到的解码字符串 tmp = resStack.pop() + res * multiStack.pop()，再将解码字符串存储在res中\n3. 遇到数字，作为multi的最低位 \n4. 遇到其他，添加到res的尾部\n5. 遍历结束后res，即最终解码字符串就是答案\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> resStack = new LinkedList<>();\n        Deque<Integer> multiStack = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '[') {\n                multiStack.push(multi);\n                multi = 0;\n                resStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (ch == ']') {\n                StringBuilder tmp = new StringBuilder();\n                tmp.append(resStack.pop());\n                int curMulti = multiStack.pop();\n                for (int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = tmp;\n            } else if (Character.isDigit(ch)) {\n                multi = multi * 10 + ch - '0';\n            } else {\n                res.append(ch);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n## 复杂度\n- 时间：O(len(s))\n- 空间：栈空间，O(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088293928","body":"## idea\n双辅助栈实现队列\n## code\n```java\nclass MyQueue {\n    Deque<Integer> pushStack = new LinkedList<>();\n    Deque<Integer> popStack = new LinkedList<>();\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n## complexity\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090428939","body":"## 计数\n遍历数组，若和有序数组expect计数相同，则说明此时可分块，res++\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int res = 0;\n        int nonzero = 0;\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i], y = expect[i];\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (nonzero == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n## 复杂度\n- O(nlogn)，排序\n- O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091728051","body":"## 链表操作\n先遍历链表，得到链表尾tail和链表长度len，若k % len == 0说明移动的长度为链表长度的倍数，即不移动直接返回head，否则尾节点连接头节点，新尾节点离旧头节点len - k % len - 1，找到新尾节点newTail，则新头节点newHead = newTail.next，并断开尾节点后的连接newTail.next = null，返回新头节点\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        int len = 1;\n        ListNode tail = head;\n        while (tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        k %= len;\n        if (k == 0) {\n            return head;\n        }\n        tail.next = head;\n        ListNode newTail = head;\n        for (int i = 0; i < k; i++) {\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        return newHead;\n    }\n}\n```\n## 复杂度\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092410760","body":"## 链表操作\n创建哑节点dummy指向head，令pre = dummy，每次交换pre后两个节点one和two，然后令pre = one，即将交换后的第二个节点作为下一轮循环的pre\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        while (pre.next != null && pre.next.next != null) {\n            ListNode one = pre.next;\n            ListNode two = pre.next.next;\n            pre.next = two;\n            one.next = two.next;\n            two.next = one;\n            pre = one;\n        }\n        return dummy.next;\n    }\n}\n```\n## 复杂度\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093664914","body":"## 二分 or 快慢指针\n递归找中点作为根节点创建二叉树，有两种方式：\n1. 数组二分，空间换时间\n2. 每次递归都使用快慢指针找中点\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        while (head != null) {\n            list.add(head.val);\n            head = head.next;\n        }\n        return buildTree(0, list.size() - 1, list);\n    }   \n\n    TreeNode buildTree(int left, int right, List<Integer> list) {\n        if (left > right) {\n            return null;\n        }\n        int mid = left + (right - left + 1) / 2;\n        TreeNode root = new TreeNode(list.get(mid));\n        root.left = buildTree(left, mid - 1, list);\n        root.right = buildTree(mid + 1, right, list);\n        return root;\n    }\n}\n```\n- 时间：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094086866","body":"## 双指针\n令pA = headA，pB = headB，遍历直至为null时pA = headB，pB = headA，若相交两个指针将会在交点会合：\n令headA到交点距离为a，headB到交点距离为b，交点到链表尾距离为c，pA或pB遍历各自链表后从另一链表到交点所走过的距离都为a + b + c，所以同时开始遍历的情况下会在交点会合。\n否则遍历至链表尾返回null\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n- 时间：O(n)\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094592985","body":"## 快慢指针\n- slow走一步，fast走两步\n- fast指针走过的长度为 a + b + n(b + c) = a + (n + 1) b + nc\n- slow指针走过的长度为 a + b\n- fast指针走过的长度是slow的两倍\n- a + (n + 1)b + nc  = 2(a + b)\n- a = c  + (n - 1)(b + c)\n- 所以若p指向head，slow指向b和c的交点，同时移动指针则当p走了a距离即走到环入口点时，slow也走过c  + (n - 1)(b + c)即饶了(n - 1)圈后走了c距离也到达换入口点\n\n![](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next == null) {\n                return null;\n            }\n            fast = fast.next.next;\n            if (slow == fast) {\n                ListNode p = head;\n                while (p != slow) {\n                    p = p.next;\n                    slow = slow.next;\n                }\n                return p;\n            }\n        }\n        return null;\n    }\n}\n```\n- 时间：O(n)，slow走过的长度不超过链表总长度\n- 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"webcoder-hk":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085977131","body":"```python\r\n# 都转成整数相加，再转成数组\r\nfrom typing import *\r\nfrom functools import reduce\r\n\r\ndef solution(a:List[int], b:int)->List[int]:\r\n    x = reduce(lambda x,y:x*10+y, a)\r\n    x += b\r\n    result = []\r\n    r = x%10\r\n    x //= 10\r\n    while x or r:\r\n        result.append(r)\r\n        r = x%10\r\n        x //= 10\r\n    result.reverse()\r\n    return result\r\n```\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565255","body":"```python\r\n# 先正向遍历数组标出不等于C得字符，再反向遍历数组利用正向遍历留下得信息算出所需结果。\r\nclass Solution:\r\n    def shortestDistance(self, S:str, C:str)-> List[int]:\r\n        n = len(S)\r\n        result = [0 for _ in range(n)]\r\n        j = 0\r\n        for i in range(n):\r\n            if S[i]!=C:\r\n                j += 1\r\n                result[i] = j\r\n            else:\r\n                j = 0\r\n        j = 0\r\n        for i in range(n-1, -1, -1):\r\n            if S[i] != C:\r\n                j += 1\r\n                if i-result[i]>=0 and result[i-result[i]]==0:\r\n                    result[i] = min(result[i], j)\r\n                else:\r\n                    result[i] = j\r\n            else:\r\n                j = 0\r\n        return result\r\n```\r\ntime: O(2n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086866910","body":"```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.maxSize = maxSize\n        self.data = []\n        \n    def push(self, x):\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n            \n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        else:\n            return -1\n\n    def increment(self, k, v):\n        n = min(len(self.data), k)\n        for i in range(n):\n            self.data[i] += v\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087459907","body":"```python\nclass Solution(object):\n    def decodeString(self, s):\n        stack, res, n = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append((n, res))\n                res, n = \"\", 0\n            elif c == ']':\n                cur_n, last_res = stack.pop()\n                res = last_res + cur_n * res\n            elif '0' <= c <= '9':\n                n = n * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088518859","body":"```python\nclass MyQueue(object):\n    def __init__(self):\n        self.stack = MyStack()\n        self.tmp = MyStack()\n\n    def push(self, x):\n        while self.stack.size()>0:\n            self.tmp.push(self.stack.pop())\n        self.stack.push(x)\n        while self.tmp.size()>0:\n            self.stack.push(self.tmp.pop())\n\n    def pop(self):\n        if self.stack.size()>0:\n            return self.stack.pop()\n\n    def peek(self):\n        if self.stack.size()>0:\n            return self.stack.peek()\n\n    def empty(self):\n        return self.stack.empty()\n    \nclass MyStack(object):\n    def __init__(self):\n        self.data = []\n\n    def push(self, x):\n        self.data.append(x)\n\n    def pop(self):\n        if len(self.data)>0:\n            return self.data.pop()\n            \n    def peek(self):\n        if len(self.data)>0:\n            return self.data[-1]\n\n    def empty(self):\n        return len(self.data)==0\n    \n    def size(self):\n        return len(self.data)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090440309","body":"```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count = collections.Counter()\r\n        counted = []\r\n        for x in arr:\r\n            count[x] += 1\r\n            counted.append((x, count[x]))\r\n\r\n        ans, cur = 0, counted[0]\r\n        for X, Y in zip(counted, sorted(counted)):\r\n            cur = max(cur, X)\r\n            if cur == Y:\r\n                ans += 1\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091411816","body":"```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head is None:\r\n            return None\r\n        p = q = head\r\n        n = 0\r\n        while q.next is not None:\r\n            q = q.next\r\n            n += 1\r\n        for _ in range(n-k%(n+1)):\r\n            p = p.next\r\n        q.next = head\r\n        head = p.next\r\n        p.next = None\r\n        return head\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092471397","body":"```python\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head is None:\n            return None\n        if head.next is None:\n            return head\n        h = head\n        p, q = h, h.next\n        p.next = q.next\n        q.next = p\n        head = q\n        while h.next is not None:\n            p, q = h.next, h.next.next\n            if q is not None:\n                p.next = q.next\n                q.next = p\n                h.next = q\n            h = p\n        return head\n```\ntime: O(n)\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093958519","body":"```python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if head is None:\n            return head\n        d = []\n        node = head\n        while node is not None:\n            d.append(node.val)\n            node = node.next\n        return self.buildTree(d)\n        \n    def buildTree(self, d):\n        if len(d) == 0:\n            return None\n        mid = len(d)//2\n        r = TreeNode(d[mid])\n        r.left = self.buildTree(d[:mid])\n        r.right = self.buildTree(d[mid+1:])\n        return r\n```\ntime: O(n)\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094183925","body":"```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        d = {}\r\n        pa,pb = headA, headB\r\n        while pa is not None:\r\n            d[id(pa)] = pa.val\r\n            pa = pa.next\r\n        while pb is not None:\r\n            if d.get(id(pb)):\r\n                return pb\r\n            pb = pb.next\r\n```\r\ntime: O(n)\r\nspace: O(n)\r\n\r\n```python\r\n# optimized\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p, q = headA, headB\r\n        while p != q:\r\n            if p is None: p = headB\r\n            else: p = p.next\r\n            if q is None: q = headA\r\n            else: q = q.next\r\n        return p\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094611157","body":"```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if head is None or head.next is None: return None\r\n        p,q = head,head.next\r\n        while p != q:\r\n            for _ in range(2):\r\n                if q is None:\r\n                    return None\r\n                q = q.next\r\n            p = p.next\r\n        head2 = p.next\r\n        p.next = None\r\n        p,q = head,head2\r\n        while p != q:\r\n            p = p.next\r\n            q = q.next\r\n            if p is None: p = head2\r\n            if q is None: q = head            \r\n        return p\r\n```\r\ntime: O(n)\r\nspace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1085981416","body":"# Problem [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)\n## Algorithm\n1. Add *k* to each digit of num from the lowest digit.\n2. Then *k%10* is saved to result as the new digit, and *k/10* is used as the new *k* for next digit.\n3. The drawback of this method is if *k* is very close to MAX_VALUE (within 10), then there could be overflow.\n\n## Complexity\n* Time complexity: O(max(num.length, logK))\n* Space complexity: O(max(num.length, logK))\n\n## Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665460","body":"# Problem [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\r\n\r\n## Algorithm\r\n1. Walk through the array from the left to find the closest char c to the right of each char in s.\r\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\r\n3. Find the min distance of step 1 and 2.\r\n4. Step 2 and 3 can be combined.\r\n\r\n## Complexity\r\n* Time Complexity: We are going over the array exactly twice. O(N)\r\n* Space Complexity: We can use the same output array, so no extra space. O(1)\r\n\r\n## Code\r\nLanguage: Java\r\n```Java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] result = new int[n];\r\n        Arrays.fill(result, n);\r\n        // Find closest c on the right of each char\r\n        int cur = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur <= i) {\r\n                result[cur] = i - cur;\r\n                cur++;\r\n            }\r\n        }\r\n\r\n        // Update to get the closest c from both sides by comparing left side\r\n        cur = n - 1;\r\n        for (int i = n - 1; i >=0; i--) {\r\n            if (s.charAt(i) != c) {\r\n                continue;\r\n            }\r\n            while (cur >= i) {\r\n                result[cur] = Math.min(result[cur], cur - i);\r\n                cur--;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891831","body":"# Problem: [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n## Algorithm\n* Use an array to implement ths stack\n* Use *index* to track the current number of elements in the array and the top of the stack.\n\n## Complexity\n* *push* operation time complexity is O(1) since we simply assign one value to the current index of the array.\n* *pop* operation time complexity is O(1).\n* *inc* operation time complexity is O(k) where k is the number of elements to increment.\n* Total space complexity of the stack is O(n) where n is the maxSize.\n\n## Code\nLanguage: Java\n```java\nclass CustomStack {\n    private int[] stack;\n    private int index = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (index == stack.length) {\n            return;\n        }\n        stack[index++] = x;\n    }\n    \n    public int pop() {\n        if (index == 0) {\n            return -1;\n        }    \n        return stack[--index];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k; i++) {\n            if (i + 1 > index) {\n                return;\n            }\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087060502","body":"# Problem [394. Decode String](https://leetcode.com/problems/decode-string/)\n\n## Algorithm\n* Iterate over each character in the string and use a stack to keep track of visited character.\n  1. Keep pushing to the stack until we hit a ']' in string.\n  2. When we hit a ']' in string.\n     1. Keep popping from stack and form a substring until we get a '[' from stack.\n     2. Keep popping digits from stack until it is no longer a digit.\n     3. Convert popped out digits to a multiplier of the substring.\n     4. Decode the substring and push the decoded substring to the stack.\n\n## Complexity\nTime Complexity: O(N) where N is the length of the decoded string.\nSpace Complexity: O(N) where N is the length of the decoded string.\n\n## Code\nLanguage: Java\n\n``` Java\npublic String decodeString(String s) {\n   Deque<Character> stack = new ArrayDeque<>();\n   for (char c : s.toCharArray()) {\n       if (c != ']') {\n           stack.addFirst(c);\n           continue;\n       }\n       List<Character> decodedStr = new ArrayList<>();\n       while (stack.peekFirst() != '[') {\n           decodedStr.add(stack.removeFirst());\n       }\n       // Remove '['\n       stack.removeFirst();\n       \n       // Get multiplier\n       int num = 0;\n       int base = 1;\n       // Important to check if stack is empty first\n       while (!stack.isEmpty() && Character.isDigit(stack.peekFirst())) {\n           // It is very important to keep track of base, as the lower digits may be 0s like \"100\"\n           // Simply using num = num * 10 + stack.removeFirst() - '0' won't work.\n           num = num + (stack.removeFirst() - '0') * base;\n           base *= 10;\n       }\n       \n       // Put decoded string back to stack\n       for (int i = 0; i < num; i++) {\n           for (int j = decodedStr.size() - 1; j >= 0; j--) {\n               stack.addFirst(decodedStr.get(j));\n           }\n       } \n   }\n   char[] result = new char[stack.size()];\n   for (int i = stack.size() - 1; i >= 0; i--) {\n       result[i] = stack.removeFirst();\n   }\n   return new String(result);        \n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088222950","body":"# Problem [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\r\n\r\n## Algorithm\r\n* Use two stacks to implement the queue: inStack and outStack.\r\n* Each element will be first pushed into inStack.\r\n* If outStack is not empty, we will pop from outStack. If outStack is empty, when pop/peek is called on the queue, we pop all elements in inStack and push them to outStack. After this, the head of the queue is at the top of outStack.\r\n\r\n## Complexity\r\n* *push()*: time complexity O(1).\r\n* *pop()*: amortized time complexity O(1). Each element will only be moved from inStack to outStack once with a total time of O(n). If we pop *n* times, the amortized time for each *pop()* is O(1).\r\n* *peek()*: same as *pop()*.\r\n\r\n## Code\r\nLanguage: Java\r\n\r\n``` Java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<>();\r\n        outStack = new ArrayDeque<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.addFirst(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            top();\r\n        }\r\n        return outStack.removeFirst();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            top();\r\n        }\r\n        return outStack.peekFirst();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void top() {\r\n        // move all elements from inStack to outStack\r\n        while (!inStack.isEmpty()) {\r\n            outStack.addFirst(inStack.removeFirst());\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090402046","body":"# Problem [768. Max Chunks To Make Sorted II](https://leetcode.com/problems/max-chunks-to-make-sorted-ii/)\n\n## Algorithm\n* In a valid solution, the max value in the *i* th partition must be less than the min value of the *i+1* th partition.\n* Use a stack to keep track of the max value of each partition.\n* Iterate over the array, if current value is less than the top of the stack, it must be in the same partition as the value at the top of the stack.\n\n## Complexity\n* Time Complexity: We iterate over the array only once. *O(N)*.\n* Space Complexity: A stack is introduced whose max length is *N*. *O(N)*.\n\n## Code\nLanguage: Java\n```Java\npublic int maxChunksToSorted(int[] arr) {\n    Deque<Integer> stack = new LinkedList<>();\n    // Use stack to keep track of the max value of each partition\n    for (int val : arr) {\n        if (stack.isEmpty() || stack.peekFirst() <= val) {\n            stack.addFirst(val);\n        } else {\n            int curMax = stack.peekFirst();\n            while (!stack.isEmpty() && stack.peekFirst() > val) {\n                stack.removeFirst();\n            }\n            stack.addFirst(curMax);\n        }\n    }\n    return stack.size();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091026426","body":"# Problem [61. Rotate List](https://leetcode.com/problems/rotate-list/)\n\n## Algorithm\n* First we find the length and tail of the list. Modulo length by *k* to find the min number of rotation needed.\n* Then traverse the list from head *length-k* nodes, to find the new tail and new head.\n\n## Complexity\n* Time Complexity: We go over the list twice. *O(N)*.\n* Space Complexity: *O(1)*\n\n## Code\nLanguage: Java\n\n``` Java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return head;\n        \n        // first find length and tail\n        ListNode cur = head;\n        int len = 1;\n        while (cur.next != null) {\n            cur = cur.next;\n            len++;\n        }\n        if (k % len == 0) return head;\n        \n        ListNode tail = cur;\n        k = k % len;\n        cur = head;\n        // Find the new tail and head\n        for (int i = 1; i < len - k ; i++) {\n            cur = cur.next;\n        }\n        tail.next = head;\n        head = cur.next;\n        cur.next = null;\n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092832329","body":"# Problem [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/)\n\n## Algorithm\n* We simply need to go over the list and swap each pair of nodes.\n* The key is to also keep track of the previous and next nodes of the pair of nodes.\n\n## Complexity\n* Time Complexity: *O(N)*\n* Space Complexity: *O(1)*\n\n## Code\nLanguage: Java\n``` Java\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode pre = dummy, cur = head;\n        while (cur != null && cur.next != null) {\n            ListNode next = cur.next;\n            ListNode temp = next.next;\n            pre.next = next;\n            next.next = cur;\n            cur.next = temp;\n            pre = cur;\n            cur = temp;\n        }\n        return dummy.next;        \n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrorz0914":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000216","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans= new ArrayList<>();\n        for(int i=num.length-1;i>=0;i--)\n        {\n            ans.add(0,(num[i]+k)%10);\n            k=(k+num[i])/10;\n        }\n        while(k!=0)\n        {\n            ans.add(0,k%10);\n            k=k/10;\n        }\n        return ans;\n    }\n##复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091815050","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode now = head;\n        while(now != null){\n            now = now.next;\n            count++;\n        }\n        k = k % count;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duantao74520":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086000316","body":"### 思路：\n\n小学加法，大于10进一，从个位开始加，将结果塞到数组，最终返回数组时，翻转一下数组。\n\n例如【2,1,5】 与 806\n\n1. 遍历数组，初始化进位为0\n\n   5 + 8 + 0 = 11 ，塞1， 进位1。\n\n   1 + 0 + 1 = 2    ，塞2， 进位0\n\n   2 + 8 + 0 = 10  ，塞0， 进位1\n\n   关键在遍历完数组后，k 有可能为0 ，但是进位可能为1.\n\n2. 特殊处理以上情况\n\n   k += 进位\n\n   这样的话，k为0 ，构造成1， k非0，刚好可以进位\n\n3. 遍历剩余的k，每次除10\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret_vec;\n        int up = 0;\n        // 遍历num\n        for (int pos = num.size() - 1 ; pos >= 0; pos--) {\n            int a = num[pos];\n            int b = k % 10;\n            k = k / 10;\n            ret_vec.emplace_back((a + b + up) % 10);\n            up = (a + b + up) /10;\n        }\n        k = k + up; // 防止有进位 k 还等于0的情况\n        while (k > 0) {\n            ret_vec.emplace_back(k % 10 );\n            k = k /10;\n        }\n         std::reverse(ret_vec.begin(), ret_vec.end());\n         return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n1. 空间复杂度 O(1)\n\n2. 时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086631015","body":"### 思路：\n\n维护两个指针，一个代表着离左边的c的位置，一个代表着离右边的c的位置\n\n遍历数组：\n\n1. 从左往右遍历s1，直到找到c，然后赋值左右c。\n2. 再次从左往右遍历s2，开始记录离左右两边最近的c。\n3. 直到s2遍历到c的位置，继续遍历上一个遍历队列s1,直到数组尽头\n4. 继续遍历s2，输出位置\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n       int c_l = -1, c_r = -1;\n        int i = 0, j = 0;\n        vector<int> ret_vec;\n        while (j < s.size()) {\n            for (i ; i < s.size(); i++) {\n                if (s[i] == c) {\n                    c_l = c_r;\n                    c_r = i;\n                    if (c_l == -1) { // 第一个c\n                        c_l = c_r;\n                    }\n\t\t\t\t\ti++;\n                    break;\n                }\n                if (i == s.size()-1) { // 最后一个c\n                    c_l = c_r;\n                }\n            }\n            for (j ; j < i; j++) {\n                ret_vec.emplace_back(min(abs(j - c_l) , abs(j-c_r)));\n            }\n\t\t\tcout << c_l << c_r << i << j <<endl;\n        }\n        return ret_vec;\n    }\n};\n```\n\n### 复杂度：\n\n时间： o(n)\n\n空间： o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086849106","body":"### 思路：\n\n正常模拟栈的操作，用top代表栈顶，maxSize代表着最大的数组长度\n\n### 代码：\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack =  new vector<int>(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            (*my_stack)[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            top --;\n            return (*my_stack)[top+1];\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++) {\n            (*my_stack)[i] += val;\n        }\n    }\nprivate:\n    vector<int>* my_stack;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n时间： add/top: O(1)  inc:O(N)\n\n空间复杂度： O(N);\n\n### 改进一：\n\n由于只有pop的时候才会取数，那么我们可以存一个add的数组，代表着所有增加的值。\n\n比如：\n\n- 调用了 increment(3, 2)，就把 increment[3] 增加 2。\n- 继续调用 increment(2, 5)，就把 increment[2] 增加 5。\n\n![img](https://tva1.sinaimg.cn/large/0081Kckwly1glwx1ryzxpj31jq0hijte.jpg)\n\n而当我们 pop 的时候：\n\n- 只需要将栈顶元素**加上 increment[cnt - 1]** 即可， 其中 cnt 为栈当前的大小。\n- 另外，我们需要将 increment[cnt - 1] 更新到 increment[cnt - 2]，并将 increment[cnt - 1] 重置为 0。\n\n### 代码：\n\n```\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        my_stack.resize(maxSize);\n        add_vec.resize(maxSize);\n        top = -1;\n        max_size = maxSize;\n    }\n    \n    void push(int x) {\n        if (top < max_size - 1) {\n            top ++;\n            my_stack[top] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if (top >= 0) {\n            // s[top] + add[top]\n            int val = my_stack[top] + add_vec[top];\n            // add[top-1] += add[top]\n            if (top >= 1) {\n                add_vec[top -1] += add_vec[top];\n            }\n            add_vec[top] = 0;\n            top --;\n            return val;\n        } else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k -1, top);\n        if (limit >= 0) {\n            add_vec[limit] += val;  // 只需要记录需要加的数\n        }\n    }\nprivate:\n    vector<int> my_stack;\n    vector<int> add_vec;\n    int max_size;\n    int top;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度：\n\n空间 O(N)\n\n时间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087464857","body":"### 思路：\n\n双指针，用一个指针指向【的后一个， 前面的数字代表的循环的次数，每次从'【'遍历到'】'。\n\n用递归解决多重括号。\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    bool IsWord(const char& c) {\n        return c >= 'a' && c <= 'z';\n    }\n    bool IsNum(const char& c) {\n        return c >= '0' && c <= '9';\n    }\n    string decodeString(string s) {\n        string ret_str;\n        for(size_t i =0 ; i < s.size(); i++) {\n            // 如果是字母直接塞, 循环终止条件\n            if (IsWord(s[i])) {\n                ret_str += s[i];\n                continue;\n            }\n            // 如果是数字，则循环填写\n            int j = i;\n            if (IsNum(s[i])) {\n                int loop_times = s[i] - '0';\n                // 计算遍历次数\n                while(IsNum(s[++j])) {\n                    loop_times = loop_times*10 + (s[j] -'0');\n                }\n                cout << \"loop_times = \" << loop_times << endl;\n                // 找出 【】里面的字母\n                int first_p = j;\n                int num_left_brackets = 1;\n                while(num_left_brackets) {\n                    ++j;\n                    if (s[j] == '[') {\n                        num_left_brackets++;\n                    }\n                    if (s[j] == ']') {\n                        num_left_brackets--;\n                    }\n                }// 退出循环时，j = ]所在的位置\n                cout << \"j = \" << j << endl;\n                // 开始递归遍历\n                for (int k = 0; k < loop_times; k++) {\n                    cout << \"sub_str = \" << s.substr(first_p+1, j-first_p-1) << endl;\n                    ret_str += decodeString(s.substr(first_p+1, j-first_p-1));\n                    cout << \"k = \" << k << endl;\n                    cout << \"ret_str = \" << ret_str << endl;\n                }\n            }\n            i = j; // 防止多塞\n        }\n        return ret_str;\n    }   \n};\n```\n\n### 复杂度：\n\n时间： O(n)\n\n空间： O(1）\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088618574","body":"### 思路：\n\n两个栈，push的时候push到s1， pop的时候从s2出，s2没有的时候，将所有的s1push到s2。\n\n### 代码：\n\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if (s2.empty()) {\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int ret_val = s2.top();\n        s2.pop();\n        return ret_val;\n    }\n    \n    int peek() {\n        if (s2.empty()) {\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n    stack<int> s1 , s2;\n};\n```\n\n复杂度：\n\n空间：O(N)\n\n时间:  O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090345080","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n\n作者：zhouzihong\n链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/c-tu-shi-by-zhouzihong-367n/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091822672","body":"### 思路：\n\n最主要的是要找到倒数第k个节点，涉及到链表的，多想想双指针，快慢指针等。\n\n1. 快慢指针找到第k个节点\n\n2. ​        // a b c d e null\n\n   ​        // d e a b c null\n\n   ​        p_quick->next = head; // e->a\n\n   ​        p_head = p_slow->next; // head->d\n\n   ​        p_slow->next = nullptr; // d->nul\n\n### 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (head == nullptr || head->next == nullptr || k == 0) {\n            return head;\n        }\n        // 获取队列长度\n        int len = 1;\n        ListNode* p_head = head;\n        while(p_head->next != nullptr) {\n            len++;\n            p_head = p_head->next;\n        }\n        k = k %len;\n        \n        // 快慢指针\n        ListNode *p_slow = head, *p_quick = head;\n        while (p_quick->next != nullptr) {\n            if (k <= 0) {\n                p_slow = p_slow->next;\n            }\n            k--;\n            p_quick = p_quick->next;\n        }\n        \n        // a b c d e null\n        // d e a b c null\n        p_quick->next = head; // e->a\n        p_head = p_slow->next; // head->d\n        p_slow->next = nullptr; // d->nul\n        return p_head;\n    }\n};\n```\n\n### 复杂度：\n\n时间： O(N)\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092878240","body":"### 思路：\n\n一定要画图解决。\n\n1. 用哨兵来表示头结点\n2. 结束条件： 当前节点的下一个 和 下下一个都不为空\n\n### 解答：\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 新建一个哨兵节点\n        ListNode org_head;\n        org_head.next = head;\n        ListNode* p_head =  &org_head;\n        // 每次遍历当前节点的后两个节点，直到后面只有一个，或者一个都没有\n        while(p_head->next != nullptr && p_head->next->next != nullptr) {\n            ListNode* node1 = p_head->next , *node2 = p_head->next->next;\n            ListNode* tmp = node2->next;\n            node2->next = node1;\n            node1->next = tmp;\n            p_head->next = node2;\n            p_head = p_head->next->next;\n        }\n        return org_head.next;\n    }\n};\n```\n\n### 复杂度：\n\n时间：O(n)\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094070087","body":"### 思路：\n\n利用递归的方法。\n\n1. 快慢指针找到中点，\n\n   1 2 3 4 5  中点 3\n\n   1 2 3 4 5 6 中点 3\n\n2. 中点的左指针指向 他的左边。  右指针指向右边。\n3. 递归返回值： 返回中间节点。\n4. 递归参数： 头结点，尾结点。\n5. 结束条件： 当前链表全为nullptr的时候\n\n### 代码：\n\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        return getTree(head, nullptr);\n    }\n    TreeNode* getTree(ListNode* head, ListNode* tail) {\n        // 结束条件  \n        if (head == tail) {\n            return nullptr;\n        }\n        // 快慢指针找到中间节点。中间节点= p_slow\n        ListNode *p_slow = head, *p_quick = head;\n        while(p_quick != tail && p_quick->next != tail) {\n            p_slow = p_slow->next;\n            p_quick = p_quick->next->next;\n        }\n        // 创建中间节点\n        TreeNode *t_mid = new TreeNode(p_slow->val);\n        t_mid->left = getTree(head, p_slow);\n        t_mid->right = getTree(p_slow->next, tail);\n        return t_mid;\n    }\n};\n```\n\n### 复杂度：\n\n时间：NLog(N) 每个节点都要遍历，并且都还会有一个二分遍历\n\n空间：LogN 每个二分遍历需要建一个快慢指针","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094199735","body":"### 思路：\n\n两个链表相不相交  一个指针可以从A遍历到尾部，然后又从B遍历到尾部。另一个指针从B遍历到尾部，接着又从A开始。\n\n![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)\n\n即： p_a : 4 1 8 4 5 5 6 1 8(i) 4 5\n\n​\t\tp_b：5 6 1 8 4 5 4 1 8(i) 4 5\n\n相等的点就是相交的点。\n\n遍历结束条件： p_a = null && p_b =null 并且 p_a已经在B分支了\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* p_a = headA, *p_b = headB;\n        bool change_a = false, change_b = false;\n        while (!(p_a == nullptr && p_b == nullptr && change_a && change_b)){\n            // 切换条件\n            if (p_a == nullptr && change_a == false) {\n                change_a = true;\n                p_a = headB;\n            }\n            if (p_b == nullptr && change_b == false) {\n                change_b = true;\n                p_b = headA;\n            }\n            if (p_a == p_b) {\n                return p_b;\n            } else {\n                p_a = p_a->next;\n                p_b = p_b->next;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n\n### 复杂度：\n\n时间： O(N)\n\n空间： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095112003","body":"### 思路：\n\n快慢指针，我们可以在两者第一次相遇（p比s多整数环) 后将快指针放回开头，这样二者再次相遇的点一点是环的入口点，\n\n结束条件： 快指针=null  或者 快慢指针相交。\n\n证明：\n\n![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\nSlow:  3  2  0 -4 2\n\nQuick: 3 0 -4 0  2\n\n设 环的长度为B,前序节点的长度为A;\n\nQ=2S\n\n相遇时 Q= S + nb  n为未知数\n\n相减则 Q = 2nb    S =nb\n\n### 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr){\n            return nullptr;\n        }\n        ListNode *s = head, *p = head;\n        while (p != nullptr && p->next != nullptr) {\n            s = s->next;\n            p = p->next->next;\n            if (p == s) {\n                p = head;\n                while (s != p) {\n                    s = s->next;\n                    p = p->next;\n                }\n                return s;\n            }\n        }\n        return nullptr;\n    }\n};\n```\n\n### 复杂度：\n\n时间 O(N) \n\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"omegalzx":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086006617","body":"~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] num2 = convertNumToArray(k);\n        List<Integer> result = new ArrayList<>();\n        int i = num.length - 1;\n        int j = num2.length - 1;\n        int carry = 0;\n        while (i >= 0 || j >= 0) {\n            int sum = carry;\n            if (i >= 0) {\n                sum += num[i];\n            }\n            if (j >= 0) {\n                sum += num2[j];\n            }\n            result.add(sum % 10);\n            carry = sum / 10;\n            i--;\n            j--;\n        }\n        if (carry > 0) {\n            result.add(carry);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n\n    private int[] convertNumToArray(int num) {\n        List<Integer> result = new LinkedList<>();\n        while (num > 0) {\n            result.add(num % 10);\n            num /= 10;\n        }\n        Collections.reverse(result);\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n~~~\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086682692","body":"~~~java\r\nclass CustomStack {\r\n\r\n    private final int maxSize;\r\n    private final int[] stack;\r\n    private final int[] inc;\r\n    private int top = -1;\r\n    private final int bottom = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n        inc = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top == maxSize - 1) {\r\n            return;\r\n        }\r\n        stack[++top] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (top < bottom) {\r\n            return -1;\r\n        }\r\n        int res = stack[top] + inc[top];\r\n        if (top > bottom) {\r\n            inc[top - 1] += inc[top];\r\n        }\r\n        inc[top] = 0;\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k - 1, top);\r\n        if (i >= bottom) {\r\n            inc[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087645644","body":"~~~java\nint ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++)));\n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuilder t = new StringBuilder();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuilder ret = new StringBuilder();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(List<String> v) {\n        StringBuilder ret = new StringBuilder();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088766445","body":"~~~java\r\nclass MyQueue {\r\n\r\n    private final Stack<Integer> stack1 = new Stack<>();\r\n    private final Stack<Integer> stack2 = new Stack<>();\r\n\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int size = stack2.size();\r\n        if (size == 0) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        int size = stack2.size();\r\n        if (size == 0) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n~~~\r\n- pop O(n)\r\n- peek O(n)\r\n- push O(1)\r\n- empty O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090427467","body":"# 思路\r\n\r\n- 贪心算法\r\n- 对于数组[a0,an]，易得\r\n  - 对于任意的[ai, aj]，当 max(aj+1,an) <= max(ai,aj)，且j>i，则[ai,aj]为排序块\r\n  - 对于任意的[ai, aj]，当max(ai,aj) <= ak，且k>j>i，则[ai,ak]为排序块的子块\r\n\r\n\r\n# 代码\r\n\r\n~~~java\r\npublic int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.peek()) {\r\n                int topValue = stack.pop();\r\n                while (!stack.isEmpty() && num < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(topValue);\r\n            } else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n~~~\r\n\r\n- 时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091757991","body":"~~~java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        // 计算链表长度\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        // 计算目标链表最后一个节点索引\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add-- > 0) {\r\n            iter = iter.next;\r\n        }\r\n        ListNode ret = iter.next;\r\n        // 断开环链表\r\n        iter.next = null;\r\n        return ret;\r\n    }\r\n}\r\n~~~","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072448","body":"~~~java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        List<Integer> list = new ArrayList<>();\r\n        while (head != null) {\r\n            list.add(head.val);\r\n            head = head.next;\r\n        }\r\n        return helper(list, 0, list.size() - 1);\r\n    }\r\n\r\n    private TreeNode helper(List<Integer> list, int start, int end) {\r\n        if (start > end) {\r\n            return null;\r\n        }\r\n        int mid = (start + end) / 2;\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        root.left = helper(list, start, mid - 1);\r\n        root.right = helper(list, mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n~~~","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094276234","body":"~~~java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode p = headA;\r\n        ListNode q = headB;\r\n\r\n        while (p != q) {\r\n            p = p == null ? headB : p.next;\r\n            q = q == null ? headA : q.next;\r\n        }\r\n        return p;\r\n    }\r\n}\r\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vivixu-qiqi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007071","body":"```\r\nvar addToArrayForm = function(num, k) {\r\n    let sum = k;\r\n    let index = num.length - 1;\r\n    let result = '';\r\n    let resultArr = [];\r\n    while(index >= 0 || sum > 0) {\r\n        if(index >= 0) {\r\n            sum += num[index];\r\n        }\r\n        result += sum % 10;\r\n        sum = Math.floor(sum / 10);\r\n        index--;\r\n    }\r\n    for(let i = result.length - 1; i >= 0; i--) {\r\n        resultArr.push(+result[i]);\r\n    }\r\n    return resultArr;\r\n};\r\n```\r\nTime Complexity：O(max(n,logk))\r\nSpace Complexity：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646668","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [];\r\n        for i in range(len(s)):\r\n            if (s[i] == c):\r\n                result.append(0)\r\n                continue\r\n            for left in range(i, -1, -1):\r\n                dist1 = 0\r\n                if (s[left] == c):\r\n                    dist1 = i - left\r\n                    break\r\n            for right in range(i, len(s)):\r\n                dist2 = 0\r\n                if (s[right] == c):\r\n                    dist2 = right - i\r\n                    break\r\n            if (dist1 == 0):\r\n                result.append(dist2)\r\n            if (dist2 == 0):\r\n                result.append(dist1)   \r\n            if (dist1 <= dist2 and dist1 != 0):\r\n                result.append(dist1)\r\n            if (dist1 > dist2 and dist2 != 0):\r\n                result.append(dist2)    \r\n\r\n        return result;\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086874419","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize\r\n  this.size = 0\r\n  this.stack = []\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.size < this.maxSize) {\r\n    this.stack.push(x)\r\n    this.size++\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.size === 0) {\r\n    return -1\r\n  } else {\r\n    this.size--\r\n    return this.stack.pop()\r\n  }\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.size); i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n```\r\nO(1) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087690400","body":"```\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let res = '';\r\n    let i = 0;\r\n\r\n    while (i < s.length) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i++]);\r\n            continue;\r\n        }\r\n\r\n        let str = '', n = '', segment = '';\r\n        while (stack[stack.length-1] !== '[') {\r\n            str = stack.pop() + str;\r\n        }\r\n\r\n        stack.pop();\r\n        while (!isNaN(stack[stack.length-1])) {\r\n            n = stack.pop() + n;\r\n        }\r\n        for (let j = 0; j < Number(n); j++) {\r\n            segment = str + segment;\r\n        }\r\n        stack.push(segment);\r\n        i++;\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088839886","body":"```\r\nvar MyQueue = function() {\r\n    s1 = []\r\n    s2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    s1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(s2.length === 0) while(s1.length != 0) s2.push(s1.pop())\r\n    return s2.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return s2.length === 0 ? s1[0] : s2[s2.length - 1] \r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return s1.length === 0 && s2.length === 0\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090401575","body":"```\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    a = arr[i];\r\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack && stack[stack.length - 1] > a) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(a);\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\nO(n) for time and space complexity","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091773890","body":"```\r\nvar rotateRight = function(head, k) {\r\n    \r\n    let list=head;\r\n    let len=0; \r\n    while(list){list=list.next; len++;}\r\n    \r\n    k=k%len;\r\n    if(k==0 || head===null){return head;}\r\n    \r\n    let index=len-k-1;\r\n    list=head;\r\n    \r\n    while(index){list=list.next; index--;}\r\n    let newNode=list.next;\r\n    list.next=null;\r\n    \r\n    list=newNode;\r\n    while(list.next){list=list.next;}\r\n    list.next=head;\r\n    \r\n    return newNode;\r\n};\r\n```\r\nTime : O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092634980","body":"```\r\nconst swapPairs = function (head) {\r\n\tconst pre = new ListNode(0, head);\r\n\tif (!head || !head.next) {\r\n\t\treturn head;\r\n\t}\r\n\tlet cur = pre;\r\n\tlet nextTwo = null,\r\n\t\tnextOne = null;\r\n\r\n\twhile (cur.next && cur.next.next) {\r\n\t\tnextTwo = cur.next.next;\r\n\t\tnextOne = cur.next;\r\n\t\tcur.next = nextTwo;\r\n\t\tnextOne.next = nextTwo.next;\r\n\t\tnextTwo.next = nextOne;\r\n\r\n\t\tcur = nextOne;\r\n\t}\r\n\treturn pre.next;\r\n};\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094063622","body":"```\r\nvar sortedListToBST = function(head) {\r\n    return toBST(toArray(head))\r\n};\r\n\r\nconst toArray = head => {\r\n    const arr = []\r\n    while (head) {\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n    return arr\r\n}\r\n\r\nconst toBST = (arr, l = 0, r = arr.length) => {\r\n    if (l === r) return null\r\n    const m = Math.floor((l + r) / 2)\r\n    const root = new TreeNode(arr[m])\r\n    root.left = toBST(arr, l, m)\r\n    root.right = toBST(arr, m + 1, r)\r\n    return root\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094301377","body":"```\r\nconst getIntersectionNode = function (headA, headB) {\r\n\tif (!headA || !headB) {\r\n\t\treturn null;\r\n\t}\r\n\tlet curA = headA;\r\n\tlet curB = headB;\r\n\tlet diff = 0;\r\n\tlet lenA = 1;\r\n\tlet lenB = 1;\r\n\tlet result = null;\r\n\twhile (curA.next) {\r\n\t\tcurA = curA.next;\r\n\t\tlenA++;\r\n\t}\r\n\twhile (curB.next) {\r\n\t\tcurB = curB.next;\r\n\t\tlenB++;\r\n\t}\r\n\tcurA = headA;\r\n\tcurB = headB;\r\n\tif (lenA < lenB) {\r\n\t\t[curA, curB] = [curB, curA];\r\n\t\t[lenA, lenB] = [lenB, lenA];\r\n\t}\r\n\tdiff = lenA - lenB;\r\n\twhile (diff-- > 0) {\r\n\t\tcurA = curA.next;\r\n\t}\r\n\twhile (curB) {\r\n\t\tresult = curA === curB ? curA : null; //x先比较当下元素\r\n\t\tif (result === curA) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcurA = curA.next;\r\n\t\tcurB = curB.next;\r\n\t}\r\n\treturn result;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094935010","body":"```\r\nvar detectCycle = function(head) {\r\n   if (!head || !head.next) return null;\r\n\tlet slow = head;\r\n\tlet fast = head;\r\n\tlet meetNode, startIndex;\r\n\twhile (fast && fast.next) {\r\n\t\tslow = slow.next; //慢指针走一步\r\n\t\tfast = fast.next.next; //快指针走两步\r\n\t\tif (slow === fast) { //相遇\r\n\t\t\tmeetNode = slow;\r\n\t\t\tstartIndex = head;\r\n\t\t\twhile (meetNode !== startIndex) { //一个指针在head，另一个指针在相遇点，它们相遇即为起始点\r\n\t\t\t\tmeetNode = meetNode.next;\r\n\t\t\t\tstartIndex = startIndex.next;\r\n\t\t\t}\r\n\t\t\treturn startIndex;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kwdfw":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086007092","body":"Day1\n\n[989、数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n#javascript\n## 思路\n1、类似现实中的加法题，取数组和数字的对应位相加并加上进位\n\n2、若相加和大于9，则用carry记录下进位为1\n\n3、算完一直就输入到数组中一位\n\n4、不断循环，从最后一位一直到第一位\n\n5、反转数组\n\n#### 处理特殊示例\n1、相加的结果比原来的位数多一位，如990+100=1090，需要在循环结束后单独判断再加一位\n\n2、数组的位数比数字的位数少，如0+23，按照循环会造成数组越界，需要加判断条件，越界就将值置为0\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let carry=0//记录进位\n    let ru=[]//最终返回的数组\n    let i=num.length-1//循环计数器\n    let result//每一位的结果\n    while(i>-1||k!=0){//||条件保证任意位数的情况下都可以进入循环\n        const x= i>=0? num[i]:0//解决数组和数字位数不同的问题\n        const y=k!=0 ? k%10:0\n        result=x+y+carry//得到某位的值\n        if(result>9){//若大于9，则保留进位，并输入到数组中\n            carry=1\n            ru.push(result%10)\n        }\n        else{//若小于等于9，则不保留进位，并输入到数组中\n            carry=0\n            ru.push(result)\n        }\n        k=Math.floor(k/10)//下取整，有时会自动进位\n        i--//推进循环\n    }\n    if(carry==1) ru.push(1)//解决相加结果比原来多一位\n    return ru.reverse()//反转数组\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653607","body":"Day2\n\n[821、数组形式的整数加法](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n#javascript\n## 思路\n1、遍历数组\n\n2、对于每个字符都分别向左和右查找c\n\n3、对比左和右的长度，取最小值填入数组中\n\n## 代码\n```javascript\nvar shortestToChar = function(s, c) {\n    var answer=Array(s.length).fill(0);//将数组中填满0\n    for(let i=0;i<s.length;i++){\n      if (s[i] === c) continue;//若该位置与字符相同，则不用管\n      let short=Infinity\n      for(let j=i;j<s.length;j++){\n          if(s[j]===c){\n              short=Math.min(short,j-i)\n              break\n          }\n      }  \n      for(let k=i;k>-1;k--){\n          if(s[k]===c){\n               short=Math.min(short,i-k)\n               break\n          }\n      }\n      answer[i]=short\n    }\n    return answer\n};\n```\n## 复杂度分析\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086894389","body":"Day3\n\n[1381、设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/submissions/)\n\n#javascript\n## 思路\n1、设置一个辅助数组inc\n\n2、调用增量函数的时候，用inc记录增加的数和值\n\n3、执行pop操作的时候，通过inc实现增加的值(利用栈的操作特性，减少了时间复杂度)\n\n## 代码\n```javascript\n/**\n * @param {number} maxSize\n */\nlet increments=[]//记录inc函数的传入值\n\n\nvar CustomStack = function(maxSize) {\n    this.max=maxSize\n    this.stack=[]\n    increments=Array(this.max).fill(0)//把数组的所有元素填满为0\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.max>this.stack.length)\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length==0) return -1\n    else{\n        increments[this.stack.length-2]+=increments[this.stack.length-1]\n        //inc数组的栈顶加到栈顶的下一个\n        const res=increments[this.stack.length-1]+this.stack.pop()\n        //将inc数组的栈顶加到原栈的栈顶\n        increments[this.stack.length]=0\n        //inc数组的栈顶置0\n        return res\n        //注意：stack.length的值一直在变\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k>this.stack.length) increments[this.stack.length-1]+=val\n    //如果栈中元素总数小于k，赋值到inc数组的栈顶\n    else increments[k-1]+=val\n    //对应inc数组的栈加上增加的值\n};\n```\n## 复杂度分析\n时间复杂度：O(1)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087644890","body":"Day4\n\n[394、字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n#javascript #栈\n## 思路\n1、从头到尾遍历字符串\n\n2、数字存入数字的栈中，字符存入字符的栈中\n\n3、出栈时，按照规定对数字和字符进行运算\n\n## 代码\n```javascript\nvar decodeString = function(s) {\n    let arrNum=[],arrStr=[]//定义两个存放的栈\n    let num=0,str=''//定义两个暂存的点\n    for(let n of s){//遍历字符串\n        if(!isNaN(n)){//如果是数字，就存到数字中\n            num=num*10+Number(n)\n        }\n        else if(n=='['){//如果是[，则将数字和字符都压入栈中，并将暂存点清空\n            arrNum.push(num)\n            num=0\n            arrStr.push(str)\n            str=''\n        }\n        else if(n==']'){//如果是]，则将数字和字符都出栈，并做对应的运算\n            str=arrStr.pop()+str.repeat(arrNum.pop())\n        }\n        else{//如果是字符，就存到字符中\n            str+=n\n        }\n    }\n    return str\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088661569","body":"Day5\n\n[232、用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n#javascript #队列\n## 思路\n1、设置两个栈，一个负责入队，一个负责出队，倒换之后刚好符合队列的性质\n\n## 代码\n```javascript\nvar MyQueue = function() {\n    this.arr1=[]//入队的栈\n    this.arr2=[]//出队的栈\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr1.push(x)//入队\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.arr2.length==0){\n        while(this.arr1.length!=0){\n            this.arr2.push(this.arr1.pop())\n        }\n        return this.arr2.pop()\n    }//如果出队的队列没有元素，就把入队的队列都拿过来\n    else return this.arr2.pop()//出队\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.arr2.length==0){\n        while(this.arr1.length!=0){\n            this.arr2.push(this.arr1.pop())\n        }\n        return this.arr2[this.arr2.length-1]\n    }//如果出队的队列没有元素，就把入队的队列都拿过来\n    else return this.arr2[this.arr2.length-1]//返回队头元素，即数组的最后一个元素\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    while(this.arr1.length!=0){\n        this.arr2.push(this.arr1.pop())\n    }//把入队队列全拿过来\n    if(this.arr2.length==0) return true\n    else return false\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089866383","body":"Day6\n\n[768、最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\n\n#javascript #队列\n## 思路\n1、构造一个单调栈\n\n2、使栈始终保持单调递增，碰到递减的情况就清除之前的数，只取最大的数\n\n3、栈中元素的个数就是能划分的排序的最多块数\n\n[题解](https://leetcode-solution.cn/solutionDetail?type=3&id=6&max_id=2)\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    const stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        a = arr[i];\n        if (stack.length > 0 && stack[stack.length - 1] > a) {//如果小于栈顶元素，则需要融合\n            const cur = stack[stack.length - 1];//记录栈顶元素的值\n            while (stack && stack[stack.length - 1] > a) stack.pop();\n            //一直清除栈中元素，直到给的值大于栈顶元素\n            stack.push(cur);\n            //将栈中最大元素放回栈中\n        }\n        else {//如果大于栈顶元素，则入栈\n            stack.push(a);\n        }\n    }\n    return stack.length;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091012211","body":"Day7\n\n[61、旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n#javascript #链表\n## 思路\n1、观察示例可以发现，需要从链表的后边截取一部分放到链表头部\n\n2、需要获取这一部分的头节点和尾节点\n\n3、使用快慢指针来分别获取头节点和尾节点\n\n 4、连接好新链表，并返回头节点\n### 特殊示例处理\n\n1、null链表和链表中只有一个元素，直接返回原头指针\n\n2、k或者rLength=0，则代表不用动链表，直接返回原头指针\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n    if(head==null) return null//头结点为空\n    if(head.next==null) return head//链表中只有一个节点\n    let p=head//保留头结点位置\n    let rLength=0//记录链表长度\n    while(p!=null){\n        p=p.next\n        rLength++\n    }\n    rLength=k%rLength//移动的位置大于长度时，会发生重复移动没有意义\n    if(rLength==0) return head//算完后发现不需要移动\n    let slow=head,fast=head//定义快慢指针，快指针指原链表尾，慢指针指新链表尾\n    while(fast.next!=null){\n        if(rLength--<=0) slow=slow.next\n        fast=fast.next\n    }\n    let q=slow.next\n    slow.next=null\n    fast.next=head\n    head=q\n    return head\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092367317","body":"Day8\n\n[24、两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n#javascript #链表\n## 思路1 迭代\n1、遍历链表，每次走两步\n\n2、需要获取四个节点才可以完成两两交换，获取对应的四个节点的位置\n\n3、 把四个节点按要求指向对应的节点\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if(head==null||head.next==null) return head//处理特殊示例\n    let p1=new ListNode(),p2=head,p3=p2.next,p4=p3.next\n    //给p1赋一个虚拟节点来处理头结点，这样可以将第一次交换放到循环里执行\n    p1.next=p2\n    head=p2.next//记录最后要返回的头结点\n    while(true){\n      p1.next=p3\n      p3.next=p2\n      p2.next=p4\n      //完成两两交换\n      if(p2.next==null||p4.next==null) break\n      //分成奇数个和偶数个节点两种情况，分别对应一个退出循环的方法\n      p1=p1.next\n      p1=p1.next\n      p2=p1.next\n      p3=p2.next\n      p4=p3.next\n      //所有节点向后走两步\n    }\n    return head\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n## 思路2 递归\n1、需要四个节点,p1,p2,p3,p4，做三次指向步骤，才能完成两两交换\n\n2、递归的返回值是下一次的p1也是这一次的p4\n\n3、递归到链表尾会返回空值，结束递归\n\n## 代码\n```javascript\nvar swapPairs = function(head) {\n    if(head==null||head.next==null) return head//处理特殊示例\n    let nextNode=head.next//nextNode为3号节点，head为2号节点\n    head.next=swapPairs(nextNode.next)//2号节点指向4号节点，同时完成了下一次操作的1号节点指向3号节点\n    nextNode.next=head//3号节点指向2号节点\n    return nextNode\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094067880","body":"Day9\n\n[109、有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n#javascript #树 #链表\n1、二叉搜索树要求左子树必须小于父节点，右子树必须大于父节点\n\n2、获取中间节点的位置，并且分别向左右两侧找左子树和右子树\n\n3、 递归调用\n\n## 代码\n```javascript\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }//快慢指针分别获取链表的中间位置和末尾位置\n  let root = new TreeNode(slow.val);//中间位置设为根节点\n  root.left = dfs(head, slow);//选择中间位置左边的节点的中间位置作为左子节点\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```\n## 复杂度分析\n时间复杂度：O(nlogn)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094155674","body":"Day10\n\n[160、相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n#javascript #链表\n## 思路\n1、使用两个指针分别遍历链表，但是两个链表长度不同，无法相交\n\n2、遍历到链表尾后，交换两个链表的位置，刚好能够补上之前差的位置，节点相交的位置就是链表相交的位置\n\n3、返回节点的位置\n\n## 代码\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n    let a=headA,b=headB\n    while(a!=b){//两个节点相等时，退出循环\n        a= a==null? headB:a.next//a到链表尾时，换到B链表上\n        b= b==null? headA:b.next//b到链表尾时，换到A链表上\n    }//如果两个链表无相交节点，则一轮之后，a==b==null，返回null\n    return a\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095040446","body":"Day11\n\n[142、环形链表](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\n\n#javascript #链表\n## 思路1：哈希表\n1、遍历链表，并记录链表中的所有值\n\n2、遇到相同的值就返回当前节点\n\n3、遍历完成后，仍没有相同的值，就返回null\n\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    let mySet=new Set()//建立一个哈希表\n    while(head){//不是环，就遍历一遍\n        if(mySet.has(head)) return head//如果在表中查到相同的元素，则返回该元素\n        mySet.add(head)//如果表中没有相同的元素，则添加该元素至表中\n        head=head.next//遍历\n    }\n    return null//无环，则返回null\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n## 思路2：快慢指针\n1、设置快慢指针，快指针一次走两步，慢指针一次走一步\n\n2、两指针相遇时，慢指针不变，快指针回到头结点，改为一次走一步\n\n3、当第二次相遇时，节点位置为入环节点\n\n[题解](https://leetcode-solution.cn/solutionDetail?type=3&id=11&max_id=2)\n\n## 代码\n```javascript\nvar detectCycle = function(head) {\n    if(!head||!head.next) return null\n    let slow=head,fast=head\n    do {\n        if (fast != null && fast.next != null) {//处理特殊示例\n            fast = fast.next.next;\n        }\n        else {\n            return null\n        }\n        slow = slow.next;\n    } while (fast != slow);\n    //两个指针第一次相遇时，退出循环\n    fast=head\n    while(slow!=fast){\n        slow=slow.next\n        fast=fast.next\n    }\n    //两个指针第二次相遇时，得到入环节点\n    return slow\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086012990","body":"### lc989 数组形式的整数加法\n\n#### 解法一\n\n##### 思路\n\n+ 先将数组翻转\n+ 在将 k 全部加在数组最后一位上\n+ 计算数组最后一位的进位，并作为下一次运算的 k\n+ 直到 k 为 0 且 数组遍历完成\n+ 最后将数组重新翻转\n\n##### 代码实现\n\n~~~ c++\nclass Solution1 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        reverse(num.begin(), num.end());\n\n        for (int i = 0; i < len; i++) {\n            num[i] += k;\n            k = num[i] / 10;\n            num[i] %= 10;\n        }\n\n        while (k > 0) {\n            num.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)\n\n\n\n#### 解法二\n\n##### 思路\n\n+ 将数组和 k 逐位相加\n+ 计算进位，并加在 k 的下一位上\n+ 直到 k 为 0 且数组遍历完成\n\n##### 代码实现\n\n~~~ c++\nclass Solution2 {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size();\n        vector<int> result;\n\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum > 9) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n        while (k > 0) {\n            result.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n~~~\n\n##### 复杂度\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086018719","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res= new ArrayList<Integer>();\n       Integer n = num.length;\n       for(int i = n-1 ;i>=0||k>0;--i,k/=10)\n       {\n           if(i>=0)\n           {\n               k+=num[i];\n           }\n           res.add(k%10);\n       }\n       Collections.reverse(res);\n        return res;\n    }\n}\n\n思路：将整个加数 k 加入数组表示的数的最低位。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086664444","body":"### 【Day 2】821. 字符的最短距离\n#### 思路：分别比较左边和右边距离最近的值，取最小。\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pre = -10000; //最大数据范围是10000\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) { //计算左段与c最近的距离\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = i - pre;\n        }\n        pre = 10000;\n        for (int i = s.length() - 1; i >= 0; i--) { //计算右段与c最近的距离,同时与之前记录的左段进行比较\n            if (s.charAt(i) == c) pre = i;\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n###\n时间复杂度：O(N)O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。\n空间复杂度：O(N)O(N)，ans 数组的大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897344","body":"### 【Day 3】1381. 设计一个支持增量操作的栈\n方法1：模拟\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087116500","body":"### 【Day 4】394. 字符串解码\n####  思路：构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n当 c 为字母时，在 res 尾部添加 c；\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n进入到新 [ 后，res 和 multi 重新记录。\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n返回字符串 res。\n\n```\npublic String decodeString(String s) {\n        // 思路: 乘法和 递推公式 前一个和作为下一个加法的加数\n        // 3[a]2[bc] = 3a+2bc = (3a + \"\") + 2bc\n        // 3[a2[c]] = 3(2c + a) = 3(2c + a) + \"\"\n        \n        // 1. 初始化倍数和res 及其对应栈\n        int multi = 0;\n        StringBuilder res = new StringBuilder();\n        Deque<Integer> multi_stack = new LinkedList<>();\n        Deque<String> res_stack = new LinkedList<>();\n\n        // 2. 遍历字符\n        char[] chars = s.toCharArray();\n        for (char ch : chars) {\n            // 3. 统计倍数\n           //只有在碰到'['时才会入栈。比如'12[a]',初始状态muti=0；c='1'，muti=0*10+1=1;c='2',muti=1*10+2=12;c='[',muti=12入栈，然后muti=0.\n            if (ch >= '0' && ch <= '9')\n                multi = multi * 10 + (ch - '0');\n            // 4. 统计res\n            else if (ch >= 'a' && ch <= 'z') \n                res.append(ch);\n            // 5. 入栈并重置临时变量\n            else if (ch == '[') {\n                multi_stack.push(multi);\n                res_stack.push(res.toString());\n                // 重置开始下一轮重新统计\n                multi = 0;\n                res = new StringBuilder();\n            // 6. 出栈做字符串乘法和加法\n            } else {\n                int cur_multi = multi_stack.pop();\n                StringBuilder temp = new StringBuilder();\n                // 乘以当前统计字符串res\n                for (int i = 0; i < cur_multi; i++)\n                    temp.append(res);\n                // 加上前一个统计字符串作为当前res\n                res = new StringBuilder(res_stack.pop() + temp);\n            }\n        }\n        return res.toString();\n    }\n```\n####\n时间复杂度 O(N)O(N)，一次遍历 s；\n空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088812452","body":"## 【Day 5】232. 用栈实现队列\n```\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n```\n## 复杂度分析\n\n时间复杂度：O(1)。\n\n空间复杂度：O(n)。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091664885","body":"### 【Day 7】61. 旋转链表\n思路：记给定链表的长度为 nn，注意到当向右移动的次数 k \\geq nk≥n 时，我们仅需要向右移动 k \\bmod nkmodn 次即可。因为每 nn 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k \\bmod n)(n−1)−(kmodn) 个节点（从 00 开始计数）。\n这样，我们可以先将给定的链表连接成环，然后将指定位置断开。\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        //算出链表的长度\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n       //找到断开的位置\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n       //移动链表\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n复杂度分析\n\n时间复杂度：O(n)O(n)，最坏情况下，我们需要遍历该链表两次。\n空间复杂度：O(1)O(1)，我们只需要常数的空间存储若干变量。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086021602","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sums = 0\n        for i,j in enumerate(num):\n            sums += j*10**(len(num)-i-1)\n        sums += k\n        ans = []\n        while sums:\n            temp = sums %10\n            sums = sums//10\n            ans.insert(0,temp)\n        return ans\n            \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086548738","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        dic = []\n        for i,j in enumerate(s):\n            if j == c:\n                dic.append(i)\n        ans = []\n        \n        for i in range(len(s)):\n            temp = []\n            for j in dic:\n                temp.append(abs(j-i))\n            ans.append(min(temp))\n        return ans\n```\n                \n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086898887","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            #self.stack.insert(0,x)\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<=k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            for i in range(k):\n                self.stack[i] += val\n        \n```      ","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092304824","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        if not head.next:\n            return head\n        prehead = ListNode(0)\n        ans = prehead\n        while head and head.next:\n            temp = head.next.next\n            nexts = head.next\n            nexts.next = head\n            prehead.next = nexts\n            head.next = temp\n            ##important\n            prehead = head\n            head= temp\n        return ans.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093321806","body":"```\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre ,slow , quick = None,head,head\n\n        while quick and quick.next:\n            pre = slow\n            slow = slow.next\n            quick = quick.next.next\n        #print(pre==head)\n        if pre:\n            pre.next = None\n        a = TreeNode(slow.val)\n        if quick == slow:\n            return a\n        \n        a.left = self.sortedListToBST(head)\n        a.right = self.sortedListToBST(slow.next)\n        return a\n        \n```      ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094185505","body":"\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        a = headA\n        b = headB\n        lena = 0\n        lenb = 0\n        while a:\n            a = a.next\n            lena +=1\n        while b:\n            b = b.next\n            lenb +=1\n        \n        a = headB\n        b= headA\n        if lena >=lenb:\n            step = lena-lenb\n            for i in range(step):\n                b = b.next\n        else:\n            step = lenb-lena\n            for i in range(step):\n                a = a.next\n        while a:\n            if a == b:\n                return a\n            a= a.next\n            b = b.next\n        return None\n        \n```  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lskong":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022222","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n\n        vector<int> res;\n        res.reserve(A.size() + 5);\n\n        int i = A.size() - 1;\n        int carry = 0;\n\n        while (i >= 0 || K > 0)\n        {\n            int n1 = i >= 0 ? A.at(i) : 0;\n            int n2 = K > 0 ? K % 10 : 0;\n            int sum = n1 + n2 + carry;\n            carry = sum / 10;\n            res.push_back(sum % 10);\n            --i;\n            K /= 10;\n        }\n\n        if (carry)\n        {\n            res.push_back(1);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086585016","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> pos;\n        vector<int> res;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                pos.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.size(); i++) {\n            int tmp = 100000000000000;\n            for(int j = 0; j < pos.size(); j++) {\n                tmp =min(tmp, abs(i -pos[j]));\n            }\n            res.push_back(tmp);\n        } \n    return res;\n    }\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092431857","body":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      if(head == nullptr || head->next== nullptr) {\n          return head;\n      }\n      ListNode* first = head;\n      ListNode* second = head->next;\n      head = second;\n      first->next = swapPairs(second->next);\n      second->next =first;\n      return head;\n\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mapo0102":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086022435","body":"思路：\n创建一个链表，获取数组长度\n逆序从最低位开始，进行链表的加和。\n完成加和后，判断k值是否完成，如果未完成，继续向链表头部加k值，然后k/10，消耗尽k的所有位数。\n\n代码：\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int n = num.length;\n\n        for (int i = n - 1; i >= 0 ; i--) {\n            int sum = k%10 + num[i];\n            k = k / 10;\n            if(sum >= 10){\n                sum -= 10;\n                k++;\n            }\n            res.add(0,sum);\n        }\n        while(k>0){\n            res.add(0,k%10);\n            k=k/10;\n        }\n        return res;\n    }\n\n    }\n\n\n复杂度：\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646897","body":"思路：\n首先先从左向右遍历一遍，将ans数组中的所有元素标志成对应位。\n再从右往左遍历一遍，再比较大小，将ans对应位置中更小的数放入对应ans。\n\n代码：\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086913613","body":"思路：将数字和char先压入栈中，把字符一个个压入栈中，遇到]符号就执行循环赋值操作。\n代码：class Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n\n                while(!stack.isEmpty() && stack.peek() != '['){\n                    sb.insert(0,stack.pop());\n                }\n\n                String sub = sb.toString();//获得一个[]的字段\n\n                stack.pop();//去掉[\n\n                sb = new StringBuilder();//清理掉sb当前的内容\n\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0,stack.pop());//获得[]前的系数\n                }\n\n                int count = Integer.parseInt(sb.toString());\n            \n                while(count > 0){\n                    for(char ch:sub.toCharArray()){\n                        stack.push(ch);\n                    }\n                    count--;//将一整个重复的字符串压入栈中\n            }\n        }\n    }\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0,stack.pop());\n        }\n        return res.toString();\n    }\n}\n\n复杂度：\n空间复杂度：O(n)\n时间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086024431","body":"### 思路\n\n数组num转换为字符串与k相加后再转换为List\n\n### 代码\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tostr = ''.join([str(i) for i in num])\n        res = str(int(tostr)+ k)\n        reslist = [int(i) for i in res]\n        return reslist\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，其中 n 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086897297","body":"\n### 代码\n\n\n```\nclass CustomStack {\n    int[] stack;\n    int size;\n    int[] increment;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        increment = new int[maxSize + 1];\n        size = 0;\n    }\n    \n    public void push(int x) {\n        if(size == stack.length){\n            return;\n        }\n        stack[size++] = x;\n    }\n    \n    public int pop() {\n        if(size == 0){\n            return -1;\n        }\n        int res = stack[size - 1];\n        if(increment[size] != 0){\n            res += increment[size];\n            increment[size - 1] += increment[size];\n            increment[size] = 0;\n        }\n        size--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        increment[Math.min(k, size)] += val;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxSize)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088736837","body":"### 思路\n【Day 5】232. 用栈实现队列\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n使用双栈\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1=new Stack<>();\n        stack2=new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty())\n                stack2.push(stack1.pop());\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if(stack2.isEmpty()){\n            while(!stack1.isEmpty()){\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090427059","body":"### 思路\n768-https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n官方题解\n排序后第k个，一定大于等于前k个数，找到这个最小k，然后重复\n\n### 代码\n```java（\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.Counter()\n        counted = []\n        for x in arr:\n            count[x] += 1\n            counted.append((x, count[x]))\n\n        ans, cur = 0, None\n        for X, Y in zip(counted, sorted(counted)):\n            cur = max(cur, X)\n            if cur == Y:\n                ans += 1\n        return ans\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094069086","body":"### 思路\n\nleetcode 109 \nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/109-you-xu-lian-biao-zhuan-huan-er-cha-s-lzlb/\n链表转成数组\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (null==head) {\n            return null;\n        }\n        List<Integer> nums = new ArrayList<>();\n        while (null!=head) {\n            nums.add( head.val );\n            head = head.next;\n        }\n        return toBst(nums,0, nums.size()-1);\n    }\n\n    private TreeNode toBst( List<Integer> nums, int left, int right ) {\n        if (left>right) {\n            return null;\n        }\n        int middle = left + (right - left)/2;\n        TreeNode root = new TreeNode(nums.get( middle ));\n        root.left = toBst( nums,left,middle-1 );\n        root.right = toBst( nums,middle+1,right );\n        return root;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oneline-wsq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086026979","body":"### 思路\n\n将num数组计算为一个数，然后再与k相加，最后再返回数组。\n\n### 代码\n\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        sum1=0\n        n=len(num)\n        for i in range(n):\n            sum1=sum1+pow(10,n-i-1)*num[i]\n\n        sum2=sum1+k\n\n        return [int(x) for x in str(sum2)]\n```\n\n### 复杂度分析\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086597093","body":"### 思路\n\n首先在s中找到所有等于c的索引；再从0开始循环，计算与索引集合相减绝对值最小的值。\n\n### 代码\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n\n        ans=[]\n        # 首先找出所有的c的索引\n        tmp=[]\n        k=0\n        for i in s:\n            if i==c:\n                tmp.append(k)\n            k+=1\n        \n        for i in range(len(s)):\n            tmp2=[abs(j-i)for j in tmp]\n            ans.append(min(tmp2))\n\n        return ans\n```\n\n### 复杂度分析\n\n时间复杂度：O(n*m)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086844229","body":"### 思路\n\n用python的list实现。\n\n### 代码\n\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize=maxSize\n        self.stack=[]\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack)<self.maxsize:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack)==0:\n            return -1\n        else:\n            ans=self.stack[-1]\n            self.stack=self.stack[0:-1]\n            return ans\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        n=len(self.stack)\n        addn=min(k,n)\n        for i in range(addn):\n            self.stack[i]=self.stack[i]+val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087073420","body":"### 思路\n利用栈来实现\n### 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # 本题的核心思路是在栈里面每次存储两个信息：（左括号前的字符串，左括号前的数字）\n        stack=[] # (str,int)记录左括号之前的字符串和左括号外的上一个数字\n        num=0\n        res=\"\" # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num=num*10+int(c)\n            elif c==\"[\":\n                stack.append((res,num))\n                res,num=\"\",0\n            elif c==\"]\":\n                top=stack.pop()\n                res=top[0]+res*top[1]\n            else:\n                res+=c\n        return res\n```\n### 复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088586552","body":"# ****[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)****\n\n### 思路\n\n### 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.data=list()\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n\n        return self.data.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        pdata=self.data[0]\n        self.data=self.data[1:]\n        return pdata\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n        return self.data[0]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.data)==0:\n            return True\n        else:\n            return False\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度分析\n\n时间复杂度： O(1)\n\n空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089757686","body":"### 思路\n\n遍历arr，压入tmp栈中，如果tmp中的所有值小于后面未遍历到的所有值的最小值，则证明可以在此划分为1个块，tmp清空，否则，继续。\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        \n        k=0\n        tmp=[]\n        for i,element in enumerate(arr[:-1]):\n            max_bh=max(arr[i+1:])\n            min_bh=min(arr[i+1:])\n            tmp.append(element)\n            if max(tmp)<=min_bh:\n                k=k+1\n                tmp=[]\n\n        k=k+1\n        return k\n```\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092641023","body":"### 思路\n\n利用递归，两两交换元素，返回交换后的头节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\ndef e2(head): # 交换两个元素，并返回head值\n    p1=head\n    if p1:\n        p2=head.next\n    else:\n        p2=None\n\n    if p1!=None and p2!=None:\n        p1.next=e2(p2.next)\n        p2.next=p1\n    elif p1!=None and p2==None:\n        return p1\n    return p2\n\nclass Solution:\n\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if head==None or head.next==None:\n            return head\n\n        p1=head\n        p2=head.next\n        p3=p2 # 最终返回\n\n        e2(p1)\n\n        return p3\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093808703","body":"### 思路\n\n先将链表转为list，再进行迭代。\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        \n        if not head:\n            return None\n        # 先计算出链表的长度\n        p1=head\n        n=0.0\n        data=[]\n        while p1:\n            data.append(p1.val) # 将数据存到list中\n            p1=p1.next \n            n+=1\n        \n\n        def buildT(arr):\n            nn=float(len(arr))\n            mm=int(nn/2+0.5)\n\n            if nn<=0:\n                return None\n\n            mnode=TreeNode(val=arr[mm-1])\n            mnode.left=buildT(arr[0:mm-1])\n            mnode.right=buildT(arr[mm:int(nn)])\n\n            return mnode    \n\n        return buildT(data)\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094163583","body":"### 思路1：循环遍历两个链表\n\n先固定指向链表1的指针，遍历链表2，遍历结束没有，则指向下一个节点。\n\npython，最后计算超时\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        p1=headA\n        p2=headB\n        while p1:\n            while p2:\n                if p1!=p2:\n                    p2=p2.next\n                else:\n                    return p2\n            if not p2:\n                p2=headB\n            p1=p1.next\n\n        return None\n```\n\n### 复杂度分析\n\n时间复杂度：O(m*n)\n\n空间复杂度：O(1)\n\n### 思路2-双指针\n\n一个指针先遍历A，再遍历B；\n\n另一个指针先遍历B，再遍历A，到达交点的时候，走过的路径相同。\n\n### 代码：\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        \"\"\"参考：双指针\"\"\"\n        A,B =headA,headB\n        while A!=B:\n            A=A.next if A else headB\n            # 这一行的逻辑是：\n            # if A非空，则A=A.next 否则A=headB\n            B=B.next if B else headA\n        return A\n```\n\n### 复杂度分析：\n\n时间复杂度：O(m+n)\n\n空间复杂度：O(1)\n\n\n### 思路3-哈希表\n\n先将其中一个链表存到哈希表中，此时再遍历另外一个链表查找重复节点\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        \"\"\"参考：哈希表\"\"\"\n        s=set()\n        p,q=headA,headB\n        while p:\n            s.add(p)\n            p=p.next\n        while q:\n            if q in s:\n                return q\n            q=q.next\n\n        return None\n```\n\n### 复杂度分析：\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094499151","body":"### 思路\n\n哈希表\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        \n        # 将遍历到的所有放入set中\n        tmp=set()\n        p1=head\n        pos=-1\n\n        while p1:\n            pos+=1\n            if p1 in tmp:\n                return p1\n            tmp.add(p1)\n            p1=p1.next\n        return None\n```\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuguang520-lab":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037440","body":"##思路\n模拟加法运算，注意将数组反转\n\n##code\n```cpp\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {//判断是否有进位\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);//判断k是否比数组的长度要长\n        }\n        reverse(res.begin(), res.end());\n        return res;\n```\n##复杂度分析\n- 实践复杂度O(n)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646031","body":"#思路\n使用的是暴力解法没有使用官方的前后遍历所以时间复杂度和空间复杂度比较高\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result;\n        vector<int > index;\n        int len = s.length();\n        for(int i = 0; i< len; i++)\n        {\n            if(s.at(i) == c)//将字符串转换成字符在进行比较\n            {\n                index.push_back(i);\n            }\n        }\n        int len_index = index.size();\n        for(int i = 0; i < len; i++)\n        {\n            int dis_min = len;//初始化为len\n            for(int j =0; j<len_index; j++)\n            {\n                dis_min = min(abs(i-index[j]),dis_min);\n            }\n            result.push_back(dis_min);\n        }\n    return result;\n    }\n};\n```\n#复杂度分析\n- 时间复杂度O(cN) c表示c字符出现的数量，n为字符串的长度\n-空间复杂度O(2N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086816450","body":"# 思路\n使用数组模拟栈的用法，定义一个容量，栈顶和栈底就很容易实现\n# code\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        element = new int[maxSize];\n        top_stack = -1;\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if(top_stack == maxsize - 1)\n        {\n            return;//超过容量，不进行操作\n        }\n        element[++top_stack] = x;\n    }\n    \n    int pop() {\n        if(top_stack < 0)\n        {\n            return -1;\n        }\n        return element[top_stack--];\n    }\n    \n    void increment(int k, int val) {\n        if(top_stack < k - 1) //按照最短长度进行累加\n        {\n            for(int i = 0; i <= top_stack; i++)\n            {\n                element[i] += val;\n            }\n        }\n        else\n        {\n            for(int i = 0; i < k; i++)\n            {\n                element[i] +=val;\n            }\n        }\n    }\nprivate:\n    int* element;//数组\n    int top_stack;//栈顶\n    int maxsize;//最大容量\n};\n```\n# 时间复杂度分析\n- 空间复杂度O(N)\n\n- 时间复杂度O(N) 利用了一个数组进行模拟","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088440527","body":"# 思路\n利用两个栈来实现队列的功能，一个栈用来接受输入，一个栈接受是输出，如果输出栈没有数字了就从输入栈中添加\n# code\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1_input.push(x);\n    }\n    \n    int pop() {\n        if(s1_input.size() == 0 &&s2_output.size() == 0)\n        {//判断队列中是否有元素\n            exit(0);\n        }\n        if(!s2_output.empty())//输出栈有元素就直接从输出栈输出\n        {\n            int i = s2_output.top();\n            s2_output.pop();\n            return i;\n        }\n        else\n        {\n            while(!s1_input.empty())\n            {\n                s2_output.push(s1_input.top());\n                s1_input.pop();\n            }\n            int i = s2_output.top();\n            s2_output.pop();\n            return i;\n        }\n    }\n    \n    int peek() {//和pop函数一样，少了删除\n        if(s1_input.size() == 0 &&s2_output.size() == 0)\n        {\n            exit(0);\n        }\n        if(!s2_output.empty())\n        {\n            int i = s2_output.top();\n            return i;\n        }\n        else\n        {\n            while(!s1_input.empty())\n            {\n                s2_output.push(s1_input.top());\n                s1_input.pop();\n            }\n            int i = s2_output.top();\n            return i;\n        }\n    }\n    \n    bool empty() {\n        return (s1_input.empty() && s2_output.empty());\n    }\nprivate:\n    stack<int> s1_input;\n    stack<int> s2_output;\n};\n```\n# 复杂度分析\n- 时间复杂度 O（1）\n- 空间复杂度O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090393004","body":"# 思路\n使用滑动窗口来解决\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n# 复杂度分析\n- 时间复杂度O(nlogn)\n- 空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091880599","body":"# 思路\n使用闭合环\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter->next = head;\n        while (add--) {\n            iter = iter->next;\n        }\n        ListNode* ret = iter->next;\n        iter->next = nullptr;\n        return ret;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(n)\n- 空间复杂度O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092445362","body":"# 思路\n增加一个空节点使对于头节点的操作和其余节点的操做一样\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr||head->next == nullptr )\n        {\n            return head;\n        }\n        ListNode* pre_head = new ListNode;//创建空节点使头节点的操作和另外节点的操作统一\n        pre_head->next = head;\n        ListNode* tem = pre_head;\n        while(tem->next !=nullptr&&tem->next->next !=nullptr)\n        {\n            ListNode* first = tem->next;\n            ListNode* last = tem->next->next;\n\n            first->next = last->next;\n            last->next = first;\n            tem->next = last;\n            tem = first;\n        }\n        return pre_head->next;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093967886","body":"# 思路\n使用快慢指针找出中点所在的位置，将其作为节点建树\n```cpp\nclass Solution {\npublic:\n    ListNode* getMedian(ListNode* left, ListNode* right) {\n        ListNode* fast = left;\n        ListNode* slow = left;\n        while (fast != right && fast->next != right) {\n            fast = fast->next;\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\n        if (left == right) {\n            return nullptr;\n        }\n        ListNode* mid = getMedian(left, right);\n        TreeNode* root = new TreeNode(mid->val);\n        root->left = buildTree(left, mid);\n        root->right = buildTree(mid->next, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        return buildTree(head, nullptr);\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(nlogn)\n- 时间复杂度O(logn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094743683","body":"# 思路\n采用快慢指针法，先找出相遇的点在哪里，然后将slow指针重新开始，fast指针从相遇的点开始但是速度要和slow一致，在下次他们相遇的点处就是循环入口出\n# code\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        if(head == nullptr||head->next==nullptr||head->next->next==nullptr)\n            return NULL;\n        //找出相遇点slow\n        while(fast->next!=nullptr && fast->next->next!= nullptr)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            if(slow == fast)\n            {\n                slow = head;\n                while(slow != fast)//以相同的速度前进，相遇的点就是循环开始点\n                {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                return slow;\n            }\n        }\n        return slow == fast?slow:NULL;\n    }\n};\n```\n# 复杂度分析\n- 时间复杂度O(N)\n- 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086037807","body":"# 思路：两次遍历，两次转换\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        array_num = 0\n        for i in range(n):\n            array_num += num[i] * (10 ** (n-i-1))\n        total = array_num + k\n        ans = []\n        for s in str(total):\n            ans.append(int(s))\n        return ans \n```\n时间复杂度:O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086594925","body":"#思路:笨蛋解法，第一次遍历找位置，第二次遍历求距离最小值\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        position = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n\n        for i in range(len(s)):\n            dis = []\n            for p in position:\n                dis.append(abs(i-p))\n            ans.append(min(dis))\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087688854","body":"# 思路：遍历字符串，遇到]之前一直入栈，遇到[之后出栈，找到重复的字符和次数后再入栈。最后栈内就是最终结果\n```python \nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for item in s :\n            if  item == ']':\n                repeatstr = ''\n                repeatcount = ''\n                while stack and stack[-1] != '[':\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatcount = stack.pop() + repeatcount\n                stack.append(repeatstr * int(repeatcount))\n            else:\n                stack.append(item)\n        ans = ''.join(stack)\n        return ans\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088657357","body":"# 思路：\n在push 的时候将先入队的元素放到后面\n```pyhon\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack =[]\n        self.aux_stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        while self.stack:\n            self.aux_stack.append(self.stack.pop())\n        self.aux_stack.append(x)\n        while self.aux_stack:\n            self.stack.append(self.aux_stack.pop())\n    \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack.pop()\n        \n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        return self.stack[-1] \n        \n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stack) == 0:\n            return True\n        else:\n            return False\n\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090389244","body":"# 思路：计数，如果两个数组计数信息一致，那么排序信息一致\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n时间复杂度：O(n**2）\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091854719","body":"# 思路\n快慢指针找到倒数第k个结点，然后改变指针的指向\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 找到倒数第k个结点\n        if head:\n            p1,p2 = head,head\n            count = 1\n            i = 0\n            while i<k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n    \n        while p2.next:\n            p1 = p1.next\n            p2 = p2.next\n        if p1.next:\n            tmp =p1.next\n        else:\n            return head\n        p1.next =None # 倒数第k+1个\n        p2.next = head # 倒数第k个\n        return tmp\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094258014","body":"# 思路：\n双指针法，走到头就从另外一条链表的头开始，相遇位置就是相交位置\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a,b = headA,headB\n        while a!=b:\n            if a:\n                a = a.next\n            else:\n                 a = headB\n            if b:\n                b = b.next\n            else:\n                b = headA\n        return a\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruceleeqaq":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086039762","body":"思路:  模拟加法，先将数组转换成数字 再将结果转换为数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\ti = len(num)-1\n        while k:\n            num[i] += k\n            k, num[i] = num[i]//10, num[i]%10\n            i -= 1\n            if i<0 and k:\n                num.insert(0,0)\n                i = 0 \n        return num\n\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661332","body":"\n\n```class Solution:\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n        class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        c_pos, ans = [], []\n        for idx, i in enumerate(s):\n            if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans    if i == c:\n                c_pos.append(idx)\n        \n        p = 0\n        for i in range(len(s)):\n            if i < c_pos[0]:\n                ans.append(c_pos[0] - i)\n            elif i > c_pos[-1]:\n                ans.append(i - c_pos[-1])\n            elif i == c_pos[p]:\n                ans.append(0)\n                p += 1\n            else:\n                ans.append(min(c_pos[p] - i, i - c_pos[p-1]))\n        return ans\n```\n\n复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895082","body":"\n\n```python\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n```\n\n复杂度\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088767021","body":"\nclass MyQueue:\n\n    def __init__(self):\n        self.L = []\n\n    def push(self, x: int) -> None:\n        self.L.append(x)\n\n    def pop(self) -> int:\n        print(self.L)\n        return self.L.pop(0)\n\n    def peek(self) -> int:\n        return self.L[0]\n\n\n    def empty(self) -> bool:\n        if(len(self.L) == 0):\n            return True\n        else:\n            return False\n\n### 复杂度\n\n时间：O(1)\n\n空间：O(N)\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093009328","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # 创建头结点\n        cur = ListNode(0)\n        cur.next = head\n        \n        first = cur\n        while cur.next and cur.next.next:\n            n1 = cur.next\n            n2 = n1.next\n            n3 = n2.next\n            \n            cur.next = n2\n            n2.next = n1\n            n1.next = n3\n            \n            cur = n1\n        return first.next\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094068320","body":"class Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (nullptr == head) return nullptr;\n        return getTree(head, nullptr);\n    }\n    TreeNode* getTree(ListNode* startPtr, ListNode* endPtr){\n        if (startPtr == endPtr) return nullptr;\n        ListNode* lowPtr = startPtr;\n        ListNode* fastPtr = startPtr;\n        while(endPtr != fastPtr && endPtr != fastPtr->next){\n            lowPtr = lowPtr->next;\n            fastPtr = fastPtr->next->next;\n        }\n        TreeNode* root = new TreeNode(lowPtr->val);\n        root->left = getTree(startPtr,lowPtr);\n        root->right = getTree(lowPtr->next,endPtr);\n        return root;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086041856","body":"## 思路\n从最低位想相加开始计算起\n\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n## 复杂度\ntime O(N)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086660724","body":"## 思路\n左右遍历 问题在于初始的c位置怎么算,算到数组中间好了\n对于prev\n因为如果不除以2的话，INT_MIN= -2^31，而刚开始的时候i-INT_MIN=i+2^31就会发生溢出，但是INT_MAX-i就不会发生溢出了，所以INT_MAX就没必要除以2了，为了看起来舒服点都除以2了\n```\nclass Solution {\npublic:\n   vector<int> shortestToChar(string S, char C) {\n       vector<int> distance(S.size(), 0);\n       int prev = INT_MIN/2;\n       for(int i = 0; i < S.size(); i ++){\n           if(S[i] == C) prev = i;\n           distance[i] = i - prev;\n       }\n       prev = INT_MAX/2;\n       for(int i = S.size() - 1; i >= 0; i --){\n           if(S[i] == C) prev = i;\n           distance[i] = min(distance[i], prev - i);\n       }\n       return distance;\n   }\n};\n```\n## 复杂度\n时空O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087668469","body":"# idea\n multiStack for num\n'['  将当前结果串resultStr 与 multi 的值进行入栈操作；\n']'，进行出栈操作 同时复制相应的倍数加入尾部\n```cpp\nclass Solution {\n    public:\n    string decodeString(string s) {\n        std::stack<int> multiStack;\n        std::stack<string> stringStack;\n        string resultStr;\n        int curMulti = 0;\n\n        for (int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            if(c == '[') {\n                multiStack.push(curMulti);\n                stringStack.push(resultStr);\n                curMulti = 0;\n                resultStr.clear();\n            }\n            else if(c == ']') {\n                int tmp = multiStack.top();\n                multiStack.pop();\n                string tmpStr;\n                for( int i = 0; i < tmp; i++ ) {\n                    tmpStr.append(resultStr);\n                }\n                resultStr = (stringStack.top() +tmpStr);\n                stringStack.pop();\n\n            }\n            else if (c >='0' && c <= '9') {\n                curMulti = curMulti* 10 + (c-'0');\n            }\n            else {\n                resultStr.append({c});\n            }\n        }\n        return resultStr;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091868256","body":"## idea\nfast slow pointer be careful with that head->next == NULL\nand the k id bigger than the length of the LinkList\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        ListNode* fast;\n        ListNode* slow;\n        \n        if (k == 0||head==NULL||head->next == NULL) return head;\n         slow = head;\n         fast = head;\n         int n = 1;\n        ListNode* iter = head;\n        while (iter->next != nullptr) {\n            iter = iter->next;\n            n++;\n        }\n\n\n         k = k % n;// ring \n        while (k > 0) {\n            fast = fast->next;\n            k--;\n       }\n       \n       while (fast->next != NULL) {\n           fast = fast->next;\n           slow = slow->next;\n       }\n       fast->next = head;\n       ListNode* cur = slow->next;\n       slow->next = NULL;\n       return cur;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093015599","body":"# idea\nsave the prev pointer as well as the prehead\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (nullptr == head || nullptr == head->next) return head;\n        ListNode* preHead = new ListNode(-1,head);\n        ListNode* tmpPtr = preHead;\n        ListNode *cur = preHead->next;\n        while (nullptr != cur && nullptr != cur->next){\n            ListNode *second = cur->next;\n            cur->next = second->next;\n            second->next = cur;\n            tmpPtr->next = second;\n            tmpPtr = cur;\n            cur = cur->next;\n        }\n        return preHead->next;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094280660","body":"## idea\nAB链表相接,继续走总能走到\n```cpp\nif (headA == nullptr || headB == nullptr) return nullptr;\n\nListNode *pA = headA;\nListNode *pB = headB;\nwhile (pA != pB) {\n    pA = pA ==nullptr ? headB : pA->next;\n    pB = pB == nullptr ? headA : pB->next;\n}\nreturn pB;","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086054479","body":"思路在注释里\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        // 初始化参数\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n\n        // 1. 从后往前逐位相加\n        for(int i = n - 1;i >= 0;i--){\n            // 1.1 逐位相加\n            int sum = A[i] + K % 10;         // 每次重置sum\n            K /= 10;    \n            // 1.2 处理两位相加 进位的情况\n            if(sum >= 10){\n                K++;                        // 进位到K的末尾\n                sum -= 10;                  // 进位清掉\n            }\n            // 1.2 当前相加的结果 添加到结果集\n            res.add(sum);\n        }\n\n        // 2. K的数字长度大于数组的数字长度\n        for(;K > 0;K /= 10){                // 每次K左移一位\n            res.add(K % 10);                // 添加到结果集\n        }\n\n        // 3. 将结果集翻转即是所求答案\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n复杂度\n空间：O(N)\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663042","body":"思路：\r\n从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右想做遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n```\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n```\r\n复杂度\r\n时间复杂度：O(N)，其中 N 是 S 的长度，我们需要遍历字符串两次。\r\n空间复杂度：O(N)，ans 数组的大小。","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092885103","body":" 思路:\n设置工作坐标temp，令node1=temp.next;node2=temp.next.next;当node1和node2，不为null时，交换node1和node2 的链接顺序，并让temp跳到node1，重复执行\n\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n      ListNode dummpyHead=new ListNode(0);\n      dummpyHead.next=head;\n      ListNode temp=dummpyHead;\n      while(temp.next!=null&&temp.next.next!=null){\n        ListNode node1=temp.next;\n        ListNode node2=temp.next.next;\n          node1.next=node2.next;\n          node2.next=node1;\n          temp.next=node2;\n          temp=node1;\n      }\n      return dummpyHead.next;\n     \n    }\n}\n```\n\n复杂度\n空间 O(N)\n时间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houyanlu":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086055675","body":"### 思路\n\n从最低位开始跟k的个位相加，大于10则进一位，\n\n\n### 代码\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> result;\n        int n = num.size();\n\n        // 从个位开始跟k的个位相加，大于10则进一位\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            result.push_back(sum);\n        }\n\n        // 最后剩下的k， 说明k是比原数组很大很大，应该是放在加和后的高位\n        for (; k > 0; k /= 10) {\n            result.push_back(k % 10);\n        }\n\n        std::reverse(result.begin(), result.end());\n\n        return result;\n    }\n};\n\n**复杂度分析**\n- 时间复杂度：O(N)，一次遍历\n- 空间复杂度：O(N) 同等大小的一个vector","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086646499","body":"### 思路\n\n先从后往前遍历一遍，\n再从前往后遍历一遍，查漏补缺以及比较出最近的值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int length = s.length();\n        vector<int> resultVector(length, -1);\n\n        int preIndex = -1;\n\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.at(i) == c) {\n                preIndex = i;\n                resultVector[i] = 0;\n            }\n\n            if (preIndex != -1) {\n                resultVector[i] = preIndex - i;        \n            }\n\n        }\n\n        preIndex = -1;\n        for (int i = 0; i < length; i++) {\n            if (s.at(i) == c) {\n                preIndex = i;\n            } else if (resultVector.at(i) == -1 && preIndex != -1) {\n                 resultVector[i] = i - preIndex;        \n            } else if (resultVector.at(i) != -1 && preIndex != -1) {\n                resultVector[i] = std::min(i - preIndex, resultVector[i]);\n            }\n        }\n\n        return resultVector;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086895800","body":"### 思路\n\n使用数组模拟栈，用一个变量 m_topIndex 来记录当前栈顶的位置.\n\npush 操作，先判断是否到达栈顶，没有就 m_topIndex 自增1，数组的相应位置 赋值。\n\npop 操作，先判断是否为空，空返回−1， 否则m_topIndex 自减后返回自减前位置的值。\n\ninc 操作，直接对栈底的最多 k 个元素加上 val。\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        m_vector.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (m_topIndex != m_vector.size() - 1) {\n            m_topIndex++;\n            m_vector[m_topIndex] = x; \n        }\n\n        \n        \n    }\n    \n    int pop() {\n        if (m_topIndex == -1) {\n            return -1;\n        }\n\n        m_topIndex--;\n        return m_vector[m_topIndex + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = std::min(k, m_topIndex + 1);\n\n        for (int i = 0; i < limit; i++) {\n            m_vector[i] += val;\n        }\n    }\n\nprivate:\n    vector<int> m_vector;\n    int m_topIndex {-1};\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n- 时间复杂度：因为数组支持随机访问，push和pop都是O(1), inc是O(k)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087624824","body":"### 思路\n\n因为需要从里到外的展开[]对，需要增加一个辅助栈 **multiStack** 用于存储紧挨着[ 的倍数\n每当遇到左方括号时，将当前结果串**resultStr** 与 **multi** 的值进行入栈操作；\n当遇到右方括号时，进行出栈操作\n\n#### 代码实现\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        std::stack<int>  multiStack;   // \n        std::stack<string> strignStack;\n        string resultStr;\n        int curMulti = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s[i];\n            if (c == '[') { \n                // 如果是“[”, 先存放当前记录的次数和字符串入辅助栈, 再清空两者的值\n                multiStack.push(curMulti);\n                strignStack.push(resultStr);\n                curMulti = 0;\n                resultStr.clear();\n            } else if (c == ']') {\n                // 取出次数，说明需要重复栈顶记录次数的resultStr,也就是这个数字后跟着的[]之间的字符\n                int tmp = multiStack.top();\n                multiStack.pop();\n                string tmpStr;\n                for (int i = 0; i < tmp; i++) {\n                    tmpStr.append(resultStr);\n                }\n                resultStr = (strignStack.top() + tmpStr);\n                strignStack.pop();\n            } else if (c >= '0' && c <= '9') {\n                // 数字可能几十 几百\n                curMulti = curMulti * 10 + (c - '0');\n            } else {\n                resultStr.append({c});\n            }\n        }\n\n        return resultStr;\n    }\n};\n```\n\n#### 复杂度分析\n\n+ 时间复杂度 *O*(*N*)，一次遍历字符串`s`；\n+ 空间复杂度 *O(N)*，辅助栈在极端情况下需要线性空间，例如 `2[3[aaaaaa]]`。","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094043216","body":"### 思路\n\n1、使用快慢双指针找到中间元素\n2、中间的就是二叉树的根，左右部分的就是左右子树，再按1去递归构造左右子树\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n     TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr) {\n            return nullptr;        \n        }\n        return sortedListToBST(head, nullptr);\n    }\n\n\n   TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if (head == tail) {\n            return nullptr;        \n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != tail && fast->next != tail) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode* root = new TreeNode(slow->val);\n        root->left     = sortedListToBST(head, slow);\n        root->right    = sortedListToBST(slow->next, tail);\n\n        return root;\n    }\n};\n\n```\n\n**复杂度分析**\n递归树的深度为 logn 所以时间复杂度和空间复杂度都是logn * 递归函数内部所需要的时间和空间\n\n- 时间复杂度：O(logn)\n- 空间复杂度：O(logn)   \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094293661","body":"### 思路\n\n使用双指针法，分别指向两个链表的起点，以相同的速度向后移动，若A = B则为相交的点\n若没有交点，则遍历完两个链表后共同指向nullptr, 不影响返回\n\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == nullptr || headB == nullptr) {\n            return nullptr;\n        }\n\n        if (headA == headB) {\n            return headA;\n        }\n        \n        ListNode* tmpA = headA;\n        ListNode* tmpB = headB;\n\n        while (tmpA != tmpB) {\n            if (tmpA == nullptr) {\n                tmpA = headB;\n            } else {\n                tmpA = tmpA->next;\n            }\n\n             if (tmpB == nullptr) {\n                tmpB = headA;\n            } else {\n                tmpB = tmpB->next;\n            }\n        }\n\n        return tmpA;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)   \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094902319","body":"### 思路\n\n快慢指针法：fast每次走两步，slow每次走一步\n第一次相遇时：fast回到head，和slow一样每次走一步，再次相遇的时候就是环的入口\n![图片](https://tva1.sinaimg.cn/large/008i3skNly1gqoqk2rhuij30gp08u3z0.jpg)\n\n\n### 代码\n\n\n```cpp\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr) {\n            return nullptr;\n        }\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast->next;\n                    slow = slow->next;\n                }\n\n                return fast;\n            } \n        }\n\n        return nullptr;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086056841","body":"### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663153","body":"### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\t\tint N = s.length();\n\t\tint[] ans = new int[N];\n\t\tint pre = -N;\n\t\tfor(int i = 0; i<N;i++) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = i-pre;\n\t\t}\n\t\tpre = 2*N;\n\t\tfor(int i = N-1; i>=0;i--) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = Math.min(ans[i],pre-i);\n\t\t}\n\t\treturn ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086891512","body":"```java\npublic class CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top =-1;\n    }\n    public void Push(int x) {\n        if(top!=stack.Length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    public int Pop() {\n        if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    public void Increment(int k, int val) {\n        int limit = Math.Min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094066181","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        List<Integer> valRecord = new ArrayList<>();\n        ListNode currentNode = head;\n        while (currentNode!=null) {\n            valRecord.add(currentNode.val);\n            currentNode = currentNode.next;\n        }\n        int[] nums = new int[valRecord.size()];\n        for(int i = 0; i < valRecord.size(); i++) {\n            nums[i] = valRecord.get(i);\n        }\n        return sortedListToBSTHelper(nums, 0, nums.length-1);\n    }\n\n    public TreeNode sortedListToBSTHelper(int[] nums, int left, int right) {\n        if(left == right)\n            return new TreeNode(nums[left]);\n        if(left > right)\n            return null;\n        int mid = left + (right-left)/2;\n        int val = nums[mid];\n        TreeNode leftNode = sortedListToBSTHelper(nums,left, mid-1);\n        TreeNode rightNode = sortedListToBSTHelper(nums, mid+1, right);\n        return new TreeNode(val, leftNode, rightNode);\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095228053","body":"```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public static ListNode inCycleNode(ListNode head) {\n        ListNode fast = head.next;\n        ListNode slow = head;\n        while(slow!=null && fast!=null) {\n            slow = slow.next;\n            fast = fast.next;\n            if(slow == fast) return slow;\n            if(fast!=null) fast = fast.next;\n        }\n        return null;\n    }\n\n    public static ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null) return null;\n        if(head.next == head) return head;\n        ListNode inLoopNode = inCycleNode(head);\n        if(inLoopNode == null) return null;\n        ListNode slow = head;\n        ListNode fast = head;\n        int count = 1;\n        for(ListNode point=inLoopNode; point.next!= inLoopNode; point = point.next) {\n            count++;\n        }\n        for(int i = 0; i < count;i++) {\n            fast = fast.next;\n        }\n        while(slow!=fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-will":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086057669","body":"## Idea:\nGo through the num array, accumulate the sum of each digits. Then sum with k and convert into a list.\n\n## Code:\n'''\n\n\tclass Solution:\n\t\tdef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\t\t\tsumArr = 0\n\t\t\tfor i, e in enumerate(num[::-1]):\n\t\t\t\tsumArr += e if i == 0 else e * (10 ** i)\n\n\t\treturn map(int, list(str(sumArr + k)))\n'''\n\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086936836","body":"## Idea\r\nUsing stack LIFO and nitrate through the string and process the char \r\n\r\n\r\n## Code\r\n\r\n```py\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, ret, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append((multi, ret))\r\n                ret, multi = \"\", 0\r\n            elif '0' <= c <= '9':\r\n                # 处理多位数字：一个空只会有一个数字，利用数字特性 n * 10 + c\r\n                multi = multi * 10 + int(c)\r\n            elif c == ']':\r\n                cur_multi, last_ret = stack.pop()\r\n                ret = last_ret + cur_multi * ret\r\n            else:\r\n                ret += c\r\n        return ret\r\n\r\n```\r\n\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088049019","body":"## Code\n```java\nclass MyQueue {\n    private Stack<Integer> s1 = new Stack<>();\n    private Stack<Integer> s2 = new Stack<>();\n    private int front;\n        \n    public MyQueue() {\n        \n    }\n    \n    // 每次S1空都更新front\n    public void push(int x) {\n        if (s1.empty())\n            front = x;\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if (s2.empty()) {\n            // s1搬空 下次push更新front\n            while(!s1.empty())\n                s2.push(s1.pop());\n        }\n        return s2.pop();\n    }\n    \n    // peek是两部分逻辑 S2相当于队列如不为空直接返回peek 否则S1最底就是peek值\n    public int peek() {\n        if (!s2.empty()) \n            return s2.peek();\n        return front;\n    }\n    \n    public boolean empty() {\n        return s1.empty() && s2.empty();\n    }\n}\n```\n\n## Complexity\nTime: amortized O(1) pop <br>\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089415383","body":"## Idea\n贪心法，代码不难，难在想到这个思路。重点是sorted arr和arr中元素个数相等即一个区块，因为依次查找所以一定是最小区块，即贪心法，所以一定是最多的个数\n\n## Code\n```py\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = num_nonzero = 0\n        \n        for x, y in zip(arr, sorted(arr)):\n            count[x] += 1\n            if count[x] == 0: num_nonzero -= 1\n            if count[x] == 1: num_nonzero += 1\n                \n            count[y] -= 1\n            if count[y] == -1: num_nonzero += 1\n            if count[y] == 0: num_nonzero -= 1\n            \n            if num_nonzero == 0: ans += 1\n            \n        return ans\n```\n\n## Complexity\nO(nlongn) <br>\nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090839748","body":"## Idea\n找到新链表的首和尾，尾比首少一步，steps = list_len - k % list_len - 1。特殊情况，如果k是0或list_len的整数倍，则无需反转，返回head即可\n\n## Code\n凭感觉写的比较乱，应该有更好的写法\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        \n        new_head = head\n        list_len = 0\n        tail = None\n        while new_head:\n            list_len += 1\n            if new_head and not new_head.next:\n                tail = new_head\n            new_head = new_head.next\n        \n        new_tail = head\n        steps = list_len - k % list_len - 1\n        for _ in range(steps):\n            new_tail = new_tail.next\n        \n        if new_tail.next:\n            new_head = new_tail.next\n            new_tail.next = None\n            tail.next = head\n        else:\n            new_head = head\n        \n        return new_head\n```\n## Complexity\nO(n) <br>\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092190427","body":"## Idea\n滑窗有三位，每次三个operations，之后向右滑动，重复操作即可\n\n## Code\n之前的写法不够简洁，借鉴了别人的码\n```py\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # dummy让code简介\n        dummy = ListNode()\n        dummy.next = head\n        cur = head\n        prev = dummy\n        # 至少两个node才swap\n        while cur and cur.next:\n            next = cur.next\n            # 滑窗内三次opeartions\n            cur.next = next.next\n            next.next = cur\n            prev.next = next\n            # 设置新滑窗\n            prev = cur\n            cur = cur.next\n        \n        return dummy.next\n```\n\n# Complexity\nO(n) <br>\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093593697","body":"## code\n```java\npublic class Solution {\npublic TreeNode sortedListToBST(ListNode head) {\n    if(head==null) return null;\n    return toBST(head,null);\n}\npublic TreeNode toBST(ListNode head, ListNode tail){\n    ListNode slow = head;\n    ListNode fast = head;\n    if(head==tail) return null;\n    \n    while(fast!=tail&&fast.next!=tail){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    TreeNode thead = new TreeNode(slow.val);\n    thead.left = toBST(head,slow);\n    thead.right = toBST(slow.next,tail);\n    return thead;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094109607","body":"## Idea\nset or two pointer\n\n## Code\n```py\n# Hashset\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        nodesA = set()\n        while headA:\n            nodesA.add(headA)\n            headA = headA.next\n        \n        while headB:\n            if headB in nodesA:\n                return headB\n            headB = headB.next\n            \n        return None\n\n# two pointer\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB: return None\n        \n        pA, pB = headA, headB\n        while pA != pB:\n            pA = pA.next if pA else headB\n            pB = pB.next if pB else headA\n        \n        return pA\n```\n\n## Complexity\nO(m + n) O(m) <br>\nO(m + n) O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094464285","body":"## Code\n```py\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast = slow = head\n        is_circle = False\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                is_circle = True\n                break\n        \n        if not is_circle: return False\n        \n        fast = head\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n            \n        return slow\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hohojii":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086058735","body":"##思路\n逐位相加\n##代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086665804","body":"##左右遍历\n##code\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n, 1e6);\n        int last = -1e6;\n        for(int i = 0; i < n; i++) {\n            if(s[i] == c) {\n                ans[i] = 0;\n                last = i;\n            }\n            else ans[i] = min(ans[i], i - last);\n        }\n        last = 1e6;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s[i] == c) last = i;\n            else ans[i] = min(ans[i], last - i);\n        }\n        return ans;\n    }\n};\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088860479","body":"‘’‘’class MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090409162","body":"##code''''\npublic class Solution {\n\n     public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091886164","body":"##code‘’‘’\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n##复杂度分析\n时间复杂度：O(n)O(n)，最坏情况下，我们需要遍历该链表两次。\n空间复杂度：O(1)O(1)，我们只需要常数的空间存储若干变量。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxjo":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086060234","body":"## 思路\nnum与k从右向左逐位相加，遇到进位则加到下一位上\n\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    let res = [];\n    for(let i = num.length - 1; i >= 0; i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum >= 10){\n            sum -= 10;\n            k += 1;\n        }\n        res.push(sum);\n    }\n    //解决k位数大于数组长度\n    while(k > 0){\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n## 复杂度分析\n时间复杂度： O(max(num.length, lgk))  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086652531","body":"## 思路\n\n使用不定长滑动窗口，边界字符为c，left和right维护窗口`\n\n## 代码\n```\nvar shortestToChar = function(s, c) {\n    let res = [];\n    let left = -Infinity;\n    let right = s.indexOf(c);\n    for(let i = 0; i < s.length; i++){\n        res.push(Math.min(Math.abs(i - left), Math.abs(i -right)));\n        if(i === right){\n            left = right;\n            right = s.indexOf(c, right + 1);\n        }\n    }\n    return res;\n};\n```\n\n## 复杂度分析\n\n\n时间复杂度:O(n)\n空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886549","body":"## 思路\n使用数组，并用原生的push、pop方式实现\n\n## 代码\n\n```\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize){\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length > 0 ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < this.stack.length; i++){\n        if(i < k){\n            this.stack[i] += val;\n        }\n    }\n};\n```\n## 复杂度分析\n时间复杂度： push(): O(1); pop():O(1); increment:O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087716526","body":"## 思路\n使用非\"]\"的字符入栈，遇到\"]\"时，字符出栈，在遇到\"[\"之前出栈的字符拼接得repeatString，随后数字字符出栈拼接转化成对应数字就是repeatNum，根据上述两个变量，得到重复的完整字符串，随后压入栈重复上述操作。\n\n## 代码\n```\n var decodeString = function(s) {\n    let stack = [];\n    for(let c of s){\n        if(c !== ']'){\n            stack.push(c);\n            continue;\n        }\n        let repeatString = '';\n        while(stack.length > 0 && stack[stack.length - 1] != '['){\n            repeatString = stack.pop() + repeatString;\n        }\n    \n        /* 弹出[ */\n        stack.pop();\n    \n        let repeatNum = '';\n        while(stack.length > 0 && !isNaN(stack[stack.length - 1])){\n            repeatNum = stack.pop() + repeatNum;\n        }\n        stack.push(repeatString.repeat(Number(repeatNum)));\n    }\n    return stack.join('');\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088852525","body":"## 思路\nstack1作为输入栈，stack2作为输出栈，只有当stack2为空时，才将stack1中的数据移到stack2中\n\n## 代码\n```\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length > 0){\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length === 0){\n        while(this.stack1.length > 0){\n            this.stack2.push(this.stack1.pop());\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack2.length == 0 && this.stack1.length == 0 ? true : false;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090406510","body":"## 思路\n栈里表示的每一个块的局部最大值，且保持后入栈的局部最大值要大于先入栈的局部最大值（即该栈出栈的元素是单调减的，所以是递减栈）\n\n## 代码\n```\nvar maxChunksToSorted = function(arr) {\n    let res = [];\n    for(let ele of arr){\n        if(res.length > 0 && res[res.length - 1] > ele){\n            //解决2 2 1这种情况，当后面出现比栈中最大值要小的数时，只能分成1块\n            let cur = res[res.length - 1];\n            while(res.length > 0 && res[res.length - 1] > ele){\n                res.pop();\n            }\n            res.push(cur);\n        }\n        else{\n            res.push(ele);\n        }\n    }\n    return res.length;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091890623","body":"## 思路\n总的思路是将倒数step个节点移至链表头部  \n使用快慢指针：  \n1、获取链表长度length  \n2、取余数step，利用余数自减，快指针移至第step + 1个节点（因为初始fast = head）  \n3、快慢指针同时走，快指针走到尾时，慢指针走到倒数第step+1个节点（因为初始slow = head）\n\n## 代码\n```\n var rotateRight = function(head, k) {\n    if(head === null || head.next === null){\n        return head;\n    }\n    //获取链表长度\n    let length = 0;\n    let temp = head;\n    while(temp !== null){\n        length += 1;\n        temp = temp.next;\n    }\n\n    let step = k % length;\n    let fast = head;\n    let slow = head;\n    while(step > 0){\n        fast = fast.next;\n        step -= 1;\n    }\n\n    while(fast.next !== null){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    fast.next = head;\n    head = slow.next;\n    slow.next = null;\n    return head;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092926330","body":"## 思路\n1、使用两个指针pre和cur交换节点，pre指向交换节点的前一个节点，cur指向交换节点的第一个节点  \n2、注意使用虚拟节点virtual，此时head是否为空，均返回virtual.next,可以减少边界判断\n## 代码\n```\n var swapPairs1 = function(head) {\n    let virtual = new ListNode(null, head);\n    let pre = virtual;\n    let cur = head;\n    while(cur !== null && cur.next !== null){\n        let curNext = cur.next;\n        pre.next = curNext;\n        cur.next = curNext.next;\n        curNext.next = cur;\n        \n        pre = cur;\n        cur = cur.next;\n    }\n    return virtual.next;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072395","body":"## 思路\n1、二分查找使用快慢指针找到中间节点  \n2、使用递归\n## 代码\n```\n var sortedListToBST1 = function(head) {\n    if(head === null) return null;\n    if(head.next === null) return new TreeNode(head.val);\n    let fast = head.next.next;\n    let slow = head;\n    while(fast !== null && fast.next !== null){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    let root = new TreeNode(slow.next.val);\n    let rightHead = slow.next.next;\n    slow.next = null;\n    root.left = sortedListToBST1(head);\n    root.right = sortedListToBST1(rightHead);\n    return root;\n};\n```\n## 复杂度分析\n时间复杂度：O(nlogn)  \n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094255320","body":"## 思路\n使用双指针\n## 代码\n```\nvar getIntersectionNode = function(headA, headB) {\n    if(headA === null) return null;\n    if(headB === null)  return null;\n    let node1 = headA;\n    let node2 = headB;\n    while(node1 !== node2){\n        node1 = node1 !== null ? node1.next : headB;\n        node2 = node2 !== null ? node2.next : headA;\n    }\n    return node1;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095139932","body":"## 思路\n参考官方题解，使用了快慢指针。  \n1、fast=head, slow=head  \n2、fast一次走两步，slow一次走一步，当相遇时，说明有环  \n3、若有环，p=head，p和slow均一次走一步，p和slow相遇处就是入环点  \n## 代码\n```\nvar detectCycle = function(head) {\n    if(head === null) return null;\n    let fast = head;\n    let slow = head;\n    while(fast !== null && fast.next !== null){\n        fast = fast.next.next;\n        slow = slow.next;\n        if(fast === slow){\n            //进入这个循环，说明有环\n            let p = head;\n            while(p != slow){\n                p = p.next;\n                slow = slow.next;\n            }\n            return p;\n        }\n    }\n    return null;\n};\n```\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ha0cheng":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086068703","body":"思路：\r\n实现数组形式的加法，逐位相加，保存进位\r\n\r\n代码：\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        Next= 0\r\n        p = len(num)- 1\r\n        while p>=0:\r\n            x = num[p]+k%10+Next\r\n            num[p] = x%10\r\n            Next = x//10\r\n\r\n            k//=10\r\n            p-=1\r\n            if k==0 and Next ==0:\r\n                break\r\n\r\n        while k>0 or Next>0:\r\n            x = k%10+Next\r\n            num.insert(0,x%10)\r\n            Next = x//10\r\n            k//=10\r\n        return num\r\n```\r\n\r\n\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086159354","body":"思路：\r\n遍历两遍，第一遍确定字符的位置，第二遍确定距离每个字符位置最近的字符区间，输出结果\r\n\r\n代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        P = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n              P.append(i)\r\n        r = []\r\n        left = 0\r\n        for i in range(len(P)):\r\n            if i==len(P)-1:\r\n                right = len(s)-1\r\n            else:\r\n                right = (P[i]+P[i+1]-1)//2\r\n            j = P[i] - left \r\n            while j>0:\r\n                r.append(j)\r\n                j-=1\r\n            while j<=right-P[i]:\r\n                r.append(j)\r\n                j+=1\r\n        \r\n            left = right+1\r\n        \r\n        return r\r\n```\r\n时间复杂度：需要遍历两遍，每次均是原字符数组的长度，所以复杂度为O(N)\r\n空间复杂度：需要一个空间来存储字符位置，最坏情况下是N，复杂度为O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086886712","body":"思路：\r\n\r\n入栈和出栈都是基础操作，主要要实现的是第三个功能，栈底前k个元素增加值，要访问栈底，想到使用数组，最开始的思路是循环增加前k个值，复杂度是O(k)，看了参考答案，如果用数组add来保存每个位置的增加量，并且在pop的过程中传递倒数第二个值，便可实现增加量的传递，实现复杂度为O(1)的方法\r\n\r\n代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.Stack = [] \r\n        self.add = []\r\n        self.maxSize = maxSize\r\n        self.length = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxSize:\r\n            self.Stack.append(x)\r\n            self.add.append(0)\r\n            self.length +=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        else:\r\n            if self.length>1:\r\n                self.add[self.length-2] += self.add[self.length-1]\r\n            self.length-=1\r\n            return self.Stack.pop()+self.add.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        idx = min(k-1,self.length-1)\r\n        if idx>=0:\r\n            self.add[idx] += val\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：入栈，出栈和增加值的复杂度都是O(1)\r\n空间复杂度：设当前栈长度是cnt，那么需要额外存储的add数据需要空间是O(cnt)，复杂度是O(cnt)，最坏情况下复杂度是O(maxSiz)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091189327","body":"思路：首先遍历一遍，确定链表长度n，然后找到新的头节点和尾节点，原来的尾节点要连在源头节点上，形成一个环形列表，然后找到第n-k个节点，是新的尾节点；第n-k+1个节点，是新的头节点，返回。\r\n\r\n代码：\r\n\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        tail = head\r\n        n=1\r\n        while tail.next:\r\n            tail=tail.next\r\n            n+=1\r\n        k=k%n\r\n        i=0\r\n        tail.next=head\r\n        for i in range(n-k-1):\r\n            head = head.next   \r\n        new_head = head.next\r\n        head.next = None\r\n    \r\n        return new_head\r\n```\r\n  \r\n复杂度分析：\r\n时间复杂度：遍历两遍，第一次n，第二次n-k，是O(n)\r\n空间复杂度：只需要一些空间来存储尾节点和新头节点，复杂度是O(1)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092446399","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # if not head or not head.next:\n        #     return head\n        \n        pre_node = ListNode(next=head)   \n        last_node = pre_node\n        while head and head.next:\n            next_head = head.next.next\n\n            last_node.next = head.next\n            head.next.next = head\n            head.next = next_head\n\n            last_node = head\n            head = next_head\n  \n        return pre_node.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072329","body":"思路：参考官方思路，递归的形成平衡二叉树，对于一段链表来说，递归的过程就是找到中间节点，作为根节点，同时调用函数，把左右两个链表分别转化成左子树和右子树，返回左子树和右子树的根节点，作为该根节点的左右子节点即可。\r\n注意是要把中间节点左右链表变成两个子链表需要让中间节点前一个节点断开，指向None.\r\n\r\n代码如下：\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        fast = head\r\n        slow = head\r\n        pre = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n\r\n        root = TreeNode(val=slow.val)\r\n    \r\n        if not pre:\r\n            return root    \r\n        pre.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n复杂度分析：\r\n时间复杂度：递归深度为O(log N)，每次递归需要遍历整个递归链表，即O(Nlog N)\r\n空间复杂度：递归深度为O(log N)，因为每次递归，问题规模变为原来的一半，规模指数下降，所以空间复杂度为O(log N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294747","body":"思路1：保存一条链表的所有节点在一个哈希表中，然后遍历另外一个节点找到第一个在这个哈希表中的节点。\r\n思路2：遍历两个链表，保存长度m,n，可以得到相交链表起始点的差距|m-n|，然后用快慢指针找到第一个相等的节点即可。\r\n思路3：用两个指针从A和B的头结点开始遍历，如果A遍历到尾就再从B的头结点开始遍历，如果B到头就从A的头结点继续开始遍历，最终能到达同样的结点，即是相同的起始结点；如果同时到达None，则是无共同结点。\r\n\r\n思路2代码如下：\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        lengthA = 1\r\n        lengthB = 1\r\n        A = headA\r\n        B = headB\r\n        while A.next:\r\n            lengthA +=1\r\n            A = A.next\r\n        while B.next:\r\n            lengthB +=1\r\n            B = B.next\r\n\r\n        A = headA\r\n        B = headB\r\n        if lengthA>=lengthB:\r\n            for i in range(0,lengthA-lengthB):\r\n                A=A.next\r\n        else:\r\n            for i in range(0,lengthB-lengthA):\r\n                B=B.next\r\n        \r\n        while A!=B:\r\n            A=A.next\r\n            B=B.next\r\n        return A\r\n```\r\n\r\n思路3代码如下：\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        A = headA\r\n        B = headB\r\n        while A or B:\r\n            A = A if A else headB\r\n            B = B if B else headA\r\n            if A == B:\r\n                return A \r\n            A = A.next \r\n            B = B.next \r\n        \r\n        return None\r\n\r\n```\r\n\r\n分析：\r\n思路1 遍历一遍，需要一个哈希表来存储，时间复杂度为O(m+n)，空间复杂度为O(n)\r\n思路2 需要遍历两遍，时间复杂度为O(m+n)，空间复杂度为O(1)\r\n思路3 需要遍历两遍，时间复杂度最坏是O(m+n)，空间复杂度为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095190019","body":"思路：快慢指针。从预先的节点pre开始走，slow每次走一步，fast每次走两步。直到遇到None(无环)或者slow和fast重合。如果重合，假设pre到环的入口长度是A，入口到重合点的长度是B，重合点到入口的长度是C，则此时slow走的步长是A+B，fast走的步长是2(A+B) = A+n(B+C)+B，可得C = (n-1)(B+C)+A，所以A%(B+C) = C%(B+C). 则我们设置一个点从重合点出发，一个点从pre出发，最终会达到环的入口，结束。\r\n\r\n代码如下：\r\n\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        pre = ListNode(0)\r\n        pre.next = head\r\n        right = pre\r\n        left = pre\r\n        while right.next and right.next.next:\r\n            right=right.next.next\r\n            left=left.next\r\n            if left==right:\r\n                break\r\n        if not right.next or not right.next.next:\r\n            return None\r\n        \r\n        left = pre\r\n        while left!=right:\r\n            left=left.next\r\n            right=right.next\r\n\r\n        return left\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度，最多遍历两次，复杂度为O(N)\r\n空间复杂度，只需要常数项的时间，复杂度为O(1)\r\n\r\n另外可以用哈希表保存遍历过的点，每次进入一个新的点，判断是否在表中O(1)，此时复杂度为O(N),需要存储哈希表复杂度为O(N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joewx21":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086071168","body":"### 思路\n\n将k加到num的低位，大于10就取余留下个位，整除取出个位得到进位，每位循环直到最高位并且 k 为0或者i<0。如果 i 小于0，数字长度加一，再循环上过程。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        while(k > 0){\n            num[i] += k;\n            k = num[i] / 10;\n            num[i--] %= 10;\n            if(i < 0 && k > 0){\n                num.insert(num.begin(), 0);\n                i = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(n)\n\\- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663863","body":"### 思路\n\n先把s中所有等于c的元素的下标值存入到数组sc中，然后利用双重循环遍历s，比较s中各个下标值与sc中元素值的大小，将当前下标值与sc[j]的差的绝对值最小值存入scret中\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> sc; // 与c相同的值得索引\n        vector<int> scret; // 距离结果\n        for(int i =0; i<s.size(); i++){\n            if(s[i] == c){\n                sc.push_back(i);\n            }\n        }\n        if(sc.size() == 1){\n            for(int i = 0; i < s.size(); i++){\n                scret.push_back(abs(i-sc[0]));\n            }\n        }\n        for (int i = 0; i<s.size(); i++){\n            for(int j = 0; j<sc.size()-1; j++){\n                if(i<=sc[j]){\n                    scret.push_back(abs(sc[j]-i));\n                    break;\n                }\n                if(i>sc[j]&&i<=sc[j+1]){\n                    scret.push_back(min(abs(i-sc[j]), abs(i-sc[j+1])));\n                    break;\n                }\n                if(i>sc[sc.size()-1]){\n                    scret.push_back(abs(i-sc[sc.size()-1]));\n                    break;\n                }\n            }\n        }\n        return scret;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086858315","body":"### 思路\n\n这里使用数组来进行栈的模拟，方便执行inc(int k, int val)操作\n\n### 代码\n\n```cpp\nclass CustomStack {\npublic:\n    int maxSize;\n    vector<int> stack;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n    }\n    \n    void push(int x) {\n        if(stack.empty()||stack.size()<maxSize){\n            stack.push_back(x);\n            return ;\n        }\n    }\n    \n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        int val = stack.back();\n        stack.pop_back();\n        return val;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k&&i<stack.size(); i++){\n            stack[i] += val;\n        }\n        return ;\n    }\n};\n```\n\n**时间复杂度**：O(min(k, stak.size()))\n\n**空间复杂度**：O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087568418","body":"### 思路\n\n用两个栈，一个存字符串一个存数字，遇到数字就把之前的字符串压入字符串栈，再把数字压入数字栈，因为数字后必是`[`，使用`str`记录的字符串是`[`之前的，将其压入栈，重新记录`str`，遇到`]`时，弹出数字栈顶元素k，并重复`str`k次。之后将字符串栈栈顶元素弹出来并与当前字符串拼接，作为新的当前正在累积的字符串。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> str_stk;//字符串栈\n        stack<int> num_stk;//数字栈\n        string str;\n        for(int i=0;i<s.size();i++){\n            if(isdigit(s[i])){\n                int n=s[i]-'0';\n                while(isdigit(s[++i])){\n                    n=10*n+s[i]-'0';\n                }\n                num_stk.push(n);\n                i--;\n            }\n            else if(s[i]=='['){\n                str_stk.push(str);\n                str=\"\";\n            }\n            else if(s[i]==']'){\n                string tmp;\n                for(int i=0;i<num_stk.top();i++){\n                    tmp+=str;\n                }\n                str=tmp;\n                num_stk.pop();\n                str=str_stk.top()+str;\n                str_stk.pop();\n            }\n            else{\n                str+=s[i];\n            }\n        }\n        return str;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088900438","body":"### 思路\n\n用两个栈来模拟队列，当需要出队时，直接取出tmp栈里面的元素，若tmp为空将stk栈的元素依次放入即可。\n\n### Code\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> stk, tmp;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    void get() {\n        if(tmp.empty()) {\n            while(!stk.empty()){\n                tmp.push(stk.top());\n            stk.pop();\n            }\n        }\n    }\n\n    int pop() {\n        int t;\n        get();\n        t = tmp.top();\n        tmp.pop();\n        return t;\n    }\n    \n    int peek() {\n        get();\n        return tmp.top();\n    }\n    \n    bool empty() {\n        return tmp.empty() && stk.empty();\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090160350","body":"### 思路\n\n思路：将数组先进行拷贝然后排序，用一个键值对记录下当前数字在数组中的正确位置，遍历数组的过程中，找到目前元素的最远正确位置为一组，如果当前元素在正确的位置上，则单独为一组。\n\n### code\n\n```cpp\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) \n    {\n        int n=arr.size();\n        vector<int> temp=arr;\n        sort(temp.begin(),temp.end());\n        unordered_map<int,queue<int>> hashmap;\n        //排序并记录当前元素的正确位置，由于数组中可能有重复元素，因此用一个队列记录元素的位置\n        for(int i=0;i<n;i++)\n        {\n            hashmap[temp[i]].push(i);\n        }\n        int ans=0;\n        int index=0;\n        //遍历原有数组进行分组\n        while(index<n)\n        {\n            int next=hashmap[arr[index]].front();\n            hashmap[arr[index]].pop();\n            if(hashmap[arr[index]].size()==0)\n            {\n                hashmap.erase(arr[index]);\n            }\n            //next表示当前组内的最大下标\n            for(int i=index+1;i<=next;i++)\n            {\n                int curr=hashmap[arr[i]].front();\n                hashmap[arr[i]].pop();\n                if(hashmap[arr[i]].size()==0)\n                {\n                    hashmap.erase(arr[i]);\n                }\n                next=max(next,curr);\n            }\n            ans++;\n            index=next+1;\n        }\n        return ans;\n    }\n};\n\n```\n\n**时间复杂度：** O(N^2)\n\n**空间复杂度：** O(2N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086072595","body":"## 思路\n\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i;\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(0, k % 10);\n        }\n        return list;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(max(num.length(),logK))$\n\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\n\n- 额外空间复杂度: $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667405","body":"## 思路(法一)\n\n利用库函数**indexOf(c)**来找到**后一个出现字母的位置**,比较前一个出现和后一个出现的距离,取最小值\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n   public int[] shortestToChar_1(String s, char c) {\n        int[] ans = new int[s.length()];\n        int fir = -1, sec = Integer.MAX_VALUE / 2, cur = 0;\n        fir = s.indexOf(c);\n        for (int i = 0; i < ans.length; i++) {\n            if (fir > i) {\n                ans[i] = fir - i;\n            } else if (fir == i) {\n                ans[i] = 0;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            } else if (i < sec) {\n                ans[i] = Math.min(Math.abs(fir - i), Math.abs(sec - i));\n            } else {\n                ans[i] = 0;\n                fir = sec;\n                sec = s.indexOf(c, fir + 1) == -1 ? Integer.MAX_VALUE / 2 : s.indexOf(c, fir + 1);\n            }\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N^2)$\n\n​\t\t\t\t\t\t\t因为String类中indexOf()方法是暴力匹配方法时间复杂度为$O(N*M)$,而我们这里M=1,所以综上总的时间复杂度为$O(N^2)$\n\n- 额外空间复杂度: $O(N)$\n\n## 思路(法二)\n\n对于每个字符 S[i]，通过**顺序遍历和逆序遍历两次**,试图找出距离向左和向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n## 语言\n\nJava\n\n## 代码\n\n```java\npublic class Solution {\n    public int[] shortestToChar_2(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        //假设上一个出现的位置为Integer.MIN_VALUE / 2\n        int prev = Integer.MIN_VALUE / 2;\n\n        //记录s[i]与前一个字符c的距离\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        //假设最后一个出现的位置为Integer.MAX_VALUE / 2\n        prev = Integer.MAX_VALUE / 2;\n\n        //计算s[i]与后一个字符c的距离,与原来的距离比较取最小值\n        for (int i = N - 1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:\t$O(N)$\n\n- 额外空间复杂度: $O(N)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086885823","body":"## 思路\n\n同样用数组来模拟实现栈,但是对increment()方法进行优化\n\n再用一个辅助数组add来记录increase的值, 利用==差分思想==, 在每次pop()时把add数组和原数组arr==相加输出==\n\n## 语言\n\njava\n\n## 代码\n\n```java\nclass CustomStack_PrefixSum {\n    private int[] arr;\n    private int[] add;\n    private int top;\n\n    public CustomStack_PrefixSum(int maxSize) {\n        arr=new int[maxSize];\n        add=new int[maxSize];\n        top=-1;\n    }\n\n    public void push(int x) {\n        if (top < arr.length-1 ) {\n            arr[++top]=x;\n        }\n    }\n\n    public int pop() {\n        if (top >= 0) {\n            int res=arr[top]+add[top];\n            if (top>=1){\n                add[top-1]+=add[top];\n            }\n            add[top--]=0;\n            return res;\n        }return -1;\n    }\n\n    public void increment(int k, int val) {\n        int end= Math.min(k-1, top);\n        if (end>=0){\n            add[end]+=val;\n        }\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:CustomStack(),push(),pop(), increment()时间复杂度为都为$O(1)$\n- 空间复杂度:$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087732150","body":"## 思路\n\n栈操作\n\n- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n- 如果当前的字符为字母或者左括号，直接进栈\n- 如果当前的字符为右括号，开始出栈,一直到左括号出栈\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic String decodeString(String s) {\n        Stack<Integer> add=new Stack<>();\n        Stack<String> str=new Stack<>();\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i)>=48&&s.charAt(i)<=57){\n                int j=i;\n                while(s.charAt(j+1)>=48&&s.charAt(j+1)<=57){\n                    j++;\n                }\n                int num=Integer.parseInt(s.substring(i,j+1));\n                add.push(num);\n                i=j;\n            }else if(s.charAt(i)==91){\n                int j=i+1;\n                String temp = new String(\"\");\n                while (s.charAt(j)>=97&&s.charAt(j)<=122){\n                    temp+=(s.charAt(j));\n                    j++;\n                }\n                i=j-1;\n                str.push(temp);\n            }else if(s.charAt(i)==93){\n                int time=add.pop();\n                String base=str.pop();\n                StringBuilder builder1 = new StringBuilder();\n                while (time>0){\n                    builder1.append(base);\n                    time--;\n                }\n                if (!str.isEmpty()){\n                    base=str.pop();\n                }\n                else base=\"\";\n                base+=builder1.toString();\n                str.push(base);\n            }else {\n                String t=new String(\"\");\n                if (!str.isEmpty()){\n                    t = str.pop();\n                }\n                t+=s.charAt(i);\n                str.push(t);\n            }\n        }\n        return str.peek();\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度: $O(S)$,S表示解码后字符串长度\n- 空间复杂度:$O(S)$,S表示解码后字符串长度,维护栈,栈的总大小最终与S相同\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088897408","body":"## 思路\n\n使用两个栈,一个栈负责存储新Push()进来的数据,当需要==访问\\弹出队列头==时,把原栈的数据放到另一个栈中,实现==逆序==\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class MyQueue {\n    LinkedList<Integer> stack  ;\n    LinkedList<Integer> queue ;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stack = new LinkedList<>();\n        queue = new LinkedList<>();\n    }\n\n    /**\n     * Push element x to the back of queue.\n     * @复杂度分析\n     *      时间复杂度:O(1)\n     *      空间复杂度:O(n)\n     * */\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    /**\n     * Removes the element from in front of queue and returns that element.\n     * @复杂度分析\n     *      时间复杂度:摊还时间复杂度为O(1)\n     *      空间复杂度:O(1)\n     * */\n    public int pop() {\n        if (queue.isEmpty()){\n            while (!stack.isEmpty()){\n                queue.push(stack.poll());\n            }\n        }\n        return queue.pop();\n    }\n\n    /**\n     * Get the front element.\n     * 时间复杂度:\n     *      摊还时间复杂度:O(1)\n     *      空间复杂度:O(1)\n     * */\n    public int peek() {\n        if (queue.isEmpty()){\n            while (!stack.isEmpty()){\n                queue.push(stack.poll());\n            }\n        }\n        return queue.peek();\n    }\n\n    /**\n     * Returns whether the queue is empty.\n     *时间复杂度:\n     *      时间复杂度:O(1)\n     *      空间复杂度:O(1)\n     * */\n    public boolean empty() {\n        if (stack.isEmpty()&&queue.isEmpty()){\n            return true;\n        }return false;\n    }\n}\n\n```\n\n## 复杂度分析\n\n- push()\n    - 时间复杂度:O(1)\n    - 空间复杂度:O(n)\n- pop()\n    - 摊还时间复杂度:O(1)\n    - 空间复杂度:O(1)\n- empty()\n    - 时间复杂度:O(1)\n    - 空间复杂度:O(1)\n- peek()\n    - 摊还时间复杂度:O(1)\n    - 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090432796","body":"## 思路\n\n先对原数组排序,排好序后找到原数组中每个对应位置(p)元素应该在的位置(q),从左往右遍历数组根据(p,q)的区间的包含关系可以不断扩大stk的大小.\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n        Stack<Pair<Integer, Integer>> stk = new Stack<>();\n        int[] sorted ;\n       sorted =arr.clone();\n       BoboNote.DataStructure.Arrays.sort(sorted);\n        int[] indexs = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            int index =Search(sorted, arr[i]);\n            indexs[i]=index;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            int left=Math.min(i,indexs[i]),right=Math.max(i,indexs[i]);\n            if (stk.isEmpty()){\n                stk.push(new Pair<>(left,right));\n            }else{\n                Pair<Integer, Integer> idx = stk.pop();\n                int preL=idx.getKey();\n                int preR=idx.getValue();\n                if (preL <= left && preR >= left && right > preR) {\n                    stk.push(new Pair<>(preL,right));\n                }\n                else if (left>preR){\n                    stk.push(new Pair<>(preL,preR));\n                    stk.push(new Pair<>(left,right));\n                }else {\n                    stk.push(new Pair<>(preL,preR));\n                }\n            }\n        }\n\n        return stk.size();\n    }\n     private int Search(int[] sorted, int a) {\n        int i=0;\n        while (sorted[i++]!=a);\n        sorted[--i]=-1;\n        return i;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(n*logn+n^2)$\n- 空间复杂度:$O(2n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091911830","body":"## 思路\n\n通过遍历找到链表的最后一个元素,并统计出链表的长度大小==size==。利用==（k%size）==的值来判断移动后链表的头节点位置，若（k%size）== 0 直接返回head，否则遍历到应该返回的头结点的前一个结点处，把它的next设置为==null==。\n\n## 语言\n\njava\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n     public ListNode rotateRight(ListNode head, int k) {\n\n        if (k==0||head==null)return head;\n        int size=1;\n        ListNode pre=null,cur=head;\n        while (cur.next!=null){\n            cur=cur.next;\n            size++;\n        }\n        if (k%size==0)return head;\n        cur.next=head;\n        cur=cur.next;\n        \n        int time=size-(k%size);\n        while (time-->0){\n            pre=cur;\n            cur=cur.next;\n        }\n        if (pre!=null){\n            pre.next=null;\n        }\n        return cur;\n    }\n\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(n)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092962166","body":"## 思路\n\n链表操作(穿针引线法)\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic ListNode swapPairs(ListNode head) {\n        ListNode virHead = new ListNode(0, head);\n        ListNode cur=virHead;\n        while (cur.next!=null&&cur.next.next!=null){\n            ListNode t=cur.next;\n\n            cur.next=cur.next.next;\n            cur=cur.next;\n            t.next=cur.next;\n            cur.next=t;\n            cur=t;\n        }\n        return virHead.next;\n    }\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(n)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072755","body":"class Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n            return convert(head,null);\r\n    }\r\n    //转换方法\r\n    public TreeNode convert(ListNode left,ListNode right){\r\n            if(left == right){\r\n                return null;\r\n            }\r\n            //得到中间值,然后递归处理两边\r\n            ListNode mid = getMedian(left,right);\r\n            TreeNode root = new TreeNode(mid.val);\r\n            //right为null和mid,left为left和mid.next\r\n            root.left = convert(left,mid);\r\n            root.right = convert(mid.next,right);\r\n            return root;\r\n    }\r\n    //中间值\r\n    public ListNode getMedian(ListNode left,ListNode right){\r\n            ListNode slow = left;\r\n            ListNode fast = left;\r\n            while(fast != right && fast.next != right){\r\n                slow = slow.next;\r\n                fast = fast.next.next;\r\n            }\r\n            return slow;\r\n    }   \r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094298305","body":"## 思路\n\n双指针法\n\n**走到尽头见不到你,于是去走你来时的路,等到相遇时才发现,你也走过我来时的路!**\n\n可以理解成两个人速度一致， 走过的路程一致。==那么肯定会同一个时间点到达终点==。如果到达终点的最后一段路两人都走的话，那么这段路上俩人肯定是肩并肩手牵手的。\n\n该题的关键是让两个不同链表的指针都同步到 ==离链表尾部相同距离的位置==!\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) {\n        return null;\n    }\n    ListNode curA = headA , curB = headB;\n    while (curA != curB) {\n        curA = curA == null ? headB : curA.next;\n        curB = curB == null ? headA : curB.next;\n    }\n    return curA;\n}\n```\n\n## 复杂度分析\n\n- 最差时间复杂度:$O(n+m)$\n- 空间复杂度:$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095238936","body":"## 思路\n\n快慢指针法\n\n若链表中存在环那么快慢指针最后一定会在环中的某个位置==重合==\n\n 此时slow指针已经走了==a+b==(a表示环外的步数,b表示入环开始到重合位置的步数);\n\n而对于fast指针此时已经走了==a+n(b+c)+b==(c表示从此时重合位置开始继续向前走到入环点的步数)\n\n这时候因为重合我们可以得到这样的等式:\n$$\na+n(b+c)+b=2(a+b)\n\\rightarrow \na=c+(n-1)(b+c)\n$$\n这时我们发现从相遇点到入环点的距离C加上 ==n-1== 圈的环长，恰好等于从链表头部到入环点的距离。即若此时再额外使用一个指针 $\\textit{ptr}$从链表头出发,随后，它和 $\\textit{slow}$ 每次向后移动一个位置。最终，它们会在入环点相遇。\n\n## 语言\n\njava\n\n## 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head==null)return null;\n       ListNode slow=head,fast=head,reRun=head;\n        do{\n            if (fast.next==null||fast.next.next==null)return null;\n            fast=fast.next.next;\n            slow=slow.next;\n        }while (slow!=fast);\n        while (slow!=reRun){\n            slow=slow.next;\n            reRun= reRun.next;\n        }\n        return reRun;\n    }\n}\n```\n\n## 复杂度分析\n\n- 时间复杂度:$O(N)$ \n    - 在最开始的快慢指针遍历的过程中,slow指针走的次数不会大于链表长度N\n    - 而在后面寻找入环点的过程中,reRun指针走的次数也不会大于链表长度N\n    - 综上$O(N)+O(N)=O(N)$\n- 空间复杂度:$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086074254","body":"### Idea\r\nLet carry = k; Add k with each digit of num form right to left, \r\nput units digit into res, update carry \r\nreverse res\r\n\r\n### Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = k;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || carry > 0) {\r\n            if (i >= 0) {\r\n                carry += num[i];\r\n            }\r\n            res.add(carry % 10);\r\n            carry /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### Complexity\r\nTime: O(N)  N refers to the length of num. (reach each element once) \r\nSpace: O(1)  (no extra space except result)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086670553","body":"## Idea\r\nTwo-pass: \r\n1st left to right, find shortest distant to character on left.\r\n2nd right to left, find shortest distant to character on right, and pick shorter one.\r\n\r\n## Code\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int position = -n;\r\n        int[] res = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = i - position;\r\n            System.out.print(res[i]);\r\n        }\r\n        System.out.print(\" \");\r\n        for (int i = position - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                position = i;   \r\n            }\r\n            res[i] = Math.min(res[i], position - i);\r\n            System.out.print(res[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\nTime: O(N)  N refers to the length of string. Traverse string twice\r\nSpace: O(N) extra space for output","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087754257","body":"## Idea\nUse two stack: \nOne intStack to store temp number k until reach to a '['\nOne strStack to store temp string until reach to a ']'\nThe peek item of strStack will record the current temp string, \nand the after-process string is after that\n\n# Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        Deque<StringBuilder> strStack = new ArrayDeque<>();\n        Deque<Integer> intStack = new ArrayDeque<>();\n        \n        int k = 0;\n        strStack.offerFirst(new StringBuilder());\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                k = k * 10 + c - '0';\n            }\n            else if (c == '[') {\n                strStack.offerFirst(new StringBuilder());\n                intStack.offerFirst(k);\n                k = 0;\n            }\n            else if (c == ']') {\n                String preStr = strStack.pollFirst().toString();\n                int preK = intStack.pollFirst();\n                for (int i = 0; i < preK; i++) {\n                    strStack.peekFirst().append(preStr);\n                }\n            }\n            else {\n                strStack.peekFirst().append(c);\n            }\n        }\n        return strStack.pollFirst().toString();\n    }\n}\n```\n## Complexity\nTime: O(N)  N refers to length of input String\nSpace: O(N) ","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094194811","body":"## Idea\nTwo pointer: a and b pointing to headA and headB\nMove a and b forword with same pace until they are pointing to a same node\nIf one pointer reach to the end of the list, point it to the another head and go ahead.\nThey will reach to the intersection or to the null since they will both move the length of two lists\n\n## Code\n```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB== null) {\n            return null;\n        }\n        \n        ListNode a = headA;\n        ListNode b = headB;\n        while (a != b) {\n            a = a == null ? headB : a.next;\n            b = b == null ? headA : b.next;\n        }\n        return a;\n    }\n}\n```\n## Complexity\nTime: O(m+n)  m and n refers to the length of two lists\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094427757","body":"## Idea\nTwo pointer (slow & fast): traverse the list with different pace to find the meeting point\n(no cycle if fast pointer reach to the tail)\nLet head to first point into cycle be A; first point into cycle to meeting point B; meeting point to first point into cycle be C; Then 2(A+B) = A+B+C+B meaning A=C\nPut slow pointer to the head and traverse the list with same pace. \nWhen two pointer meet again, we got the first point into cycle. \n    \n## Code\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        \n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next; // diff pace\n            if (slow == fast) {\n                break; // meeting point\n            }\n        }\n        \n        if (fast == null || fast.next == null) { // if no cycle\n            return null;\n        }\n        \n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next; // same pace\n        }\n        return slow; // since A=C\n    }\n}\n```\n## Complexity\nTime: O(n)  n refers to the length of list\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raingolee":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086081768","body":"### 思路\n从低位开始（从右到左），两个位置的数相加，如果超过10，则增加一个标记位，下一个位置的数字相加之后加一，因为是不等长的，所以存在相同位置的数字为空时候则设置为0，切不需要设置标记位。\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091783926","body":"### 解题思路：\n计算链表的长度，并将尾指针指向头节点形成循环链表，将头指针右移链表长度-k后，再在头指针前一个节点形成断链\n\n### 复杂度\n时间复杂度O(N)\n\n### 实现\n```\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    if(head==NULL||head->next==NULL)\n        return head;\n    //判断链表是否为空或者为一个节点\n    int length=0;\n    //计算链表的长度\n    struct ListNode* rear=head;\n    while(rear->next!=NULL){\n        rear=rear->next;\n        length++;\n    }\n    //使尾指针指向最后一个节点，少算入最后一个节点的长度，因此循环结束后还需要长度加一\n    length++;\n    rear->next=head;\n    //使尾指针指向头节点，形成循环链表\n    k%=length;\n    //%运算，防止k值大于链表长度\n    for(int i=0;i<length-k;i++)\n        head=head->next;\n    //将头指针向右移动链表长度减去右移长度\n    while(rear->next!=head)\n        rear=rear->next;\n        rear->next=NULL;\n    //将尾指针指向头指针前一个节点，并进行断链\n    return head;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"all-sunday":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082274","body":"### 思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n\n### 代码\n\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n- 空间复杂度：O(max(n,k))，开辟了新数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086641183","body":"### 思路\r\n先遍历一次字符串s，获得字符串s种所有c的小标，并存在cIndexs数组；\r\n\r\n双层循环，外层遍历字符串s，内层遍历cIndexs数组，即将字符串s种每一个字字符的小标与所有的字符c小标分别求绝对值，所得值中最小的即为所求目标，存入结果answer数组。\r\n\r\n暂没有其他思路，就暴力求解了。😥\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] answer = new int[n];\r\n        int[] cIndexs = new int[n];\r\n        int cNum = 0;\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                cIndexs[cNum++] = i;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            int minDistance = n;\r\n            for(int j = 0; j < cNum; j++){\r\n                int distance = Math.abs(i - cIndexs[j]);\r\n                if(distance < minDistance){\r\n                    minDistance = distance;\r\n                }\r\n            }\r\n            answer[i] = minDistance;\r\n        }\r\n\r\n        return answer;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N^2)，双重循环，其中N为字符串s的长度。\r\n- 空间复杂度：O(N)，使用了额外的大小为字符串长度N的数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086893650","body":"### 思路\n用数组模拟栈的操作，top记录栈顶的位置。\n### 代码\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < stack.length - 1){\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top > -1){\n            int res = stack[top];\n            stack[top--] = 0;\n            return res;\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if(top < k - 1){\n            k = top + 1;\n        }\n        for(int i = 0; i < k; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：初始化、push、pop操作均为O(1)，inc操作为O(k)。\n- 空间复杂度：O(maxSize)，使用了额外长度为maxSize的数组stack。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087733546","body":"### 思路\r\n每个左括号对应一个子问题，通过递归调用函数解决；\r\n\r\n遇到'['，则递归调用，返回得到的字符串和当前处理到的下标，根据数字mutil得到新的res，并根据返回的下标i继续解析剩余字符串。\r\n### 代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n\r\n    private String[] dfs(String s, int i){\r\n        StringBuilder res = new StringBuilder();\r\n        int mutil = 0;\r\n        while(i < s.length()){\r\n            char c = s.charAt(i);\r\n            if(c >= '0' && c <= '9'){\r\n                mutil = mutil * 10 + Integer.parseInt(String.valueOf(c));\r\n            }else if(c == '['){\r\n                String[] temp = dfs(s, i + 1);\r\n                i = Integer.parseInt(temp[0]);\r\n                while(mutil > 0){\r\n                    res.append(temp[1]);\r\n                    mutil--;\r\n                }\r\n            }else if(c == ']'){\r\n                return new String[] {String.valueOf(i), res.toString()};\r\n            }else{\r\n                res.append(String.valueOf(c));\r\n            }\r\n            i++;\r\n        }\r\n        return new String[] {res.toString()};\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，实际上还是遍历。\r\n- 空间复杂度：O(N)，极端情况下，递归深度达到N。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088939342","body":"### 思路\n双栈，输入栈专门用于输入；\n\n输出栈用于pop和peek操作，如果输出栈为空，则将输入栈的元素全部压入输出栈，此时输出栈的输出顺序即为队列顺序；\n\n输入、输出栈均为空，则队列为空。\n### 代码\n```\nclass MyQueue {\n    private Stack<Integer> in;//输入栈\n    private Stack<Integer> out;//输出栈\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n       if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }\n       return out.pop(); \n    }\n    \n    public int peek() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)。\n- 空间复杂度：O(N)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090435914","body":"### 思路\n没得思路，我没看懂😥，下面是官方题解。\n### 代码\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(NlogN)，其中N为arr的长度。\n- 空间复杂度：O(N)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091915351","body":"### 思路\n计算出链表的长度n，并找到链表的尾节点，将其与头节点相连，得到闭合为环的链表；\n\n然后我们找到新链表的最后一个节点，将当前闭合为环的链表断开，即得结果。\n### 代码\n```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，遍历链表。\n- 空间复杂度：O(1)。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093035590","body":"### 思路\n遍历链表，每次借助temp节点交换两个节点，没有节点或只有一个节点。\n### 代码\n```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode res = new ListNode();\n        res.next = head;\n        ListNode temp = res;\n        while (temp.next != null && temp.next.next != null) {\n            ListNode node1 = temp.next;\n            ListNode node2 = temp.next.next;\n            temp.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            temp = node1;\n        }\n        return res.next;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，遍历一次链表。\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094072173","body":"### 思路\n没得思路，看的官方题解😢。\n### 代码\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)。\n- 空间复杂度：O(logn)，平衡二叉树的高度为O(logn)，即为递归过程中栈的最大深度，也就是需要的空间。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095231957","body":"### 思路\n遍历链表，通过哈希表记录遍历过的节点，如果节点再哈希表中已存在，则有环且该节点即为答案，否则无环。\n### 代码\n```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode node = head;\n        Set<ListNode> set = new HashSet<>();\n\n        while(node != null){\n            if(set.contains(node)){\n                return node;\n            }else{\n                set.add(node);\n            }\n            node = node.next;\n        }\n        return null;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，遍历链表。\n- 空间复杂度：O(n)，创建了哈希表。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086082862","body":"public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> result = new ArrayList<>();\n    int cur = k;\n    int i = num.length - 1;\n    while (i >= 0 || cur > 0) {\n        if (i >= 0) {\n            cur += num[i];\n        }\n        result.add(cur % 10);\n        cur /= 10;\n        i--;\n    }\n    Collections.reverse(result);\n    return result;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086663613","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092993516","body":"class Solution {\n    public ListNode swapPairs(ListNode head) {\n      ListNode dummpyHead=new ListNode(0);\n      dummpyHead.next=head;\n      ListNode temp=dummpyHead;\n      while(temp.next!=null&&temp.next.next!=null){\n        ListNode node1=temp.next;\n        ListNode node2=temp.next.next;\n          node1.next=node2.next;\n          node2.next=node1;\n          temp.next=node2;\n          temp=node1;\n      }\n      return dummpyHead.next;\n     \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086083587","body":"## 思路\n\n- 直接把k加到A中\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int i = A.size()-1;\n        while(K > 0){\n            A[i] += K;\n            K = A[i] / 10;\n            A[i--] %= 10;\n            \n            if(i < 0 && K > 0){\n                A.insert(A.begin(),0);\n                i = 0;\n            }\n        }\n        \n        return A;\n    }\n};\n```\n\n## 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hulichao":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086084672","body":"思路\n遍历数组，把k加到最后一个元素num[n]，把num[n]对10取余的余数加到结果res数组，对10取整后的结果重新赋给k；\n\n循环上一步操作倒数第二个元素，直至数组遍历完或k值不大于0，则把剩下的数组元素或k加到res数组;\n\n最后反转数组即可。\n\n代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        while(true){\n                if(n>0 && k>0){\n                    num[--n] += k;\n                    res.add(num[n] % 10);\n                    k = num[n] / 10;\n                }else if(n>0){\n                    res.add(num[--n]);\n                    \n                }else if(k>0){\n                    res.add(k%10);\n                    k /= 10;\n                    \n                }else{\n                    break;\n                }    \n\n            }\n            Collections.reverse(res);\n            return res;\n        }\n}\n复杂度分析\n\n时间复杂度：O(max(n,k))，其中 n 为数组长度，k为k的位数。\n空间复杂度：O(max(n,k))，开辟了新数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086667513","body":"### 思路\n关键点在于加一个变量，用来指出距离当前遍历到的字符的最左的目标字符的下标，和距离当前遍历到的字符的最右的目标字符的下标。\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int[] ans = new int[S.length()];\n        int pre = -100001;\n        //从左到右\n        for (int i = 0; i < S.length(); i++) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = i - pre;\n        }\n\n        pre = 100001;\n        for (int i = S.length() - 1; i >=0 ; i--) {\n            if (S.charAt(i) == C)\n                pre = i;\n            ans[i] = Math.min(ans[i], pre -i);\n        }\n\n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896250","body":"### 思路\n用个数组模拟栈就好了。\n\n### 代码\n\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top<stack.length-1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top==-1){\n            return -1;\n        }else{\n            return stack[top--];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k;i++){\n            if(i<=top){\n                stack[i] += val;\n            }else{\n                break;\n            }\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087681468","body":"### 思路\n使用两个栈 分别用来记录 数字 和 其他所有字符\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        // 使用两个栈 分别用来记录 数字 和 其他所有字符\n        Stack<Integer> stack_num = new Stack<>();\n        Stack<String> stack_string = new Stack<>();\n\n        char[] chars = s.toCharArray();\n        for(char ch: chars){\n            // 如遇到数字 进入数字栈\n            if (Character.isDigit(ch))\n                stack_num.push(ch - '0');\n\n            // 如遇到字母 进入其他栈\n            else if (Character.isAlphabetic(ch))\n                stack_string.push(String.valueOf(ch));\n\n            // 如遇到 [ 进入其他栈 并在数字栈做标记\n            else if (ch == '['){\n                stack_num.push(-1);\n                stack_string.push(String.valueOf(\"[\"));\n            }\n\n            // 遇到 ] 开始出栈进行拼接 后入栈\n            else{\n\n                // 新建一个 StringBuilder 来记录一次解码\n                StringBuilder tmp = new StringBuilder();\n\n                // 当栈不为空且 没有到本次解码的头 即 左括弧 [ 时 在 tmp 前面插入该字符（串）保证顺序\n                while (!stack_string.isEmpty() && !\"[\".equals(stack_string.peek()))\n                    tmp.insert(0, stack_string.pop());\n\n                // 遇到左括弧 弹出一次\n                stack_string.pop();\n\n                // 同时弹出数字栈的 标记 -1\n                stack_num.pop();\n\n                // cnt 用于计数括弧前的数字来判断括弧里面的字符串重复几次\n                int cnt = 0;\n                StringBuilder cntString = new StringBuilder();\n\n                // 求出重复次数\n                while (!stack_num.isEmpty() && -1 != stack_num.peek())\n                    cntString.insert(0, stack_num.pop());\n                cnt = Integer.parseInt(cntString.toString());\n\n                // 根据 cnt 次数来重复字符串\n                StringBuilder pushBack = new StringBuilder();\n                while(cnt-- > 0)\n                    pushBack.append(tmp);\n\n                // 重复以后再压入栈\n                stack_string.push(pushBack.toString());\n            }\n        }\n\n        // 当字符串遍历结束以后再用插入的方式汇总\n        StringBuilder sb = new StringBuilder();\n        while(!stack_string.isEmpty())\n            sb.insert(0, stack_string.pop());\n        return sb.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089055356","body":"\n  ### 思路\n模拟一下就可以了\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> a;// 输入栈\n    private Stack<Integer> b;// 输出栈\n    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n        // 如果b栈为空，则将a栈全部弹出并压入b栈中，然后b.pop()\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091909931","body":"### 思路\n先遍历求得链表总长度count，同时将链表首尾相连；\n再找到原链表的倒数第k+1个节点，该节点的next就是新链表的头结点。\n\n### 代码\n\n\n```java\n\npublic ListNode rotateRight(ListNode head, int k) {\n\tif (head == null || head.next == null || k == 0) return head;\n    \n    int count = 1; // 用来统计链表总结点数\n    ListNode tmp = head;\n    while (tmp.next != null) {\n        count++;\n        tmp = tmp.next;\n    }\n    k %= count;\n    // 当k为0时，不需要旋转，\n    if (k == 0) return head;\n    \n    // 不满足上述条件，必将进行旋转，所以先将首尾相连\n    tmp.next = head;\n    // 现在只需要找到倒数第k+1个节点\n    for (int i = 0; i < count - k; i++) {\n        tmp = tmp.next;\n    }\n    ListNode newHead = tmp.next;\n    tmp.next = null;\n    return newHead; \n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shin-guid":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086085454","body":"## 思路\r\n将A、K格式化为数组，反转，从低位开始相加，一直到最高位，注意处理进位\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const numArr = num.reverse();\r\n    const kArr = String(k).split('').reverse().map(Number);\r\n\r\n    let result = [];\r\n    let i = 0;\r\n    let curr = 0;\r\n    let carry = 0;\r\n    while(i < numArr.length || i < kArr.length || carry > 0) {\r\n        sum = (numArr[i] || 0) + (kArr[i] || 0) + carry;\r\n        curr = sum % 10;\r\n        carry = parseInt(sum / 10);\r\n        result[i] = curr;\r\n        i++;\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086661461","body":"## 思路\n1. 遍历字符串，找出所有c的索引，成为索引数组\n2. 遍历字符串，每个字符串遍历索引数组求绝对值，取最小\n\n## code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    // 转换为数组\n    // 遍历找出所有c的索引\n    // 遍历数组，比较距离，取最小值\n    const strArray = s.split('');\n    let cIndexArray = [];\n\n    strArray.forEach((s, i) => {\n        if (s === c) {\n            cIndexArray.push(i);\n        }\n    })\n    let result = [];\n    strArray.forEach((s, i) => {\n        let diff = Infinity;\n        cIndexArray.forEach((cIndex) => {\n            diff = Math.min(diff, Math.abs(cIndex - i));\n        })\n\n        result.push(diff);\n    })\n\n    return result;\n};\n\n## 复杂度\n\n- 时间复杂度：O(n2)\n- 空间复杂度：O(n)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/2#issuecomment-1086101381","body":"var addToArrayForm = function (num, k) {\r\n    let k_array = [];\r\n    let length_cal = 0;\r\n    let cal_array = [];\r\n    while (k > 0) {\r\n        let yu = k % 10;\r\n        k_array.unshift(yu);\r\n        k = (k - yu) / 10;\r\n    }\r\n\r\n    if (k_array.length < num.length) {\r\n        length_cal = num.length;\r\n        const len = k_array.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            k_array.unshift(0);\r\n        }\r\n    } else {\r\n        length_cal = k_array.length;\r\n        const len = num.length\r\n        for (let index = 0; index < length_cal - len; index++) {\r\n            num.unshift(0);\r\n        }\r\n    }\r\n\r\n    for (let index = 0; index < length_cal; index++) {\r\n        const m = num.pop();\r\n        const n = k_array.pop();\r\n        if (m + n >= 10) {\r\n            cal_array.unshift((m + n) % 10);\r\n            k_array[k_array.length - 1] = k_array[k_array.length - 1] + 1;\r\n            if (index === length_cal - 1) {\r\n                cal_array.unshift(1);\r\n            }\r\n        } else {\r\n            cal_array.unshift(m + n)\r\n        }\r\n    }\r\n\r\n    return cal_array;\r\n};\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086639124","body":"\n\n```JavaScript\nvar shortestToChar = function (s, c) {\n    let arr = s.split('');\n    for (let iterator in arr) {\n        if (arr[iterator] == c) {\n            arr[iterator] = 0\n        } else {\n            arr[iterator] = null;\n        }\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = 0; j < arr.length; j++) {\n            if (arr[j] === i) {\n                if (j > 0) {\n                    if (arr[j - 1] == null || arr[j - 1] > i + 1) {\n                        arr[j - 1] = i + 1;\n                    }\n                }\n                if (j < arr.length - 1) {\n                    if (arr[j + 1] == null || arr[j + 1] > i + 1) {\n                        arr[j + 1] = i + 1;\n                    }\n                }\n            }\n        }\n    }\n    return arr;\n};\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(N^2)\n\\- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086896296","body":"\n\n```JavaScript\nvar CustomStack = function (maxSize) {\n\n    this.stack = [];\n    this.maxSize = maxSize;\n\n    //for loop create array, value default null, size = maxSize\n    for (let index = 0; index < maxSize; index++) {\n        this.stack[index] = null;\n    }\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n\n    // stack's last one is not null, do not push\n    if (this.stack[this.maxSize - 1] !== null) {\n        return;\n    }\n\n    // for loop find the first index is null, push parameter at index\n    const indexCanPush = this.stack.findIndex(element => element === null);\n    this.stack[indexCanPush] = x;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    // find the first one (called lastOne) is not null from the tail of stack\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    // the index value of lastOne set to null, return last one\n    if (lastOne !== -1) {\n        this.stack[lastOneIndex] = null\n    }\n\n    return lastOne;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n\n    // from tail to head, find the first one is not null\n    const { lastOne, lastOneIndex } = this.lastOne();\n\n    for (let index = lastOneIndex; index >= 0 && k > 0; index--, k--) {\n        this.stack[lastOneIndex] += val;\n    }\n};\n\nCustomStack.prototype.lastOne = function () {\n\n    // from tail to head, find the first one is not null\n    let lastOne = -1;\n    let lastOneIndex = -1;\n    for (let tail = this.maxSize - 1; tail >= 0; tail--) {\n        if (this.stack[tail] !== null) {\n            lastOne = this.stack[tail];\n            lastOneIndex = tail;\n            return { lastOne, lastOneIndex };\n        }\n    }\n\n    return { lastOne, lastOneIndex };\n\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087640793","body":"```javascript\nvar decodeString = function(s) {\n\n    let numStack = []; \n    let strStack = []; \n    let temp = ''; \n    let num = 0; \n    for(let i = 0; i < s.length; i++) { \n        const c = s[i];\n        if(/\\d/.test(c)) { \n            num = num * 10 + (c.charCodeAt() - '0'.charCodeAt()); \n        } else if(c === '[') {\n            strStack.push(temp); \n            numStack.push(num); \n            num = 0;\n            temp = '';\n        } else if(c ===']') { \n            let repeatTimes = numStack.pop();\n            temp = strStack.pop() + temp.repeat(repeatTimes); \n        } else {\n            temp += c; \n        }\n    }\n\n    return temp;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088540596","body":"```javascript\nclass MyQueue {\n    stack: number[] = [];\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        const top = this.stack[0];\n        // this.stack.splice(0, 1);\n        for (let index = 1; index < this.stack.length; index++) {\n            this.stack[index - 1] = this.stack[index];\n        }\n        this.stack.pop();\n        return top;\n    }\n\n    peek(): number {\n        return this.stack[0]\n    }\n\n    empty(): boolean {\n        if (this.stack.length <= 0) {\n            return true;\n        }\n        return false;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090432330","body":"```javascript\nfunction maxChunksToSorted(arr: number[]): number {\n\n    let stack: number[] = [];\n\n    let headOutCount: number = 1;\n\n    stack.push(arr[0]);\n\n    for (let index = 1; index < arr.length; index++) {\n\n        if (stack[stack.length - 1] > arr[index]) {\n\n            stack.push(arr[index]);\n\n        } else if (stack[stack.length - 1] < arr[index]) {\n\n            while (stack[stack.length - 1] < arr[index]) {\n                stack.pop();\n            }\n\n            /*if (stack.length === 0) {\n                headOutCount++;\n            }*/\n\n        } else if (stack[0] === arr[index] && index === arr.length - 1) {\n            stack.pop();\n            headOutCount++;\n        }\n\n        if (stack.length === 0) {\n            stack.push(arr[index]);\n            headOutCount++;\n        }\n    }\n    return headOutCount;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091869146","body":"```javascript\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\n    let len: number = 0;\n    let point: ListNode = head;\n    let newHead: ListNode = head;\n    let newTail: ListNode;\n    let tail: ListNode;\n    const realK = k % len;\n\n    if (head === null || realK === 0) {\n        return head;\n    }\n\n    while (point) {\n        len++;\n        point = point.next;\n    }\n\n    for (let index = 0; index < len - realK; index++) {\n\n        newTail = newHead;\n        newHead = newHead.next;\n\n    }\n\n    tail = newHead;\n    while (tail.next) {\n        tail = tail.next;\n    }\n\n    newTail.next = null;\n    tail.next = head;\n\n    return newHead;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092987111","body":"```typescript\nfunction swapPairs(head: ListNode | null): ListNode | null {\n\n    if (head === null || head.next === null) {\n        return head;\n    }\n\n    let point: ListNode = head;\n    let newHead: ListNode = point.next;\n    point.next = newHead.next;\n    newHead.next = point;\n\n    let pre: ListNode = point;\n    point = pre.next;\n\n    let len: number = 1;\n    head = newHead;\n    while (head.next) {\n        head = head.next;\n        len++;\n    }\n\n    let odd: boolean = len % 2 === 0 ? false : true;\n    let loopCount: number = odd ? Math.floor(len / 2) - 1 : Math.floor(len / 2) - 2;\n\n    while (loopCount > 0) {\n        pre.next = point.next;\n        point.next = point.next.next;\n        pre.next.next = point;\n\n        pre = point;\n        point = pre.next;\n        loopCount--;\n    }\n\n    if (!odd && point !== null) {\n        pre.next = point.next;\n        pre.next.next = point;\n        point.next = null;\n    }\n\n    return newHead;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094062508","body":"```javascript\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    let tree_root: TreeNode = new TreeNode();\n    let data_arr = [];\n\n    if (head === null) {\n        return null;\n    }\n\n    while (head !== null) {\n        data_arr.push(head.val);\n        head = head.next;\n    }\n\n    convertBST(data_arr, tree_root, 0, data_arr.length);\n    return tree_root;\n\n};\n\nfunction convertBST(arr_tree: number[], root: TreeNode, start_position: number, convert_length: number) {\n    let left_length: number;\n    let right_length: number;\n    let tree_left: TreeNode = new TreeNode();\n    let tree_right: TreeNode = new TreeNode();\n    root.left = null;\n    root.right = null;\n\n    root.val = arr_tree[start_position + Math.floor(convert_length / 2)];\n    left_length = Math.floor(convert_length / 2);\n    right_length = convert_length - left_length - 1;\n    if (left_length > 0) {\n        root.left = tree_left;\n        convertBST(arr_tree, root.left, start_position, left_length);\n    }\n    if (right_length > 0) {\n        root.right = tree_right;\n        convertBST(arr_tree, root.right, start_position + left_length + 1, right_length);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094288621","body":"```typescript\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n\n    if (!headA || !headB) {\n        return null;\n    }\n\n    let len_a: number = 0;\n    let len_b: number = 0;\n    let point_a: ListNode | null = headA;\n    let point_b: ListNode | null = headB;\n    let cutLen: number = 0;\n\n    while (point_a) {\n        len_a++;\n        point_a = point_a.next;\n    }\n    while (point_b) {\n        len_b++;\n        point_b = point_b.next;\n    }\n\n    point_a = headA;\n    point_b = headB;\n\n    cutLen = Math.abs(len_a - len_b);\n    if (cutLen > 0) {\n        if (len_a > len_b) {\n            while (cutLen > 0) {\n                point_a = point_a!.next;\n                cutLen--;\n            }\n        }\n\n        if (len_a < len_b) {\n            while (cutLen > 0) {\n                point_b = point_b!.next;\n                cutLen--;\n            }\n        }\n    }\n\n    for (let index = 0; index < Math.min(len_a, len_b); index++) {\n        if (point_a !== point_b) {\n            point_a = point_a!.next;\n            point_b = point_b!.next;\n        } else {\n            return point_a;\n        }\n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095152566","body":"```javascript\nfunction detectCycle(head: ListNode | null): ListNode | null {\n\n    let cycleMap = new Map();\n    let point: ListNode | null = head;\n\n    while (point) {\n        if (!cycleMap.has(point)) {\n            cycleMap.set(point, 1);\n        } else {\n            return point;\n        }\n        point = point.next;\n    }\n    return null;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nancychien":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086268399","body":"思路：\r\n1. 找出目標 index 位置並 save to a target list\r\n2. loop through 原來的字串和target list 並計算最小距離\r\n`\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        target = []\r\n        output = []\r\n\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                target.append(i)\r\n\r\n        for i in range(len(s)):\r\n            output.append(min(abs(i-x) for x in target))\r\n\r\n        return output\r\n`\r\n\r\nTime complexity: O(n^2)\r\nSpace complexity:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086768346","body":"思路：\r\n用 list 去模擬出 stack 的操作\r\n`\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize  = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.maxSize: \r\n            return -1\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: \r\n            return -1\r\n        res = self.stack.pop()\r\n        self.cur_size -= 1\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.cur_size, k)): \r\n            self.stack[i] += val\r\n`\r\nTime Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(N)\r\nSpace Complexity:\r\n- push: O(1)\r\n- pop: O(1)\r\n- increment: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088111025","body":"### 思路\r\nUse two stacks. One for pushing (stack_push), one for popping (stack_pop)\r\n`\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack_push = []\r\n        self.stack_pop = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_push.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        # stack_pop is empty\r\n        if not self.stack_pop: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n        result = self.stack_pop.pop()\r\n        return result\r\n        \r\n    def peek(self) -> int:\r\n        if self.empty(): \r\n            return -1\r\n        if self.stack_pop: \r\n            return self.stack_pop[-1]\r\n        else: \r\n            while self.stack_push: \r\n                tmp = self.stack_push.pop()\r\n                self.stack_pop.append(tmp)\r\n            return self.stack_pop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack_push and not self.stack_pop\r\n`\r\n\r\nTime complixiety:\r\npush - O(1)\r\npop  - O(n)\r\npeek - O(n)\r\nempty - O(1)\r\nSpace complixiety:\r\npush - O(n)\r\npop  - O(1)\r\npeek - O(1)\r\nempty - O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090780574","body":"思路:\n1. Find the old tail and connect it with the head (old_tail.next = head) to close the ring. Compute the length of the list n at the same time\n2. Find the new tail, which is (n - k % n - 1)th node from the head and the new head, which is (n - k % n)th node\n3. Break the ring new_tail.next = None and return new_head.\n\n`\nclass Solution:\n   def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: \n            return None\n        if not head.next: \n            return head\n        \n        cnt = 1\n        \n        slow, fast = head, head\n        \n        while fast.next:\n            fast = fast.next\n            cnt += 1\n        fast.next = head # circle the list\n        \n        for i in range(cnt - k%cnt - 1):\n            slow = slow.next\n        new_head = slow.next    \n        slow.next = None\n        \n        return new_head\n`\nTime complexity : O(N) \nSpace complexity : O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092545241","body":"思路：Iterative\n1. 兩個為一單位： firstNode and secondNode\n2. Swap the two nodes. The swap step is\n    firstNode.next  = secondNode.next\n    secondNode.next = firstNode\n3. We also need to assign the prevNode's next to the head of the swapped pair. This step would ensure the currently swapped pair is linked correctly to the end of the previously swapped list\n```\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Dummy node acts as the prevNode for the head node\n        # of the list and hence stores pointer to the head node.\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        prev_node = dummy\n\n        while head and head.next:\n\n            # Nodes to be swapped\n            first_node = head;\n            second_node = head.next;\n\n            # Swapping\n            prev_node.next = second_node\n            first_node.next = second_node.next\n            second_node.next = first_node\n\n            # Reinitializing the head and prev_node for next swap\n            prev_node = first_node\n            head = first_node.next\n\n        # Return the new head node.\n        return dummy.next\n```\nTime complexity: O(n)\nSpace Complexity: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094164929","body":"思路:\n    用 hash table 先存一遍 list B. If we find the node pointed to by headA in our set containing nodes of B, \n    then return the node. If nothing, then return null\n```\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        nodes_in_B = set()\n\n        while headB is not None:\n            nodes_in_B.add(headB)\n            headB = headB.next\n\n        while headA is not None:\n            if headA in nodes_in_B:\n                return headA\n            headA = headA.next\n\n        return None\n```\nTime: O(m+n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086420045","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; //create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store \r\n\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087119592","body":"### 代码\n```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        String str = recursive(s);\n        return str;\n    }\n\n    public String recursive(String s){\n        StringBuilder sb = new StringBuilder();\n        while(index < s.length()){\n            char cur = s.charAt(index);\n            index++;\n            if(cur >= '0' && cur <= '9'){\n                int num = cur - '0';\n                while(s.charAt(index) >= '0' && s.charAt(index) <= '9'){\n                    num = num * 10 + s.charAt(index) - '0';\n                    index++;\n                }\n                String str = recursive(s);\n                for(int i = 0; i < num; i++){\n                    sb.append(str);\n                }\n            }else if(cur == '['){\n                \n            }else if(cur == ']'){\n                break;\n            }else{\n                sb.append(cur);\n            }\n        }\n        return sb.toString();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pureryudo":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086506715","body":"### 思路\n\n进行两次遍历\n\n使用prev记录上一次出现的c的位置，初始值设为极小的负数。\n\n第一次从左到右遍历，记录当前位置i到prev的绝对值。\n\n第二次从右到左遍历，记录当前位置i到prev的绝对值，并与第一次遍历的结果取min存入结果数组，\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n    int[] result = new int[s.length()];\n    char[] chars = s.toCharArray();\n    /*记录当前遍历中上一个c出现的位置\n        初始值设置为极小的负数用于在比较时获得正确的值*/\n    int prev = Integer.MIN_VALUE/2;\n    /*第一次遍历 从左到右 记录与上一个c的距离*/\n    for (int i = 0; i < chars.length; i++){\n        //还没有出现过c\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.abs(i-prev);\n    }\n    /*第二次遍历 从右到左 记录与上一个c的距离*/\n    prev = -1;\n    for (int i = chars.length-1; i >= 0; i--){\n        if (chars[i] == c){\n            prev = i;\n        }\n        result[i] = Math.min(result[i],Math.abs(prev-i));\n    }\n    return result;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N) N为数组长度\n\n额外空间复杂度：O(N) 新建了一个长度为N的数组用于存放结果","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091157320","body":"### 思路\n\n1. 找到尾结点 和 首节点相连组成一个循环链表。\n2. 若k>length 则k=k%length 这是head向左移动的次数，等同于向右移动length-k次。找到移动后的首节点。\n3. 再由length找到移动后的尾结点，将尾结点的next=null。断开。\n\n### 代码\n\n```java\npublic static ListNode rotateRight(ListNode head, int k) {\n    if (k == 0 || head == null || head.next == null){\n        return head;\n    }\n    //找到最后一个节点 连上首节点\n    ListNode temp = head;\n    ListNode result = null;\n    int length = 1;\n    while (temp.next != null){\n        temp = temp.next;\n        length++;\n    }\n    temp.next = head;\n    //n为head向右移动的次数\n    if (k >length){\n        k=k%length;\n    }\n    int n = length-k;\n    int i = 1;\n    temp = head;\n    while (i <= n){\n        temp = temp.next;\n        i++;\n    }\n\n    ListNode resultHead = temp;\n    temp = resultHead;\n    //从head数length个得到尾结点 断开\n    i = 1;\n    while (i < length){\n        temp = temp.next;\n        i++;\n    }\n    temp.next = null;\n\n    return resultHead;\n}\n```\n\n### 复杂度分析\n\n时间复杂度：O(N)\n\n额外空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092371708","body":"### 思路\n\n使用pre next1 next2指针记录当前指针的前一个，下一个和下下一个结点。\n\n当前指针每次走两步。\n\n需要注意pre为null 和 剩下的是单个结点的情况。\n\n### 代码\n\n```java\npublic static ListNode swapPairs(ListNode head) {\n    if (head == null){\n        return null;\n    }\n    ListNode result = null;\n    ListNode temp = head;\n    ListNode pre = null;\n    ListNode next1 = null;\n    ListNode next2 = null;\n    while (temp != null){\n        next1 = temp.next;\n        if (pre == null){\n            result = next1;\n        }else {\n            pre.next = next1;\n        }\n        if (next1 == null){\n            if (pre != null){\n                pre.next = temp;\n            }else {\n                result = temp;\n            }\n            return result;\n        }else {\n            next2 = next1.next;\n        }\n        next1.next = temp;\n        temp.next = next2;\n        pre = temp;\n        temp = next2;\n    }\n    return result;\n}\n```\n\n\n\n### 复杂度分析\n\ntime: O(N)\n\nspace:O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094729263","body":"### 思路\n\n首先，快慢指针第一次相遇时，慢指针一定是一圈都没有走完的。\n\n<img src=\"https://assets.leetcode-cn.com/solution-static/142/142_fig1.png\" alt=\"fig1\" style=\"zoom: 33%;\" />\n\na为head到环入口的距离，b为环入口到第一次相遇的距离，b+c是环的长度。\n$$\n相遇时快慢指针走的距离： \\\\\nslow=a+b \\quad\nfast=a+n(b+c) \\qquad n为快指针走的圈数 \\\\\nfast = 2*slow\t\\\\\n可得：a = n(b+c)-b = (n-1)(b+c) + c\t\n$$\n在slow和fast的第一次相遇时，使用temp指向head。head和slow同时开始移动，他们必定会在环入口处相遇，因为此时slow要走(n-1)个完整的环再加c，正好到环入口，距离也是a。\n\n### 代码\n\n```java\npublic ListNode detectCycle(ListNode head) {\n    if (head == null || head.next == null){\n        return null;\n    }\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null){\n        slow = slow.next;\n        if (fast.next == null){\n            return null;\n        }else {\n            fast = fast.next.next;\n        }\n\n        if (slow == fast){\n            ListNode temp  = head;\n            while (temp != slow){\n                temp = temp.next;\n                slow = slow.next;\n            }\n            return temp;\n        }\n    }\n    return null;\n}\n```\n\n### 复杂度分析\n\ntime：O(N)\n\nspace：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoliz":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086560188","body":"思路:   先查遍历找出C值对应的下标索引存储includesIndex中， 在进行一次循环 当前值等于C那么距离直接为0，内部进行二次循环 includesIndex arr 进行绝对值计算 \n\n\nvar shortestToChar = function(s, c) {\n\n    let includesIndex = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            includesIndex.push(i)\n        }\n    }\n\n    var res = Array(s.length).fill(0);\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0;\n            continue;\n        }\n\n        for(let val of includesIndex ) {\n            const dist = Math.abs(val - i)\n            \n            if (dist >= res[i]) break;\n            res[i] = dist;\n        }\n    }\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086754886","body":"### 思路\r\n数组实现栈\r\n\r\n### 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.number = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.number > this.stack.length) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(!this.stack.length) return -1;\r\n    return this.stack.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for( let i = 0; i < this.stack.length; i++) {\r\n        if (i < k) {\r\n            this.stack[i] += val\r\n        }   \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度： push:O(1)、pop：O(1)  O(N)  N:  是k，需增量元素个数\r\n- 空间复杂度  O(N)   N: maxSize\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088188139","body":"### 思路\n看到这个题型首先想到数组增删改查\n\n### 代码\n```javascript\nvar MyQueue = function() {\n    this.tasck = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    return this.tasck.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.tasck.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.tasck.slice(0, 1)\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n   return !this.tasck.length;\n};\n```\n\n### 复杂度分析\n- 时间复杂度: O(1)\n- 空间复杂度: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090405003","body":"\n## 题目地址(768. 最多能完成排序的块 II)\n\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\n\n## 题目描述\n\n```\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\n\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n\n\n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n\n注意:\n\narr的长度在[1, 2000]之间。\narr[i]的大小在[0, 10**8]之间。\n```\n\n## 前置知识\n\n-Aarry\n\n\n## 思路\n两个数组进行对比，新创建一个sort后的数组，两个数组进行遍历进行自加，如果相等count累加计数\n\n## 代码\n\n- 语言支持：JavaScript\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sorted = [...arr]\n    sorted.sort((a, b) => {\n        return a - b\n    })\n    \n    console.log(sorted, 'sorted')\n\n    let count = 0;\n    let sum1 = 0;\n    let sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i]\n        sum2 += sorted[i]\n\n        if(sum1 === sum2) {\n            count++\n            sum1 = 0;\n            sum2 = 0;  \n        }\n    }\n\n    return count;\n};\n\n```\n\n\n**复杂度分析**\n n 为数组长度。\n\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091814214","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n \n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n## 前置知识\n\n- \n\n\n## 思路\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head ||!head.next) return head;\n    let count = 0;\n    let now = head;\n\n    while(now) {\n        now = now.next;\n        count++;\n    }\n    k = k % count;\n\n    let slow = (fast = head);\n    while (fast.next) {\n        if(k-- <= 0) {\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n\n    let res = slow.next;\n    slow.next = null;\n\n    return res\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092961436","body":"\n## 题目地址(61. 旋转链表)\n\nhttps://leetcode-cn.com/problems/rotate-list/\n\n## 题目描述\n\n```\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n\n \n\n示例 1：\n\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n\n示例 2：\n\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n提示：\n\n链表中节点的数目在范围 [0, 500] 内\n-100 <= Node.val <= 100\n0 <= k <= 2 * 109\n```\n\n\n## 思路\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (!head ||!head.next) return head;\n    let count = 0;\n    let now = head;\n\n    while(now) {\n        now = now.next;\n        count++;\n    }\n    k = k % count;\n\n    let slow = (fast = head);\n    while (fast.next) {\n        if(k-- <= 0) {\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n\n    let res = slow.next;\n    slow.next = null;\n\n    return res\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenliangchen":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086565399","body":"## 思路：\r\n先从左边遍历，每次遍历中 先找到对应的目标的下标，在过程中利用i的下标去减去最小值的二分之一，（目的是在没找到的情况下，通过减去最小值留下一个最大数值，最小值为负数 i - -则变为加法）。之后进行右边遍历，同理，在过程中进行大小的比较。对比两次遍历最小的值是哪个，这样即可得到正确答案。\r\n\r\n用最小值的目的是为了避免溢出\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] ans = new int[len];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n - 时间复杂度：O(N)\r\n - 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086770200","body":"## 思路\r\n利用数组进行数据的存储，在push和pop时判断情况，并记录下标和最大容量\r\n\r\n## 代码\r\n\r\n```\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：push 和 pop 操作的时间复杂度为 O(1)，其余为O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087238550","body":"## 思路\r\n维护一个栈 和临时链表来进行括号匹配和字符串储存，当遇到右括号开始pop计算后形成新字符串，然后重新入栈\r\n\r\n\r\n## 代码\r\n```\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder();\r\n        Stack<Character> st = new Stack<>();\r\n        for(int i = 0; i < len;i++){\r\n            \r\n            char t = s.charAt(i);\r\n            if(t == ']'){                   \r\n                List<Character> temp = new ArrayList<>();\r\n                while(st.peek()!='['){\r\n                    temp.add(st.pop());\r\n                   } \r\n                \r\n                    st.pop(); // remove the '['\r\n                    int base =1;\r\n                    int k = 0;\r\n                    while( !st.empty() && Character.isDigit(st.peek() )){\r\n                         k = k + (st.pop() - '0' ) * base;\r\n                         base *= 10;\r\n                    }\r\n\r\n                    while(k!=0){\r\n                        for(int j = temp.size() -1; j >=0;j--){\r\n                            st.push(temp.get(j));\r\n                        }\r\n                        k--;\r\n                    }\r\n                \r\n            }else{\r\n                st.push(t);\r\n            }\r\n        \r\n        }\r\n        char[] ans = new char[st.size()];\r\n        int j = st.size()-1;\r\n        while(!st.empty()){\r\n            ans[j] = st.pop();\r\n            j--;\r\n        }\r\n\r\n        \r\n        return new String(ans);\r\n    }\r\n}\r\n\r\n```\r\n## 复杂度\r\n - 时间 O(K*K *N) \r\n - 空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088372686","body":"## 思路\r\n维护两个栈，一个专门用来入，另一个在出时负责倒一下。\r\n\r\n## 代码\r\n\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> st;\r\n    Stack<Integer> ans;\r\n    int f;\r\n\r\n    public MyQueue() {\r\n        st = new Stack<>();\r\n        ans = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(st.empty()){\r\n            f =x;\r\n        }\r\n        \r\n        st.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(ans.empty()){\r\n            while(!st.empty()){\r\n                ans.push(st.pop());\r\n            }\r\n        }\r\n        return ans.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(!ans.empty()) return ans.peek();\r\n        \r\n        return f;\r\n    }\r\n    \r\n    public boolean empty() {\r\n\r\n        \r\n        return ans.empty() && st.empty();\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间  push: O(1) peek: O(n) pop: O(n) empty: O(1)\r\n- 空间   O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090121730","body":"## 思路\r\n用数组的差进行维护\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n                 int[] Left_max = new int[arr.length];\r\n        int[] right_min = new int[arr.length];\r\n        \r\n         //LEFT MAX array\r\n        Left_max[0]=arr[0];\r\n        for(int i=1;i<arr.length;i++){\r\n            if(arr[i]>Left_max[i-1]){\r\n                Left_max[i]=arr[i];\r\n            }else{\r\n               Left_max[i]=Left_max[i-1];\r\n            }\r\n        }\r\n        \r\n        //Right min Array\r\n        right_min[arr.length-1]=arr[arr.length-1];\r\n        for(int i=arr.length-2;i>=0;i--){\r\n            if(arr[i]<right_min[i+1]){\r\n                right_min[i]=arr[i];\r\n            }else{\r\n                right_min[i]=right_min[i+1];\r\n            }\r\n        }\r\n        \r\n        int chunk=1; \r\n        for(int i=0;i<arr.length-1;i++){\r\n            if(Left_max[i]<=right_min[i+1]){\r\n                chunk++;\r\n            }\r\n        }\r\n        return chunk;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n - 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091428737","body":"## 思路\r\n先统计有多少个数据，再通过k%len 得到需要的步数。使用双指针进行快慢K，来达到效果\r\n\r\n## 代码\r\n\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        int len = 0;\r\n        ListNode p = head;\r\n        while(p != null){\r\n            p = p.next;\r\n            len++;\r\n        }\r\n        \r\n        k = k % len;\r\n        ListNode s = head, f = head;\r\n        \r\n        while(f.next!=null){\r\n            \r\n            if( k <= 0){\r\n                s= s.next;\r\n                \r\n            }\r\n            k--;\r\n            f= f.next;\r\n                \r\n        }\r\n        f.next = head;\r\n        ListNode res  = s.next;\r\n        s.next = null;\r\n        return res;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092458658","body":"## 思路\r\n从原始链表的头节点开始递归。\r\n\r\n每个递归调用负责交换一对节点。让我们用firstNode和secondNode来表示要交换的两个节点。\r\n\r\n下一次递归是通过调用具有下一对节点头的函数来进行的。如果链表中还有节点，这个调用将交换接下来的两个节点，并进行进一步的递归调用。\r\n\r\n一旦我们从递归调用中获得指向剩余交换列表的指针，我们就可以交换firstNode和secondNode，即当前递归调用中的节点，然后将指针返回到secondNode，因为它将是交换后的新头。\r\n\r\n## 代码\r\n\r\n\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n\r\n        // If the list has no node or has only one node left.\r\n        if ((head == null) || (head.next == null)) {\r\n            return head;\r\n        }\r\n\r\n        // Nodes to be swapped\r\n        ListNode firstNode = head;\r\n        ListNode secondNode = head.next;\r\n\r\n        // Swapping\r\n        firstNode.next  = swapPairs(secondNode.next);\r\n        secondNode.next = firstNode;\r\n\r\n        // Now the head is the second node\r\n        return secondNode;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间O(N) \r\n- 空间O(N) \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093771848","body":"## 思路\r\n用双指针方法来找出链表的中间元素, 断开中间元素左边的链表部分 作为左子树，同理右半边为右子树。\r\n## 代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        ListNode mid = findMid(head);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        \r\n        if(head == mid){\r\n            return root;\r\n        }\r\n        \r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(mid.next);\r\n\r\n        \r\n        return root;\r\n        \r\n    }\r\n    \r\n    private ListNode findMid(ListNode head){\r\n        ListNode s = head, p = null, f = head;\r\n\r\n        while(f!=null && f.next!=null){\r\n            p = s;\r\n            s = s.next;\r\n            f = f.next.next;\r\n        \r\n        }\r\n        \r\n        if(p!=null){\r\n            p.next = null;\r\n        }\r\n        \r\n        return s;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n## 复杂度\r\n-TC: O(N logN)\r\n-SC: O(Log N)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094178687","body":"## 思路\r\n双指针遍历，遇到相同即为相交\r\n## 代码\r\n\r\n```\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094549058","body":"## 思路\r\n直接HashSet添加，如果遇到重复就返回，遇不到就返回空\r\n\r\n## 代码\r\n\r\n```\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> ans = new HashSet<>();\r\n        if(head == null) return null;\r\n        while(head.next!=null){\r\n            if(ans.contains(head)){\r\n                return head;\r\n            }else{\r\n                ans.add(head);\r\n                head = head.next;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\ntime complexity: O(N)\r\nspace complexity: O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086566581","body":"4.2算法题：\nIdea：\n1.找到指定字符在目标字符串的下标并放进一个数组记录。\n2.循环比较字符串中每个字符距离和指定字符的距离，记录下较小的一个，放入另一个数组。\n\nCode：\n\nvar shortestToChar = function(s, c) {\n    var nearstXb = [];\n    var absDis = [];\n\n    for(var i=0;i<s.length;i++){\n      if(s[i] == c){\n      nearstXb.push(i);}    \n    };\n\n    for(var i=0;i<s.length;i++){\n        var min2 = s.length;\n        for(var j=0;j<nearstXb.length;j++){\n            var min1 = Math.abs(i-nearstXb[j])\n            if(min1<min2){\n               min2 = min1;}\n        }\n        absDis.push(min2);\n    }\n\n    return absDis;\n\n}\n \n时间复杂度：O(N^2)\n空间复杂度：（1）\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088765863","body":"Idea: 双栈对放思路，彼此为镜像，出栈时先将1栈的数压入2栈，再将2栈打印，即可实现。\n\nCode:\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out();\n    }\n    return this.outStack[this.outStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n\n  \nComplexity:\n时间：O(n）,空间：O（1）\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092375537","body":"Idea: 采用递归的方法进行两两转换，首先是针对头节点来说如果本身为空或者下一个为空，则直接返回（对于后续迭代的话的意思就是当剩下的只有一个节点或无节点时，结束迭代）\n单次迭代：首先是把将newHead赋为Head的next节点，\n再对head的下一个节点进行递归操作（此时head即将变为第二个节点）\n此时迭代的对象是newhead的下一个（就是head的下一个的下一个节点，第二组进行交换的节点）\n最后将newhead转为新头节点，下一个是head。\n\nCode：\nvar swapPairs = function(head) {\n    if (head === null|| head.next === null) {\n        return head;\n    }\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head;\n    return newHead;\n\n};\n\nComplexity：\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086582373","body":"### 思路\n\n第一想法是以当前字符为中心，然后向左右两边搜索，搜索到的第一个C即可得到当前字符到C的最小距离。\n但是这样的算法复杂度是O(N^2)\n\n第二想法是首先将C在S中的索引全部找出来，这样就可以用当前字符的索引直接减到C的索引，从而得到一个最小值\n这样的算法复杂度就是O(N)。下面的代码是这个想法的实现。\n\n后来又看了一下官方的题解，发现是遍历正、反二次就可以解决了。果然是我太菜了。。。。。。\n\n### 代码\n\n\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，最坏时，C和S的长度一样","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086797464","body":"### 思路\n粗看还蛮简单的，直接使用数组来模拟，push和pop操作都在数组尾操作，时间上都是O(1)，inc操作是O(k)\n按此实现并提交，发现只击败40%，看来还有改进空间。\n\npush和pop都已经是O(1)了，那就只有inc可以改进。一时想不出来，查看是解后，发现只记录增量及位置，\n直到需要返回的栈顶元素的时候才计算真实的值，这样每个pop操作也只计算一次，不影响pop的执行效率。\n按此方法，inc的执行效率也改进为O(1)。\n\n### 代码\n\n\n```Go\ntype CustomStack struct {\n    data []int\n    add []int\n    idx int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{data: make([]int, maxSize), add: make([]int, maxSize), idx: 0}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.hasSpace() {\n        this.data[this.idx] = x\n        this.idx++\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if !this.hasElement() {\n        return -1\n    }\n    \n    this.idx--\n    element := this.data[this.idx] + this.add[this.idx]\n\n    if this.idx > 0 {\n        this.add[this.idx - 1] += this.add[this.idx]\n    }\n    this.add[this.idx] = 0\n\n    return element\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    // for i := 0; i < this.idx && i < k; i++ {\n        // this.data[i] += val\n    // }\n    if !this.hasElement() {\n        return\n    }\n\n    if k >= this.idx {\n        this.add[this.idx - 1] += val\n    } else {\n        this.add[k - 1] += val\n    }\n}\n\nfunc (this *CustomStack) hasSpace() bool {\n    return this.idx < cap(this.data)\n}\n\nfunc (this *CustomStack) hasElement() bool {\n    return this.idx > 0\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(N), N为栈最大空间。因为需要一个额外的辅助数组add","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087604329","body":"### 思路\n一开始没看到有嵌套的情况，我还想这个题还蛮简单的，写出来的第一版当然不通过。\n第二版将待解析的字符串先入栈，碰到右括号才弹出，这样可以解析出最内层的字符串。\n若还有外层的字符串未解析，则继续将解析出来内层字符串写回到栈中，若已经到达最\n外层了，则可以将此解析后字符串写到结果中\n\n### 代码\n\n\n```Go\n\nfunc decodeString(s string) string {\n\tvar ret bytes.Buffer\n\tvar cache []byte\n\n\tfindRepeatNumString := func() (int, int, int, int) {\n\t\tnumBegin, numEnd, sBegin, sEnd  := -1, -1, -1, -1\n\n\t\tsEnd = len(cache) - 1\n\t\tfor j := sEnd; j >=0; j-- {\n\t\t\tif numEnd == -1 && cache[j] >= '0' && cache[j] <= '9' {\n\t\t\t\tsBegin = j + 2\n\t\t\t\tnumEnd = j + 1\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif numEnd != -1 && (cache[j] < '0' || cache[j] > '9') {\n\t\t\t\tnumBegin = j + 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif numBegin == -1 {\n\t\t\tnumBegin = 0\n\t\t}\n\n\t\treturn numBegin, numEnd, sBegin, sEnd\n\t}\n\n\tdecodeSubString := func() {\n\t\tvar subString bytes.Buffer\n\n\t\tnumBegin, numEnd, sBegin, sEnd := findRepeatNumString()\n\t\tnum, _ := strconv.Atoi(string(cache[numBegin:numEnd]))\n\t\tfor i := 0; i < num; i++ {\n\t\t\tsubString.Write(cache[sBegin:sEnd])\n\t\t}\n\n\t\tif numBegin == 0 {\n\t\t\tret.Write(subString.Bytes())\n\t\t\tcache = cache[:0]\n\t\t} else {\n\t\t\tcache = append(cache[:numBegin], subString.Bytes()...)\n\t\t}\n\t}\n\n\tfor i := 0; i < len(s); i++ {\n\t\tif len(cache) == 0 && s[i] >= 'a' && s[i] <= 'z' {\n\t\t\tret.WriteByte(s[i])\n\t\t\tcontinue\n\t\t}\n\n\t\tcache = append(cache, s[i])\n\t\tif s[i] == ']' { decodeSubString() }\n\t}\n\n\treturn ret.String()\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：如果没有嵌套的情况，时间复杂度应该是O(S)，即解码后的长度。嵌套的情况我也不太确定\n- 空间复杂度：O(S)，即解码后的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088203400","body":"### 思路\n\n见代码\n\n### 代码\n\n\n```Go\ntype MyQueue struct {\n\tinput *MyStack\n\toutput *MyStack\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tinput: new(MyStack),\n\t\toutput: new(MyStack),\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.input.Push(x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\t// 题目保证不会在空的栈上面调用pop/peek\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Pop()\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Peek()\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif this.input.Size() != 0 || this.output.Size() != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (this *MyQueue) inputToOutput() {\n\tfor !this.input.IsEmpty() {\n\t\tthis.output.Push(this.input.Pop())\n\t}\n}\n\ntype MyStack struct {\n\tdata []int\n}\n\nfunc (receiver *MyStack) Pop() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\n\tv := receiver.data[len(receiver.data) - 1]\n\treceiver.data = receiver.data[:len(receiver.data) - 1]\n\treturn v\n}\n\nfunc (receiver *MyStack) Peek() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\n\treturn receiver.data[len(receiver.data) - 1]\n}\n\nfunc (receiver *MyStack) Push(v int) {\n\treceiver.data = append(receiver.data, v)\n}\n\nfunc (receiver *MyStack) Size() int {\n\treturn len(receiver.data)\n}\n\nfunc (receiver *MyStack) IsEmpty() bool {\n\treturn len(receiver.data) == 0\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty是O(1)。pop和peek由于有一个遍历动作，看上去是N(N), 但是随后的pop/peek就是O(1)了，所以，平摊一下的话，应该就是O(1)。综上，平均时间复杂度为O(1)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091768715","body":"### 思路\n\n先计算链表长度，与k取模后得到真正需要旋转的次数，但是并不需要真的旋转这么多次。\n而是利用快慢指针直接找到旋转n次后的那个新的头节点，从该处断后，最后将原链表尾\n指向原链表头即可\n\n### 代码\n\n\n```Go\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil {return head}\n\n\tvar listLen int\n\tvar p1 = head\n\tfor p1 != nil {\n\t\tlistLen++\n\t\tp1 = p1.Next\n\t}\n\n\tdiff := k % listLen\n\tif diff == 0 {\n\t\treturn head\n\t}\n\tp2 := head\n\tp1 = head\n\tfor i := 0; i < diff; i++ {\n\t\tp1 = p1.Next\n\t}\n\tfor p1.Next != nil {\n\t\tp1 = p1.Next\n\t\tp2 = p2.Next\n\t}\n\n\tnewHead := p2.Next\n\tp2.Next = nil\n\tp1.Next = head\n\treturn newHead\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092916730","body":"### 思路\n\n见代码中的描述\n\n### 代码\n\n\n```Go\nfunc swapPairs(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\n\tnewHead := head.Next\n\t// 交换之前\n\t// ... -> 3 -> 4 -> 5 ->   6 -> 7 -> ...\n\t//        ^    ^    ^      ^\n\t//        l    p   pp     ppp\n\t// 交换之后\n\t// ... -> 3 -> 5 -> 4 ->   6 -> 7 -> ...\n\t//             ^    ^      ^    ^\n\t//             l    p      pp   ppp\n\tvar l *ListNode\n\tp := head\n\tpp := p.Next\n\tppp := pp.Next\n\tfor {\n\t\tp.Next = ppp\n\t\tpp.Next = p\n\t\tif l != nil {\n\t\t\tl.Next = pp\n\t\t}\n\t\tl = p\n\n\t\tif ppp == nil {\n\t\t\tbreak\n\t\t}\n\t\tp = ppp\n\t\tpp = p.Next\n\t\tif pp == nil {\n\t\t\tbreak\n\t\t}\n\t\tppp = pp.Next\n\t}\n\n\treturn newHead\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093600210","body":"### 思路\n\n有二种基本思路：<br>\n1. 将链表转换为数组，然后按二分法进行递归<br>\n2. 不转换为链表，每次都遍历链表找中点，按中点分为左右二个子链表递归<br>\n<br>\n第一种思路相当于使用空间换时间，时间复杂度为O(N) + O(N) = O(N)，第一O(N)为转换为链表的过程，第二个为构造树的过程<br>\n第二种思路的时间复杂度为O(NlogN)\n\n### 代码\n\n\n```Go\nfunc sortedListToBST(head *ListNode) *TreeNode {\n\tvar buildBST func([]int) *TreeNode\n\tbuildBST = func(data []int) *TreeNode {\n\t\tif data == nil || len(data) == 0 {return nil}\n\n\t\trootIdx := len(data) / 2\n\t\troot := &TreeNode{Val: data[rootIdx]}\n\t\tif rootIdx > 0 {\n\t\t\troot.Left = buildBST(data[:rootIdx])\n\t\t}\n\t\tif rootIdx < len(data) - 1 {\n\t\t\troot.Right = buildBST(data[rootIdx + 1:])\n\t\t}\n\n\t\treturn root\n\t}\n\n\tvar arr []int\n\tfor head != nil {\n\t\tarr = append(arr, head.Val)\n\t\thead = head.Next\n\t}\n\treturn buildBST(arr)\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094159652","body":"### 思路\n\n利用这样一条性质：若相遇，则经过的路径长度必相等\n\n### 代码\n\n\n```Go\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\n    var aHead, bHead = headA, headB\n    for aHead != nil && bHead != nil {\n        if aHead == bHead {return aHead}\n        aHead = aHead.Next\n        bHead = bHead.Next\n\n        if aHead == nil && bHead != nil {\n            aHead = headB\n        } else if bHead == nil && aHead != nil {\n            bHead = headA\n        }\n    }\n    return nil\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N+M)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winrunwang":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086593212","body":"思路:\n遍历一次，用2个临时变量存储指针信息。中间第二个for循环调整距离问题\npublic int[] shortestToChar(String s, char c) {\n        int first = -1;\n        int temp = -1;\n        int n  = s.length();\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            char t = s.charAt(i);\n            if(t == c){\n                res[i] = 0;\n                if(first == -1){\n                    first = i;\n                }\n                if(temp!= -1){\n                    for (int j = temp; j < i; j++) {\n                        res[j] = Math.min(i-j,res[j]);\n                    }\n                }\n                temp = i;\n            }\n            if(first != -1){\n                res[i] = i-temp;\n            }\n        }\n        for (int i = 0; i < first; i++) {\n            res[i] = first - i;\n        }\n        return res;\n    }\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088756960","body":"设立头尾。每次更新的时候头尾做个转换即可\n\n\nStack<Integer> head,tail;\n\n    public Solution232() {\n        head = new Stack<>();\n        tail = new Stack<>();\n\n    }\n\n    public void push(int x) {\n          tail.push(x);\n    }\n\n    public int pop() {\n         peek();\n         return head.pop();\n    }\n\n    public int peek() {\n        if (head.isEmpty())\n            // 把 s1 元素压入 s2\n            while (!tail.isEmpty())\n                head.push(tail.pop());\n        return head.peek();\n    }\n\n    public boolean empty() {\n      return head.isEmpty() && tail.isEmpty();\n    }","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091777103","body":"思路\n第一遍遍历链表得到链表长度和最后一个节点，判断链表长度和k的数量关系，将最后一个节点连接头节点，闭合成环，只需再遍历一次链表，找到需要断开的位置即可。\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null|| k == 0)  return head;\n        int n = 0;\t\t\t   //链表的长度\n        ListNode tail = null;  //尾节点\n        for(ListNode p = head; p != null ; p = p.next){\n            tail = p;\n            n++;\n        }\n        k %= n;\n        ListNode p = head;\n        for(int i = 0; i < n - k - 1; i++)  p = p.next;   //找到链表的第n-k个节点\n        tail.next = head;\n        head = p.next;\n        p.next = null;\n        return head;  //返回新的头节点\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094272547","body":"思路:链表A走完后从B的起点开始走。B走完后从A的起点开始走。如果相遇说明相交。如果没有就说明没有。\n\n\n public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n         if(headA == null || headB == null){\n              return null;\n         }\n         ListNode PA = headA;\n         ListNode PB = headB;\n         while(PA != PB){\n             PA = PA == null?headB:PA.next;\n             PB = PB == null?headA:PB.next;\n         }\n         return PA;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086601300","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n            char[] array = s.toCharArray();\n            int len = s.length();\n            int[] res = new int[len];\n            Arrays.fill(res, len);\n            int idx_c = -1;\n            for(int i = 0; i < len ; i++) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    res[i] = 0;\n                    continue;\n                }\n                if(idx_c != -1) {\n                    res[i] = i - idx_c;\n                }\n            }\n            for(int i = len - 1; i >= 0 ; i--) {\n                if(array[i] == c) {\n                    idx_c = i;\n                    continue;\n                }\n                if(idx_c > i) {\n                    res[i] = Math.min(res[i], idx_c - i);\n                }\n                \n            }\n            return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086802767","body":"class CustomStack {\n\n    int[] data;\n    int[] add;\n    int maxSize;\n    int curSize;\n\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n        add = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n    \n    public void push(int x) {\n        if(curSize == maxSize){\n            return;\n        }\n        data[curSize++] = x;\n    }\n    \n    public int pop() {\n        if(curSize == 0) return -1;\n        int res = data[curSize - 1] + add[curSize - 1];\n        if(curSize > 1) {\n            add[curSize - 2] += add[curSize - 1]; \n        }\n        add[curSize - 1] = 0;\n        curSize--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        if(curSize == 0) return;\n        add[Math.min(k, curSize) - 1] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087293757","body":"class Solution {\n    public String decodeString(String s) {\n        // 碰到【 入栈字母  碰到 】出栈字母并计算\n        Deque<String> cStack = new LinkedList<>();   // 存储的是[ 后  数字前的字符串  如  2[ab3[cd4[ef]]] 中的ab  cd  依次入栈  \n        Deque<Integer> nStack = new LinkedList<>();  // 存储的是[ 前的数字  如上例中的 2 3 4\n        char[] arr = s.toCharArray();\n        // 难点  数字可能不止一位数\n        int num = 0;\n        String piece = \"\";\n        for(char c : arr) {\n            if ( c >= '0' && c <= '9') {\n                num = num * 10 + (c - '0');\n            } else if (c == '[') {\n                nStack.push(num);\n                cStack.push(piece);\n                num = 0;\n                piece = \"\";\n            } else if (c == ']') {\n                String inner = piece;\n                int cnt = nStack.pop() - 1;\n                for(int i = 0 ; i < cnt; i ++) {\n                    piece += inner;\n                }\n                piece = cStack.pop() + piece;\n            } else {\n                piece += c;\n            }\n        }\n        return piece;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088220824","body":"class MyQueue {\n\n    Deque<Integer> pushStack;\n    Deque<Integer> popStack;\n\n    public MyQueue() {\n        pushStack = new LinkedList<>();\n        popStack = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        if(popStack.isEmpty()){\n            transfer();\n        }\n        if(popStack.isEmpty()) \n        return -1;\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        if(popStack.isEmpty()){\n            transfer();\n        }\n        if(popStack.isEmpty()) \n        return -1;\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n\n    private void transfer() {\n        while(!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090356229","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n       Deque<Integer> stack = new LinkedList<>();\n       for(int i : arr) {\n           if(!stack.isEmpty() && i < stack.peek()) {\n               int top = stack.pop();\n               while(!stack.isEmpty() && i < stack.peek())  {\n                   stack.pop();\n               }\n               stack.push(top);\n           } else {\n               stack.push(i);\n           }\n       }\n       return stack.size();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091476462","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0) return head;\n        int l = 1 ;\n        ListNode dummyHead = head;\n        while(head.next != null) {\n            head = head.next;\n            l++;\n        }\n        ListNode tail = head;\n        k = k % l;\n        if(k == 0) return dummyHead;\n        l -= k;\n\n        head = dummyHead;\n        while(--l > 0) {\n            head = head.next;\n        }\n\n        ListNode newHead = head.next;\n        head.next = null;\n        tail.next = dummyHead;\n        return newHead;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092709666","body":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummyHead = new ListNode(-1, head);\n        ListNode cur = dummyHead;\n        while(cur.next != null && cur.next.next != null) {\n            ListNode next2 = cur.next.next;\n            ListNode next3 = cur.next.next.next;\n            cur.next.next = next3;\n            next2.next = cur.next;\n            cur.next = next2;\n            cur = next2.next; // cur 指向两个要交换节点的前一个节点\n        }\n        return dummyHead.next;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093598085","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null ) return null;\n        if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = null, slow = head, fast = head;\n        while(fast!= null && fast.next != null) {\n            pre = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        pre.next = null;\n        root.left = sortedListToBST(head);\n        root.right = sortedListToBST(slow.next);\n        return root;\n\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094510782","body":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        while(fast != null && fast.next !=null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow) break;\n        }\n        if(fast == null || fast.next == null) return null;\n        // 相遇时 f = 2s  f = s + nb   s=nb  入口点为a + nb 因此slow 走a步到达入口点  两个指针再次一起走就行\n        fast = head;\n        while(fast != slow) {\n            fast =fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ethanwlx":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086617041","body":"思路：先从左往右，找每个index离左边最近的距离，再从右边往左，最后取左右的最小值。\n时间：O(n)\n空间：O(n)\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans_l = [float(inf)] * len(s)\n        ans_r = [float(inf)] * len(s)\n        ans = [0] * len(s)\n       \n        for i in range(len(s)):\n            if i == 0:\n                if s[i] == c:\n                    ans_l[i] = 0   \n            else:\n                ans_l[i] = ans_l[i-1] + 1 if s[i] != c else 0\n\n        for i in range(len(s) - 1, -1, -1):\n            if i == len(s) - 1:\n                if s[i] == c:\n                    ans_r[i] = 0          \n                ans[i] = min(ans_l[i], ans_r[i])\n            else:\n                ans_r[i] = ans_r[i+1] + 1 if s[i] != c else 0\n                ans[i] = min(ans_l[i], ans_r[i])\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086767347","body":"难点在于用O(1)时间处理增加量，假设我们记录增加量的值，指令分别为（1,20） （2,40） （4，40） （4，60）\n并画出图\n1##\n2####\n3\n4##########\n对于4 增加量就是 100\n对于3也是100\n对于2就是100+40=140\n对于1就是140+20= 160\n对于 i 位置就是上一个位置的值+自己本身的值\n把这张表格记录下来我们就可以做到线性时间得到每一个位置的增加量值\n时间： O（1）\n空间： O(maxsize)\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.addition = []\n        self.maxSize = maxSize\n        self.size = 0\n\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.addition.append(0)\n            self.size += 1\n\n\n    def pop(self) -> int:\n        if self.size > 0:\n            if self.size > 1:\n                self.addition[-2] += self.addition[-1]\n            st = self.stack.pop() + self.addition.pop()\n            self.size -= 1\n            return st\n        return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.size > 0:\n            self.addition[min(k,self.size)-1] += val\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086650773","body":"### 思路\n使用双指针，然后遍历字符串\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] result=new int[N];\n        int indexNext=S.indexOf(C);//双指针，indexNext表示下一个C的下标， \n        int index=indexNext;//index表示前一个C的坐标\n    // 通过这里的赋值使在只有左边有C字符的时候（此时index = indexNext）的时候\n    //index也在当前字符的右边，否则在左右都有C字符的时候，当前字符必在index和indexNext的中间。\n       for(int i = 0; i < S.length(); i++){\n            if(S.charAt(i) == C){//每当遍历到C就更新index和indexNext\n                result[i] = 0;\n                index = i;\n                indexNext = S.indexOf(C, i+1);\n                //这里如果当前是最后一个C时，此时indexNext为-1，这也保证了上面的情况\n            }else{\n                result[i] = Math.min(Math.abs(index - i), Math.abs(indexNext - i));\n            }\n        }\n       return result;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O（n）\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086854030","body":"### 思路\n使用栈实现\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1){\n            ++top;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top==-1)\n            return -1;\n        --top;\n        return stack[top+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        int li=Math.min(k,top+1);\n        for(int i=0;i<li;i++){\n            stack[i]+=val;\n        }\n\n    }\n}\n```\n### 复杂度分析\n时间复杂度：push和pop是0（1）,inc是O(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088759764","body":"### 思路\n使用双栈进行实现\n### 代码\n```java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack=new LinkedList<>();\n        outStack=new LinkedList<>();\n\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.pop();\n    }\n \n    public int peek() {\n        if(outStack.isEmpty()){\n            inout();\n        }\n    return outStack.peek();\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tt-fantastic":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086653492","body":"public int[] shortestDistance(String s, char c) {\n        int[] arr = new int[s.length()];\n        int distance = Integer.MIN_VALUE；\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                distance = i;\n            }\n            arr[i] = i - distance;\n        }\n\n        distance = Integer.MAX_VALUE;\n        for (int j = s.length() - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                distance = j;\n            }\n            arr[j] = Math.min(arr[j], distance - j);\n        }\n       return arr;","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090319401","body":"```java\npublic int max(int arr[]) {\n        Stack<Integer> stack = new Stack();\n        for (int num: arr) {\n            int max = num;\n            while (!stack.isEmpty() && stack.peek() > num) {\n                max = Math.max(max, stack.pop());\n            }\n            stack.push(max);\n        }\n        return stack.size();\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091873831","body":"```java \npublic static void main(String[] args) {\n\n    }\n\n    public ListNode right(ListNode node, int k) {\n        if (node == null) {\n            return null;\n        }\n        ListNode current = node;\n        int count = 1;\n        //获取节点数\n        while (current.next != null) {\n            current = current.next;\n            count++;\n        }\n        current.next = node;\n        //节点数 - k % 节点数\n        for (int i = 1; i < count - (k % count); i++) {\n            current = current.next;\n        }\n        ListNode newNode = current.next;\n        current.next = null;\n        return newNode;\n    }\n    //定义节点\n    static class ListNode {\n        //数据 ：节点数据\n        int val;\n        //对象 ：引用下一个节点对象。\n        ListNode next;\n\n        public ListNode(int val) {\n            this.val = val;\n        }\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095152979","body":"```java \npublic ListNode detectCycle(ListNode head) {\n        if (head.next == null || head == null ) {\n            return null;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n\n            if (fast == slow) {\n                ListNode node = fast;\n                while (node != slow) {\n                    node = node.next;\n                    slow = node.next;\n                }\n                return node;\n            }\n        }\n        return null;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyh331":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086658067","body":"### **Day2**  思路  \n\n两边都遍历，最后留下较小的值  \n\n### 代码  \n\n```\nc++\nclass Solution \n{\npublic:\n    vector<int> shortestToChar(string s, char c) \n    {\n        vector<int> ans(s.size(), 0);\n        int left = INT_MAX;\n        int right = INT_MAX;\n        for(int i = 0; i < s.size(); i ++) \n        {\n            if (s[i] == c) \n            {\n                left = i;\n            }\n            ans[i] = i - left;\n        }\n        for(int i = s.size() - 1; i >= 0; i --) \n        {\n            if (s[i] == c) \n            {\n                right = i;\n            }\n            ans[i] = min(abs(ans[i]), right - i);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086862033","body":"### Day3 思路\n考虑用vector(本质为单端动态数组)容器实现。\n1. 构造函数中用m_Maxsize接收传入进来的maxSize。\n2. void push中判断数组元素个数<m_Maxsize？然后_.push_back(x)将x压入堆栈\n3. void pop中用_.empty()判断容器是否为空,不为空时先用**int top=_.back();保留引用，后续返回top**，再进行出栈操作。\n4. increment中for保证i < k && i < _.size()就可以\n### 代码\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int m_Maxsize;\n    //构造函数\n    CustomStack(int maxSize) {\n        m_Maxsize=maxSize;\n        //stack.resize(maxSize);\n    }\n    //入栈函数\n    void push(int x) {\n        if(stack.size()<m_Maxsize){\n            stack.push_back(x);\n        }\n    }\n    //出栈函数,弹出栈顶元素，并返回栈顶的值，栈为空时返回-1\n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }\n        else{\n            //要返回的是出栈前的栈顶，所以需要先把栈顶保留引用，用 int top=stack.back();接收一下\n            int top = stack.back();\n            stack.pop_back();\n            return top;\n        }\n\n    }\n    //栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val\n    void increment(int k, int val) {\n        for(int i=0 ; i<k && i<stack.size();i++){\n            stack[i]+=val;\n        }\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度\npush:O(1)\npop:O(1)\nincr:O(k)\n- 空间复杂度\npush:O(1)\npop:O(1)\nincr:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087681416","body":"### Day3 思路\n用栈来解决问题\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[') //将‘[’前的数字压入nums栈内， 字母字符串压入strs栈内\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else //遇到‘]’时，操作与之相配的‘[’之间的字符，使用分配律\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算\n                                  //若是左括号，res会被压入strs栈，作为上一层的运算\n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088375886","body":"\n### Day5 思路\n使用两个栈来实现队列，一个是输入栈，一个是输出栈。\n1. push操作直接压入输入栈即可。输入栈的元素顺序是和队列相反的。\n2. pop操作需要先判断输出栈是否为空，然后将输入栈全部放入到输出栈，此时输出栈的**栈顶到栈底的元素排列**就和**队列中队头到队尾的元素排列**一致。\n3. peek操作，使用2中已有的pop函数,注意最后要将出栈的元素放回去。\n3. empty，只需判断两个栈是否为空即可\n### 代码\n```c++\nclass MyQueue {\npublic:\n    stack<int> StkIn, StkOut;\n    MyQueue() {\n\n    }\n    //入队，直接将数据x压入StkIn即可\n    void push(int x) {\n        StkIn.push(x);\n    }\n    //出队，\n    int pop() {\n        //当StkOut栈为空时，将StkIn的元素全部放入StkOut，\n        //这样做StkOut中从栈顶到栈底元素的排列就和队列中从队头到队尾一致。\n        if(StkOut.empty()){\n            while(!StkIn.empty()){\n                StkOut.push(StkIn.top());\n                StkIn.pop();\n            }\n        }\n        int result=StkOut.top();\n        StkOut.pop();\n        return result;\n    }\n    //返回队列首部的元素。\n    int peek() {\n        int res=this->pop();//直接使用已经写好的pop函数\n        StkOut.push(res);//pop函数中弹出了res，所以要添加回去\n        return res;\n\n    }\n    //返回队列是否为空，只需判断两个栈是否都为空即可\n    bool empty() {\n        return StkIn.empty()&&StkOut.empty();\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：push和empty是O(1)，pop和peek是O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090108751","body":"### Day6 思路\n1. 将原数组进行分块后，对各分块分别进行排序后的结果等于原数组排序后的结果。\n2. 每个分块中的数字相对于前一个分块都是递增的(因为有重复数字，所以也可能是相同，下一个分块中的所有数字都会大于等于上一个分块中的所有数字。\n3. 在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块。\n4. 如果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块(保持栈的单调递增)\n5. 涉及单调栈的知识\n6. 若数组元素>=单调栈栈顶元素，数组元素入栈。若数组元素<单调栈栈顶元素，先将栈顶元素保存，再栈非空且arr[i]<栈顶元素情况下，将栈顶元素弹出，即拿出来重新组成块，最后将最大值重新入栈\n### 代码\n```c++\nclass Solution \n{\npublic:\n    int maxChunksToSorted(vector<int>& arr)\n    {\n        //单调栈，\n        stack<int>maxStk;\n        //直接将数组的第一个入栈\n        maxStk.push(arr[0]);\n        //从第二个元素开始遍历数组\n        for(int i=1;i<arr.size();i++)\n        {\n            //若数组元素>=单调栈栈顶元素，数组元素入栈\n            if(arr[i]>=maxStk.top())\n            {\n                maxStk.push(arr[i]);\n            }\n            else\n            {\n                //若数组元素<单调栈栈顶元素，先将栈顶元素保存，再栈非空且arr[i]<栈顶元素情况下，将栈顶元素弹出，即拿出来重新组成块，最后将最大值重新入栈\n              int maxNum=maxStk.top();\n              while(!maxStk.empty()&&arr[i]<maxStk.top())\n              {\n                \n                maxStk.pop();\n              }\n              maxStk.push(maxNum);\n            }\n        }\n        return maxStk.size();\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091020616","body":"### Day7 思路\n假设链表的长度为n，为了将链表每个节点向右移动 k 个位置，我们只需要将链表的后 k % n个节点移动到链表的最前面，然后将链表的后k % n个节点和前 n - k个节点连接到一块即可。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || !k)  return head;\n        int n = 0;        //链表的长度\n        ListNode* nodelt=head;   //头节点\n        ListNode* Tail=head;\n        while(nodelt!=NULL){\n            n++;\n            Tail=nodelt;\n            nodelt=nodelt->next;\n        }\n        k %= n;  \n        ListNode* p = head;\n        for(int i = 0; i < n - k - 1; i++)   p = p->next;  //找到链表的第n-k个节点\n        Tail->next = head;\n        head = p->next;\n        p->next = nullptr;\n        return head;     //返回新的头节点\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度:O(N)\n- 空间复杂度:O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093832975","body":"### Day9 思路\n找到中点后递归+中序遍历\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* h; \n    TreeNode* sortedListToBST(ListNode* head) {\n        //if(!head ) return head;\n        h = head;\n        int n = 0;\n        for(auto p = head; p; p = p->next) n ++;\n        return build(0, n - 1);\n\n    }\n\n    TreeNode* build(int l, int r) {\n        if(l > r) return nullptr;\n        TreeNode *root = new TreeNode();\n        int mid = (l + r  +1) >> 1;\n        root->left = build(l, mid - 1);\n        root->val = h->val;   \n        h = h->next; \n        root->right = build(mid + 1, r);\n        return root;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094175652","body":"### Day3 思路\n双指针方法\n1. 只有当链表headA和headB 都不为空时，两个链表才可能相交。因此首先判断链表headA和headB是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。\n2. 当链表A和B 都不为空时，创建两个指针pA和pB，初始时分别指向两个链表的头节点headA和headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：\n3. 每步操作需要同时更新指针pA和pB。\n4. 如果指针pA 不为空，则将指针pA 移到下一个节点；如果指针pB 不为空，则将指针pB 移到下一个节点。\n5. 如果指针pA 为空，则将指针pA 移到链表headB的头节点；如果指针pB 为空，则将指针pB 移到链表headA 的头节点。\n6. 当指针pA和pB 指向同一个节点或者都为空时，返回它们指向的节点或者null。\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (headA == NULL || headB == NULL) {\n            return NULL;\n        }\n        ListNode *pA = headA, *pB = headB;\n        while (pA != pB) {\n            if(pA!=NULL){\n                pA=pA->next;\n            }\n            else{\n                pA=headB;\n            }\n            if(pB!=NULL){\n                pB=pB->next;\n            }\n            else{\n                pB=headA;\n            }\n            //pA = pA == nullptr ? headB : pA->next;\n           // pB = pB == nullptr ? headA : pB->next;\n        }\n        return pA;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094485739","body":"### Day11 思路\n快慢指针，fast与slow，fast的速度是slow的两倍，起始位置都为链表头部，若链表中存在环，则快指针必在\n环中与慢指针相遇。相遇时，重新指定一个pre指针从链表头开始，当再次相遇时，返回pre即可。\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head;\n        ListNode *fast=head;\n        //让快慢指针开始运动，第一次相遇时跳出\n        while(fast!=NULL && fast->next!=NULL){\n            slow=slow->next;\n            fast=fast->next->next;\n            //快慢指针相遇，代表有环\n            if(slow==fast){\n                break;\n            }\n        }\n        //判断没环的情况下，返回null\n        if(fast==NULL || fast->next==NULL){\n            return NULL;\n        }\n        //重新指定一个pre指针从链表头部开始，让pre和slow同一速度，当相遇时，返回pre\n        ListNode *pre=head;\n        while(pre!=slow){\n            pre=pre->next;\n            slow=slow->next;\n        }\n        return pre;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennethalgol":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086659398","body":"# 思路\r\n双指针\r\n# 语言\r\njava\r\n\r\n```java\r\npublic int[] shortestToChar(String S, char C) {\r\n        \r\n        int[] res = new int[S.length()];\r\n        int cur = S.indexOf(C), pre = cur;\r\n        for(int i = 0; i < S.length(); i++){\r\n            if(S.charAt(i) == C){//其实就是每当遍历到C就更新cur和pre\r\n                res[i] = 0;\r\n                pre = i;\r\n                cur = S.indexOf(C, i+1);//注意：这里如果当前是最后一个C时，此时cur为-1，这也保证了上面的情况3\r\n\r\n            }else{\r\n                res[i] = Math.min(Math.abs(pre - i), Math.abs(cur - i));//\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度分析\r\n时间 O(n) 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086660008","body":"# 思路\r\n模拟\r\n\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091455551","body":"# 思路\r\n快慢指针\r\n\r\n```java\r\nclass Solution {\r\n        public ListNode rotateRight(ListNode head, int k) {\r\n            if (head == null) {\r\n                return head;\r\n            }\r\n            ListNode slow = head;\r\n            ListNode fast = head;\r\n            for (int i = 0; i < k; i++) {\r\n                if (fast.next == null) {\r\n                    //超过一轮时重新开始走,这边也可以优化成模(但是前提需要知道链表总长度至少要遍历一次),可以免去不停的循环遍历\r\n                    fast = head;\r\n                } else {\r\n                    fast = fast.next;\r\n                }\r\n            }\r\n            //快慢指针间距离为0，移动0个位置，直接返回head\r\n            if (fast == head) {\r\n                return head;\r\n            }\r\n            while (fast.next != null) {\r\n                slow = slow.next;\r\n                fast = fast.next;\r\n            }\r\n            ListNode newHead = slow.next;\r\n            fast.next = head;\r\n            slow.next = null;\r\n            return newHead;\r\n        }\r\n    }\r\n\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094715344","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode pos = head;\r\n        Set<ListNode> visited = new HashSet<ListNode>();\r\n        while(pos != null){\r\n            if(visited.contains(pos)){\r\n                return pos;\r\n            }else{\r\n                visited.add(pos);\r\n            }\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dtldtt":[null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/3#issuecomment-1086666626","body":"### 思路\n\n把原数组str中的c的下标取出来单独放在一个数组中，作为判断的边界。相当于几个分割点，除了开头和末尾的特殊情况，每次只需要判断离前一个分界点近还是离后一个分界点近就可以了。\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n#define MIN(x,y) ((x)<(y) ? (x) : (y))\n    vector<int> shortestToChar(string str, char c) {\n        vector<int> flags;\n        vector<int> answer;\n        for(int i=0;i<str.size();i++){\n            if(str[i]==c) flags.push_back(i);\n        }\n        //print_vector(flags);\n        //cout<<\"end\\n\";\n        int current_flag=0;\n        for(int i=0;i<str.size();i++){\n            if(current_flag==flags.size()){\n            answer.push_back(i-flags[current_flag-1]);\n            continue;\n            }\n            if(i>flags[current_flag]) {current_flag++; i--; continue;}\n            else if(current_flag==0){\n            answer.push_back(flags[current_flag]-i);\n            continue;\n            }\n            answer.push_back(MIN(i-flags[current_flag-1],flags[current_flag]-i));\n        }\n        return answer;\n            }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086819738","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n\n### 思路\n\n就是用数组实现一个栈，标记对栈顶元素做好标记就好\n\n### 代码\n\n\n```cpp\n\nclass CustomStack {\nprivate:\n    int maxSize;\n    int *stack;\n    int num; //当前有几个数在栈中\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize=maxSize;\n        this->stack = new int[maxSize];\n        num=-1;\n    }\n    ~CustomStack(){\n        delete [] this->stack;\n    }\n    bool is_empty()\n{\n    return num==-1;\n}\n    \n    void push(int x) {\n        if(num<maxSize-1) stack[++num]=x;\n        else return;\n    }\n    \n    int pop() {\n        if(is_empty()) return -1;\n        return stack[num--];\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<=num;i++){\n          stack[i]+=val;\n        }\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087720258","body":"### [394. 字符串的解码](https://leetcode-cn.com/problems/decode-string/)\n\n\n### 思路\n\n用栈保存字符串，然后遇到中括号进行相应的处理\n\n### 代码\n\n\n```cpp\n\nstring decodeString(string s) {\n  stack<char> str_stack, tmp_stack;\n  for(int i=0;s[i];i++){\n    if(s[i]!=']') str_stack.push(s[i]);\n    else {\n      while(str_stack.top()!='['){\n        tmp_stack.push(str_stack.top());\n        str_stack.pop();\n      }\n      str_stack.pop();\n      string tmp_str=\"\";\n      while(!tmp_stack.empty()){\n        tmp_str+=tmp_stack.top();\n        tmp_stack.pop();\n      }\n      string single_str=\"\";\n      short times=str_stack.top()-'0';\n      str_stack.pop();\n      string final_str=\"\";\n      for(int j=0;j<times;j++){\n        final_str+=tmp_str;\n      }\n      for(int j=0;j<final_str.length();j++){\n        str_stack.push(final_str[j]);\n      }\n    }\n  }\n  string ret=\"\",ret_reverse=\"\";\n  while(!str_stack.empty()){\n    ret+=str_stack.top();\n    str_stack.pop();\n  }\n  for(int i=ret.length()-1;i>=0;i--){\n    ret_reverse+=ret[i];\n  }\n  return ret_reverse;\n}\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N2)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088699390","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n\n### 思路\n\n在push操作的时候处理一下，再使用一个临时栈，把栈中的内容反过来，这样永远保证栈是队列的反向，这样执行pop和peek都可以直接调用栈的pop和top。\n\n### 代码\n\n\n```cpp\n\n\nclass MyQueue {\nstack<int> my_queue;\npublic:\n    MyQueue() {\n      \n    }\n    \n    void push(int x) {\n      if(my_queue.empty()) my_queue.push(x);\n      else {\n        stack<int> tmp_queue;\n        while(!my_queue.empty()){\n          tmp_queue.push(my_queue.top());\n          my_queue.pop();\n        }\n        my_queue.push(x);\n        while(!tmp_queue.empty()){\n          my_queue.push(tmp_queue.top());\n          tmp_queue.pop();\n        }\n      }\n    }\n    \n    int pop() {\n      int ret=my_queue.top();\n      my_queue.pop();\n      return ret;\n    }\n    \n    int peek() {\n      return my_queue.top();\n    }\n    \n    bool empty() {\n      return my_queue.empty();\n    }\n};\n\n\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091905658","body":"## 2022-04-07\n\n### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\n\n\n### 思路\n\n每次都遍历找到尾元素和尾元素的前一个元素，然后将前一个元素的next置空，将尾元素next指向head，head指向新的head（tail），然后继续循环。\n\n**关键点是**\n循环的次数要对链表元素个数取模，可以减少很多次循环。\n### 代码\n\n\n```cpp\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int list_size(ListNode *head){\n      int n=0;\n      while(head){\n        n++;\n        head=head->next;\n      }\n      return n;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n      if(!head || !(head->next)) return head;\n      k=k%list_size(head);\n      ListNode *tail=head->next;\n      ListNode *pre_tail=head;\n      \n      for(int i=0;i<k;i++){\n        while(tail->next){\n          pre_tail=tail;\n          tail=tail->next;\n      }\n        pre_tail->next=NULL;\n        tail->next=head;\n        head=tail;\n      }\n      return head;\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093032613","body":"## 2022-04-08\n\n### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n\n### 思路\n\n维护三个变量，分别指向pre,cur,post前中后三个节点，直接交换，认真一点儿做好每个节点的next归属就行\n\n\n### 代码\n\n\n```cpp\n\n\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n      if(!head || !(head->next)) return head;\n      ListNode ptr(0,head);\n      ListNode *pre=&ptr, *cur=head,*post=cur->next;\n      do{\n        cur->next=post->next;\n        post->next=cur;\n        pre->next=post;\n        pre=cur;\n        if(cur==head) head=post;\n        cur=pre->next;\n        if(cur)\n          post=cur->next;\n      }while(pre && cur && post);\n      return head;\n    }\n};\n\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094064568","body":"## 2022-04-09\n\n### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\n\n\n### 思路\n\n主要是利用二叉搜索树的性质，二叉搜索树的中序遍历是一个有序数列。\n构建二叉树的前提是中序遍历+任何其他遍历，中序遍历确定左右子树，其他遍历确认根节点。这里已经知道中序遍历，所以只需要找根节点。因为要构建平衡二叉搜索树，所以需要两边一样多，所以根节点就是有序数列的中位数。\n\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    int getListSize(ListNode *head)\n{\n  int ret=0;\n  while(head){\n    ret++;\n    head=head->next;\n  }\n  return ret;\n}\n    TreeNode* sortedListToBST(ListNode* head) {\n      if(!head) return nullptr;\n      if(!(head->next)){\n        TreeNode *ret=new TreeNode(head->val);\n        return ret;\n      }\n      int size=getListSize(head);\n      int mid= size>>1;\n      int i=0;\n      ListNode* pre_list=head;\n      while(i<mid-1){\n        pre_list=pre_list->next;\n        i++;\n      }\n      ListNode *cur=pre_list->next;\n      ListNode *post=cur->next;\n      pre_list->next=nullptr;\n      TreeNode *root=new TreeNode(cur->val);\n      root->left=sortedListToBST(head);\n      root->right=sortedListToBST(post);\n      return root;\n    }\n};\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n#### 备注","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094255628","body":"## 2022-04-10\n\n### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\n\n\n### 思路\n\n这个题最简单最直接的思路就是利用一个集合，把第一个链表的节点存进去，再遍历第二个链表，一个一个查看是不是重复的节点，第一个重复的节点就是相交的地方。但是这个的空间时间复杂度都较高，代码中注释部分就是这个解法。\n\n巧妙地是第**二个办法**，因为两个链表如果在某个节点重合，那么后续的部分是完全一样的。假设a链表先到达了重合点，那么他到了结尾，如果从b链表的开头开始，下次一定会和b在重合点见面。因为a+b-c=b+a-c. 这个时间复杂度是on，空间复杂度是o1.见代码未注释的部分。\n\n\n### 代码\n\n\n```cpp\n\n\n// class Solution {\n// public:\n//     int getSize(ListNode *head){\n//       int ret=0;\n//       while(head){\n//         ret++;\n//         head=head->next;\n//       }\n//       return ret;\n//     }\n//     ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n//       if(!headA || !headB) return nullptr;\n//       if(getSize(headA)>getSize(headB)){\n//         ListNode *tmp=headA;\n//         headA=headB;\n//         headB=tmp;\n//       }\n//       set<ListNode*> records;\n//       while(headA){\n//         records.insert(headA);\n//         headA=headA->next;\n//       }\n//       while(headB){\n//         if(records.count(headB))\n//           return headB;\n//         headB=headB->next;\n//       }\n//       return nullptr;\n//     }\n// };\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      if(!headA || !headB) return nullptr;\n      ListNode *A=headA, *B=headB;\n      bool flagA=true,flagB=true;\n      while(headA && headB){\n        if(headA==headB) return headA;\n        if(headA->next) headA=headA->next;\n        else if(flagA) {headA=B; flagA=false;}\n        else headA=nullptr;\n        if(headB->next) headB=headB->next;\n        else if(flagB) {headB=A; flagB=false;}\n        else headB=nullptr;\n      }\n      return nullptr;\n    }\n};\n\n\n\n```\n\n#### **复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086761350","body":"# Day 3: 1381. Design a Stack With Increment Operation (stack)\n\n- Problem Link\n  - [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n- Ideas\n  -  We could either use vanilla way to implement, or use an array to store the information. Use an additional array to record the increment value. inc[i] means for all elements stack[0] ~ stack[i], we should plus inc[i] when popped from the stack. Then inc[i-1]+=inc[i], so that we can accumulate the increment inc[i] for the bottom elements and the following pops.\n  \n- Complexity: hash table and bucket\n  - Time: O(1)\n  - Space: O(N)\n\n- Code\n\n```python\nclass CustomStack:\n    \n    def __init__(self, maxSize: int):\n        self.list = []\n        self.inc = [] #log inc value and add to the number when poping a number\n        self.maxsize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxsize:\n            self.list.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.inc: return -1\n        if len(self.inc) >1:\n            self.inc[-2] += self.inc[-1]\n        return self.list.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, len(self.inc)) -1] +=val\n```\n\n- other resources:\n    - ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087073148","body":"# Day 4: 394. Decode String (stack, dfs, bracket)\n\n- Problem Link\n  - [394. Decode String](https://leetcode.com/problems/decode-string/)\n  - Other useful links:\n\n- Ideas\n  -  ideas are from [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2). We could use stack to store the information before the first ']'. When we meet the first ']' we will get the string before it, then get all the numbers before the string. \n  -  Note the += might cause error since it is reversed order. and not that `stack[-1] != '[':` is required to avoid [ in the string.\n\n- Complexity: \n  - Time: O(len(decoded_string))\n  - Space:  O(len(decoded_string))\n\n- Code\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c ==']':\n                string_to_repeat = ''\n                repeat_times = ''\n                while stack and stack[-1] != '[':\n                    string_to_repeat  =stack.pop() + string_to_repeat\n                stack.pop()  #pop out [\n                while stack and stack[-1].isnumeric():\n                    repeat_times  = stack.pop() + repeat_times\n                stack.append(string_to_repeat * int(repeat_times))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```\n\n- other resources:\n  - [official solution](https://leetcode-solution.cn/solutionDetail?type=3&id=4&max_id=2)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092019966","body":"# Day 8: 24. Swap Nodes in Pairs (linked list)\n\n- Problem Link\n  - [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/submissions/)\n\n- Ideas\n  -  we could iterate the linked list to swap the nodes. We need a dummy pre head, and represent the first two nodes as pre-1-2-n. Then we point pre to 2, and point 1 to n, and then point 2 to 1. After that we locate to the original first node. So we have pre-2-**1**-n.\n\n- Complexity: \n  - Time: O(N)\n  - Space: O(1)\n\n- Code\n\n```python\nclass Solution(object):\n    def swapPairs(self, head):\n        if not head or not head.next: return head\n        ans = ListNode()\n        ans.next = head #previous dummy node of first node\n        pre = ans #pre is used to iterate all the nodes, while ans remains at the beginning.\n        #pre-1-2-n\n        while pre.next and pre.next.next:\n            firstNode = pre.next\n            secondNode = pre.next.next\n            pre.next = secondNode #prehead point to the second  -->pre-2-n; 1 \n            firstNode.next = secondNode.next #first point to the next of second  -->pre-2; 1-n\n            secondNode.next = firstNode #second point to the original first  -->pre-2-1-n\n            pre = pre.next.next #locate to the first node of the current pair need to be swapped.\n        return ans.next #next of prehead, which is the first node of transformed list.\n```\n\n- other resources:\n    - [solution in lc](https://leetcode.com/problems/swap-nodes-in-pairs/discuss/171788/Python-or-Dummynode)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"floatingstarlight":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086764343","body":"class CustomStack {\n\n    private final int maxSize;\n    private final int[] stack;\n    private final int[] inc;\n    private int top = -1;\n    private final int bottom = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top == maxSize - 1) {\n            return;\n        }\n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top < bottom) {\n            return -1;\n        }\n        int res = stack[top] + inc[top];\n        if (top > bottom) {\n            inc[top - 1] += inc[top];\n        }\n        inc[top] = 0;\n        top--;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k - 1, top);\n        if (i >= bottom) {\n            inc[i] += val;\n        }\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089174267","body":"class MyQueue {\n    private Stack<Integer> a;// \n    private Stack<Integer> b;// \n    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n  \n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094060347","body":"class Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    //[start, end) \n    TreeNode build(ListNode start, ListNode end){\n        if(start == end){\n            return null;\n        }\n        \n        ListNode mid = findMid(start, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(start, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    //two pointers\n    ListNode findMid(ListNode start, ListNode end){\n        ListNode slow = start, fast = start;\n        while (fast != end && fast.next != end){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086775193","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = []\n        self.cnt = 0\n        self.size = maxSize\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.cnt < self.size:\n            self.stack.append(x)\n            self.cnt += 1\n        \n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.cnt != 0:\n            self.cnt -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, self.cnt)):\n            self.stack[i] += val\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1093011965","body":"### 代码\n```python\nif not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"currybeefer":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086781771","body":"题目：【Day 3】1381. 设计一个支持增量操作的栈\r\n思路： 利用数组和一个指向数组顶部的指针就可以完成。但是注意边界条件的细节问题。\r\n我这里定义的cur指针指向的是下一个需要入栈的值应该存在的位置，所以初始值为0\r\n代码：\r\n```\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) \r\n    {\r\n        max=maxSize;\r\n        arr=new int[maxSize];\r\n        cur=0;\r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        if(cur>=max) return;\r\n        arr[cur]=x;\r\n        cur++;\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        if(cur==0) return -1;\r\n        cur--;\r\n        return arr[cur];\r\n    }\r\n    \r\n    void increment(int k, int val) \r\n    {\r\n        int count=0;\r\n        if(cur<=k-1)\r\n            count=cur;\r\n        else\r\n            count=k;\r\n        \r\n        for(int i=0;i<count;i++)\r\n            arr[i]+=val;\r\n    }\r\npublic:\r\n    int* arr;\r\n    int cur;\r\n    int max;\r\n};\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N) 主要是在 increment()中用了一次循环\r\n空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087057406","body":"思路：使用dfs递归，将字符串分解成字母序列+数字*[字母序列]的形式进行递归求解。括弧里边的表达式都需要放入递归里\r\n代码参考了一位老哥的结构\r\n代码：\r\n`string decodeString(string s) \r\n    {\r\n        int index=0;\r\n        return dfs(s, index);\r\n    }\r\n\r\n    string dfs(string& s, int& index)\r\n    {\r\n        string res;\r\n        while (index < s.size() && s[index] != ']')\r\n        {\r\n            if (s[index] >= 'a' && s[index] <= 'z' || s[index] >= 'A' && s[index] <= 'Z')\r\n            {\r\n                res += s[index];\r\n                index++;\r\n            }\r\n            else if (isdigit(s[index]))\r\n            {\r\n                int k = index;\r\n                while (isdigit(s[k]))\r\n                    k++;\r\n                int num = stoi(s.substr(index, k - index));//stoi string转换成int类型\r\n                index = k + 1;//去掉左括号\r\n                string val = dfs(s, index);//进一步递归，确认括号里的字符串\r\n                index++;\r\n                while (num > 0)\r\n                {\r\n                    res += val;\r\n                    num--;\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }   `\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088092050","body":"思路：这题的思路就是用两个栈模拟就好啦\r\n代码：\r\n` stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() \r\n    {\r\n        \r\n    }\r\n    \r\n    void push(int x) \r\n    {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() \r\n    {\r\n        int res;\r\n        while(!stk1.empty())\r\n        {\r\n            int x = stk1.top();\r\n            stk1.pop();\r\n            stk2.push(x);\r\n        }\r\n        res=stk2.top();\r\n        stk2.pop();\r\n        while(!stk2.empty())\r\n        {\r\n            int x = stk2.top();\r\n            stk2.pop();\r\n            stk1.push(x);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    int peek() \r\n    {\r\n        int res;\r\n        while(!stk1.empty())\r\n        {\r\n            int x = stk1.top();\r\n            stk1.pop();\r\n            stk2.push(x);\r\n        }\r\n        res=stk2.top();\r\n        while(!stk2.empty())\r\n        {\r\n            int x = stk2.top();\r\n            stk2.pop();\r\n            stk1.push(x);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    bool empty() \r\n    {\r\n        return stk1.empty();\r\n    }`\r\n复杂度：\r\npeek()和pop()的时间复杂度是O(n)，其他都是O(1)\r\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089831099","body":"思路：按照官方题解说的计数排序的思想来做\r\n代码：C++代码\r\n`int maxChunksToSorted(vector<int>& arr) \r\n    {\r\n        int res=0;\r\n        vector<int> sorted_arr(arr);\r\n        sort(sorted_arr.begin(),sorted_arr.end());\r\n        \r\n        unordered_map<int,int> count_a;\r\n        unordered_map<int,int> count_sa;\r\n        \r\n        for(int i=0;i<arr.size();i++)\r\n        {\r\n            count_a[arr[i]]+=1;\r\n            count_sa[sorted_arr[i]]+=1;\r\n            \r\n            if(count_a==count_sa) res++;\r\n        }\r\n        return res;\r\n    }`\r\n时间复杂度：O(n^2)\r\n空间复杂度: O(n)\r\n脖子疼，我先打个卡，之后再研究剩下的解法....","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091095631","body":"思路： 分析可知，就是将链表的倒数第k个节点开始的部分接到头部就好。对于k大于链表个数的，应该取余后求解。那么用快慢指针法求得倒数第k个节点的位置，但是在此之前应该先计算链表的节点数量count，最后k=k%count。\r\n代码：\r\n` ListNode* rotateRight(ListNode* head, int k) \r\n    {\r\n        if(head==nullptr || head->next==nullptr || k==0) return head;\r\n        ListNode* p=head;\r\n        int count=0;\r\n        while(p!=nullptr)\r\n        {\r\n            count++;\r\n            p=p->next;\r\n        }\r\n        k=k%count;\r\n        \r\n        ListNode* fast=head;\r\n        ListNode* slow=head;\r\n        \r\n        for(int i=0;i<k;i++)\r\n        {\r\n            fast=fast->next;\r\n        }\r\n        while(fast->next!=nullptr)\r\n        {\r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        fast->next=head;\r\n        head=slow->next;\r\n        slow->next=nullptr;\r\n        \r\n        return head;\r\n    }`\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092385610","body":"思路：用双指针就能解决\r\n代码：\r\nListNode* swapPairs(ListNode* head) \r\n    {\r\n        if(head==nullptr || head->next ==nullptr) return head;\r\n        ListNode* vh=new ListNode();\r\n        vh->next=head;\r\n        ListNode* pre=vh;\r\n        ListNode* p1=head;\r\n        ListNode* p2=head->next;\r\n        while(p1!=nullptr && p2!=nullptr)\r\n        {\r\n            swap(pre,p1,p2);\r\n            pre=p1;\r\n            p1=p1->next;\r\n            if(p1==nullptr) break;\r\n            p2=p1->next;\r\n        }\r\n        return vh->next;\r\n    }\r\n    void swap(ListNode* pre, ListNode* p1,ListNode* p2)\r\n    {\r\n        p1->next=p2->next;\r\n        p2->next=p1;\r\n        pre->next=p2;\r\n    }\r\n复杂度：\r\n时间复杂度和空间复杂度都是O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093420611","body":"思路：参考官方题解，由于链表已经排序了，所以以寻找到链表的中点，以链表中点为界限，中点左边是二叉搜索树的左孩子们，中点的右边是二叉树的右孩子们。进行递归地构造。\r\n寻找链表的中点当然就用快慢指针法就好啦。\r\nTreeNode* sortedListToBST(ListNode* head) \r\n    {\r\n        if(head==nullptr) return nullptr;\r\n        return sortedListToBST(head,nullptr);\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail)\r\n    {\r\n        if(head==tail) return nullptr;\r\n        ListNode* slow=head;\r\n        ListNode* fast=head;\r\n        //寻找链表中点，以中点为界构造二叉树\r\n        while(fast!=tail && fast->next!=tail)\r\n        {\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }\r\n        TreeNode* root=new TreeNode(slow->val);\r\n        root->left=sortedListToBST(head,slow);\r\n        root->right=sortedListToBST(slow->next,tail);\r\n        return root;\r\n    }\r\n复杂度分析：\r\n时间复杂度为O(nlogn)\r\n空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094135071","body":"思路：用双指针法，之前做过，具体解法看我写的博客：https://blog.csdn.net/Currybeefer/article/details/107434522\r\n代码：\r\n`  if(pHead1==nullptr)\r\n        {\r\n            return pHead1;\r\n        }\r\n        if(pHead2==nullptr)\r\n        {\r\n            return pHead2;\r\n        }\r\n        \r\n        ListNode* p1=pHead1;\r\n        ListNode* p2=pHead2;\r\n        while(p1!=p2)\r\n        {\r\n            p1=p1->next;\r\n            p2=p2->next;\r\n            if(p1!=p2)\r\n            {\r\n                if(p1==nullptr)\r\n                {\r\n                    p1=pHead2;\r\n                }\r\n                if(p2==nullptr)\r\n                {\r\n                    p2=pHead1;\r\n                }\r\n            }\r\n        }\r\n        return p1;\r\n    }`\r\n复杂度：\r\n时间复杂度O(m+n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094440160","body":"思路：这题真没啥好说的了，稍微刷过链表类题目的人应该都见过这个题目。当年第一次遇见是真的没有头绪。\r\n具体方法就看我博客吧，里边写了：https://blog.csdn.net/Currybeefer/article/details/107304915\r\n` ListNode *detectCycle(ListNode *head) \r\n    {\r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n\r\n        while (fast && fast->next) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if (slow == fast) {\r\n                fast = head;\r\n                while (slow != fast) {\r\n                    slow = slow->next;\r\n                    fast = fast->next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return nullptr;    \r\n    }`\r\n由于用了双指针，时间复杂度和空间复杂度都是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/14#issuecomment-1095290990","body":"思路：使用哈希链表这个数据结构来写。\r\n代码：\r\n```\r\nclass Node\r\n{\r\npublic:\r\n    int key;\r\n    int val;\r\n    Node* next;\r\n    Node* prev;\r\n    \r\n    Node(int i_key, int i_val)\r\n    {\r\n        key=i_key;\r\n        val=i_val;\r\n    }\r\n};\r\nclass DoubleList\r\n{\r\npublic:\r\n    Node* head;\r\n    Node* tail;\r\n    int size;\r\n    \r\n    DoubleList()\r\n    {\r\n        head=new Node(0,0);\r\n        tail=new Node(0,0);\r\n        head->next=tail;\r\n        tail->prev=head;\r\n        size=0;\r\n    }\r\n    void AddLast(Node* x)\r\n    {\r\n        x->prev=tail->prev;\r\n        x->next=tail;\r\n        tail->prev->next=x;\r\n        tail->prev=x;\r\n        size++;\r\n    }\r\n    void Remove(Node* x)\r\n    {\r\n        x->prev->next=x->next;\r\n        x->next->prev=x->prev;\r\n        size--;\r\n    }\r\n    Node* RemoveFirst()\r\n    {\r\n        if(head->next==tail)\r\n            return nullptr;\r\n        Node* first=head->next;\r\n        Remove(first);\r\n        return first;\r\n    }\r\n    int Size(){return size;}\r\n};\r\nclass LRUCache {\r\npublic:\r\n    unordered_map<int, Node*> map;\r\n    DoubleList cache;\r\n    int cap;\r\n    LRUCache(int capacity) {\r\n        cap=capacity;\r\n        //map=new unorder_map<int,Node*> ();\r\n        //cache=new DoubleList();\r\n    }\r\n    void MakeRecently(int key)\r\n    {\r\n        Node* x=map[key];\r\n        cache.Remove(x);\r\n        cache.AddLast(x);\r\n    }\r\n    void AddRecently(int key, int val) \r\n    {\r\n        Node* x=new Node(key,val);\r\n        cache.AddLast(x);\r\n        map[key]=x;\r\n    }\r\n    void DeleteKey(int key)\r\n    {\r\n        Node* x=map[key];\r\n        cache.Remove(x);\r\n        map.erase(key);\r\n    }\r\n    void RemoveLeastRecently()\r\n    {\r\n        Node* deleNode=cache.RemoveFirst();\r\n        int deleteKey=deleNode->key;\r\n        map.erase(deleteKey);\r\n    }\r\n    int get(int key) \r\n    {\r\n        if(map.find(key)==map.end())\r\n            return -1;\r\n        MakeRecently(key);\r\n        return map[key]->val;\r\n    }\r\n    \r\n    void put(int key, int value) \r\n    {\r\n        if(map.find(key)!=map.end())\r\n        {\r\n            DeleteKey(key);\r\n            AddRecently(key,value);\r\n            return;\r\n        }\r\n        if(cap==cache.Size())\r\n        {\r\n            RemoveLeastRecently();\r\n        }\r\n        AddRecently(key,value);\r\n    }\r\n};\r\n复杂度：\r\n时间复杂度为O(1)\r\n空间复杂度为O(n)\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oldfashioneddog":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086831280","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087248552","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        res=\"\"\n        multi=0\n        for c in s:\n            if c=='[':\n                stack.append([multi,res])\n                res,multi=\"\",0\n            elif c==']':\n                cur_multi,last_res=stack.pop()\n                res=last_res+res*cur_multi\n            elif '0'<= c <='9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088636936","body":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # for i in range(0,n):\n        #     nums1[m+i]=nums2[i]#nums1[m:]=nums2\n        # nums1.sort()\n        # return nums1\n        k = m + n - 1  # 目标数组总长度\n        while m > 0 and n > 0:  # 只要两个数组任意一个遍历完\n            if nums1[m - 1] > nums2[n - 1]:  # 一数组最后一个比二最后一个大\n                nums1[k] = nums1[m - 1]  # 将一数组最后一个移到目标数组最后一个\n                m -= 1  # 一数组的指针左移\n            else:\n                nums1[k] = nums2[n - 1]  # 将二数组最后一个移到目标数组最后一个\n                n -= 1  # 将二数组的指针左移\n            k -= 1  # 目标数组指针左移\n        nums1[:n] = nums2[:n]  # 如果第二个数组未遍历完，说明一数组已排序好，将二数组剪切过来","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090402609","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        pre1,pre2=0,0\n        res=0\n        for a,b in zip(arr,sorted(arr)):\n            pre1+=a\n            pre2+=b\n            if pre1==pre2:\n                res+=1\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091899418","body":"class Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head :return head\n        tail = head\n        Len = 1\n        while tail.next:    # 计算长度\n            tail = tail.next\n            Len += 1\n        k = (Len - k) % Len # 计算余数\n        tail.next = head\n        while k > 0:        # 找到分割点及头节点\n            tail = tail.next\n            k -= 1\n        head = tail.next    # 断链并返回\n        tail.next = None\n        return head\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092940583","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        thead = ListNode(-1)\n        thead.next = head\n        c = thead\n        while c.next and c.next.next:\n            a, b=c.next, c.next.next\n            c.next, a.next = b, b.next\n            b.next = a\n            c = c.next.next\n        return thead.next\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094280803","body":"class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n\n        # 链表A和B任一为空，链表不相交\n        if not headA or not headB:\n            return None\n\n        # 初始化headA、headB的指针和长度\n        flagA, flagB = headA, headB\n        lenA, lenB = 0, 0\n\n        # 求链表 A 的长度\n        while flagA:\n            flagA = flagA.next\n            lenA += 1\n\n        # 求链表 B 的长度\n        while flagB:\n            flagB = flagB.next\n            lenB += 1\n\n        # 重新指向表头\n        flagA, flagB = headA, headB\n\n        # 为了让大家看的明白点，我就不用华丽花哨的写法了，用最笨的写法表示。\n        # 当A是长链表，则指针flagA后移到和B链表同等长度的位置上。\n        if lenA > lenB:\n            d_value = lenA - lenB\n            while d_value:\n                flagA = flagA.next\n                d_value -= 1\n        # 当B是长链表，则指针flagB后移到和A链表同等长度的位置上。\n        else:\n            d_value = lenB - lenA\n            while d_value:\n                flagB = flagB.next\n                d_value -= 1\n\n        # 然后两个指针flagA和flagB同时遍历\n        while flagA:\n            if flagA == flagB:\n                return flagA\n            else:\n                flagA = flagA.next\n                flagB = flagB.next\n\n        # 如果没有相遇，返回 None\n        return None","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095196710","body":"class Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingchen77":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086877050","body":"#### 思路\n用两个数组模拟栈，一个存放每次push的数字，另外一个存放increment的内容，注意要更新increment出栈后的内容\n\n#### 代码\n```python\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.incremental = []\n        self.cur = 0\n        self.size = maxSize\n    def push(self, x: int) -> None:\n        if self.cur < self.size:\n            self.st.append(x)\n            self.cur += 1\n            self.incremental.append(0)\n    def pop(self) -> int:\n        if self.cur == 0:\n            return -1\n        if self.cur >= 2:\n            self.incremental[-2] += self.incremental[-1]\n        self.cur -= 1\n        return self.st.pop() + self.incremental.pop()\n    def increment(self, k: int, val: int) -> None:\n        if self.cur > 0:\n            self.incremental[min(self.cur, k) - 1] += val\n```\n#### 空间复杂度\n时间 O(1) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087081672","body":"#### 思路\n使用栈，通过对 “]” 的判断，进行出栈操作\n#### 代码\n```python\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                repeatStr = \"\"\n                repeatCount = \"\"\n                while stack and stack[-1] != \"[\":\n                    repeatStr = stack.pop() + repeatStr\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088566405","body":"#### 思路\n通过两个栈颠倒数据\n#### 代码\n```python\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.help_stack.append(self.stack.pop())\n        self.help_stack.append(x)\n        while self.help_stack:\n            self.stack.append(self.help_stack.pop())\n    def pop(self) -> int:\n        return self.stack.pop()\n    def peek(self) -> int:\n        return self.stack[-1]\n    def empty(self) -> bool:\n        if not self.stack:\n            return True\n        else:\n            return False \n```\n#### 复杂度\n时间 O(n) \\\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089819996","body":"#### 思路\n用数组的差表示arr和sorted(arr)的关系\n#### 代码\n```python\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = 0\n        count = collections.defaultdict(int)\n        non_zero_count = 0\n        for a, b in zip(arr, sorted(arr)):\n            if count[a] == -1:\n                non_zero_count -= 1\n            if count[a] == 0:\n                non_zero_count += 1\n            count[a] += 1\n            if count[b] == 1:\n                non_zero_count -= 1\n            if count[b] == 0:\n                non_zero_count += 1\n            count[b] -= 1\n            if non_zero_count == 0:\n                res += 1\n        return res \n```\n#### 复杂度 \n时间O(nlogn) \\\n空间O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091245452","body":"#### 思路\n通过设定p1以及p2的指针，进行移动，注意k%count，防止k大于链表长度\n\n#### 代码\n```python\n   def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        count = 1\n        p1 = head\n        while p1 and p1.next:\n            count += 1\n            p1 = p1.next\n        \n        offset = count - k % count\n\n        count = 1        \n        p2 = head\n        while count < offset:\n            p2 = p2.next\n            count += 1\n        p1.next = head\n        head = p2.next\n        p2.next = None\n        return head\n```\n#### 复杂度\n时间O(n) \\\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092397386","body":"#### 思路\n将交换的前一个节点pre，交换的两个节点head，head.next以及最后一个节点的head.next.next分别表示出来，直接交换即可\n\n#### 代码\n```python\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        res = ListNode(0)\n        res.next = head.next\n        pre = res\n        while head and head.next:\n            pre.next = head\n            p1 = head.next\n            p2 = p1.next\n\n            p1.next = head\n            head.next = p2\n            pre.next = p1\n\n            pre = head\n            head = p2\n        return res.next\n```\n\n#### 复杂度\n时间 O(n) \\\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093580373","body":"#### 思路\n寻找中间节点的位置，左右节点递归\n#### 代码\n```python\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        pre = ListNode()\n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n#### 复杂度\n时间 O(nlog(n)) \\\n空间 O(log(n))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094933958","body":"#### 思路\n经典的环问题，快慢指针相遇，再次出发\n####\n```python\n    def detectCycle(self, head: ListNode) -> ListNode:\n        if not head:\n            return head\n        \n        slow = fast = head\n        x = None \n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        x = head\n        while x != slow:\n            x = x.next\n            slow = slow.next\n        return slow\n```\n#### 复杂度\n时间O(n) \\\n空间O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/4#issuecomment-1086884935","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.size = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.size) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length != 0) {\n        let tmp = this.stack.pop();\n        return tmp;\n    } else {\n        return -1;\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length && i < k; ++i) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087517926","body":"## 思路\n栈。除了']'一律入栈，遇']'开始出栈处理\n## 代码\n```js\nvar decodeString = function(s) {\n    let stack = [];\n    for (let char of s) {\n        if (char != ']') {\n            stack.push(char);\n        } else {\n            let repeatStr = stack.pop();\n            let tmpC = stack.pop();\n            while (tmpC != '[') {\n               repeatStr = tmpC + repeatStr;\n               tmpC = stack.pop();\n            }\n            let repeatTime = \"\";\n            while (stack.length && !isNaN(stack.slice(-1))) {\n                repeatTime = stack.pop() + repeatTime;\n            }\n            stack.push(repeatStr.repeat(+repeatTime));\n        }\n    }\n    return stack.join(\"\");\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088640899","body":"```js\n// 直接模拟\nvar MyQueue = function() {\n    this.stack = [];\n    this.helperStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while (this.stack.length) {\n        this.helperStack.push(this.stack.pop());\n    }\n    let ret = this.helperStack.pop();\n    while (this.helperStack.length) {\n        this.stack.push(this.helperStack.pop());\n    }\n    return ret;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while (this.stack.length) {\n        this.helperStack.push(this.stack.pop());\n    }\n    let ret = this.helperStack.slice(-1);\n    while (this.helperStack.length) {\n        this.stack.push(this.helperStack.pop());\n    }\n    return ret;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090431494","body":"## 思路\n题解中的计数法。\n1. 先拷贝输入数组并排序\n2. 同时遍历输入数组和排序数组并建立两个数组的计数\n    - 用一个hashMap计数，一个数组加，一个数组减\n3. 统计计数相同的次数\n## 代码\n```js\nvar maxChunksToSorted = function(arr) {\n    let res = 0;\n    let count = new Map();\n    let sortedArr = arr.slice();\n    sortedArr.sort((a, b) => a - b);\n    for (let i = 0; i < arr.length; i++) {\n        if (count.has(arr[i])) {\n            if (count.get(arr[i]) == -1) {\n                count.delete(arr[i]);\n            } else {\n                count.set(arr[i], count.get(arr[i]) + 1);\n            }\n        } else {\n            count.set(arr[i], 1);\n        }\n        if (count.has(sortedArr[i])) {\n            if (count.get(sortedArr[i]) == 1) {\n                count.delete(sortedArr[i]);\n            } else {\n                count.set(sortedArr[i],count.get(sortedArr[i]) - 1);\n            }\n        } else {\n            count.set(sortedArr[i], -1);\n        }\n        if (count.size == 0) {\n            res++;\n        }\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1086967880","body":"代码：\nJavaScript\n\n```js\nvar decodeString = function(s){\n    const stack = [];\n\n    for (let char of s) {\n        if (char !== ']') {\n            stack.push(char);\n            continue;\n        }\n\n        let cur = stack.pop();\n        let str = '';\n        while (cur !== '[') {\n            str = cur + str;\n            cur = stack.pop();\n        }\n\n        // now get the number here\n        cur = stack.pop();\n        let num = '';\n        // be careful here, how we count the number\n        while (cur >= '0' && cur <= '9') {\n            num = cur + num;\n            cur = stack.pop();\n        }\n        stack.push(cur);\n        stack.push(str.repeat(num));\n    }\n    return stack.join('');\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091027008","body":"# 思路\n使用数组模拟\n\n# 代码\n\n语言：JavaScript\n\n```js\nvar rotateRight = function(head, k) {\n    if (!head) return null;\n    let arr = [];\n    let p = head;\n    while (p) {\n        arr.push(p.val);\n        p = p.next;\n    }\n\n    k = k % arr.length;\n    while (k --) {\n        arr.unshift(arr.pop());\n    }\n\n    let dummy = new ListNode(-1);\n    let cur = dummy;\n    for (let i = 0; i < arr.length; i++) {\n        cur = cur.next = new ListNode(arr[i]);\n    }\n\n    return dummy.next;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"geek-lx":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087052946","body":"思路：\n\n该题难点是括号嵌套括号，如：2[2[a]c]，应该输出aacaac，因为需要**从内向外**打开，所以可以使用stack FILO解题\n\n\n\n算法流程：见代码，已经很清晰了\n\n代码：\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c #当c为字母时，res尾后添加c\n        return res\n```\n\n复杂度：\n\nTime：O（n）\n\nSpace：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088185063","body":"思路：\n\nUse two stacks\n\n代码：\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.help_stack = []\n\n    def push(self, x: int) -> None:\n            while self.stack:\n                self.help_stack.append(self.stack.pop())\n            self.help_stack.append(x)\n            while self.help_stack:\n                self.stack.append(self.help_stack.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        return self.stack[-1]\n\n    def empty(self) -> bool:\n        return not bool(self.stack)\n\n```\n\n复杂度：\n\nTime complixiety:\npush - O(n)\npop - O(1)\npeek - O(1)\nempty - O(1)\nSpace complixiety:\npush - O(n)\npop - O(1)\npeek - O(1)\nempty - O(1)\n\n疑问：\n\n[->int 在Python函数定义中是什么意思？](https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions)\n\n只是告诉 返回一个整数（但它不会强制函数返回整数）。它被称为*返回批注*\n\n来自 <https://stackoverflow.com/questions/14379753/what-does-mean-in-python-function-definitions> \n\n \n\n 峰顶的索引是-1，那栈的索引是怎样的呢？\n\n  def peek(self) -> int:\n\n​    return self.stack[-1]\n\n//我认为首先看stack是怎样实现的？\n\nList可以实现stack，dict更适合链表\n\n但是list可没有-1的索引？\n\n5.1.1. 將 List 作為 Stack（堆疊）使用\n\n来自 <https://docs.python.org/zh-tw/3/tutorial/datastructures.html#using-lists-as-stacks> ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090434624","body":"辅助栈法：\n\n判断是否是排序块只需要用到该块的 元素最大值 headhead 。我们联想到，是否可以遍历一遍数组 arrarr ，动态判断到目前数字 numnum 为止最多能分出多少排序块，并保存每个排序块的最大值 headhead 。每遍历到下个数字 numnum ，动态判断前面所有的排序块是否成立，并更新所有排序块：\n当某排序块 num < headnum<head ：将此排序块[A]与 num 合并，形成新排序块[A | num]，最大值仍为 headhead ；\n当某排序块 num >= headnum>=head ：原排序块保留，并新加排序块 [num] 。\n而对于整个数组的排序块，其 headhead 大小是从左到右递增的。例如：数组 [1,2,1,3,4,7,5,6][1,2,1,3,4,7,5,6] 最多可划分为 [1|2,1|3|4|7,5,6][1∣2,1∣3∣4∣7,5,6] ，headhead 为 [1,2,3,4,7][1,2,3,4,7] 。因此，若给数组尾部加入一个随机正整数 nn ，尾部的排序块更容易被合并（最先满足 num < headnum<head ）。当 nn 值较小时（ << 前面多个排序块的 headhead ），则需按尾部到首部的顺序合并多个排序块。\n这种先入（首部到尾部添加排序块）后出（尾部到首部判断并合并排序块）的特性，让我们联想到使用 栈 保存排序块最大值 headhead 。在遍历过程中，通过维护栈的 headhead 序列，实现排序。\n\n代码：\n\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n\n```\n\n复杂度分析：\n\n时间复杂度 O(N)O(N) ：遍历一遍 arrarr 为 O(N)O(N)，修正排序块最多遍历一遍 arrarr 为 O(N)O(N)；\n空间复杂度 O(N)O(N) ：极端情况下排序块数量等于数组长度，此时 stackstack 占用线性大小额外空间。","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092832386","body":"4.8\n\n思路：递归\n\n终止条件：当前节点为null，或者下一个节点为 `null`\n函数内：将 2 指向 1，1 指向下一层的递归函数，最后返回节点 2\n\n```python\nclass Solution(object):\n\tdef swapPairs(self, head):\n\t\t# 递归的终止条件\n\t\tif not (head and head.next):\n\t\t\treturn head\n\t\t# 假设链表是 1->2->3->4\n\t\t# 这句就先保存节点2\n\t\ttmp = head.next\n\t\t# 继续递归，处理节点3->4\n\t\t# 当递归结束返回后，就变成了4->3\n\t\t# 于是head节点就指向了4，变成1->4->3\n\t\thead.next = self.swapPairs(tmp.next)\n\t\t# 将2节点指向1\n\t\ttmp.next = head\n\t\treturn tmp\n\n```\n\n空间复杂度 O(1)\n\n时间复杂度是 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093781861","body":"4.9\n\n思路：\n\n快慢指针起初都指向头结点，分别一次走两步和一步，当快指针走到尾节点时，慢指针正好走到链表的中间。断成两个链表，分而治之。\n\n代码：\n\n```python\n#快慢指针法\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow #保存slow前一个节点，因为链表没有前驱指针\n            slow = slow.next \n\n        if pre: #如果pre有值，则slow左边有节点\n            pre.next = None #切断pre\n            \n        node = TreeNode(slow.val) # 根据slow指向的节点值，构建节点\n\n        if slow == fast: #？？？\n            return node\n        node.left = self.sortedListToBST(head) #递归构建左子树\n        node.right = self.sortedListToBST(slow.next) #递归构建右子树\n        return node\n```\n\n复杂度：\n\n令 n 为链表长度。\n\n- 时间复杂度：递归树的深度为 lognlogn，每一层的基本操作数为 nn，因此总的时间复杂度为O(nlogn)O(nlogn)\n- 空间复杂度：空间复杂度为O(logn)O(logn)\n\n//存在疑问：应该是不了解递归树\n\n\n\n### 4.9小结\n\n1.知道了通过快慢指针找到中点和结尾\n\n2.我知道左子树小于节点，右子树大于节点，但代码中封装好了，NEXT：预习树\n\nnode.left = self.sortedListToBST(head)\n\nnode.right = self.sortedListToBST(slow.next)\n\n\\3. slow和fast没有变化，这句代码不可少，需要提问\n\n if slow == fast:\n\n​      return node\n\n \n\n4.python return?//函数当然有，怎么if里也有？\n\n5.？复杂度计算不太理解\n\n![计算机生成了可选文字: Python 函 数 可 以 返 回 多 种 类 型 的 值  与 其 他 编 程 语 言 不 同 ， python 函 数 不 限 于 返 回 单 一 类 型 的 值 。 如 果 您 昏  它 没 有 任 何 有 关 它 可 以 返 回 的 内 容 的 信 息 。  让 我 们 看 一 个 示 例 ， 其 中 函 数 将 返 回 多 种 类 型 的 值 。  def get_demo_data(object_type):  if ' s t r '  object_type ：  return 'test'  elif 'tuple'  object_type:  （ 1 ， 2 ， 3 ）  object_type:  [ 1 ， 2 ， 3 ]  object_type ：  None  return  elif ' 1 i s t '  return  elif ' d i c t '  return  else:  return ](file:///C:/Users/lx2019/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)\n\n \n\n「手画图解」三种解法逐个吃透 | 109. 有序链表转换二叉搜索树\n\n \n\n来自 <https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/shou-hua-tu-jie-san-chong-jie-fa-jie-zhu-shu-zu-ku/> \n\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094193165","body":"####  4.10\n\n思路：双指针\n\n- 使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动。\n- 当 a 到达链表 A 的尾部时，将它重定位到链表 B 的头节点；\n- 当 b 到达链表 B 的尾部时，将它重定位到链表 A 的头节点；\n- 若在此过程中 a, b 指针相遇，则相遇节点为两链表相交的起始节点，否则说明两个链表不存在相交点。\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a\n```\n\n- 时间复杂度：O(N）\n\n- 空间复杂度：O(1)\n\n  \n\n补充资料：\n\n- [空间复杂度](https://www.cnblogs.com/lonely-wolf/p/15674526.html#空间复杂度)\n\n对于算法的空间复杂度也可以简单的进行总结一下：\n\n- 如果申请的是有限个数（常量）的变量，空间复杂度为 `O(1)`。\n- 如果申请的是一维数组，队列或者链表等，那么空间复杂度为 `O(n)`。\n- 如果申请的是二维数组，那么空间复杂度为 `O(n²)`。\n- 如果是在循环体中申请的数组等，可能就需要取嵌套的乘积来作为空间复杂度，这种就需要具体的进一步分析。\n\n来自 <https://www.cnblogs.com/lonely-wolf/p/15674526.html> ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095067730","body":"4.11\n\n思路:\n\n1. 定义一个 fast 指针,每次**前进两步**,一个 slow 指针,每次**前进一步**\n2. 当两个指针相遇时\n   1. 将 fast 指针**重定位**到链表头部,同时 fast 指针每次只**前进一步**\n   2. slow 指针继续前进,每次**前进一步**\n3. 当两个指针再次相遇时,当前节点就是环的入口\n\n代码：\n\n```python\n#快慢指针法\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087203278","body":"```go\r\nfunc decodeString(s string) (res string) {\r\n\tvar stack []string\r\n\tgetDigits := func(ptr *int) (ret string) {\r\n\t\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n\t\t\tret += string(s[*ptr])\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tgetStrings := func(strs []string) (ret string) {\r\n\t\tfor _, str := range strs {\r\n\t\t\tret += str\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tptr := 0\r\n\tfor ptr < len(s) {\r\n\t\tchr := s[ptr]\r\n\t\tif chr >= '0' && chr <= '9' {\r\n\t\t\tdigits := getDigits(&ptr)\r\n\t\t\tstack = append(stack, digits)\r\n\t\t} else if chr >= 'a' && chr <= 'z' || chr == '[' {\r\n\t\t\tstack = append(stack, string(chr))\r\n\t\t\tptr++\r\n\t\t} else {\r\n\t\t\tptr++\r\n\t\t\tvar sub []string\r\n\t\t\tfor stack[len(stack)-1] != \"[\" {\r\n\t\t\t\tsub = append(sub, stack[len(stack)-1])\r\n\t\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\t}\r\n\t\t\tn := len(sub)\r\n\t\t\tfor i := 0; i < n/2; i++ {\r\n\t\t\t\tsub[i], sub[n-i-1] = sub[n-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\trepTimes, _ := strconv.Atoi(stack[len(stack)-1])\r\n\t\t\tstack = stack[:len(stack)-1]\r\n\t\t\tst := strings.Repeat(getStrings(sub), repTimes)\r\n\t\t\tstack =append(stack, st)\r\n\t\t}\r\n\t}\r\n\tres = getStrings(stack)\r\n\treturn\r\n}\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maybetoffee":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/5#issuecomment-1087276903","body":"思路：需要从里到外获得substring和substring对应的次数，符合栈先进后出的特点。为什么需要讲左括号也推进去？因为我们压栈遇到右括号的时候就说明一个substring已经结束，可以弹出了，什么时候结束弹出？就是遇到左括号的时候。弹完substring之后，在弹出一次栈顶，就是将左括号弹出，然后如果当前栈顶是数字，那就是substring对应的次数。\npublic String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()){\n            if(c != ']'){\n                stack.push(c);\n            }else{\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek()!='['){\n                    sb.insert(0,stack.pop());\n                }\n                String sub = sb.toString();//one of the subStr need to be multiplied\n                stack.pop();//should be a [\n                sb = new StringBuilder();//clean current sb\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    sb.insert(0, stack.pop());\n                }    \n                int count = Integer.parseInt(sb.toString());\n                while(count != 0){\n                    for(char elem: sub.toCharArray()){\n                        stack.push(elem);\n                    }\n                    count--;\n                }\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty()){\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1087917880","body":"class MyStack {\n    private Queue<Integer> q;\n    private int top_elem;\n\n    public MyStack() {\n        q = new LinkedList<>();\n        top_elem = 0; \n    }\n    \n    public void push(int x) {\n        q.offer(x);\n        top_elem = x;\n    }\n    \n    public int pop() {\n        int size = q.size();\n        while(size > 2){\n            q.offer(q.poll());\n            size--;\n        }\n        top_elem = q.peek();\n        q.offer(q.poll());\n        return q.poll();\n    }\n    \n    public int top() {\n        return top_elem;\n    }\n    \n    public boolean empty() {\n        return q.isEmpty();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089328600","body":"```\npublic int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int num : arr){\n            if(!stack.isEmpty() && num < stack.peek()){\n                int chunkMax = stack.pop();\n                while(!stack.isEmpty() && num < stack.peek()){\n                    stack.pop();\n                }\n                stack.push(chunkMax);\n            }else{\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090440293","body":"今天才做过\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || k == 0){\r\n            return head;\r\n        }\r\n        int n = calculeLength(head);\r\n        k = k%n;\r\n        \r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n       \r\n        for(int i = 0; i < k; i++){\r\n            fast = fast.next;\r\n        }\r\n        \r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        \r\n        fast.next = head;\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        return newHead;\r\n    }\r\n    \r\n    private int calculeLength(ListNode head){\r\n        int count = 0;\r\n        while(head != null){\r\n            head = head.next;\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092090649","body":"``` \npublic ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode curr = dummy;\n    \n        while(curr.next != null && curr.next.next != null){\n            ListNode p1 = curr.next;\n            ListNode p2 = curr.next.next;\n            p1.next = p2.next;\n            curr.next = p2;\n            p2.next = p1;\n            curr = curr.next.next;\n        }\n        return dummy.next;\n    }\n````\n注意reference即可","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093472369","body":"双指针找终点\n```\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    //[start, end) \n    TreeNode build(ListNode start, ListNode end){\n        if(start == end){\n            return null;\n        }\n        \n        ListNode mid = findMid(start, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(start, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    //two pointers\n    ListNode findMid(ListNode start, ListNode end){\n        ListNode slow = start, fast = start;\n        while (fast != end && fast.next != end){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094126350","body":"```\n\rpublic int[] intersection(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int[] res = new int[nums1.length];\n        int p1 = 0;\n        int p2 = 0;\n        int index = 0;\n        \n        while(p1 < nums1.length && p2<nums2.length){\n            if(nums1[p1] == nums2[p2]){\n                if(index ==0 || nums1[p1] != res[index-1]){\n                    res[index] = nums1[p1];\n                    index++;\n                }\n                p1++;\n                p2++;\n            }else if(nums1[p1] < nums2[p2]){\n                p1++;\n            }else{\n                p2++;\n            }\n        }\n        int[] result = new int[index];\n        for(int i = 0; i< index; i++){\n            result[i] = res[i];\n        }\n        return result;       \n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094372461","body":"```\npublic ListNode detectCycle(ListNode head) {\n        ListNode fast = head, slow = head;\n        \n        while(fast != null && fast.next != null){\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast){\n                break; //found the meet position\n            }\n        }\n        if(fast == null || fast.next == null) return null;\n        \n        fast = head;\n        while(slow != fast){\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088086201","body":"用两个stack\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            else:\r\n                return -1\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            else:\r\n                return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\nTime: O(1)\r\n\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089134263","body":"这道题一直不太会做，今天看人家辅助栈解法一下就懂了。对于每一个chunk，重点是我们需要知道每个chunk 的最大值(local maximum) ，所以最后的答案是辅助栈的长度。我们要围护一个non-strict decreasing stack， 所以只有在小于栈顶才pop。\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # the length of the stack is the answer we want \r\n        # non-strict decreasing stack\r\n        stack = []\r\n        for i,v in enumerate(arr):\r\n            if stack:\r\n                ## larger or equal to is OK\r\n                if v < stack[-1]:\r\n\r\n                    # this is important, this denotes the max of the curr chunk\r\n                    # we need the local maximum of each chunk\r\n                    # so incoming elements can do the same procedure by comparing with the local maximum\r\n                    head = stack.pop() \r\n\r\n                    ## we need to group this chunk\r\n                    while stack and v < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(head)\r\n                else:\r\n                    stack.append(v)\r\n\r\n            else:\r\n                stack.append(v)\r\n        return len(stack)\r\n```\r\n时间 O(n)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090597514","body":"算是比较经典的一道题目：主要考察快慢指针。思路：先算链表长度，然乎对k做mudolo，然后把倒数第k个节点搬到第一个去就行\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n\r\n        cnt = 0\r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            cnt += 1\r\n        \r\n        k = k % cnt\r\n        if k == 0:\r\n            return head\r\n        prev = None\r\n        fast = slow = head\r\n        while k > 1:\r\n            fast = fast.next\r\n            k -=1\r\n        while fast and fast.next:\r\n            fast = fast.next\r\n            prev = slow\r\n            slow = slow.next\r\n        \r\n        prev.next = None\r\n        fast.next = head\r\n        return slow\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092264296","body":"没啥套路，就考虑两两节点如何swap，需要使用sentinel node 记录返回值\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        prev = ans = ListNode(0)\r\n        left = head\r\n        right = head.next\r\n        while left and right:\r\n            nextLeft = right.next \r\n            prev.next = right\r\n            right.next = left\r\n            left.next = nextLeft\r\n\r\n            prev = left\r\n            left = nextLeft\r\n            if left:\r\n                right = left.next\r\n\r\n        return ans.next\r\n\r\n```\r\n时间 O(n)\r\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fhuang5":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088158191","body":"(Java). Used helper function to avoid repeated code. O(1) amortized time and O(1) auxiliary space.\n```\nclass MyQueue {\n    \n    private Stack<Integer> pushStack = new Stack<Integer>();\n    private Stack<Integer> popStack = new Stack<Integer>();\n    \n    private void updatePopStack() {\n        if(popStack.isEmpty()) {\n            while(!pushStack.isEmpty()){\n                popStack.push(pushStack.pop());\n            }\n        }\n    }\n\n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        updatePopStack();\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        updatePopStack();\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return ( popStack.isEmpty() && pushStack.isEmpty() );\n        \n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089450902","body":"Key invariant: In each chunk, every element must greater than or equal to the maximum of the previous chunk.\n\nI kept a stack storing the maximums of each chunk so far. Each new element starts out in its own chunk, then adjacent chunks are unioned together from right to left (via popping off of the stack and updating the maximum) until the above invariant is satisfied. \n\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> maxInChunks = new Stack<Integer>();\n        for (int x: arr) {\n            int newMax = x;\n            while (!maxInChunks.isEmpty() && maxInChunks.peek() > x) {\n                newMax = Math.max(newMax, maxInChunks.pop());\n            }\n            maxInChunks.push(newMax);\n        }\n        return maxInChunks.size();\n    }\n}\n```\nTime complexity: O(n), since at most n-1 unions will take place\n\nAuxiliary space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090884355","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        ListNode cur = head;\n        int count = 1;\n        while (cur.next != null){\n            cur = cur.next;\n            count++;\n        }\n        cur.next = head;\n        for (int i = 1; i <= count - (k % count); i++){\n            cur = cur.next;\n        }\n        ListNode newHead = cur.next;\n        cur.next = null; \n        return newHead;              \n    }\n}\n```\nTime Complexity: O(n)\\\nSpace Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092317701","body":"```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode secondNode = head.next;\n        ListNode subResult = swapPairs(secondNode.next);\n        secondNode.next = head;\n        head.next = subResult;\n        \n        return secondNode;\n        \n    }\n}\n\n#Time Complexity: O(n), where n is the number of nodes\n#Space Complexity: O(n/2) on the call stack\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1093759747","body":"```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n        int count = 0;\n        ListNode cur = head;\n        while (cur!= null){\n            cur = cur.next;\n            count++;\n        }\n        cur = head;\n        for (int i = 0; i< count/2-1; i++){\n            cur = cur.next;\n        }\n        TreeNode root = new TreeNode(cur.next.val);\n        root.right= sortedListToBST(cur.next.next);\n        cur.next = null;\n        root.left = sortedListToBST(head);\n        return root;     \n        \n    }\n}\n\n//TC: O(N logN) where N is the length of the linked list.\n//SC: O(Log N) on call stack, and O(N) on the heap.\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088190548","body":"```python\r\nclass MyQueue(object):\r\n\r\n    \"\"\"\r\n    Queue is fifo stack is lifo\r\n    \r\n    [1, 2, 3]\r\n    [3, 2, 1]\r\n    \r\n    [4] -> push\r\n    [3,2,1] -> peak and pop\r\n    if not queue:\r\n        push elem from first stack to sec\r\n    else:\r\n        pop or peek from the other    \r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.pushStack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        return self.popStack.pop()\r\n            \r\n            \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        print(self.pushStack)\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        print(self.popStack)\r\n        return self.popStack[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.pushStack) == 0 and len(self.popStack) == 0\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088280937","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stackpush = []\n        self.stackpop = []\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stackpush.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while not self.stackpop:\n            while self.stackpush:\n                self.stackpop.append(self.stackpush.pop())\n        return self.stackpop.pop()\n            \n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while self.stackpop:\n            self.stackpush.append(self.stackpop.pop())\n        return self.stackpush[0]\n    \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not(bool(self.stackpop) or bool(self.stackpush))\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092586336","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = ListNode(next = head)\r\n        cur = head\r\n        while cur and cur.next:\r\n            cur_val = cur.val\r\n            cur.val = cur.next.val\r\n            cur.next.val = cur_val\r\n            cur = cur.next.next\r\n\r\n        return dummy.next\r\n```\r\n\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088371802","body":"```cpp\n// 4-5 cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    stack<int> stIn;\n    stack<int> stOut;\n\n    MyQueue() {\n\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (stOut.empty()) {\n            while(!stIn.empty()) {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        int res = this->pop();\n        stOut.push(res);\n        return res;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094294097","body":"```cpp\n// 4-10 cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n\n        int lenA = 0;\n        int lenB = 0;\n\n        while (curA != NULL) {\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) {\n            lenB++;\n            curB = curB->next;\n        }\n\n        curA = headA;\n        curB = headB;\n        if (lenB > lenA) {\n            swap(curB, curA);\n            swap(lenB, lenA);\n        }\n        int gap = lenA - lenB;\n        while (gap--) {\n            curA = curA->next;\n        }\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zuoduozhongguo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088712753","body":"# 思路\r\n\r\n用列表来作为栈的存储空间，先入栈，后出栈入第二个栈，当需要输出时再从第二个栈输出，即可实现队列功能\r\n\r\n# 代码\r\n\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.b:\r\n            self.a.append(self.b.pop())\r\n        self.a.append(x)\r\n        while self.a:\r\n            self.b.append(self.a.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.b[-1] \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.b) == 0\r\n```\r\n\r\n# 复杂度\r\n时间：O(1)，空间：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094302359","body":"## 20220410 打卡\r\n## 思路\r\n双指针分别遍历两个链表，相同则返回，遍历到底则指向另一个链表的头结点\r\n\r\n## 代码\r\n```Python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headB or not headA:\r\n            return None\r\n        \r\n        p = headA\r\n        q = headB\r\n        while p!=q:\r\n            p = p.next if p else headB\r\n            q = q.next if q else headA\r\n        return p\r\n```\r\n\r\n## 复杂度\r\n时间：O(m+n) , 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bey11-h":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088779331","body":"class MyQueue {\n    Stack<Integer> stack1 = new Stack<>();\n    Stack<Integer> stack2 = new Stack<>();\n    int front;\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        if (stack1.isEmpty()) {\n            front = x;\n        }\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        stack2.push(x);\n        while(!stack2.isEmpty()){\n            stack1.push(stack2.pop());\n        }\n    }\n    \n    public int pop() {\n        int top = stack1.pop();\n        if (!stack1.isEmpty()){\n            front = stack1.peek();\n        }\n        return top;\n    }\n    \n    public int peek() {\n        return front;\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aibotao":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088859289","body":"class MyQueue {\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new ArrayDeque<>();\n        stackOut = new ArrayDeque<>();\n    }\n\n    //push时检查out栈里是否为空，否则倒到in栈里再进行push\n    public void push(int x) {\n        while(stackOut.size()>=1){\n            stackIn.addFirst(stackOut.removeFirst());\n        }\n        stackIn.addFirst(x);\n    }\n    \n    //pop同理\n    public int pop() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.removeFirst();\n        return res;\n    }\n    \n    public int peek() {\n        while(stackIn.size()>=1){\n            stackOut.addFirst(stackIn.removeFirst());\n        }\n        int res = stackOut.getFirst();\n        return res;\n    }\n    \n    public boolean empty() {\n        return stackIn.size()==0 && stackOut.size()==0;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dqhe":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/6#issuecomment-1088948032","body":"# 思路\n将第一个栈的数字倒入第二个栈\n\n# 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_push=[]\n        self.stack_pop=[]\n\n    def push(self, x: int) -> None:\n        self.stack_push.append(x)\n\n    def pop(self) -> int:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop.pop()\n\n    def peek(self) -> int:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return self.stack_pop[-1]\n\n    def empty(self) -> bool:\n        while self.stack_push:\n            self.stack_pop.append(self.stack_push.pop())\n        return not bool(self.stack_pop)\n```\n# 复杂度分析\n\n时间复杂度O(N)\n空间复杂度O(N)","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1095106256","body":"# 思路\n快慢指针法\n\n# 代码\n```python\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        x = None\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                x = fast\n                break\n        if not x:\n            return None\n        slow = head\n        while slow != x:\n            slow = slow.next\n            x = x.next\n        return slow\n```\n# 复杂度分析\n时间复杂度 O(N)\n空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1089725657","body":"\r\n\r\n### 思路\r\n辅助栈牛逼\r\n\r\n### 代码\r\n\r\n```class Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094029871","body":"```\nclass Solution:\n    def __init__(self):\n        self.head = None\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        n, self.head = 0, head\n        while head:\n            head = head.next\n            n += 1\n        return self.to_bst(0, n - 1)\n    def to_bst(self, left, right):\n        if left > right: return\n        m = (left + right) // 2\n        left_child = self.to_bst(left, m - 1)\n        father = TreeNode(self.head.val)\n        self.head = self.head.next\n        father.left = left_child\n        father.right = self.to_bst(m + 1, right)\n        return father\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vuesch":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090208804","body":"## 代码\n```js\nvar maxChunksToSorted = function (arr) {\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    a = arr[i];\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\n      const cur = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > a) stack.pop();\n      stack.push(cur);\n    } else {\n      stack.push(a);\n    }\n  }\n  return stack.length;\n};\n\n```\n## 复杂度分析\n\n时间复杂度：O(N)O(N)，其中 N 为数组长度。\n\n空间复杂度：O(N)O(N)，其中 N 为数组长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090291824","body":"/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  const stack = []\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\r\n      stack.push(arr[i])\r\n    } else {\r\n      const cur = stack.pop()\r\n      while(stack[stack.length - 1] > arr[i]) {\r\n        stack.pop()\r\n      }\r\n      stack.push(cur)\r\n    }\r\n  }\r\n  return stack.length\r\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094200547","body":"## 思路\r\n双指针，两个指针分别从A、B以相同速度出发，当某个指针走到尾后，将其指向另一个链表的头，继续走。当两个指针碰头时，就是相交点\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n\r\n    while (a && b) {\r\n      if (a === b) return a\r\n      a = a.next\r\n      b = b.next\r\n\r\n      if (!a) {\r\n        a = headB\r\n      }\r\n      if (!b) {\r\n        b = headA\r\n      }\r\n    }\r\n    return null\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(m+n)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nealchristmas":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/7#issuecomment-1090304858","body":"```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    let currMax = arr[0]\r\n    const stack = [currMax]\r\n    for (let i = 1; i < arr.length; i++) {\r\n        if (arr[i] >= stack[stack.length - 1]) {\r\n            currMax = Math.max(currMax, arr[i])\r\n            stack.push(arr[i])\r\n\r\n        } else {\r\n            while (stack.length && arr[i] < stack[stack.length - 1]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(currMax)\r\n        }\r\n\r\n    }\r\n    return stack.length\r\n\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1090880462","body":"```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head == None or head.next == None:\n            return head\n        lenth = 1\n        pt = head\n        while pt.next != None:\n            pt = pt.next\n            lenth += 1\n        old_tail = pt\n        true_k = k % lenth\n        if true_k == 0: return head\n        num_to_move = lenth - true_k\n        cur = head\n        while num_to_move - 1:\n            cur = cur.next\n            num_to_move -= 1\n        new_tail = cur\n        new_head = cur.next\n        old_tail.next = head\n        new_tail.next = None\n        return new_head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzq-666":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091735334","body":"class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        index = 0 \n        node = head\n        head = head\n        test = head\n        l = 0\n        if k == 0 or not head or not head.next:\n            return head\n        while test:\n            test = test.next\n            l += 1\n        k = k%l\n        while index <k:\n            flag  = node.next.next\n            if flag:\n                node = node.next\n                continue\n            else:\n                i = node.next\n                node.next = None\n                i.next = head\n                head = i\n                node  = head\n            index += 1\n        return head","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091817844","body":"### **思路**\n\n先计算链表的长度，记为cnt，k对链表长度取余是要旋转的次数，旋转几次，就是倒数第几个链表拆出来作为头，相当于找到要旋转断开的地方，拆成两个链表，把后面的链表拼到前面的链表上，后面链表指向头，前面链表指向None\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next:\n            cut += 1\n            if cut == cnt - k:\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n        return res if res else head\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weihaoxie":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/8#issuecomment-1091852920","body":"## 解题思路：\n先将链表连接成循环链表，并计算链表长度，然后将头指针往前移动链表长度-k%链表长度\n## 复杂度\n时间复杂度为O(N)\n## 实现\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        curNode = head\n        count = 1\n        while(curNode.next is not None):\n            curNode = curNode.next\n            count+=1\n        curNode.next = head\n        headNode = head\n        curNode = head\n        i = 0\n        while(i<count-k%count):\n            preNode = curNode\n            curNode = curNode.next\n            i+=1\n        preNode.next = None\n        return curNode\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/9#issuecomment-1092323168","body":"## 思路\n1. 按照朴素的思路，交换两个节点后连接回原来链表\n2. 按照该方式交换后续的节点\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head is None or head.next is None:\n            return head\n        new_head = head.next\n        curNode = head\n        nextNode = new_head.next\n        curNode.next = nextNode\n        new_head.next = curNode\n        head = new_head\n\n        while( nextNode is not None and nextNode.next is not None):\n            new_head = nextNode.next\n            curNode.next = new_head\n            curNode = nextNode\n            nextNode = new_head.next\n            curNode.next = nextNode\n            new_head.next = curNode\n  \n        return head\n```\n## 复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/11#issuecomment-1094069157","body":"## 思路\n1. 用快慢指针找到中间节点\n2. 递归左右两部分\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getRootNode(self,head,tail):\n        if head is None :\n            return None\n        if head.next is None:\n            return TreeNode(head.val)\n        if head == tail:\n            return TreeNode(head.val)\n        premid = head\n        mid = head.next\n        if mid == tail:\n            t =tail\n        else:\n            t = mid.next\n        while(t != tail and t.next!=tail):\n            t = t.next.next\n            premid = mid\n            mid = mid.next\n        if mid == tail:\n            aftermid = None\n        else:\n            aftermid = mid.next\n        return TreeNode(mid.val,self.getRootNode(head,premid),self.getRootNode(aftermid,tail))\n        \n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if head is None:\n            return None\n        if head.next is None:\n            return TreeNode(head.val)\n        premid = head\n        mid = head.next\n        tail = mid.next\n        aftermid = tail\n        while(tail is not None and tail.next is not None):\n            tail = tail.next.next\n            premid = mid\n            mid = mid.next\n                \n        aftermid = mid.next\n        return TreeNode(mid.val,self.getRootNode(head,premid),self.getRootNode(aftermid,tail))\n```\n## 复杂度\n时间复杂度为O(nlogn)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094169477","body":"## 思路\n- 遍历链表将节点放到两个list中\n- 从后到前比对list中的节点\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        lista = []\n        listb = []\n        cur1 = headA\n        cur2 = headB\n        while(cur1 is not None):\n            lista.append(cur1)\n            cur1=cur1.next\n        while(cur2 is not None):\n            listb.append(cur2)\n            cur2=cur2.next\n        rhead = None\n        for i in range(min(len(lista),len(listb))):\n            if lista[len(lista)-1-i] == listb[len(listb)-1-i]:\n                rhead = lista[len(lista)-1-i]\n        return rhead\n```\n## 复杂度\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/13#issuecomment-1094510867","body":"### 思路\n1. 先用快慢指针判断是否存在环\n2. 判断环的起点（假设head到环的起点距离为a，环的起点到相遇点为b，相遇点到环的起点为c，则有2a+2b=a+b+c+b，那么a=c，将其中一个指针放到head每次走一步相遇时的节点就是入口）\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = head\n        fast = head\n        while(fast is not None and fast.next is not None):\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                fast = head\n                while(fast!=slow):\n                    fast = fast.next\n                    slow = slow.next\n                return slow\n        return None\n```\n### 复杂度\n- 时间复杂度O(n)\n- 空间复杂度为O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-7-daily-check/issues/12#issuecomment-1094242148","body":"### 代码\r\n```python\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        cur = headA\r\n        visited = {}\r\n        while cur:\r\n            visited[id(cur)] = cur\r\n            cur = cur.next\r\n        \r\n        cur = headB\r\n        while cur:\r\n            if id(cur) in visited:\r\n                return visited[id(cur)]\r\n            cur = cur.next\r\n        return None\r\n\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}